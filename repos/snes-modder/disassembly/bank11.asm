.BANK 11 SLOT 0
.ORG $0000

.SECTION "Bank11" FORCE

	cpx $FF.b		; E4 FF ; Compare $FF.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $00, $00		; 62 00 00 ; Push effective relative address $62, $00, $00 [Writes: Stack Pointer]
	brk $65.b		; 00 65 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $62.b,S		; 03 62 ; OR accumulator with stack relative $62.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $65.b		; 06 65 ; Arithmetic shift left $65.b [Reads: Direct Page] [Flags: NCZ]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	ora #$62.b		; 09 62 ; Logical OR #$62.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $0202.w		; 0C 02 02 ; Test and set bits $0202.w [Reads: Accumulator] [Flags: Z]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $0F, $62		; 62 0F 62 ; Push effective relative address $62, $0F, $62 [Writes: Stack Pointer]
	ora $080083.l		; 0F 83 00 08 ; OR accumulator with memory (long) $080083.l [Writes: Accumulator] [Flags: NZ]
	.db $62, $12, $01		; 62 12 01 ; Push effective relative address $62, $12, $01 [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora #$63.b		; 09 63 ; Logical OR #$63.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $62.b,X		; 15 62 ; OR accumulator with memory $62.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	asl $84.b,X		; 16 84 ; Arithmetic shift left $84.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $19.b		; 02 19 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $1A.b,S		; 63 1A ; Add with carry (stack relative) $1A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	adc $1D.b,S		; 63 1D ; Add with carry (stack relative) $1D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	.db $10, $6A		; 10 6A ; Branch if plus to $10, $6A [Flow: branch]
	and ($02.b,X)		; 21 02 ; Logical AND ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and [$07.b]		; 27 07 ; AND accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	adc $2C.b,S		; 63 2C ; Add with carry (stack relative) $2C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cop $0D.b		; 02 0D ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $09		; 30 09 ; Branch if minus to $30, $09 [Flow: branch]
	stz $31.b		; 64 31 ; Store zero to $31.b
	ora $13.b,S		; 03 13 ; OR accumulator with stack relative $13.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($00.b)		; 32 00 ; AND accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $65.b,S		; 03 65 ; OR accumulator with stack relative $65.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $02.b,X		; 36 02 ; Rotate left $02.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	and $323C.w		; 2D 3C 32 ; Logical AND $323C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	stz $3D.b		; 64 3D ; Store zero to $3D.b
	ora $09.b,S		; 03 09 ; OR accumulator with stack relative $09.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $2942.w		; 0C 42 29 ; Test and set bits $2942.w [Reads: Accumulator] [Flags: Z]
	adc $43.b,S		; 63 43 ; Add with carry (stack relative) $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cop $37.b		; 02 37 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor [$32.b]		; 47 32 ; Exclusive OR accumulator with memory (long) [$32.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $48.b,S		; 63 48 ; Add with carry (stack relative) $48.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora #$41.b		; 09 41 ; Logical OR #$41.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$35.b]		; 07 35 ; OR accumulator with memory (long) [$35.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($4C.b,S),Y		; 13 4C ; OR accumulator (stack relative indirect indexed) ($4C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $4E29.w		; 4D 29 4E ; Exclusive OR $4E29.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $6220.w,X		; 1D 20 62 ; OR accumulator with memory $6220.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $523406.l		; 4F 06 34 52 ; Exclusive OR accumulator with memory (long) $523406.l [Writes: Accumulator] [Flags: NZ]
	eor ($32.b,S),Y		; 53 32 ; XOR accumulator (stack relative indirect indexed) ($32.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	adc $54.b,S		; 63 54 ; Add with carry (stack relative) $54.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	trb $1D20.w		; 1C 20 1D ; Test and reset bits $1D20.w [Reads: Accumulator] [Flags: Z]
	ora $5958.w,X		; 1D 58 59 ; OR accumulator with memory $5958.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $36.b,S		; 03 36 ; OR accumulator with stack relative $36.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $50, $09		; 50 09 ; Branch if overflow clear to $50, $09 [Flow: branch]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	stz $5A.b		; 64 5A ; Store zero to $5A.b
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	and [$5F.b]		; 27 5F ; AND accumulator with memory (long) [$5F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc ($09.b,X)		; 61 09 ; Add with carry ($09.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $62.b,X		; 15 62 ; OR accumulator with memory $62.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	jsr $0807.w		; 20 07 08 ; Jump to subroutine at $0807.w [Writes: Stack Pointer] [Flow: call]
	eor ($63.b,S),Y		; 53 63 ; XOR accumulator (stack relative indirect indexed) ($63.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $0B.b,S		; 63 0B ; Add with carry (stack relative) $0B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	and ($3D.b)		; 32 3D ; AND accumulator with memory (indirect) ($3D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $35.b,X		; 34 35 ; Test bits $35.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	adc [$1A.b]		; 67 1A ; Add with carry (long) [$1A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	adc #$1D.b		; 69 1D ; Add #$1D.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	adc $6A.b,S		; 63 6A ; Add with carry (stack relative) $6A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	tsb $41.b		; 04 41 ; Test and set bits $41.b [Reads: Accumulator] [Flags: Z]
	ror $3F3E.w		; 6E 3E 3F ; Rotate right $3F3E.w [Flags: NCZ]
	cop $63.b		; 02 63 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $0A0907.l		; 6F 07 09 0A ; Add with carry (long) $0A0907.l [Writes: Accumulator] [Flags: NCVZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc ($74.b,S),Y		; 73 74 ; Add with carry (stack relative indirect indexed) ($74.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	eor ($62.b,X)		; 41 62 ; Exclusive OR accumulator with memory ($62.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	ora [$0B.b],Y		; 17 0B ; OR accumulator with memory (long indexed) [$0B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora #$75.b		; 09 75 ; Logical OR #$75.b with accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $071D.w		; 20 1D 07 ; Jump to subroutine at $071D.w [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ror $77.b,X		; 76 77 ; Rotate right $77.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	and $3737.w,Y		; 39 37 37 ; AND accumulator with memory $3737.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $50, $78		; 50 78 ; Branch if overflow clear to $50, $78 [Flow: branch]
	adc $7A05.w,Y		; 79 05 7A ; Add $7A05.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$7B.b]		; 07 7B ; OR accumulator with memory (long) [$7B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jmp ($001D.w,X)		; 7C 1D 00 ; Jump indirect indexed to ($001D.w,X) [Reads: X Index] [Flow: jump]
	ora $7D.b,S		; 03 7D ; OR accumulator with stack relative $7D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $1D.b		; 25 1D ; Logical AND $1D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $7E.b		; 06 7E ; Arithmetic shift left $7E.b [Reads: Direct Page] [Flags: NCZ]
	asl $0002.w		; 0E 02 00 ; Arithmetic shift left $0002.w [Flags: NCZ]
	ora ($7F.b,X)		; 01 7F ; Logical OR ($7F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $E4FF.w,X		; 1D FF E4 ; OR accumulator with memory $E4FF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $62FF00.l,X		; FF 00 FF 62 ; Subtract with carry (long,X) $62FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $62.b		; 06 62 ; Arithmetic shift left $62.b [Reads: Direct Page] [Flags: NCZ]
	asl $04.b		; 06 04 ; Arithmetic shift left $04.b [Reads: Direct Page] [Flags: NCZ]
	eor ($80.b,S),Y		; 53 80 ; XOR accumulator (stack relative indirect indexed) ($80.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta ($3B.b,X)		; 81 3B ; Store accumulator ($3B.b,X) [Reads: Direct Page, Accumulator, X Index]
	.db $82, $83, $00		; 82 83 00 ; Branch always long to $82, $83, $00 [Flow: branch]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0F.b		; 06 0F ; Arithmetic shift left $0F.b [Reads: Direct Page] [Flags: NCZ]
	.db $10, $3F		; 10 3F ; Branch if plus to $10, $3F [Flow: branch]
	sta $84.b,S		; 83 84 ; Store accumulator (stack relative) $84.b,S [Reads: Stack Pointer, Accumulator]
	ora ($64.b),Y		; 11 64 ; OR accumulator with memory ($64.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $01.b		; 85 01 ; Store accumulator to $01.b [Reads: Accumulator]
	and $006202.l,X		; 3F 02 62 00 ; AND accumulator with memory (long,X) $006202.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cop $8A.b		; 02 8A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $62, $8C, $06		; 62 8C 06 ; Push effective relative address $62, $8C, $06 [Writes: Stack Pointer]
	ora $908F.w,X		; 1D 8F 90 ; OR accumulator with memory $908F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $9291.w,X		; 1D 91 92 ; OR accumulator with memory $9291.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	.db $62, $09, $01		; 62 09 01 ; Push effective relative address $62, $09, $01 [Writes: Stack Pointer]
	ror $6634.w,X		; 7E 34 66 ; Rotate right $6634.w,X [Reads: X Index] [Flags: NCZ]
	sta ($01.b,S),Y		; 93 01 ; Store accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	ora $631F.w,X		; 1D 1F 63 ; OR accumulator with memory $631F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	stz $0159.w,X		; 9E 59 01 ; Store zero to $0159.w,X [Reads: X Index]
	adc $1D9F9F.l,X		; 7F 9F 9F 1D ; Add long $1D9F9F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $9F66.w,X		; 1D 66 9F ; OR accumulator with memory $9F66.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $9F.b,S		; 03 9F ; OR accumulator with stack relative $9F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldx $09.b		; A6 09 ; Load $09.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $62, $A7, $01		; 62 A7 01 ; Push effective relative address $62, $A7, $01 [Writes: Stack Pointer]
	sta [$98.b],Y		; 97 98 ; Store accumulator (long indexed) [$98.b],Y [Reads: Direct Page, Y Index, Accumulator]
	adc $AA.b,S		; 63 AA ; Add with carry (stack relative) $AA.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora ($1F.b,X)		; 01 1F ; Logical OR ($1F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $02AE62.l,X		; 1F 62 AE 02 ; Logical OR long $02AE62.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $82, $08, $76		; 82 08 76 ; Branch always long to $82, $08, $76 [Flow: branch]
	.db $62, $B1, $00		; 62 B1 00 ; Push effective relative address $62, $B1, $00 [Writes: Stack Pointer]
	ora $B466.w,X		; 1D 66 B4 ; OR accumulator with memory $B466.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora #$BB.b		; 09 BB ; Logical OR #$BB.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ldy $BD11.w,X		; BC 11 BD ; Load Y register $BD11.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ora $BFBE.w,X		; 1D BE BF ; OR accumulator with memory $BFBE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	trb $C1C0.w		; 1C C0 C1 ; Test and reset bits $C1C0.w [Reads: Accumulator] [Flags: Z]
	.db $62, $09, $05		; 62 09 05 ; Push effective relative address $62, $09, $05 [Writes: Stack Pointer]
	ora #$C2.b		; 09 C2 ; Logical OR #$C2.b with accumulator [Writes: Accumulator] [Flags: NZ]
	and $C4C3.w		; 2D C3 C4 ; Logical AND $C4C3.w with accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	stz $C5.b		; 64 C5 ; Store zero to $C5.b
	tsb $12.b		; 04 12 ; Test and set bits $12.b [Reads: Accumulator] [Flags: Z]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $CB64.w		; 2C 64 CB ; Test bits $CB64.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	ora #$A5.b		; 09 A5 ; Logical OR #$A5.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $1DD0.w,X		; 1D D0 1D ; OR accumulator with memory $1DD0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda $D1.b,X		; B5 D1 ; Load $D1.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $D2, $00		; 62 D2 00 ; Push effective relative address $62, $D2, $00 [Writes: Stack Pointer]
	cop $62.b		; 02 62 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $00.b,X		; D5 00 ; Compare accumulator $00.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	and [$62.b]		; 27 62 ; AND accumulator with memory (long) [$62.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	asl $15.b,X		; 16 15 ; Arithmetic shift left $15.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	jmp.w [$0B14]		; DC 14 0B ; Jump long indirect [$0B14] [Flow: jump]
	cmp $7EDE.w,X		; DD DE 7E ; Compare accumulator $7EDE.w,X [Reads: X Index] [Flags: NCZ]
	eor ($DF.b,X)		; 41 DF ; Exclusive OR accumulator with memory ($DF.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $82, $08, $2C		; 82 08 2C ; Branch always long to $82, $08, $2C [Flow: branch]
	wai		; CB ; Wait for interrupt
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	cpx #$DC.b		; E0 DC ; Compare #$DC.b with X register [Reads: X Index] [Flags: NCZ]
	ora $7A.b		; 05 7A ; Logical OR $7A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc ($1D.b,X)		; E1 1D ; Subtract with carry ($1D.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	lda ($05.b)		; B2 05 ; Load accumulator (indirect) ($05.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
.ACCU 8
	sep #$E3		; E2 E3
	ora $E4.b,S		; 03 E4 ; OR accumulator with stack relative $E4.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $62.b		; E5 62 ; Subtract $62.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $62, $E6, $0D		; 62 E6 0D ; Push effective relative address $62, $E6, $0D [Writes: Stack Pointer]
	cop $E6.b		; 02 E6 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc #$EA.b		; E9 EA ; Subtract #$EA.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	eor ($DF.b,X)		; 41 DF ; Exclusive OR accumulator with memory ($DF.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cpx $1509.w		; EC 09 15 ; Compare $1509.w with X register [Reads: X Index] [Flags: NCZ]
	.db $62, $B2, $C0		; 62 B2 C0 ; Push effective relative address $62, $B2, $C0 [Writes: Stack Pointer]
	sbc $0962.w		; ED 62 09 ; Subtract $0962.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ora $EE.b,S		; 03 EE ; OR accumulator with stack relative $EE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora #$EF.b		; 09 EF ; Logical OR #$EF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	stx $62.b		; 86 62 ; Store X register to $62.b [Reads: X Index]
	.db $F0, $0C		; F0 0C ; Branch if equal to $F0, $0C [Flow: branch]
	and $1D1B.w		; 2D 1B 1D ; Logical AND $1D1B.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $F4F3.w,X		; 1D F3 F4 ; OR accumulator with memory $F4F3.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$93.b]		; 07 93 ; OR accumulator with memory (long) [$93.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $F5.b		; 06 F5 ; Arithmetic shift left $F5.b [Reads: Direct Page] [Flags: NCZ]
	stz $8FF6.w		; 9C F6 8F ; Store zero to $8FF6.w
	.db $62, $F7, $00		; 62 F7 00 ; Push effective relative address $62, $F7, $00 [Writes: Stack Pointer]
	and [$63.b],Y		; 37 63 ; AND accumulator with memory (long indexed) [$63.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	trb $28FF.w		; 1C FF 28 ; Test and reset bits $28FF.w [Reads: Accumulator] [Flags: Z]
	brk $26.b		; 00 26 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($26.b,X)		; 01 26 ; Logical OR ($26.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($26.b,X)		; 01 26 ; Logical OR ($26.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $2A.b		; 00 2A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $29.b		; 00 29 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $000101.l		; 22 01 01 00 ; Jump to subroutine long $000101.l [Writes: Stack Pointer] [Flow: call]
	brk $26.b		; 00 26 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $27.b		; 00 27 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $01.b,S		; 23 01 ; AND accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $01.b		; 25 01 ; Logical AND $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $000001.l		; 22 01 00 00 ; Jump to subroutine long $000001.l [Writes: Stack Pointer] [Flow: call]
	jsl $000001.l		; 22 01 00 00 ; Jump to subroutine long $000001.l [Writes: Stack Pointer] [Flow: call]
	rol $01.b		; 26 01 ; Rotate left $01.b [Reads: Direct Page] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$01.b]		; 27 01 ; AND accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $29.b		; 00 29 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $2A.b		; 00 2A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $2C.b		; 00 2C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $62, $06, $05		; 62 06 05 ; Push effective relative address $62, $06, $05 [Writes: Stack Pointer]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	inc $00FF.w,X		; FE FF 00 ; Increment memory $00FF.w,X [Reads: X Index] [Flags: NZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $62, $00, $62		; 62 00 62 ; Push effective relative address $62, $00, $62 [Writes: Stack Pointer]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $06.b,S		; 23 06 ; AND accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $62.b,S		; 03 62 ; OR accumulator with stack relative $62.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora #$62.b		; 09 62 ; Logical OR #$62.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$00.b		; 09 00 ; Logical OR #$00.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$62.b		; 09 62 ; Logical OR #$62.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	stz $0B.b		; 64 0B ; Store zero to $0B.b
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	cop $65.b		; 02 65 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $63		; 10 63 ; Branch if plus to $10, $63 [Flow: branch]
	ora $04.b,X		; 15 04 ; OR accumulator with memory $04.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $1A19.w,X		; 1D 19 1A ; OR accumulator with memory $1A19.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ldx $26.b,Y		; B6 26 ; Load X register $26.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	and [$09.b]		; 27 09 ; AND accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$28.b]		; 07 28 ; OR accumulator with memory (long) [$28.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$99.b		; 29 99 ; Logical AND #$99.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $2B2A.w,Y		; 99 2A 2B ; Store accumulator to $2B2A.w,Y [Reads: Y Index, Accumulator]
	adc $2B.b,S		; 63 2B ; Add with carry (stack relative) $2B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora ($25.b,X)		; 01 25 ; Logical OR ($25.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora #$63.b		; 09 63 ; Logical OR #$63.b with accumulator [Writes: Accumulator] [Flags: NZ]
	and $1D7C02.l		; 2F 02 7C 1D ; AND accumulator with memory (long) $1D7C02.l [Writes: Accumulator] [Flags: NZ]
	sta $3362.w,Y		; 99 62 33 ; Store accumulator to $3362.w,Y [Reads: Y Index, Accumulator]
	.db $62, $35, $03		; 62 35 03 ; Push effective relative address $62, $35, $03 [Writes: Stack Pointer]
	rol $0725.w		; 2E 25 07 ; Rotate left $0725.w [Flags: NCZ]
	and ($63.b)		; 32 63 ; AND accumulator with memory (indirect) ($63.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	cop $1D.b		; 02 1D ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $6433.w,X		; 3C 33 64 ; Test bits $6433.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	and $2E06.w,X		; 3D 06 2E ; AND accumulator with memory $2E06.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $3B.b		; 04 3B ; Test and set bits $3B.b [Reads: Accumulator] [Flags: Z]
	sta ($8E.b),Y		; 91 8E ; Store accumulator ($8E.b),Y [Reads: Direct Page, Y Index, Accumulator]
	adc $42.b,S		; 63 42 ; Add with carry (stack relative) $42.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $1D.b,S		; 03 1D ; OR accumulator with stack relative $1D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lsr $47.b		; 46 47 ; Logical shift right $47.b [Reads: Direct Page] [Flags: NCZ]
	eor ($62.b,X)		; 41 62 ; Exclusive OR accumulator with memory ($62.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	tsb $09.b		; 04 09 ; Test and set bits $09.b [Reads: Accumulator] [Flags: Z]
	ora [$4B.b]		; 07 4B ; OR accumulator with memory (long) [$4B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jmp $621D.w		; 4C 1D 62 ; Jump to $621D.w [Flow: jump]
	eor $9902.w		; 4D 02 99 ; Exclusive OR $9902.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $50, $51		; 50 51 ; Branch if overflow clear to $50, $51 [Flow: branch]
	stz $51.b		; 64 51 ; Store zero to $51.b
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	and ($56.b)		; 32 56 ; AND accumulator with memory (indirect) ($56.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $44.b,S		; 43 44 ; Exclusive OR accumulator with stack relative $44.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $57.b,S		; 63 57 ; Add with carry (stack relative) $57.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cop $1D.b		; 02 1D ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $6341.w,X		; 1D 41 63 ; OR accumulator with memory $6341.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	asl $00.b,X		; 16 00 ; Arithmetic shift left $00.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tsb $5F.b		; 04 5F ; Test and set bits $5F.b [Reads: Accumulator] [Flags: Z]
	lsr $1D4F.w		; 4E 4F 1D ; Logical shift right $1D4F.w [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	asl $6261.w,X		; 1E 61 62 ; Arithmetic shift left $6261.w,X [Reads: X Index] [Flags: NCZ]
	eor ($48.b,X)		; 41 48 ; Exclusive OR accumulator with memory ($48.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$63.b		; 49 63 ; Exclusive OR #$63.b with accumulator [Writes: Accumulator] [Flags: NZ]
	stz $00.b		; 64 00 ; Store zero to $00.b
	ora #$07.b		; 09 07 ; Logical OR #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	eor [$58.b],Y		; 57 58 ; Exclusive OR accumulator with memory (long indexed) [$58.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $1D.b		; 65 1D ; Add $1D.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $6662.w,X		; 1D 62 66 ; OR accumulator with memory $6662.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $5352.w		; 0D 52 53 ; Logical OR $5352.w with accumulator [Writes: Accumulator] [Flags: NZ]
	adc $69.b,S		; 63 69 ; Add with carry (stack relative) $69.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	eor #$6A.b		; 49 6A ; Exclusive OR #$6A.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$32.b]		; 07 32 ; OR accumulator with memory (long) [$32.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jmp ($6D98.w)		; 6C 98 6D ; Jump indirect to ($6D98.w) [Flow: jump]
	and $632D.w		; 2D 2D 63 ; Logical AND $632D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ror $690A.w		; 6E 0A 69 ; Rotate right $690A.w [Flags: NCZ]
	eor #$6A.b		; 49 6A ; Exclusive OR #$6A.b with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	ora ($7F.b,X)		; 01 7F ; Logical OR ($7F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $4B72.w,X		; 3C 72 4B ; Test bits $4B72.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	jsl $70106D.l		; 22 6D 10 70 ; Jump to subroutine long $70106D.l [Writes: Stack Pointer] [Flow: call]
	adc ($73.b),Y		; 71 73 ; Add with carry ($73.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $09.b		; 06 09 ; Arithmetic shift left $09.b [Reads: Direct Page] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	stz $1D.b,X		; 74 1D ; Store zero to $1D.b,X [Reads: X Index]
	adc $76.b,X		; 75 76 ; Add $76.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($76.b)		; 72 76 ; Add with carry (indirect) ($76.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $7772.w,X		; 1D 72 77 ; OR accumulator with memory $7772.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sbc $0122E4.l,X		; FF E4 22 01 ; Subtract with carry (long,X) $0122E4.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $91.b		; E4 91 ; Compare $91.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3B.b		; 00 3B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $25.b		; 02 25 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $01.b		; 26 01 ; Rotate left $01.b [Reads: Direct Page] [Flags: NCZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	jmp.w [$0003]		; DC 03 00 ; Jump long indirect [$0003] [Flow: jump]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $27.b		; 02 27 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($25.b,X)		; 01 25 ; Logical OR ($25.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora $7E.b,S		; 03 7E ; OR accumulator with stack relative $7E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta ($82.b,X)		; 81 82 ; Store accumulator ($82.b,X) [Reads: Direct Page, Accumulator, X Index]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $62.b,S		; 83 62 ; Store accumulator (stack relative) $62.b,S [Reads: Stack Pointer, Accumulator]
	bit #$00.b		; 89 00 ; Test bits #$00.b with accumulator [Reads: Accumulator] [Flags: Z]
	bit #$68.b		; 89 68 ; Test bits #$68.b with accumulator [Reads: Accumulator] [Flags: Z]
	sty $1D02.w		; 8C 02 1D ; Store Y register to $1D02.w [Reads: Y Index]
	sta $96.b,X		; 95 96 ; Store accumulator to $96.b,X [Reads: Accumulator, X Index]
	ror $96.b		; 66 96 ; Rotate right $96.b [Reads: Direct Page] [Flags: NCZ]
	jsl $9E649D.l		; 22 9D 64 9E ; Jump to subroutine long $9E649D.l [Writes: Stack Pointer] [Flow: call]
	tsb $95.b		; 04 95 ; Test and set bits $95.b [Reads: Accumulator] [Flags: Z]
	stx $A2.b,Y		; 96 A2 ; Store X register $A2.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	lda ($99.b,X)		; A1 99 ; Load accumulator ($99.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $A3, $22		; 62 A3 22 ; Push effective relative address $62, $A3, $22 [Writes: Stack Pointer]
	ldx $63.b		; A6 63 ; Load $63.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	lda [$24.b]		; A7 24 ; Load accumulator (long) [$24.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	adc $AC.b,S		; 63 AC ; Add with carry (stack relative) $AC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	jsl $B00378.l		; 22 78 03 B0 ; Jump to subroutine long $B00378.l [Writes: Stack Pointer] [Flow: call]
	lda ($A8.b),Y		; B1 A8 ; Load accumulator ($A8.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda ($24.b)		; B2 24 ; Load accumulator (indirect) ($24.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda ($62.b,S),Y		; B3 62 ; Load accumulator (stack relative indirect indexed) ($62.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldy $01.b,X		; B4 01 ; Load Y register $01.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	sta ($79.b),Y		; 91 79 ; Store accumulator ($79.b),Y [Reads: Direct Page, Y Index, Accumulator]
	adc $B7.b		; 65 B7 ; Add $B7.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	bit $BD.b		; 24 BD ; Test bits $BD.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	.db $62, $BE, $00		; 62 BE 00 ; Push effective relative address $62, $BE, $00 [Writes: Stack Pointer]
	lda [$6A.b],Y		; B7 6A ; Load accumulator (long indexed) [$6A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($24.b,X)		; C1 24 ; Compare accumulator ($24.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	cmp $02.b,S		; C3 02 ; Compare accumulator (stack relative) $02.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy $62A2.w		; CC A2 62 ; Compare $62A2.w with Y register [Reads: Y Index] [Flags: NCZ]
	cmp $B706.w		; CD 06 B7 ; Compare $B706.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	lda [$B8.b],Y		; B7 B8 ; Load accumulator (long indexed) [$B8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $D1		; D0 D1 ; Branch if not equal to $D0, $D1 [Flow: branch]
	sta $A2.b,X		; 95 A2 ; Store accumulator to $A2.b,X [Reads: Accumulator, X Index]
	adc $D2.b,S		; 63 D2 ; Add with carry (stack relative) $D2.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $95.b,S		; 03 95 ; OR accumulator with stack relative $95.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp ($D6.b)		; D2 D6 ; Compare accumulator (indirect) ($D6.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp [$23.b],Y		; D7 23 ; Compare accumulator (long indexed) [$23.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cmp $6B.b,S		; C3 6B ; Compare accumulator (stack relative) $6B.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	tsb $96.b		; 04 96 ; Test and set bits $96.b [Reads: Accumulator] [Flags: Z]
	lda ($A2.b,X)		; A1 A2 ; Load accumulator ($A2.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ldx #$94.b		; A2 94 ; Load #$94.b into X register [Writes: X Index] [Flags: NZ]
	ror $02E4.w		; 6E E4 02 ; Rotate right $02E4.w [Flags: NCZ]
	ora $1DA1.w,X		; 1D A1 1D ; OR accumulator with memory $1DA1.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	stz $F3.b		; 64 F3 ; Store zero to $F3.b
	ora $0A.b,S		; 03 0A ; OR accumulator with stack relative $0A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sbc $63ED.w		; ED ED 63 ; Subtract $63ED.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora #$F2.b		; 09 F2 ; Logical OR #$F2.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ldx #$94.b		; A2 94 ; Load #$94.b into X register [Writes: X Index] [Flags: NZ]
	jsr ($0903.w,X)		; FC 03 09 ; Jump to subroutine indirect indexed ($0903.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $14FE.w,X		; FD FE 14 ; Subtract with carry $14FE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $83.b,X		; 16 83 ; Arithmetic shift left $83.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sbc $F2FB00.l,X		; FF 00 FB F2 ; Subtract with carry (long,X) $F2FB00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $96.b,X		; 95 96 ; Store accumulator to $96.b,X [Reads: Accumulator, X Index]
	cpx $13.b		; E4 13 ; Compare $13.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsr $8423.w		; 20 23 84 ; Jump to subroutine at $8423.w [Writes: Stack Pointer] [Flow: call]
	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc ($1D.b)		; F2 1D ; Subtract with carry (indirect) ($1D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda ($1F.b,X)		; A1 1F ; Load accumulator ($1F.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $95.b		; 04 95 ; Test and set bits $95.b [Reads: Accumulator] [Flags: Z]
	ldx #$A1.b		; A2 A1 ; Load #$A1.b into X register [Writes: X Index] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	cpx #$01.b		; E0 01 ; Compare #$01.b with X register [Reads: X Index] [Flags: NCZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $62, $05, $04		; 62 05 04 ; Push effective relative address $62, $05, $04 [Writes: Stack Pointer]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora #$DA.b		; 09 DA ; Logical OR #$DA.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $2B0122.l,X		; FF 22 01 2B ; Subtract with carry (long,X) $2B0122.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($2D.b,X)		; 01 2D ; Logical OR ($2D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($3C.b,X)		; 01 3C ; Logical OR ($3C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($28.b,X)		; 01 28 ; Logical OR ($28.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $25.b		; 02 25 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and #$02.b		; 29 02 ; Logical AND #$02.b with accumulator [Writes: Accumulator] [Flags: NZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $01.b,S		; 23 01 ; AND accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $012402.l		; 22 02 24 01 ; Jump to subroutine long $012402.l [Writes: Stack Pointer] [Flow: call]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	cop $83.b		; 02 83 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	cop $83.b		; 02 83 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $02.b,S		; 23 02 ; AND accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $27.b		; 00 27 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $000102.l		; 22 02 01 00 ; Jump to subroutine long $000102.l [Writes: Stack Pointer] [Flow: call]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $3A.b		; 00 3A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $02.b		; 25 02 ; Logical AND $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $83.b		; 02 83 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $02.b		; 26 02 ; Rotate left $02.b [Reads: Direct Page] [Flags: NCZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	adc $0222.w,X		; 7D 22 02 ; Add $0222.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $022601.l		; 22 01 26 02 ; Jump to subroutine long $022601.l [Writes: Stack Pointer] [Flow: call]
	jsl $02FF01.l		; 22 01 FF 02 ; Jump to subroutine long $02FF01.l [Writes: Stack Pointer] [Flow: call]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	adc $6BC1.w,Y		; 79 C1 6B ; Add $6BC1.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $84.b		; 00 84 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $16.b,S		; 63 16 ; Add with carry (stack relative) $16.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	brk $C6.b		; 00 C6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($23.b,S),Y		; 73 23 ; Add with carry (stack relative indirect indexed) ($23.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	brk $27.b		; 00 27 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $37.b		; 66 37 ; Rotate right $37.b [Reads: Direct Page] [Flags: NCZ]
	tsb $2F.b		; 04 2F ; Test and set bits $2F.b [Reads: Accumulator] [Flags: Z]
	sty $96.b,X		; 94 96 ; Store Y register $96.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	rol $6BC3.w,X		; 3E C3 6B ; Rotate left $6BC3.w,X [Reads: X Index] [Flags: NCZ]
	and $4B4102.l,X		; 3F 02 41 4B ; AND accumulator with memory (long,X) $4B4102.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jmp $4C62.w		; 4C 62 4C ; Jump to $4C62.w [Flow: jump]
	brk $CC.b		; 00 CC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $4F.b		; 66 4F ; Rotate right $4F.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	eor ($56.b)		; 52 56 ; Exclusive OR accumulator with memory (indirect) ($56.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	eor #$EB.b		; 49 EB ; Exclusive OR #$EB.b with accumulator [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy $631C.w		; CC 1C 63 ; Compare $631C.w with Y register [Reads: Y Index] [Flags: NCZ]
	eor [$23.b],Y		; 57 23 ; Exclusive OR accumulator with memory (long indexed) [$23.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	ora [$5C.b]		; 07 5C ; OR accumulator with memory (long) [$5C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $0600.w		; 2E 00 06 ; Rotate left $0600.w [Flags: NCZ]
	eor $94AA.w,X		; 5D AA 94 ; Exclusive OR accumulator with memory $94AA.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldx #$62.b		; A2 62 ; Load #$62.b into X register [Writes: X Index] [Flags: NZ]
	lsr $6124.w,X		; 5E 24 61 ; Logical shift right $6124.w,X [Reads: X Index] [Flags: NCZ]
	tsb $62.b		; 04 62 ; Test and set bits $62.b [Reads: Accumulator] [Flags: Z]
	adc $17.b,S		; 63 17 ; Add with carry (stack relative) $17.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	tsb $6264.w		; 0C 64 62 ; Test and set bits $6264.w [Reads: Accumulator] [Flags: Z]
	cmp ($03.b,S),Y		; D3 03 ; Compare accumulator (stack relative indirect indexed) ($03.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	lda ($65.b,X)		; A1 65 ; Load accumulator ($65.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $66, $04		; 62 66 04 ; Push effective relative address $62, $66, $04 [Writes: Stack Pointer]
	jsl $030323.l		; 22 23 03 03 ; Jump to subroutine long $030323.l [Writes: Stack Pointer] [Flow: call]
	ora [$6B.b],Y		; 17 6B ; OR accumulator with memory (long indexed) [$6B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc #$04.b		; 69 04 ; Add #$04.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	ora $03E4.w,X		; 1D E4 03 ; OR accumulator with memory $03E4.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $71.b,X		; 75 71 ; Add $71.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	ror $06.b,X		; 76 06 ; Rotate right $06.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	lsr $807F.w,X		; 5E 7F 80 ; Logical shift right $807F.w,X [Reads: X Index] [Flags: NCZ]
	sta $81.b,X		; 95 81 ; Store accumulator to $81.b,X [Reads: Accumulator, X Index]
	.db $82, $71, $63		; 82 71 63 ; Branch always long to $82, $71, $63 [Flow: branch]
	sta $03.b,S		; 83 03 ; Store accumulator (stack relative) $03.b,S [Reads: Stack Pointer, Accumulator]
	sty $87.b,X		; 94 87 ; Store Y register $87.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ora $8967.w,X		; 1D 67 89 ; OR accumulator with memory $8967.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $09.b		; 04 09 ; Test and set bits $09.b [Reads: Accumulator] [Flags: Z]
	sbc $91ED.w,X		; FD ED 91 ; Subtract with carry $91ED.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	stx $62.b,Y		; 96 62 ; Store X register $62.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	sta ($01.b)		; 92 01 ; Store accumulator (indirect) ($01.b) [Reads: Direct Page, Accumulator]
	ora $63A2.w,X		; 1D A2 63 ; OR accumulator with memory $63A2.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $06.b,X		; 95 06 ; Store accumulator to $06.b,X [Reads: Accumulator, X Index]
	eor ($6A.b,S),Y		; 53 6A ; XOR accumulator (stack relative indirect indexed) ($6A.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,S),Y		; 13 01 ; OR accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	sta $A1.b,X		; 95 A1 ; Store accumulator to $A1.b,X [Reads: Accumulator, X Index]
	adc $99.b		; 65 99 ; Add $99.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora #$A2.b		; 09 A2 ; Logical OR #$A2.b with accumulator [Writes: Accumulator] [Flags: NZ]
	rol $9F82.w		; 2E 82 9F ; Rotate left $9F82.w [Flags: NCZ]
	ldy #$1F.b		; A0 1F ; Load #$1F.b into Y register [Writes: Y Index] [Flags: NZ]
	tsb $A1.b		; 04 A1 ; Test and set bits $A1.b [Reads: Accumulator] [Flags: Z]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ora #$65.b		; 09 65 ; Logical OR #$65.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ldx #$0B.b		; A2 0B ; Load #$0B.b into X register [Writes: X Index] [Flags: NZ]
	sta $2E.b,X		; 95 2E ; Store accumulator to $2E.b,X [Reads: Accumulator, X Index]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	ora $F8.b,S		; 03 F8 ; OR accumulator with stack relative $F8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	lda #$AA.b		; A9 AA ; Load #$AA.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsl $A90508.l		; 22 08 05 A9 ; Jump to subroutine long $A90508.l [Writes: Stack Pointer] [Flow: call]
	ora [$AC.b]		; 07 AC ; OR accumulator with memory (long) [$AC.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $220226.l,X		; FF 26 02 22 ; Subtract with carry (long,X) $220226.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $022301.l		; 22 01 23 02 ; Jump to subroutine long $022301.l [Writes: Stack Pointer] [Flow: call]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $01.b,S		; 43 01 ; Exclusive OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $43.b		; 02 43 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $010102.l		; 22 02 01 01 ; Jump to subroutine long $010102.l [Writes: Stack Pointer] [Flow: call]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $86.b		; 02 86 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $010202.l		; 22 02 02 01 ; Jump to subroutine long $010202.l [Writes: Stack Pointer] [Flow: call]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $022401.l		; 22 01 24 02 ; Jump to subroutine long $022401.l [Writes: Stack Pointer] [Flow: call]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $010002.l		; 22 02 00 01 ; Jump to subroutine long $010002.l [Writes: Stack Pointer] [Flow: call]
	eor $01.b,S		; 43 01 ; Exclusive OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $23.b		; 02 23 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($84.b,X)		; 01 84 ; Logical OR ($84.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $02.b,S		; 23 02 ; AND accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and #$02.b		; 29 02 ; Logical AND #$02.b with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $000002.l		; 22 02 00 00 ; Jump to subroutine long $000002.l [Writes: Stack Pointer] [Flow: call]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($29.b,X)		; 01 29 ; Logical OR ($29.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $84.b		; 02 84 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $02.b		; 25 02 ; Logical AND $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($25.b,X)		; 01 25 ; Logical OR ($25.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $010503.l		; 22 03 05 01 ; Jump to subroutine long $010503.l [Writes: Stack Pointer] [Flow: call]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $43.b		; 02 43 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl L000702.l		; 22 02 87 00 ; Jump to subroutine long L000702.l [Writes: Stack Pointer] [Flow: call]
	lda $22.b,S		; A3 22 ; Load accumulator (stack relative) $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $030102.l		; 22 02 01 03 ; Jump to subroutine long $030102.l [Writes: Stack Pointer] [Flow: call]
	ora $83.b,S		; 03 83 ; OR accumulator with stack relative $83.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $A6.b		; 00 A6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $01.b,S		; 43 01 ; Exclusive OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $012F03.l		; 2F 03 2F 01 ; AND accumulator with memory (long) $012F03.l [Writes: Accumulator] [Flags: NZ]
	and $66FF03.l		; 2F 03 FF 66 ; AND accumulator with memory (long) $66FF03.l [Writes: Accumulator] [Flags: NZ]
	lda $B80A.w		; AD 0A B8 ; Load $B80A.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sty $84.b		; 84 84 ; Store Y register to $84.b [Reads: Y Index]
	ldy $AE.b,X		; B4 AE ; Load Y register $AE.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	lda $B6.b,X		; B5 B6 ; Load $B6.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sty $B7.b		; 84 B7 ; Store Y register to $B7.b [Reads: Y Index]
	clv		; B8 ; Clear overflow flag [Flags: V]
	jsl $B96378.l		; 22 78 63 B9 ; Jump to subroutine long $B96378.l [Writes: Stack Pointer] [Flow: call]
	.db $10, $84		; 10 84 ; Branch if plus to $10, $84 [Flow: branch]
	sty $BD.b		; 84 BD ; Store Y register to $BD.b [Reads: Y Index]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	lda $84BB.w,Y		; B9 BB 84 ; Load $84BB.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ldx $B3B8.w,Y		; BE B8 B3 ; Load X register $B3B8.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ldx $78BF.w		; AE BF 78 ; Load $78BF.w into X register [Writes: X Index] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cpy #$C1.b		; C0 C1 ; Compare #$C1.b with Y register [Reads: Y Index] [Flags: NCZ]
	ora $83.b,X		; 15 83 ; OR accumulator with memory $83.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $C0.b		; 02 C0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rep #$C3		; C2 C3 ; Reset processor status bits #$C3 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	.db $62, $C3, $05		; 62 C3 05 ; Push effective relative address $62, $C3, $05 [Writes: Stack Pointer]
	sty $AD.b		; 84 AD ; Store Y register to $AD.b [Reads: Y Index]
	dec $78.b		; C6 78 ; Decrement $78.b [Reads: Direct Page] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sta $08C764.l		; 8F 64 C7 08 ; Store accumulator (long) $08C764.l [Reads: Accumulator]
	lda [$CC.b],Y		; B7 CC ; Load accumulator (long indexed) [$CC.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $C331.w		; CD 31 C3 ; Compare $C331.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp $CE.b,S		; C3 CE ; Compare accumulator (stack relative) $CE.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	sty $CF.b		; 84 CF ; Store Y register to $CF.b [Reads: Y Index]
	jsl $8F0478.l		; 22 78 04 8F ; Jump to subroutine long $8F0478.l [Writes: Stack Pointer] [Flow: call]
	.db $D0, $CB		; D0 CB ; Branch if not equal to $D0, $CB [Flow: branch]
	cmp $C3.b,S		; C3 C3 ; Compare accumulator (stack relative) $C3.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	.db $62, $D1, $00		; 62 D1 00 ; Push effective relative address $62, $D1, $00 [Writes: Stack Pointer]
	lda ($63.b,X)		; A1 63 ; Load accumulator ($63.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	pei ($22.b)		; D4 22 ; Push effective indirect address ($22.b) [Reads: Direct Page] [Writes: Stack Pointer]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	tsb $D8.b		; 04 D8 ; Test and set bits $D8.b [Reads: Accumulator] [Flags: Z]
	.db $D0, $D9		; D0 D9 ; Branch if not equal to $D0, $D9 [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $DB.b,S		; 63 DB ; Add with carry (stack relative) $DB.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	brk $AA.b		; 00 AA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $DF, $22		; 62 DF 22 ; Push effective relative address $62, $DF, $22 [Writes: Stack Pointer]
.ACCU 8
	sep #$63		; E2 63
	sbc $04.b,S		; E3 04 ; Subtract stack-relative $04.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	ora $DCE7.w,X		; 1D E7 DC ; OR accumulator with memory $DCE7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	ora $E963.w,X		; 1D 63 E9 ; OR accumulator with memory $E963.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $EE63ED.l		; 22 ED 63 EE ; Jump to subroutine long $EE63ED.l [Writes: Stack Pointer] [Flow: call]
	ora ($95.b)		; 12 95 ; OR accumulator with memory (indirect) ($95.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc ($DC.b)		; F2 DC ; Subtract with carry (indirect) ($DC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($F4.b,S),Y		; F3 F4 ; Subtract with carry (stack relative indirect indexed) ($F4.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora [$AA.b]		; 07 AA ; OR accumulator with memory (long) [$AA.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $B4.b,X		; F5 B4 ; Subtract $B4.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx $81B2.w		; AE B2 81 ; Load $81B2.w into X register [Writes: X Index] [Flags: NZ]
	sty $F6.b		; 84 F6 ; Store Y register to $F6.b [Reads: Y Index]
	sbc [$F2.b],Y		; F7 F2 ; Subtract with carry (long indexed) [$F2.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc ($DC.b)		; F2 DC ; Subtract with carry (indirect) ($DC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $62, $F9, $01		; 62 F9 01 ; Push effective relative address $62, $F9, $01 [Writes: Stack Pointer]
	lda $BF.b,X		; B5 BF ; Load $BF.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $FC, $02		; 62 FC 02 ; Push effective relative address $62, $FC, $02 [Writes: Stack Pointer]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	lda [$FF.b],Y		; B7 FF ; Load accumulator (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $00, $01		; 62 00 01 ; Push effective relative address $62, $00, $01 [Writes: Stack Pointer]
	sbc ($DC.b)		; F2 DC ; Subtract with carry (indirect) ($DC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $62, $03, $19		; 62 03 19 ; Push effective relative address $62, $03, $19 [Writes: Stack Pointer]
	lda $070684.l,X		; BF 84 06 07 ; Load long $070684.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cpy #$C1.b		; C0 C1 ; Compare #$C1.b with Y register [Reads: Y Index] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc $F26909.l,X		; FF 09 69 F2 ; Subtract with carry (long,X) $F26909.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp.w [$0B0A]		; DC 0A 0B ; Jump long indirect [$0B0A] [Flow: jump]
	sty $84.b		; 84 84 ; Store Y register to $84.b [Reads: Y Index]
	tsb $790D.w		; 0C 0D 79 ; Test and set bits $790D.w [Reads: Accumulator] [Flags: Z]
	ldx $7878.w		; AE 78 78 ; Load $7878.w into X register [Writes: X Index] [Flags: NZ]
	sta $850F0E.l		; 8F 0E 0F 85 ; Store accumulator (long) $850F0E.l [Reads: Accumulator]
	brk $AF.b		; 00 AF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $10, $11		; 10 11 ; Branch if plus to $10, $11 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sta $C9.b,S		; 83 C9 ; Store accumulator (stack relative) $C9.b,S [Reads: Stack Pointer, Accumulator]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	asl $12.b,X		; 16 12 ; Arithmetic shift left $12.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	and ($9E.b,S),Y		; 33 9E ; AND accumulator (stack relative indirect indexed) ($9E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc #$66.b		; 69 66 ; Add #$66.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	ora ($62.b,S),Y		; 13 62 ; OR accumulator (stack relative indirect indexed) ($62.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $1905.w,Y		; 19 05 19 ; OR accumulator with memory $1905.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $171D.w		; 1C 1D 17 ; Test and reset bits $171D.w [Reads: Accumulator] [Flags: Z]
	asl $2F1F.w,X		; 1E 1F 2F ; Arithmetic shift left $2F1F.w,X [Reads: X Index] [Flags: NCZ]
	asl $2E.b		; 06 2E ; Arithmetic shift left $2E.b [Reads: Direct Page] [Flags: NCZ]
	jsr $2100.w		; 20 00 21 ; Jump to subroutine at $2100.w [Writes: Stack Pointer] [Flow: call]
	sbc $000162.l,X		; FF 62 01 00 ; Subtract with carry (long,X) $000162.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($43.b,X)		; 01 43 ; Logical OR ($43.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $03.b,S		; 23 03 ; AND accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($44.b,X)		; 01 44 ; Logical OR ($44.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $02.b		; 06 02 ; Arithmetic shift left $02.b [Reads: Direct Page] [Flags: NCZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $010203.l		; 22 03 02 01 ; Jump to subroutine long $010203.l [Writes: Stack Pointer] [Flow: call]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $03.b		; 26 03 ; Rotate left $03.b [Reads: Direct Page] [Flags: NCZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $030501.l		; 22 01 05 03 ; Jump to subroutine long $030501.l [Writes: Stack Pointer] [Flow: call]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $62.b		; 02 62 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($43.b,X)		; 01 43 ; Logical OR ($43.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl L000301.l		; 22 01 83 00 ; Jump to subroutine long L000301.l [Writes: Stack Pointer] [Flow: call]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $03.b		; 24 03 ; Test bits $03.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsl $032201.l		; 22 01 22 03 ; Jump to subroutine long $032201.l [Writes: Stack Pointer] [Flow: call]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	eor $22.b,X		; 55 22 ; Exclusive OR accumulator with memory $22.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $02.b,S		; 43 02 ; Exclusive OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($44.b,X)		; 01 44 ; Logical OR ($44.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $03.b,S		; 23 03 ; AND accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $02.b		; 25 02 ; Logical AND $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $008402.l		; 22 02 84 00 ; Jump to subroutine long $008402.l [Writes: Stack Pointer] [Flow: call]
	adc $24.b,S		; 63 24 ; Add with carry (stack relative) $24.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $23.b,S		; 03 23 ; OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $01.b,S		; 23 01 ; AND accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $03.b		; 25 03 ; Logical AND $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $01.b,S		; 23 01 ; AND accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($25.b,X)		; 01 25 ; Logical OR ($25.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $84.b,S		; 03 84 ; OR accumulator with stack relative $84.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	and ($2D.b,X)		; 21 2D ; Logical AND ($2D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $03.b		; 24 03 ; Test bits $03.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	jsl $030101.l		; 22 01 01 03 ; Jump to subroutine long $030101.l [Writes: Stack Pointer] [Flow: call]
	ora $24.b,S		; 03 24 ; OR accumulator with stack relative $24.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($25.b,X)		; 01 25 ; Logical OR ($25.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $83.b,S		; 03 83 ; OR accumulator with stack relative $83.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $49.b		; 00 49 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $01.b		; 25 01 ; Logical AND $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $FC8410.l,X		; FF 10 84 FC ; Subtract with carry (long,X) $FC8410.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $233F91.l		; 22 91 3F 23 ; Jump to subroutine long $233F91.l [Writes: Stack Pointer] [Flow: call]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	bit $25.b		; 24 25 ; Test bits $25.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ldy $AE.b,X		; B4 AE ; Load Y register $AE.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	adc $26B7.w,Y		; 79 B7 26 ; Add $26B7.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx $84AF.w		; AE AF 84 ; Load $84AF.w into X register [Writes: X Index] [Flags: NZ]
	adc $27.b,S		; 63 27 ; Add with carry (stack relative) $27.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora ($88.b,S),Y		; 13 88 ; OR accumulator (stack relative indirect indexed) ($88.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	bit #$8C.b		; 89 8C ; Test bits #$8C.b with accumulator [Reads: Accumulator] [Flags: Z]
	bit $C22D.w		; 2C 2D C2 ; Test bits $C22D.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	cmp $2E.b,S		; C3 2E ; Compare accumulator (stack relative) $2E.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	ldx $C52F.w		; AE 2F C5 ; Load $C52F.w into X register [Writes: X Index] [Flags: NZ]
	lda [$30.b],Y		; B7 30 ; Load accumulator (long indexed) [$30.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta ($F2.b,S),Y		; 93 F2 ; Store accumulator (stack relative indirect indexed) ($F2.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	and ($1D.b),Y		; 31 1D ; AND accumulator with memory ($1D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $3262.w,X		; 1D 62 32 ; OR accumulator with memory $3262.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cop $CC.b		; 02 CC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $21		; 30 21 ; Branch if minus to $30, $21 [Flow: branch]
	ror $35.b		; 66 35 ; Rotate right $35.b [Reads: Direct Page] [Flags: NCZ]
	ora $AA07.w,X		; 1D 07 AA ; OR accumulator with memory $AA07.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldy $3CAD.w		; AC AD 3C ; Load $3CAD.w into Y register [Writes: Y Index] [Flags: NZ]
	and $1DA1.w,X		; 3D A1 1D ; AND accumulator with memory $1DA1.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $31		; 30 31 ; Branch if minus to $30, $31 [Flow: branch]
	cmp $32.b,S		; C3 32 ; Compare accumulator (stack relative) $32.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	rol $FF3F.w,X		; 3E 3F FF ; Rotate left $FF3F.w,X [Reads: X Index] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	lda ($B4.b)		; B2 B4 ; Load accumulator (indirect) ($B4.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $41.b,X		; B5 41 ; Load $41.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $42, $4B		; 42 4B ; Reserved instruction
	jmp $4443.w		; 4C 43 44 ; Jump to $4443.w [Flow: jump]
	ora $453E.w,X		; 1D 3E 45 ; OR accumulator with memory $453E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	bit $62.b		; 24 62 ; Test bits $62.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	lsr $06.b		; 46 06 ; Logical shift right $06.b [Reads: Direct Page] [Flags: NCZ]
	ldy $41BE.w,X		; BC BE 41 ; Load Y register $41BE.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	eor #$52.b		; 49 52 ; Exclusive OR #$52.b with accumulator [Writes: Accumulator] [Flags: NZ]
	eor ($EB.b,S),Y		; 53 EB ; XOR accumulator (stack relative indirect indexed) ($EB.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $62, $4A, $19		; 62 4A 19 ; Push effective relative address $62, $4A, $19 [Writes: Stack Pointer]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $218B.w		; 4D 8B 21 ; Exclusive OR $218B.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lsr $CA8F.w		; 4E 8F CA ; Logical shift right $CA8F.w [Flags: NCZ]
	.db $D0, $4F		; D0 4F ; Branch if not equal to $D0, $4F [Flow: branch]
	ora $5150.w,X		; 1D 50 51 ; OR accumulator with memory $5150.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	eor ($97.b)		; 52 97 ; Exclusive OR accumulator with memory (indirect) ($97.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	stx $95.b,Y		; 96 95 ; Store X register $95.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	ora $2130.w,X		; 1D 30 21 ; OR accumulator with memory $2130.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($0A.b,S),Y		; 53 0A ; XOR accumulator (stack relative indirect indexed) ($0A.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	mvn $1D,$55		; 54 55 1D ; Move block negative $1D,$55 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	adc $56.b		; 65 56 ; Add $56.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $62, $5B, $08		; 62 5B 08 ; Push effective relative address $62, $5B, $08 [Writes: Stack Pointer]
	lda ($30.b,X)		; A1 30 ; Load accumulator ($30.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	lsr $5F98.w,X		; 5E 98 5F ; Logical shift right $5F98.w,X [Reads: X Index] [Flags: NCZ]
	sta $56.b,X		; 95 56 ; Store accumulator to $56.b,X [Reads: Accumulator, X Index]
	.db $62, $60, $04		; 62 60 04 ; Push effective relative address $62, $60, $04 [Writes: Stack Pointer]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	adc $F3.b,S		; 63 F3 ; Add with carry (stack relative) $F3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	pea $0743.w		; F4 43 07 ; Push absolute address $0743.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	asl $08.b		; 06 08 ; Arithmetic shift left $08.b [Reads: Direct Page] [Flags: NCZ]
	sbc $070709.l		; EF 09 07 07 ; Subtract with carry (long) $070709.l [Writes: Accumulator] [Flags: NCVZ]
	sbc $066409.l		; EF 09 64 06 ; Subtract with carry (long) $066409.l [Writes: Accumulator] [Flags: NCVZ]
	asl $64.b		; 06 64 ; Arithmetic shift left $64.b [Reads: Direct Page] [Flags: NCZ]
	adc $23.b		; 65 23 ; Add $23.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora ($68.b,X)		; 01 68 ; Logical OR ($68.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	adc #$22.b		; 69 22 ; Add #$22.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $6A.b		; 65 6A ; Add $6A.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and $F8.b,S		; 23 F8 ; AND accumulator with stack relative $F8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($70.b,X)		; 01 70 ; Logical OR ($70.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	adc $62F822.l		; 6F 22 F8 62 ; Add with carry (long) $62F822.l [Writes: Accumulator] [Flags: NCVZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $6D6C.w		; 0D 6C 6D ; Logical OR $6D6C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	adc ($09.b),Y		; 71 09 ; Add with carry ($09.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($F8.b)		; 72 F8 ; Add with carry (indirect) ($F8.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	adc ($07.b,S),Y		; 73 07 ; Add with carry (stack relative indirect indexed) ($07.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora [$72.b]		; 07 72 ; OR accumulator with memory (long) [$72.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	stz $22.b,X		; 74 22 ; Store zero to $22.b,X [Reads: X Index]
	jmp ($6D00.w)		; 6C 00 6D ; Jump indirect to ($6D00.w) [Flow: jump]
	.db $62, $75, $08		; 62 75 08 ; Push effective relative address $62, $75, $08 [Writes: Stack Pointer]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	adc #$78.b		; 69 78 ; Add #$78.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	ror $76.b,X		; 76 76 ; Rotate right $76.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	adc [$F8.b],Y		; 77 F8 ; Add with carry (long indexed) [$F8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	stz $22.b,X		; 74 22 ; Store zero to $22.b,X [Reads: X Index]
	jmp ($6D00.w)		; 6C 00 6D ; Jump indirect to ($6D00.w) [Flow: jump]
	jsl $7001F8.l		; 22 F8 01 70 ; Jump to subroutine long $7001F8.l [Writes: Stack Pointer] [Flow: call]
	adc $F824.w,Y		; 79 24 F8 ; Add $F824.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($7A.b,X)		; 01 7A ; Logical OR ($7A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	stz $22.b,X		; 74 22 ; Store zero to $22.b,X [Reads: X Index]
	jmp ($6D05.w)		; 6C 05 6D ; Jump indirect to ($6D05.w) [Flow: jump]
	sed		; F8 ; Set decimal flag [Flags: D]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc ($06.b,S),Y		; 73 06 ; Add with carry (stack relative indirect indexed) ($06.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	stz $24.b		; 64 24 ; Store zero to $24.b
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $010202.l,X		; FF 02 02 01 ; Subtract with carry (long,X) $010202.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $02.b,S		; 43 02 ; Exclusive OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $01, $83		; 62 01 83 ; Push effective relative address $62, $01, $83 [Writes: Stack Pointer]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$01.b]		; 27 01 ; AND accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $012302.l		; 22 02 23 01 ; Jump to subroutine long $012302.l [Writes: Stack Pointer] [Flow: call]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $62.b		; 02 62 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $01.b,S		; 43 01 ; Exclusive OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $24.b		; 02 24 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($26.b,X)		; 01 26 ; Logical OR ($26.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $03.b,S		; 23 03 ; AND accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $25.b		; 00 25 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $84.b,S		; 03 84 ; OR accumulator with stack relative $84.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $31.b		; 00 31 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	and ($23.b)		; 32 23 ; AND accumulator with memory (indirect) ($23.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $010203.l		; 22 03 02 01 ; Jump to subroutine long $010203.l [Writes: Stack Pointer] [Flow: call]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $010003.l		; 22 03 00 01 ; Jump to subroutine long $010003.l [Writes: Stack Pointer] [Flow: call]
	and $03.b		; 25 03 ; Logical AND $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $002203.l		; 22 03 22 00 ; Jump to subroutine long $002203.l [Writes: Stack Pointer] [Flow: call]
	stx $00.b		; 86 00 ; Store X register to $00.b [Reads: X Index]
	ror $0222.w,X		; 7E 22 02 ; Rotate right $0222.w,X [Reads: X Index] [Flags: NCZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	.db $90, $00		; 90 00 ; Branch if carry clear to $90, $00 [Flow: branch]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $03.b,S		; 23 03 ; AND accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $25.b		; 02 25 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $43.b,S		; 03 43 ; OR accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $012303.l		; 22 03 23 01 ; Jump to subroutine long $012303.l [Writes: Stack Pointer] [Flow: call]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	trb $84BB.w		; 1C BB 84 ; Test and reset bits $84BB.w [Reads: Accumulator] [Flags: Z]
	sty $7C.b		; 84 7C ; Store Y register to $7C.b [Reads: Y Index]
	adc $CA11.w,X		; 7D 11 CA ; Add $CA11.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx $BF78.w		; AE 78 BF ; Load $BF78.w into X register [Writes: X Index] [Flags: NZ]
	cpy #$7E.b		; C0 7E ; Compare #$7E.b with Y register [Reads: Y Index] [Flags: NCZ]
	dec $8F.b		; C6 8F ; Decrement $8F.b [Reads: Direct Page] [Flags: NZ]
	and $84.b,S		; 23 84 ; AND accumulator with stack relative $84.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $0A4D80.l,X		; 7F 80 4D 0A ; Add long $0A4D80.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($7D.b,S),Y		; 53 7D ; XOR accumulator (stack relative indirect indexed) ($7D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta ($12.b,X)		; 81 12 ; Store accumulator ($12.b,X) [Reads: Direct Page, Accumulator, X Index]
	eor $B67B.w		; 4D 7B B6 ; Exclusive OR $B67B.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lda [$62.b],Y		; B7 62 ; Load accumulator (long indexed) [$62.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $82, $02, $81		; 82 02 81 ; Branch always long to $82, $02, $81 [Flow: branch]
	eor $234E.w		; 4D 4E 23 ; Exclusive OR $234E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	tsb $C389.w		; 0C 89 C3 ; Test and set bits $C389.w [Reads: Accumulator] [Flags: Z]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	bit #$CE.b		; 89 CE ; Test bits #$CE.b with accumulator [Reads: Accumulator] [Flags: Z]
	ldx $8FC6.w,Y		; BE C6 8F ; Load X register $8FC6.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	cmp #$C3.b		; C9 C3 ; Compare #$C3.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $4C.b,S		; 83 4C ; Store accumulator (stack relative) $4C.b,S [Reads: Stack Pointer, Accumulator]
	jsl $84001D.l		; 22 1D 00 84 ; Jump to subroutine long $84001D.l [Writes: Stack Pointer] [Flow: call]
	jsl $3E1A1D.l		; 22 1D 1A 3E ; Jump to subroutine long $3E1A1D.l [Writes: Stack Pointer] [Flow: call]
	cmp $C3.b,S		; C3 C3 ; Compare accumulator (stack relative) $C3.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	sta $AE.b		; 85 AE ; Store accumulator to $AE.b [Reads: Accumulator]
	mvp $86,$44		; 44 44 86 ; Move block positive $86,$44 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $1D87.w,X		; 1D 87 1D ; OR accumulator with memory $1D87.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($D3.b)		; D2 D3 ; Compare accumulator (indirect) ($D3.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	pei ($89.b)		; D4 89 ; Push effective indirect address ($89.b) [Reads: Direct Page] [Writes: Stack Pointer]
	ora $301D.w,X		; 1D 1D 30 ; OR accumulator with memory $301D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	sty $1D8D.w		; 8C 8D 1D ; Store Y register to $1D8D.w [Reads: Y Index]
	ora $65D2.w,X		; 1D D2 65 ; OR accumulator with memory $65D2.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	stx $4C0A.w		; 8E 0A 4C ; Store X register to $4C0A.w [Reads: X Index]
	lda ($AD.b,X)		; A1 AD ; Load accumulator ($AD.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	jsr $9594.w		; 20 94 95 ; Jump to subroutine at $9594.w [Writes: Stack Pointer] [Flow: call]
	ora $961D.w,X		; 1D 1D 96 ; OR accumulator with memory $961D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta [$22.b],Y		; 97 22 ; Store accumulator (long indexed) [$22.b],Y [Reads: Direct Page, Y Index, Accumulator]
	ora $9809.w,X		; 1D 09 98 ; OR accumulator with memory $9809.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $9A1D.w,Y		; 99 1D 9A ; Store accumulator to $9A1D.w,Y [Reads: Y Index, Accumulator]
	lda $9B.b,X		; B5 9B ; Load $9B.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	stz $1D9D.w		; 9C 9D 1D ; Store zero to $1D9D.w
	.db $62, $9E, $22		; 62 9E 22 ; Push effective relative address $62, $9E, $22 [Writes: Stack Pointer]
	ora $A165.w,X		; 1D 65 A1 ; OR accumulator with memory $A165.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	lda [$A8.b]		; A7 A8 ; Load accumulator (long) [$A8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $501D.w,X		; 1D 1D 50 ; OR accumulator with memory $501D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda #$1D.b		; A9 1D ; Load #$1D.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $AA62.w,X		; 1D 62 AA ; OR accumulator with memory $AA62.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cop $87.b		; 02 87 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $62CE.w,X		; 3E CE 62 ; Rotate left $62CE.w,X [Reads: X Index] [Flags: NCZ]
	lda $F202.w		; AD 02 F2 ; Load $F202.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $6295.w,X		; 1D 95 62 ; OR accumulator with memory $6295.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $03		; B0 03 ; Branch if carry set to $B0, $03 [Flow: branch]
	.db $F0, $B3		; F0 B3 ; Branch if equal to $F0, $B3 [Flow: branch]
	ldy $A8.b,X		; B4 A8 ; Load Y register $A8.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	.db $62, $B5, $03		; 62 B5 03 ; Push effective relative address $62, $B5, $03 [Writes: Stack Pointer]
	dec $B8.b,X		; D6 B8 ; Decrement memory $B8.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	brk $B9.b		; 00 B9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $56121D.l		; 22 1D 12 56 ; Jump to subroutine long $56121D.l [Writes: Stack Pointer] [Flow: call]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	sbc $A8BB.w,Y		; F9 BB A8 ; Subtract with carry $A8BB.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $A11D.w,X		; 1D 1D A1 ; OR accumulator with memory $A11D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	sbc $84.b,X		; F5 84 ; Subtract $84.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $1DF2BC.l		; 0F BC F2 1D ; OR accumulator with memory (long) $1DF2BC.l [Writes: Accumulator] [Flags: NZ]
	ora $BD4C.w,X		; 1D 4C BD ; OR accumulator with memory $BD4C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldx $1D22.w,Y		; BE 22 1D ; Load X register $1D22.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	cop $BF.b		; 02 BF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $62.b,X		; B5 62 ; Load $62.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lda $B93A03.l,X		; BF 03 3A B9 ; Load long $B93A03.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	ldy $C222.w		; AC 22 C2 ; Load $C222.w into Y register [Writes: Y Index] [Flags: NZ]
	asl $A0.b		; 06 A0 ; Arithmetic shift left $A0.b [Reads: Direct Page] [Flags: NCZ]
	ora $C394.w,X		; 1D 94 C3 ; OR accumulator with memory $C394.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy $9B.b		; C4 9B ; Compare $9B.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	.db $B0, $65		; B0 65 ; Branch if carry set to $B0, $65 [Flow: branch]
	cmp $22.b		; C5 22 ; Compare $22.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	.db $62, $A9, $62		; 62 A9 62 ; Push effective relative address $62, $A9, $62 [Writes: Stack Pointer]
	wai		; CB ; Wait for interrupt
	ora $CE78.w,Y		; 19 78 CE ; OR accumulator with memory $CE78.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $90, $C8		; 90 C8 ; Branch if carry clear to $90, $C8 [Flow: branch]
	cmp [$BD.b]		; C7 BD ; Compare accumulator (long) [$BD.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ldx $CF05.w,Y		; BE 05 CF ; Load X register $CF05.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	.db $D0, $C9		; D0 C9 ; Branch if not equal to $D0, $C9 [Flow: branch]
	cmp ($D2.b),Y		; D1 D2 ; Compare accumulator ($D2.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cmp #$79.b		; C9 79 ; Compare #$79.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	ldx $8F78.w		; AE 78 8F ; Load $8F78.w into X register [Writes: X Index] [Flags: NZ]
	cmp ($C2.b,S),Y		; D3 C2 ; Compare accumulator (stack relative indirect indexed) ($C2.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	pei ($D5.b)		; D4 D5 ; Push effective indirect address ($D5.b) [Reads: Direct Page] [Writes: Stack Pointer]
	ora ($8F.b),Y		; 11 8F ; OR accumulator with memory ($8F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $BB, $03		; 62 BB 03 ; Push effective relative address $62, $BB, $03 [Writes: Stack Pointer]
	dec $B0.b,X		; D6 B0 ; Decrement memory $B0.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	ora ($83.b),Y		; 11 83 ; OR accumulator with memory ($83.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $220000.l,X		; FF 00 00 22 ; Subtract with carry (long,X) $220000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $24.b,S		; 03 24 ; OR accumulator with stack relative $24.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $23.b,S		; 03 23 ; OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $2B.b,S		; 03 2B ; OR accumulator with stack relative $2B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $03.b,S		; 23 03 ; AND accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	and $22.b,X		; 35 22 ; Logical AND $22.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ora $010022.l,X		; 1F 22 00 01 ; Logical OR long $010022.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $24.b,S		; 03 24 ; OR accumulator with stack relative $24.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $23.b,S		; 03 23 ; OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $27.b,S		; 03 27 ; OR accumulator with stack relative $27.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $030000.l		; 22 00 00 03 ; Jump to subroutine long $030000.l [Writes: Stack Pointer] [Flow: call]
	jsl $030100.l		; 22 00 01 03 ; Jump to subroutine long $030100.l [Writes: Stack Pointer] [Flow: call]
	ora $23.b,S		; 03 23 ; OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0A.b,S		; 03 0A ; OR accumulator with stack relative $0A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $23.b		; 04 23 ; Test and set bits $23.b [Reads: Accumulator] [Flags: Z]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $040500.l		; 22 00 05 04 ; Jump to subroutine long $040500.l [Writes: Stack Pointer] [Flow: call]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	tsb $23.b		; 04 23 ; Test and set bits $23.b [Reads: Accumulator] [Flags: Z]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $04.b		; 26 04 ; Rotate left $04.b [Reads: Direct Page] [Flags: NCZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $23.b		; 04 23 ; Test and set bits $23.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $23.b		; 04 23 ; Test and set bits $23.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $23.b		; 04 23 ; Test and set bits $23.b [Reads: Accumulator] [Flags: Z]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	lda $00.b,S		; A3 00 ; Load accumulator (stack relative) $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $23.b		; 04 23 ; Test and set bits $23.b [Reads: Accumulator] [Flags: Z]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9E.b		; 00 9E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $D7, $16		; 62 D7 16 ; Push effective relative address $62, $D7, $16 [Writes: Stack Pointer]
	cmp [$C8.b]		; C7 C8 ; Compare accumulator (long) [$C8.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora $D796.w,X		; 1D 96 D7 ; OR accumulator with memory $D796.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	trb $0B.b		; 14 0B ; Test and reset bits $0B.b [Reads: Accumulator] [Flags: Z]
	ora #$0A.b		; 09 0A ; Logical OR #$0A.b with accumulator [Writes: Accumulator] [Flags: NZ]
	stz $61.b,X		; 74 61 ; Store zero to $61.b,X [Reads: X Index]
	ora [$35.b]		; 07 35 ; OR accumulator with memory (long) [$35.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	ora $D796.w,X		; 1D 96 D7 ; OR accumulator with memory $D796.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$43.b		; 29 43 ; Logical AND #$43.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ror $9334.w,X		; 7E 34 93 ; Rotate right $9334.w,X [Reads: X Index] [Flags: NCZ]
	.db $62, $06, $18		; 62 06 18 ; Push effective relative address $62, $06, $18 [Writes: Stack Pointer]
	sty $DC.b,X		; 94 DC ; Store Y register $DC.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $1D1F.w,X		; DD 1F 1D ; Compare accumulator $1D1F.w,X [Reads: X Index] [Flags: NCZ]
	ror $DE0D.w,X		; 7E 0D DE ; Rotate right $DE0D.w,X [Reads: X Index] [Flags: NCZ]
	ror $113E.w,X		; 7E 3E 11 ; Rotate right $113E.w,X [Reads: X Index] [Flags: NCZ]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	tsb $3B.b		; 04 3B ; Test and set bits $3B.b [Reads: Accumulator] [Flags: Z]
	cmp $D80C09.l,X		; DF 09 0C D8 ; Compare accumulator (long,X) $D80C09.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	cmp [$C8.b]		; C7 C8 ; Compare accumulator (long) [$C8.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	eor $37.b,X		; 55 37 ; Exclusive OR accumulator with memory $37.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc $E0.b,S		; 63 E0 ; Add with carry (stack relative) $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$24.b		; E0 24 ; Compare #$24.b with X register [Reads: X Index] [Flags: NCZ]
	.db $30, $09		; 30 09 ; Branch if minus to $30, $09 [Flow: branch]
	cpx $E5.b		; E4 E5 ; Compare $E5.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	cmp $3507.w,Y		; D9 07 35 ; Compare accumulator $3507.w,Y [Reads: Y Index] [Flags: NCZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	inc $D7.b		; E6 D7 ; Increment $D7.b [Reads: Direct Page] [Flags: NZ]
	lsr $96A5.w		; 4E A5 96 ; Logical shift right $96A5.w [Flags: NCZ]
	lda $E74F1D.l,X		; BF 1D 4F E7 ; Load long $E74F1D.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $82, $35, $E8		; 82 35 E8 ; Branch always long to $82, $35, $E8 [Flow: branch]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc #$B9.b		; E9 B9 ; Subtract #$B9.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	nop		; EA ; No operation
	nop		; EA ; No operation
	and [$EB.b]		; 27 EB ; AND accumulator with memory (long) [$EB.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jmp $ECD9E5.l		; 5C E5 D9 EC ; Jump long to $ECD9E5.l [Flow: jump]
	sbc $03.b,S		; E3 03 ; Subtract stack-relative $03.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	sbc $626B.w		; ED 6B 62 ; Subtract $626B.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ora #$E0.b		; 09 E0 ; Logical OR #$E0.b with accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DEE09.l		; 22 09 EE 0D ; Jump to subroutine long $0DEE09.l [Writes: Stack Pointer] [Flow: call]
	and ($DF.b)		; 32 DF ; AND accumulator with memory (indirect) ($DF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	stz $EF.b		; 64 EF ; Store zero to $EF.b
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpx BG3SC.w		; EC 09 21 ; Compare BG3SC.w with X register [Reads: X Index] [Flags: NCZ]
	adc $6B.b,S		; 63 6B ; Add with carry (stack relative) $6B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $1A		; F0 1A ; Branch if equal to $F0, $1A [Flow: branch]
	sbc ($F2.b),Y		; F1 F2 ; Subtract with carry ($F2.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	stx $F0.b		; 86 F0 ; Store X register to $F0.b [Reads: X Index]
	sbc ($F3.b),Y		; F1 F3 ; Subtract with carry ($F3.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $F5F4.w		; 2D F4 F5 ; Logical AND $F5F4.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $0100.w,Y		; 39 00 01 ; AND accumulator with memory $0100.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $F6.b,S		; 83 F6 ; Store accumulator (stack relative) $F6.b,S [Reads: Stack Pointer, Accumulator]
	sbc [$C5.b],Y		; F7 C5 ; Subtract with carry (long indexed) [$C5.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $F8.b,S		; 63 F8 ; Add with carry (stack relative) $F8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	brk $6B.b		; 00 6B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $FC.b,S		; 63 FC ; Add with carry (stack relative) $FC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $0900.w,X		; 1D 00 09 ; OR accumulator with memory $0900.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpx #$03.b		; E0 03 ; Compare #$03.b with X register [Reads: X Index] [Flags: NCZ]
	tsb $43.b		; 04 43 ; Test and set bits $43.b [Reads: Accumulator] [Flags: Z]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cpx $0A09.w		; EC 09 0A ; Compare $0A09.w with X register [Reads: X Index] [Flags: NCZ]
	stz $00.b,X		; 74 00 ; Store zero to $00.b,X [Reads: X Index]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor ($07.b,S),Y		; 53 07 ; XOR accumulator (stack relative indirect indexed) ($07.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	lsr $6309.w		; 4E 09 63 ; Logical shift right $6309.w [Flags: NCZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	wai		; CB ; Wait for interrupt
	.db $62, $0A, $04		; 62 0A 04 ; Push effective relative address $62, $0A, $04 [Writes: Stack Pointer]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0007.w		; 0D 07 00 ; Logical OR $0007.w with accumulator [Writes: Accumulator] [Flags: NZ]
	adc $0E.b,S		; 63 0E ; Add with carry (stack relative) $0E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora ($38.b,X)		; 01 38 ; Logical OR ($38.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $1262.w,Y		; 39 62 12 ; AND accumulator with memory $1262.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$2B.b		; E0 2B ; Compare #$2B.b with X register [Reads: X Index] [Flags: NCZ]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora #$0A.b		; 09 0A ; Logical OR #$0A.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $FA.b,X		; 15 FA ; OR accumulator with memory $FA.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	jsr $29D7.w		; 20 D7 29 ; Jump to subroutine at $29D7.w [Writes: Stack Pointer] [Flow: call]
	asl $29.b,X		; 16 29 ; Arithmetic shift left $29.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	and #$43.b		; 29 43 ; Logical AND #$43.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ldx $170E.w,Y		; BE 0E 17 ; Load X register $170E.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	.db $30, $09		; 30 09 ; Branch if minus to $30, $09 [Flow: branch]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sty $20.b,X		; 94 20 ; Store Y register $20.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $35.b,X		; 34 35 ; Test bits $35.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	adc [$19.b]		; 67 19 ; Add with carry (long) [$19.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	dec $0020.w,X		; DE 20 00 ; Decrement memory $0020.w,X [Reads: X Index] [Flags: NZ]
	sbc ($F4.b,S),Y		; F3 F4 ; Subtract with carry (stack relative indirect indexed) ($F4.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($1A.b,X)		; 01 1A ; Logical OR ($1A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	clv		; B8 ; Clear overflow flag [Flags: V]
	trb $3F1D.w		; 1C 1D 3F ; Test and reset bits $3F1D.w [Reads: Accumulator] [Flags: Z]
	cop $6F.b		; 02 6F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $1E.b,S		; 63 1E ; Add with carry (stack relative) $1E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ldx $7405.w,Y		; BE 05 74 ; Load X register $7405.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	jsl $23090B.l		; 22 0B 09 23 ; Jump to subroutine long $23090B.l [Writes: Stack Pointer] [Flow: call]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	.db $30, $09		; 30 09 ; Branch if minus to $30, $09 [Flow: branch]
	sbc $230122.l,X		; FF 22 01 23 ; Subtract with carry (long,X) $230122.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $26.b		; 04 26 ; Test and set bits $26.b [Reads: Accumulator] [Flags: Z]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $45.b		; 00 45 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $04.b,S		; 23 04 ; AND accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	brk $29.b		; 00 29 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $25.b		; 04 25 ; Test and set bits $25.b [Reads: Accumulator] [Flags: Z]
	brk $29.b		; 00 29 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	ora ($84.b,X)		; 01 84 ; Logical OR ($84.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $25.b		; 00 25 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $030104.l		; 22 04 01 03 ; Jump to subroutine long $030104.l [Writes: Stack Pointer] [Flow: call]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	jsl $000004.l		; 22 04 00 00 ; Jump to subroutine long $000004.l [Writes: Stack Pointer] [Flow: call]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	tsb $83.b		; 04 83 ; Test and set bits $83.b [Reads: Accumulator] [Flags: Z]
	brk $42.b		; 00 42 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $23.b,S		; 03 23 ; OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $84.b		; 04 84 ; Test and set bits $84.b [Reads: Accumulator] [Flags: Z]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $040200.l		; 22 00 02 04 ; Jump to subroutine long $040200.l [Writes: Stack Pointer] [Flow: call]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $030200.l		; 22 00 02 03 ; Jump to subroutine long $030200.l [Writes: Stack Pointer] [Flow: call]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $04.b,S		; 43 04 ; Exclusive OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	sta ($01.b),Y		; 91 01 ; Store accumulator ($01.b),Y [Reads: Direct Page, Y Index, Accumulator]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $042300.l		; 22 00 23 04 ; Jump to subroutine long $042300.l [Writes: Stack Pointer] [Flow: call]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $2E.b		; 04 2E ; Test and set bits $2E.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $6162.w		; 0C 62 61 ; Test and set bits $6162.w [Reads: Accumulator] [Flags: Z]
	.db $62, $A5, $96		; 62 A5 96 ; Push effective relative address $62, $A5, $96 [Writes: Stack Pointer]
	ora $241D.w,X		; 1D 1D 24 ; OR accumulator with memory $241D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $1425D7.l,X		; 1F D7 25 14 ; Logical OR long $1425D7.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	.db $62, $09, $0B		; 62 09 0B ; Push effective relative address $62, $09, $0B [Writes: Stack Pointer]
	rol $DC.b		; 26 DC ; Rotate left $DC.b [Reads: Direct Page] [Flags: NCZ]
	rol $DE.b		; 26 DE ; Rotate left $DE.b [Reads: Direct Page] [Flags: NCZ]
	and [$FF.b]		; 27 FF ; AND accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda ($4B.b,S),Y		; B3 4B ; Load accumulator (stack relative indirect indexed) ($4B.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	ror $9334.w,X		; 7E 34 93 ; Rotate right $9334.w,X [Reads: X Index] [Flags: NCZ]
	.db $62, $06, $0D		; 62 06 0D ; Push effective relative address $62, $06, $0D [Writes: Stack Pointer]
	asl $29.b		; 06 29 ; Arithmetic shift left $29.b [Reads: Direct Page] [Flags: NCZ]
	cmp $22AA29.l,X		; DF 29 AA 22 ; Compare accumulator (long,X) $22AA29.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	stz $BF.b,X		; 74 BF ; Store zero to $BF.b,X [Reads: X Index]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lda $3F3E7E.l,X		; BF 7E 3E 3F ; Load long $3F3E7E.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cop $62.b		; 02 62 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	cmp [$2C.b]		; C7 2C ; Compare accumulator (long) [$2C.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	and $2EA5.w		; 2D A5 2E ; Logical AND $2EA5.w with accumulator [Writes: Accumulator] [Flags: NZ]
	inc $7E.b		; E6 7E ; Increment $7E.b [Reads: Direct Page] [Flags: NZ]
	and $00834A.l		; 2F 4A 83 00 ; AND accumulator with memory (long) $00834A.l [Writes: Accumulator] [Flags: NZ]
	tsb $6503.w		; 0C 03 65 ; Test and set bits $6503.w [Reads: Accumulator] [Flags: Z]
	.db $62, $43, $1D		; 62 43 1D ; Push effective relative address $62, $43, $1D [Writes: Stack Pointer]
	adc $30.b,S		; 63 30 ; Add with carry (stack relative) $30.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora ($1D.b,X)		; 01 1D ; Logical OR ($1D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ror $3462.w,X		; 7E 62 34 ; Rotate right $3462.w,X [Reads: X Index] [Flags: NCZ]
	cop $82.b		; 02 82 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $69.b		; 06 69 ; Arithmetic shift left $69.b [Reads: Direct Page] [Flags: NCZ]
	and [$07.b],Y		; 37 07 ; AND accumulator with memory (long indexed) [$07.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and [$37.b],Y		; 37 37 ; AND accumulator with memory (long indexed) [$37.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor [$3E.b]		; 47 3E ; Exclusive OR accumulator with memory (long) [$3E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $3D4102.l,X		; 3F 02 41 3D ; AND accumulator with memory (long,X) $3D4102.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc [$42.b]		; 67 42 ; Add with carry (long) [$42.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $43.b		; 05 43 ; Logical OR $43.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	mvp $4A,$55		; 44 55 4A ; Move block positive $4A,$55 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	.db $62, $4B, $02		; 62 4B 02 ; Push effective relative address $62, $4B, $02 [Writes: Stack Pointer]
	dec $377E.w,X		; DE 7E 37 ; Decrement memory $377E.w,X [Reads: X Index] [Flags: NZ]
	adc $4E.b,S		; 63 4E ; Add with carry (stack relative) $4E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	asl $4E.b		; 06 4E ; Arithmetic shift left $4E.b [Reads: Direct Page] [Flags: NCZ]
	eor ($9F.b)		; 52 9F ; Exclusive OR accumulator with memory (indirect) ($9F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror $0605.w,X		; 7E 05 06 ; Rotate right $0605.w,X [Reads: X Index] [Flags: NCZ]
	ror $5362.w,X		; 7E 62 53 ; Rotate right $5362.w,X [Reads: X Index] [Flags: NCZ]
	cop $7E.b		; 02 7E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($3D.b,X)		; 41 3D ; Exclusive OR accumulator with memory ($3D.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $56, $00		; 62 56 00 ; Push effective relative address $62, $56, $00 [Writes: Stack Pointer]
	.db $10, $62		; 10 62 ; Branch if plus to $10, $62 [Flow: branch]
	eor $E805.w,Y		; 59 05 E8 ; Exclusive OR accumulator with memory $E805.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cop $18.b		; 02 18 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp $63E046.l		; 5C 46 E0 63 ; Jump long to $63E046.l [Flow: jump]
	eor $6204.w,X		; 5D 04 62 ; Exclusive OR accumulator with memory $6204.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc ($4E.b,X)		; 61 4E ; Add with carry ($4E.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $62EE.w,X		; 1D EE 62 ; OR accumulator with memory $62EE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$E0.b		; 09 E0 ; Logical OR #$E0.b with accumulator [Writes: Accumulator] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	ora ($DB.b)		; 12 DB ; OR accumulator with memory (indirect) ($DB.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $62, $B3, $2D		; 62 B3 2D ; Push effective relative address $62, $B3, $2D [Writes: Stack Pointer]
	sbc $6337.w,Y		; F9 37 63 ; Subtract with carry $6337.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $CDF3.w,X		; 1D F3 CD ; OR accumulator with memory $CDF3.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	stz $F5.b		; 64 F5 ; Store zero to $F5.b
	adc $93.b		; 65 93 ; Add $93.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: NCZ]
	cmp $6766.w,X		; DD 66 67 ; Compare accumulator $6766.w,X [Reads: X Index] [Flags: NCZ]
	cmp [$C8.b]		; C7 C8 ; Compare accumulator (long) [$C8.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora $FC1D.w,X		; 1D 1D FC ; OR accumulator with memory $FC1D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $1C83.w,X		; FD 83 1C ; Subtract with carry $1C83.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	cmp ($01.b),Y		; D1 01 ; Compare accumulator ($01.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cop $D7.b		; 02 D7 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cld		; D8 ; Clear decimal flag [Flags: D]
	jsr $D796.w		; 20 96 D7 ; Jump to subroutine at $D796.w [Writes: Stack Pointer] [Flow: call]
	and #$68.b		; 29 68 ; Logical AND #$68.b with accumulator [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc #$14.b		; 69 14 ; Add #$14.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sty $846A.w		; 8C 6A 84 ; Store Y register to $846A.w [Reads: Y Index]
	brk $9C.b		; 00 9C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $20436B.l		; 0F 6B 43 20 ; OR accumulator with memory (long) $20436B.l [Writes: Accumulator] [Flags: NZ]
	ror $1234.w,X		; 7E 34 12 ; Rotate right $1234.w,X [Reads: X Index] [Flags: NCZ]
	pea $086C.w		; F4 6C 08 ; Push absolute address $086C.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	.db $F0, $64		; F0 64 ; Branch if equal to $F0, $64 [Flow: branch]
	sbc $65.b,X		; F5 65 ; Subtract $65.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	adc $6D.b,S		; 63 6D ; Add with carry (stack relative) $6D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora ($59.b,X)		; 01 59 ; Logical OR ($59.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $2C.b		; 00 2C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $71.b		; 05 71 ; Logical OR $71.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc ($D1.b)		; 72 D1 ; Add with carry (indirect) ($D1.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	tsb $0900.w		; 0C 00 09 ; Test and set bits $0900.w [Reads: Accumulator] [Flags: Z]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	adc ($62.b,S),Y		; 73 62 ; Add with carry (stack relative indirect indexed) ($62.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora #$FF.b		; 09 FF ; Logical OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $030202.l		; 22 02 02 03 ; Jump to subroutine long $030202.l [Writes: Stack Pointer] [Flow: call]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $01.b		; 24 01 ; Test bits $01.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	mvp $01,$04		; 44 04 01 ; Move block positive $01,$04 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	jsl $030202.l		; 22 02 02 03 ; Jump to subroutine long $030202.l [Writes: Stack Pointer] [Flow: call]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $030B01.l		; 22 01 0B 03 ; Jump to subroutine long $030B01.l [Writes: Stack Pointer] [Flow: call]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $010103.l		; 22 03 01 01 ; Jump to subroutine long $010103.l [Writes: Stack Pointer] [Flow: call]
	ora $62.b,S		; 03 62 ; OR accumulator with stack relative $62.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $23.b,S		; 03 23 ; OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $83.b,S		; 03 83 ; OR accumulator with stack relative $83.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $26.b,S		; 03 26 ; OR accumulator with stack relative $26.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $01.b		; 25 01 ; Logical AND $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $83.b		; 02 83 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	bit $0403.w		; 2C 03 04 ; Test bits $0403.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $84.b		; 00 84 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2D.b		; 00 2D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl L000304.l		; 22 04 83 00 ; Jump to subroutine long L000304.l [Writes: Stack Pointer] [Flow: call]
	eor [$0A.b]		; 47 0A ; Exclusive OR accumulator with memory (long) [$0A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $23.b,S		; 03 23 ; OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	cop $44.b		; 02 44 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $040200.l		; 22 00 02 04 ; Jump to subroutine long $040200.l [Writes: Stack Pointer] [Flow: call]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	and $04.b,S		; 23 04 ; AND accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $83.b		; 04 83 ; Test and set bits $83.b [Reads: Accumulator] [Flags: Z]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	jsl $010103.l		; 22 03 01 01 ; Jump to subroutine long $010103.l [Writes: Stack Pointer] [Flow: call]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $86.b		; 04 86 ; Test and set bits $86.b [Reads: Accumulator] [Flags: Z]
	brk $71.b		; 00 71 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $04.b		; 26 04 ; Rotate left $04.b [Reads: Direct Page] [Flags: NCZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $04.b		; 25 04 ; Logical AND $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	and [$04.b]		; 27 04 ; AND accumulator with memory (long) [$04.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $040101.l		; 22 01 01 04 ; Jump to subroutine long $040101.l [Writes: Stack Pointer] [Flow: call]
	tsb $FF.b		; 04 FF ; Test and set bits $FF.b [Reads: Accumulator] [Flags: Z]
	tsb $ED.b		; 04 ED ; Test and set bits $ED.b [Reads: Accumulator] [Flags: Z]
	sbc $F974.w		; ED 74 F9 ; Subtract $F974.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sbc $020322.l,X		; FF 22 03 02 ; Subtract with carry (long,X) $020322.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $F8.b		; 24 F8 ; Test bits $F8.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	tsb $75.b		; 04 75 ; Test and set bits $75.b [Reads: Accumulator] [Flags: Z]
	sbc $F976.w		; ED 76 F9 ; Subtract $F976.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	adc [$22.b],Y		; 77 22 ; Add with carry (long indexed) [$22.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	sbc $78.b		; E5 78 ; Subtract $78.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jsl $7B13F8.l		; 22 F8 13 7B ; Jump to subroutine long $7B13F8.l [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	dec $86.b,X		; D6 86 ; Decrement memory $86.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	adc $561D.w,Y		; 79 1D 56 ; Add $561D.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor [$03.b],Y		; 57 03 ; Exclusive OR accumulator with memory (long indexed) [$03.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $7A.b,S		; 03 7A ; OR accumulator with stack relative $7A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	lda #$72.b		; A9 72 ; Load #$72.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sed		; F8 ; Set decimal flag [Flags: D]
	dec $DD.b,X		; D6 DD ; Decrement memory $DD.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	jsl $56131D.l		; 22 1D 13 56 ; Jump to subroutine long $56131D.l [Writes: Stack Pointer] [Flow: call]
	eor [$03.b],Y		; 57 03 ; Exclusive OR accumulator with memory (long indexed) [$03.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jmp ($7676.w,X)		; 7C 76 76 ; Jump indirect indexed to ($7676.w,X) [Reads: X Index] [Flow: jump]
	adc [$F8.b],Y		; 77 F8 ; Add with carry (long indexed) [$F8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($09.b),Y		; 71 09 ; Add with carry ($09.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($7D.b)		; 72 7D ; Add with carry (indirect) ($7D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($AB.b,S),Y		; F3 AB ; Subtract with carry (stack relative indirect indexed) ($AB.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($A2.b)		; F2 A2 ; Subtract with carry (indirect) ($A2.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $5756.w,X		; 1D 56 57 ; OR accumulator with memory $5756.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	and $F8.b,S		; 23 F8 ; AND accumulator with stack relative $F8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $62, $75, $08		; 62 75 08 ; Push effective relative address $62, $75, $08 [Writes: Stack Pointer]
	jmp ($B37E.w)		; 6C 7E B3 ; Jump indirect to ($B37E.w) [Flow: jump]
	adc $DB8061.l,X		; 7F 61 80 DB ; Add long $DB8061.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr $BA.b,X		; 56 BA ; Logical shift right $BA.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	rol $E5.b		; 26 E5 ; Rotate left $E5.b [Reads: Direct Page] [Flags: NCZ]
	ora ($6C.b,X)		; 01 6C ; Logical OR ($6C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jmp ($1522.w)		; 6C 22 15 ; Jump indirect to ($1522.w) [Flow: jump]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	asl $E6.b,X		; 16 E6 ; Arithmetic shift left $E6.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	ora $9F1D.w,X		; 1D 1D 9F ; OR accumulator with memory $9F1D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $0881.w,X		; 1D 81 08 ; OR accumulator with memory $0881.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	lda ($6C.b)		; B2 6C ; Load accumulator (indirect) ($6C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jmp ($8215.w)		; 6C 15 82 ; Jump indirect to ($8215.w) [Flow: jump]
	sta $16.b,S		; 83 16 ; Store accumulator (stack relative) $16.b,S [Reads: Stack Pointer, Accumulator]
	ora $84.b,S		; 03 84 ; OR accumulator with stack relative $84.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $1DA2.w,X		; 1D A2 1D ; OR accumulator with memory $1DA2.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $86.b		; 85 86 ; Store accumulator to $86.b [Reads: Accumulator]
	sbc $E6.b		; E5 E6 ; Subtract $E6.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $62, $87, $15		; 62 87 15 ; Push effective relative address $62, $87, $15 [Writes: Stack Pointer]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc ($23.b,X)		; 61 23 ; Add with carry ($23.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $8A.b		; 24 8A ; Test bits $8A.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ldx #$A2.b		; A2 A2 ; Load #$A2.b into X register [Writes: X Index] [Flags: NZ]
	ora $A88B.w,X		; 1D 8B A8 ; OR accumulator with memory $A88B.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $E5E4.w,X		; 1D E4 E5 ; OR accumulator with memory $E5E4.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sty $1DA8.w		; 8C A8 1D ; Store Y register to $1DA8.w [Reads: Y Index]
	lda ($1D.b)		; B2 1D ; Load accumulator (indirect) ($1D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $8A2E.w,X		; 1D 2E 8A ; OR accumulator with memory $8A2E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $8D63.w,X		; 1D 63 8D ; OR accumulator with memory $8D63.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $A2.b		; 05 A2 ; Logical OR $A2.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc ($1D.b)		; F2 1D ; Subtract with carry (indirect) ($1D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $1D.b,S		; E3 1D ; Subtract stack-relative $1D.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	ldx #$22.b		; A2 22 ; Load #$22.b into X register [Writes: X Index] [Flags: NZ]
	ora $9102.w,X		; 1D 02 91 ; OR accumulator with memory $9102.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta ($B2.b)		; 92 B2 ; Store accumulator (indirect) ($B2.b) [Reads: Direct Page, Accumulator]
	adc $93.b,S		; 63 93 ; Add with carry (stack relative) $93.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora ($FA.b,S),Y		; 13 FA ; OR accumulator (stack relative indirect indexed) ($FA.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	.db $F0, $E3		; F0 E3 ; Branch if equal to $F0, $E3 [Flow: branch]
	ora $1D1C.w,X		; 1D 1C 1D ; OR accumulator with memory $1D1C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldx #$1D.b		; A2 1D ; Load #$1D.b into X register [Writes: X Index] [Flags: NZ]
	sta [$03.b],Y		; 97 03 ; Store accumulator (long indexed) [$03.b],Y [Reads: Direct Page, Y Index, Accumulator]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	stz $986C.w		; 9C 6C 98 ; Store zero to $986C.w
	adc [$5A.b],Y		; 77 5A ; Add with carry (long indexed) [$5A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $2295.w,Y		; F9 95 22 ; Subtract with carry $2295.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	brk $99.b		; 00 99 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	eor $0D.b		; 45 0D ; Exclusive OR $0D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	stz $9A88.w		; 9C 88 9A ; Store zero to $9A88.w
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	sbc $9D9C.w,Y		; F9 9C 9D ; Subtract with carry $9D9C.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lda ($B3.b,S),Y		; B3 B3 ; Load accumulator (stack relative indirect indexed) ($B3.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	stz $1DA0.w,X		; 9E A0 1D ; Store zero to $1DA0.w,X [Reads: X Index]
	lsr $66.b,X		; 56 66 ; Logical shift right $66.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sta $62AB00.l,X		; 9F 00 AB 62 ; Store accumulator (long,X) $62AB00.l,X [Reads: Accumulator, X Index]
	ldx $62.b		; A6 62 ; Load $62.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ldy #$62.b		; A0 62 ; Load #$62.b into Y register [Writes: Y Index] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsl $AE01AB.l		; 22 AB 01 AE ; Jump to subroutine long $AE01AB.l [Writes: Stack Pointer] [Flow: call]
	lda ($66.b,S),Y		; B3 66 ; Load accumulator (stack relative indirect indexed) ($66.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $07AA03.l		; AF 03 AA 07 ; Load long $07AA03.l into accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$B6.b]		; 07 B6 ; OR accumulator with memory (long) [$B6.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $B701B3.l		; 22 B3 01 B7 ; Jump to subroutine long $B701B3.l [Writes: Stack Pointer] [Flow: call]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	sbc $000125.l,X		; FF 25 01 00 ; Subtract with carry (long,X) $000125.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $2E.b,S		; 03 2E ; OR accumulator with stack relative $2E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $2E.b,S		; 03 2E ; OR accumulator with stack relative $2E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $2A.b		; 04 2A ; Test and set bits $2A.b [Reads: Accumulator] [Flags: Z]
	ora ($44.b,X)		; 01 44 ; Logical OR ($44.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $28.b,S		; 03 28 ; OR accumulator with stack relative $28.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $012603.l		; 22 03 26 01 ; Jump to subroutine long $012603.l [Writes: Stack Pointer] [Flow: call]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $002404.l		; 22 04 24 00 ; Jump to subroutine long $002404.l [Writes: Stack Pointer] [Flow: call]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	jsl $040001.l		; 22 01 00 04 ; Jump to subroutine long $040001.l [Writes: Stack Pointer] [Flow: call]
	bit $01.b		; 24 01 ; Test bits $01.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora $02.b		; 05 02 ; Logical OR $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	tsb $83.b		; 04 83 ; Test and set bits $83.b [Reads: Accumulator] [Flags: Z]
	brk $42.b		; 00 42 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $42.b		; 00 42 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $02.b		; 24 02 ; Test bits $02.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	tsb $83.b		; 04 83 ; Test and set bits $83.b [Reads: Accumulator] [Flags: Z]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $04.b		; 45 04 ; Exclusive OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl L000304.l		; 22 04 83 00 ; Jump to subroutine long L000304.l [Writes: Stack Pointer] [Flow: call]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $23.b		; 04 23 ; Test and set bits $23.b [Reads: Accumulator] [Flags: Z]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $01.b		; 25 01 ; Logical AND $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $23.b		; 04 23 ; Test and set bits $23.b [Reads: Accumulator] [Flags: Z]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	cop $25.b		; 02 25 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $23.b		; 04 23 ; Test and set bits $23.b [Reads: Accumulator] [Flags: Z]
	cop $29.b		; 02 29 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $FF.b		; 04 FF ; Test and set bits $FF.b [Reads: Accumulator] [Flags: Z]
	asl $F8.b		; 06 F8 ; Arithmetic shift left $F8.b [Reads: Direct Page] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $F8F8.w		; ED F8 F8 ; Subtract $F8F8.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sbc $F8245A.l,X		; FF 5A 24 F8 ; Subtract with carry (long,X) $F8245A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $F82203.l		; 22 03 22 F8 ; Jump to subroutine long $F82203.l [Writes: Stack Pointer] [Flow: call]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	cop $24.b		; 02 24 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsl $F82203.l		; 22 03 22 F8 ; Jump to subroutine long $F82203.l [Writes: Stack Pointer] [Flow: call]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $F8.b		; E5 F8 ; Subtract $F8.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsl $F82203.l		; 22 03 22 F8 ; Jump to subroutine long $F82203.l [Writes: Stack Pointer] [Flow: call]
	ora #$ED.b		; 09 ED ; Logical OR #$ED.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $71F85A.l,X		; FF 5A F8 71 ; Subtract with carry (long,X) $71F85A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda #$72.b		; A9 72 ; Load #$72.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsl $F82203.l		; 22 03 22 F8 ; Jump to subroutine long $F82203.l [Writes: Stack Pointer] [Flow: call]
	ora $ED.b		; 05 ED ; Logical OR $ED.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $B8.b		; E5 B8 ; Subtract $B8.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc [$5A.b],Y		; 77 5A ; Add with carry (long indexed) [$5A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $62, $75, $00		; 62 75 00 ; Push effective relative address $62, $75, $00 [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsl $F80703.l		; 22 03 07 F8 ; Jump to subroutine long $F80703.l [Writes: Stack Pointer] [Flow: call]
	sbc $E5.b		; E5 E5 ; Subtract $E5.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	lda $56BA.w,Y		; B9 BA 56 ; Load $56BA.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	bit $E5.b		; 24 E5 ; Test bits $E5.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	jsl $F80503.l		; 22 03 05 F8 ; Jump to subroutine long $F80503.l [Writes: Stack Pointer] [Flow: call]
	ora $B91D.w,X		; 1D 1D B9 ; OR accumulator with memory $B91D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ldy $1D24.w,X		; BC 24 1D ; Load Y register $1D24.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	asl $1DA2.w		; 0E A2 1D ; Arithmetic shift left $1DA2.w [Flags: NCZ]
	cpx $03.b		; E4 03 ; Compare $03.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $F8.b,S		; 03 F8 ; OR accumulator with stack relative $F8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	adc $1DBD.w,Y		; 79 BD 1D ; Add $1DBD.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx #$B9.b		; A2 B9 ; Load #$B9.b into X register [Writes: X Index] [Flags: NZ]
	ldx $221D.w,Y		; BE 1D 22 ; Load X register $221D.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ldx #$01.b		; A2 01 ; Load #$01.b into X register [Writes: X Index] [Flags: NZ]
	lda $0084E4.l,X		; BF E4 84 00 ; Load long $0084E4.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr $1D0E.w		; 4E 0E 1D ; Logical shift right $1D0E.w [Flags: NCZ]
	ora $79B9.w,X		; 1D B9 79 ; OR accumulator with memory $79B9.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$A2.b		; C0 A2 ; Compare #$A2.b with Y register [Reads: Y Index] [Flags: NCZ]
	ldx #$C1.b		; A2 C1 ; Load #$C1.b into X register [Writes: X Index] [Flags: NZ]
	rep #$8A		; C2 8A ; Reset processor status bits #$8A [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	ora $E5E4.w,X		; 1D E4 E5 ; OR accumulator with memory $E5E4.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	stx $22C3.w		; 8E C3 22 ; Store X register to $22C3.w [Reads: X Index]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $7A79.w		; 0D 79 7A ; Logical OR $7A79.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $1DA2.w,X		; 1D A2 1D ; OR accumulator with memory $1DA2.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $C5C4.w,X		; 1D C4 C5 ; OR accumulator with memory $C5C4.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda $941D1D.l,X		; BF 1D 1D 94 ; Load long $941D1D.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc [$7B.b]		; 67 7B ; Add with carry (long) [$7B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	.db $80, $0C		; 80 0C ; Branch always to $80, $0C [Flow: branch]
	lda $C608.w,Y		; B9 08 C6 ; Load $C608.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda $1DA28A.l,X		; BF 8A A2 1D ; Load long $1DA28A.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $989C.w,X		; 1D 9C 98 ; OR accumulator with memory $989C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp [$C8.b]		; C7 C8 ; Compare accumulator (long) [$C8.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	sta $03.b,S		; 83 03 ; Store accumulator (stack relative) $03.b,S [Reads: Stack Pointer, Accumulator]
	sbc $C7.b		; E5 C7 ; Subtract $C7.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	stx $AB23.w		; 8E 23 AB ; Store X register to $AB23.w [Reads: X Index]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lsr $B1.b,X		; 56 B1 ; Logical shift right $B1.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	adc ($61.b,X)		; 61 61 ; Add with carry ($61.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp #$7A.b		; C9 7A ; Compare #$7A.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora $B156.w,X		; 1D 56 B1 ; OR accumulator with memory $B156.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	and $B3.b,S		; 23 B3 ; AND accumulator with stack relative $B3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	trb $F2AB.w		; 1C AB F2 ; Test and reset bits $F2AB.w [Reads: Accumulator] [Flags: Z]
	ora $2256.w,X		; 1D 56 22 ; OR accumulator with memory $2256.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $A2A104.l		; 22 04 A1 A2 ; Jump to subroutine long $A2A104.l [Writes: Stack Pointer] [Flow: call]
	sbc ($56.b)		; F2 56 ; Subtract with carry (indirect) ($56.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jsl $A8CCCB.l		; 22 CB CC A8 ; Jump to subroutine long $A8CCCB.l [Writes: Stack Pointer] [Flow: call]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda ($FB.b,S),Y		; B3 FB ; Load accumulator (stack relative indirect indexed) ($FB.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc ($A2.b)		; F2 A2 ; Subtract with carry (indirect) ($A2.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $A11D.w,X		; 1D 1D A1 ; OR accumulator with memory $A11D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $05CE.w		; CD CE 05 ; Compare $05CE.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $CF62.w		; CD 62 CF ; Compare $CF62.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cop $A8.b		; 02 A8 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($05.b)		; D2 05 ; Compare accumulator (indirect) ($05.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	jsl $CD0607.l		; 22 07 06 CD ; Jump to subroutine long $CD0607.l [Writes: Stack Pointer] [Flow: call]
	lda $B5D4D3.l		; AF D3 D4 B5 ; Load long $B5D4D3.l into accumulator [Writes: Accumulator] [Flags: NZ]
	lda $AF.b,X		; B5 AF ; Load $AF.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $D5, $FF		; 62 D5 FF ; Push effective relative address $62, $D5, $FF [Writes: Stack Pointer]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($27.b,X)		; 01 27 ; Logical OR ($27.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	ora $23.b,S		; 03 23 ; OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($26.b,X)		; 01 26 ; Logical OR ($26.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $030301.l		; 22 01 03 03 ; Jump to subroutine long $030301.l [Writes: Stack Pointer] [Flow: call]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	ora ($26.b,X)		; 01 26 ; Logical OR ($26.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $01.b		; 24 01 ; Test bits $01.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($27.b,X)		; 01 27 ; Logical OR ($27.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	ora $25.b,S		; 03 25 ; OR accumulator with stack relative $25.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($29.b,X)		; 01 29 ; Logical OR ($29.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $26.b		; 04 26 ; Test and set bits $26.b [Reads: Accumulator] [Flags: Z]
	ora ($28.b,X)		; 01 28 ; Logical OR ($28.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ora $280000.l		; 0F 00 00 28 ; OR accumulator with memory (long) $280000.l [Writes: Accumulator] [Flags: NZ]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	brk $27.b		; 00 27 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($43.b,X)		; 01 43 ; Logical OR ($43.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $05.b,S		; 23 05 ; AND accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $25.b		; 04 25 ; Test and set bits $25.b [Reads: Accumulator] [Flags: Z]
	ora $83.b		; 05 83 ; Logical OR $83.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $32.b		; 00 32 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and [$05.b]		; 27 05 ; AND accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $23.b		; 04 23 ; Test and set bits $23.b [Reads: Accumulator] [Flags: Z]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	jsl $040005.l		; 22 05 00 04 ; Jump to subroutine long $040005.l [Writes: Stack Pointer] [Flow: call]
	jsl $042205.l		; 22 05 22 04 ; Jump to subroutine long $042205.l [Writes: Stack Pointer] [Flow: call]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	cop $26.b		; 02 26 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $83.b,S		; 03 83 ; OR accumulator with stack relative $83.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $97.b		; 00 97 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	ora $24.b		; 05 24 ; Logical OR $24.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $04.b		; 26 04 ; Rotate left $04.b [Reads: Direct Page] [Flags: NCZ]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $DC0605.l,X		; FF 05 06 DC ; Subtract with carry (long,X) $DC0605.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $D6.b,X		; D6 D6 ; Decrement memory $D6.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	cmp $D965.w,Y		; D9 65 D9 ; Compare accumulator $D965.w,Y [Reads: Y Index] [Flags: NCZ]
	ora $5A.b,S		; 03 5A ; OR accumulator with stack relative $5A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora #$83.b		; 09 83 ; Logical OR #$83.b with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $DF.b		; 02 DF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $62D9.w,Y		; D9 D9 62 ; Compare accumulator $62D9.w,Y [Reads: Y Index] [Flags: NCZ]
	cpx #$0C.b		; E0 0C ; Compare #$0C.b with X register [Reads: X Index] [Flags: NCZ]
	dec $5A03.w,X		; DE 03 5A ; Decrement memory $5A03.w,X [Reads: X Index] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora ($20.b,S),Y		; 13 20 ; OR accumulator (stack relative indirect indexed) ($20.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $D6.b,S		; E3 D6 ; Subtract stack-relative $D6.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	dec $DF.b,X		; D6 DF ; Decrement memory $DF.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	adc $E4.b,S		; 63 E4 ; Add with carry (stack relative) $E4.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $F8.b,S		; 03 F8 ; OR accumulator with stack relative $F8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $D6E8.w		; ED E8 D6 ; Subtract $D6E8.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	.db $62, $DF, $63		; 62 DF 63 ; Push effective relative address $62, $DF, $63 [Writes: Stack Pointer]
	sbc #$00.b		; E9 00 ; Subtract #$00.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sbc [$85.b]		; E7 85 ; Subtract with carry (long) [$85.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	brk $2C.b		; 00 2C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($ED.b,X)		; 01 ED ; Logical OR ($ED.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sbc $E503.w		; ED 03 E5 ; Subtract $E503.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sbc $13.b		; E5 13 ; Subtract $13.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsl $F668ED.l		; 22 ED 68 F6 ; Jump to subroutine long $F668ED.l [Writes: Stack Pointer] [Flow: call]
	ora [$CC.b]		; 07 CC ; OR accumulator with memory (long) [$CC.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $F8FF.w,X		; 1D FF F8 ; OR accumulator with memory $F8FF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $7AED.w		; ED ED 7A ; Subtract $7AED.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ora $0068.w,X		; 1D 68 00 ; OR accumulator with memory $0068.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $F8BD.w,X		; 1D BD F8 ; OR accumulator with memory $F8BD.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $977A.w		; ED 7A 97 ; Subtract $977A.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ora $0A09.w,X		; 1D 09 0A ; OR accumulator with memory $0A09.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ror $0A.b		; 66 0A ; Rotate right $0A.b [Reads: Direct Page] [Flags: NCZ]
	ora $1D.b		; 05 1D ; Logical OR $1D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $7AE5.w,X		; 1D E5 7A ; OR accumulator with memory $7AE5.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sty $A2.b,X		; 94 A2 ; Store Y register $A2.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	adc [$11.b]		; 67 11 ; Add with carry (long) [$11.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tsb $1D36.w		; 0C 36 1D ; Test and set bits $1D36.w [Reads: Accumulator] [Flags: Z]
	ora $1DAB.w,Y		; 19 AB 1D ; OR accumulator with memory $1DAB.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sty $A2.b,X		; 94 A2 ; Store Y register $A2.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	ldx #$98.b		; A2 98 ; Load #$98.b into X register [Writes: X Index] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cmp $63D91B.l,X		; DF 1B D9 63 ; Compare accumulator (long,X) $63D91B.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	trb $AB0B.w		; 1C 0B AB ; Test and reset bits $AB0B.w [Reads: Accumulator] [Flags: Z]
	ldx $1DB3.w		; AE B3 1D ; Load $1DB3.w into X register [Writes: X Index] [Flags: NZ]
	sta $8E.b,X		; 95 8E ; Store accumulator to $8E.b,X [Reads: Accumulator, X Index]
	pea $CD07.w		; F4 07 CD ; Push absolute address $CD07.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	jsr $1D1C.w		; 20 1C 1D ; Jump to subroutine at $1D1C.w [Writes: Stack Pointer] [Flow: call]
	.db $62, $21, $0C		; 62 21 0C ; Push effective relative address $62, $21, $0C [Writes: Stack Pointer]
	cmp ($B3.b)		; D2 B3 ; Compare accumulator (indirect) ($B3.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	lda [$A8.b],Y		; B7 A8 ; Load accumulator (long indexed) [$A8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	ldx $B524.w		; AE 24 B5 ; Load $B524.w into X register [Writes: X Index] [Flags: NZ]
	and $26.b		; 25 26 ; Logical AND $26.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($22.b,X)		; 21 22 ; Logical AND ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	adc $27.b,S		; 63 27 ; Add with carry (stack relative) $27.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $A8.b		; 05 A8 ; Logical OR $A8.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	trb $B3B3.w		; 1C B3 B3 ; Test and reset bits $B3B3.w [Reads: Accumulator] [Flags: Z]
	lda [$63.b],Y		; B7 63 ; Load accumulator (long indexed) [$63.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	ora ($D9.b,X)		; 01 D9 ; Logical OR ($D9.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp $2F62.w,Y		; D9 62 2F ; Compare accumulator $2F62.w,Y [Reads: Y Index] [Flags: NCZ]
	brk $EB.b		; 00 EB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $32, $0D		; 62 32 0D ; Push effective relative address $62, $32, $0D [Writes: Stack Pointer]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	and $36.b,X		; 35 36 ; Logical AND $36.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sta $D93837.l		; 8F 37 38 D9 ; Store accumulator (long) $D93837.l [Reads: Accumulator]
	and $0A0A.w,Y		; 39 0A 0A ; AND accumulator with memory $0A0A.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($F3.b)		; F2 F3 ; Subtract with carry (indirect) ($F3.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ror $3A.b		; 66 3A ; Rotate right $3A.b [Reads: Direct Page] [Flags: NCZ]
	ora ($B3.b),Y		; 11 B3 ; OR accumulator with memory ($B3.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor ($F3.b,X)		; 41 F3 ; Exclusive OR accumulator with memory ($F3.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $42, $43		; 42 43 ; Reserved instruction
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	mvp $45,$33		; 44 33 45 ; Move block positive $45,$33 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cmp $D7D6.w,Y		; D9 D6 D7 ; Compare accumulator $D7D6.w,Y [Reads: Y Index] [Flags: NCZ]
	cmp $46F9.w,Y		; D9 F9 46 ; Compare accumulator $46F9.w,Y [Reads: Y Index] [Flags: NCZ]
	eor [$FB.b]		; 47 FB ; Exclusive OR accumulator with memory (long) [$FB.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $D9.b		; 25 D9 ; Logical AND $D9.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $3A.b		; 02 3A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $23FF.w,Y		; D9 FF 23 ; Compare accumulator $23FF.w,Y [Reads: Y Index] [Flags: NCZ]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $01.b		; 25 01 ; Logical AND $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $040703.l		; 22 03 07 04 ; Jump to subroutine long $040703.l [Writes: Stack Pointer] [Flow: call]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $83.b,S		; 03 83 ; OR accumulator with stack relative $83.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$04.b]		; 07 04 ; OR accumulator with memory (long) [$04.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $24.b		; 02 24 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $14.b		; 05 14 ; Logical OR $14.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $02.b		; 05 02 ; Logical OR $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $030A01.l		; 22 01 0A 03 ; Jump to subroutine long $030A01.l [Writes: Stack Pointer] [Flow: call]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	asl $0001.w		; 0E 01 00 ; Arithmetic shift left $0001.w [Flags: NCZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $02.b		; 05 02 ; Logical OR $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $24.b		; 04 24 ; Test and set bits $24.b [Reads: Accumulator] [Flags: Z]
	ora ($09.b,X)		; 01 09 ; Logical OR ($09.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	ora $02.b		; 05 02 ; Logical OR $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and [$01.b]		; 27 01 ; AND accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $01.b		; 24 01 ; Test bits $01.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $83.b		; 05 83 ; Logical OR $83.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $4E.b		; 00 4E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $050204.l		; 22 04 02 05 ; Jump to subroutine long $050204.l [Writes: Stack Pointer] [Flow: call]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $050102.l		; 22 02 01 05 ; Jump to subroutine long $050102.l [Writes: Stack Pointer] [Flow: call]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl L000304.l		; 22 04 83 00 ; Jump to subroutine long L000304.l [Writes: Stack Pointer] [Flow: call]
	sta ($01.b,S),Y		; 93 01 ; Store accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $05.b		; 24 05 ; Test bits $05.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $05.b,S		; 23 05 ; AND accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $45.b		; 00 45 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	and $05.b,S		; 23 05 ; AND accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $040701.l		; 22 01 07 04 ; Jump to subroutine long $040701.l [Writes: Stack Pointer] [Flow: call]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $83.b		; 04 83 ; Test and set bits $83.b [Reads: Accumulator] [Flags: Z]
	brk $B2.b		; 00 B2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	ora ($44.b,X)		; 01 44 ; Logical OR ($44.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $05.b,S		; 23 05 ; AND accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $05.b,S		; 23 05 ; AND accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $226B00.l,X		; FF 00 6B 22 ; Subtract with carry (long,X) $226B00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp ($9805.w)		; 6C 05 98 ; Jump indirect to ($9805.w) [Flow: jump]
	sbc $78.b		; E5 78 ; Subtract $78.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	eor #$24.b		; 49 24 ; Exclusive OR #$24.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $880A6C.l		; 22 6C 0A 88 ; Jump to subroutine long $880A6C.l [Writes: Stack Pointer] [Flow: call]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ldy $704B.w		; AC 4B 70 ; Load $704B.w into Y register [Writes: Y Index] [Flags: NZ]
	adc $6968F8.l		; 6F F8 68 69 ; Add with carry (long) $6968F8.l [Writes: Accumulator] [Flags: NCVZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	asl $8807.w		; 0E 07 88 ; Arithmetic shift left $8807.w [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda ($B6.b,X)		; A1 B6 ; Load accumulator ($B6.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ldy $7A.b,X		; B4 7A ; Load Y register $7A.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	ora $64A1.w,X		; 1D A1 64 ; OR accumulator with memory $64A1.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	trb $03.b		; 14 03 ; Test and reset bits $03.b [Reads: Accumulator] [Flags: Z]
	jmp ($A888.w)		; 6C 88 A8 ; Jump indirect to ($A888.w) [Flow: jump]
	sta [$9A.b],Y		; 97 9A ; Store accumulator (long indexed) [$9A.b],Y [Reads: Direct Page, Y Index, Accumulator]
	cop $50.b		; 02 50 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $AA51.w,X		; 1D 51 AA ; OR accumulator with memory $AA51.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	eor ($59.b)		; 52 59 ; Exclusive OR accumulator with memory (indirect) ($59.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	eor ($54.b,S),Y		; 53 54 ; XOR accumulator (stack relative indirect indexed) ($54.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	sta $A2.b,X		; 95 A2 ; Store accumulator to $A2.b,X [Reads: Accumulator, X Index]
	.db $62, $55, $E0		; 62 55 E0 ; Push effective relative address $62, $55, $E0 [Writes: Stack Pointer]
	sec		; 38 ; Set carry flag [Flags: C]
	ora $8658.w,X		; 1D 58 86 ; OR accumulator with memory $8658.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $A2.b,X		; 95 A2 ; Store accumulator to $A2.b,X [Reads: Accumulator, X Index]
	ora $41A2.w,X		; 1D A2 41 ; OR accumulator with memory $41A2.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	eor $B9DB.w,Y		; 59 DB B9 ; Exclusive OR accumulator with memory $B9DB.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ror $5A1D.w		; 6E 1D 5A ; Rotate right $5A1D.w [Flags: NCZ]
	lda ($79.b)		; B2 79 ; Load accumulator (indirect) ($79.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($1D.b),Y		; 91 1D ; Store accumulator ($1D.b),Y [Reads: Direct Page, Y Index, Accumulator]
	ora $5B8D.w,X		; 1D 8D 5B ; OR accumulator with memory $5B8D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jmp $5D1D49.l		; 5C 49 1D 5D ; Jump long to $5D1D49.l [Flow: jump]
	lsr $7AC9.w,X		; 5E C9 7A ; Logical shift right $7AC9.w,X [Reads: X Index] [Flags: NCZ]
	eor $7ABA56.l,X		; 5F 56 BA 7A ; Exclusive OR accumulator with memory (long,X) $7ABA56.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora [$AA.b]		; 07 AA ; OR accumulator with memory (long) [$AA.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta [$EA.b],Y		; 97 EA ; Store accumulator (long indexed) [$EA.b],Y [Reads: Direct Page, Y Index, Accumulator]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ldx #$A1.b		; A2 A1 ; Load #$A1.b into X register [Writes: X Index] [Flags: NZ]
	ora $611D04.l,X		; 1F 04 1D 61 ; Logical OR long $611D04.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $86.b		; 85 86 ; Store accumulator to $86.b [Reads: Accumulator]
	sbc $62.b		; E5 62 ; Subtract $62.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $82, $00, $06		; 82 00 06 ; Branch always long to $82, $00, $06 [Flow: branch]
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: NCZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	tsb $A2F2.w		; 0C F2 A2 ; Test and set bits $A2F2.w [Reads: Accumulator] [Flags: Z]
	adc $B1.b,S		; 63 B1 ; Add with carry (stack relative) $B1.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	adc ($B4.b,X)		; 61 B4 ; Add with carry ($B4.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	sta [$54.b],Y		; 97 54 ; Store accumulator (long indexed) [$54.b],Y [Reads: Direct Page, Y Index, Accumulator]
	stz $65.b		; 64 65 ; Store zero to $65.b
	jsr $2220.w		; 20 20 22 ; Jump to subroutine at $2220.w [Writes: Stack Pointer] [Flow: call]
	lda ($0C.b,S),Y		; B3 0C ; Load accumulator (stack relative indirect indexed) ($0C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc ($1D.b)		; F2 1D ; Subtract with carry (indirect) ($1D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lsr $22.b,X		; 56 22 ; Logical shift right $22.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ror $94.b		; 66 94 ; Rotate right $94.b [Reads: Direct Page] [Flags: NCZ]
	ldx #$50.b		; A2 50 ; Load #$50.b into X register [Writes: X Index] [Flags: NZ]
	adc [$5A.b]		; 67 5A ; Add with carry (long) [$5A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsl $680DA8.l		; 22 A8 0D 68 ; Jump to subroutine long $680DA8.l [Writes: Stack Pointer] [Flow: call]
	adc #$1D.b		; 69 1D ; Add #$1D.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	lda ($07.b,X)		; A1 07 ; Load accumulator ($07.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ldx #$6A.b		; A2 6A ; Load #$6A.b into X register [Writes: X Index] [Flags: NZ]
	ldx #$56.b		; A2 56 ; Load #$56.b into X register [Writes: X Index] [Flags: NZ]
	eor [$5A.b],Y		; 57 5A ; Exclusive OR accumulator with memory (long indexed) [$5A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora $6B62.w,X		; 1D 62 6B ; OR accumulator with memory $6B62.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	eor ($51.b,X)		; 41 51 ; Exclusive OR accumulator with memory ($51.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $CEB5.w		; CD B5 CE ; Compare $CEB5.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc ($AA.b)		; F2 AA ; Subtract with carry (indirect) ($AA.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lsr $BA.b,X		; 56 BA ; Logical shift right $BA.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	stz $6E.b		; 64 6E ; Store zero to $6E.b
	brk $CC.b		; 00 CC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $73.b,S		; 63 73 ; Add with carry (stack relative) $73.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	tsb $FBD2.w		; 0C D2 FB ; Test and set bits $FBD2.w [Reads: Accumulator] [Flags: Z]
	adc [$6A.b],Y		; 77 6A ; Add with carry (long indexed) [$6A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	adc $D1DC.w,Y		; 79 DC D1 ; Add $D1DC.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	ldx #$8E.b		; A2 8E ; Load #$8E.b into X register [Writes: X Index] [Flags: NZ]
	wai		; CB ; Wait for interrupt
	.db $62, $7B, $E0		; 62 7B E0 ; Push effective relative address $62, $7B, $E0 [Writes: Stack Pointer]
	rol $2A.b		; 26 2A ; Rotate left $2A.b [Reads: Direct Page] [Flags: NCZ]
	cmp ($B3.b)		; D2 B3 ; Compare accumulator (indirect) ($B3.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	ldx $7EB7.w		; AE B7 7E ; Load $7EB7.w into X register [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $2F80B7.l,X		; 7F B7 80 2F ; Add long $2F80B7.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp ($81.b),Y		; D1 81 ; Compare accumulator ($81.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	cmp ($B3.b)		; D2 B3 ; Compare accumulator (indirect) ($B3.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	lda [$82.b],Y		; B7 82 ; Load accumulator (long indexed) [$82.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $B546.w,Y		; F9 46 B5 ; Subtract with carry $B546.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $47.b,X		; B5 47 ; Load $47.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sta $3F.b,S		; 83 3F ; Store accumulator (stack relative) $3F.b,S [Reads: Stack Pointer, Accumulator]
	sty $20.b		; 84 20 ; Store Y register to $20.b [Reads: Y Index]
	sta $86.b		; 85 86 ; Store accumulator to $86.b [Reads: Accumulator]
	eor $2A.b		; 45 2A ; Exclusive OR $2A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	sta $3A.b,S		; 83 3A ; Store accumulator (stack relative) $3A.b,S [Reads: Stack Pointer, Accumulator]
	sbc $000524.l,X		; FF 24 05 00 ; Subtract with carry (long,X) $000524.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($25.b,X)		; 01 25 ; Logical OR ($25.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $22.b		; 05 22 ; Logical OR $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $02.b		; 05 02 ; Logical OR $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $22.b		; 05 22 ; Logical OR $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $05.b,S		; 23 05 ; AND accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $022205.l		; 22 05 22 02 ; Jump to subroutine long $022205.l [Writes: Stack Pointer] [Flow: call]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $05.b		; 24 05 ; Test bits $05.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $05.b,S		; 23 05 ; AND accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $2B.b,S		; 03 2B ; OR accumulator with stack relative $2B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $02.b		; 05 02 ; Logical OR $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $2205.w		; 2D 05 22 ; Logical AND $2205.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cop $26.b		; 02 26 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $22.b		; 05 22 ; Logical OR $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $2D.b		; 02 2D ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $29.b		; 02 29 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $02.b		; 05 02 ; Logical OR $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rol $05.b		; 26 05 ; Rotate left $05.b [Reads: Direct Page] [Flags: NCZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $05.b		; 24 05 ; Test bits $05.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	jsl $052B01.l		; 22 01 2B 05 ; Jump to subroutine long $052B01.l [Writes: Stack Pointer] [Flow: call]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($27.b,X)		; 01 27 ; Logical OR ($27.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	stx $0522.w		; 8E 22 05 ; Store X register to $0522.w [Reads: X Index]
	and #$06.b		; 29 06 ; Logical AND #$06.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $010006.l		; 22 06 00 01 ; Jump to subroutine long $010006.l [Writes: Stack Pointer] [Flow: call]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	asl $02.b		; 06 02 ; Arithmetic shift left $02.b [Reads: Direct Page] [Flags: NCZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $23.b,S		; 03 23 ; OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $02.b		; 06 02 ; Arithmetic shift left $02.b [Reads: Direct Page] [Flags: NCZ]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $05.b		; 06 05 ; Arithmetic shift left $05.b [Reads: Direct Page] [Flags: NCZ]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $06.b		; 24 06 ; Test bits $06.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $83.b,S		; 03 83 ; OR accumulator with stack relative $83.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $EB.b		; 00 EB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $008764.l,X		; FF 64 87 00 ; Subtract with carry (long,X) $008764.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($65.b),Y		; 71 65 ; Add with carry ($65.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sty $8222.w		; 8C 22 82 ; Store Y register to $8222.w [Reads: Y Index]
	cop $71.b		; 02 71 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($87.b)		; 92 87 ; Store accumulator (indirect) ($87.b) [Reads: Direct Page, Accumulator]
	.db $62, $93, $02		; 62 93 02 ; Push effective relative address $62, $93, $02 [Writes: Stack Pointer]
	eor ($FD.b),Y		; 51 FD ; Exclusive OR accumulator with memory ($FD.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $9663.w		; ED 63 96 ; Subtract $9663.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	jsl $710282.l		; 22 82 02 71 ; Jump to subroutine long $710282.l [Writes: Stack Pointer] [Flow: call]
	jmp ($6292.w)		; 6C 92 62 ; Jump indirect to ($6292.w) [Flow: jump]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($ED.b,X)		; 01 ED ; Logical OR ($ED.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $62, $9D, $05		; 62 9D 05 ; Push effective relative address $62, $9D, $05 [Writes: Stack Pointer]
	stx $8F8F.w		; 8E 8F 8F ; Store X register to $8F8F.w [Reads: X Index]
	ldy #$A1.b		; A0 A1 ; Load #$A1.b into Y register [Writes: Y Index] [Flags: NZ]
	sta [$64.b]		; 87 64 ; Store accumulator (long) [$64.b] [Reads: Direct Page, Accumulator]
	ldx #$01.b		; A2 01 ; Load #$01.b into X register [Writes: X Index] [Flags: NZ]
	ora ($9D.b,X)		; 01 9D ; Logical OR ($9D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $62, $A7, $03		; 62 A7 03 ; Push effective relative address $62, $A7, $03 [Writes: Stack Pointer]
	.db $82, $82, $64		; 82 82 64 ; Branch always long to $82, $82, $64 [Flow: branch]
	eor ($63.b),Y		; 51 63 ; Exclusive OR accumulator with memory ($63.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	brk $A8.b		; 00 A8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $AE.b		; 66 AE ; Rotate right $AE.b [Reads: Direct Page] [Flags: NCZ]
	ora #$82.b		; 09 82 ; Logical OR #$82.b with accumulator [Writes: Accumulator] [Flags: NZ]
	stz $67.b		; 64 67 ; Store zero to $67.b
	ora $B5.b,S		; 03 B5 ; OR accumulator with stack relative $B5.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	stx $B7B6.w		; 8E B6 B7 ; Store X register to $B7B6.w [Reads: X Index]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	ror $B8.b		; 66 B8 ; Rotate right $B8.b [Reads: Direct Page] [Flags: NCZ]
	brk $67.b		; 00 67 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $8E0003.l		; 22 03 00 8E ; Jump to subroutine long $8E0003.l [Writes: Stack Pointer] [Flow: call]
	.db $62, $BF, $03		; 62 BF 03 ; Push effective relative address $62, $BF, $03 [Writes: Stack Pointer]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	rep #$C3		; C2 C3 ; Reset processor status bits #$C3 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	ora $C463.w,X		; 1D 63 C4 ; OR accumulator with memory $C463.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $C80103.l		; 22 03 01 C8 ; Jump to subroutine long $C80103.l [Writes: Stack Pointer] [Flow: call]
	stx $C96B.w		; 8E 6B C9 ; Store X register to $C96B.w [Reads: X Index]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	cmp $02.b,X		; D5 02 ; Compare accumulator $02.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	lsr $DE.b,X		; 56 DE ; Logical shift right $DE.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	and $62.b,S		; 23 62 ; AND accumulator with stack relative $62.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $E2D503.l,X		; DF 03 D5 E2 ; Compare accumulator (long,X) $E2D503.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	cmp $66CD.w		; CD CD 66 ; Compare $66CD.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	sbc $00.b,S		; E3 00 ; Subtract stack-relative $00.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	cmp $EA64.w,Y		; D9 64 EA ; Compare accumulator $EA64.w,Y [Reads: Y Index] [Flags: NCZ]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $D6.b,X		; D6 D6 ; Decrement memory $D6.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc $71ED04.l		; EF 04 ED 71 ; Subtract with carry (long) $71ED04.l [Writes: Accumulator] [Flags: NCVZ]
	ora ($87.b,X)		; 01 87 ; Logical OR ($87.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	dec $64.b,X		; D6 64 ; Decrement memory $64.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sbc $C5FF.w,Y		; F9 FF C5 ; Subtract with carry $C5FF.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $ED.b		; C5 ED ; Compare $ED.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	adc ($06.b),Y		; 71 06 ; Add with carry ($06.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($87.b)		; 92 87 ; Store accumulator (indirect) ($87.b) [Reads: Direct Page, Accumulator]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	adc #$02.b		; 69 02 ; Add #$02.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	tsb $ED.b		; 04 ED ; Test and set bits $ED.b [Reads: Accumulator] [Flags: Z]
	adc ($06.b),Y		; 71 06 ; Add with carry ($06.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp ($6292.w)		; 6C 92 62 ; Jump indirect to ($6292.w) [Flow: jump]
	tsb $0300.w		; 0C 00 03 ; Test and set bits $0300.w [Reads: Accumulator] [Flags: Z]
	adc $0F.b,S		; 63 0F ; Add with carry (stack relative) $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $13.b,S		; 63 13 ; Add with carry (stack relative) $13.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cop $0C.b		; 02 0C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($636C.w)		; 6C 6C 63 ; Jump indirect to ($636C.w) [Flow: jump]
	ora [$0B.b],Y		; 17 0B ; OR accumulator with memory (long indexed) [$0B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $1B.b,S		; 03 1B ; OR accumulator with stack relative $1B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$1C.b],Y		; 17 1C ; OR accumulator with memory (long indexed) [$1C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($1D.b)		; 12 1D ; OR accumulator with memory (indirect) ($1D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx #$1E.b		; E0 1E ; Compare #$1E.b with X register [Reads: X Index] [Flags: NCZ]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jmp ($63A2.w)		; 6C A2 63 ; Jump indirect to ($63A2.w) [Flow: jump]
	jsr $1A09.w		; 20 09 1A ; Jump to subroutine at $1A09.w [Writes: Stack Pointer] [Flow: call]
	ora $75.b,S		; 03 75 ; OR accumulator with stack relative $75.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $63.b		; 00 63 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $FF.b		; 24 FF ; Test bits $FF.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	and $F3.b		; 25 F3 ; Logical AND $F3.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc ($FF.b),Y		; 71 FF ; Add with carry ($FF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $26.b		; 06 26 ; Arithmetic shift left $26.b [Reads: Direct Page] [Flags: NCZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $26.b		; 06 26 ; Arithmetic shift left $26.b [Reads: Direct Page] [Flags: NCZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $84.b,S		; 03 84 ; OR accumulator with stack relative $84.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $21.b		; 00 21 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $05.b		; 06 05 ; Arithmetic shift left $05.b [Reads: Direct Page] [Flags: NCZ]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $24.b		; 06 24 ; Arithmetic shift left $24.b [Reads: Direct Page] [Flags: NCZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $030400.l		; 22 00 04 03 ; Jump to subroutine long $030400.l [Writes: Stack Pointer] [Flow: call]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	jsl $040000.l		; 22 00 00 04 ; Jump to subroutine long $040000.l [Writes: Stack Pointer] [Flow: call]
	jsl $060001.l		; 22 01 00 06 ; Jump to subroutine long $060001.l [Writes: Stack Pointer] [Flow: call]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $06.b		; 04 06 ; Test and set bits $06.b [Reads: Accumulator] [Flags: Z]
	asl $26.b		; 06 26 ; Arithmetic shift left $26.b [Reads: Direct Page] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $24.b		; 06 24 ; Arithmetic shift left $24.b [Reads: Direct Page] [Flags: NCZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	asl $23.b		; 06 23 ; Arithmetic shift left $23.b [Reads: Direct Page] [Flags: NCZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $02.b		; 06 02 ; Arithmetic shift left $02.b [Reads: Direct Page] [Flags: NCZ]
	asl $24.b		; 06 24 ; Arithmetic shift left $24.b [Reads: Direct Page] [Flags: NCZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $C1.b		; 00 C1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $24.b		; 06 24 ; Arithmetic shift left $24.b [Reads: Direct Page] [Flags: NCZ]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $83.b		; 06 83 ; Arithmetic shift left $83.b [Reads: Direct Page] [Flags: NCZ]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $23.b		; 06 23 ; Arithmetic shift left $23.b [Reads: Direct Page] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $26.b		; 06 26 ; Arithmetic shift left $26.b [Reads: Direct Page] [Flags: NCZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: NCZ]
	asl $24.b		; 06 24 ; Arithmetic shift left $24.b [Reads: Direct Page] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $23.b		; 06 23 ; Arithmetic shift left $23.b [Reads: Direct Page] [Flags: NCZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $26.b		; 00 26 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$62.b]		; 27 62 ; AND accumulator with memory (long) [$62.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stx $00.b		; 86 00 ; Store X register to $00.b [Reads: X Index]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora #$28.b		; 09 28 ; Logical OR #$28.b with accumulator [Writes: Accumulator] [Flags: NZ]
	and #$62.b		; 29 62 ; Logical AND #$62.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$01.b		; 09 01 ; Logical OR #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$0A.b		; 09 0A ; Logical OR #$0A.b with accumulator [Writes: Accumulator] [Flags: NZ]
	stx $00.b		; 86 00 ; Store X register to $00.b [Reads: X Index]
	.db $10, $05		; 10 05 ; Branch if plus to $10, $05 [Flow: branch]
	asl $10.b		; 06 10 ; Arithmetic shift left $10.b [Reads: Direct Page] [Flags: NCZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	and ($93.b),Y		; 31 93 ; AND accumulator with memory ($93.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $06, $00		; 62 06 00 ; Push effective relative address $62, $06, $00 [Writes: Stack Pointer]
	.db $F0, $84		; F0 84 ; Branch if equal to $F0, $84 [Flow: branch]
	brk $21.b		; 00 21 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $02F0.w		; 0E F0 02 ; Arithmetic shift left $02F0.w [Flags: NCZ]
	adc ($2C.b),Y		; 71 2C ; Add with carry ($2C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($39.b,S),Y		; 53 39 ; XOR accumulator (stack relative indirect indexed) ($39.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $010002.l,X		; 3F 02 00 01 ; AND accumulator with memory (long,X) $010002.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $1C.b,S		; 83 1C ; Store accumulator (stack relative) $1C.b,S [Reads: Stack Pointer, Accumulator]
	lsr $D12D.w,X		; 5E 2D D1 ; Logical shift right $D12D.w,X [Reads: X Index] [Flags: NCZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	asl $2F0A.w		; 0E 0A 2F ; Arithmetic shift left $2F0A.w [Flags: NCZ]
	rol $9291.w		; 2E 91 92 ; Rotate left $9291.w [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora #$0A.b		; 09 0A ; Logical OR #$0A.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sty $1D29.w		; 8C 29 1D ; Store Y register to $1D29.w [Reads: Y Index]
	inc $0084.w		; EE 84 00 ; Increment $0084.w [Flags: NZ]
	ora $2F13.w,X		; 1D 13 2F ; OR accumulator with memory $2F13.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc ($62.b,X)		; 61 62 ; Add with carry ($62.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $7A		; 30 7A ; Branch if minus to $30, $7A [Flow: branch]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $64		; F0 64 ; Branch if equal to $F0, $64 [Flow: branch]
	ora $3131.w,X		; 1D 31 31 ; OR accumulator with memory $3131.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta ($06.b,S),Y		; 93 06 ; Store accumulator (stack relative indirect indexed) ($06.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	cop $71.b		; 02 71 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $67.b		; 26 67 ; Rotate left $67.b [Reads: Direct Page] [Flags: NCZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	and ($84.b)		; 32 84 ; AND accumulator with memory (indirect) ($84.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $36.b		; 00 36 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $27.b,S		; 03 27 ; OR accumulator with stack relative $27.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $833F39.l,X		; FF 39 3F 83 ; Subtract with carry (long,X) $833F39.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $DF.b		; 02 DF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $008422.l		; 6F 22 84 00 ; Add with carry (long) $008422.l [Writes: Accumulator] [Flags: NCVZ]
	lsr $18.b		; 46 18 ; Logical shift right $18.b [Reads: Direct Page] [Flags: NCZ]
	jsl $929174.l		; 22 74 91 92 ; Jump to subroutine long $929174.l [Writes: Stack Pointer] [Flow: call]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	ora [$FE.b]		; 07 FE ; OR accumulator with memory (long) [$FE.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	cmp #$93.b		; C9 93 ; Compare #$93.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	ora [$93.b]		; 07 93 ; OR accumulator with memory (long) [$93.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	stz $33.b		; 64 33 ; Store zero to $33.b
	bit $C9.b,X		; 34 C9 ; Test bits $C9.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sta ($06.b,S),Y		; 93 06 ; Store accumulator (stack relative indirect indexed) ($06.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($7F.b,X)		; 01 7F ; Logical OR ($7F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	bit $04.b,X		; 34 04 ; Test bits $04.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	tsb $1B.b		; 04 1B ; Test and set bits $1B.b [Reads: Accumulator] [Flags: Z]
	trb $3635.w		; 1C 35 36 ; Test and reset bits $3635.w [Reads: Accumulator] [Flags: Z]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	adc $0A00.w		; 6D 00 0A ; Add $0A00.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	jmp ($0901.w,X)		; 7C 01 09 ; Jump indirect indexed to ($0901.w,X) [Reads: X Index] [Flow: jump]
	ora [$64.b]		; 07 64 ; OR accumulator with memory (long) [$64.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and [$83.b],Y		; 37 83 ; AND accumulator with memory (long indexed) [$83.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta ($3C.b,S),Y		; 93 3C ; Store accumulator (stack relative indirect indexed) ($3C.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	ora $7A30.w,X		; 1D 30 7A ; OR accumulator with memory $7A30.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$FE.b]		; 07 FE ; OR accumulator with memory (long) [$FE.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jmp ($8A3D.w,X)		; 7C 3D 8A ; Jump indirect indexed to ($8A3D.w,X) [Reads: X Index] [Flow: jump]
	rol $93C9.w,X		; 3E C9 93 ; Rotate left $93C9.w,X [Reads: X Index] [Flags: NCZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $3B.b		; 04 3B ; Test and set bits $3B.b [Reads: Accumulator] [Flags: Z]
	trb $1A19.w		; 1C 19 1A ; Test and reset bits $1A19.w [Reads: Accumulator] [Flags: Z]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $3F27.w,X		; 1D 27 3F ; OR accumulator with memory $3F27.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	and $4064.w,X		; 3D 64 40 ; AND accumulator with memory $4064.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $09.b,S		; 03 09 ; OR accumulator with stack relative $09.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$45.b]		; 07 45 ; OR accumulator with memory (long) [$45.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr $83.b		; 46 83 ; Logical shift right $83.b [Reads: Direct Page] [Flags: NCZ]
	brk $75.b		; 00 75 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	adc $D94706.l,X		; 7F 06 47 D9 ; Add long $D94706.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	eor #$07.b		; 49 07 ; Exclusive OR #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc $837C.w,X		; FE 7C 83 ; Increment memory $837C.w,X [Reads: X Index] [Flags: NZ]
	brk $B4.b		; 00 B4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ldx $0103.w,Y		; BE 03 01 ; Load X register $0103.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cmp $834B.w,Y		; D9 4B 83 ; Compare accumulator $834B.w,Y [Reads: Y Index] [Flags: NCZ]
	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1D.b		; 00 1D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	adc $00.b		; 65 00 ; Add $00.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cop $FF.b		; 02 FF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: NCZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: NCZ]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: NCZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	jsl $060301.l		; 22 01 03 06 ; Jump to subroutine long $060301.l [Writes: Stack Pointer] [Flow: call]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ora $23.b,X		; 15 23 ; OR accumulator with memory $23.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	asl $0A.b		; 06 0A ; Arithmetic shift left $0A.b [Reads: Direct Page] [Flags: NCZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	ora ($25.b,X)		; 01 25 ; Logical OR ($25.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $08.b		; 06 08 ; Arithmetic shift left $08.b [Reads: Direct Page] [Flags: NCZ]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $04.b		; 06 04 ; Arithmetic shift left $04.b [Reads: Direct Page] [Flags: NCZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	ora ($29.b,X)		; 01 29 ; Logical OR ($29.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: NCZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $83.b		; 06 83 ; Arithmetic shift left $83.b [Reads: Direct Page] [Flags: NCZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	asl $04.b		; 06 04 ; Arithmetic shift left $04.b [Reads: Direct Page] [Flags: NCZ]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($43.b,X)		; 01 43 ; Logical OR ($43.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	asl $02.b		; 06 02 ; Arithmetic shift left $02.b [Reads: Direct Page] [Flags: NCZ]
	cop $89.b		; 02 89 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $86.b		; 00 86 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	and ($28.b),Y		; 31 28 ; AND accumulator with memory ($28.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $05.b		; 06 05 ; Arithmetic shift left $05.b [Reads: Direct Page] [Flags: NCZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $06.b,S		; 23 06 ; AND accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $06.b,X		; 34 06 ; Test bits $06.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $24.b		; 06 24 ; Arithmetic shift left $24.b [Reads: Direct Page] [Flags: NCZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	ora ($2F.b,X)		; 01 2F ; Logical OR ($2F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $2F.b,S		; 03 2F ; OR accumulator with stack relative $2F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $FF.b		; 06 FF ; Arithmetic shift left $FF.b [Reads: Direct Page] [Flags: NCZ]
	ora $91.b		; 05 91 ; Logical OR $91.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jmp $EDF8.w		; 4C F8 ED ; Jump to $EDF8.w [Flow: jump]
	sep #$4D		; E2 4D ; Set processor status bits #$4D [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	.db $62, $06, $63		; 62 06 63 ; Push effective relative address $62, $06, $63 [Writes: Stack Pointer]
	lsr $0662.w		; 4E 62 06 ; Logical shift right $0662.w [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sta [$5A.b],Y		; 97 5A ; Store accumulator (long indexed) [$5A.b],Y [Reads: Direct Page, Y Index, Accumulator]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $52ED.w		; ED ED 52 ; Subtract $52ED.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $53.b,S		; 63 53 ; Add with carry (stack relative) $53.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $BA.b,X		; 56 BA ; Logical shift right $BA.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ror $7AED.w		; 6E ED 7A ; Rotate right $7AED.w [Flags: NCZ]
	eor [$27.b],Y		; 57 27 ; Exclusive OR accumulator with memory (long indexed) [$27.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora #$07.b		; 09 07 ; Logical OR #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	adc $58.b,S		; 63 58 ; Add with carry (stack relative) $58.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and [$09.b]		; 27 09 ; AND accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc ($61.b,X)		; 61 61 ; Add with carry ($61.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	stx $7A.b		; 86 7A ; Store X register to $7A.b [Reads: X Index]
	sta $305C.w,Y		; 99 5C 30 ; Store accumulator to $305C.w,Y [Reads: Y Index, Accumulator]
	asl $5D63.w		; 0E 63 5D ; Arithmetic shift left $5D63.w [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr $0E61.w,X		; 5E 61 0E ; Logical shift right $0E61.w,X [Reads: X Index] [Flags: NCZ]
	.db $62, $22, $22		; 62 22 22 ; Push effective relative address $62, $22, $22 [Writes: Stack Pointer]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	sta $5C1D.w,Y		; 99 1D 5C ; Store accumulator to $5C1D.w,Y [Reads: Y Index, Accumulator]
	ora $6364.w,X		; 1D 64 63 ; OR accumulator with memory $6364.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $65.b		; 00 65 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $68, $06		; 62 68 06 ; Push effective relative address $62, $68, $06 [Writes: Stack Pointer]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jmp ($6261.w)		; 6C 61 62 ; Jump indirect to ($6261.w) [Flow: jump]
	jmp $6D646A.l		; 5C 6A 64 6D ; Jump long to $6D646A.l [Flow: jump]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	adc $1D6972.l		; 6F 72 69 1D ; Add with carry (long) $1D6972.l [Writes: Accumulator] [Flags: NCVZ]
	ora $731C.w,X		; 1D 1C 73 ; OR accumulator with memory $731C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc [$68.b]		; 67 68 ; Add with carry (long) [$68.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jmp $1D7574.l		; 5C 74 75 1D ; Jump long to $1D7574.l [Flow: jump]
	ora $7776.w,X		; 1D 76 77 ; OR accumulator with memory $7776.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $751D.w,X		; 1D 1D 75 ; OR accumulator with memory $751D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ora $29DF.w,X		; 1D DF 29 ; OR accumulator with memory $29DF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jmp $79651E.l		; 5C 1E 65 79 ; Jump long to $79651E.l [Flow: jump]
	ora $7F7A.w,Y		; 19 7A 7F ; OR accumulator with memory $7F7A.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $80, $08		; 80 08 ; Branch always to $80, $08 [Flow: branch]
	dec $1D.b		; C6 1D ; Decrement $1D.b [Reads: Direct Page] [Flags: NZ]
	sta $FB5C2D.l,X		; 9F 2D 5C FB ; Store accumulator (long,X) $FB5C2D.l,X [Reads: Accumulator, X Index]
	sta ($1F.b,X)		; 81 1F ; Store accumulator ($1F.b,X) [Reads: Direct Page, Accumulator, X Index]
	bit $82.b		; 24 82 ; Test bits $82.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sta $37.b,S		; 83 37 ; Store accumulator (stack relative) $37.b,S [Reads: Stack Pointer, Accumulator]
	ora $E58084.l,X		; 1F 84 80 E5 ; Logical OR long $E58084.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp [$C8.b]		; C7 C8 ; Compare accumulator (long) [$C8.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sta $6D.b		; 85 6D ; Store accumulator to $6D.b [Reads: Accumulator]
	ror $861D.w		; 6E 1D 86 ; Rotate right $861D.w [Flags: NCZ]
	brk $87.b		; 00 87 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	stx $87.b		; 86 87 ; Store X register to $87.b [Reads: X Index]
	ora $B156.w,X		; 1D 56 B1 ; OR accumulator with memory $B156.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc ($C9.b,X)		; 61 C9 ; Add with carry ($C9.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	ora $8988.w,X		; 1D 88 89 ; OR accumulator with memory $8988.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $89, $0A		; 62 89 0A ; Push effective relative address $62, $89, $0A [Writes: Stack Pointer]
	bit #$89.b		; 89 89 ; Test bits #$89.b with accumulator [Reads: Accumulator] [Flags: Z]
	sty $A08D.w		; 8C 8D A0 ; Store Y register to $A08D.w [Reads: Y Index]
	stx $2256.w		; 8E 56 22 ; Store X register to $2256.w [Reads: X Index]
	tsb $1D.b		; 04 1D ; Test and set bits $1D.b [Reads: Accumulator] [Flags: Z]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $62, $8F, $02		; 62 8F 02 ; Push effective relative address $62, $8F, $02 [Writes: Stack Pointer]
	eor $678F92.l		; 4F 92 8F 67 ; Exclusive OR accumulator with memory (long) $678F92.l [Writes: Accumulator] [Flags: NZ]
	sta ($00.b,S),Y		; 93 00 ; Store accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	sta $9B62.w,Y		; 99 62 9B ; Store accumulator to $9B62.w,Y [Reads: Y Index, Accumulator]
	ora #$97.b		; 09 97 ; Logical OR #$97.b with accumulator [Writes: Accumulator] [Flags: NZ]
	stx $97.b,Y		; 96 97 ; Store X register $97.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	stz $9B9F.w,X		; 9E 9F 9B ; Store zero to $9B9F.w,X [Reads: X Index]
	ldy #$AB.b		; A0 AB ; Load #$AB.b into Y register [Writes: Y Index] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	lda ($22.b,X)		; A1 22 ; Load accumulator ($22.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ldx #$00.b		; A2 00 ; Load #$00.b into X register [Writes: X Index] [Flags: NZ]
	lda $24.b,S		; A3 24 ; Load accumulator (stack relative) $24.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	.db $62, $A1, $00		; 62 A1 00 ; Push effective relative address $62, $A1, $00 [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	and $A42FC9.l		; 2F C9 2F A4 ; AND accumulator with memory (long) $A42FC9.l [Writes: Accumulator] [Flags: NZ]
	sbc $010023.l,X		; FF 23 00 01 ; Subtract with carry (long,X) $010023.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	and $06.b,S		; 23 06 ; AND accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $27.b		; 06 27 ; Arithmetic shift left $27.b [Reads: Direct Page] [Flags: NCZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $062301.l		; 22 01 23 06 ; Jump to subroutine long $062301.l [Writes: Stack Pointer] [Flow: call]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $05.b		; 06 05 ; Arithmetic shift left $05.b [Reads: Direct Page] [Flags: NCZ]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	jsl $000206.l		; 22 06 02 00 ; Jump to subroutine long $000206.l [Writes: Stack Pointer] [Flow: call]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and [$06.b]		; 27 06 ; AND accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $83.b		; 06 83 ; Arithmetic shift left $83.b [Reads: Direct Page] [Flags: NCZ]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $33.b,S		; 03 33 ; OR accumulator with stack relative $33.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	brk $2E.b		; 00 2E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	brk $2E.b		; 00 2E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	brk $32.b		; 00 32 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	cop $24.b		; 02 24 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: NCZ]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $07.b,S		; 23 07 ; AND accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $070206.l		; 22 06 02 07 ; Jump to subroutine long $070206.l [Writes: Stack Pointer] [Flow: call]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	bit $06.b		; 24 06 ; Test bits $06.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $012306.l		; 22 06 23 01 ; Jump to subroutine long $012306.l [Writes: Stack Pointer] [Flow: call]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	jsl $070101.l		; 22 01 01 07 ; Jump to subroutine long $070101.l [Writes: Stack Pointer] [Flow: call]
	ora [$2F.b]		; 07 2F ; OR accumulator with memory (long) [$2F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $2F.b,S		; 03 2F ; OR accumulator with stack relative $2F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $FF.b		; 06 FF ; Arithmetic shift left $FF.b [Reads: Direct Page] [Flags: NCZ]
	.db $62, $06, $02		; 62 06 02 ; Push effective relative address $62, $06, $02 [Writes: Stack Pointer]
	asl $A5.b		; 06 A5 ; Arithmetic shift left $A5.b [Reads: Direct Page] [Flags: NCZ]
	adc ($43.b),Y		; 71 43 ; Add with carry ($43.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx $A7.b		; A6 A7 ; Load $A7.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	cop $DC.b		; 02 DC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $62, $06, $17		; 62 06 17 ; Push effective relative address $62, $06, $17 [Writes: Stack Pointer]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda #$16.b		; A9 16 ; Load #$16.b into accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $A706.w		; 0C 06 A7 ; Test and set bits $A706.w [Reads: Accumulator] [Flags: Z]
	asl $DC.b		; 06 DC ; Arithmetic shift left $DC.b [Reads: Direct Page] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	and $010002.l,X		; 3F 02 00 01 ; AND accumulator with memory (long,X) $010002.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora #$0A.b		; 09 0A ; Logical OR #$0A.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sty $03AB.w		; 8C AB 03 ; Store Y register to $03AB.w [Reads: Y Index]
	ora #$0A.b		; 09 0A ; Logical OR #$0A.b with accumulator [Writes: Accumulator] [Flags: NZ]
	adc $AC.b,S		; 63 AC ; Add with carry (stack relative) $AC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta ($0B.b)		; 92 0B ; Store accumulator (indirect) ($0B.b) [Reads: Direct Page, Accumulator]
	ora #$0A.b		; 09 0A ; Logical OR #$0A.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $B0, $0E		; B0 0E ; Branch if carry set to $B0, $0E [Flow: branch]
	.db $62, $34, $1D		; 62 34 1D ; Push effective relative address $62, $34, $1D [Writes: Stack Pointer]
	cpx $13.b		; E4 13 ; Compare $13.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	adc $B1.b,S		; 63 B1 ; Add with carry (stack relative) $B1.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $A8.b		; 05 A8 ; Logical OR $A8.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($B0.b,S),Y		; 33 B0 ; AND accumulator (stack relative indirect indexed) ($B0.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $1D62.w		; 0E 62 1D ; Arithmetic shift left $1D62.w [Flags: NCZ]
	.db $62, $B5, $04		; 62 B5 04 ; Push effective relative address $62, $B5, $04 [Writes: Stack Pointer]
	ora $B81F2D.l,X		; 1F 2D 1F B8 ; Logical OR long $B81F2D.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda $B965.w,Y		; B9 65 B9 ; Load $B965.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $241D.w,X		; 1D 1D 24 ; OR accumulator with memory $241D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda $37C01F.l,X		; BF 1F C0 37 ; Load long $37C01F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $2256.w,X		; 1E 56 22 ; Arithmetic shift left $2256.w,X [Reads: X Index] [Flags: NCZ]
	jsl $C163A8.l		; 22 A8 63 C1 ; Jump to subroutine long $C163A8.l [Writes: Stack Pointer] [Flow: call]
	brk $6A.b		; 00 6A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $C5.b		; 64 C5 ; Store zero to $C5.b
	brk $C8.b		; 00 C8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $CA, $00		; 62 CA 00 ; Push effective relative address $62, $CA, $00 [Writes: Stack Pointer]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	adc $CD.b,S		; 63 CD ; Add with carry (stack relative) $CD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora ($C4.b,X)		; 01 C4 ; Logical OR ($C4.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $D168.w,X		; 1D 68 D1 ; OR accumulator with memory $D168.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $C9.b		; 00 C9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $DA.b		; 64 DA ; Store zero to $DA.b
	ora $1D.b,S		; 03 1D ; OR accumulator with stack relative $1D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $80, $DF		; 80 DF ; Branch always to $80, $DF [Flow: branch]
	dec $65.b,X		; D6 65 ; Decrement memory $65.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: NCZ]
	cmp $64.b,X		; D5 64 ; Compare accumulator $64.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	inc $0A.b		; E6 0A ; Increment $0A.b [Reads: Direct Page] [Flags: NZ]
	ora $D26A.w,X		; 1D 6A D2 ; OR accumulator with memory $D26A.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cpx $37E3.w		; EC E3 37 ; Compare $37E3.w with X register [Reads: X Index] [Flags: NCZ]
	bit $E0ED.w,X		; 3C ED E0 ; Test bits $E0ED.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	cmp [$62.b],Y		; D7 62 ; Compare accumulator (long indexed) [$62.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	inc $E904.w		; EE 04 E9 ; Increment $E904.w [Flags: NZ]
	dec $1DF1.w,X		; DE F1 1D ; Decrement memory $1DF1.w,X [Reads: X Index] [Flags: NZ]
	dec $63.b		; C6 63 ; Decrement $63.b [Reads: Direct Page] [Flags: NZ]
	sbc ($0E.b)		; F2 0E ; Subtract with carry (indirect) ($0E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $F6		; F0 F6 ; Branch if equal to $F0, $F6 [Flow: branch]
	cpx $F7E3.w		; EC E3 F7 ; Compare $F7E3.w with X register [Reads: X Index] [Flags: NCZ]
	sbc $F8.b,S		; E3 F8 ; Subtract stack-relative $F8.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	sbc #$DE.b		; E9 DE ; Subtract #$DE.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $F9		; 80 F9 ; Branch always to $80, $F9 [Flow: branch]
	sta $FA99.w,Y		; 99 99 FA ; Store accumulator to $FA99.w,Y [Reads: Y Index, Accumulator]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	stz $FB.b		; 64 FB ; Store zero to $FB.b
	.db $62, $00, $03		; 62 00 03 ; Push effective relative address $62, $00, $03 [Writes: Stack Pointer]
	jsr ($1D03.w,X)		; FC 03 1D ; Jump to subroutine indirect indexed ($1D03.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	stx $63.b,Y		; 96 63 ; Store X register $63.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	ldy #$02.b		; A0 02 ; Load #$02.b into Y register [Writes: Y Index] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sta $2409.w,Y		; 99 09 24 ; Store accumulator to $2409.w,Y [Reads: Y Index, Accumulator]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	.db $62, $A1, $23		; 62 A1 23 ; Push effective relative address $62, $A1, $23 [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	cop $0A.b		; 02 0A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx #$0B.b		; A2 0B ; Load #$0B.b into X register [Writes: X Index] [Flags: NZ]
	jsl $0C01AB.l		; 22 AB 01 0C ; Jump to subroutine long $0C01AB.l [Writes: Stack Pointer] [Flow: call]
	ora $C92F.w		; 0D 2F C9 ; Logical OR $C92F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $03FFA4.l		; 2F A4 FF 03 ; AND accumulator with memory (long) $03FFA4.l [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $030001.l		; 22 01 00 03 ; Jump to subroutine long $030001.l [Writes: Stack Pointer] [Flow: call]
	and $07.b,S		; 23 07 ; AND accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$24.b]		; 07 24 ; OR accumulator with memory (long) [$24.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $01.b		; 24 01 ; Test bits $01.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	trb $0602.w		; 1C 02 06 ; Test and reset bits $0602.w [Reads: Accumulator] [Flags: Z]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $070201.l		; 22 01 02 07 ; Jump to subroutine long $070201.l [Writes: Stack Pointer] [Flow: call]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $060307.l		; 22 07 03 06 ; Jump to subroutine long $060307.l [Writes: Stack Pointer] [Flow: call]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	ora ($29.b,X)		; 01 29 ; Logical OR ($29.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $24.b		; 06 24 ; Arithmetic shift left $24.b [Reads: Direct Page] [Flags: NCZ]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $22.b		; 05 22 ; Logical OR $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$04.b]		; 07 04 ; OR accumulator with memory (long) [$04.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $25.b		; 00 25 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0D.b]		; 07 0D ; OR accumulator with memory (long) [$0D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	rol $08.b,X		; 36 08 ; Rotate left $08.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: NCZ]
	ora [$04.b]		; 07 04 ; OR accumulator with memory (long) [$04.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $22.b		; 05 22 ; Logical OR $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	asl $02.b		; 06 02 ; Arithmetic shift left $02.b [Reads: Direct Page] [Flags: NCZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $07.b,S		; 23 07 ; AND accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor $06.b,S		; 43 06 ; Exclusive OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $07.b		; 26 07 ; Rotate left $07.b [Reads: Direct Page] [Flags: NCZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $06.b,S		; 43 06 ; Exclusive OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$04.b]		; 07 04 ; OR accumulator with memory (long) [$04.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($25.b,X)		; 01 25 ; Logical OR ($25.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $83.b		; 06 83 ; Arithmetic shift left $83.b [Reads: Direct Page] [Flags: NCZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	rep #$03		; C2 03 ; Reset processor status bits #$03 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $010007.l		; 22 07 00 01 ; Jump to subroutine long $010007.l [Writes: Stack Pointer] [Flow: call]
	and $07.b		; 25 07 ; Logical AND $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	stx $00.b		; 86 00 ; Store X register to $00.b [Reads: X Index]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora $25.b,S		; 03 25 ; OR accumulator with stack relative $25.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$0C.b]		; 07 0C ; OR accumulator with memory (long) [$0C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$32.b]		; 07 32 ; OR accumulator with memory (long) [$32.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $060600.l,X		; FF 00 06 06 ; Subtract with carry (long,X) $060600.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $63.b,S		; 63 63 ; Add with carry (stack relative) $63.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	asl $160C.w		; 0E 0C 16 ; Arithmetic shift left $160C.w [Flags: NCZ]
	ora ($0B.b)		; 12 0B ; OR accumulator with memory (indirect) ($0B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $0002.w		; 20 02 00 ; Jump to subroutine at $0002.w [Writes: Stack Pointer] [Flow: call]
	tsb $13.b		; 04 13 ; Test and set bits $13.b [Reads: Accumulator] [Flags: Z]
	ora #$0A.b		; 09 0A ; Logical OR #$0A.b with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc $62E2.w,X		; FD E2 62 ; Subtract with carry $62E2.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	trb $07.b		; 14 07 ; Test and reset bits $07.b [Reads: Accumulator] [Flags: Z]
	ora $9C.b,S		; 03 9C ; OR accumulator with stack relative $9C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $F8.b,X		; 16 F8 ; Arithmetic shift left $F8.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora #$07.b		; 09 07 ; Logical OR #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	cpx $62.b		; E4 62 ; Compare $62.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($04.b,S),Y		; 13 04 ; OR accumulator (stack relative indirect indexed) ($04.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($ED.b,X)		; 01 ED ; Logical OR ($ED.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$18.b],Y		; 17 18 ; OR accumulator with memory (long indexed) [$18.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	trb $B002.w		; 1C 02 B0 ; Test and reset bits $B002.w [Reads: Accumulator] [Flags: Z]
	asl $6219.w		; 0E 19 62 ; Arithmetic shift left $6219.w [Flags: NCZ]
	asl $1A02.w,X		; 1E 02 1A ; Arithmetic shift left $1A02.w,X [Reads: X Index] [Flags: NCZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	sta $1C62.w,X		; 9D 62 1C ; Store accumulator to $1C62.w,X [Reads: Accumulator, X Index]
	cop $1A.b		; 02 1A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $FB4320.l,X		; 1F 20 43 FB ; Logical OR long $FB4320.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $6A02.w,X		; 1D 02 6A ; OR accumulator with memory $6A02.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	bit $2167.w,X		; 3C 67 21 ; Test bits $2167.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	tsb $2927.w		; 0C 27 29 ; Test and set bits $2927.w [Reads: Accumulator] [Flags: Z]
	ora $1D6A.w,X		; 1D 6A 1D ; OR accumulator with memory $1D6A.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	stx $F02A.w		; 8E 2A F0 ; Store X register to $F02A.w [Reads: X Index]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	sbc $E6.b		; E5 E6 ; Subtract $E6.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and ($24.b,X)		; 21 24 ; Logical AND ($24.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $E608.w		; 2C 08 E6 ; Test bits $E608.w with accumulator [Reads: Accumulator] [Flags: NVZ]
.INDEX 16
	rep #$1D		; C2 1D
	ldx $2DFA.w		; AE FA 2D ; Load $2DFA.w into X register [Writes: X Index] [Flags: NZ]
	ora $62E6A3.l,X		; 1F A3 E6 62 ; Logical OR long $62E6A3.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rol $1D04.w		; 2E 04 1D ; Rotate left $1D04.w [Flags: NCZ]
	and [$FF.b]		; 27 FF ; AND accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $1D.b		; E6 1D ; Increment $1D.b [Reads: Direct Page] [Flags: NZ]
	adc $31.b		; 65 31 ; Add $31.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	sbc $37.b		; E5 37 ; Subtract $37.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta [$38.b],Y		; 97 38 ; Store accumulator (long indexed) [$38.b],Y [Reads: Direct Page, Y Index, Accumulator]
	stz $6A.b,X		; 74 6A ; Store zero to $6A.b,X [Reads: X Index]
	jsl $1DDE74.l		; 22 74 DE 1D ; Jump to subroutine long $1DDE74.l [Writes: Stack Pointer] [Flow: call]
	and $3287.w,Y		; 39 87 32 ; AND accumulator with memory $3287.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$3A.b		; C9 3A ; Compare #$3A.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $3C.b		; E5 3C ; Subtract $3C.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and $3EF0.w,X		; 3D F0 3E ; AND accumulator with memory $3EF0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and ($34.b,S),Y		; 33 34 ; AND accumulator (stack relative indirect indexed) ($34.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $3F.b		; E6 3F ; Increment $3F.b [Reads: Direct Page] [Flags: NZ]
	.db $30, $FB		; 30 FB ; Branch if minus to $30, $FB [Flow: branch]
	stz $40.b		; 64 40 ; Store zero to $40.b
	cpx #$AF21.w		; E0 21 AF ; Compare #$AF21.w with X register [Reads: X Index] [Flags: NCZ]
	eor $2D.b		; 45 2D ; Exclusive OR $2D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr $FB.b		; 46 FB ; Logical shift right $FB.b [Reads: Direct Page] [Flags: NCZ]
	and [$FF.b]		; 27 FF ; AND accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc ($87.b,X)		; 61 87 ; Add with carry ($87.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor [$6A.b]		; 47 6A ; Exclusive OR accumulator with memory (long) [$6A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $30, $40		; 30 40 ; Branch if minus to $30, $40 [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	jsl $4AE549.l		; 22 49 E5 4A ; Jump to subroutine long $4AE549.l [Writes: Stack Pointer] [Flow: call]
	and $4B.b,X		; 35 4B ; Logical AND $4B.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	jmp $7422.w		; 4C 22 74 ; Jump to $7422.w [Flow: jump]
	adc [$8F.b]		; 67 8F ; Add with carry (long) [$8F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	eor $08A0.w		; 4D A0 08 ; Exclusive OR $08A0.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lsr $4F5E.w		; 4E 5E 4F ; Logical shift right $4F5E.w [Flags: NCZ]
	.db $50, $49		; 50 49 ; Branch if overflow clear to $50, $49 [Flow: branch]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $62, $51, $09		; 62 51 09 ; Push effective relative address $62, $51, $09 [Writes: Stack Pointer]
	and ($34.b,S),Y		; 33 34 ; AND accumulator (stack relative indirect indexed) ($34.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	mvn $55,$9C		; 54 9C 55 ; Move block negative $55,$9C [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	eor $56.b,S		; 43 56 ; Exclusive OR accumulator with stack relative $56.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor [$43.b],Y		; 57 43 ; Exclusive OR accumulator with memory (long indexed) [$43.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	mvp $58,$65		; 44 65 58 ; Move block positive $58,$65 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $416A.w		; 0D 6A 41 ; Logical OR $416A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	mvp $5E,$0D		; 44 0D 5E ; Move block positive $5E,$0D [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	lsr $605F.w		; 4E 5F 60 ; Logical shift right $605F.w [Flags: NCZ]
	lsr $804F.w		; 4E 4F 80 ; Logical shift right $804F.w [Flags: NCZ]
	adc ($62.b,X)		; 61 62 ; Add with carry ($62.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $62.b		; E5 62 ; Subtract $62.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc $00.b,S		; 63 00 ; Add with carry (stack relative) $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	adc $66.b		; 65 66 ; Add $66.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora [$58.b]		; 07 58 ; OR accumulator with memory (long) [$58.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $6C.b		; 65 6C ; Add $6C.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc $6EC9.w		; 6D C9 6E ; Add $6EC9.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	adc $706249.l		; 6F 49 62 70 ; Add with carry (long) $706249.l [Writes: Accumulator] [Flags: NCVZ]
	ora $747320.l		; 0F 20 73 74 ; OR accumulator with memory (long) $747320.l [Writes: Accumulator] [Flags: NZ]
	eor $1D1D92.l		; 4F 92 1D 1D ; Exclusive OR accumulator with memory (long) $1D1D92.l [Writes: Accumulator] [Flags: NZ]
	and $C932.w,Y		; 39 32 C9 ; AND accumulator with memory $C932.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $4F.b,X		; 75 4F ; Add $4F.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $77		; 30 77 ; Branch if minus to $30, $77 [Flow: branch]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $01FF.w,X		; 1D FF 01 ; OR accumulator with memory $01FF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $070201.l		; 22 01 02 07 ; Jump to subroutine long $070201.l [Writes: Stack Pointer] [Flow: call]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and [$07.b]		; 27 07 ; AND accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $020401.l		; 22 01 04 02 ; Jump to subroutine long $020401.l [Writes: Stack Pointer] [Flow: call]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $07.b,S		; 23 07 ; AND accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $010207.l		; 22 07 02 01 ; Jump to subroutine long $010207.l [Writes: Stack Pointer] [Flow: call]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $07.b,S		; 23 07 ; AND accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$07.b]		; 27 07 ; AND accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $24.b		; 05 24 ; Logical OR $24.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $29.b		; 06 29 ; Arithmetic shift left $29.b [Reads: Direct Page] [Flags: NCZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $23.b		; 06 23 ; Arithmetic shift left $23.b [Reads: Direct Page] [Flags: NCZ]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $07.b,S		; 23 07 ; AND accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $07.b		; 24 07 ; Test bits $07.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	eor ($01.b,S),Y		; 53 01 ; XOR accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $07.b		; 25 07 ; Logical AND $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $25.b		; 00 25 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($25.b,X)		; 01 25 ; Logical OR ($25.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	eor ($00.b)		; 52 00 ; Exclusive OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $27.b		; 06 27 ; Arithmetic shift left $27.b [Reads: Direct Page] [Flags: NCZ]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0A.b]		; 07 0A ; OR accumulator with memory (long) [$0A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $06.b		; 04 06 ; Test and set bits $06.b [Reads: Accumulator] [Flags: Z]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	ora [$02.b]		; 07 02 ; OR accumulator with memory (long) [$02.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $84.b,S		; 03 84 ; OR accumulator with stack relative $84.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $AB.b		; 00 AB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	cop $28.b		; 02 28 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	cmp $27.b		; C5 27 ; Compare $27.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $83.b		; 02 83 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A6.b		; 00 A6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	eor $00.b,X		; 55 00 ; Exclusive OR accumulator with memory $00.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $26.b		; 00 26 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $2032E0.l,X		; FF E0 32 20 ; Subtract with carry (long,X) $2032E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $ED.b,X		; 76 ED ; Rotate right $ED.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	adc [$F8.b],Y		; 77 F8 ; Add with carry (long indexed) [$F8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$78.b],Y		; 17 78 ; OR accumulator with memory (long indexed) [$78.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $7879.w,Y		; 79 79 78 ; Add $7879.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($7A.b)		; 12 7A ; OR accumulator with memory (indirect) ($7A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $FBED.w		; ED ED FB ; Subtract $FBED.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	adc [$FB.b],Y		; 77 FB ; Add with carry (long indexed) [$FB.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $7C.b,S		; 03 7C ; OR accumulator with stack relative $7C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $7C7D.w,X		; 7D 7D 7C ; Add $7C7D.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	stz $7F7E.w		; 9C 7E 7F ; Store zero to $7F7E.w
	adc $9DEDF8.l,X		; 7F F8 ED 9D ; Add long $9DEDF8.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	sta ($80.b,X)		; 81 80 ; Store accumulator ($80.b,X) [Reads: Direct Page, Accumulator, X Index]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $82, $83, $83		; 82 83 83 ; Branch always long to $82, $83, $83 [Flow: branch]
	.db $82, $1F, $84		; 82 1F 84 ; Branch always long to $82, $1F, $84 [Flow: branch]
	sta $85.b		; 85 85 ; Store accumulator to $85.b [Reads: Accumulator]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sta $2386.w,X		; 9D 86 23 ; Store accumulator to $2386.w,X [Reads: Accumulator, X Index]
	rol $05.b		; 26 05 ; Rotate left $05.b [Reads: Direct Page] [Flags: NCZ]
	ora $8887.w,Y		; 19 87 88 ; OR accumulator with memory $8887.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta [$36.b]		; 87 36 ; Store accumulator (long) [$36.b] [Reads: Direct Page, Accumulator]
	.db $62, $89, $02		; 62 89 02 ; Push effective relative address $62, $89, $02 [Writes: Stack Pointer]
	and #$8C.b		; 29 8C ; Logical AND #$8C.b with accumulator [Writes: Accumulator] [Flags: NZ]
	and ($62.b,X)		; 21 62 ; Logical AND ($62.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta $2C17.w		; 8D 17 2C ; Store accumulator to $2C17.w [Reads: Accumulator]
	jsl $90E549.l		; 22 49 E5 90 ; Jump to subroutine long $90E549.l [Writes: Stack Pointer] [Flow: call]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $2E.b		; E6 2E ; Increment $2E.b [Reads: Direct Page] [Flags: NZ]
	sta $922C91.l		; 8F 91 2C 92 ; Store accumulator (long) $922C91.l [Reads: Accumulator]
	and $9309EE.l		; 2F EE 09 93 ; AND accumulator with memory (long) $9309EE.l [Writes: Accumulator] [Flags: NZ]
	asl $9594.w,X		; 1E 94 95 ; Arithmetic shift left $9594.w,X [Reads: X Index] [Flags: NCZ]
	bit $E5.b		; 24 E5 ; Test bits $E5.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	inc $2E.b		; E6 2E ; Increment $2E.b [Reads: Direct Page] [Flags: NZ]
	and $059662.l		; 2F 62 96 05 ; AND accumulator with memory (long) $059662.l [Writes: Accumulator] [Flags: NZ]
	cmp #$FE.b		; C9 FE ; Compare #$FE.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	sta $3231.w,Y		; 99 31 32 ; Store accumulator to $3231.w,Y [Reads: Y Index, Accumulator]
	jmp ($9A62.w,X)		; 7C 62 9A ; Jump indirect indexed to ($9A62.w,X) [Reads: X Index] [Flow: jump]
	asl $8B.b		; 06 8B ; Arithmetic shift left $8B.b [Reads: Direct Page] [Flags: NCZ]
	sta $8D2F.w,X		; 9D 2F 8D ; Store accumulator to $8D2F.w,X [Reads: Accumulator, X Index]
	stz $1D9F.w,X		; 9E 9F 1D ; Store zero to $1D9F.w,X [Reads: X Index]
	.db $62, $39, $62		; 62 39 62 ; Push effective relative address $62, $39, $62 [Writes: Stack Pointer]
	and $A065.w,Y		; 39 65 A0 ; AND accumulator with memory $A065.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $97.b		; 06 97 ; Arithmetic shift left $97.b [Reads: Direct Page] [Flags: NCZ]
	sta [$A6.b],Y		; 97 A6 ; Store accumulator (long indexed) [$A6.b],Y [Reads: Direct Page, Y Index, Accumulator]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sta ($A7.b),Y		; 91 A7 ; Store accumulator ($A7.b),Y [Reads: Direct Page, Y Index, Accumulator]
	and $08A867.l,X		; 3F 67 A8 08 ; AND accumulator with memory (long,X) $08A867.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $A02E.w,X		; 1D 2E A0 ; OR accumulator with memory $A02E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	stx $62.b,Y		; 96 62 ; Store X register $62.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	jsl $64090B.l		; 22 0B 09 64 ; Jump to subroutine long $64090B.l [Writes: Stack Pointer] [Flow: call]
	.db $B0, $0A		; B0 0A ; Branch if carry set to $B0, $0A [Flow: branch]
	ora $2EB6B5.l,X		; 1F B5 B6 2E ; Logical OR long $2EB6B5.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldy #$68B7.w		; A0 B7 68 ; Load #$68B7.w into Y register [Writes: Y Index] [Flags: NZ]
	ldx $0630.w,Y		; BE 30 06 ; Load X register $0630.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	.db $10, $62		; 10 62 ; Branch if plus to $10, $62 [Flow: branch]
	clv		; B8 ; Clear overflow flag [Flags: V]
	brk $58.b		; 00 58 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $BB, $08		; 62 BB 08 ; Push effective relative address $62, $BB, $08 [Writes: Stack Pointer]
	ora $E608.w,X		; 1D 08 E6 ; OR accumulator with memory $E608.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldx $6A29.w,Y		; BE 29 6A ; Load X register $6A29.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ora $711A.w,Y		; 19 1A 71 ; OR accumulator with memory $711A.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $BF, $12		; 62 BF 12 ; Push effective relative address $62, $BF, $12 [Writes: Stack Pointer]
	lda ($96.b)		; B2 96 ; Load accumulator (indirect) ($96.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	mvp $9F,$C2		; 44 C2 9F ; Move block positive $9F,$C2 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cpx $24.b		; E4 24 ; Compare $24.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	cmp $97.b,S		; C3 97 ; Compare accumulator (stack relative) $97.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	mvp $27,$86		; 44 86 27 ; Move block positive $27,$86 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora #$2F.b		; 09 2F ; Logical OR #$2F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	lda [$C4.b],Y		; B7 C4 ; Load accumulator (long indexed) [$C4.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $9F9E.w		; 8D 9E 9F ; Store accumulator to $9F9E.w [Reads: Accumulator]
	stz $C5.b		; 64 C5 ; Store zero to $C5.b
	ora [$9F.b]		; 07 9F ; OR accumulator with memory (long) [$9F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sta $0ECB.w		; 8D CB 0E ; Store accumulator to $0ECB.w [Reads: Accumulator]
	and $678DCC.l		; 2F CC 8D 67 ; AND accumulator with memory (long) $678DCC.l [Writes: Accumulator] [Flags: NZ]
	cmp $A903.w		; CD 03 A9 ; Compare $A903.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	eor $22D6D5.l		; 4F D5 D6 22 ; Exclusive OR accumulator with memory (long) $22D6D5.l [Writes: Accumulator] [Flags: NZ]
	jmp $D711.w		; 4C 11 D7 ; Jump to $D711.w [Flow: jump]
	dec $D848.w		; CE 48 D8 ; Decrement $D848.w [Flags: NZ]
	sta $D2D9.w		; 8D D9 D2 ; Store accumulator to $D2D9.w [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	lda #$DC.b		; A9 DC ; Load #$DC.b into accumulator [Writes: Accumulator] [Flags: NZ]
	eor $DDDEDD.l		; 4F DD DE DD ; Exclusive OR accumulator with memory (long) $DDDEDD.l [Writes: Accumulator] [Flags: NZ]
	cmp $48DF.w,X		; DD DF 48 ; Compare accumulator $48DF.w,X [Reads: X Index] [Flags: NCZ]
	.db $62, $E0, $03		; 62 E0 03 ; Push effective relative address $62, $E0, $03 [Writes: Stack Pointer]
	sta $E396.w		; 8D 96 E3 ; Store accumulator to $E396.w [Reads: Accumulator]
	sbc $0022FF.l,X		; FF FF 22 00 ; Subtract with carry (long,X) $0022FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$04.b]		; 07 04 ; OR accumulator with memory (long) [$04.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $010200.l		; 22 00 02 01 ; Jump to subroutine long $010200.l [Writes: Stack Pointer] [Flow: call]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	tsb $84.b		; 04 84 ; Test and set bits $84.b [Reads: Accumulator] [Flags: Z]
	brk $15.b		; 00 15 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($2B.b,X)		; 01 2B ; Logical OR ($2B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$04.b]		; 07 04 ; OR accumulator with memory (long) [$04.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $2B.b		; 06 2B ; Arithmetic shift left $2B.b [Reads: Direct Page] [Flags: NCZ]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	ora ($25.b,X)		; 01 25 ; Logical OR ($25.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$83.b]		; 07 83 ; OR accumulator with memory (long) [$83.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$0C.b]		; 07 0C ; OR accumulator with memory (long) [$0C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: NCZ]
	tsb $83.b		; 04 83 ; Test and set bits $83.b [Reads: Accumulator] [Flags: Z]
	brk $2E.b		; 00 2E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $25.b		; 06 25 ; Arithmetic shift left $25.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora #$07.b		; 09 07 ; Logical OR #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $08.b		; 06 08 ; Arithmetic shift left $08.b [Reads: Direct Page] [Flags: NCZ]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($25.b,X)		; 01 25 ; Logical OR ($25.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora #$07.b		; 09 07 ; Logical OR #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $8308.w		; 2C 08 83 ; Test bits $8308.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	bit $0208.w		; 2C 08 02 ; Test bits $0208.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$08.b]		; 27 08 ; AND accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	.db $70, $02		; 70 02 ; Branch if overflow set to $70, $02 [Flow: branch]
	asl $08.b		; 06 08 ; Arithmetic shift left $08.b [Reads: Direct Page] [Flags: NCZ]
	ora ($27.b,X)		; 01 27 ; Logical OR ($27.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	ora [$2A.b]		; 07 2A ; OR accumulator with memory (long) [$2A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $070008.l		; 22 08 00 07 ; Jump to subroutine long $070008.l [Writes: Stack Pointer] [Flow: call]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc $090B05.l,X		; FF 05 0B 09 ; Subtract with carry (long,X) $090B05.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	stz $E4.b,X		; 74 E4 ; Store zero to $E4.b,X [Reads: X Index]
	jsl $000083.l		; 22 83 00 00 ; Jump to subroutine long $000083.l [Writes: Stack Pointer] [Flow: call]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	.db $62, $06, $07		; 62 06 07 ; Push effective relative address $62, $06, $07 [Writes: Stack Pointer]
	bit $3347.w,X		; 3C 47 33 ; Test bits $3347.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	.db $B0, $0E		; B0 0E ; Branch if carry set to $B0, $0E [Flow: branch]
	.db $62, $34, $3B		; 62 34 3B ; Push effective relative address $62, $34, $3B [Writes: Stack Pointer]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ora $05.b,X		; 15 05 ; OR accumulator with memory $05.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $02		; B0 02 ; Branch if carry set to $B0, $02 [Flow: branch]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor [$23.b]		; 47 23 ; Exclusive OR accumulator with memory (long) [$23.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $62.b		; E5 62 ; Subtract $62.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inc $62.b		; E6 62 ; Increment $62.b [Reads: Direct Page] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	ora $E7.b		; 05 E7 ; Logical OR $E7.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora #$EB.b		; 09 EB ; Logical OR #$EB.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cpx $A022.w		; EC 22 A0 ; Compare $A022.w with X register [Reads: X Index] [Flags: NCZ]
	adc $ED.b,S		; 63 ED ; Add with carry (stack relative) $ED.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $62, $F0, $00		; 62 F0 00 ; Push effective relative address $62, $F0, $00 [Writes: Stack Pointer]
	sbc $0AF363.l		; EF 63 F3 0A ; Subtract with carry (long) $0AF363.l [Writes: Accumulator] [Flags: NCVZ]
	ldy #$FB1E.w		; A0 1E FB ; Load #$FB1E.w into Y register [Writes: Y Index] [Flags: NZ]
	lda $EEBA.w,Y		; B9 BA EE ; Load $EEBA.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $42, $61		; 42 61 ; Reserved instruction
	.db $62, $F7, $F2		; 62 F7 F2 ; Push effective relative address $62, $F7, $F2 [Writes: Stack Pointer]
	adc $F8.b,S		; 63 F8 ; Add with carry (stack relative) $F8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$E520.w		; E0 20 E5 ; Compare #$E520.w with X register [Reads: X Index] [Flags: NCZ]
	cmp $FDFC.w,Y		; D9 FC FD ; Compare accumulator $FDFC.w,Y [Reads: Y Index] [Flags: NCZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ldy $1DEE.w,X		; BC EE 1D ; Load Y register $1DEE.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	adc [$68.b]		; 67 68 ; Add with carry (long) [$68.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$F2.b],Y		; F7 F2 ; Subtract with carry (long indexed) [$F2.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $090B.w,X		; FE 0B 09 ; Increment memory $090B.w,X [Reads: X Index] [Flags: NZ]
	sbc $70E400.l,X		; FF 00 E4 70 ; Subtract with carry (long,X) $70E400.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $EE1DBD.l		; 6F BD 1D EE ; Add with carry (long) $EE1DBD.l [Writes: Accumulator] [Flags: NCVZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cmp $F2F729.l,X		; DF 29 F7 F2 ; Compare accumulator (long,X) $F2F729.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	ora $1006.w,X		; 1D 06 10 ; OR accumulator with memory $1006.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $022401.l		; 2F 01 24 02 ; AND accumulator with memory (long) $022401.l [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	inc $DB59.w		; EE 59 DB ; Increment $DB59.w [Flags: NZ]
	rol $F203.w,X		; 3E 03 F2 ; Rotate left $F203.w,X [Reads: X Index] [Flags: NCZ]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	adc ($26.b),Y		; 71 26 ; Add with carry ($26.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $080A07.l		; 22 07 0A 08 ; Jump to subroutine long $080A07.l [Writes: Stack Pointer] [Flow: call]
	inc $5E5D.w		; EE 5D 5E ; Increment $5E5D.w [Flags: NZ]
	adc ($09.b,X)		; 61 09 ; Add with carry ($09.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc ($0B.b,X)		; 61 0B ; Add with carry ($0B.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora #$2F.b		; 09 2F ; Logical OR #$2F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $14.b		; 05 14 ; Logical OR $14.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $10.b		; 06 10 ; Arithmetic shift left $10.b [Reads: Direct Page] [Flags: NCZ]
	and $6A370B.l		; 2F 0B 37 6A ; AND accumulator with memory (long) $6A370B.l [Writes: Accumulator] [Flags: NZ]
	ora [$03.b],Y		; 17 03 ; OR accumulator with memory (long indexed) [$03.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cop $71.b		; 02 71 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $0B.b		; 26 0B ; Rotate left $0B.b [Reads: Direct Page] [Flags: NCZ]
	stz $22.b		; 64 22 ; Store zero to $22.b
	brk $1B.b		; 00 1B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $27.b		; 65 27 ; Add $27.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	.db $90, $62		; 90 62 ; Branch if carry clear to $90, $62 [Flow: branch]
	and $6A02.w		; 2D 02 6A ; Logical AND $6A02.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $10, $1B		; 10 1B ; Branch if plus to $10, $1B [Flow: branch]
	.db $62, $30, $02		; 62 30 02 ; Push effective relative address $62, $30, $02 [Writes: Stack Pointer]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tsb $8333.w		; 0C 33 83 ; Test and set bits $8333.w [Reads: Accumulator] [Flags: Z]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $34.b		; 05 34 ; Logical OR $34.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	stz $35.b,X		; 74 35 ; Store zero to $35.b,X [Reads: X Index]
	asl $1B36.w,X		; 1E 36 1B ; Arithmetic shift left $1B36.w,X [Reads: X Index] [Flags: NCZ]
	.db $62, $37, $02		; 62 37 02 ; Push effective relative address $62, $37, $02 [Writes: Stack Pointer]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	.db $B0, $00		; B0 00 ; Branch if carry set to $B0, $00 [Flow: branch]
	sbc [$64.b]		; E7 64 ; Subtract with carry (long) [$64.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	bit $0083.w,X		; 3C 83 00 ; Test bits $0083.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ora ($2D.b,X)		; 01 2D ; Logical OR ($2D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor ($83.b,X)		; 41 83 ; Exclusive OR accumulator with memory ($83.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $2B.b		; 04 2B ; Test and set bits $2B.b [Reads: Accumulator] [Flags: Z]
	.db $42, $E4		; 42 E4 ; Reserved instruction
	eor $44.b,S		; 43 44 ; Exclusive OR accumulator with stack relative $44.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	cmp $4501.w,Y		; D9 01 45 ; Compare accumulator $4501.w,Y [Reads: Y Index] [Flags: NCZ]
	lsr $FF.b		; 46 FF ; Logical shift right $FF.b [Reads: Direct Page] [Flags: NCZ]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $08.b,S		; 23 08 ; AND accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	rol $07.b		; 26 07 ; Rotate left $07.b [Reads: Direct Page] [Flags: NCZ]
	asl $08.b		; 06 08 ; Arithmetic shift left $08.b [Reads: Direct Page] [Flags: NCZ]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $08.b		; 25 08 ; Logical AND $08.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($2A.b,X)		; 01 2A ; Logical OR ($2A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $0208.w		; 2C 08 02 ; Test bits $0208.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $43.b,S		; 03 43 ; OR accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora #$01.b		; 09 01 ; Logical OR #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $04.b		; 06 04 ; Arithmetic shift left $04.b [Reads: Direct Page] [Flags: NCZ]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $22.b		; 05 22 ; Logical OR $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $020308.l		; 22 08 03 02 ; Jump to subroutine long $020308.l [Writes: Stack Pointer] [Flow: call]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	ora [$83.b]		; 07 83 ; OR accumulator with memory (long) [$83.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $02.b		; 25 02 ; Logical AND $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$04.b		; 09 04 ; Logical OR #$04.b with accumulator [Writes: Accumulator] [Flags: NZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$2D.b]		; 07 2D ; OR accumulator with memory (long) [$2D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $030008.l		; 2F 08 00 03 ; AND accumulator with memory (long) $030008.l [Writes: Accumulator] [Flags: NZ]
	eor $08.b,S		; 43 08 ; Exclusive OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$26.b]		; 07 26 ; OR accumulator with memory (long) [$26.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $070408.l		; 22 08 04 07 ; Jump to subroutine long $070408.l [Writes: Stack Pointer] [Flow: call]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $08.b		; 25 08 ; Logical AND $08.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $08.b,S		; 23 08 ; AND accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	lda ($00.b,S),Y		; B3 00 ; Load accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($29.b,X)		; 01 29 ; Logical OR ($29.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C5.b		; 00 C5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $008508.l		; 22 08 85 00 ; Jump to subroutine long $008508.l [Writes: Stack Pointer] [Flow: call]
	lda ($01.b,S),Y		; B3 01 ; Load accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $070108.l		; 22 08 01 07 ; Jump to subroutine long $070108.l [Writes: Stack Pointer] [Flow: call]
	ora $FF.b		; 05 FF ; Logical OR $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $62, $09, $62		; 62 09 62 ; Push effective relative address $62, $09, $62 [Writes: Stack Pointer]
	ora #$05.b		; 09 05 ; Logical OR #$05.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$2F.b		; 09 2F ; Logical OR #$2F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	eor [$48.b]		; 47 48 ; Exclusive OR accumulator with memory (long) [$48.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $634E.w		; 4D 4E 63 ; Exclusive OR $634E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	eor #$0A.b		; 49 0A ; Exclusive OR #$0A.b with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $B062.w		; 0E 62 B0 ; Arithmetic shift left $B062.w [Flags: NCZ]
	asl $B062.w		; 0E 62 B0 ; Arithmetic shift left $B062.w [Flags: NCZ]
	asl $4D2F.w		; 0E 2F 4D ; Arithmetic shift left $4D2F.w [Flags: NCZ]
	lsr $6457.w		; 4E 57 64 ; Logical shift right $6457.w [Flags: NCZ]
	eor $0BE826.l		; 4F 26 E8 0B ; Exclusive OR accumulator with memory (long) $0BE826.l [Writes: Accumulator] [Flags: NZ]
	and $543DEA.l,X		; 3F EA 3D 54 ; AND accumulator with memory (long,X) $543DEA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $551D74.l		; 22 74 1D 55 ; Jump to subroutine long $551D74.l [Writes: Stack Pointer] [Flow: call]
	lsr $F0.b,X		; 56 F0 ; Logical shift right $F0.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $F0, $57		; F0 57 ; Branch if equal to $F0, $57 [Flow: branch]
	jsl $590C58.l		; 22 58 0C 59 ; Jump to subroutine long $590C58.l [Writes: Stack Pointer] [Flow: call]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	inc $EE35.w		; EE 35 EE ; Increment $EE35.w [Flags: NZ]
	and ($34.b,S),Y		; 33 34 ; AND accumulator (stack relative indirect indexed) ($34.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	adc [$5C.b]		; 67 5C ; Add with carry (long) [$5C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	eor $2217.w,X		; 5D 17 22 ; Exclusive OR accumulator with memory $2217.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$19.b]		; 07 19 ; OR accumulator with memory (long) [$19.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr $5F11.w,X		; 5E 11 5F ; Logical shift right $5F11.w,X [Reads: X Index] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $1D.b		; E5 1D ; Subtract $1D.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda ($64.b,X)		; A1 64 ; Load accumulator ($64.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc ($03.b,X)		; 61 03 ; Add with carry ($03.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $66.b		; 24 66 ; Test bits $66.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	bit $25.b		; 24 25 ; Test bits $25.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	adc $67.b,S		; 63 67 ; Add with carry (stack relative) $67.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	trb $1D.b		; 14 1D ; Test and reset bits $1D.b [Reads: Accumulator] [Flags: Z]
	ora $6B9A.w,X		; 1D 9A 6B ; OR accumulator with memory $6B9A.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldy $6C.b		; A4 6C ; Load $6C.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	stz $CC.b,X		; 74 CC ; Store zero to $CC.b,X [Reads: X Index]
	and $1E2F6D.l		; 2F 6D 2F 1E ; AND accumulator with memory (long) $1E2F6D.l [Writes: Accumulator] [Flags: NZ]
	.db $42, $B9		; 42 B9 ; Reserved instruction
	ldx $E5EE.w,Y		; BE EE E5 ; Load X register $E5EE.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and ($C9.b)		; 32 C9 ; AND accumulator with memory (indirect) ($C9.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $22.b		; E5 22 ; Subtract $22.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ror $B700.w		; 6E 00 B7 ; Rotate right $B700.w [Flags: NCZ]
	.db $62, $6E, $08		; 62 6E 08 ; Push effective relative address $62, $6E, $08 [Writes: Stack Pointer]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cmp #$C0.b		; C9 C0 ; Compare #$C0.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	inc $1E1D.w		; EE 1D 1E ; Increment $1E1D.w [Flags: NZ]
	adc ($72.b),Y		; 71 72 ; Add with carry ($72.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $25.b		; E5 25 ; Subtract $25.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc ($09.b,X)		; 61 09 ; Add with carry ($09.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	tsb $6A.b		; 04 6A ; Test and set bits $6A.b [Reads: Accumulator] [Flags: Z]
	inc $74E5.w		; EE E5 74 ; Increment $74E5.w [Flags: NZ]
	rol $4973.w,X		; 3E 73 49 ; Rotate left $4973.w,X [Reads: X Index] [Flags: NCZ]
	and $14.b		; 25 14 ; Logical AND $14.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $74.b		; 00 74 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $750412.l		; 22 12 04 75 ; Jump to subroutine long $750412.l [Writes: Stack Pointer] [Flow: call]
	ora ($12.b)		; 12 12 ; OR accumulator with memory (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror $3E.b,X		; 76 3E ; Rotate right $3E.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	adc $77.b		; 65 77 ; Add $77.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc $7C.b,S		; 63 7C ; Add with carry (stack relative) $7C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	jsl $816280.l		; 22 80 62 81 ; Jump to subroutine long $816280.l [Writes: Stack Pointer] [Flow: call]
	ora #$32.b		; 09 32 ; Logical OR #$32.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sty $F0.b		; 84 F0 ; Store Y register to $F0.b [Reads: Y Index]
	sta $F2.b		; 85 F2 ; Store accumulator to $F2.b [Reads: Accumulator]
	sbc $86.b		; E5 86 ; Subtract $86.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta [$F2.b]		; 87 F2 ; Store accumulator (long) [$F2.b] [Reads: Direct Page, Accumulator]
	and $0D62.w		; 2D 62 0D ; Logical AND $0D62.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $62, $88, $00		; 62 88 00 ; Push effective relative address $62, $88, $00 [Writes: Stack Pointer]
	and ($62.b)		; 32 62 ; AND accumulator with memory (indirect) ($62.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	ora $F2.b		; 05 F2 ; Logical OR $F2.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $F2F7.w,X		; 1D F7 F2 ; OR accumulator with memory $F2F7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $1762.w		; 0C 62 17 ; Test and set bits $1762.w [Reads: Accumulator] [Flags: Z]
	cop $8E.b		; 02 8E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $9063AE.l		; 8F AE 63 90 ; Store accumulator (long) $9063AE.l [Reads: Accumulator]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	lda ($00.b,S),Y		; B3 00 ; Load accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and [$62.b],Y		; 37 62 ; AND accumulator with memory (long indexed) [$62.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $66.b,S		; 23 66 ; AND accumulator with stack relative $66.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sty $0C.b,X		; 94 0C ; Store Y register $0C.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	sbc ($1D.b)		; F2 1D ; Subtract with carry (indirect) ($1D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $F2F7.w,X		; 1D F7 F2 ; OR accumulator with memory $F2F7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $1F2F6A.l		; 22 6A 2F 1F ; Jump to subroutine long $1F2F6A.l [Writes: Stack Pointer] [Flow: call]
	sbc [$9B.b],Y		; F7 9B ; Subtract with carry (long indexed) [$9B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($C9.b,X)		; 61 C9 ; Add with carry ($C9.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $62, $9C, $84		; 62 9C 84 ; Push effective relative address $62, $9C, $84 [Writes: Stack Pointer]
	brk $B3.b		; 00 B3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0C.b]		; 07 0C ; OR accumulator with memory (long) [$0C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $9F1D.w,X		; 1D 1D 9F ; OR accumulator with memory $9F1D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldy #$619B.w		; A0 9B 61 ; Load #$619B.w into Y register [Writes: Y Index] [Flags: NZ]
	cmp #$FF.b		; C9 FF ; Compare #$FF.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $000108.l		; 22 08 01 00 ; Jump to subroutine long $000108.l [Writes: Stack Pointer] [Flow: call]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $01.b,S		; 43 01 ; Exclusive OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$04.b]		; 07 04 ; OR accumulator with memory (long) [$04.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $000308.l		; 22 08 03 00 ; Jump to subroutine long $000308.l [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $08.b,S		; 23 08 ; AND accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $001101.l		; 22 01 11 00 ; Jump to subroutine long $001101.l [Writes: Stack Pointer] [Flow: call]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $2D.b		; 00 2D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $004301.l		; 22 01 43 00 ; Jump to subroutine long $004301.l [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	and ($00.b),Y		; 31 00 ; AND accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora [$62.b]		; 07 62 ; OR accumulator with memory (long) [$62.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	and #$05.b		; 29 05 ; Logical AND #$05.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $082207.l		; 22 07 22 08 ; Jump to subroutine long $082207.l [Writes: Stack Pointer] [Flow: call]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	eor ($24.b)		; 52 24 ; Exclusive OR accumulator with memory (indirect) ($24.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsl $030807.l		; 22 07 08 03 ; Jump to subroutine long $030807.l [Writes: Stack Pointer] [Flow: call]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $07.b,S		; 43 07 ; Exclusive OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	eor $01.b,S		; 43 01 ; Exclusive OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	jsl $040401.l		; 22 01 04 04 ; Jump to subroutine long $040401.l [Writes: Stack Pointer] [Flow: call]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $040007.l		; 22 07 00 04 ; Jump to subroutine long $040007.l [Writes: Stack Pointer] [Flow: call]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	mvn $08,$0E		; 54 0E 08 ; Move block negative $08,$0E [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $22.b		; 05 22 ; Logical OR $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	ora $08.b		; 05 08 ; Logical OR $08.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	dec $06.b,X		; D6 06 ; Decrement memory $06.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	sbc [$02.b]		; E7 02 ; Subtract with carry (long) [$02.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $FF.b		; 05 FF ; Logical OR $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $4E.b		; 05 4E ; Logical OR $4E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda ($4C.b,X)		; A1 4C ; Load accumulator ($4C.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ldx #$1C1D.w		; A2 1D 1C ; Load #$1C1D.w into X register [Writes: X Index] [Flags: NZ]
	.db $62, $A3, $16		; 62 A3 16 ; Push effective relative address $62, $A3, $16 [Writes: Stack Pointer]
	lda ($67.b)		; B2 67 ; Load accumulator (indirect) ($67.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr $95A6.w		; 4E A6 95 ; Logical shift right $95A6.w [Flags: NCZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $53A7.w,X		; 3D A7 53 ; AND accumulator with memory $53A7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda ($A9.b)		; B2 A9 ; Load accumulator (indirect) ($A9.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldx $26.b,Y		; B6 26 ; Load X register $26.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	ora $AA1D.w,X		; 1D 1D AA ; OR accumulator with memory $AA1D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($58.b),Y		; 51 58 ; Exclusive OR accumulator with memory ($58.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	sta $E5.b,X		; 95 E5 ; Store accumulator to $E5.b,X [Reads: Accumulator, X Index]
	adc $AC.b,S		; 63 AC ; Add with carry (stack relative) $AC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$B63C.w		; E0 3C B6 ; Compare #$B63C.w with X register [Reads: X Index] [Flags: NCZ]
	.db $B0, $09		; B0 09 ; Branch if carry set to $B0, $09 [Flow: branch]
	sta ($61.b,S),Y		; 93 61 ; Store accumulator (stack relative indirect indexed) ($61.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	.db $62, $2D, $C9		; 62 2D C9 ; Push effective relative address $62, $2D, $C9 [Writes: Stack Pointer]
	inc $95B1.w,X		; FE B1 95 ; Increment memory $95B1.w,X [Reads: X Index] [Flags: NZ]
	lda ($B3.b)		; B2 B3 ; Load accumulator (indirect) ($B3.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $EEC2.w,Y		; 99 C2 EE ; Store accumulator to $EEC2.w,Y [Reads: Y Index, Accumulator]
	ora #$B4.b		; 09 B4 ; Logical OR #$B4.b with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $67F6.w		; 0E F6 67 ; Arithmetic shift left $67F6.w [Flags: NCZ]
	lda $1C.b,X		; B5 1C ; Load $1C.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $B63A.w,Y		; 39 3A B6 ; AND accumulator with memory $B63A.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $B2.b,X		; 95 B2 ; Store accumulator to $B2.b,X [Reads: Accumulator, X Index]
	lda [$67.b],Y		; B7 67 ; Load accumulator (long indexed) [$67.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ldy #$0E30.w		; A0 30 0E ; Load #$0E30.w into Y register [Writes: Y Index] [Flags: NZ]
	inc $B8.b,X		; F6 B8 ; Increment memory $B8.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	ldx $B9.b,Y		; B6 B9 ; Load X register $B9.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	and #$24.b		; 29 24 ; Logical AND #$24.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($8E.b),Y		; 91 8E ; Store accumulator ($8E.b),Y [Reads: Direct Page, Y Index, Accumulator]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	sta $E5.b,X		; 95 E5 ; Store accumulator to $E5.b,X [Reads: Accumulator, X Index]
	ldy $20.b		; A4 20 ; Load $20.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	cmp $61BB.w,Y		; D9 BB 61 ; Compare accumulator $61BB.w,Y [Reads: Y Index] [Flags: NCZ]
	.db $62, $EE, $09		; 62 EE 09 ; Push effective relative address $62, $EE, $09 [Writes: Stack Pointer]
	and $422499.l		; 2F 99 24 42 ; AND accumulator with memory (long) $422499.l [Writes: Accumulator] [Flags: NZ]
	eor $BC.b,S		; 43 BC ; Exclusive OR accumulator with stack relative $BC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $3B.b,X		; 95 3B ; Store accumulator to $3B.b,X [Reads: Accumulator, X Index]
	ora $BD62.w,X		; 1D 62 BD ; OR accumulator with memory $BD62.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $67.b		; 04 67 ; Test and set bits $67.b [Reads: Accumulator] [Flags: Z]
	lda $30.b,X		; B5 30 ; Load $30.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	asl $64F6.w		; 0E F6 64 ; Arithmetic shift left $64F6.w [Flags: NCZ]
	cpy #$950D.w		; C0 0D 95 ; Compare #$950D.w with Y register [Reads: Y Index] [Flags: NCZ]
	lda ($3B.b)		; B2 3B ; Load accumulator (indirect) ($3B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror $556F.w		; 6E 6F 55 ; Rotate right $556F.w [Flags: NCZ]
	cmp $FF2729.l,X		; DF 29 27 FF ; Compare accumulator (long,X) $FF2729.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	cmp $53.b		; C5 53 ; Compare $53.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	and $C662.w,X		; 3D 62 C6 ; AND accumulator with memory $C662.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $42.b,S		; 03 42 ; OR accumulator with stack relative $42.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp #$CA.b		; C9 CA ; Compare #$CA.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	eor #$62.b		; 49 62 ; Exclusive OR #$62.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $42, $12		; 42 12 ; Reserved instruction
	jsl $55AA74.l		; 22 74 AA 55 ; Jump to subroutine long $55AA74.l [Writes: Stack Pointer] [Flow: call]
	ldx $A5A4.w		; AE A4 A5 ; Load $A5A4.w into X register [Writes: X Index] [Flags: NZ]
	.db $30, $40		; 30 40 ; Branch if minus to $30, $40 [Flow: branch]
	wai		; CB ; Wait for interrupt
	eor ($CC.b)		; 52 CC ; Exclusive OR accumulator with memory (indirect) ($CC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy #$4ECD.w		; A0 CD 4E ; Load #$4ECD.w into Y register [Writes: Y Index] [Flags: NZ]
	dec $CF33.w		; CE 33 CF ; Decrement $CF33.w [Flags: NZ]
	trb $9F43.w		; 1C 43 9F ; Test and reset bits $9F43.w [Reads: Accumulator] [Flags: Z]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	cpx #$C52A.w		; E0 2A C5 ; Compare #$C52A.w with X register [Reads: X Index] [Flags: NCZ]
	.db $30, $8B		; 30 8B ; Branch if minus to $30, $8B [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	adc ($57.b,S),Y		; 73 57 ; Add with carry (stack relative indirect indexed) ($57.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	.db $D0, $BF		; D0 BF ; Branch if not equal to $D0, $BF [Flow: branch]
	ora $6261.w,X		; 1D 61 62 ; OR accumulator with memory $6261.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	and [$FF.b]		; 27 FF ; AND accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $A1.b,S		; 03 A1 ; OR accumulator with stack relative $A1.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
.ACCU 16
.INDEX 16
	rep #$3B		; C2 3B
	adc $64.b,S		; 63 64 ; Add with carry (stack relative) $64.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $61.b,S		; 03 61 ; OR accumulator with stack relative $61.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $62, $97, $98		; 62 97 98 ; Push effective relative address $62, $97, $98 [Writes: Stack Pointer]
	adc [$B5.b]		; 67 B5 ; Add with carry (long) [$B5.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda ($22.b)		; B2 22 ; Load accumulator (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	stz $51.b,X		; 74 51 ; Store zero to $51.b,X [Reads: X Index]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	cmp #$49CA.w		; C9 CA 49 ; Compare #$49CA.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	lda ($67.b)		; B2 67 ; Load accumulator (indirect) ($67.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $D1.b,X		; B5 D1 ; Load $D1.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and ($62.b)		; 32 62 ; AND accumulator with memory (indirect) ($62.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp ($E0.b)		; D2 E0 ; Compare accumulator (indirect) ($E0.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	and $CF33.w		; 2D 33 CF ; Logical AND $CF33.w with accumulator [Writes: Accumulator] [Flags: NZ]
	adc ($22.b,S),Y		; 73 22 ; Add with carry (stack relative indirect indexed) ($22.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $52		; 80 52 ; Branch always to $80, $52 [Flow: branch]
	cmp $99.b,X		; D5 99 ; Compare accumulator $99.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	rol $29DF.w,X		; 3E DF 29 ; Rotate left $29DF.w,X [Reads: X Index] [Flags: NCZ]
	bit $A73D.w,X		; 3C 3D A7 ; Test bits $A73D.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	eor ($D6.b,S),Y		; 53 D6 ; XOR accumulator (stack relative indirect indexed) ($D6.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $D797.w,X		; 1D 97 D7 ; OR accumulator with memory $D797.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $E5.b,X		; 95 E5 ; Store accumulator to $E5.b,X [Reads: Accumulator, X Index]
	cld		; D8 ; Clear decimal flag [Flags: D]
	cmp $4843.w,Y		; D9 43 48 ; Compare accumulator $4843.w,Y [Reads: Y Index] [Flags: NCZ]
	eor #$4843.w		; 49 43 48 ; Exclusive OR #$4843.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lsr $DA.b		; 46 DA ; Logical shift right $DA.b [Reads: Direct Page] [Flags: NCZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	eor #$4843.w		; 49 43 48 ; Exclusive OR #$4843.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jmp.w [$E595]		; DC 95 E5 ; Jump long indirect [$E595] [Flow: jump]
	eor ($DD.b)		; 52 DD ; Exclusive OR accumulator with memory (indirect) ($DD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	jmp $A14E.w		; 4C 4E A1 ; Jump to $A14E.w [Flow: jump]
	jmp $A14E.w		; 4C 4E A1 ; Jump to $A14E.w [Flow: jump]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	sbc ($02.b,S),Y		; F3 02 ; Subtract with carry (stack relative indirect indexed) ($02.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	dec $E595.w,X		; DE 95 E5 ; Decrement memory $E595.w,X [Reads: X Index] [Flags: NZ]
	sbc $050503.l,X		; FF 03 05 05 ; Subtract with carry (long,X) $050503.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$2B.b]		; 07 2B ; OR accumulator with memory (long) [$2B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ora ($00.b,S),Y		; 13 00 ; OR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $2A.b		; 00 2A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and [$08.b]		; 27 08 ; AND accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $080409.l		; 22 09 04 08 ; Jump to subroutine long $080409.l [Writes: Stack Pointer] [Flow: call]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $09.b		; 26 09 ; Rotate left $09.b [Reads: Direct Page] [Flags: NCZ]
	jsl $090508.l		; 22 08 05 09 ; Jump to subroutine long $090508.l [Writes: Stack Pointer] [Flow: call]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $09.b		; 25 09 ; Logical AND $09.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $092208.l		; 22 08 22 09 ; Jump to subroutine long $092208.l [Writes: Stack Pointer] [Flow: call]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	ora #$0602.w		; 09 02 06 ; Logical OR #$0602.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: NCZ]
	ora #$0600.w		; 09 00 06 ; Logical OR #$0600.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and [$09.b]		; 27 09 ; AND accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora #$0606.w		; 09 06 06 ; Logical OR #$0606.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $000209.l		; 22 09 02 00 ; Jump to subroutine long $000209.l [Writes: Stack Pointer] [Flow: call]
	ora #$2209.w		; 09 09 22 ; Logical OR #$2209.w with accumulator [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsl $010309.l		; 22 09 03 01 ; Jump to subroutine long $010309.l [Writes: Stack Pointer] [Flow: call]
	ora #$0606.w		; 09 06 06 ; Logical OR #$0606.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $060009.l		; 22 09 00 06 ; Jump to subroutine long $060009.l [Writes: Stack Pointer] [Flow: call]
	and $09.b		; 25 09 ; Logical AND $09.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $090201.l		; 22 01 02 09 ; Jump to subroutine long $090201.l [Writes: Stack Pointer] [Flow: call]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	jsl $060309.l		; 22 09 03 06 ; Jump to subroutine long $060309.l [Writes: Stack Pointer] [Flow: call]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora #$0304.w		; 09 04 03 ; Logical OR #$0304.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora #$2306.w		; 09 06 23 ; Logical OR #$2306.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$0022.w		; 09 22 00 ; Logical OR #$0022.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $020409.l		; 22 09 04 02 ; Jump to subroutine long $020409.l [Writes: Stack Pointer] [Flow: call]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora #$2406.w		; 09 06 24 ; Logical OR #$2406.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$0102.w		; 09 02 01 ; Logical OR #$0102.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $09.b,S		; 23 09 ; AND accumulator with stack relative $09.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $08.b		; 06 08 ; Arithmetic shift left $08.b [Reads: Direct Page] [Flags: NCZ]
	ora #$0607.w		; 09 07 06 ; Logical OR #$0607.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$0808.w		; 09 08 08 ; Logical OR #$0808.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $010009.l		; 22 09 00 01 ; Jump to subroutine long $010009.l [Writes: Stack Pointer] [Flow: call]
	bit $09.b		; 24 09 ; Test bits $09.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	adc ($25.b,X)		; 61 25 ; Add with carry ($25.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora #$0600.w		; 09 00 06 ; Logical OR #$0600.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $09.b,S		; 23 09 ; AND accumulator with stack relative $09.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	ora [$09.b]		; 07 09 ; OR accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	and $09.b		; 25 09 ; Logical AND $09.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $09.b,S		; 23 09 ; AND accumulator with stack relative $09.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	ora [$09.b]		; 07 09 ; OR accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $09.b		; 25 09 ; Logical AND $09.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $09.b,S		; 23 09 ; AND accumulator with stack relative $09.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $E4E503.l,X		; FF 03 E5 E4 ; Subtract with carry (long,X) $E4E503.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $E06326.l,X		; DF 26 63 E0 ; Compare accumulator (long,X) $E06326.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	ora $E3.b,S		; 03 E3 ; OR accumulator with stack relative $E3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx $E3.b		; E4 E3 ; Compare $E3.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc $62.b,S		; E3 62 ; Subtract stack-relative $62.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	sbc $05.b		; E5 05 ; Subtract $05.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$3B.b]		; E7 3B ; Subtract with carry (long) [$3B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ror $8DE8.w		; 6E E8 8D ; Rotate right $8DE8.w [Flags: NCZ]
	stx $E968.w		; 8E 68 E9 ; Store X register to $E968.w [Reads: X Index]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sbc ($24.b)		; F2 24 ; Subtract with carry (indirect) ($24.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc $F3.b,X		; 75 F3 ; Add $F3.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	pea $F509.w		; F4 09 F5 ; Push absolute address $F509.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	inc $44.b,X		; F6 44 ; Increment memory $44.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	sbc [$F8.b],Y		; F7 F8 ; Subtract with carry (long indexed) [$F8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $F9.b,S		; 63 F9 ; Add with carry (stack relative) $F9.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	asl $90.b		; 06 90 ; Arithmetic shift left $90.b [Reads: Direct Page] [Flags: NCZ]
	adc $FD.b,X		; 75 FD ; Add $FD.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $0E		; 30 0E ; Branch if minus to $30, $0E [Flow: branch]
	inc $24F6.w,X		; FE F6 24 ; Increment memory $24F6.w,X [Reads: X Index] [Flags: NZ]
	sbc [$00.b],Y		; F7 00 ; Subtract with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $040062.l,X		; FF 62 00 04 ; Subtract with carry (long,X) $040062.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda ($75.b)		; B2 75 ; Load accumulator (indirect) ($75.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $B61F.w,X		; FD 1F B6 ; Subtract with carry $B61F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $03.b		; 66 03 ; Rotate right $03.b [Reads: Direct Page] [Flags: NCZ]
	jsl $0A05F7.l		; 22 F7 05 0A ; Jump to subroutine long $0A05F7.l [Writes: Stack Pointer] [Flow: call]
	sbc $75.b		; E5 75 ; Subtract $75.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $80B6.w,X		; FD B6 80 ; Subtract with carry $80B6.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $0B.b		; 65 0B ; Add $0B.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cop $F6.b		; 02 F6 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$F7.b],Y		; F7 F7 ; Subtract with carry (long indexed) [$F7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $62, $11, $08		; 62 11 08 ; Push effective relative address $62, $11, $08 [Writes: Stack Pointer]
	adc $14.b,X		; 75 14 ; Add $14.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $8080.w,X		; DE 80 80 ; Decrement memory $8080.w,X [Reads: X Index] [Flags: NZ]
	ora $0D.b,X		; 15 0D ; OR accumulator with memory $0D.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	asl $80.b,X		; 16 80 ; Arithmetic shift left $80.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $62, $17, $64		; 62 17 64 ; Push effective relative address $62, $17, $64 [Writes: Stack Pointer]
	ora $4101.w,Y		; 19 01 41 ; OR accumulator with memory $4101.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $0084.w,X		; 1E 84 00 ; Arithmetic shift left $0084.w,X [Reads: X Index] [Flags: NCZ]
	stz $05.b		; 64 05 ; Store zero to $05.b
	ora $FB201F.l,X		; 1F 1F 20 FB ; Logical OR long $FB201F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	.db $62, $21, $01		; 62 21 01 ; Push effective relative address $62, $21, $01 [Writes: Stack Pointer]
	cpy $8424.w		; CC 24 84 ; Compare $8424.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $64.b		; 00 64 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $6A.b		; 00 6A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $25, $05		; 62 25 05 ; Push effective relative address $62, $25, $05 [Writes: Stack Pointer]
	rol $28.b		; 26 28 ; Rotate left $28.b [Reads: Direct Page] [Flags: NCZ]
	and #$CC8B.w		; 29 8B CC ; Logical AND #$CC8B.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $0085.w,X		; 1E 85 00 ; Arithmetic shift left $0085.w,X [Reads: X Index] [Flags: NCZ]
	sta $03.b,S		; 83 03 ; Store accumulator (stack relative) $03.b,S [Reads: Stack Pointer, Accumulator]
	stz $5A.b,X		; 74 5A ; Store zero to $5A.b,X [Reads: X Index]
	ldx $26.b,Y		; B6 26 ; Load X register $26.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	.db $62, $2A, $0C		; 62 2A 0C ; Push effective relative address $62, $2A, $0C [Writes: Stack Pointer]
.ACCU 16
	rep #$A0		; C2 A0
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	bit $80.b		; 24 80 ; Test bits $80.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	and $0D15.w		; 2D 15 0D ; Logical AND $0D15.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $FB.b,X		; 16 FB ; Arithmetic shift left $FB.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	inc $2F09.w		; EE 09 2F ; Increment $2F09.w [Flags: NZ]
	.db $62, $2E, $04		; 62 2E 04 ; Push effective relative address $62, $2E, $04 [Writes: Stack Pointer]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	cmp $24BB.w,Y		; D9 BB 24 ; Compare accumulator $24BB.w,Y [Reads: Y Index] [Flags: NCZ]
	.db $80, $64		; 80 64 ; Branch always to $80, $64 [Flow: branch]
	and ($0D.b),Y		; 31 0D ; AND accumulator with memory ($0D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $0E		; 30 0E ; Branch if minus to $30, $0E [Flow: branch]
	and $302F36.l		; 2F 36 2F 30 ; AND accumulator with memory (long) $302F36.l [Writes: Accumulator] [Flags: NZ]
	and [$BE.b],Y		; 37 BE ; AND accumulator with memory (long indexed) [$BE.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	and $3987.w,Y		; 39 87 39 ; AND accumulator with memory $3987.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	inc $F7.b,X		; F6 F7 ; Increment memory $F7.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	.db $62, $3A, $0A		; 62 3A 0A ; Push effective relative address $62, $3A, $0A [Writes: Stack Pointer]
	asl $2A3D.w,X		; 1E 3D 2A ; Arithmetic shift left $2A3D.w,X [Reads: X Index] [Flags: NCZ]
	and $753E30.l		; 2F 30 3E 75 ; AND accumulator with memory (long) $753E30.l [Writes: Accumulator] [Flags: NZ]
	and $396ADE.l,X		; 3F DE 6A 39 ; AND accumulator with memory (long,X) $396ADE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $40, $E0		; 62 40 E0 ; Push effective relative address $62, $40, $E0 [Writes: Stack Pointer]
	jsl $6A433B.l		; 22 3B 43 6A ; Jump to subroutine long $6A433B.l [Writes: Stack Pointer] [Flow: call]
	mvp $2F,$36		; 44 36 2F ; Move block positive $2F,$36 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	.db $30, $24		; 30 24 ; Branch if minus to $30, $24 [Flow: branch]
	adc $3F.b,X		; 75 3F ; Add $3F.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	trb $451F.w		; 1C 1F 45 ; Test and reset bits $451F.w [Reads: Accumulator] [Flags: Z]
	ora $3B46.w		; 0D 46 3B ; Logical OR $3B46.w with accumulator [Writes: Accumulator] [Flags: NZ]
	eor $1D.b,S		; 43 1D ; Exclusive OR accumulator with stack relative $1D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	mvp $2F,$2A		; 44 2A 2F ; Move block positive $2F,$2A [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	.db $30, $E5		; 30 E5 ; Branch if minus to $30, $E5 [Flow: branch]
	adc $3F.b,X		; 75 3F ; Add $3F.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $25D9.w,X		; 1D D9 25 ; OR accumulator with memory $25D9.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor [$0D.b]		; 47 0D ; Exclusive OR accumulator with memory (long) [$0D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	eor #$1D43.w		; 49 43 1D ; Exclusive OR #$1D43.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	jmp.w [$03FF]		; DC FF 03 ; Jump long indirect [$03FF] [Flow: jump]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora #$2409.w		; 09 09 24 ; Logical OR #$2409.w with accumulator [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	rol $09.b		; 26 09 ; Rotate left $09.b [Reads: Direct Page] [Flags: NCZ]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsl $082309.l		; 22 09 23 08 ; Jump to subroutine long $082309.l [Writes: Stack Pointer] [Flow: call]
	jsl $070109.l		; 22 09 01 07 ; Jump to subroutine long $070109.l [Writes: Stack Pointer] [Flow: call]
	ora [$25.b]		; 07 25 ; OR accumulator with memory (long) [$25.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$0824.w		; 09 24 08 ; Logical OR #$0824.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $09.b		; 06 09 ; Arithmetic shift left $09.b [Reads: Direct Page] [Flags: NCZ]
	ora #$0008.w		; 09 08 00 ; Logical OR #$0008.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$0607.w		; 09 07 06 ; Logical OR #$0607.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $09.b,S		; 23 09 ; AND accumulator with stack relative $09.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $08.b		; 24 08 ; Test bits $08.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora [$09.b]		; 07 09 ; OR accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$0101.w		; 09 01 01 ; Logical OR #$0101.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$0507.w		; 09 07 05 ; Logical OR #$0507.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$0822.w		; 09 22 08 ; Logical OR #$0822.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and #$0109.w		; 29 09 01 ; Logical AND #$0109.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	asl $0943.w		; 0E 43 09 ; Arithmetic shift left $0943.w [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	bit $09.b		; 24 09 ; Test bits $09.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $27.b		; 05 27 ; Logical OR $27.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$0800.w		; 09 00 08 ; Logical OR #$0800.w with accumulator [Writes: Accumulator] [Flags: NZ]
	bit $09.b		; 24 09 ; Test bits $09.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	ora #$0800.w		; 09 00 08 ; Logical OR #$0800.w with accumulator [Writes: Accumulator] [Flags: NZ]
	rol $0009.w		; 2E 09 00 ; Rotate left $0009.w [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	bit $09.b		; 24 09 ; Test bits $09.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$0805.w		; 09 05 08 ; Logical OR #$0805.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$0809.w		; 09 09 08 ; Logical OR #$0809.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $09.b,S		; 23 09 ; AND accumulator with stack relative $09.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $23.b		; 05 23 ; Logical OR $23.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$0005.w		; 09 05 00 ; Logical OR #$0005.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $09.b,S		; 23 09 ; AND accumulator with stack relative $09.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $010309.l		; 22 09 03 01 ; Jump to subroutine long $010309.l [Writes: Stack Pointer] [Flow: call]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$25.b]		; 07 25 ; OR accumulator with memory (long) [$25.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$0702.w		; 09 02 07 ; Logical OR #$0702.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $060309.l		; 22 09 03 06 ; Jump to subroutine long $060309.l [Writes: Stack Pointer] [Flow: call]
	ora #$0606.w		; 09 06 06 ; Logical OR #$0606.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $09.b		; 25 09 ; Logical AND $09.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $22.b		; 05 22 ; Logical OR $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$0000.w		; 09 00 00 ; Logical OR #$0000.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $000009.l		; 22 09 00 00 ; Jump to subroutine long $000009.l [Writes: Stack Pointer] [Flow: call]
	and $09.b		; 25 09 ; Logical AND $09.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	lsr $0000.w		; 4E 00 00 ; Logical shift right $0000.w [Flags: NCZ]
	jsl $000209.l		; 22 09 02 00 ; Jump to subroutine long $000209.l [Writes: Stack Pointer] [Flow: call]
	ora #$2308.w		; 09 08 23 ; Logical OR #$2308.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$0701.w		; 09 01 07 ; Logical OR #$0701.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: NCZ]
	ora #$0000.w		; 09 00 00 ; Logical OR #$0000.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $000209.l		; 22 09 02 00 ; Jump to subroutine long $000209.l [Writes: Stack Pointer] [Flow: call]
	ora #$2308.w		; 09 08 23 ; Logical OR #$2308.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$0702.w		; 09 02 07 ; Logical OR #$0702.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $E7E708.l,X		; FF 08 E7 E7 ; Subtract with carry (long,X) $E7E708.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	sbc $E3.b,S		; E3 E3 ; Subtract stack-relative $E3.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	cpx $E3.b		; E4 E3 ; Compare $E3.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc $66.b,S		; E3 66 ; Subtract stack-relative $66.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	jmp $F201.w		; 4C 01 F2 ; Jump to $F201.w [Flow: jump]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $62, $53, $62		; 62 53 62 ; Push effective relative address $62, $53, $62 [Writes: Stack Pointer]
	cpx $EB00.w		; EC 00 EB ; Compare $EB00.w with X register [Reads: X Index] [Flags: NCZ]
	.db $62, $56, $01		; 62 56 01 ; Push effective relative address $62, $56, $01 [Writes: Stack Pointer]
	stx $658F.w		; 8E 8F 65 ; Store X register to $658F.w [Reads: X Index]
	eor $F744.w,Y		; 59 44 F7 ; Exclusive OR accumulator with memory $F744.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	asl $5F.b		; 06 5F ; Arithmetic shift left $5F.b [Reads: Direct Page] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	pea $6109.w		; F4 09 61 ; Push absolute address $6109.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	adc ($0D.b,X)		; 61 0D ; Add with carry ($0D.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $62.b,S		; 63 62 ; Add with carry (stack relative) $62.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	bit $F7.b		; 24 F7 ; Test bits $F7.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora [$5F.b]		; 07 5F ; OR accumulator with memory (long) [$5F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $30.b,X		; 16 30 ; Arithmetic shift left $30.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	asl $6166.w		; 0E 66 61 ; Arithmetic shift left $6166.w [Flags: NCZ]
	cmp #$2267.w		; C9 67 22 ; Compare #$2267.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	sbc [$04.b],Y		; F7 04 ; Subtract with carry (long indexed) [$04.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	asl $69.b		; 06 69 ; Arithmetic shift left $69.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora #$6A64.w		; 09 64 6A ; Logical OR #$6A64.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc ($C9.b,X)		; 61 C9 ; Add with carry ($C9.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $F7F770.l		; 6F 70 F7 F7 ; Add with carry (long) $F7F770.l [Writes: Accumulator] [Flags: NCVZ]
	eor $72F271.l,X		; 5F 71 F2 72 ; Exclusive OR accumulator with memory (long,X) $72F271.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $64.b,X		; F6 64 ; Increment memory $64.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	adc ($0C.b,S),Y		; 73 0C ; Add with carry (stack relative indirect indexed) ($0C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	adc ($C9.b,X)		; 61 C9 ; Add with carry ($C9.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	adc $1919.w,Y		; 79 19 19 ; Add $1919.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	asl $7B.b,X		; 16 7B ; Arithmetic shift left $7B.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	jmp ($3AF6.w,X)		; 7C F6 3A ; Jump indirect indexed to ($3AF6.w,X) [Reads: X Index] [Flow: jump]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $62, $7D, $00		; 62 7D 00 ; Push effective relative address $62, $7D, $00 [Writes: Stack Pointer]
	adc ($62.b,X)		; 61 62 ; Add with carry ($62.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	eor $8363.w,X		; 5D 63 83 ; Exclusive OR accumulator with memory $8363.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $17.b,S		; 03 17 ; OR accumulator with stack relative $17.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $3A.b,X		; F6 3A ; Increment memory $3A.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta [$00.b]		; 87 00 ; Store accumulator (long) [$00.b] [Reads: Direct Page, Accumulator]
	stx $9062.w		; 8E 62 90 ; Store X register to $9062.w [Reads: X Index]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora $6E.b,S		; 03 6E ; OR accumulator with stack relative $6E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta ($97.b,S),Y		; 93 97 ; Store accumulator (stack relative indirect indexed) ($97.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	.db $90, $62		; 90 62 ; Branch if carry clear to $90, $62 [Flow: branch]
	sty $03.b,X		; 94 03 ; Store Y register $03.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	lda #$26B6.w		; A9 B6 26 ; Load #$26B6.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($84.b),Y		; 91 84 ; Store accumulator ($84.b),Y [Reads: Direct Page, Y Index, Accumulator]
	brk $77.b		; 00 77 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $97.b		; 02 97 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($C9.b,X)		; 61 C9 ; Add with carry ($C9.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $98.b,S		; 63 98 ; Add with carry (stack relative) $98.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $EE.b,S		; 03 EE ; OR accumulator with stack relative $EE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora #$1F2F.w		; 09 2F 1F ; Logical OR #$1F2F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	adc [$04.b],Y		; 77 04 ; Add with carry (long indexed) [$04.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	stz $619D.w		; 9C 9D 61 ; Store zero to $619D.w
	cmp #$62E5.w		; C9 E5 62 ; Compare #$62E5.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	sta $3003.w,Y		; 99 03 30 ; Store accumulator to $3003.w,Y [Reads: Y Index, Accumulator]
	asl $CC2F.w		; 0E 2F CC ; Arithmetic shift left $CC2F.w [Flags: NCZ]
	adc $9E.b,S		; 63 9E ; Add with carry (stack relative) $9E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora [$9C.b],Y		; 17 9C ; OR accumulator with memory (long indexed) [$9C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ror $C961.w		; 6E 61 C9 ; Rotate right $C961.w [Flags: NCZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $A29A.w,Y		; 99 9A A2 ; Store accumulator to $A29A.w,Y [Reads: Y Index, Accumulator]
	lda [$A3.b],Y		; B7 A3 ; Load accumulator (long indexed) [$A3.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda [$B7.b],Y		; B7 B7 ; Load accumulator (long indexed) [$B7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $A4.b,X		; 15 A4 ; OR accumulator with memory $A4.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor $778716.l,X		; 5F 16 87 77 ; Exclusive OR accumulator with memory (long,X) $778716.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc ($C9.b,X)		; 61 C9 ; Add with carry ($C9.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $99.b		; A5 99 ; Load $99.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	ora $00A662.l,X		; 1F 62 A6 00 ; Logical OR long $00A662.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $08A962.l,X		; 1F 62 A9 08 ; Logical OR long $08A962.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $9C.b,X		; 16 9C ; Arithmetic shift left $9C.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ldy $6261.w		; AC 61 62 ; Load $6261.w into Y register [Writes: Y Index] [Flags: NZ]
	sbc $99.b		; E5 99 ; Subtract $99.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	ora $08AD62.l,X		; 1F 62 AD 08 ; Logical OR long $08AD62.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $B1F6B0.l,X		; 1F B0 F6 B1 ; Logical OR long $B1F6B0.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $9C.b		; 85 9C ; Store accumulator to $9C.b [Reads: Accumulator]
	sta [$61.b],Y		; 97 61 ; Store accumulator (long indexed) [$61.b],Y [Reads: Direct Page, Y Index, Accumulator]
	ora $9862.w		; 0D 62 98 ; Logical OR $9862.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $B2, $09		; 62 B2 09 ; Push effective relative address $62, $B2, $09 [Writes: Stack Pointer]
	ora $B6F6B5.l,X		; 1F B5 F6 B6 ; Logical OR long $B6F6B5.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda [$9C.b],Y		; B7 9C ; Load accumulator (long indexed) [$9C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc [$61.b],Y		; 77 61 ; Add with carry (long indexed) [$61.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp #$FFE5.w		; C9 E5 FF ; Compare #$FFE5.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora #$2206.w		; 09 06 22 ; Logical OR #$2206.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$09.b]		; 07 09 ; OR accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$0209.w		; 09 09 02 ; Logical OR #$0209.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $09.b,S		; 23 09 ; AND accumulator with stack relative $09.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$09.b]		; 07 09 ; OR accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($86.b,X)		; 01 86 ; Logical OR ($86.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $090301.l		; 22 01 03 09 ; Jump to subroutine long $090301.l [Writes: Stack Pointer] [Flow: call]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$0085.w		; 09 85 00 ; Logical OR #$0085.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $0122.w		; 0E 22 01 ; Arithmetic shift left $0122.w [Flags: NCZ]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $09.b		; 05 09 ; Logical OR $09.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta [$00.b]		; 87 00 ; Store accumulator (long) [$00.b] [Reads: Direct Page, Accumulator]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	jsl $010209.l		; 22 09 02 01 ; Jump to subroutine long $010209.l [Writes: Stack Pointer] [Flow: call]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $09.b,S		; 23 09 ; AND accumulator with stack relative $09.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora ($09.b,X)		; 01 09 ; Logical OR ($09.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$0006.w		; 09 06 00 ; Logical OR #$0006.w with accumulator [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	ora #$0702.w		; 09 02 07 ; Logical OR #$0702.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $070009.l		; 22 09 00 07 ; Jump to subroutine long $070009.l [Writes: Stack Pointer] [Flow: call]
	and $09.b		; 25 09 ; Logical AND $09.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora #$0201.w		; 09 01 02 ; Logical OR #$0201.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $020009.l		; 22 09 00 02 ; Jump to subroutine long $020009.l [Writes: Stack Pointer] [Flow: call]
	and $09.b		; 25 09 ; Logical AND $09.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $4F.b		; 00 4F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora #$0000.w		; 09 00 00 ; Logical OR #$0000.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $070209.l		; 22 09 02 07 ; Jump to subroutine long $070209.l [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$85.b]		; 07 85 ; OR accumulator with memory (long) [$85.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $7D.b		; 00 7D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0609.w		; 0C 09 06 ; Test and set bits $0609.w [Reads: Accumulator] [Flags: Z]
	ora #$0904.w		; 09 04 09 ; Logical OR #$0904.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$0705.w		; 09 05 07 ; Logical OR #$0705.w with accumulator [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$6204.w		; 09 04 62 ; Logical OR #$6204.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$83.b]		; 07 83 ; OR accumulator with memory (long) [$83.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $51.b		; 00 51 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $08.b		; 05 08 ; Logical OR $08.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $09.b,S		; 03 09 ; OR accumulator with stack relative $09.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$09.b]		; 07 09 ; OR accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $23.b		; 06 23 ; Arithmetic shift left $23.b [Reads: Direct Page] [Flags: NCZ]
	ora #$0723.w		; 09 23 07 ; Logical OR #$0723.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora #$0A0E.w		; 09 0E 0A ; Logical OR #$0A0E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$0307.w		; 09 07 03 ; Logical OR #$0307.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$0104.w		; 09 04 01 ; Logical OR #$0104.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$0A.b]		; 07 0A ; OR accumulator with memory (long) [$0A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	bit $07.b		; 24 07 ; Test bits $07.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora $0A.b,S		; 03 0A ; OR accumulator with stack relative $0A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$0A.b]		; 07 0A ; OR accumulator with memory (long) [$0A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($0A.b,X)		; 01 0A ; Logical OR ($0A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $03010A.l		; 22 0A 01 03 ; Jump to subroutine long $03010A.l [Writes: Stack Pointer] [Flow: call]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora [$0A.b]		; 07 0A ; OR accumulator with memory (long) [$0A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $06030A.l		; 22 0A 03 06 ; Jump to subroutine long $06030A.l [Writes: Stack Pointer] [Flow: call]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($0A.b,X)		; 01 0A ; Logical OR ($0A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $935204.l,X		; FF 04 52 93 ; Subtract with carry (long,X) $935204.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	stz $B8.b,X		; 74 B8 ; Store zero to $B8.b,X [Reads: X Index]
	sta ($22.b)		; 92 22 ; Store accumulator (indirect) ($22.b) [Reads: Direct Page, Accumulator]
	ora $320D.w,X		; 1D 0D 32 ; OR accumulator with memory $320D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$B975.w		; C9 75 B9 ; Compare #$B975.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc [$8A.b],Y		; 77 8A ; Add with carry (long indexed) [$8A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $9352.w,X		; 1D 52 93 ; OR accumulator with memory $9352.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	stx $BC.b,Y		; 96 BC ; Store X register $BC.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	.db $62, $BC, $0A		; 62 BC 0A ; Push effective relative address $62, $BC, $0A [Writes: Stack Pointer]
	ora $BF75.w		; 0D 75 BF ; Logical OR $BF75.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and [$70.b],Y		; 37 70 ; AND accumulator with memory (long indexed) [$70.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $935C.w,X		; 1D 5C 93 ; OR accumulator with memory $935C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$62C1.w		; C0 C1 62 ; Compare #$62C1.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $42, $03		; 42 03 ; Reserved instruction
.ACCU 16
	rep #$AD		; C2 AD
	cmp #$6275.w		; C9 75 62 ; Compare #$6275.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp $83.b,S		; C3 83 ; Compare accumulator (stack relative) $83.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($B8.b,X)		; 01 B8 ; Logical OR ($B8.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	dec $62.b		; C6 62 ; Decrement $62.b [Reads: Direct Page] [Flags: NZ]
	eor $9A05.w		; 4D 05 9A ; Exclusive OR $9A05.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $75C7.w,X		; 9D C7 75 ; Store accumulator to $75C7.w,X [Reads: Accumulator, X Index]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $62, $84, $00		; 62 84 00 ; Push effective relative address $62, $84, $00 [Writes: Stack Pointer]
	ora $C962.w		; 0D 62 C9 ; Logical OR $C962.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cop $58.b		; 02 58 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $32.b		; 65 32 ; Add $32.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc $CC.b,S		; 63 CC ; Add with carry (stack relative) $CC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	.db $D0, $92		; D0 92 ; Branch if not equal to $D0, $92 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	eor ($93.b)		; 52 93 ; Exclusive OR accumulator with memory (indirect) ($93.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $D2D1.w,X		; 1D D1 D2 ; OR accumulator with memory $D2D1.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta ($1D.b,S),Y		; 93 1D ; Store accumulator (stack relative indirect indexed) ($1D.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	cmp ($02.b,S),Y		; D3 02 ; Compare accumulator (stack relative indirect indexed) ($02.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	eor ($93.b)		; 52 93 ; Exclusive OR accumulator with memory (indirect) ($93.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $DC62.w,X		; 1D 62 DC ; OR accumulator with memory $DC62.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp $0BE022.l,X		; DF 22 E0 0B ; Compare accumulator (long,X) $0BE022.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	sbc ($E2.b,X)		; E1 E2 ; Subtract with carry ($E2.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $77.b		; A5 77 ; Load $77.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $93.b,S		; E3 93 ; Subtract stack-relative $93.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	dec $E4C9.w,X		; DE C9 E4 ; Decrement memory $E4C9.w,X [Reads: X Index] [Flags: NZ]
	sbc $5E.b		; E5 5E ; Subtract $5E.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc $E6.b		; 65 E6 ; Add $E6.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora #$77A5.w		; 09 A5 77 ; Logical OR #$77A5.w with accumulator [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($93.b)		; 52 93 ; Exclusive OR accumulator with memory (indirect) ($93.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $ECDE.w,X		; 1D DE EC ; OR accumulator with memory $ECDE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda $1D.b		; A5 1D ; Load $1D.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $62, $ED, $03		; 62 ED 03 ; Push effective relative address $62, $ED, $03 [Writes: Stack Pointer]
	adc $BF.b,X		; 75 BF ; Add $BF.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor [$1D.b]		; 47 1D ; Exclusive OR accumulator with memory (long) [$1D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	ror $F01E.w,X		; 7E 1E F0 ; Rotate right $F01E.w,X [Reads: X Index] [Flags: NCZ]
	ldy #$85F1.w		; A0 F1 85 ; Load #$85F1.w into Y register [Writes: Y Index] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($E5.b)		; F2 E5 ; Subtract with carry (indirect) ($E5.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc $BF.b,X		; 75 BF ; Add $BF.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor [$98.b]		; 47 98 ; Exclusive OR accumulator with memory (long) [$98.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc ($8A.b,S),Y		; F3 8A ; Subtract with carry (stack relative indirect indexed) ($8A.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	eor ($CC.b)		; 52 CC ; Exclusive OR accumulator with memory (indirect) ($CC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pea $1DF2.w		; F4 F2 1D ; Push absolute address $1DF2.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sbc $F6.b,X		; F5 F6 ; Subtract $F6.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $B2.b,S		; A3 B2 ; Load accumulator (stack relative) $B2.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ror $556F.w		; 6E 6F 55 ; Rotate right $556F.w [Flags: NCZ]
	cpx $CD8D.w		; EC 8D CD ; Compare $CD8D.w with X register [Reads: X Index] [Flags: NCZ]
	dec $1AF7.w		; CE F7 1A ; Decrement $1AF7.w [Flags: NZ]
	adc $F8.b,S		; 63 F8 ; Add with carry (stack relative) $F8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora #$3B17.w		; 09 17 3B ; Logical OR #$3B17.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ror $496F.w		; 6E 6F 49 ; Rotate right $496F.w [Flags: NCZ]
	ora $CDFC.w,X		; 1D FC CD ; OR accumulator with memory $CDFC.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dec $6248.w		; CE 48 62 ; Decrement $6248.w [Flags: NZ]
	sbc $000F.w,X		; FD 0F 00 ; Subtract with carry $000F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($B0.b,X)		; 01 B0 ; Logical OR ($B0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	trb $7598.w		; 1C 98 75 ; Test and reset bits $7598.w [Reads: Accumulator] [Flags: Z]
	eor $F31D1D.l		; 4F 1D 1D F3 ; Exclusive OR accumulator with memory (long) $F31D1D.l [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	cpx #$0302.w		; E0 02 03 ; Compare #$0302.w with X register [Reads: X Index] [Flags: NCZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $8B.b,S		; 23 8B ; AND accumulator with stack relative $8B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $6F04.w		; 0D 04 6F ; Logical OR $6F04.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $44.b		; 05 44 ; Logical OR $44.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp [$CD.b]		; C7 CD ; Compare accumulator (long) [$CD.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	and $E6062E.l		; 2F 2E 06 E6 ; AND accumulator with memory (long) $E6062E.l [Writes: Accumulator] [Flags: NZ]
	sbc ($07.b)		; F2 07 ; Subtract with carry (indirect) ($07.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc ($71.b),Y		; 71 71 ; Add with carry ($71.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $62, $08, $17		; 62 08 17 ; Push effective relative address $62, $08, $17 [Writes: Stack Pointer]
	eor #$6648.w		; 49 48 66 ; Exclusive OR #$6648.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp ($2F.b)		; D2 2F ; Compare accumulator (indirect) ($2F.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora $0B2E.w,X		; 1D 2E 0B ; OR accumulator with memory $0B2E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($0C.b)		; 52 0C ; Exclusive OR accumulator with memory (indirect) ($0C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpy $0DA0.w		; CC A0 0D ; Compare $0DA0.w with Y register [Reads: Y Index] [Flags: NCZ]
	asl $930E.w		; 0E 0E 93 ; Arithmetic shift left $930E.w [Flags: NCZ]
	ora $A02E.w,X		; 1D 2E A0 ; OR accumulator with memory $A02E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda $1D.b		; A5 1D ; Load $1D.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $2E.b		; A5 2E ; Load $2E.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sbc $020A2E.l,X		; FF 2E 0A 02 ; Subtract with carry (long,X) $020A2E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($0A.b,X)		; 01 0A ; Logical OR ($0A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	jsl $0A0205.l		; 22 05 02 0A ; Jump to subroutine long $0A0205.l [Writes: Stack Pointer] [Flow: call]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	.db $10, $01		; 10 01 ; Branch if plus to $10, $01 [Flow: branch]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $26.b		; 05 26 ; Logical OR $26.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	jsl $31E406.l		; 22 06 E4 31 ; Jump to subroutine long $31E406.l [Writes: Stack Pointer] [Flow: call]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $8E.b		; E4 8E ; Compare $8E.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $0A.b		; 25 0A ; Logical AND $0A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$0A.b]		; 07 0A ; OR accumulator with memory (long) [$0A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $2D0F00.l,X		; FF 00 0F 2D ; Subtract with carry (long,X) $2D0F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $11		; 10 11 ; Branch if plus to $10, $11 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora ($12.b),Y		; 11 12 ; OR accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $13ECFF.l,X		; FF FF EC 13 ; Subtract with carry (long,X) $13ECFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $1413EC.l,X		; FF EC 13 14 ; Subtract with carry (long,X) $1413EC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $EC15EC.l,X		; FF EC 15 EC ; Subtract with carry (long,X) $EC15EC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $17.b,X		; 16 17 ; Arithmetic shift left $17.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($63.b),Y		; 11 63 ; OR accumulator with memory ($63.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsl $1C63B9.l		; 22 B9 63 1C ; Jump to subroutine long $1C63B9.l [Writes: Stack Pointer] [Flow: call]
	brk $1B.b		; 00 1B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $20, $03		; 62 20 03 ; Push effective relative address $62, $20, $03 [Writes: Stack Pointer]
	ora ($18.b),Y		; 11 18 ; OR accumulator with memory ($18.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($23.b,X)		; 21 23 ; Logical AND ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	mvp $25,$24		; 44 24 25 ; Move block positive $25,$24 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $26.b		; 64 26 ; Store zero to $26.b
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	ora ($12.b),Y		; 11 12 ; OR accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	jsl $042C62.l		; 22 62 2C 04 ; Jump to subroutine long $042C62.l [Writes: Stack Pointer] [Flow: call]
	and $302F.w		; 2D 2F 30 ; Logical AND $302F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $622F.w		; 2D 2F 62 ; Logical AND $622F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and ($04.b),Y		; 31 04 ; AND accumulator with memory ($04.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $341811.l		; 22 11 18 34 ; Jump to subroutine long $341811.l [Writes: Stack Pointer] [Flow: call]
	jsl $151962.l		; 22 62 19 15 ; Jump to subroutine long $151962.l [Writes: Stack Pointer] [Flow: call]
	and $1F.b,X		; 35 1F ; Logical AND $1F.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	rol $B9.b,X		; 36 B9 ; Rotate left $B9.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	jsr $3837.w		; 20 37 38 ; Jump to subroutine at $3837.w [Writes: Stack Pointer] [Flow: call]
	.db $10, $39		; 10 39 ; Branch if plus to $10, $39 [Flow: branch]
	ora ($18.b),Y		; 11 18 ; OR accumulator with memory ($18.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($22.b,X)		; 21 22 ; Logical AND ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	and $3B.b,S		; 23 3B ; AND accumulator with stack relative $3B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $27.b		; 26 27 ; Rotate left $27.b [Reads: Direct Page] [Flags: NCZ]
	bit $293D.w,X		; 3C 3D 29 ; Test bits $293D.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	rol $3F22.w,X		; 3E 22 3F ; Rotate left $3F22.w,X [Reads: X Index] [Flags: NCZ]
	tsb $11.b		; 04 11 ; Test and set bits $11.b [Reads: Accumulator] [Flags: Z]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	eor ($22.b,X)		; 41 22 ; Exclusive OR accumulator with memory ($22.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and ($6A.b,X)		; 21 6A ; Logical AND ($6A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $42, $03		; 42 03 ; Reserved instruction
	ora ($18.b),Y		; 11 18 ; OR accumulator with memory ($18.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor ($22.b,X)		; 41 22 ; Exclusive OR accumulator with memory ($22.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc [$4D.b]		; 67 4D ; Add with carry (long) [$4D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($31.b,X)		; 01 31 ; Logical OR ($31.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor $83.b,X		; 55 83 ; Exclusive OR accumulator with memory $83.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $2E.b		; 00 2E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $56.b,S		; 03 56 ; OR accumulator with stack relative $56.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $654E41.l		; 22 41 4E 65 ; Jump to subroutine long $654E41.l [Writes: Stack Pointer] [Flow: call]
	eor [$08.b],Y		; 57 08 ; Exclusive OR accumulator with memory (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($48.b),Y		; 31 48 ; AND accumulator with memory ($48.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	eor $4011.w,X		; 5D 11 40 ; Exclusive OR accumulator with memory $4011.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr $22.b,X		; 56 22 ; Logical shift right $22.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	eor ($66.b,X)		; 41 66 ; Exclusive OR accumulator with memory ($66.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lsr $3109.w,X		; 5E 09 31 ; Logical shift right $3109.w,X [Reads: X Index] [Flags: NCZ]
	mvn $66,$65		; 54 65 66 ; Move block negative $66,$65 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora ($18.b),Y		; 11 18 ; OR accumulator with memory ($18.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	jsl $655D67.l		; 22 67 5D 65 ; Jump to subroutine long $655D67.l [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	ora #$3231.w		; 09 31 32 ; Logical OR #$3231.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ror $116E.w		; 6E 6E 11 ; Rotate right $116E.w [Flags: NCZ]
	ora ($34.b)		; 12 34 ; OR accumulator with memory (indirect) ($34.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $22706F.l		; 22 6F 70 22 ; Jump to subroutine long $22706F.l [Writes: Stack Pointer] [Flow: call]
	adc ($0A.b),Y		; 71 0A ; Add with carry ($0A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($72.b)		; 72 72 ; Add with carry (indirect) ($72.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc ($37.b,S),Y		; 73 37 ; Add with carry (stack relative indirect indexed) ($37.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	ora ($18.b),Y		; 11 18 ; OR accumulator with memory ($18.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	stz $5D.b,X		; 74 5D ; Store zero to $5D.b,X [Reads: X Index]
	jsl $766375.l		; 22 75 63 76 ; Jump to subroutine long $766375.l [Writes: Stack Pointer] [Flow: call]
	and $75.b,S		; 23 75 ; AND accumulator with stack relative $75.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $7A.b		; 05 7A ; Logical OR $7A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($12.b),Y		; 11 12 ; OR accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $7B.b		; 65 7B ; Add $7B.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc ($64.b),Y		; 71 64 ; Add with carry ($64.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp ($EA04.w,X)		; 7C 04 EA ; Jump indirect indexed to ($EA04.w,X) [Reads: X Index] [Flow: jump]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta ($EB.b,X)		; 81 EB ; Store accumulator ($EB.b,X) [Reads: Direct Page, Accumulator, X Index]
	.db $62, $82, $04		; 62 82 04 ; Push effective relative address $62, $82, $04 [Writes: Stack Pointer]
	rol $B9.b,X		; 36 B9 ; Rotate left $B9.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sta $85.b		; 85 85 ; Store accumulator to $85.b [Reads: Accumulator]
	trb $8662.w		; 1C 62 86 ; Test and reset bits $8662.w [Reads: Accumulator] [Flags: Z]
	ora $17.b		; 05 17 ; Logical OR $17.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit #$2020.w		; 89 20 20 ; Test bits #$2020.w with accumulator [Reads: Accumulator] [Flags: Z]
	ora ($8A.b)		; 12 8A ; OR accumulator with memory (indirect) ($8A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $010104.l,X		; FF 04 01 01 ; Subtract with carry (long,X) $010104.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora ($29.b,X)		; 01 29 ; Logical OR ($29.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $000A.w		; 2E 0A 00 ; Rotate left $000A.w [Flags: NCZ]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $42.b		; E4 42 ; Compare $42.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $2A.b		; E4 2A ; Compare $2A.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $0A.b,S		; 23 0A ; AND accumulator with stack relative $0A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $0A.b		; 24 0A ; Test bits $0A.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $000A.w		; 2C 0A 00 ; Test bits $000A.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	ora $29.b		; 05 29 ; Logical OR $29.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $22.b		; 05 22 ; Logical OR $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$0A.b],Y		; 37 0A ; AND accumulator with memory (long indexed) [$0A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$0A.b]		; 27 0A ; AND accumulator with memory (long) [$0A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $22.b		; 05 22 ; Logical OR $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $0B060A.l		; 22 0A 06 0B ; Jump to subroutine long $0B060A.l [Writes: Stack Pointer] [Flow: call]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $0A.b		; 24 0A ; Test bits $0A.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $15FE05.l,X		; FF 05 FE 15 ; Subtract with carry (long,X) $15FE05.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	sty $10F8.w		; 8C F8 10 ; Store Y register to $10F8.w [Reads: Y Index]
	adc $8D.b		; 65 8D ; Add $8D.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $8F.b,S		; 03 8F ; OR accumulator with stack relative $8F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $90, $93		; 90 93 ; Branch if carry clear to $90, $93 [Flow: branch]
	.db $82, $62, $94		; 82 62 94 ; Branch always long to $82, $62, $94 [Flow: branch]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta $9766.w		; 8D 66 97 ; Store accumulator to $9766.w [Reads: Accumulator]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	stz $9F82.w,X		; 9E 82 9F ; Store zero to $9F82.w,X [Reads: X Index]
	ldy #$095C.w		; A0 5C 09 ; Load #$095C.w into Y register [Writes: Y Index] [Flags: NZ]
	lda ($A2.b,X)		; A1 A2 ; Load accumulator ($A2.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $A3.b,S		; 63 A3 ; Add with carry (stack relative) $A3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $62, $A3, $01		; 62 A3 01 ; Push effective relative address $62, $A3, $01 [Writes: Stack Pointer]
	lda [$82.b]		; A7 82 ; Load accumulator (long) [$82.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $62, $A8, $03		; 62 A8 03 ; Push effective relative address $62, $A8, $03 [Writes: Stack Pointer]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	ldy $6898.w		; AC 98 68 ; Load $6898.w into Y register [Writes: Y Index] [Flags: NZ]
	lda $A100.w		; AD 00 A1 ; Load $A100.w into accumulator [Writes: Accumulator] [Flags: NZ]
	stz $B6.b		; 64 B6 ; Store zero to $B6.b
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ldx #$B3AE.w		; A2 AE B3 ; Load #$B3AE.w into X register [Writes: X Index] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ldy $B3AE.w,X		; BC AE B3 ; Load Y register $B3AE.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lda $64A1.w,X		; BD A1 64 ; Load $64A1.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldx $9802.w,Y		; BE 02 98 ; Load X register $9802.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	cmp $C4.b,S		; C3 C4 ; Compare accumulator (stack relative) $C4.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	and $AF.b,S		; 23 AF ; AND accumulator with stack relative $AF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $62, $C5, $04		; 62 C5 04 ; Push effective relative address $62, $C5, $04 [Writes: Stack Pointer]
	lda ($8C.b,X)		; A1 8C ; Load accumulator ($8C.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	sta $C863.w		; 8D 63 C8 ; Store accumulator to $C863.w [Reads: Accumulator]
	ora $CC1D.w		; 0D 1D CC ; Logical OR $CC1D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp $CE1D.w		; CD 1D CE ; Compare $CE1D.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp $8D888B.l		; CF 8B 88 8D ; Compare accumulator (long) $8D888B.l [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $FF		; D0 FF ; Branch if not equal to $D0, $FF [Flow: branch]
	lda ($A2.b,X)		; A1 A2 ; Load accumulator ($A2.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($22.b),Y		; D1 22 ; Compare accumulator ($22.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cmp ($0B.b)		; D2 0B ; Compare accumulator (indirect) ($0B.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp ($D4.b,S),Y		; D3 D4 ; Compare accumulator (stack relative indirect indexed) ($D4.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	cmp ($D2.b)		; D2 D2 ; Compare accumulator (indirect) ($D2.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp $D6.b,X		; D5 D6 ; Compare accumulator $D6.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sta $D8D7A1.l,X		; 9F A1 D7 D8 ; Store accumulator (long,X) $D8D7A1.l,X [Reads: Accumulator, X Index]
	lda ($AC.b,X)		; A1 AC ; Load accumulator ($AC.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and [$B3.b]		; 27 B3 ; AND accumulator with memory (long) [$B3.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cmp $6BDA.w,Y		; D9 DA 6B ; Compare accumulator $6BDA.w,Y [Reads: Y Index] [Flags: NCZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	cld		; D8 ; Clear decimal flag [Flags: D]
	jmp.w [$1DDD]		; DC DD 1D ; Jump long indirect [$1DDD] [Flow: jump]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	adc #$1D09.w		; 69 09 1D ; Add #$1D09.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cpy $DECD.w		; CC CD DE ; Compare $DECD.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $82, $DF, $DF		; 82 DF DF ; Branch always long to $82, $DF, $DF [Flow: branch]
	cpx #$E0D8.w		; E0 D8 E0 ; Compare #$E0D8.w with X register [Reads: X Index] [Flags: NCZ]
	jsl $D30724.l		; 22 24 07 D3 ; Jump to subroutine long $D30724.l [Writes: Stack Pointer] [Flow: call]
	sbc ($15.b,X)		; E1 15 ; Subtract with carry ($15.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
.INDEX 8
	sep #$D3		; E2 D3
	sbc $E4.b,S		; E3 E4 ; Subtract stack-relative $E4.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	lda $65.b,X		; B5 65 ; Load $65.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $1C.b		; E5 1C ; Subtract $1C.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc #$FFEB.w		; E9 EB FF ; Subtract #$FFEB.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cpx $E4ED.w		; EC ED E4 ; Compare $E4ED.w with X register [Reads: X Index] [Flags: NCZ]
	.db $D0, $14		; D0 14 ; Branch if not equal to $D0, $14 [Flow: branch]
	lda ($EE.b,X)		; A1 EE ; Load accumulator ($EE.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $8D		; 10 8D ; Branch if plus to $10, $8D [Flow: branch]
	sbc $D8ECFF.l		; EF FF EC D8 ; Subtract with carry (long) $D8ECFF.l [Writes: Accumulator] [Flags: NCVZ]
	trb $F0.b		; 14 F0 ; Test and reset bits $F0.b [Reads: Accumulator] [Flags: Z]
	ora #$18F1.w		; 09 F1 18 ; Logical OR #$18F1.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lda ($F2.b,X)		; A1 F2 ; Load accumulator ($F2.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	trb $F3.b		; 14 F3 ; Test and reset bits $F3.b [Reads: Accumulator] [Flags: Z]
	pea $DCE8.w		; F4 E8 DC ; Push absolute address $DCE8.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	cmp $1D62.w,X		; DD 62 1D ; Compare accumulator $1D62.w,X [Reads: X Index] [Flags: NCZ]
	ora [$1D.b]		; 07 1D ; OR accumulator with memory (long) [$1D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	trb $F586.w		; 1C 86 F5 ; Test and reset bits $F586.w [Reads: Accumulator] [Flags: Z]
	jmp.w [$CCDD]		; DC DD CC ; Jump long indirect [$CCDD] [Flow: jump]
	.db $62, $F6, $01		; 62 F6 01 ; Push effective relative address $62, $F6, $01 [Writes: Stack Pointer]
	cpx #$25.b		; E0 25 ; Compare #$25.b with X register [Reads: X Index] [Flags: NCZ]
	.db $62, $F9, $14		; 62 F9 14 ; Push effective relative address $62, $F9, $14 [Writes: Stack Pointer]
.ACCU 8
.INDEX 8
	sep #$FC		; E2 FC
	and $FD.b		; 25 FD ; Logical AND $FD.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $D325E0.l,X		; FF E0 25 D3 ; Subtract with carry (long,X) $D325E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $FF82.w,X		; FE 82 FF ; Increment memory $FF82.w,X [Reads: X Index] [Flags: NZ]
	.db $F0, $14		; F0 14 ; Branch if equal to $F0, $14 [Flow: branch]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$E4.b]		; 27 E4 ; AND accumulator with memory (long) [$E4.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $FF.b		; 02 FF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$9F.b		; 09 9F ; Logical OR #$9F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $A101F0.l		; 22 F0 01 A1 ; Jump to subroutine long $A101F0.l [Writes: Stack Pointer] [Flow: call]
	.db $82, $FF, $09		; 82 FF 09 ; Branch always long to $82, $FF, $09 [Flow: branch]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $08.b		; 06 08 ; Arithmetic shift left $08.b [Reads: Direct Page] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $0B.b		; 25 0B ; Logical AND $0B.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	ora $46.b,S		; 03 46 ; OR accumulator with stack relative $46.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $86.b		; 00 86 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $0B.b,S		; 23 0B ; AND accumulator with stack relative $0B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	bit $0B.b		; 24 0B ; Test bits $0B.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	.db $10, $05		; 10 05 ; Branch if plus to $10, $05 [Flow: branch]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tsb $0B.b		; 04 0B ; Test and set bits $0B.b [Reads: Accumulator] [Flags: Z]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $0B.b		; 24 0B ; Test bits $0B.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	jsr $0083.w		; 20 83 00 ; Jump to subroutine at $0083.w [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $0B.b,S		; 23 0B ; AND accumulator with stack relative $0B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	and $000827.l		; 2F 27 08 00 ; AND accumulator with memory (long) $000827.l [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ora [$83.b]		; 07 83 ; OR accumulator with memory (long) [$83.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $0B.b		; 25 0B ; Logical AND $0B.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $07.b		; 24 07 ; Test bits $07.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora $08.b,S		; 03 08 ; OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($25.b,X)		; 01 25 ; Logical OR ($25.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	jsl L000307.l		; 22 07 83 00 ; Jump to subroutine long L000307.l [Writes: Stack Pointer] [Flow: call]
	and $030B25.l		; 2F 25 0B 03 ; AND accumulator with memory (long) $030B25.l [Writes: Accumulator] [Flags: NZ]
	ora $0B.b		; 05 0B ; Logical OR $0B.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	jsl $080400.l		; 22 00 04 08 ; Jump to subroutine long $080400.l [Writes: Stack Pointer] [Flow: call]
	ora [$0B.b]		; 07 0B ; OR accumulator with memory (long) [$0B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $25.b		; 00 25 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	stx $00.b		; 86 00 ; Store X register to $00.b [Reads: X Index]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	jsl $08000B.l		; 22 0B 00 08 ; Jump to subroutine long $08000B.l [Writes: Stack Pointer] [Flow: call]
	eor $08.b,S		; 43 08 ; Exclusive OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora #$06.b		; 09 06 ; Logical OR #$06.b with accumulator [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora ($0B.b,X)		; 01 0B ; Logical OR ($0B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($2C.b,X)		; 01 2C ; Logical OR ($2C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $050B.w		; 2D 0B 05 ; Logical AND $050B.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	pea $09FF.w		; F4 FF 09 ; Push absolute address $09FF.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	asl $10.b		; 06 10 ; Arithmetic shift left $10.b [Reads: Direct Page] [Flags: NCZ]
	and $1F030B.l		; 2F 0B 03 1F ; AND accumulator with memory (long) $1F030B.l [Writes: Accumulator] [Flags: NZ]
	eor [$1F.b]		; 47 1F ; Exclusive OR accumulator with memory (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $1B.b		; 04 1B ; Test and set bits $1B.b [Reads: Accumulator] [Flags: Z]
	and $05.b,S		; 23 05 ; AND accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $06.b		; 04 06 ; Test and set bits $06.b [Reads: Accumulator] [Flags: Z]
	asl $02.b		; 06 02 ; Arithmetic shift left $02.b [Reads: Direct Page] [Flags: NCZ]
	adc ($26.b),Y		; 71 26 ; Add with carry ($26.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	ora $08.b,S		; 03 08 ; OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$7F.b]		; 07 7F ; OR accumulator with memory (long) [$7F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	adc #$09.b		; 69 09 ; Add #$09.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $0A		; 80 0A ; Branch always to $80, $0A [Flow: branch]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora #$86.b		; 09 86 ; Logical OR #$86.b with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($EE.b,X)		; 01 EE ; Logical OR ($EE.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $0B63.w		; 2D 63 0B ; Logical AND $0B63.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($EE.b,X)		; 01 EE ; Logical OR ($EE.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $0F64.w		; 2D 64 0F ; Logical AND $0F64.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	.db $10, $06		; 10 06 ; Branch if plus to $10, $06 [Flow: branch]
	trb $15.b		; 14 15 ; Test and reset bits $15.b [Reads: Accumulator] [Flags: Z]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $17.b,X		; 16 17 ; Arithmetic shift left $17.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	inc $642D.w		; EE 2D 64 ; Increment $642D.w [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	jsr $1D06.w		; 20 06 1D ; Jump to subroutine at $1D06.w [Writes: Stack Pointer] [Flow: call]
	asl $1F12.w,X		; 1E 12 1F ; Arithmetic shift left $1F12.w,X [Reads: X Index] [Flags: NCZ]
	jsr $2D60.w		; 20 60 2D ; Jump to subroutine at $2D60.w [Writes: Stack Pointer] [Flow: call]
	adc $21.b,S		; 63 21 ; Add with carry (stack relative) $21.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	and $083762.l		; 2F 62 37 08 ; AND accumulator with memory (long) $083762.l [Writes: Accumulator] [Flags: NZ]
	and [$38.b],Y		; 37 38 ; AND accumulator with memory (long indexed) [$38.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	eor $25.b		; 45 25 ; Exclusive OR $25.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $9D26.w,X		; 1D 26 9D ; OR accumulator with memory $9D26.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and [$83.b]		; 27 83 ; AND accumulator with memory (long) [$83.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $29.b		; 24 29 ; Test bits $29.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	bit $E8.b		; 24 E8 ; Test bits $E8.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora $3F.b		; 05 3F ; Logical OR $3F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora #$2F.b		; 09 2F ; Logical OR #$2F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	jsl $2D032C.l		; 22 2C 03 2D ; Jump to subroutine long $2D032C.l [Writes: Stack Pointer] [Flow: call]
	.db $F0, $2E		; F0 2E ; Branch if equal to $F0, $2E [Flow: branch]
	rol $F022.w		; 2E 22 F0 ; Rotate left $F022.w [Flags: NCZ]
	tsb $2C.b		; 04 2C ; Test and set bits $2C.b [Reads: Accumulator] [Flags: Z]
	asl $10.b		; 06 10 ; Arithmetic shift left $10.b [Reads: Direct Page] [Flags: NCZ]
	and $30232F.l		; 2F 2F 23 30 ; AND accumulator with memory (long) $30232F.l [Writes: Accumulator] [Flags: NZ]
	tsb $31.b		; 04 31 ; Test and set bits $31.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and ($33.b)		; 32 33 ; AND accumulator with memory (indirect) ($33.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $62, $34, $01		; 62 34 01 ; Push effective relative address $62, $34, $01 [Writes: Stack Pointer]
	cop $71.b		; 02 71 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $37, $22		; 62 37 22 ; Push effective relative address $62, $37, $22 [Writes: Stack Pointer]
	ora $740B09.l,X		; 1F 09 0B 74 ; Logical OR long $740B09.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $3D3C.w,X		; 1D 3C 3D ; OR accumulator with memory $3D3C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	trb $090B.w		; 1C 0B 09 ; Test and reset bits $090B.w [Reads: Accumulator] [Flags: Z]
	adc $3E.b		; 65 3E ; Add $3E.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora #$0B.b		; 09 0B ; Logical OR #$0B.b with accumulator [Writes: Accumulator] [Flags: NZ]
	stz $44.b,X		; 74 44 ; Store zero to $44.b,X [Reads: X Index]
	eor $1D.b		; 45 1D ; Exclusive OR $1D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr $47.b		; 46 47 ; Logical shift right $47.b [Reads: Direct Page] [Flags: NCZ]
	.db $10, $B0		; 10 B0 ; Branch if plus to $10, $B0 [Flow: branch]
	asl $4862.w		; 0E 62 48 ; Arithmetic shift left $4862.w [Flags: NCZ]
	tsb $C5.b		; 04 C5 ; Test and set bits $C5.b [Reads: Accumulator] [Flags: Z]
	eor ($4B.b,S),Y		; 53 4B ; XOR accumulator (stack relative indirect indexed) ($4B.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	jmp $1F23.w		; 4C 23 1F ; Jump to $1F23.w [Flow: jump]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	stz $10.b,X		; 74 10 ; Store zero to $10.b,X [Reads: X Index]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	eor $424E.w		; 4D 4E 42 ; Exclusive OR $424E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	eor $2A62DB.l		; 4F DB 62 2A ; Exclusive OR accumulator with memory (long) $2A62DB.l [Writes: Accumulator] [Flags: NZ]
	bit $50.b		; 24 50 ; Test bits $50.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ror $51.b		; 66 51 ; Rotate right $51.b [Reads: Direct Page] [Flags: NCZ]
	brk $A1.b		; 00 A1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $58.b		; 65 58 ; Add $58.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $62, $5B, $01		; 62 5B 01 ; Push effective relative address $62, $5B, $01 [Writes: Stack Pointer]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	mvn $5E,$62		; 54 62 5E ; Move block negative $5E,$62 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $3D.b		; 05 3D ; Logical OR $3D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda [$53.b]		; A7 53 ; Load accumulator (long) [$53.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $53A7.w,X		; 3D A7 53 ; AND accumulator with memory $53A7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	pea $27FF.w		; F4 FF 27 ; Push absolute address $27FF.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	and $07.b,S		; 23 07 ; AND accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0B.b		; 05 0B ; Logical OR $0B.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	and $08.b,S		; 23 08 ; AND accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $0B.b		; 26 0B ; Rotate left $0B.b [Reads: Direct Page] [Flags: NCZ]
	ora $08.b,S		; 03 08 ; OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	bit $0B.b		; 24 0B ; Test bits $0B.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	bit $0B.b		; 24 0B ; Test bits $0B.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ora $0B24.w,X		; 1D 24 0B ; OR accumulator with memory $0B24.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	bit $0B.b		; 24 0B ; Test bits $0B.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ora $0B24.w,X		; 1D 24 0B ; OR accumulator with memory $0B24.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	rol $0B.b		; 26 0B ; Rotate left $0B.b [Reads: Direct Page] [Flags: NCZ]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $0B.b		; 25 0B ; Logical AND $0B.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	jsl $0B0400.l		; 22 00 04 0B ; Jump to subroutine long $0B0400.l [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	eor $0B2B.w,X		; 5D 2B 0B ; Exclusive OR accumulator with memory $0B2B.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $08.b,S		; 03 08 ; OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$0B.b]		; 07 0B ; OR accumulator with memory (long) [$0B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $0B.b		; 25 0B ; Logical AND $0B.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	cop $0B.b		; 02 0B ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $0B.b,S		; 23 0B ; AND accumulator with stack relative $0B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	jsl $0B0108.l		; 22 08 01 0B ; Jump to subroutine long $0B0108.l [Writes: Stack Pointer] [Flow: call]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	eor $02.b,X		; 55 02 ; Exclusive OR accumulator with memory $02.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($0B.b,X)		; 01 0B ; Logical OR ($0B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	jsl $0B0108.l		; 22 08 01 0B ; Jump to subroutine long $0B0108.l [Writes: Stack Pointer] [Flow: call]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora ($09.b,X)		; 01 09 ; Logical OR ($09.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	lsr $0B.b		; 46 0B ; Logical shift right $0B.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	sta $000B25.l		; 8F 25 0B 00 ; Store accumulator (long) $000B25.l [Reads: Accumulator]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	and $01.b		; 25 01 ; Logical AND $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsl $08230B.l		; 22 0B 23 08 ; Jump to subroutine long $08230B.l [Writes: Stack Pointer] [Flow: call]
	and [$0B.b]		; 27 0B ; AND accumulator with memory (long) [$0B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $070B.w		; 2D 0B 07 ; Logical AND $070B.w with accumulator [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	.db $F0, $01		; F0 01 ; Branch if equal to $F0, $01 [Flow: branch]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	sbc $0607FF.l		; EF FF 07 06 ; Subtract with carry (long) $0607FF.l [Writes: Accumulator] [Flags: NCVZ]
	asl $61.b		; 06 61 ; Arithmetic shift left $61.b [Reads: Direct Page] [Flags: NCZ]
	.db $62, $06, $06		; 62 06 06 ; Push effective relative address $62, $06, $06 [Writes: Stack Pointer]
	adc ($63.b,X)		; 61 63 ; Add with carry ($63.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $EA.b,S		; 23 EA ; AND accumulator with stack relative $EA.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $64.b		; 05 64 ; Logical OR $64.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	adc ($C9.b,X)		; 61 C9 ; Add with carry ($C9.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $66.b		; 65 66 ; Add $66.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and $80.b,S		; 23 80 ; AND accumulator with stack relative $80.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $67.b		; 02 67 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	adc #$22.b		; 69 22 ; Add #$22.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tsb $6B.b		; 04 6B ; Test and set bits $6B.b [Reads: Accumulator] [Flags: Z]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	adc ($C9.b,X)		; 61 C9 ; Add with carry ($C9.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	tas		; [PATTERN: Memory clearing operation] 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	stz $6C.b		; 64 6C ; Store zero to $6C.b
	ora ($9A.b,X)		; 01 9A ; Logical OR ($9A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	stz $71.b		; 64 71 ; Store zero to $71.b
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ora $7664.w,X		; 1D 64 76 ; OR accumulator with memory $7664.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($9A.b,X)		; 01 9A ; Logical OR ($9A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc $7B.b,S		; 63 7B ; Add with carry (stack relative) $7B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	bit $7F63.w		; 2C 63 7F ; Test bits $7F63.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	ora ($9A.b,X)		; 01 9A ; Logical OR ($9A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc $83.b,S		; 63 83 ; Add with carry (stack relative) $83.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	tsb $8775.w		; 0C 75 87 ; Test and set bits $8775.w [Reads: Accumulator] [Flags: Z]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cmp #$1B.b		; C9 1B ; Compare #$1B.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	bit #$8A.b		; 89 8A ; Test bits #$8A.b with accumulator [Reads: Accumulator] [Flags: Z]
	lsr $47.b		; 46 47 ; Logical shift right $47.b [Reads: Direct Page] [Flags: NCZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	sty $032A.w		; 8C 2A 03 ; Store Y register to $032A.w [Reads: Y Index]
	jsl $8D091F.l		; 22 1F 09 8D ; Jump to subroutine long $8D091F.l [Writes: Stack Pointer] [Flow: call]
	sta $1BC932.l		; 8F 32 C9 1B ; Store accumulator (long) $1BC932.l [Reads: Accumulator]
	stx $8F20.w		; 8E 20 8F ; Store X register to $8F20.w [Reads: X Index]
	.db $90, $1D		; 90 1D ; Branch if carry clear to $90, $1D [Flow: branch]
	.db $62, $91, $03		; 62 91 03 ; Push effective relative address $62, $91, $03 [Writes: Stack Pointer]
	sta $959490.l		; 8F 90 94 95 ; Store accumulator (long) $959490.l [Reads: Accumulator]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	eor $9604.w,X		; 5D 04 96 ; Exclusive OR accumulator with memory $9604.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$97.b		; 29 97 ; Logical AND #$97.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	jsl $990729.l		; 22 29 07 99 ; Jump to subroutine long $990729.l [Writes: Stack Pointer] [Flow: call]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	sta $1B9C40.l		; 8F 40 9C 1B ; Store accumulator (long) $1B9C40.l [Reads: Accumulator]
	adc $9D.b		; 65 9D ; Add $9D.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	lda $A4.b,S		; A3 A4 ; Load accumulator (stack relative) $A4.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldx $A5.b,Y		; B6 A5 ; Load X register $A5.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	ldx $30.b		; A6 30 ; Load $30.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	lda [$1B.b]		; A7 1B ; Load accumulator (long) [$1B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	and [$62.b],Y		; 37 62 ; AND accumulator with memory (long indexed) [$62.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldy $AC62.w		; AC 62 AC ; Load $AC62.w into Y register [Writes: Y Index] [Flags: NZ]
	ora [$09.b]		; 07 09 ; OR accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $1212B0.l		; AF B0 12 12 ; Load long $1212B0.l into accumulator [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	lda ($37.b),Y		; B1 37 ; Load accumulator ($37.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $0F, $1C		; 62 0F 1C ; Push effective relative address $62, $0F, $1C [Writes: Stack Pointer]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda ($B2.b)		; B2 B2 ; Load accumulator (indirect) ($B2.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	lda ($0E.b,S),Y		; B3 0E ; Load accumulator (stack relative indirect indexed) ($0E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldy $B5.b,X		; B4 B5 ; Load Y register $B5.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	adc #$69.b		; 69 69 ; Add #$69.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	lda ($37.b),Y		; B1 37 ; Load accumulator ($37.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ldx $1A.b,Y		; B6 1A ; Load X register $1A.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldy $9AAC.w		; AC AC 9A ; Load $9AAC.w into Y register [Writes: Y Index] [Flags: NZ]
	.db $B0, $12		; B0 12 ; Branch if carry set to $B0, $12 [Flow: branch]
	lda [$8F.b],Y		; B7 8F ; Load accumulator (long indexed) [$8F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	lda $B11B.w,Y		; B9 1B B1 ; Load $B11B.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and [$63.b],Y		; 37 63 ; AND accumulator with memory (long indexed) [$63.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($08.b,X)		; 21 08 ; Logical AND ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda ($B2.b)		; B2 B2 ; Load accumulator (indirect) ($B2.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $69B5.w		; 8D B5 69 ; Store accumulator to $69B5.w [Reads: Accumulator]
	adc #$BA.b		; 69 BA ; Add #$BA.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp $53.b		; C5 53 ; Compare $53.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	.db $62, $BB, $23		; 62 BB 23 ; Push effective relative address $62, $BB, $23 [Writes: Stack Pointer]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $BD65.w,X		; BD 65 BD ; Load $BD65.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $4F.b,S		; 03 4F ; OR accumulator with stack relative $4F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	jmp $5B625D.l		; 5C 5D 62 5B ; Jump long to $5B625D.l [Flow: jump]
	brk $5B.b		; 00 5B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	cpx #$63.b		; E0 63 ; Compare #$63.b with X register [Reads: X Index] [Flags: NCZ]
	cmp $07.b,S		; C3 07 ; Compare accumulator (stack relative) $07.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	lda ($58.b,X)		; A1 58 ; Load accumulator ($58.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $53A7.w,X		; 3D A7 53 ; AND accumulator with memory $53A7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $53A7.w,X		; 3D A7 53 ; AND accumulator with memory $53A7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	.db $F0, $05		; F0 05 ; Branch if equal to $F0, $05 [Flow: branch]
	rol $C74F.w,X		; 3E 4F C7 ; Rotate left $C74F.w,X [Reads: X Index] [Flags: NCZ]
	and $53A7.w,X		; 3D A7 53 ; AND accumulator with memory $53A7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $040B01.l,X		; FF 01 0B 04 ; Subtract with carry (long,X) $040B01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: NCZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($0B.b,X)		; 01 0B ; Logical OR ($0B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	and $01.b		; 25 01 ; Logical AND $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $04.b		; 06 04 ; Arithmetic shift left $04.b [Reads: Direct Page] [Flags: NCZ]
	ora $0B.b,S		; 03 0B ; OR accumulator with stack relative $0B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$24.b]		; 07 24 ; OR accumulator with memory (long) [$24.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $0B2605.l		; 22 05 26 0B ; Jump to subroutine long $0B2605.l [Writes: Stack Pointer] [Flow: call]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $08.b,S		; 03 08 ; OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $03090B.l		; 22 0B 09 03 ; Jump to subroutine long $03090B.l [Writes: Stack Pointer] [Flow: call]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora #$01.b		; 09 01 ; Logical OR #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora #$01.b		; 09 01 ; Logical OR #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $0B.b		; 25 0B ; Logical AND $0B.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $0B.b		; 26 0B ; Rotate left $0B.b [Reads: Direct Page] [Flags: NCZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	jsl $051608.l		; 22 08 16 05 ; Jump to subroutine long $051608.l [Writes: Stack Pointer] [Flow: call]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tsb $000C.w		; 0C 0C 00 ; Test and set bits $000C.w [Reads: Accumulator] [Flags: Z]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	tsb $0B07.w		; 0C 07 0B ; Test and set bits $0B07.w [Reads: Accumulator] [Flags: Z]
	tsb $080C.w		; 0C 0C 08 ; Test and set bits $080C.w [Reads: Accumulator] [Flags: Z]
	tsb $0000.w		; 0C 00 00 ; Test and set bits $0000.w [Reads: Accumulator] [Flags: Z]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $0806.w		; 0C 06 08 ; Test and set bits $0806.w [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	tsb $0407.w		; 0C 07 04 ; Test and set bits $0407.w [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$0B.b		; 09 0B ; Logical OR #$0B.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	lda $080405.l,X		; BF 05 04 08 ; Load long $080405.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	and ($03.b),Y		; 31 03 ; AND accumulator with memory ($03.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	brk $CA.b		; 00 CA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	tsb $0086.w		; 0C 86 00 ; Test and set bits $0086.w [Reads: Accumulator] [Flags: Z]
	cpy $0086.w		; CC 86 00 ; Compare $0086.w with Y register [Reads: Y Index] [Flags: NCZ]
	cmp #$85.b		; C9 85 ; Compare #$85.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	brk $CA.b		; 00 CA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $22C802.l,X		; FF 02 C8 22 ; Subtract with carry (long,X) $22C802.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	.db $62, $09, $01		; 62 09 01 ; Push effective relative address $62, $09, $01 [Writes: Stack Pointer]
	ora #$0A.b		; 09 0A ; Logical OR #$0A.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp #$8E.b		; C9 8E ; Compare #$8E.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora $30C8.w		; 0D C8 30 ; Logical OR $30C8.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $62, $06, $1F		; 62 06 1F ; Push effective relative address $62, $06, $1F [Writes: Stack Pointer]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	asl $B062.w		; 0E 62 B0 ; Arithmetic shift left $B062.w [Flags: NCZ]
	and ($08.b),Y		; 31 08 ; AND accumulator with memory ($08.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $10.b		; 06 10 ; Arithmetic shift left $10.b [Reads: Direct Page] [Flags: NCZ]
	wai		; CB ; Wait for interrupt
	stx $C80D.w		; 8E 0D C8 ; Store X register to $C80D.w [Reads: X Index]
	ora $001A.w,Y		; 19 1A 00 ; OR accumulator with memory $001A.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tsb $CC.b		; 04 CC ; Test and set bits $CC.b [Reads: Accumulator] [Flags: Z]
	cmp $2C2B.w		; CD 2B 2C ; Compare $2C2B.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	and $1B3A.w,Y		; 39 3A 1B ; AND accumulator with memory $1B3A.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $8E73.w		; 1C 73 8E ; Test and reset bits $8E73.w [Reads: Accumulator] [Flags: Z]
	.db $62, $CE, $5B		; 62 CE 5B ; Push effective relative address $62, $CE, $5B [Writes: Stack Pointer]
	and [$09.b]		; 27 09 ; AND accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$62.b]		; 07 62 ; OR accumulator with memory (long) [$62.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $91400B.l		; CF 0B 40 91 ; Compare accumulator (long) $91400B.l [Reads: Accumulator] [Flags: NCZ]
	stx $2937.w		; 8E 37 29 ; Store X register to $2937.w [Reads: X Index]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	stx $920D.w		; 8E 0D 92 ; Store X register to $920D.w [Reads: X Index]
	lda ($D2.b)		; B2 D2 ; Load accumulator (indirect) ($D2.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pea $D364.w		; F4 64 D3 ; Push absolute address $D364.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	ora [$1F.b]		; 07 1F ; OR accumulator with memory (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $A1.b,S		; 03 A1 ; OR accumulator with stack relative $A1.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
.ACCU 16
	rep #$AA		; C2 AA
	stx $C9.b,Y		; 96 C9 ; Store X register $C9.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	ldx $66.b		; A6 66 ; Load $66.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	ora [$6E.b]		; 07 6E ; OR accumulator with memory (long) [$6E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $E0AAAC.l,X		; DF AC AA E0 ; Compare accumulator (long,X) $E0AAAC.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	sbc $239D.w		; ED 9D 23 ; Subtract $239D.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	.db $62, $E1, $03		; 62 E1 03 ; Push effective relative address $62, $E1, $03 [Writes: Stack Pointer]
	ora #$B1E4.w		; 09 E4 B1 ; Logical OR #$B1E4.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$E562.w		; 09 62 E5 ; Logical OR #$E562.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$7ACA.w		; 09 CA 7A ; Logical OR #$7ACA.w with accumulator [Writes: Accumulator] [Flags: NZ]
	adc ($22.b,S),Y		; 73 22 ; Add with carry (stack relative indirect indexed) ($22.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	and $E8.b,S		; 23 E8 ; AND accumulator with stack relative $E8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc #$3023.w		; E9 23 30 ; Subtract #$3023.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	asl $EA63.w		; 0E 63 EA ; Arithmetic shift left $EA63.w [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	jsr $04EE.w		; 20 EE 04 ; Jump to subroutine at $04EE.w [Writes: Stack Pointer] [Flow: call]
	ora $73EF.w,X		; 1D EF 73 ; OR accumulator with memory $73EF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$7224.w		; 49 24 72 ; Exclusive OR #$7224.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cpy $F1F0.w		; CC F0 F1 ; Compare $F1F0.w with Y register [Reads: Y Index] [Flags: NCZ]
	adc $F1.b,S		; 63 F1 ; Add with carry (stack relative) $F1.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $1D5FF5.l,X		; 1F F5 5F 1D ; Logical OR long $1D5FF5.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda $3E.b		; A5 3E ; Load $3E.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc [$5A.b],Y		; 77 5A ; Add with carry (long indexed) [$5A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($62.b)		; 12 62 ; OR accumulator with memory (indirect) ($62.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $63.b,X		; F6 63 ; Increment memory $63.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpx #$24.b		; E0 24 ; Compare #$24.b with X register [Reads: X Index] [Flags: NCZ]
	asl $1DCC.w,X		; 1E CC 1D ; Arithmetic shift left $1DCC.w,X [Reads: X Index] [Flags: NCZ]
	ora $FCFB.w,X		; 1D FB FC ; OR accumulator with memory $FCFB.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($0D.b)		; 32 0D ; AND accumulator with memory (indirect) ($0D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc #$FEFD.w		; 69 FD FE ; Add #$FEFD.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $086E6E.l,X		; 9F 6E 6E 08 ; Store accumulator (long,X) $086E6E.l,X [Reads: Accumulator, X Index]
	sbc $1D0100.l,X		; FF 00 01 1D ; Subtract with carry (long,X) $1D0100.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl $4002.w,X		; 1E 02 40 ; Arithmetic shift left $4002.w,X [Reads: X Index] [Flags: NCZ]
	stz $0403.w		; 9C 03 04 ; Store zero to $0403.w
	cmp ($05.b,X)		; C1 05 ; Compare accumulator ($05.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	ora $1F741F.l,X		; 1F 1F 74 1F ; Logical OR long $1F741F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $6A.b		; 06 6A ; Arithmetic shift left $6A.b [Reads: Direct Page] [Flags: NCZ]
	cpy #$C1.b		; C0 C1 ; Compare #$C1.b with Y register [Reads: Y Index] [Flags: NCZ]
	and ($62.b)		; 32 62 ; AND accumulator with memory (indirect) ($62.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$E0.b]		; 07 E0 ; OR accumulator with memory (long) [$E0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $53A73D.l		; 22 3D A7 53 ; Jump to subroutine long $53A73D.l [Writes: Stack Pointer] [Flow: call]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	ora $FFBA1F.l,X		; 1F 1F BA FF ; Logical OR long $FFBA1F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $C5.b,S		; 03 C5 ; OR accumulator with stack relative $C5.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor ($3D.b,S),Y		; 53 3D ; XOR accumulator (stack relative indirect indexed) ($3D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda [$53.b]		; A7 53 ; Load accumulator (long) [$53.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $DA46.w,X		; 3D 46 DA ; AND accumulator with memory $DA46.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	.db $62, $1F, $61		; 62 1F 61 ; Push effective relative address $62, $1F, $61 [Writes: Stack Pointer]
	.db $62, $74, $99		; 62 74 99 ; Push effective relative address $62, $74, $99 [Writes: Stack Pointer]
	asl $5655.w,X		; 1E 55 56 ; Arithmetic shift left $5655.w,X [Reads: X Index] [Flags: NCZ]
	lsr $DA.b		; 46 DA ; Logical shift right $DA.b [Reads: Direct Page] [Flags: NCZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	lsr $4E.b		; 46 4E ; Logical shift right $4E.b [Reads: Direct Page] [Flags: NCZ]
	lda ($4C.b,X)		; A1 4C ; Load accumulator ($4C.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $0B, $00		; 62 0B 00 ; Push effective relative address $62, $0B, $00 [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	.db $62, $0E, $05		; 62 0E 05 ; Push effective relative address $62, $0E, $05 [Writes: Stack Pointer]
	asl $4E0D.w		; 0E 0D 4E ; Arithmetic shift left $4E0D.w [Flags: NCZ]
	lda ($4C.b,X)		; A1 4C ; Load accumulator ($4C.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lsr $0083.w		; 4E 83 00 ; Logical shift right $0083.w [Flags: NCZ]
	cpy $A700.w		; CC 00 A7 ; Compare $A700.w with Y register [Reads: Y Index] [Flags: NCZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	wai		; CB ; Wait for interrupt
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	sbc ($FF.b),Y		; F1 FF ; Subtract with carry ($FF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$09.b]		; 07 09 ; OR accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $0C.b		; 02 0C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$0600.w		; 09 00 06 ; Logical OR #$0600.w with accumulator [Writes: Accumulator] [Flags: NZ]
	eor $0C.b,S		; 43 0C ; Exclusive OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$0709.w		; 09 09 07 ; Logical OR #$0709.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$09.b]		; 07 09 ; OR accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $2609.w		; 0C 09 26 ; Test and set bits $2609.w [Reads: Accumulator] [Flags: Z]
	tsb $0906.w		; 0C 06 09 ; Test and set bits $0906.w [Reads: Accumulator] [Flags: Z]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$0603.w		; 09 03 06 ; Logical OR #$0603.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$0C29.w		; 09 29 0C ; Logical OR #$0C29.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ora ($2A.b),Y		; 11 2A ; OR accumulator with memory ($2A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tsb $0506.w		; 0C 06 05 ; Test and set bits $0506.w [Reads: Accumulator] [Flags: Z]
	ora [$09.b]		; 07 09 ; OR accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	tsb $240C.w		; 0C 0C 24 ; Test and set bits $240C.w [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	bit $0C.b		; 24 0C ; Test bits $0C.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$0608.w		; 09 08 06 ; Logical OR #$0608.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $2407.w		; 0C 07 24 ; Test and set bits $2407.w [Reads: Accumulator] [Flags: Z]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	ora $0C05.w,X		; 1D 05 0C ; OR accumulator with memory $0C05.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $0601.w		; 0C 01 06 ; Test and set bits $0601.w [Reads: Accumulator] [Flags: Z]
	tsb $230C.w		; 0C 0C 23 ; Test and set bits $230C.w [Reads: Accumulator] [Flags: Z]
	asl $23.b		; 06 23 ; Arithmetic shift left $23.b [Reads: Direct Page] [Flags: NCZ]
	tsb $0501.w		; 0C 01 05 ; Test and set bits $0501.w [Reads: Accumulator] [Flags: Z]
	ora $2D.b		; 05 2D ; Logical OR $2D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $0703.w		; 0C 03 07 ; Test and set bits $0703.w [Reads: Accumulator] [Flags: Z]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$29.b]		; 07 29 ; OR accumulator with memory (long) [$29.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $220C.w		; 0C 0C 22 ; Test and set bits $220C.w [Reads: Accumulator] [Flags: Z]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$0C.b]		; 07 0C ; OR accumulator with memory (long) [$0C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$09.b]		; 07 09 ; OR accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $090207.l		; 22 07 02 09 ; Jump to subroutine long $090207.l [Writes: Stack Pointer] [Flow: call]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $08030C.l		; 22 0C 03 08 ; Jump to subroutine long $08030C.l [Writes: Stack Pointer] [Flow: call]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$0722.w		; 09 22 07 ; Logical OR #$0722.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($0C.b,X)		; 01 0C ; Logical OR ($0C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$84.b]		; 07 84 ; OR accumulator with memory (long) [$84.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $072C0C.l		; 22 0C 2C 07 ; Jump to subroutine long $072C0C.l [Writes: Stack Pointer] [Flow: call]
	cop $0C.b		; 02 0C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $2D04.w		; 0C 04 2D ; Test and set bits $2D04.w [Reads: Accumulator] [Flags: Z]
	tsb $0203.w		; 0C 03 02 ; Test and set bits $0203.w [Reads: Accumulator] [Flags: Z]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $29.b		; 06 29 ; Arithmetic shift left $29.b [Reads: Direct Page] [Flags: NCZ]
	tsb $080E.w		; 0C 0E 08 ; Test and set bits $080E.w [Reads: Accumulator] [Flags: Z]
	tsb $040C.w		; 0C 0C 04 ; Test and set bits $040C.w [Reads: Accumulator] [Flags: Z]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	ora ($0B.b,X)		; 01 0B ; Logical OR ($0B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	brk $E7.b		; 00 E7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $753B18.l,X		; FF 18 3B 75 ; Subtract with carry (long,X) $753B18.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $AA02DE.l,X		; 3F DE 02 AA ; AND accumulator with memory (long,X) $AA02DE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $0D.b,X		; 15 0D ; OR accumulator with memory $0D.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	asl $6A.b,X		; 16 6A ; Arithmetic shift left $6A.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($1D.b),Y		; 11 1D ; OR accumulator with memory ($1D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($1F.b)		; 12 1F ; OR accumulator with memory (indirect) ($1F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $751D30.l		; 2F 30 1D 75 ; AND accumulator with memory (long) $751D30.l [Writes: Accumulator] [Flags: NZ]
	and $131DFC.l,X		; 3F FC 1D 13 ; AND accumulator with memory (long,X) $131DFC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	trb $0D.b		; 14 0D ; Test and reset bits $0D.b [Reads: Accumulator] [Flags: Z]
	ora $24.b,X		; 15 24 ; OR accumulator with memory $24.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	asl $09.b,X		; 16 09 ; Arithmetic shift left $09.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora [$30.b],Y		; 17 30 ; OR accumulator with memory (long indexed) [$30.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpx $75.b		; E4 75 ; Compare $75.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	and $396AE6.l,X		; 3F E6 6A 39 ; AND accumulator with memory (long,X) $396AE6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $1A24.w,Y		; 19 24 1A ; OR accumulator with memory $1A24.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $1B, $06		; 62 1B 06 ; Push effective relative address $62, $1B, $06 [Writes: Stack Pointer]
	lda ($75.b)		; B2 75 ; Load accumulator (indirect) ($75.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $1EFBFC.l,X		; 3F FC FB 1E ; AND accumulator with memory (long,X) $1EFBFC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $632024.l,X		; 1F 24 20 63 ; Logical OR long $632024.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($06.b,X)		; 21 06 ; Logical AND ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $75.b		; E5 75 ; Subtract $75.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and $256A6A.l,X		; 3F 6A 6A 25 ; AND accumulator with memory (long,X) $256A6A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rol $23.b		; 26 23 ; Rotate left $23.b [Reads: Direct Page] [Flags: NCZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $27.b		; 64 27 ; Store zero to $27.b
	ora $75.b		; 05 75 ; Logical OR $75.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $2C7435.l,X		; 3F 35 74 2C ; AND accumulator with memory (long,X) $2C7435.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jmp ($8024.w)		; 6C 24 80 ; Jump indirect to ($8024.w) [Flow: jump]
	ora $2E2DF9.l		; 0F F9 2D 2E ; OR accumulator with memory (long) $2E2DF9.l [Writes: Accumulator] [Flags: NZ]
	.db $30, $E5		; 30 E5 ; Branch if minus to $30, $E5 [Flow: branch]
	bit $302F.w,X		; 3C 2F 30 ; Test bits $302F.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	asl $316A.w,X		; 1E 6A 31 ; Arithmetic shift left $316A.w,X [Reads: X Index] [Flags: NCZ]
	and ($B7.b)		; 32 B7 ; AND accumulator with memory (indirect) ($B7.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sty $80.b,X		; 94 80 ; Store Y register $80.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	sta [$63.b]		; 87 63 ; Store accumulator (long) [$63.b] [Reads: Direct Page, Accumulator]
	and ($03.b,S),Y		; 33 03 ; AND accumulator (stack relative indirect indexed) ($03.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $AF.b		; E5 AF ; Subtract $AF.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and [$38.b],Y		; 37 38 ; AND accumulator with memory (long indexed) [$38.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and #$0539.w		; 29 39 05 ; Logical AND #$0539.w with accumulator [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	rol $90.b,X		; 36 90 ; Rotate left $90.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc $AF.b		; E5 AF ; Subtract $AF.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	eor $29.b		; 45 29 ; Exclusive OR $29.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $E5.b,X		; 36 E5 ; Rotate left $E5.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cpx $E5.b		; E4 E5 ; Compare $E5.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	bit $3780.w,X		; 3C 80 37 ; Test bits $3780.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	jsl $370980.l		; 22 80 09 37 ; Jump to subroutine long $370980.l [Writes: Stack Pointer] [Flow: call]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	bit $363B.w,X		; 3C 3B 36 ; Test bits $363B.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	cpx #$26.b		; E0 26 ; Compare #$26.b with X register [Reads: X Index] [Flags: NCZ]
	rol $50.b		; 26 50 ; Rotate left $50.b [Reads: Direct Page] [Flags: NCZ]
	jsl $3D0126.l		; 22 26 01 3D ; Jump to subroutine long $3D0126.l [Writes: Stack Pointer] [Flow: call]
	rol $84.b		; 26 84 ; Rotate left $84.b [Reads: Direct Page] [Flags: NCZ]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $3B.b		; 02 3B ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $3E.b,X		; 36 3E ; Rotate left $3E.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	bit $022C.w		; 2C 2C 02 ; Test bits $022C.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	and $623E36.l,X		; 3F 36 3E 62 ; AND accumulator with memory (long,X) $623E36.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $42.b		; 00 42 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	eor $07.b,S		; 43 07 ; Exclusive OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	mvp $47,$42		; 44 42 47 ; Move block positive $47,$42 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	.db $62, $3D, $B7		; 62 3D B7 ; Push effective relative address $62, $3D, $B7 [Writes: Stack Pointer]
	sty $63.b,X		; 94 63 ; Store Y register $63.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	eor $62.b		; 45 62 ; Exclusive OR $62.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr $E0.b		; 46 E0 ; Logical shift right $E0.b [Reads: Direct Page] [Flags: NCZ]
	jsl $4A4946.l		; 22 46 49 4A ; Jump to subroutine long $4A4946.l [Writes: Stack Pointer] [Flow: call]
	lda ($4B.b,X)		; A1 4B ; Load accumulator ($4B.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	and ($1D.b,S),Y		; 33 1D ; AND accumulator (stack relative indirect indexed) ($1D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($C5.b),Y		; 31 C5 ; AND accumulator with memory ($C5.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor ($3D.b,S),Y		; 53 3D ; XOR accumulator (stack relative indirect indexed) ($3D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda [$53.b]		; A7 53 ; Load accumulator (long) [$53.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $53A7.w,X		; 3D A7 53 ; AND accumulator with memory $53A7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $A7A7.w,X		; 3D A7 A7 ; AND accumulator with memory $A7A7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($3D.b,S),Y		; 53 3D ; XOR accumulator (stack relative indirect indexed) ($3D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $42A5.w,X		; 3E A5 42 ; Rotate left $42A5.w,X [Reads: X Index] [Flags: NCZ]
	eor $DA46DB.l		; 4F DB 46 DA ; Exclusive OR accumulator with memory (long) $DA46DB.l [Writes: Accumulator] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	lsr $DA.b		; 46 DA ; Logical shift right $DA.b [Reads: Direct Page] [Flags: NCZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	lsr $DA.b		; 46 DA ; Logical shift right $DA.b [Reads: Direct Page] [Flags: NCZ]
	sbc $09090F.l,X		; FF 0F 09 09 ; Subtract with carry (long,X) $09090F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $0000.w		; 0C 00 00 ; Test and set bits $0000.w [Reads: Accumulator] [Flags: Z]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	ora #$0908.w		; 09 08 09 ; Logical OR #$0908.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$0C0C.w		; 09 0C 0C ; Logical OR #$0C0C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$27.b]		; 07 27 ; OR accumulator with memory (long) [$27.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $0806.w		; 0C 06 08 ; Test and set bits $0806.w [Reads: Accumulator] [Flags: Z]
	tsb $090C.w		; 0C 0C 09 ; Test and set bits $090C.w [Reads: Accumulator] [Flags: Z]
	ora #$0507.w		; 09 07 05 ; Logical OR #$0507.w with accumulator [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tsb $0900.w		; 0C 00 09 ; Test and set bits $0900.w [Reads: Accumulator] [Flags: Z]
	jsl $09040C.l		; 22 0C 04 09 ; Jump to subroutine long $09040C.l [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $080C.w		; 0C 0C 08 ; Test and set bits $080C.w [Reads: Accumulator] [Flags: Z]
	jsl $09000C.l		; 22 0C 00 09 ; Jump to subroutine long $09000C.l [Writes: Stack Pointer] [Flow: call]
	jsl $09020C.l		; 22 0C 02 09 ; Jump to subroutine long $09020C.l [Writes: Stack Pointer] [Flow: call]
	tsb $2405.w		; 0C 05 24 ; Test and set bits $2405.w [Reads: Accumulator] [Flags: Z]
	tsb $0900.w		; 0C 00 09 ; Test and set bits $0900.w [Reads: Accumulator] [Flags: Z]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	and $0908.w		; 2D 08 09 ; Logical AND $0908.w with accumulator [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora #$060C.w		; 09 0C 06 ; Logical OR #$060C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $010C.w		; 0C 0C 01 ; Test and set bits $010C.w [Reads: Accumulator] [Flags: Z]
	bit $0C.b		; 24 0C ; Test bits $0C.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: NCZ]
	tsb $0C02.w		; 0C 02 0C ; Test and set bits $0C02.w [Reads: Accumulator] [Flags: Z]
	tsb $0901.w		; 0C 01 09 ; Test and set bits $0901.w [Reads: Accumulator] [Flags: Z]
	bit $020C.w		; 2C 0C 02 ; Test bits $020C.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora #$0C2C.w		; 09 2C 0C ; Logical OR #$0C2C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $09.b		; 06 09 ; Arithmetic shift left $09.b [Reads: Direct Page] [Flags: NCZ]
	tsb $0229.w		; 0C 29 02 ; Test and set bits $0229.w [Reads: Accumulator] [Flags: Z]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $090105.l		; 22 05 01 09 ; Jump to subroutine long $090105.l [Writes: Stack Pointer] [Flow: call]
	tsb $0C43.w		; 0C 43 0C ; Test and set bits $0C43.w [Reads: Accumulator] [Flags: Z]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$09.b]		; 07 09 ; OR accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $07.b		; 24 07 ; Test bits $07.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $0C0209.l		; 22 09 02 0C ; Jump to subroutine long $0C0209.l [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$62.b]		; 07 62 ; OR accumulator with memory (long) [$62.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$0724.w		; 09 24 07 ; Logical OR #$0724.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $0C0009.l		; 22 09 00 0C ; Jump to subroutine long $0C0009.l [Writes: Stack Pointer] [Flow: call]
	and [$07.b]		; 27 07 ; AND accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $0C.b		; 06 0C ; Arithmetic shift left $0C.b [Reads: Direct Page] [Flags: NCZ]
	tsb $0706.w		; 0C 06 07 ; Test and set bits $0706.w [Reads: Accumulator] [Flags: Z]
	tsb $0608.w		; 0C 08 06 ; Test and set bits $0608.w [Reads: Accumulator] [Flags: Z]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	tsb $0405.w		; 0C 05 04 ; Test and set bits $0405.w [Reads: Accumulator] [Flags: Z]
	ora ($0C.b,X)		; 01 0C ; Logical OR ($0C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $0507.w		; 0C 07 05 ; Test and set bits $0507.w [Reads: Accumulator] [Flags: Z]
	bit $0C.b		; 24 0C ; Test bits $0C.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	eor $02.b,S		; 43 02 ; Exclusive OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $0C02.w		; 0C 02 0C ; Test and set bits $0C02.w [Reads: Accumulator] [Flags: Z]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	jsl $07080C.l		; 22 0C 08 07 ; Jump to subroutine long $07080C.l [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $0604.w		; 0C 04 06 ; Test and set bits $0604.w [Reads: Accumulator] [Flags: Z]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	cpx #$0B.b		; E0 0B ; Compare #$0B.b with X register [Reads: X Index] [Flags: NCZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0005.w		; 0C 05 00 ; Test and set bits $0005.w [Reads: Accumulator] [Flags: Z]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $FF.b		; 05 FF ; Logical OR $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($99.b),Y		; 11 99 ; OR accumulator with memory ($99.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	jmp $1D1D.w		; 4C 1D 1D ; Jump to $1D1D.w [Flow: jump]
	lda [$2D.b],Y		; B7 2D ; Load accumulator (long indexed) [$2D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $3AF6.w,Y		; 39 F6 3A ; AND accumulator with memory $3AF6.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $614E.w		; 4D 4E 61 ; Exclusive OR $614E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $4F44.w		; 0D 44 4F ; Logical OR $4F44.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $50, $24		; 50 24 ; Branch if overflow clear to $50, $24 [Flow: branch]
	asl $07.b,X		; 16 07 ; Arithmetic shift left $07.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	eor ($F6.b),Y		; 51 F6 ; Exclusive OR accumulator with memory ($F6.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor ($53.b)		; 52 53 ; Exclusive OR accumulator with memory (indirect) ($53.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	stz $6177.w		; 9C 77 61 ; Store zero to $6177.w
	cmp #$5463.w		; C9 63 54 ; Compare #$5463.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	bit $1A.b		; 24 1A ; Test bits $1A.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	trb $58.b		; 14 58 ; Test and reset bits $58.b [Reads: Accumulator] [Flags: Z]
	eor $4D16.w,Y		; 59 16 4D ; Exclusive OR accumulator with memory $4D16.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr $4E5A.w		; 4E 5A 4E ; Logical shift right $4E5A.w [Flags: NCZ]
	cpx #$24.b		; E0 24 ; Compare #$24.b with X register [Reads: X Index] [Flags: NCZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	inc $5C.b,X		; F6 5C ; Increment memory $5C.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	jsr $0720.w		; 20 20 07 ; Jump to subroutine at $0720.w [Writes: Stack Pointer] [Flow: call]
	jsr $5D20.w		; 20 20 5D ; Jump to subroutine at $5D20.w [Writes: Stack Pointer] [Flow: call]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	eor $6411.w		; 4D 11 64 ; Exclusive OR $6411.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lsr $180D.w,X		; 5E 0D 18 ; Logical shift right $180D.w,X [Reads: X Index] [Flags: NCZ]
	adc $55.b,S		; 63 55 ; Add with carry (stack relative) $55.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc $EB5564.l		; EF 64 55 EB ; Subtract with carry (long) $EB5564.l [Writes: Accumulator] [Flags: NCVZ]
	sbc $6A4D74.l		; EF 74 4D 6A ; Subtract with carry (long) $6A4D74.l [Writes: Accumulator] [Flags: NCVZ]
	adc $66.b		; 65 66 ; Add $66.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	stz $67.b		; 64 67 ; Store zero to $67.b
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	jmp $243E.w		; 4C 3E 24 ; Jump to $243E.w [Flow: jump]
	jmp $D93E.w		; 4C 3E D9 ; Jump to $D93E.w [Flow: jump]
	jmp ($6DDE.w)		; 6C DE 6D ; Jump indirect to ($6DDE.w) [Flow: jump]
	ror $99AB.w		; 6E AB 99 ; Rotate right $99AB.w [Flags: NCZ]
	ror $6F.b		; 66 6F ; Rotate right $6F.b [Reads: Direct Page] [Flags: NCZ]
	cop $73.b		; 02 73 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $6C.b,X		; 74 6C ; Store zero to $6C.b,X [Reads: X Index]
	.db $62, $76, $03		; 62 76 03 ; Push effective relative address $62, $76, $03 [Writes: Stack Pointer]
	cmp #$99C9.w		; C9 C9 99 ; Compare #$99C9.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	adc $7A29.w,Y		; 79 29 7A ; Add $7A29.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $7B.b		; 05 7B ; Logical OR $7B.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jmp ($A4A4.w,X)		; 7C A4 A4 ; Jump indirect indexed to ($A4A4.w,X) [Reads: X Index] [Flow: jump]
	sta $297D.w,Y		; 99 7D 29 ; Store accumulator to $297D.w,Y [Reads: Y Index, Accumulator]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $E5E5A3.l,X		; 1F A3 E5 E5 ; Logical OR long $E5E5A3.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $7E7D.w,Y		; 99 7D 7E ; Store accumulator to $7E7D.w,Y [Reads: Y Index, Accumulator]
	.db $80, $3C		; 80 3C ; Branch always to $80, $3C [Flow: branch]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	and [$23.b],Y		; 37 23 ; AND accumulator with memory (long indexed) [$23.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $80, $0B		; 80 0B ; Branch always to $80, $0B [Flow: branch]
	rol $E5.b,X		; 36 E5 ; Rotate left $E5.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	rol $993E.w,X		; 3E 3E 99 ; Rotate left $993E.w,X [Reads: X Index] [Flags: NCZ]
	adc $26E0.w,X		; 7D E0 26 ; Add $26E0.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $E0.b		; 26 E0 ; Rotate left $E0.b [Reads: Direct Page] [Flags: NCZ]
	eor $26234F.l		; 4F 4F 23 26 ; Exclusive OR accumulator with memory (long) $26234F.l [Writes: Accumulator] [Flags: NZ]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	sta $7F00.w,X		; 9D 00 7F ; Store accumulator to $7F00.w,X [Reads: Accumulator, X Index]
	and [$2C.b]		; 27 2C ; AND accumulator with memory (long) [$2C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $80, $81		; 80 81 ; Branch always to $80, $81 [Flow: branch]
	jsl $B25449.l		; 22 49 54 B2 ; Jump to subroutine long $B25449.l [Writes: Stack Pointer] [Flow: call]
	sta $258382.l,X		; 9F 82 83 25 ; Store accumulator (long,X) $258382.l,X [Reads: Accumulator, X Index]
	sty $06.b		; 84 06 ; Store Y register to $06.b [Reads: Y Index]
	sta $22.b		; 85 22 ; Store accumulator to $22.b [Reads: Accumulator]
	stz $86.b,X		; 74 86 ; Store zero to $86.b,X [Reads: X Index]
	sta [$49.b]		; 87 49 ; Store accumulator (long) [$49.b] [Reads: Direct Page, Accumulator]
	sbc $62.b		; E5 62 ; Subtract $62.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ora ($88.b,X)		; 01 88 ; Logical OR ($88.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	eor $5B.b,S		; 43 5B ; Exclusive OR accumulator with stack relative $5B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sty $8D02.w		; 8C 02 8D ; Store Y register to $8D02.w [Reads: Y Index]
	and ($34.b,S),Y		; 33 34 ; AND accumulator (stack relative indirect indexed) ($34.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $62, $8E, $08		; 62 8E 08 ; Push effective relative address $62, $8E, $08 [Writes: Stack Pointer]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	eor ($3D.b,S),Y		; 53 3D ; XOR accumulator (stack relative indirect indexed) ($3D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda [$53.b]		; A7 53 ; Load accumulator (long) [$53.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	.db $42, $CC		; 42 CC ; Reserved instruction
	asl $9162.w,X		; 1E 62 91 ; Arithmetic shift left $9162.w,X [Reads: X Index] [Flags: NCZ]
	trb $8E.b		; 14 8E ; Test and reset bits $8E.b [Reads: Accumulator] [Flags: Z]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl $C932.w,X		; 1E 32 C9 ; Arithmetic shift left $C932.w,X [Reads: X Index] [Flags: NCZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	lsr $DA.b		; 46 DA ; Logical shift right $DA.b [Reads: Direct Page] [Flags: NCZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	.db $62, $1D, $1D		; 62 1D 1D ; Push effective relative address $62, $1D, $1D [Writes: Stack Pointer]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lsr $5394.w,X		; 5E 94 53 ; Logical shift right $5394.w,X [Reads: X Index] [Flags: NCZ]
	ora $32FB.w,X		; 1D FB 32 ; OR accumulator with memory $32FB.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$00FF.w		; C9 FF 00 ; Compare #$00FF.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora ($26.b,X)		; 01 26 ; Logical OR ($26.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tsb $0C06.w		; 0C 06 0C ; Test and set bits $0C06.w [Reads: Accumulator] [Flags: Z]
	tsb $0101.w		; 0C 01 01 ; Test and set bits $0101.w [Reads: Accumulator] [Flags: Z]
	tsb $010C.w		; 0C 0C 01 ; Test and set bits $010C.w [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $0C.b		; 05 0C ; Logical OR $0C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	mvp $0A,$0C		; 44 0C 0A ; Move block positive $0A,$0C [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	tsb $0C.b		; 04 0C ; Test and set bits $0C.b [Reads: Accumulator] [Flags: Z]
	asl $0C.b		; 06 0C ; Arithmetic shift left $0C.b [Reads: Direct Page] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	asl $0C26.w		; 0E 26 0C ; Arithmetic shift left $0C26.w [Flags: NCZ]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ora ($00.b,S),Y		; 13 00 ; OR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $83.b		; 05 83 ; Logical OR $83.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0C.b		; 05 0C ; Logical OR $0C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $43.b		; 05 43 ; Logical OR $43.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0C.b		; 05 0C ; Logical OR $0C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $0A.b		; 04 0A ; Test and set bits $0A.b [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tsb $010A.w		; 0C 0A 01 ; Test and set bits $010A.w [Reads: Accumulator] [Flags: Z]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	bit $0C22.w,X		; 3C 22 0C ; Test bits $0C22.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	mvp $0C,$0A		; 44 0A 0C ; Move block positive $0C,$0A [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	and $0C26.w		; 2D 26 0C ; Logical AND $0C26.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $0A22.w		; 0C 22 0A ; Test and set bits $0A22.w [Reads: Accumulator] [Flags: Z]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($2A.b,X)		; 01 2A ; Logical OR ($2A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $0A05.w		; 0C 05 0A ; Test and set bits $0A05.w [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	tsb $0C01.w		; 0C 01 0C ; Test and set bits $0C01.w [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and $0C.b,S		; 23 0C ; AND accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	and $0143.w,X		; 3D 43 01 ; AND accumulator with memory $0143.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $0C04.w		; 0C 04 0C ; Test and set bits $0C04.w [Reads: Accumulator] [Flags: Z]
	ora ($0C.b,X)		; 01 0C ; Logical OR ($0C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $0C.b		; 06 0C ; Arithmetic shift left $0C.b [Reads: Direct Page] [Flags: NCZ]
	eor $0C.b,S		; 43 0C ; Exclusive OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ora $0200.w,X		; 1D 00 02 ; OR accumulator with memory $0200.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	bit $0C.b		; 24 0C ; Test bits $0C.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0C.b		; 05 0C ; Logical OR $0C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $05000A.l		; 22 0A 00 05 ; Jump to subroutine long $05000A.l [Writes: Stack Pointer] [Flow: call]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	sta $850C24.l		; 8F 24 0C 85 ; Store accumulator (long) $850C24.l [Reads: Accumulator]
	brk $2A.b		; 00 2A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $06.b		; 04 06 ; Test and set bits $06.b [Reads: Accumulator] [Flags: Z]
	tsb $0C01.w		; 0C 01 0C ; Test and set bits $0C01.w [Reads: Accumulator] [Flags: Z]
	cop $2C.b		; 02 2C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0002.w		; 0C 02 00 ; Test and set bits $0002.w [Reads: Accumulator] [Flags: Z]
	tsb $2402.w		; 0C 02 24 ; Test and set bits $2402.w [Reads: Accumulator] [Flags: Z]
	tsb $0083.w		; 0C 83 00 ; Test and set bits $0083.w [Reads: Accumulator] [Flags: Z]
	tsb $0122.w		; 0C 22 01 ; Test and set bits $0122.w [Reads: Accumulator] [Flags: Z]
	ora ($0C.b,X)		; 01 0C ; Logical OR ($0C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $25.b		; 00 25 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0607.w		; 0C 07 06 ; Test and set bits $0607.w [Reads: Accumulator] [Flags: Z]
	tsb $0303.w		; 0C 03 03 ; Test and set bits $0303.w [Reads: Accumulator] [Flags: Z]
	tsb $0007.w		; 0C 07 00 ; Test and set bits $0007.w [Reads: Accumulator] [Flags: Z]
	ora [$23.b]		; 07 23 ; OR accumulator with memory (long) [$23.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $0201.w		; 0C 01 02 ; Test and set bits $0201.w [Reads: Accumulator] [Flags: Z]
	asl $43.b		; 06 43 ; Arithmetic shift left $43.b [Reads: Direct Page] [Flags: NCZ]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	cld		; D8 ; Clear decimal flag [Flags: D]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $0322.w		; 0C 22 03 ; Test and set bits $0322.w [Reads: Accumulator] [Flags: Z]
	tsb $0C.b		; 04 0C ; Test and set bits $0C.b [Reads: Accumulator] [Flags: Z]
	tsb $0200.w		; 0C 00 02 ; Test and set bits $0200.w [Reads: Accumulator] [Flags: Z]
	tsb $83.b		; 04 83 ; Test and set bits $83.b [Reads: Accumulator] [Flags: Z]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $0C0001.l		; 22 01 00 0C ; Jump to subroutine long $0C0001.l [Writes: Stack Pointer] [Flow: call]
	sbc $23D601.l,X		; FF 01 D6 23 ; Subtract with carry (long,X) $23D601.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $25.b		; 24 25 ; Test bits $25.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	sbc $0995.w,X		; FD 95 09 ; Subtract with carry $0995.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	stx $97.b,Y		; 96 97 ; Store X register $97.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $22D6.w,Y		; 99 D6 22 ; Store accumulator to $22D6.w,Y [Reads: Y Index, Accumulator]
	sbc $EA9B9A.l,X		; FF 9A 9B EA ; Subtract with carry (long,X) $EA9B9A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	nop		; EA ; No operation
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	ora #$109C.w		; 09 9C 10 ; Logical OR #$109C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $9E9D.w		; 8D 9D 9E ; Store accumulator to $9E9D.w [Reads: Accumulator]
	dec $22.b,X		; D6 22 ; Decrement memory $22.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	sbc $E09F62.l,X		; FF 62 9F E0 ; Subtract with carry (long,X) $E09F62.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $9FA1A1.l,X		; 9F A1 A1 9F ; Store accumulator (long,X) $9FA1A1.l,X [Reads: Accumulator, X Index]
	.db $F0, $A2		; F0 A2 ; Branch if equal to $F0, $A2 [Flow: branch]
	lda $A1.b,S		; A3 A1 ; Load accumulator (stack relative) $A1.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldy $FF.b		; A4 FF ; Load $FF.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	dec $22.b,X		; D6 22 ; Decrement memory $22.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	sbc $FFFFA5.l,X		; FF A5 FF FF ; Subtract with carry (long,X) $FFFFA5.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx $FF.b		; A6 FF ; Load $FF.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	sbc $A7FFA5.l,X		; FF A5 FF A7 ; Subtract with carry (long,X) $A7FFA5.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $F0A8A1.l,X		; 7F A1 A8 F0 ; Add long $F0A8A1.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $22.b,X		; D6 22 ; Decrement memory $22.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	.db $F0, $A9		; F0 A9 ; Branch if equal to $F0, $A9 [Flow: branch]
	nop		; EA ; No operation
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda #$EA9B.w		; A9 9B EA ; Load #$EA9B.w into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$AAF0.w		; A9 F0 AA ; Load #$AAF0.w into accumulator [Writes: Accumulator] [Flags: NZ]
	adc $ECABA1.l,X		; 7F A1 AB EC ; Add long $ECABA1.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $22.b,X		; D6 22 ; Decrement memory $22.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	sbc $A0A1AC.l,X		; FF AC A1 A0 ; Subtract with carry (long,X) $A0A1AC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy $A1A0.w		; AC A0 A1 ; Load $A1A0.w into Y register [Writes: Y Index] [Flags: NZ]
	ldy $ADFF.w		; AC FF AD ; Load $ADFF.w into Y register [Writes: Y Index] [Flags: NZ]
	adc $FFDBA1.l,X		; 7F A1 DB FF ; Add long $FFDBA1.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $6A.b,X		; D6 6A ; Decrement memory $6A.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	ldx $7F0D.w		; AE 0D 7F ; Load $7F0D.w into X register [Writes: X Index] [Flags: NZ]
	lda ($02.b,X)		; A1 02 ; Load accumulator ($02.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$0FD6.w		; 09 D6 0F ; Logical OR #$0FD6.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	lda $F8BA.w,Y		; B9 BA F8 ; Load $F8BA.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	.db $10, $B9		; 10 B9 ; Branch if plus to $10, $B9 [Flow: branch]
	.db $62, $BC, $15		; 62 BC 15 ; Push effective relative address $62, $BC, $15 [Writes: Stack Pointer]
	lda ($BF.b,X)		; A1 BF ; Load accumulator ($BF.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ror $D6D6.w		; 6E D6 D6 ; Rotate right $D6D6.w [Flags: NCZ]
	cpy #$E5.b		; C0 E5 ; Compare #$E5.b with Y register [Reads: Y Index] [Flags: NCZ]
	lda $E5C1.w,Y		; B9 C1 E5 ; Load $E5C1.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	rep #$09		; C2 09 ; Reset processor status bits #$09 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	cmp $C4.b,S		; C3 C4 ; Compare accumulator (stack relative) $C4.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	and $1088C5.l		; 2F C5 88 10 ; AND accumulator with memory (long) $1088C5.l [Writes: Accumulator] [Flags: NZ]
	sta [$C6.b],Y		; 97 C6 ; Store accumulator (long indexed) [$C6.b],Y [Reads: Direct Page, Y Index, Accumulator]
	dec $DD.b,X		; D6 DD ; Decrement memory $DD.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	stz $C7.b		; 64 C7 ; Store zero to $C7.b
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora #$CCFF.w		; 09 FF CC ; Logical OR #$CCFF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	.db $F0, $14		; F0 14 ; Branch if equal to $F0, $14 [Flow: branch]
	sbc $D6CECD.l,X		; FF CD CE D6 ; Subtract with carry (long,X) $D6CECD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $CF63.w,X		; DD 63 CF ; Compare accumulator $CF63.w,X [Reads: X Index] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	wai		; CB ; Wait for interrupt
	.db $F0, $A6		; F0 A6 ; Branch if equal to $F0, $A6 [Flow: branch]
	cpy $A6D8.w		; CC D8 A6 ; Compare $A6D8.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpx $D309.w		; EC 09 D3 ; Compare $D309.w with X register [Reads: X Index] [Flags: NCZ]
	sbc $D4.b		; E5 D4 ; Subtract $D4.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp $D564.w,X		; DD 64 D5 ; Compare accumulator $D564.w,X [Reads: X Index] [Flags: NCZ]
	ora ($B3.b,X)		; 01 B3 ; Logical OR ($B3.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda $62DA62.l		; AF 62 DA 62 ; Load long $62DA62.l into accumulator [Writes: Accumulator] [Flags: NZ]
	jmp.w [$1D01]		; DC 01 1D ; Jump long indirect [$1D01] [Flow: jump]
	cmp $A20083.l,X		; DF 83 00 A2 ; Compare accumulator (long,X) $A20083.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	ora $E0.b		; 05 E0 ; Logical OR $E0.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc ($E5.b,X)		; E1 E5 ; Subtract with carry ($E5.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $E2.b		; E5 E2 ; Subtract $E2.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $22.b,S		; E3 22 ; Subtract stack-relative $22.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	sbc $01.b		; E5 01 ; Subtract $01.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cpx $1D.b		; E4 1D ; Compare $1D.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	adc $E5.b		; 65 E5 ; Add $E5.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora [$6A.b]		; 07 6A ; OR accumulator with memory (long) [$6A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	mvp $EC,$44		; 44 44 EC ; Move block positive $EC,$44 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
.INDEX 16
	rep #$1D		; C2 1D
	stx $63.b,Y		; 96 63 ; Store X register $63.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	cpx $D318.w		; EC 18 D3 ; Compare $D318.w with X register [Reads: X Index] [Flags: NCZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $4C5B.w		; 8D 5B 4C ; Store accumulator to $4C5B.w [Reads: Accumulator]
	jmp $4B4BF0.l		; 5C F0 4B 4B ; Jump long to $4B4BF0.l [Flow: jump]
	sbc ($4C.b),Y		; F1 4C ; Subtract with carry ($4C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($4B.b)		; F2 4B ; Subtract with carry (indirect) ($4B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $E5D9.w		; 8D D9 E5 ; Store accumulator to $E5D9.w [Reads: Accumulator]
	sbc ($B2.b,S),Y		; F3 B2 ; Subtract with carry (stack relative indirect indexed) ($B2.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sta [$EA.b],Y		; 97 EA ; Store accumulator (long indexed) [$EA.b],Y [Reads: Direct Page, Y Index, Accumulator]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	pea $A7F5.w		; F4 F5 A7 ; Push absolute address $A7F5.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	.db $62, $EA, $00		; 62 EA 00 ; Push effective relative address $62, $EA, $00 [Writes: Stack Pointer]
	inc $FF.b,X		; F6 FF ; Increment memory $FF.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	ora $06050A.l		; 0F 0A 05 06 ; OR accumulator with memory (long) $06050A.l [Writes: Accumulator] [Flags: NZ]
	tsb $050A.w		; 0C 0A 05 ; Test and set bits $050A.w [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tsb HDMACNT0.w		; 0C 0A 43 ; Test and set bits HDMACNT0.w [Reads: Accumulator] [Flags: Z]
	ora $0C.b		; 05 0C ; Logical OR $0C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $0A.b,S		; 43 0A ; Exclusive OR accumulator with stack relative $0A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $0601.w		; 0C 01 06 ; Test and set bits $0601.w [Reads: Accumulator] [Flags: Z]
	tsb $0A23.w		; 0C 23 0A ; Test and set bits $0A23.w [Reads: Accumulator] [Flags: Z]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $830A.w		; 0C 0A 83 ; Test and set bits $830A.w [Reads: Accumulator] [Flags: Z]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0C.b,S		; 03 0C ; OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $0C01.w		; 0C 01 0C ; Test and set bits $0C01.w [Reads: Accumulator] [Flags: Z]
	eor $0A.b,S		; 43 0A ; Exclusive OR accumulator with stack relative $0A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0D08.w		; 0D 08 0D ; Logical OR $0D08.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $0C0C.w		; 0D 0C 0C ; Logical OR $0C0C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and [$0D.b]		; 27 0D ; AND accumulator with memory (long) [$0D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	bit $02.b		; 24 02 ; Test bits $02.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora $0C0C.w		; 0D 0C 0C ; Logical OR $0C0C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	bit $0D.b		; 24 0D ; Test bits $0D.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	and $050504.l		; 2F 04 05 05 ; AND accumulator with memory (long) $050504.l [Writes: Accumulator] [Flags: NZ]
	asl $0A.b		; 06 0A ; Arithmetic shift left $0A.b [Reads: Direct Page] [Flags: NCZ]
	ora $0122.w		; 0D 22 01 ; Logical OR $0122.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0C010D.l		; 22 0D 01 0C ; Jump to subroutine long $0C010D.l [Writes: Stack Pointer] [Flow: call]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	jsl $0A230D.l		; 22 0D 23 0A ; Jump to subroutine long $0A230D.l [Writes: Stack Pointer] [Flow: call]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $06,$0D		; 44 0D 06 ; Move block positive $06,$0D [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $0A0A0D.l		; 22 0D 0A 0A ; Jump to subroutine long $0A0A0D.l [Writes: Stack Pointer] [Flow: call]
	ora $040D.w		; 0D 0D 04 ; Logical OR $040D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $0D.b		; 02 0D ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0D.b]		; 07 0D ; OR accumulator with memory (long) [$0D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $84.b		; 06 84 ; Arithmetic shift left $84.b [Reads: Direct Page] [Flags: NCZ]
	brk $5B.b		; 00 5B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $0D.b		; 26 0D ; Rotate left $0D.b [Reads: Direct Page] [Flags: NCZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0D0A.w		; 0D 0A 0D ; Logical OR $0D0A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($0C.b,X)		; 01 0C ; Logical OR ($0C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $0D.b		; 25 0D ; Logical AND $0D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($85.b,X)		; 01 85 ; Logical OR ($85.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $7A.b		; 00 7A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($0D.b,X)		; 01 0D ; Logical OR ($0D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: NCZ]
	ora $0600.w		; 0D 00 06 ; Logical OR $0600.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $0D.b,S		; 23 0D ; AND accumulator with stack relative $0D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0C0D.w		; 0D 0D 0C ; Logical OR $0C0D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06010D.l		; 22 0D 01 06 ; Jump to subroutine long $06010D.l [Writes: Stack Pointer] [Flow: call]
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: NCZ]
	ora $0602.w		; 0D 02 06 ; Logical OR $0602.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $270C.w		; 0D 0C 27 ; Logical OR $270C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0601.w		; 0D 01 06 ; Logical OR $0601.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: NCZ]
	ora $0610.w		; 0D 10 06 ; Logical OR $0610.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $010C.w		; 0D 0C 01 ; Logical OR $010C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($0D.b,X)		; 01 0D ; Logical OR ($0D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora ($0D.b,X)		; 01 0D ; Logical OR ($0D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0D.b,S		; 03 0D ; OR accumulator with stack relative $0D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $2207.w		; 0D 07 22 ; Logical OR $2207.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$83.b]		; 07 83 ; OR accumulator with memory (long) [$83.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $86.b		; 00 86 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and #$0203.w		; 29 03 02 ; Logical AND #$0203.w with accumulator [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	cop $09.b		; 02 09 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $0D.b,S		; 23 0D ; AND accumulator with stack relative $0D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $01.b,S		; 23 01 ; AND accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$0D.b]		; 07 0D ; OR accumulator with memory (long) [$0D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $0201.w		; 0C 01 02 ; Test and set bits $0201.w [Reads: Accumulator] [Flags: Z]
	ora $220D.w		; 0D 0D 22 ; Logical OR $220D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpx #$F039.w		; E0 39 F0 ; Compare #$F039.w with X register [Reads: X Index] [Flags: NCZ]
	sbc $40F709.l,X		; FF 09 F7 40 ; Subtract with carry (long,X) $40F709.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFEFA1.l,X		; FF A1 EF FF ; Subtract with carry (long,X) $FFEFA1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora #$ECFF.w		; 09 FF EC ; Logical OR #$ECFF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $14		; F0 14 ; Branch if equal to $F0, $14 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	cmp [$EC.b]		; C7 EC ; Compare accumulator (long) [$EC.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ldx $FF.b		; A6 FF ; Load $FF.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	lda [$18.b]		; A7 18 ; Load accumulator (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $FADC.w,Y		; F9 DC FA ; Subtract with carry $FADC.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $1DFB.w,Y		; B9 FB 1D ; Load $1DFB.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $CC36.w,X		; 1D 36 CC ; OR accumulator with memory $CC36.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsr ($FF8B.w,X)		; FC 8B FF ; Jump to subroutine indirect indexed ($FF8B.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora #$A2EC.w		; 09 EC A2 ; Logical OR #$A2EC.w with accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	cld		; D8 ; Clear decimal flag [Flags: D]
	cpx #$2425.w		; E0 25 24 ; Compare #$2425.w with X register [Reads: X Index] [Flags: NCZ]
	sbc $15FE.w,X		; FD FE 15 ; Subtract with carry $15FE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $D600D3.l,X		; FF D3 00 D6 ; Subtract with carry (long,X) $D600D3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $F90386.l,X		; 1F 86 03 F9 ; Logical OR long $F90386.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldx $FF.b		; A6 FF ; Load $FF.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	cpx $6721.w		; EC 21 67 ; Compare $6721.w with X register [Reads: X Index] [Flags: NCZ]
	tsb $06.b		; 04 06 ; Test and set bits $06.b [Reads: Accumulator] [Flags: Z]
	and [$FD.b]		; 27 FD ; AND accumulator with memory (long) [$FD.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $B40CD8.l,X		; FF D8 0C B4 ; Subtract with carry (long,X) $B40CD8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $64.b,X		; B5 64 ; Load $64.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $3108.w		; 0D 08 31 ; Logical OR $3108.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$220A.w		; 09 0A 22 ; Logical OR #$220A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cpx $09FF.w		; EC FF 09 ; Compare $09FF.w with X register [Reads: X Index] [Flags: NCZ]
	trb $12.b		; 14 12 ; Test and reset bits $12.b [Reads: Accumulator] [Flags: Z]
	jsl $1307E5.l		; 22 E5 07 13 ; Jump to subroutine long $1307E5.l [Writes: Stack Pointer] [Flow: call]
	ora $31CC14.l		; 0F 14 CC 31 ; OR accumulator with memory (long) $31CC14.l [Writes: Accumulator] [Flags: NZ]
	ora #$150A.w		; 09 0A 15 ; Logical OR #$150A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $62, $1B, $1B		; 62 1B 1B ; Push effective relative address $62, $1B, $1B [Writes: Stack Pointer]
	ora $1716.w,X		; 1D 16 17 ; OR accumulator with memory $1716.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	lsr $CB19.w,X		; 5E 19 CB ; Logical shift right $CB19.w,X [Reads: X Index] [Flags: NCZ]
	ora ($08.b),Y		; 11 08 ; OR accumulator with memory ($08.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora #$1A33.w		; 09 33 1A ; Logical OR #$1A33.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	bit #$8922.w		; 89 22 89 ; Test bits #$8922.w with accumulator [Reads: Accumulator] [Flags: Z]
	tsb $1C.b		; 04 1C ; Test and set bits $1C.b [Reads: Accumulator] [Flags: Z]
	ldy $651D.w		; AC 1D 65 ; Load $651D.w into Y register [Writes: Y Index] [Flags: NZ]
	asl $CC1F.w,X		; 1E 1F CC ; Arithmetic shift left $CC1F.w,X [Reads: X Index] [Flags: NCZ]
	and ($09.b),Y		; 31 09 ; AND accumulator with memory ($09.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	ror $20.b		; 66 20 ; Rotate right $20.b [Reads: Direct Page] [Flags: NCZ]
	ora #$27B3.w		; 09 B3 27 ; Logical OR #$27B3.w with accumulator [Writes: Accumulator] [Flags: NZ]
	adc $11C428.l		; 6F 28 C4 11 ; Add with carry (long) $11C428.l [Writes: Accumulator] [Flags: NCVZ]
	and ($09.b),Y		; 31 09 ; AND accumulator with memory ($09.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $E4.b		; E5 E4 ; Subtract $E4.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc $29.b		; 65 29 ; Add $29.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora #$6558.w		; 09 58 65 ; Logical OR #$6558.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $31CC2F.l		; 0F 2F CC 31 ; OR accumulator with memory (long) $31CC2F.l [Writes: Accumulator] [Flags: NZ]
	ora #$5E30.w		; 09 30 5E ; Logical OR #$5E30.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $62, $31, $00		; 62 31 00 ; Push effective relative address $62, $31, $00 [Writes: Stack Pointer]
	adc $63.b		; 65 63 ; Add $63.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	bit $08.b,X		; 34 08 ; Test bits $08.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	inc $38.b,X		; F6 38 ; Increment memory $38.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	and $08CC.w,Y		; 39 CC 08 ; AND accumulator with memory $08CC.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora #$653A.w		; 09 3A 65 ; Logical OR #$653A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	.db $62, $3B, $02		; 62 3B 02 ; Push effective relative address $62, $3B, $02 [Writes: Stack Pointer]
	adc ($0F.b)		; 72 0F ; Add with carry (indirect) ($0F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp $3E65.w,Y		; D9 65 3E ; Compare accumulator $3E65.w,Y [Reads: Y Index] [Flags: NCZ]
	ora $09.b,S		; 03 09 ; OR accumulator with stack relative $09.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	mvp $72,$6F		; 44 6F 72 ; Move block positive $72,$6F [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	.db $62, $45, $10		; 62 45 10 ; Push effective relative address $62, $45, $10 [Writes: Stack Pointer]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	sbc ($E5.b,X)		; E1 E5 ; Subtract with carry ($E5.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $49.b		; E5 49 ; Subtract $49.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc $4A.b		; E5 4A ; Subtract $4A.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $82, $44, $44		; 82 44 44 ; Branch always long to $82, $44, $44 [Flow: branch]
	sta [$44.b],Y		; 97 44 ; Store accumulator (long indexed) [$44.b],Y [Reads: Direct Page, Y Index, Accumulator]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	jmp $2297.w		; 4C 97 22 ; Jump to $2297.w [Flow: jump]
	mvp $C2,$05		; 44 05 C2 ; Move block positive $C2,$05 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	eor $964E.w		; 4D 4E 96 ; Exclusive OR $964E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	eor $4B2982.l		; 4F 82 29 4B ; Exclusive OR accumulator with memory (long) $4B2982.l [Writes: Accumulator] [Flags: NZ]
	cop $4D.b		; 02 4D ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($FC.b,S),Y		; D3 FC ; Compare accumulator (stack relative indirect indexed) ($FC.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	adc $50.b,S		; 63 50 ; Add with carry (stack relative) $50.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	and $06.b,S		; 23 06 ; AND accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	mvn $06,$06		; 54 06 06 ; Move block negative $06,$06 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sbc $06.b,X		; F5 06 ; Subtract $06.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp.w [$5655]		; DC 55 56 ; Jump long indirect [$5655] [Flow: jump]
	adc ($06.b),Y		; 71 06 ; Add with carry ($06.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $FF.b		; 06 FF ; Arithmetic shift left $FF.b [Reads: Direct Page] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $0A0D.w		; 0D 0D 0A ; Logical OR $0A0D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($0D.b,X)		; 01 0D ; Logical OR ($0D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $84.b		; 04 84 ; Test and set bits $84.b [Reads: Accumulator] [Flags: Z]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $0D.b		; 24 0D ; Test bits $0D.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0B.b,S		; 03 0B ; OR accumulator with stack relative $0B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0B0A.w		; 0D 0A 0B ; Logical OR $0B0A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $04.b		; 06 04 ; Arithmetic shift left $04.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $0A.b,S		; 03 0A ; OR accumulator with stack relative $0A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $2801.w		; 0D 01 28 ; Logical OR $2801.w with accumulator [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	rol $0D01.w		; 2E 01 0D ; Rotate left $0D01.w [Flags: NCZ]
	ora [$25.b]		; 07 25 ; OR accumulator with memory (long) [$25.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0083.w		; 0D 83 00 ; Logical OR $0083.w with accumulator [Writes: Accumulator] [Flags: NZ]
	bit $0D22.w,X		; 3C 22 0D ; Test bits $0D22.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $050D.w		; 0D 0D 05 ; Logical OR $050D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $0D.b,S		; 23 0D ; AND accumulator with stack relative $0D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	and $0D03.w		; 2D 03 0D ; Logical AND $0D03.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0003.w		; 0D 03 00 ; Logical OR $0003.w with accumulator [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	ora $0805.w		; 0D 05 08 ; Logical OR $0805.w with accumulator [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $0D0D.w		; 0C 0D 0D ; Test and set bits $0D0D.w [Reads: Accumulator] [Flags: Z]
	ora $23.b,S		; 03 23 ; OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0900.w		; 0D 00 09 ; Logical OR $0900.w with accumulator [Writes: Accumulator] [Flags: NZ]
	bit $0D.b		; 24 0D ; Test bits $0D.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	asl $0405.w		; 0E 05 04 ; Arithmetic shift left $0405.w [Flags: NCZ]
	ora $070D.w		; 0D 0D 07 ; Logical OR $070D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $2509.w		; 0D 09 25 ; Logical OR $2509.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0803.w		; 0D 03 08 ; Logical OR $0803.w with accumulator [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $0D.b		; 25 0D ; Logical AND $0D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $0D.b		; 26 0D ; Rotate left $0D.b [Reads: Direct Page] [Flags: NCZ]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $02.b		; 25 02 ; Logical AND $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $0D.b,S		; 23 0D ; AND accumulator with stack relative $0D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	adc ($25.b)		; 72 25 ; Add with carry (indirect) ($25.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $0B.b,S		; 03 0B ; OR accumulator with stack relative $0B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $0D.b,S		; 23 0D ; AND accumulator with stack relative $0D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $0C0D.w		; 0D 0D 0C ; Logical OR $0C0D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $0D.b		; 24 0D ; Test bits $0D.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora ($0D.b,X)		; 01 0D ; Logical OR ($0D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $070D.w		; 0D 0D 07 ; Logical OR $070D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $25.b,S		; 03 25 ; OR accumulator with stack relative $25.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $240D.w		; 0D 0D 24 ; Logical OR $240D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$24.b]		; 07 24 ; OR accumulator with memory (long) [$24.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($0B.b,X)		; 01 0B ; Logical OR ($0B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $2401.w		; 0D 01 24 ; Logical OR $2401.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0324.w		; 0D 24 03 ; Logical OR $0324.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $58570A.l,X		; FF 0A 57 58 ; Subtract with carry (long,X) $58570A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($E3.b,X)		; 41 E3 ; Exclusive OR accumulator with memory ($E3.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor $DBDA.w,Y		; 59 DA DB ; Exclusive OR accumulator with memory $DBDA.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr $DA.b		; 46 DA ; Logical shift right $DA.b [Reads: Direct Page] [Flags: NCZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	lsr $84.b		; 46 84 ; Logical shift right $84.b [Reads: Direct Page] [Flags: NCZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($5A.b,X)		; 01 5A ; Logical OR ($5A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor [$62.b],Y		; 57 62 ; Exclusive OR accumulator with memory (long indexed) [$62.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	ora $A1.b		; 05 A1 ; Logical OR $A1.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jmp $A14E.w		; 4C 4E A1 ; Jump to $A14E.w [Flow: jump]
	jmp $844E.w		; 4C 4E 84 ; Jump to $844E.w [Flow: jump]
	brk $15.b		; 00 15 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$5E55.w		; 09 55 5E ; Logical OR #$5E55.w with accumulator [Writes: Accumulator] [Flags: NZ]
	eor ($60.b,X)		; 41 60 ; Exclusive OR accumulator with memory ($60.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $53A7.w,X		; 3D A7 53 ; AND accumulator with memory $53A7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $53A7.w,X		; 3D A7 53 ; AND accumulator with memory $53A7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	bit $0F.b		; 24 0F ; Test bits $0F.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	adc $11.b,S		; 63 11 ; Add with carry (stack relative) $11.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	sbc $A4.b,S		; E3 A4 ; Subtract stack-relative $A4.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	lda $A4AE.w		; AD AE A4 ; Load $A4AE.w into accumulator [Writes: Accumulator] [Flags: NZ]
	lda $A4AE.w		; AD AE A4 ; Load $A4AE.w into accumulator [Writes: Accumulator] [Flags: NZ]
	lda $59AE.w		; AD AE 59 ; Load $59AE.w into accumulator [Writes: Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	.db $30, $01		; 30 01 ; Branch if minus to $30, $01 [Flow: branch]
	eor $60630D.l,X		; 5F 0D 63 60 ; Exclusive OR accumulator with memory (long,X) $60630D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $6263.w		; 0E 63 62 ; Arithmetic shift left $6263.w [Flags: NCZ]
	cmp ($5D.b),Y		; D1 5D ; Compare accumulator ($5D.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	lda ($4C.b,X)		; A1 4C ; Load accumulator ($4C.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	stz $65.b		; 64 65 ; Store zero to $65.b
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	sbc $1F.b,S		; E3 1F ; Subtract stack-relative $1F.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	sta $6766.w,Y		; 99 66 67 ; Store accumulator to $6766.w,Y [Reads: Y Index, Accumulator]
	ora ($63.b),Y		; 11 63 ; OR accumulator with memory ($63.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	ora [$3D.b]		; 07 3D ; OR accumulator with memory (long) [$3D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda [$53.b]		; A7 53 ; Load accumulator (long) [$53.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	stz $6D6C.w		; 9C 6C 6D ; Store zero to $6D6C.w
	sta $1F.b,X		; 95 1F ; Store accumulator to $1F.b,X [Reads: Accumulator, X Index]
	adc [$6E.b]		; 67 6E ; Add with carry (long) [$6E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	eor $DBDA.w,Y		; 59 DA DB ; Exclusive OR accumulator with memory $DBDA.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ror $77.b,X		; 76 77 ; Rotate right $77.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sta $7978.w,X		; 9D 78 79 ; Store accumulator to $7978.w,X [Reads: Accumulator, X Index]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	adc [$64.b],Y		; 77 64 ; Add with carry (long indexed) [$64.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$4C4B.w		; 09 4B 4C ; Logical OR #$4C4B.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $80, $77		; 80 77 ; Branch always to $80, $77 [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($82.b,X)		; 81 82 ; Store accumulator ($82.b,X) [Reads: Direct Page, Accumulator, X Index]
	ora $7783.w		; 0D 83 77 ; Logical OR $7783.w with accumulator [Writes: Accumulator] [Flags: NZ]
	adc $84.b		; 65 84 ; Add $84.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $52.b		; 05 52 ; Logical OR $52.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor ($9C.b,S),Y		; 53 9C ; XOR accumulator (stack relative indirect indexed) ($9C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	jsl $8D018C.l		; 22 8C 01 8D ; Jump to subroutine long $8D018C.l [Writes: Stack Pointer] [Flow: call]
	ora $8E66.w,X		; 1D 66 8E ; OR accumulator with memory $8E66.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cop $BB.b		; 02 BB ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	sta $25.b		; 85 25 ; Store accumulator to $25.b [Reads: Accumulator]
	adc ($01.b,X)		; 61 01 ; Add with carry ($01.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp.w [$628E]		; DC 8E 62 ; Jump long indirect [$628E] [Flow: jump]
	sta $04.b,X		; 95 04 ; Store accumulator to $04.b,X [Reads: Accumulator, X Index]
	clc		; 18 ; Clear carry flag [Flags: C]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	jmp $259A99.l		; 5C 99 9A 25 ; Jump long to $259A99.l [Flow: jump]
	jsl $DCB101.l		; 22 01 B1 DC ; Jump to subroutine long $DCB101.l [Writes: Stack Pointer] [Flow: call]
	adc $9B.b,S		; 63 9B ; Add with carry (stack relative) $9B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ror $9F.b		; 66 9F ; Rotate right $9F.b [Reads: Direct Page] [Flags: NCZ]
	ldy #$60E6.w		; A0 E6 60 ; Load #$60E6.w into Y register [Writes: Y Index] [Flags: NZ]
	and $1E.b,X		; 35 1E ; Logical AND $1E.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $1D6A.w,Y		; D9 6A 1D ; Compare accumulator $1D6A.w,Y [Reads: Y Index] [Flags: NCZ]
	lsr $B1.b,X		; 56 B1 ; Logical shift right $B1.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	stz $A1.b		; 64 A1 ; Store zero to $A1.b
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	asl $A6.b		; 06 A6 ; Arithmetic shift left $A6.b [Reads: Direct Page] [Flags: NCZ]
	cmp ($C6.b)		; D2 C6 ; Compare accumulator (indirect) ($C6.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	lda [$A8.b]		; A7 A8 ; Load accumulator (long) [$A8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta [$44.b],Y		; 97 44 ; Store accumulator (long indexed) [$44.b],Y [Reads: Direct Page, Y Index, Accumulator]
	mvp $56,$C2		; 44 C2 56 ; Move block positive $56,$C2 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	and $E5.b,S		; 23 E5 ; AND accumulator with stack relative $E5.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $A6.b		; 06 A6 ; Arithmetic shift left $A6.b [Reads: Direct Page] [Flags: NCZ]
	lda #$4B24.w		; A9 24 4B ; Load #$4B24.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($4D.b,X)		; 01 4D ; Logical OR ($4D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	dec $24.b		; C6 24 ; Decrement $24.b [Reads: Direct Page] [Flags: NZ]
	mvp $06,$02		; 44 02 06 ; Move block positive $06,$02 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	eor ($06.b,S),Y		; 53 06 ; XOR accumulator (stack relative indirect indexed) ($06.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $06.b,S		; 43 06 ; Exclusive OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ora $AB.b,S		; 03 AB ; OR accumulator with stack relative $AB.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor ($A6.b,S),Y		; 53 A6 ; XOR accumulator (stack relative indirect indexed) ($A6.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda #$4B24.w		; A9 24 4B ; Load #$4B24.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $080406.l,X		; FF 06 04 08 ; Subtract with carry (long,X) $080406.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $23.b		; 04 23 ; Test and set bits $23.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsl $08020D.l		; 22 0D 02 08 ; Jump to subroutine long $08020D.l [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	eor $08.b,S		; 43 08 ; Exclusive OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $0802.w		; 0D 02 08 ; Logical OR $0802.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	and $0D.b,S		; 23 0D ; AND accumulator with stack relative $0D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	ora ($0D.b,X)		; 01 0D ; Logical OR ($0D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $06.b		; 04 06 ; Test and set bits $06.b [Reads: Accumulator] [Flags: Z]
	bit $0D.b		; 24 0D ; Test bits $0D.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $0D.b,S		; 23 0D ; AND accumulator with stack relative $0D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $02.b,S		; 23 02 ; AND accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $0D.b		; 24 0D ; Test bits $0D.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0201.w		; 0D 01 02 ; Logical OR $0201.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0809.w		; 0D 09 08 ; Logical OR $0809.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0202.w		; 0D 02 02 ; Logical OR $0202.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0104.w		; 0D 04 01 ; Logical OR $0104.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $23.b		; 04 23 ; Test and set bits $23.b [Reads: Accumulator] [Flags: Z]
	cop $23.b		; 02 23 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0106.w		; 0D 06 01 ; Logical OR $0106.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($0D.b,X)		; 01 0D ; Logical OR ($0D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$0D.b]		; 27 0D ; AND accumulator with memory (long) [$0D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$040C.w		; 09 0C 04 ; Logical OR #$040C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $05.b		; 06 05 ; Arithmetic shift left $05.b [Reads: Direct Page] [Flags: NCZ]
	ora $0709.w		; 0D 09 07 ; Logical OR $0709.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $23.b		; 06 23 ; Arithmetic shift left $23.b [Reads: Direct Page] [Flags: NCZ]
	ora $080B.w		; 0D 0B 08 ; Logical OR $080B.w with accumulator [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $02.b		; 05 02 ; Logical OR $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0D.b,S		; 03 0D ; OR accumulator with stack relative $0D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $0D0208.l		; 22 08 02 0D ; Jump to subroutine long $0D0208.l [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $0D.b,S		; 23 0D ; AND accumulator with stack relative $0D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	eor #$0822.w		; 49 22 08 ; Exclusive OR #$0822.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($0D.b,X)		; 01 0D ; Logical OR ($0D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	eor $08.b,S		; 43 08 ; Exclusive OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0D03.w		; 0D 03 0D ; Logical OR $0D03.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $25.b		; 05 25 ; Logical OR $25.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0403.w		; 0D 03 04 ; Logical OR $0403.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsl $05050D.l		; 22 0D 05 05 ; Jump to subroutine long $05050D.l [Writes: Stack Pointer] [Flow: call]
	ora $0305.w		; 0D 05 03 ; Logical OR $0305.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $040201.l		; 22 01 02 04 ; Jump to subroutine long $040201.l [Writes: Stack Pointer] [Flow: call]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $02030D.l		; 22 0D 03 02 ; Jump to subroutine long $02030D.l [Writes: Stack Pointer] [Flow: call]
	cop $0D.b		; 02 0D ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $22.b		; 05 22 ; Logical OR $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $06.b,S		; 23 06 ; AND accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $01.b,S		; 23 01 ; AND accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $8301.w		; 0D 01 83 ; Logical OR $8301.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $87.b		; 00 87 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $03.b		; 25 03 ; Logical AND $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $0303.w		; 0C 03 03 ; Test and set bits $0303.w [Reads: Accumulator] [Flags: Z]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $03.b		; 25 03 ; Logical AND $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $06010D.l		; 22 0D 01 06 ; Jump to subroutine long $06010D.l [Writes: Stack Pointer] [Flow: call]
	asl $24.b		; 06 24 ; Arithmetic shift left $24.b [Reads: Direct Page] [Flags: NCZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $DA46.w,Y		; 19 46 DA ; OR accumulator with memory $DA46.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	lsr $DA.b		; 46 DA ; Logical shift right $DA.b [Reads: Direct Page] [Flags: NCZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	lsr $DA.b		; 46 DA ; Logical shift right $DA.b [Reads: Direct Page] [Flags: NCZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	ldy $ACA5.w		; AC A5 AC ; Load $ACA5.w into Y register [Writes: Y Index] [Flags: NZ]
	lda $DA59.w		; AD 59 DA ; Load $DA59.w into accumulator [Writes: Accumulator] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	lsr $49C3.w		; 4E C3 49 ; Logical shift right $49C3.w [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr $4A49.w		; 4E 49 4A ; Logical shift right $4A49.w [Flags: NCZ]
	lsr $6849.w		; 4E 49 68 ; Logical shift right $6849.w [Flags: NCZ]
	stz $AE.b		; 64 AE ; Store zero to $AE.b
	cop $49.b		; 02 49 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $63C6.w,X		; 3D C6 63 ; AND accumulator with memory $63C6.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda ($04.b,S),Y		; B3 04 ; Load accumulator (stack relative indirect indexed) ($04.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor ($58.b),Y		; 51 58 ; Exclusive OR accumulator with memory ($58.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda [$29.b],Y		; B7 29 ; Load accumulator (long indexed) [$29.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	stz $B8.b		; 64 B8 ; Store zero to $B8.b
	ora ($AC.b,X)		; 01 AC ; Logical OR ($AC.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda $63.b		; A5 63 ; Load $63.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $B901.w,X		; BD 01 B9 ; Load $B901.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $C16461.l		; 22 61 64 C1 ; Jump to subroutine long $C16461.l [Writes: Stack Pointer] [Flow: call]
	ora ($68.b,X)		; 01 68 ; Logical OR ($68.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta $C663.w,Y		; 99 63 C6 ; Store accumulator to $C663.w,Y [Reads: Y Index, Accumulator]
	ora ($79.b,X)		; 01 79 ; Logical OR ($79.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $CAA80D.l		; 22 0D A8 CA ; Jump to subroutine long $CAA80D.l [Writes: Stack Pointer] [Flow: call]
	wai		; CB ; Wait for interrupt
	lda ($49.b)		; B2 49 ; Load accumulator (indirect) ($49.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpy $6161.w		; CC 61 61 ; Compare $6161.w with Y register [Reads: Y Index] [Flags: NCZ]
	cmp $E5C9.w		; CD C9 E5 ; Compare $E5C9.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $23.b		; 85 23 ; Store accumulator to $23.b [Reads: Accumulator]
	adc ($0C.b,X)		; 61 0C ; Add with carry ($0C.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $BCBB.w		; CE BB BC ; Decrement $BCBB.w [Flags: NZ]
	cmp $D02222.l		; CF 22 22 D0 ; Compare accumulator (long) $D02222.l [Reads: Accumulator] [Flags: NCZ]
	tsb $1D.b		; 04 1D ; Test and set bits $1D.b [Reads: Accumulator] [Flags: Z]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc $9A.b,X		; F5 9A ; Subtract $9A.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp ($22.b),Y		; D1 22 ; Compare accumulator ($22.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cmp ($0C.b)		; D2 0C ; Compare accumulator (indirect) ($0C.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp ($C4.b,S),Y		; D3 C4 ; Compare accumulator (stack relative indirect indexed) ($C4.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	cmp $0B.b		; C5 0B ; Compare $0B.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	and ($B7.b,S),Y		; 33 B7 ; AND accumulator (stack relative indirect indexed) ($B7.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lsr $D4.b,X		; 56 D4 ; Logical shift right $D4.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $F0, $ED		; F0 ED ; Branch if equal to $F0, $ED [Flow: branch]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	ldy $6380.w		; AC 80 63 ; Load $6380.w into Y register [Writes: Y Index] [Flags: NZ]
	cmp $0B.b,X		; D5 0B ; Compare accumulator $0B.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	jmp $3E3D.w		; 4C 3D 3E ; Jump to $3E3D.w [Flow: jump]
	cpy $5A6A.w		; CC 6A 5A ; Compare $5A6A.w with Y register [Reads: Y Index] [Flags: NCZ]
	adc ($61.b,X)		; 61 61 ; Add with carry ($61.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy $A8.b,X		; B4 A8 ; Load Y register $A8.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	cmp $1762.w,Y		; D9 62 17 ; Compare accumulator $1762.w,Y [Reads: Y Index] [Flags: NCZ]
	tsb $52DA.w		; 0C DA 52 ; Test and set bits $52DA.w [Reads: Accumulator] [Flags: Z]
	eor ($DB.b,S),Y		; 53 DB ; XOR accumulator (stack relative indirect indexed) ($DB.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta ($DC.b,S),Y		; 93 DC ; Store accumulator (stack relative indirect indexed) ($DC.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	cmp $2256.w,X		; DD 56 22 ; Compare accumulator $2256.w,X [Reads: X Index] [Flags: NCZ]
	jsl $DFDEA8.l		; 22 A8 DE DF ; Jump to subroutine long $DFDEA8.l [Writes: Stack Pointer] [Flow: call]
	.db $62, $23, $09		; 62 23 09 ; Push effective relative address $62, $23, $09 [Writes: Stack Pointer]
	cpx #$5655.w		; E0 55 56 ; Compare #$5655.w with X register [Reads: X Index] [Flags: NCZ]
	sbc ($18.b,X)		; E1 18 ; Subtract with carry ($18.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
.ACCU 8
	sep #$E3		; E2 E3
	stz $6A.b,X		; 74 6A ; Store zero to $6A.b,X [Reads: X Index]
	eor $03E465.l,X		; 5F 65 E4 03 ; Exclusive OR accumulator with memory (long,X) $03E465.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldx $676A.w,Y		; BE 6A 67 ; Load X register $676A.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ror $62.b		; 66 62 ; Rotate right $62.b [Reads: Direct Page] [Flags: NCZ]
	nop		; EA ; No operation
	ora [$10.b],Y		; 17 10 ; OR accumulator with memory (long indexed) [$10.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $B261.w		; ED 61 B2 ; Subtract $B261.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	lda ($86.b,S),Y		; B3 86 ; Load accumulator (stack relative indirect indexed) ($86.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $F9.b		; E5 F9 ; Subtract $F9.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $C0.b		; E5 C0 ; Subtract $C0.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	asl $A5DF.w,X		; 1E DF A5 ; Arithmetic shift left $A5DF.w,X [Reads: X Index] [Flags: NCZ]
	lda $A4.b,S		; A3 A4 ; Load accumulator (stack relative) $A4.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	inc $BA63.w		; EE 63 BA ; Increment $BA63.w [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	ora $23EC.w,X		; 1D EC 23 ; OR accumulator with memory $23EC.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldy #$E523.w		; A0 23 E5 ; Load #$E523.w into Y register [Writes: Y Index] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	cop $EF.b		; 02 EF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($44.b,X)		; 41 44 ; Exclusive OR accumulator with memory ($44.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	mvp $A9,$F0		; 44 F0 A9 ; Move block positive $A9,$F0 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ldx $B7.b,Y		; B6 B7 ; Load X register $B7.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	and $25B7B6.l,X		; 3F B6 B7 25 ; AND accumulator with memory (long,X) $25B7B6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	mvp $48,$04		; 44 04 48 ; Move block positive $48,$04 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	.db $F0, $8C		; F0 8C ; Branch if equal to $F0, $8C [Flow: branch]
	sta $62EE.w		; 8D EE 62 ; Store accumulator to $62EE.w [Reads: Accumulator]
	ora #$01.b		; 09 01 ; Logical OR #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$0A.b		; 09 0A ; Logical OR #$0A.b with accumulator [Writes: Accumulator] [Flags: NZ]
	and $4B.b		; 25 4B ; Logical AND $4B.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $62, $F1, $03		; 62 F1 03 ; Push effective relative address $62, $F1, $03 [Writes: Stack Pointer]
	eor $0749.w		; 4D 49 07 ; Exclusive OR $0749.w with accumulator [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $62, $06, $FF		; 62 06 FF ; Push effective relative address $62, $06, $FF [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0106.w		; 0D 06 01 ; Logical OR $0106.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0901.w		; 0D 01 09 ; Logical OR $0901.w with accumulator [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora #$01.b		; 09 01 ; Logical OR #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $010D.w		; 0D 0D 01 ; Logical OR $010D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$01.b		; 09 01 ; Logical OR #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	ora $060C.w		; 0D 0C 06 ; Logical OR $060C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($0B.b,X)		; 01 0B ; Logical OR ($0B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $02.b,S		; 23 02 ; AND accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $0D.b		; 04 0D ; Test and set bits $0D.b [Reads: Accumulator] [Flags: Z]
	tsb $0D.b		; 04 0D ; Test and set bits $0D.b [Reads: Accumulator] [Flags: Z]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $0D.b,S		; 23 0D ; AND accumulator with stack relative $0D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($0D.b,X)		; 01 0D ; Logical OR ($0D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: NCZ]
	asl $0304.w		; 0E 04 03 ; Arithmetic shift left $0304.w [Flags: NCZ]
	ora $0E.b,S		; 03 0E ; OR accumulator with stack relative $0E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $02030E.l		; 22 0E 03 02 ; Jump to subroutine long $02030E.l [Writes: Stack Pointer] [Flow: call]
	asl $060E.w		; 0E 0E 06 ; Arithmetic shift left $060E.w [Flags: NCZ]
	and $0E.b,S		; 23 0E ; AND accumulator with stack relative $0E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $070E.w		; 0E 0E 07 ; Arithmetic shift left $070E.w [Flags: NCZ]
	and $0E.b,S		; 23 0E ; AND accumulator with stack relative $0E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	asl $020E.w		; 0E 0E 02 ; Arithmetic shift left $020E.w [Flags: NCZ]
	cop $23.b		; 02 23 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $020B.w		; 0E 0B 02 ; Arithmetic shift left $020B.w [Flags: NCZ]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $0E.b		; 06 0E ; Arithmetic shift left $0E.b [Reads: Direct Page] [Flags: NCZ]
	asl $0600.w		; 0E 00 06 ; Arithmetic shift left $0600.w [Flags: NCZ]
	and $0E.b,S		; 23 0E ; AND accumulator with stack relative $0E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $05.b		; 06 05 ; Arithmetic shift left $05.b [Reads: Direct Page] [Flags: NCZ]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $23.b,S		; 03 23 ; OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $0324.w		; 0E 24 03 ; Arithmetic shift left $0324.w [Flags: NCZ]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $08.b		; 05 08 ; Logical OR $08.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $2C.b		; 06 2C ; Arithmetic shift left $2C.b [Reads: Direct Page] [Flags: NCZ]
	asl $0501.w		; 0E 01 05 ; Arithmetic shift left $0501.w [Flags: NCZ]
	tsb $0722.w		; 0C 22 07 ; Test and set bits $0722.w [Reads: Accumulator] [Flags: Z]
	and $0E.b		; 25 0E ; Logical AND $0E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	asl $0707.w		; 0E 07 07 ; Arithmetic shift left $0707.w [Flags: NCZ]
	ora #$07.b		; 09 07 ; Logical OR #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $43.b		; 05 43 ; Logical OR $43.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $08.b		; 05 08 ; Logical OR $08.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $0E.b,S		; 23 0E ; AND accumulator with stack relative $0E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	asl $050E.w		; 0E 0E 05 ; Arithmetic shift left $050E.w [Flags: NCZ]
	ora $26.b		; 05 26 ; Logical OR $26.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$25.b]		; 07 25 ; OR accumulator with memory (long) [$25.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $0502.w		; 0E 02 05 ; Arithmetic shift left $0502.w [Flags: NCZ]
	asl $260E.w		; 0E 0E 26 ; Arithmetic shift left $260E.w [Flags: NCZ]
	ora $24.b		; 05 24 ; Logical OR $24.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $0703.w		; 0E 03 07 ; Arithmetic shift left $0703.w [Flags: NCZ]
	ora #$05.b		; 09 05 ; Logical OR #$05.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$23.b		; 09 23 ; Logical OR #$23.b with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $0F.b		; 06 0F ; Arithmetic shift left $0F.b [Reads: Direct Page] [Flags: NCZ]
	asl $0E0A.w		; 0E 0A 0E ; Arithmetic shift left $0E0A.w [Flags: NCZ]
	asl $02.b		; 06 02 ; Arithmetic shift left $02.b [Reads: Direct Page] [Flags: NCZ]
	asl $0206.w		; 0E 06 02 ; Arithmetic shift left $0206.w [Flags: NCZ]
	ora [$0B.b]		; 07 0B ; OR accumulator with memory (long) [$0B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $2203.w		; 0E 03 22 ; Arithmetic shift left $2203.w [Flags: NCZ]
	asl $0600.w		; 0E 00 06 ; Arithmetic shift left $0600.w [Flags: NCZ]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $0108.w		; 0E 08 01 ; Arithmetic shift left $0108.w [Flags: NCZ]
	asl $0003.w		; 0E 03 00 ; Arithmetic shift left $0003.w [Flags: NCZ]
	asl $000E.w		; 0E 0E 00 ; Arithmetic shift left $000E.w [Flags: NCZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $0E0901.l		; 22 01 09 0E ; Jump to subroutine long $0E0901.l [Writes: Stack Pointer] [Flow: call]
	ora $0E.b,S		; 03 0E ; OR accumulator with stack relative $0E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0B01.w		; 0D 01 0B ; Logical OR $0B01.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $012200.l		; 22 00 22 01 ; Jump to subroutine long $012200.l [Writes: Stack Pointer] [Flow: call]
	cop $0E.b		; 02 0E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	asl $E0FF.w		; 0E FF E0 ; Arithmetic shift left $E0FF.w [Flags: NCZ]
	and ($52.b,X)		; 21 52 ; Logical AND ($52.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta ($FB.b,S),Y		; 93 FB ; Store accumulator (stack relative indirect indexed) ($FB.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	ora $A6F4.w,X		; 1D F4 A6 ; OR accumulator with memory $A6F4.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $F5.b		; 06 F5 ; Arithmetic shift left $F5.b [Reads: Direct Page] [Flags: NCZ]
	asl $DD.b		; 06 DD ; Arithmetic shift left $DD.b [Reads: Direct Page] [Flags: NCZ]
	eor ($DD.b,S),Y		; 53 DD ; XOR accumulator (stack relative indirect indexed) ($DD.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $F6.b		; 06 F6 ; Arithmetic shift left $F6.b [Reads: Direct Page] [Flags: NCZ]
	sbc [$FC.b],Y		; F7 FC ; Subtract with carry (long indexed) [$FC.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $93.b,S		; E3 93 ; Subtract stack-relative $93.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lda #$F8.b		; A9 F8 ; Load #$F8.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $A6.b,X		; F5 A6 ; Subtract $A6.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $53.b		; 06 53 ; Arithmetic shift left $53.b [Reads: Direct Page] [Flags: NCZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	eor $5A59.w,Y		; 59 59 5A ; Exclusive OR accumulator with memory $5A59.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $FA92.w,Y		; F9 92 FA ; Subtract with carry $FA92.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($93.b)		; 52 93 ; Exclusive OR accumulator with memory (indirect) ($93.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $FB.b,S		; 63 FB ; Add with carry (stack relative) $FB.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $A6.b,S		; 03 A6 ; OR accumulator with stack relative $A6.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $FF.b		; 06 FF ; Arithmetic shift left $FF.b [Reads: Direct Page] [Flags: NCZ]
	sta ($62.b)		; 92 62 ; Store accumulator (indirect) ($62.b) [Reads: Direct Page, Accumulator]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $57.b,X		; 56 57 ; Logical shift right $57.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $52.b,S		; 03 52 ; OR accumulator with stack relative $52.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta ($62.b,S),Y		; 93 62 ; Store accumulator (stack relative indirect indexed) ($62.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	lsr $0807.w,X		; 5E 07 08 ; Logical shift right $0807.w,X [Reads: X Index] [Flags: NCZ]
	ldx $63.b		; A6 63 ; Load $63.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	ora #$03.b		; 09 03 ; Logical OR #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	lda ($0D.b,X)		; A1 0D ; Load accumulator ($0D.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	asl $6352.w		; 0E 52 63 ; Arithmetic shift left $6352.w [Flags: NCZ]
	ora $131E04.l		; 0F 04 1E 13 ; OR accumulator with memory (long) $131E04.l [Writes: Accumulator] [Flags: NZ]
	trb $5B.b		; 14 5B ; Test and reset bits $5B.b [Reads: Accumulator] [Flags: Z]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	.db $62, $15, $0D		; 62 15 0D ; Push effective relative address $62, $15, $0D [Writes: Stack Pointer]
	ora $5B.b,X		; 15 5B ; OR accumulator with memory $5B.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cmp $6AA0.w,Y		; D9 A0 6A ; Compare accumulator $6AA0.w,Y [Reads: Y Index] [Flags: NCZ]
	stz $18.b,X		; 74 18 ; Store zero to $18.b,X [Reads: X Index]
	ora $6AB2.w,Y		; 19 B2 6A ; OR accumulator with memory $6AB2.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $62, $18, $05		; 62 18 05 ; Push effective relative address $62, $18, $05 [Writes: Stack Pointer]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc $18.b		; E5 18 ; Subtract $18.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cmp $C222.w,Y		; D9 22 C2 ; Compare accumulator $C222.w,Y [Reads: Y Index] [Flags: NCZ]
	adc $1B.b,S		; 63 1B ; Add with carry (stack relative) $1B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	bit $C2.b		; 24 C2 ; Test bits $C2.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora $E4.b,S		; 03 E4 ; OR accumulator with stack relative $E4.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $BD.b		; E5 BD ; Subtract $BD.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	jsl $20631F.l		; 22 1F 63 20 ; Jump to subroutine long $20631F.l [Writes: Stack Pointer] [Flow: call]
	bit $1F.b		; 24 1F ; Test bits $1F.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora ($24.b)		; 12 24 ; OR accumulator with memory (indirect) ($24.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $54.b		; E5 54 ; Subtract $54.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	and $26.b		; 25 26 ; Logical AND $26.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($22.b,X)		; 21 22 ; Logical AND ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and [$28.b]		; 27 28 ; AND accumulator with memory (long) [$28.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $80, $29		; 80 29 ; Branch always to $80, $29 [Flow: branch]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	rol $E524.w,X		; 3E 24 E5 ; Rotate left $E524.w,X [Reads: X Index] [Flags: NCZ]
	eor $E5.b,S		; 43 E5 ; Exclusive OR accumulator with stack relative $E5.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda ($08.b)		; B2 08 ; Load accumulator (indirect) ($08.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $21.b		; 26 21 ; Rotate left $21.b [Reads: Direct Page] [Flags: NCZ]
	jsl $2B242A.l		; 22 2A 24 2B ; Jump to subroutine long $2B242A.l [Writes: Stack Pointer] [Flow: call]
	bit $E5AE.w		; 2C AE E5 ; Test bits $E5AE.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	rol $8B.b		; 26 8B ; Rotate left $8B.b [Reads: Direct Page] [Flags: NCZ]
	cop $2D.b		; 02 2D ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($22.b,X)		; 21 22 ; Logical AND ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $62, $2E, $02		; 62 2E 02 ; Push effective relative address $62, $2E, $02 [Writes: Stack Pointer]
	cmp $3231.w		; CD 31 32 ; Compare $3231.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	rol $71.b		; 26 71 ; Rotate left $71.b [Reads: Direct Page] [Flags: NCZ]
	stz $33.b		; 64 33 ; Store zero to $33.b
	ora $41.b,S		; 03 41 ; OR accumulator with stack relative $41.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	sbc $A5.b		; E5 A5 ; Subtract $A5.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and $A0.b,S		; 23 A0 ; AND accumulator with stack relative $A0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $390E38.l		; 0F 38 0E 39 ; OR accumulator with memory (long) $390E38.l [Writes: Accumulator] [Flags: NZ]
	stx $59.b,Y		; 96 59 ; Store X register $59.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $30, $40		; 30 40 ; Branch if minus to $30, $40 [Flow: branch]
	stz $8B8B.w		; 9C 8B 8B ; Store zero to $8B8B.w
	jmp $3B4C.w		; 4C 4C 3B ; Jump to $3B4C.w [Flow: jump]
	stx $62.b		; 86 62 ; Store X register to $62.b [Reads: X Index]
	bit $4204.w,X		; 3C 04 42 ; Test bits $4204.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	asl $41FB.w,X		; 1E FB 41 ; Arithmetic shift left $41FB.w,X [Reads: X Index] [Flags: NCZ]
	stz $3F.b		; 64 3F ; Store zero to $3F.b
	asl $44EB.w,X		; 1E EB 44 ; Arithmetic shift left $44EB.w,X [Reads: X Index] [Flags: NCZ]
	sta $3C1D.w		; 8D 1D 3C ; Store accumulator to $3C1D.w [Reads: Accumulator]
	eor $1D.b		; 45 1D ; Exclusive OR $1D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	dec $4841.w,X		; DE 41 48 ; Decrement memory $4841.w,X [Reads: X Index] [Flags: NZ]
	eor #$43.b		; 49 43 ; Exclusive OR #$43.b with accumulator [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr $FF.b		; 46 FF ; Logical shift right $FF.b [Reads: Direct Page] [Flags: NCZ]
	asl $5F.b		; 06 5F ; Arithmetic shift left $5F.b [Reads: Direct Page] [Flags: NCZ]
	sbc $1D.b,S		; E3 1D ; Subtract stack-relative $1D.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	lda #$47.b		; A9 47 ; Load #$47.b into accumulator [Writes: Accumulator] [Flags: NZ]
	trb $1D1D.w		; 1C 1D 1D ; Test and reset bits $1D1D.w [Reads: Accumulator] [Flags: Z]
	eor ($53.b)		; 52 53 ; Exclusive OR accumulator with memory (indirect) ($53.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	eor [$5E.b]		; 47 5E ; Exclusive OR accumulator with memory (long) [$5E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	sbc $020E26.l,X		; FF 26 0E 02 ; Subtract with carry (long,X) $020E26.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $0122.w		; 0E 22 01 ; Arithmetic shift left $0122.w [Flags: NCZ]
	bit $0E.b		; 24 0E ; Test bits $0E.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $030101.l		; 22 01 01 03 ; Jump to subroutine long $030101.l [Writes: Stack Pointer] [Flow: call]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $0084.w		; 0E 84 00 ; Arithmetic shift left $0084.w [Flags: NCZ]
	ora [$02.b]		; 07 02 ; OR accumulator with memory (long) [$02.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $0E03.w		; 0E 03 0E ; Arithmetic shift left $0E03.w [Flags: NCZ]
	jsl $0E4501.l		; 22 01 45 0E ; Jump to subroutine long $0E4501.l [Writes: Stack Pointer] [Flow: call]
	ora ($29.b,X)		; 01 29 ; Logical OR ($29.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $0601.w		; 0E 01 06 ; Arithmetic shift left $0601.w [Flags: NCZ]
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: NCZ]
	asl $0600.w		; 0E 00 06 ; Arithmetic shift left $0600.w [Flags: NCZ]
	and ($0E.b,S),Y		; 33 0E ; AND accumulator (stack relative indirect indexed) ($0E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $000E.w		; 2E 0E 00 ; Rotate left $000E.w [Flags: NCZ]
	cop $2E.b		; 02 2E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0200.w		; 0E 00 02 ; Arithmetic shift left $0200.w [Flags: NCZ]
	bit $0E.b		; 24 0E ; Test bits $0E.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora [$0A.b]		; 07 0A ; OR accumulator with memory (long) [$0A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($0E.b,X)		; 01 0E ; Logical OR ($0E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $0A.b		; 02 0A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl $0E01.w		; 0E 01 0E ; Arithmetic shift left $0E01.w [Flags: NCZ]
	cop $23.b		; 02 23 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0700.w		; 0E 00 07 ; Arithmetic shift left $0700.w [Flags: NCZ]
	and #$0E.b		; 29 0E ; Logical AND #$0E.b with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $07000E.l		; 22 0E 00 07 ; Jump to subroutine long $07000E.l [Writes: Stack Pointer] [Flow: call]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl $0200.w		; 0E 00 02 ; Arithmetic shift left $0200.w [Flags: NCZ]
	bit $010E.w		; 2C 0E 01 ; Test bits $010E.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $000E.w,X		; 3C 0E 00 ; Test bits $000E.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	tsb $0E2E.w		; 0C 2E 0E ; Test and set bits $0E2E.w [Reads: Accumulator] [Flags: Z]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $000E.w		; 2E 0E 00 ; Rotate left $000E.w [Flags: NCZ]
	tsb $0E2E.w		; 0C 2E 0E ; Test and set bits $0E2E.w [Reads: Accumulator] [Flags: Z]
	cop $0C.b		; 02 0C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $FF0E.w		; 0E 0E FF ; Arithmetic shift left $FF0E.w [Flags: NCZ]
	cop $49.b		; 02 49 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	jsl $4D034C.l		; 22 4C 03 4D ; Jump to subroutine long $4D034C.l [Writes: Stack Pointer] [Flow: call]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr $0A22.w		; 4E 22 0A ; Logical shift right $0A22.w [Flags: NCZ]
	ora $4F.b		; 05 4F ; Logical OR $4F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $50, $4A		; 50 4A ; Branch if overflow clear to $50, $4A [Flow: branch]
	eor ($52.b),Y		; 51 52 ; Exclusive OR accumulator with memory ($52.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	stx $22.b,Y		; 96 22 ; Store X register $22.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora ($9C.b,X)		; 01 9C ; Logical OR ($9C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $62.b,X		; 15 62 ; OR accumulator with memory $62.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($07.b,S),Y		; 53 07 ; XOR accumulator (stack relative indirect indexed) ($07.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $15.b,X		; 15 15 ; OR accumulator with memory $15.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lsr $0A.b,X		; 56 0A ; Logical shift right $0A.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	eor ($6B.b)		; 52 6B ; Exclusive OR accumulator with memory (indirect) ($6B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor [$22.b],Y		; 57 22 ; Exclusive OR accumulator with memory (long indexed) [$22.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	jsl $5A2059.l		; 22 59 20 5A ; Jump to subroutine long $5A2059.l [Writes: Stack Pointer] [Flow: call]
	jsl $5C225B.l		; 22 5B 22 5C ; Jump to subroutine long $5C225B.l [Writes: Stack Pointer] [Flow: call]
	cop $5D.b		; 02 5D ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $6250.w,X		; 5E 50 62 ; Logical shift right $6250.w,X [Reads: X Index] [Flags: NCZ]
	eor $6A9201.l,X		; 5F 01 92 6A ; Exclusive OR accumulator with memory (long,X) $6A9201.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $62, $01		; 62 62 01 ; Push effective relative address $62, $62, $01 [Writes: Stack Pointer]
	sbc $6265.w,Y		; F9 65 62 ; Subtract with carry $6265.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $506601.l,X		; 5F 01 66 50 ; Exclusive OR accumulator with memory (long,X) $506601.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc #$67.b		; 69 67 ; Add #$67.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	.db $42, $02		; 42 02 ; Reserved instruction
	sbc ($67.b)		; F2 67 ; Subtract with carry (indirect) ($67.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc [$62.b]		; 67 62 ; Add with carry (long) [$62.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc ($00.b),Y		; 71 00 ; Add with carry ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc [$64.b]		; 67 64 ; Add with carry (long) [$64.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	stz $06.b,X		; 74 06 ; Store zero to $06.b,X [Reads: X Index]
	adc [$71.b]		; 67 71 ; Add with carry (long) [$71.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc $F273.w,Y		; 79 73 F2 ; Add $F273.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc [$67.b]		; 67 67 ; Add with carry (long) [$67.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	brk $4C.b		; 00 4C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $83, $01		; 62 83 01 ; Push effective relative address $62, $83, $01 [Writes: Stack Pointer]
	sbc ($67.b)		; F2 67 ; Subtract with carry (indirect) ($67.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc $86.b,S		; 63 86 ; Add with carry (stack relative) $86.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $131076.l		; 0F 76 10 13 ; OR accumulator with memory (long) $131076.l [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $10, $8B		; 10 8B ; Branch if plus to $10, $8B [Flow: branch]
	ora $8C.b,X		; 15 8C ; OR accumulator with memory $8C.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($67.b)		; F2 67 ; Subtract with carry (indirect) ($67.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $7D8E.w		; 8D 8E 7D ; Store accumulator to $7D8E.w [Reads: Accumulator]
	ror $64.b,X		; 76 64 ; Rotate right $64.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sta $909001.l		; 8F 01 90 90 ; Store accumulator (long) $909001.l [Reads: Accumulator]
	.db $62, $94, $05		; 62 94 05 ; Push effective relative address $62, $94, $05 [Writes: Stack Pointer]
	sbc ($97.b)		; F2 97 ; Subtract with carry (indirect) ($97.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $7698.w		; 8D 98 76 ; Store accumulator to $7698.w [Reads: Accumulator]
	sta $009964.l		; 8F 64 99 00 ; Store accumulator (long) $009964.l [Reads: Accumulator]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	adc $9E.b,S		; 63 9E ; Add with carry (stack relative) $9E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	asl $F2.b		; 06 F2 ; Arithmetic shift left $F2.b [Reads: Direct Page] [Flags: NCZ]
	adc [$8D.b]		; 67 8D ; Add with carry (long) [$8D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ldx #$90A3.w		; A2 A3 90 ; Load #$90A3.w into X register [Writes: X Index] [Flags: NZ]
	ldy $24.b		; A4 24 ; Load $24.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	lda $03.b		; A5 03 ; Load $03.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldx $A7.b		; A6 A7 ; Load $A7.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	ror $02.b,X		; 76 02 ; Rotate right $02.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $62, $A8, $04		; 62 A8 04 ; Push effective relative address $62, $A8, $04 [Writes: Stack Pointer]
	ldx #$90AB.w		; A2 AB 90 ; Load #$90AB.w into X register [Writes: X Index] [Flags: NZ]
	ldy $A5.b		; A4 A5 ; Load $A5.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	jsl $A504AC.l		; 22 AC 04 A5 ; Jump to subroutine long $A504AC.l [Writes: Stack Pointer] [Flow: call]
	lda $8FAE.w		; AD AE 8F ; Load $8FAE.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $90, $62		; 90 62 ; Branch if carry clear to $90, $62 [Flow: branch]
	lda $B30085.l		; AF 85 00 B3 ; Load long $B30085.l into accumulator [Writes: Accumulator] [Flags: NZ]
	asl $B2.b		; 06 B2 ; Arithmetic shift left $B2.b [Reads: Direct Page] [Flags: NCZ]
	ldy $B3A5.w		; AC A5 B3 ; Load $B3A5.w into Y register [Writes: Y Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	.db $90, $90		; 90 90 ; Branch if carry clear to $90, $90 [Flow: branch]
	.db $62, $B4, $84		; 62 B4 84 ; Push effective relative address $62, $B4, $84 [Writes: Stack Pointer]
	brk $B3.b		; 00 B3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $0084AC.l		; 22 AC 84 00 ; Jump to subroutine long $0084AC.l [Writes: Stack Pointer] [Flow: call]
	wai		; CB ; Wait for interrupt
	ora ($B7.b,X)		; 01 B7 ; Logical OR ($B7.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	clv		; B8 ; Clear overflow flag [Flags: V]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	cmp ($24.b)		; D2 24 ; Compare accumulator (indirect) ($24.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	lda $83.b		; A5 83 ; Load $83.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $CC.b		; 00 CC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $B9.b,S		; 63 B9 ; Add with carry (stack relative) $B9.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora ($AB.b,X)		; 01 AB ; Logical OR ($AB.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $90, $64		; 90 64 ; Branch if carry clear to $90, $64 [Flow: branch]
	lda $BE04.w,X		; BD 04 BE ; Load $BE04.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
.ACCU 16
	rep #$AA		; C2 AA
	.db $90, $90		; 90 90 ; Branch if carry clear to $90, $90 [Flow: branch]
	sbc $270E2F.l,X		; FF 2F 0E 27 ; Subtract with carry (long,X) $270E2F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($29.b,X)		; 01 29 ; Logical OR ($29.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $0100.w		; 0E 00 01 ; Arithmetic shift left $0100.w [Flags: NCZ]
	jsl $01010E.l		; 22 0E 01 01 ; Jump to subroutine long $01010E.l [Writes: Stack Pointer] [Flow: call]
	ora ($2D.b,X)		; 01 2D ; Logical OR ($2D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $0701.w		; 0E 01 07 ; Arithmetic shift left $0701.w [Flags: NCZ]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0200.w		; 0E 00 02 ; Arithmetic shift left $0200.w [Flags: NCZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $0200.w		; 0E 00 02 ; Arithmetic shift left $0200.w [Flags: NCZ]
	cpx $20.b		; E4 20 ; Compare $20.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	asl $0102.w		; 0E 02 01 ; Arithmetic shift left $0102.w [Flags: NCZ]
	asl $2401.w		; 0E 01 24 ; Arithmetic shift left $2401.w [Flags: NCZ]
	asl $0700.w		; 0E 00 07 ; Arithmetic shift left $0700.w [Flags: NCZ]
	and $0E.b		; 25 0E ; Logical AND $0E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $0A.b,S		; 43 0A ; Exclusive OR accumulator with stack relative $0A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $0500.w		; 0E 00 05 ; Arithmetic shift left $0500.w [Flags: NCZ]
	and $06000E.l,X		; 3F 0E 00 06 ; AND accumulator with memory (long,X) $06000E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rol $010E.w		; 2E 0E 01 ; Rotate left $010E.w [Flags: NCZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $01000E.l		; 2F 0E 00 01 ; AND accumulator with memory (long) $01000E.l [Writes: Accumulator] [Flags: NZ]
	and $02FF0E.l,X		; 3F 0E FF 02 ; AND accumulator with memory (long,X) $02FF0E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $67.b,S		; C3 67 ; Compare accumulator (stack relative) $67.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	cmp $2C.b,S		; C3 2C ; Compare accumulator (stack relative) $2C.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	adc [$27.b]		; 67 27 ; Add with carry (long) [$27.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $C4.b		; 00 C4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $67.b		; 26 67 ; Rotate left $67.b [Reads: Direct Page] [Flags: NCZ]
	ora #$C55C.w		; 09 5C C5 ; Logical OR #$C55C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $C6.b,X		; 15 C6 ; OR accumulator with memory $C6.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	jmp $2222C7.l		; 5C C7 22 22 ; Jump long to $2222C7.l [Flow: jump]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cpy $25.b		; C4 25 ; Compare $25.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	adc [$09.b]		; 67 09 ; Add with carry (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp #$95CA.w		; C9 CA 95 ; Compare #$95CA.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	wai		; CB ; Wait for interrupt
	cpy $CC.b		; C4 CC ; Compare $CC.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	ldx $1D.b,Y		; B6 1D ; Load X register $1D.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	cmp $25CE.w		; CD CE 25 ; Compare $25CE.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	adc [$03.b]		; 67 03 ; Add with carry (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	.db $90, $94		; 90 94 ; Branch if carry clear to $90, $94 [Flow: branch]
	.db $62, $CF, $02		; 62 CF 02 ; Push effective relative address $62, $CF, $02 [Writes: Stack Pointer]
	cmp ($D2.b),Y		; D1 D2 ; Compare accumulator ($D2.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	adc #$6725.w		; 69 25 67 ; Add #$6725.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	ora $BA.b,S		; 03 BA ; OR accumulator with stack relative $BA.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	.db $90, $90		; 90 90 ; Branch if carry clear to $90, $90 [Flow: branch]
	adc $D3.b		; 65 D3 ; Add $D3.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and $67.b		; 25 67 ; Logical AND $67.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $D9.b		; 06 D9 ; Arithmetic shift left $D9.b [Reads: Direct Page] [Flags: NCZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	.db $90, $DB		; 90 DB ; Branch if carry clear to $90, $DB [Flow: branch]
	cmp ($DC.b,S),Y		; D3 DC ; Compare accumulator (stack relative indirect indexed) ($DC.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	adc #$6728.w		; 69 28 67 ; Add #$6728.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	ora $DD.b,S		; 03 DD ; OR accumulator with stack relative $DD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $9090.w,X		; DE 90 90 ; Decrement memory $9090.w,X [Reads: X Index] [Flags: NZ]
	adc $DF.b		; 65 DF ; Add $DF.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	jmp $67E5.w		; 4C E5 67 ; Jump to $67E5.w [Flow: jump]
	inc $67.b		; E6 67 ; Increment $67.b [Reads: Direct Page] [Flags: NZ]
	adc [$E7.b]		; 67 E7 ; Add with carry (long) [$E7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	.db $90, $94		; 90 94 ; Branch if carry clear to $90, $94 [Flow: branch]
	.db $62, $E9, $E0		; 62 E9 E0 ; Push effective relative address $62, $E9, $E0 [Writes: Stack Pointer]
	and [$F8.b]		; 27 F8 ; AND accumulator with memory (long) [$F8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx $EDF8.w		; EC F8 ED ; Compare $EDF8.w with X register [Reads: X Index] [Flags: NCZ]
	cpy $67.b		; C4 67 ; Compare $67.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	adc [$E6.b]		; 67 E6 ; Add with carry (long) [$E6.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ror $EE.b,X		; 76 EE ; Rotate right $EE.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $90, $EF		; 90 EF ; Branch if carry clear to $90, $EF [Flow: branch]
	.db $90, $94		; 90 94 ; Branch if carry clear to $90, $94 [Flow: branch]
	.db $F0, $10		; F0 10 ; Branch if equal to $F0, $10 [Flow: branch]
	.db $10, $F1		; 10 F1 ; Branch if plus to $10, $F1 [Flow: branch]
	.db $10, $8B		; 10 8B ; Branch if plus to $10, $8B [Flow: branch]
	lda $C4.b,X		; B5 C4 ; Load $C4.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $67.b,S		; C3 67 ; Compare accumulator (stack relative) $67.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	sta $F2DB90.l		; 8F 90 DB F2 ; Store accumulator (long) $F2DB90.l [Reads: Accumulator]
	sbc ($90.b)		; F2 90 ; Subtract with carry (indirect) ($90.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($90.b,S),Y		; F3 90 ; Subtract with carry (stack relative indirect indexed) ($90.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	.db $90, $F4		; 90 F4 ; Branch if carry clear to $90, $F4 [Flow: branch]
	sty $F5.b,X		; 94 F5 ; Store Y register $F5.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	inc $67.b,X		; F6 67 ; Increment memory $67.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	adc [$25.b]		; 67 25 ; Add with carry (long) [$25.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $90, $00		; 90 00 ; Branch if carry clear to $90, $00 [Flow: branch]
	sbc [$22.b],Y		; F7 22 ; Subtract with carry (long indexed) [$22.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $90, $0E		; 90 0E ; Branch if carry clear to $90, $0E [Flow: branch]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	.db $90, $D3		; 90 D3 ; Branch if carry clear to $90, $D3 [Flow: branch]
	asl $F8.b,X		; 16 F8 ; Arithmetic shift left $F8.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cmp $90.b,S		; C3 90 ; Compare accumulator (stack relative) $90.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	.db $90, $F4		; 90 F4 ; Branch if carry clear to $90, $F4 [Flow: branch]
	.db $90, $90		; 90 90 ; Branch if carry clear to $90, $90 [Flow: branch]
	sbc $EF9090.l		; EF 90 90 EF ; Subtract with carry (long) $EF9090.l [Writes: Accumulator] [Flags: NCVZ]
	jsl $F90390.l		; 22 90 03 F9 ; Jump to subroutine long $F90390.l [Writes: Stack Pointer] [Flow: call]
	ora $17.b,S		; 03 17 ; OR accumulator with stack relative $17.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jmp $902C.w		; 4C 2C 90 ; Jump to $902C.w [Flow: jump]
	tsb $FA.b		; 04 FA ; Test and set bits $FA.b [Reads: Accumulator] [Flags: Z]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	cop $90.b		; 02 90 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($9022.w,X)		; FC 22 90 ; Jump to subroutine indirect indexed ($9022.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora $F4.b,S		; 03 F4 ; OR accumulator with stack relative $F4.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $90, $90		; 90 90 ; Branch if carry clear to $90, $90 [Flow: branch]
	pea $9024.w		; F4 24 90 ; Push absolute address $9024.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	ora $FD.b,S		; 03 FD ; OR accumulator with stack relative $FD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc [$90.b]		; 67 90 ; Add with carry (long) [$90.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inc $9024.w,X		; FE 24 90 ; Increment memory $9024.w,X [Reads: X Index] [Flags: NZ]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $90.b		; 25 90 ; Logical AND $90.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($FD.b,X)		; 01 FD ; Logical OR ($FD.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	adc [$FF.b]		; 67 FF ; Add with carry (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cop $0E.b		; 02 0E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $83.b		; 04 83 ; Test and set bits $83.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $060108.l		; 22 08 01 06 ; Jump to subroutine long $060108.l [Writes: Stack Pointer] [Flow: call]
	ora $090085.l		; 0F 85 00 09 ; OR accumulator with memory (long) $090085.l [Writes: Accumulator] [Flags: NZ]
	jsl $070604.l		; 22 04 06 07 ; Jump to subroutine long $070604.l [Writes: Stack Pointer] [Flow: call]
	asl $08.b		; 06 08 ; Arithmetic shift left $08.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($26.b,X)		; 01 26 ; Logical OR ($26.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $0006.w		; 0C 06 00 ; Test and set bits $0006.w [Reads: Accumulator] [Flags: Z]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	asl $0300.w		; 0E 00 03 ; Arithmetic shift left $0300.w [Flags: NCZ]
	and $0F.b,S		; 23 0F ; AND accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $0306.w		; 0E 06 03 ; Arithmetic shift left $0306.w [Flags: NCZ]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $000001.l		; 0F 01 00 00 ; OR accumulator with memory (long) $000001.l [Writes: Accumulator] [Flags: NZ]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $23.b		; 02 23 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0C000C.l		; 0F 0C 00 0C ; OR accumulator with memory (long) $0C000C.l [Writes: Accumulator] [Flags: NZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $06.b		; 04 06 ; Test and set bits $06.b [Reads: Accumulator] [Flags: Z]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $26.b		; 02 26 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0F0701.l		; 0F 01 07 0F ; OR accumulator with memory (long) $0F0701.l [Writes: Accumulator] [Flags: NZ]
	jsl $0E0100.l		; 22 00 01 0E ; Jump to subroutine long $0E0100.l [Writes: Stack Pointer] [Flow: call]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $020222.l		; 0F 22 02 02 ; OR accumulator with memory (long) $020222.l [Writes: Accumulator] [Flags: NZ]
	ora $83060F.l		; 0F 0F 06 83 ; OR accumulator with memory (long) $83060F.l [Writes: Accumulator] [Flags: NZ]
	brk $74.b		; 00 74 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $0F.b		; 24 0F ; Test bits $0F.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	adc $0005.w,Y		; 79 05 00 ; Add $0005.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: NCZ]
	ora $050C01.l		; 0F 01 0C 05 ; OR accumulator with memory (long) $050C01.l [Writes: Accumulator] [Flags: NZ]
	and $0F.b,S		; 23 0F ; AND accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $83.b,S		; 03 83 ; OR accumulator with stack relative $83.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $8B.b		; 00 8B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $05240C.l		; 0F 0C 24 05 ; OR accumulator with memory (long) $05240C.l [Writes: Accumulator] [Flags: NZ]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $030323.l		; 0F 23 03 03 ; OR accumulator with memory (long) $030323.l [Writes: Accumulator] [Flags: NZ]
	tsb $06.b		; 04 06 ; Test and set bits $06.b [Reads: Accumulator] [Flags: Z]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $05.b		; 25 05 ; Logical AND $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $0E0F05.l		; 0F 05 0F 0E ; OR accumulator with memory (long) $0E0F05.l [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $0F.b		; 02 0F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $090523.l		; 0F 23 05 09 ; OR accumulator with memory (long) $090523.l [Writes: Accumulator] [Flags: NZ]
	ora $010C0E.l		; 0F 0E 0C 01 ; OR accumulator with memory (long) $010C0E.l [Writes: Accumulator] [Flags: NZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	jsl $05010F.l		; 22 0F 01 05 ; Jump to subroutine long $05010F.l [Writes: Stack Pointer] [Flow: call]
	ora $26.b		; 05 26 ; Logical OR $26.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $030B03.l		; 0F 03 0B 03 ; OR accumulator with memory (long) $030B03.l [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $0F.b		; 26 0F ; Rotate left $0F.b [Reads: Direct Page] [Flags: NCZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $0F.b		; 24 0F ; Test bits $0F.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	jsl $0E0302.l		; 22 02 03 0E ; Jump to subroutine long $0E0302.l [Writes: Stack Pointer] [Flow: call]
	ora $830B0F.l		; 0F 0F 0B 83 ; OR accumulator with memory (long) $830B0F.l [Writes: Accumulator] [Flags: NZ]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $0B.b,S		; 43 0B ; Exclusive OR accumulator with stack relative $0B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $010F02.l		; 0F 02 0F 01 ; OR accumulator with memory (long) $010F02.l [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc $8328E0.l,X		; FF E0 28 83 ; Subtract with carry (long,X) $8328E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	trb $4D47.w		; 1C 47 4D ; Test and reset bits $4D47.w [Reads: Accumulator] [Flags: Z]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	jmp $DEA2.w		; 4C A2 DE ; Jump to $DEA2.w [Flow: jump]
	sbc $4CA14E.l,X		; FF 4E A1 4C ; Subtract with carry (long,X) $4CA14E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr $4CA1.w		; 4E A1 4C ; Logical shift right $4CA1.w [Flags: NCZ]
	lsr $298C.w		; 4E 8C 29 ; Logical shift right $298C.w [Flags: NCZ]
	eor [$57.b]		; 47 57 ; Exclusive OR accumulator with memory (long) [$57.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor ($53.b)		; 52 53 ; Exclusive OR accumulator with memory (indirect) ($53.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $3D.b		; 00 3D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda [$53.b]		; A7 53 ; Load accumulator (long) [$53.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $53A7.w,X		; 3D A7 53 ; AND accumulator with memory $53A7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $640B.w,X		; 3D 0B 64 ; AND accumulator with memory $640B.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor [$6A.b]		; 47 6A ; Exclusive OR accumulator with memory (long) [$6A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $56.b,X		; 55 56 ; Exclusive OR accumulator with memory $56.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $1D, $61		; 62 1D 61 ; Push effective relative address $62, $1D, $61 [Writes: Stack Pointer]
	.db $62, $AC, $13		; 62 AC 13 ; Push effective relative address $62, $AC, $13 [Writes: Stack Pointer]
	ldy $AD.b		; A4 AD ; Load $AD.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	ldx $1BA4.w		; AE A4 1B ; Load $1BA4.w into X register [Writes: X Index] [Flags: NZ]
	trb $9392.w		; 1C 92 93 ; Test and reset bits $9392.w [Reads: Accumulator] [Flags: Z]
	ora $6867.w,X		; 1D 67 68 ; OR accumulator with memory $6867.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda [$67.b],Y		; B7 67 ; Load accumulator (long indexed) [$67.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	stz $35.b,X		; 74 35 ; Store zero to $35.b,X [Reads: X Index]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	ldx $26.b,Y		; B6 26 ; Load X register $26.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	cmp $0163.w,Y		; D9 63 01 ; Compare accumulator $0163.w,Y [Reads: Y Index] [Flags: NCZ]
	asl $DF93.w		; 0E 93 DF ; Arithmetic shift left $DF93.w [Flags: NCZ]
	and #$DF1F.w		; 29 1F DF ; Logical AND #$DF1F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and #$1E05.w		; 29 05 1E ; Logical AND #$1E05.w with accumulator [Writes: Accumulator] [Flags: NZ]
	inc $2F09.w		; EE 09 2F ; Increment $2F09.w [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cmp ($D2.b),Y		; D1 D2 ; Compare accumulator ($D2.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	adc $06.b,S		; 63 06 ; Add with carry (stack relative) $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	tsb $321F.w		; 0C 1F 32 ; Test and set bits $321F.w [Reads: Accumulator] [Flags: Z]
	trb $03CC.w		; 1C CC 03 ; Test and reset bits $03CC.w [Reads: Accumulator] [Flags: Z]
	and ($0E.b),Y		; 31 0E ; AND accumulator with memory ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $060630.l		; 2F 30 06 06 ; AND accumulator with memory (long) $060630.l [Writes: Accumulator] [Flags: NZ]
	jmp.w [$66DD]		; DC DD 66 ; Jump long indirect [$66DD] [Flow: jump]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora ($CC.b,X)		; 01 CC ; Logical OR ($CC.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($22.b),Y		; 11 22 ; OR accumulator with memory ($22.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda ($01.b,X)		; A1 01 ; Load accumulator ($01.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	asl $63.b		; 06 63 ; Arithmetic shift left $63.b [Reads: Direct Page] [Flags: NCZ]
	ora ($22.b)		; 12 22 ; OR accumulator with memory (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	asl $16.b		; 06 16 ; Arithmetic shift left $16.b [Reads: Direct Page] [Flags: NCZ]
	ora [$A0.b],Y		; 17 A0 ; OR accumulator with memory (long indexed) [$A0.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $5B5A.w,Y		; 19 5A 5B ; OR accumulator with memory $5B5A.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	stz $1A.b		; 64 1A ; Store zero to $1A.b
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ldy $201F.w,X		; BC 1F 20 ; Load Y register $201F.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and ($A5.b,X)		; 21 A5 ; Logical AND ($A5.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $6261.w,X		; 1D 61 62 ; OR accumulator with memory $6261.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda ($6A.b)		; B2 6A ; Load accumulator (indirect) ($6A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $62, $22, $01		; 62 22 01 ; Push effective relative address $62, $22, $01 [Writes: Stack Pointer]
	sta $63FF.w,Y		; 99 FF 63 ; Store accumulator to $63FF.w,Y [Reads: Y Index, Accumulator]
	and $08.b		; 25 08 ; Logical AND $08.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	mvp $1D,$86		; 44 86 1D ; Move block positive $1D,$86 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	adc [$68.b]		; 67 68 ; Add with carry (long) [$68.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $29DE.w,X		; 1D DE 29 ; OR accumulator with memory $29DE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $FF24.w,Y		; 99 24 FF ; Store accumulator to $FF24.w,Y [Reads: Y Index, Accumulator]
	ora #$2B2A.w		; 09 2A 2B ; Logical OR #$2B2A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sty $868D.w		; 8C 8D 86 ; Store Y register to $868D.w [Reads: Y Index]
	cmp $1D6A29.l,X		; DF 29 6A 1D ; Compare accumulator (long,X) $1D6A29.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	bit $FF25.w		; 2C 25 FF ; Test bits $FF25.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and $2EA1.w		; 2D A1 2E ; Logical AND $2EA1.w with accumulator [Writes: Accumulator] [Flags: NZ]
	mvp $E6,$8D		; 44 8D E6 ; Move block positive $E6,$8D [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	asl $2CDE.w,X		; 1E DE 2C ; Arithmetic shift left $2CDE.w,X [Reads: X Index] [Flags: NCZ]
	and $10FF23.l		; 2F 23 FF 10 ; AND accumulator with memory (long) $10FF23.l [Writes: Accumulator] [Flags: NZ]
	.db $30, $FD		; 30 FD ; Branch if minus to $30, $FD [Flow: branch]
	sbc $06.b,X		; F5 06 ; Subtract $06.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $E3.b,S		; 63 E3 ; Add with carry (stack relative) $E3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $0303.w,X		; 1D 03 03 ; OR accumulator with memory $0303.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	trb $3231.w		; 1C 31 32 ; Test and reset bits $3231.w [Reads: Accumulator] [Flags: Z]
	and $30FFFF.l		; 2F FF FF 30 ; AND accumulator with memory (long) $30FFFF.l [Writes: Accumulator] [Flags: NZ]
	and $3364.w		; 2D 64 33 ; Logical AND $3364.w with accumulator [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	lsr $1DE6.w		; 4E E6 1D ; Logical shift right $1DE6.w [Flags: NCZ]
	cmp $3138.w,Y		; D9 38 31 ; Compare accumulator $3138.w,Y [Reads: Y Index] [Flags: NCZ]
	and $3A3A.w,Y		; 39 3A 3A ; AND accumulator with memory $3A3A.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($69.b,S),Y		; 33 69 ; AND accumulator (stack relative indirect indexed) ($69.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	stz $3C.b		; 64 3C ; Store zero to $3C.b
	jsl $440F4C.l		; 22 4C 0F 44 ; Jump to subroutine long $440F4C.l [Writes: Stack Pointer] [Flow: call]
	sec		; 38 ; Set carry flag [Flags: C]
	eor ($53.b,X)		; 41 53 ; Exclusive OR accumulator with memory ($53.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	asl $42.b		; 06 42 ; Arithmetic shift left $42.b [Reads: Direct Page] [Flags: NCZ]
	eor $6A.b,S		; 43 6A ; Exclusive OR accumulator with stack relative $6A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $44.b,X		; 55 44 ; Exclusive OR accumulator with memory $44.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($45.b,S),Y		; 53 45 ; XOR accumulator (stack relative indirect indexed) ($45.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lsr $EB.b		; 46 EB ; Logical shift right $EB.b [Reads: Direct Page] [Flags: NCZ]
	sta ($FF.b,X)		; 81 FF ; Store accumulator ($FF.b,X) [Reads: Direct Page, Accumulator, X Index]
	ora $0B0D.w		; 0D 0D 0B ; Logical OR $0B0D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $03250F.l		; 0F 0F 25 03 ; OR accumulator with memory (long) $03250F.l [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $07,$06		; 44 06 07 ; Move block positive $07,$06 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $26.b,S		; 03 26 ; OR accumulator with stack relative $26.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $000308.l		; 0F 08 03 00 ; OR accumulator with memory (long) $000308.l [Writes: Accumulator] [Flags: NZ]
	ora $02000F.l		; 0F 0F 00 02 ; OR accumulator with memory (long) $02000F.l [Writes: Accumulator] [Flags: NZ]
	ora $220300.l		; 0F 00 03 22 ; OR accumulator with memory (long) $220300.l [Writes: Accumulator] [Flags: NZ]
	ora $0F0119.l		; 0F 19 01 0F ; OR accumulator with memory (long) $0F0119.l [Writes: Accumulator] [Flags: NZ]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0C0907.l		; 0F 07 09 0C ; OR accumulator with memory (long) $0C0907.l [Writes: Accumulator] [Flags: NZ]
	ora $0F0405.l		; 0F 05 04 0F ; OR accumulator with memory (long) $0F0405.l [Writes: Accumulator] [Flags: NZ]
	ora $000203.l		; 0F 03 02 00 ; OR accumulator with memory (long) $000203.l [Writes: Accumulator] [Flags: NZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	jsl $02030F.l		; 22 0F 03 02 ; Jump to subroutine long $02030F.l [Writes: Stack Pointer] [Flow: call]
	ora $24060C.l		; 0F 0C 06 24 ; OR accumulator with memory (long) $24060C.l [Writes: Accumulator] [Flags: NZ]
	ora $3D0083.l		; 0F 83 00 3D ; OR accumulator with memory (long) $3D0083.l [Writes: Accumulator] [Flags: NZ]
	jsl $02020F.l		; 22 0F 02 02 ; Jump to subroutine long $02020F.l [Writes: Stack Pointer] [Flow: call]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and [$0F.b]		; 27 0F ; AND accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $0F.b,S		; 23 0F ; AND accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $23050F.l		; 0F 0F 05 23 ; OR accumulator with memory (long) $23050F.l [Writes: Accumulator] [Flags: NZ]
	ora $0F0403.l		; 0F 03 04 0F ; OR accumulator with memory (long) $0F0403.l [Writes: Accumulator] [Flags: NZ]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	jmp ($0902.w)		; 6C 02 09 ; Jump indirect to ($0902.w) [Flow: jump]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $0F.b,S		; 23 0F ; AND accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $08.b		; 06 08 ; Arithmetic shift left $08.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $0E0707.l		; 0F 07 07 0E ; OR accumulator with memory (long) $0E0707.l [Writes: Accumulator] [Flags: NZ]
	ora $850083.l		; 0F 83 00 85 ; OR accumulator with memory (long) $850083.l [Writes: Accumulator] [Flags: NZ]
	tsb $09.b		; 04 09 ; Test and set bits $09.b [Reads: Accumulator] [Flags: Z]
	tsb $0D0F.w		; 0C 0F 0D ; Test and set bits $0D0F.w [Reads: Accumulator] [Flags: Z]
	ora $420083.l		; 0F 83 00 42 ; OR accumulator with memory (long) $420083.l [Writes: Accumulator] [Flags: NZ]
	ora ($0E.b,X)		; 01 0E ; Logical OR ($0E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $25.b		; 05 25 ; Logical OR $25.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0F0902.l		; 0F 02 09 0F ; OR accumulator with memory (long) $0F0902.l [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	.db $82, $83, $00		; 82 83 00 ; Branch always long to $82, $83, $00 [Flow: branch]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	ora $050F06.l		; 0F 06 0F 05 ; OR accumulator with memory (long) $050F06.l [Writes: Accumulator] [Flags: NZ]
	jsl $00040F.l		; 22 0F 04 00 ; Jump to subroutine long $00040F.l [Writes: Stack Pointer] [Flow: call]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora #$0083.w		; 09 83 00 ; Logical OR #$0083.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ror $0C1D.w		; 6E 1D 0C ; Rotate right $0C1D.w [Flags: NCZ]
	ora $090F.w		; 0D 0F 09 ; Logical OR $090F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $000207.l		; 0F 07 02 00 ; OR accumulator with memory (long) $000207.l [Writes: Accumulator] [Flags: NZ]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	ora #$0507.w		; 09 07 05 ; Logical OR #$0507.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$02.b]		; 07 02 ; OR accumulator with memory (long) [$02.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0F.b		; 05 0F ; Logical OR $0F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($0D.b,X)		; 01 0D ; Logical OR ($0D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $050705.l		; 0F 05 07 05 ; OR accumulator with memory (long) $050705.l [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $07.b,S		; 23 07 ; AND accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $0F.b,S		; 23 0F ; AND accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $0D.b		; 04 0D ; Test and set bits $0D.b [Reads: Accumulator] [Flags: Z]
	asl $05.b		; 06 05 ; Arithmetic shift left $05.b [Reads: Direct Page] [Flags: NCZ]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $090A0F.l		; 22 0F 0A 09 ; Jump to subroutine long $090A0F.l [Writes: Stack Pointer] [Flow: call]
	ora $0F.b		; 05 0F ; Logical OR $0F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $0F0F.w		; 0C 0F 0F ; Test and set bits $0F0F.w [Reads: Accumulator] [Flags: Z]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $5D0083.l		; 0F 83 00 5D ; OR accumulator with memory (long) $5D0083.l [Writes: Accumulator] [Flags: NZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $0F.b,S		; 23 0F ; AND accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $5E530E.l,X		; FF 0E 53 5E ; Subtract with carry (long,X) $5E530E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $E3.b,S		; 63 E3 ; Add with carry (stack relative) $E3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $471C.w,X		; 1D 1C 47 ; OR accumulator with memory $471C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $6A1D.w,X		; 1D 1D 6A ; OR accumulator with memory $6A1D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $50, $51		; 50 51 ; Branch if overflow clear to $50, $51 [Flow: branch]
	eor [$47.b]		; 47 47 ; Exclusive OR accumulator with memory (long) [$47.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor ($22.b)		; 52 22 ; Exclusive OR accumulator with memory (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $9409.w		; 20 09 94 ; Jump to subroutine at $9409.w [Writes: Stack Pointer] [Flow: call]
	sta $1D.b,X		; 95 1D ; Store accumulator to $1D.b,X [Reads: Accumulator, X Index]
	sta $08A04D.l		; 8F 4D A0 08 ; Store accumulator (long) $08A04D.l [Reads: Accumulator]
	sta ($56.b,S),Y		; 93 56 ; Store accumulator (stack relative indirect indexed) ($56.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	eor [$64.b],Y		; 57 64 ; Exclusive OR accumulator with memory (long indexed) [$64.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	jmp $9D4D.w		; 4C 4D 9D ; Jump to $9D4D.w [Flow: jump]
	ora $4F4E.w,X		; 1D 4E 4F ; OR accumulator with memory $4F4E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $505E.w,X		; 1D 5E 50 ; OR accumulator with memory $505E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $6256.w,X		; 1D 56 62 ; OR accumulator with memory $6256.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($19.b),Y		; 51 19 ; Exclusive OR accumulator with memory ($19.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cop $54.b		; 02 54 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $BB.b,X		; 76 BB ; Rotate right $BB.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	eor $47.b,X		; 55 47 ; Exclusive OR accumulator with memory $47.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lsr $57.b,X		; 56 57 ; Logical shift right $57.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $42BA.w		; 0D BA 42 ; Logical OR $42BA.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	.db $10, $8E		; 10 8E ; Branch if plus to $10, $8E [Flow: branch]
	eor $635A.w,Y		; 59 5A 63 ; Exclusive OR accumulator with memory $635A.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	stx $1D.b		; 86 1D ; Store X register to $1D.b [Reads: X Index]
	ora $4755.w,X		; 1D 55 47 ; OR accumulator with memory $4755.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr $42.b,X		; 56 42 ; Logical shift right $42.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $5B62.w,X		; 1D 62 5B ; OR accumulator with memory $5B62.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $08.b,S		; [PATTERN: Memory clearing operation] 03 08 ; OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lsr $A47C.w,X		; 5E 7C A4 ; Logical shift right $A47C.w,X [Reads: X Index] [Flags: NCZ]
	stz $5F.b		; 64 5F ; Store zero to $5F.b
	ora $3B.b,S		; 03 3B ; OR accumulator with stack relative $3B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	stz $65.b		; 64 65 ; Store zero to $65.b
	lda ($62.b,S),Y		; B3 62 ; Load accumulator (stack relative indirect indexed) ($62.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ror $02.b		; 66 02 ; Rotate right $02.b [Reads: Direct Page] [Flags: NCZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ora $6965A3.l,X		; 1F A3 65 69 ; Logical OR long $6965A3.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cop $64.b		; 02 64 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $706379.l		; 6F 79 63 70 ; Add with carry (long) $706379.l [Writes: Accumulator] [Flags: NCVZ]
	tsb $80.b		; 04 80 ; Test and set bits $80.b [Reads: Accumulator] [Flags: Z]
	stz $75.b,X		; 74 75 ; Store zero to $75.b,X [Reads: X Index]
	cmp ($6A.b,X)		; C1 6A ; Compare accumulator ($6A.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	.db $62, $76, $0A		; 62 76 0A ; Push effective relative address $62, $76, $0A [Writes: Stack Pointer]
	ora $6F.b,S		; 03 6F ; OR accumulator with stack relative $6F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $369D.w,Y		; 79 9D 36 ; Add $369D.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $E57A.w,Y		; 79 7A E5 ; Add $E57A.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $B23B.w,X		; 3E 3B B2 ; Rotate left $B23B.w,X [Reads: X Index] [Flags: NCZ]
	adc $7B.b,S		; 63 7B ; Add with carry (stack relative) $7B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $35.b,X		; 15 35 ; OR accumulator with memory $35.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $7F.b,X		; 35 7F ; Logical AND $7F.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $802B1C.l		; 22 1C 2B 80 ; Jump to subroutine long $802B1C.l [Writes: Stack Pointer] [Flow: call]
	sta ($8A.b,X)		; 81 8A ; Store accumulator ($8A.b,X) [Reads: Direct Page, Accumulator, X Index]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	and $82545A.l		; 2F 5A 54 82 ; AND accumulator with memory (long) $82545A.l [Writes: Accumulator] [Flags: NZ]
	ldx $83.b		; A6 83 ; Load $83.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	ora $841D.w,X		; 1D 1D 84 ; OR accumulator with memory $841D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $2B.b,X		; 95 2B ; Store accumulator to $2B.b,X [Reads: Accumulator, X Index]
	cpy #$8565.w		; C0 65 85 ; Compare #$8565.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpx #$5A41.w		; E0 41 5A ; Compare #$5A41.w with X register [Reads: X Index] [Flags: NCZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	lsr $358C.w,X		; 5E 8C 35 ; Logical shift right $358C.w,X [Reads: X Index] [Flags: NCZ]
	and $8D.b,X		; 35 8D ; Logical AND $8D.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sta $8E.b,X		; 95 8E ; Store accumulator to $8E.b,X [Reads: Accumulator, X Index]
	sta $FF9052.l		; 8F 52 90 FF ; Store accumulator (long) $FF9052.l [Reads: Accumulator]
	sta ($09.b),Y		; 91 09 ; Store accumulator ($09.b),Y [Reads: Direct Page, Y Index, Accumulator]
	sta ($C9.b)		; 92 C9 ; Store accumulator (indirect) ($C9.b) [Reads: Direct Page, Accumulator]
	sta ($54.b,S),Y		; 93 54 ; Store accumulator (stack relative indirect indexed) ($54.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	sty $1D.b,X		; 94 1D ; Store Y register $1D.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	ora $C895.w,X		; 1D 95 C8 ; OR accumulator with memory $C895.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	stx $9B.b,Y		; 96 9B ; Store X register $9B.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	sta [$98.b],Y		; 97 98 ; Store accumulator (long indexed) [$98.b],Y [Reads: Direct Page, Y Index, Accumulator]
	lda $80.b,X		; B5 80 ; Load $80.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sta $9A8B.w,Y		; 99 8B 9A ; Store accumulator to $9A8B.w,Y [Reads: Y Index, Accumulator]
	ror $7A.b,X		; 76 7A ; Rotate right $7A.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $3003.w,X		; 1D 03 30 ; OR accumulator with memory $3003.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc [$E3.b],Y		; F7 E3 ; Subtract with carry (long indexed) [$E3.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $AF24.w,X		; 3E 24 AF ; Rotate left $AF24.w,X [Reads: X Index] [Flags: NCZ]
	eor $FB.b		; 45 FB ; Exclusive OR $FB.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $6AE5A3.l,X		; 1F A3 E5 6A ; Logical OR long $6AE5A3.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	stx $4A.b		; 86 4A ; Store X register to $4A.b [Reads: X Index]
	sbc ($B8.b)		; F2 B8 ; Subtract with carry (indirect) ($B8.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	adc ($95.b,S),Y		; 73 95 ; Add with carry (stack relative indirect indexed) ($95.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc $B2.b		; E5 B2 ; Subtract $B2.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	bit $4A.b		; 24 4A ; Test bits $4A.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	.db $80, $36		; 80 36 ; Branch always to $80, $36 [Flow: branch]
	sbc $B2.b		; E5 B2 ; Subtract $B2.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $62, $9C, $17		; 62 9C 17 ; Push effective relative address $62, $9C, $17 [Writes: Stack Pointer]
	cmp ($3E.b,X)		; C1 3E ; Compare accumulator ($3E.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	adc ($95.b,S),Y		; 73 95 ; Add with carry (stack relative indirect indexed) ($95.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc $79.b		; E5 79 ; Subtract $79.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc #$989F.w		; 69 9F 98 ; Add #$989F.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sbc $A0.b		; E5 A0 ; Subtract $A0.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	mvn $A1,$6A		; 54 6A A1 ; Move block negative $A1,$6A [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	trb $95A2.w		; 1C A2 95 ; Test and reset bits $95A2.w [Reads: Accumulator] [Flags: Z]
	sbc $A3.b		; E5 A3 ; Subtract $A3.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ldy $A8.b		; A4 A8 ; Load $A8.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	adc $A5.b,S		; 63 A5 ; Add with carry (stack relative) $A5.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc $060317.l,X		; FF 17 03 06 ; Subtract with carry (long,X) $060317.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $010303.l		; 0F 03 03 01 ; OR accumulator with memory (long) $010303.l [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	cop $0F.b		; 02 0F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0F0202.l		; 0F 02 02 0F ; OR accumulator with memory (long) $0F0202.l [Writes: Accumulator] [Flags: NZ]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $07010F.l		; 0F 0F 01 07 ; OR accumulator with memory (long) $07010F.l [Writes: Accumulator] [Flags: NZ]
	asl $84.b		; 06 84 ; Arithmetic shift left $84.b [Reads: Direct Page] [Flags: NCZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $01230F.l		; 0F 0F 23 01 ; OR accumulator with memory (long) $01230F.l [Writes: Accumulator] [Flags: NZ]
	ora #$0E0F.w		; 09 0F 0E ; Logical OR #$0E0F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $090507.l		; 0F 07 05 09 ; OR accumulator with memory (long) $090507.l [Writes: Accumulator] [Flags: NZ]
	cop $0F.b		; 02 0F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$0F.b]		; 27 0F ; AND accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $05.b		; 14 05 ; Test and reset bits $05.b [Reads: Accumulator] [Flags: Z]
	ora $0F0905.l		; 0F 05 09 0F ; OR accumulator with memory (long) $0F0905.l [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	ora $070501.l		; 0F 01 05 07 ; OR accumulator with memory (long) $070501.l [Writes: Accumulator] [Flags: NZ]
	ora [$04.b]		; 07 04 ; OR accumulator with memory (long) [$04.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ora $0900.w,X		; 1D 00 09 ; OR accumulator with memory $0900.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	bit $05.b		; 24 05 ; Test bits $05.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	jsl $090107.l		; 22 07 01 09 ; Jump to subroutine long $090107.l [Writes: Stack Pointer] [Flow: call]
	asl $62.b		; 06 62 ; Arithmetic shift left $62.b [Reads: Direct Page] [Flags: NCZ]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $430500.l		; 0F 00 05 43 ; OR accumulator with memory (long) $430500.l [Writes: Accumulator] [Flags: NZ]
	ora $09.b		; 05 09 ; Logical OR $09.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $08.b		; 06 08 ; Arithmetic shift left $08.b [Reads: Direct Page] [Flags: NCZ]
	ora $010707.l		; 0F 07 07 01 ; OR accumulator with memory (long) $010707.l [Writes: Accumulator] [Flags: NZ]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	jsl $05010F.l		; 22 0F 01 05 ; Jump to subroutine long $05010F.l [Writes: Stack Pointer] [Flow: call]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$0707.w		; 09 07 07 ; Logical OR #$0707.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $0F.b,S		; 43 0F ; Exclusive OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $43.b		; 05 43 ; Logical OR $43.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$0807.w		; 09 07 08 ; Logical OR #$0807.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $09.b		; 05 09 ; Logical OR $09.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0F.b		; 05 0F ; Logical OR $0F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $85.b		; 05 85 ; Logical OR $85.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $0F.b,S		; 23 0F ; AND accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora #$0505.w		; 09 05 05 ; Logical OR #$0505.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $090902.l		; 0F 02 09 09 ; OR accumulator with memory (long) $090902.l [Writes: Accumulator] [Flags: NZ]
	ora $24.b		; 05 24 ; Logical OR $24.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $230700.l		; 0F 00 07 23 ; OR accumulator with memory (long) $230700.l [Writes: Accumulator] [Flags: NZ]
	ora $0B.b		; 05 0B ; Logical OR $0B.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0F.b		; 05 0F ; Logical OR $0F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $0F0D06.l		; 0F 06 0D 0F ; OR accumulator with memory (long) $0F0D06.l [Writes: Accumulator] [Flags: NZ]
	jsl $050507.l		; 22 07 05 05 ; Jump to subroutine long $050507.l [Writes: Stack Pointer] [Flow: call]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $440707.l		; 0F 07 07 44 ; OR accumulator with memory (long) $440707.l [Writes: Accumulator] [Flags: NZ]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	ora $08070F.l		; 0F 0F 07 08 ; OR accumulator with memory (long) $08070F.l [Writes: Accumulator] [Flags: NZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $230201.l		; 0F 01 02 23 ; OR accumulator with memory (long) $230201.l [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $000522.l		; 0F 22 05 00 ; OR accumulator with memory (long) $000522.l [Writes: Accumulator] [Flags: NZ]
	ora [$83.b]		; 07 83 ; OR accumulator with memory (long) [$83.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $C7.b		; 00 C7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $5C.b		; 00 5C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $05.b,S		; 43 05 ; Exclusive OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$83.b]		; 07 83 ; OR accumulator with memory (long) [$83.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $6F.b		; 00 6F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0003.w		; 0D 03 00 ; Logical OR $0003.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $05.b		; 06 05 ; Arithmetic shift left $05.b [Reads: Direct Page] [Flags: NCZ]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0F.b		; 05 0F ; Logical OR $0F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$0B.b]		; 07 0B ; OR accumulator with memory (long) [$0B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $18FF01.l		; 0F 01 FF 18 ; OR accumulator with memory (long) $18FF01.l [Writes: Accumulator] [Flags: NZ]
	and ($A6.b,X)		; 21 A6 ; Logical AND ($A6.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	mvn $20,$20		; 54 20 20 ; Move block negative $20,$20 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	tsb $DC53.w		; 0C 53 DC ; Test and set bits $DC53.w [Reads: Accumulator] [Flags: Z]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $E5.b,X		; 95 E5 ; Store accumulator to $E5.b,X [Reads: Accumulator, X Index]
	adc $BF.b,X		; 75 BF ; Add $BF.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda #$8282.w		; A9 82 82 ; Load #$8282.w into accumulator [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	eor ($76.b)		; 52 76 ; Exclusive OR accumulator with memory (indirect) ($76.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	ora [$12.b],Y		; 17 12 ; OR accumulator with memory (long indexed) [$12.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ldx $83AB.w		; AE AB 83 ; Load $83AB.w into X register [Writes: X Index] [Flags: NZ]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($77.b)		; 12 77 ; OR accumulator with memory (indirect) ($77.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $82, $82, $AC		; 82 82 AC ; Branch always long to $82, $82, $AC [Flow: branch]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc $0202.w		; ED 02 02 ; Subtract $0202.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ora $4D.b,S		; 03 4D ; OR accumulator with stack relative $4D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lsr $17AD.w,X		; 5E AD 17 ; Logical shift right $17AD.w,X [Reads: X Index] [Flags: NCZ]
	inc $1D.b		; E6 1D ; Increment $1D.b [Reads: Direct Page] [Flags: NZ]
	eor ($A9.b,X)		; 41 A9 ; Exclusive OR accumulator with memory ($A9.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $82, $82, $62		; 82 82 62 ; Branch always long to $82, $82, $62 [Flow: branch]
	ldx $2BE0.w		; AE E0 2B ; Load $2BE0.w into X register [Writes: X Index] [Flags: NZ]
	eor [$47.b]		; 47 47 ; Exclusive OR accumulator with memory (long) [$47.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda ($B2.b),Y		; B1 B2 ; Load accumulator ($B2.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda $B39D.w		; AD 9D B3 ; Load $B39D.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sbc ($23.b)		; F2 23 ; Subtract with carry (indirect) ($23.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ldy $77.b,X		; B4 77 ; Load Y register $77.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	.db $82, $82, $20		; 82 82 20 ; Branch always long to $82, $82, $20 [Flow: branch]
	ora #$A4B5.w		; 09 B5 A4 ; Logical OR #$A4B5.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ldy $B6.b		; A4 B6 ; Load $B6.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	sbc $239D.w,X		; FD 9D 23 ; Subtract with carry $239D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and [$FE.b],Y		; 37 FE ; AND accumulator with memory (long indexed) [$FE.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpy $776A.w		; CC 6A 77 ; Compare $776A.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $82, $82, $B7		; 82 82 B7 ; Branch always long to $82, $82, $B7 [Flow: branch]
	sbc $E5E5A3.l,X		; FF A3 E5 E5 ; Subtract with carry (long,X) $E5E5A3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $3B1CB0.l		; AF B0 1C 3B ; Load long $3B1CB0.l into accumulator [Writes: Accumulator] [Flags: NZ]
	adc $BF.b,X		; 75 BF ; Add $BF.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lda #$8277.w		; A9 77 82 ; Load #$8277.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $62, $B8, $E0		; 62 B8 E0 ; Push effective relative address $62, $B8, $E0 [Writes: Stack Pointer]
	and ($E5.b),Y		; 31 E5 ; AND accumulator with memory ($E5.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $3E.b		; E5 3E ; Subtract $3E.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $A5.b		; E5 A5 ; Subtract $A5.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda ($BB.b)		; B2 BB ; Load accumulator (indirect) ($BB.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $F03D.w,X		; 3C 3D F0 ; Test bits $F03D.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	dec $77.b		; C6 77 ; Decrement $77.b [Reads: Direct Page] [Flags: NZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	ldy $E5BD.w,X		; BC BD E5 ; Load Y register $E5BD.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	.db $90, $E5		; 90 E5 ; Branch if carry clear to $90, $E5 [Flow: branch]
	sbc $E4.b		; E5 E4 ; Subtract $E4.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	mvp $AF,$3B		; 44 3B AF ; Move block positive $AF,$3B [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	eor $2D.b		; 45 2D ; Exclusive OR $2D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldx $67BF.w,Y		; BE BF 67 ; Load X register $67BF.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	cpy #$3EE5.w		; C0 E5 3E ; Compare #$3EE5.w with Y register [Reads: Y Index] [Flags: NCZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $3B.b		; A5 3B ; Load $3B.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $24.b		; E5 24 ; Subtract $24.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $3E.b		; E5 3E ; Subtract $3E.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $C1.b		; E5 C1 ; Subtract $C1.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and $C2.b,X		; 35 C2 ; Logical AND $C2.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ldx $C3.b		; A6 C3 ; Load $C3.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	cpy $E5.b		; C4 E5 ; Compare $E5.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	sbc $13.b		; E5 13 ; Subtract $13.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inc $22.b		; E6 22 ; Increment $22.b [Reads: Direct Page] [Flags: NZ]
	cmp $0B.b		; C5 0B ; Compare $0B.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	dec $3E.b		; C6 3E ; Decrement $3E.b [Reads: Direct Page] [Flags: NZ]
	sbc $E5.b		; E5 E5 ; Subtract $E5.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	bit $E5.b		; 24 E5 ; Test bits $E5.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sbc ($C7.b,X)		; E1 C7 ; Subtract with carry ($C7.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $82, $3E, $3E		; 82 3E 3E ; Branch always long to $82, $3E, $3E [Flow: branch]
	inc $62.b		; E6 62 ; Increment $62.b [Reads: Direct Page] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cop $CA.b		; 02 CA ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	wai		; CB ; Wait for interrupt
	eor #$E523.w		; 49 23 E5 ; Exclusive OR #$E523.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cpx #$5252.w		; E0 52 52 ; Compare #$5252.w with X register [Reads: X Index] [Flags: NCZ]
	cpy $E582.w		; CC 82 E5 ; Compare $E582.w with Y register [Reads: Y Index] [Flags: NCZ]
	inc $C8.b		; E6 C8 ; Increment $C8.b [Reads: Direct Page] [Flags: NZ]
	eor #$CECD.w		; 49 CD CE ; Exclusive OR #$CECD.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lda [$A6.b]		; A7 A6 ; Load accumulator (long) [$A6.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $249049.l		; CF 49 90 24 ; Compare accumulator (long) $249049.l [Reads: Accumulator] [Flags: NCZ]
	sbc $52.b		; E5 52 ; Subtract $52.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cpy $24D0.w		; CC D0 24 ; Compare $24D0.w with Y register [Reads: Y Index] [Flags: NCZ]
	and [$53.b],Y		; 37 53 ; AND accumulator with memory (long indexed) [$53.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($F7.b),Y		; D1 F7 ; Compare accumulator ($F7.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cmp ($0B.b)		; D2 0B ; Compare accumulator (indirect) ($0B.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	tsb $D4D3.w		; 0C D3 D4 ; Test and set bits $D4D3.w [Reads: Accumulator] [Flags: Z]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	lda ($3B.b)		; B2 3B ; Load accumulator (indirect) ($3B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor ($CC.b)		; 52 CC ; Exclusive OR accumulator with memory (indirect) ($CC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $E5.b,X		; D5 E5 ; Compare accumulator $E5.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	adc $D6.b,X		; 75 D6 ; Add $D6.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $2002.w,X		; FD 02 20 ; Subtract with carry $2002.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $09.b,S		; 23 09 ; AND accumulator with stack relative $09.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $C9D7.w,X		; FD D7 C9 ; Subtract with carry $C9D7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $E5.b		; E5 E5 ; Subtract $E5.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and [$53.b],Y		; 37 53 ; AND accumulator with memory (long indexed) [$53.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	cmp $DA75.w,Y		; D9 75 DA ; Compare accumulator $DA75.w,Y [Reads: Y Index] [Flags: NCZ]
	tsb $6A.b		; 04 6A ; Test and set bits $6A.b [Reads: Accumulator] [Flags: Z]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	ora $041F.w,X		; 1D 1F 04 ; OR accumulator with memory $041F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	cmp #$E53B.w		; C9 3B E5 ; Compare #$E53B.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	bit $DDDC.w,X		; 3C DC DD ; Test bits $DDDC.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	sbc $75.b		; E5 75 ; Subtract $75.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ldy #$3E1D.w		; A0 1D 3E ; Load #$3E1D.w into Y register [Writes: Y Index] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	rol $1D1D.w,X		; 3E 1D 1D ; Rotate left $1D1D.w,X [Reads: X Index] [Flags: NCZ]
	adc ($C9.b,X)		; 61 C9 ; Add with carry ($C9.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $E144.w,X		; DE 44 E1 ; Decrement memory $E144.w,X [Reads: X Index] [Flags: NZ]
	cmp [$25.b]		; C7 25 ; Compare accumulator (long) [$25.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sbc $0E0F02.l,X		; FF 02 0F 0E ; Subtract with carry (long,X) $0E0F02.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $220E24.l		; 0F 24 0E 22 ; OR accumulator with memory (long) $220E24.l [Writes: Accumulator] [Flags: NZ]
	ora $0F0E02.l		; 0F 02 0E 0F ; OR accumulator with memory (long) $0F0E02.l [Writes: Accumulator] [Flags: NZ]
	ora $220E22.l		; 0F 22 0E 22 ; OR accumulator with memory (long) $220E22.l [Writes: Accumulator] [Flags: NZ]
	ora $230E24.l		; 0F 24 0E 23 ; OR accumulator with memory (long) $230E24.l [Writes: Accumulator] [Flags: NZ]
	ora $830E22.l		; 0F 22 0E 83 ; OR accumulator with memory (long) $830E22.l [Writes: Accumulator] [Flags: NZ]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $0E.b		; 26 0E ; Rotate left $0E.b [Reads: Direct Page] [Flags: NCZ]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $0E.b		; 25 0E ; Logical AND $0E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $010E.w		; 2D 0E 01 ; Logical AND $010E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0E2D0F.l		; 0F 0F 2D 0E ; OR accumulator with memory (long) $0E2D0F.l [Writes: Accumulator] [Flags: NZ]
	jsl $0E2C0F.l		; 22 0F 2C 0E ; Jump to subroutine long $0E2C0F.l [Writes: Stack Pointer] [Flow: call]
	cop $0F.b		; 02 0F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $2B0F.w		; 0E 0F 2B ; Arithmetic shift left $2B0F.w [Flags: NCZ]
	asl $0F22.w		; 0E 22 0F ; Arithmetic shift left $0F22.w [Flags: NCZ]
	bit $010E.w		; 2C 0E 01 ; Test bits $010E.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	ora $0E2D0F.l		; 0F 0F 2D 0E ; OR accumulator with memory (long) $0E2D0F.l [Writes: Accumulator] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $000E.w		; 2E 0E 00 ; Rotate left $000E.w [Flags: NCZ]
	cop $2E.b		; 02 2E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0F22.w		; 0E 22 0F ; Arithmetic shift left $0F22.w [Flags: NCZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl $0F22.w		; 0E 22 0F ; Arithmetic shift left $0F22.w [Flags: NCZ]
	ora ($0C.b,X)		; 01 0C ; Logical OR ($0C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $001023.l		; 0F 23 10 00 ; OR accumulator with memory (long) $001023.l [Writes: Accumulator] [Flags: NZ]
	ora $080E25.l		; 0F 25 0E 08 ; OR accumulator with memory (long) $080E25.l [Writes: Accumulator] [Flags: NZ]
	ora $0F0F10.l		; 0F 10 0F 0F ; OR accumulator with memory (long) $0F0F10.l [Writes: Accumulator] [Flags: NZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0083.w		; 0C 83 00 ; Test and set bits $0083.w [Reads: Accumulator] [Flags: Z]
	dec $26.b		; C6 26 ; Decrement $26.b [Reads: Direct Page] [Flags: NZ]
	.db $10, $05		; 10 05 ; Branch if plus to $10, $05 [Flow: branch]
	ora $101006.l		; 0F 06 10 10 ; OR accumulator with memory (long) $101006.l [Writes: Accumulator] [Flags: NZ]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$10.b]		; 27 10 ; AND accumulator with memory (long) [$10.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and #$2410.w		; 29 10 24 ; Logical AND #$2410.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $04FF.w		; 0E FF 04 ; Arithmetic shift left $04FF.w [Flags: NCZ]
	cmp $BAE0BA.l,X		; DF BA E0 BA ; Compare accumulator (long,X) $BAE0BA.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsl $E16290.l		; 22 90 62 E1 ; Jump to subroutine long $E16290.l [Writes: Stack Pointer] [Flow: call]
	ora $90.b		; 05 90 ; Logical OR $90.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx $E5.b		; E4 E5 ; Compare $E5.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $90, $90		; 90 90 ; Branch if carry clear to $90, $90 [Flow: branch]
	lda [$62.b],Y		; B7 62 ; Load accumulator (long indexed) [$62.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	inc $00.b		; E6 00 ; Increment $00.b [Reads: Direct Page] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	and $90.b,S		; 23 90 ; AND accumulator with stack relative $90.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $E9.b,S		; 63 E9 ; Add with carry (stack relative) $E9.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora [$8F.b]		; 07 8F ; OR accumulator with memory (long) [$8F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $90, $90		; 90 90 ; Branch if carry clear to $90, $90 [Flow: branch]
	sbc $EECA.w		; ED CA EE ; Subtract $EECA.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sbc $9023AB.l		; EF AB 23 90 ; Subtract with carry (long) $9023AB.l [Writes: Accumulator] [Flags: NCVZ]
	ora $94.b,S		; 03 94 ; OR accumulator with stack relative $94.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $10		; F0 10 ; Branch if equal to $F0, $10 [Flow: branch]
	sta $049022.l		; 8F 22 90 04 ; Store accumulator (long) $049022.l [Reads: Accumulator]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	.db $F0, $BA		; F0 BA ; Branch if equal to $F0, $BA [Flow: branch]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $90, $04		; 90 04 ; Branch if carry clear to $90, $04 [Flow: branch]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	sbc ($F2.b),Y		; F1 F2 ; Subtract with carry ($F2.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $90, $04		; 90 04 ; Branch if carry clear to $90, $04 [Flow: branch]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	sbc ($F4.b,S),Y		; F3 F4 ; Subtract with carry (stack relative indirect indexed) ($F4.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	inc $DA.b		; E6 DA ; Increment $DA.b [Reads: Direct Page] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $90, $04		; 90 04 ; Branch if carry clear to $90, $04 [Flow: branch]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	sbc $52.b,X		; F5 52 ; Subtract $52.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $DE.b,X		; F6 DE ; Increment memory $DE.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $90, $03		; 90 03 ; Branch if carry clear to $90, $03 [Flow: branch]
	inc $F7.b		; E6 F7 ; Increment $F7.b [Reads: Direct Page] [Flags: NZ]
	inc $DE.b,X		; F6 DE ; Increment memory $DE.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	.db $90, $02		; 90 02 ; Branch if carry clear to $90, $02 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $2CDE.w,Y		; F9 DE 2C ; Subtract with carry $2CDE.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $90, $01		; 90 01 ; Branch if carry clear to $90, $01 [Flow: branch]
	jmp.w [$2DAB]		; DC AB 2D ; Jump long indirect [$2DAB] [Flow: jump]
	.db $90, $83		; 90 83 ; Branch if carry clear to $90, $83 [Flow: branch]
	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $90, $02		; 90 02 ; Branch if carry clear to $90, $02 [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	jsr ($902A.w,X)		; FC 2A 90 ; Jump to subroutine indirect indexed ($902A.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	tsb $FD.b		; 04 FD ; Test and set bits $FD.b [Reads: Accumulator] [Flags: Z]
	inc $EE8C.w,X		; FE 8C EE ; Increment memory $EE8C.w,X [Reads: X Index] [Flags: NZ]
	sbc $010022.l,X		; FF 22 00 01 ; Subtract with carry (long,X) $010022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($FC.b,X)		; 01 FC ; Logical OR ($FC.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $90.b		; 25 90 ; Logical AND $90.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $02FD.w		; 0E FD 02 ; Arithmetic shift left $02FD.w [Flags: NCZ]
	sty $B57E.w		; 8C 7E B5 ; Store Y register to $B57E.w [Reads: Y Index]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ora $EE03.w,X		; 1D 03 EE ; OR accumulator with memory $EE03.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $FC.b		; 04 FC ; Test and set bits $FC.b [Reads: Accumulator] [Flags: Z]
	.db $90, $90		; 90 90 ; Branch if carry clear to $90, $90 [Flow: branch]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $080707.l		; 22 07 07 08 ; Jump to subroutine long $080707.l [Writes: Stack Pointer] [Flow: call]
	ora #$6A7E.w		; 09 7E 6A ; Logical OR #$6A7E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $64EE.w,X		; 1D EE 64 ; OR accumulator with memory $64EE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	jsl $C30210.l		; 22 10 02 C3 ; Jump to subroutine long $C30210.l [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($24.b),Y		; 11 24 ; OR accumulator with memory ($24.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($62.b)		; 12 62 ; OR accumulator with memory (indirect) ($62.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,S),Y		; 13 01 ; OR accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	cmp $22.b,X		; D5 22 ; Compare accumulator $22.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	dec $FF.b,X		; D6 FF ; Decrement memory $FF.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	rol $000E.w		; 2E 0E 00 ; Rotate left $000E.w [Flags: NCZ]
	.db $10, $3E		; 10 3E ; Branch if plus to $10, $3E [Flow: branch]
	asl $1000.w		; 0E 00 10 ; Arithmetic shift left $1000.w [Flags: NCZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl $1023.w		; 0E 23 10 ; Arithmetic shift left $1023.w [Flags: NCZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl $1024.w		; 0E 24 10 ; Arithmetic shift left $1024.w [Flags: NCZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl $1025.w		; 0E 25 10 ; Arithmetic shift left $1025.w [Flags: NCZ]
	and #$010E.w		; 29 0E 01 ; Logical AND #$010E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	and $010E.w		; 2D 0E 01 ; Logical AND $010E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $10, $05		; 10 05 ; Branch if plus to $10, $05 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	asl $1001.w		; 0E 01 10 ; Arithmetic shift left $1001.w [Flags: NCZ]
	.db $10, $23		; 10 23 ; Branch if plus to $10, $23 [Flow: branch]
	asl $1001.w		; 0E 01 10 ; Arithmetic shift left $1001.w [Flags: NCZ]
	ora $84.b		; 05 84 ; Logical OR $84.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $69.b		; 00 69 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$10.b]		; 27 10 ; AND accumulator with memory (long) [$10.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	and $1023.w,X		; 3D 23 10 ; AND accumulator with memory $1023.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $0E2210.l		; 22 10 22 0E ; Jump to subroutine long $0E2210.l [Writes: Stack Pointer] [Flow: call]
	cop $10.b		; 02 10 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $10.b		; 25 10 ; Logical AND $10.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $0E2410.l		; 22 10 24 0E ; Jump to subroutine long $0E2410.l [Writes: Stack Pointer] [Flow: call]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	.db $10, $23		; 10 23 ; Branch if plus to $10, $23 [Flow: branch]
	asl $1002.w		; 0E 02 10 ; Arithmetic shift left $1002.w [Flags: NCZ]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	and $0010.w		; 2D 10 00 ; Logical AND $0010.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $103A.w		; 0D 3A 10 ; Logical OR $103A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cop $0E.b		; 02 0E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	sbc $009022.l,X		; FF 22 90 00 ; Subtract with carry (long,X) $009022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	pea $9029.w		; F4 29 90 ; Push absolute address $9029.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	ora ($FD.b,X)		; 01 FD ; Logical OR ($FD.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $25.b,X		; 16 25 ; Arithmetic shift left $25.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $90, $00		; 90 00 ; Branch if carry clear to $90, $00 [Flow: branch]
	pea $9026.w		; F4 26 90 ; Push absolute address $9026.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	ora ($FD.b,X)		; 01 FD ; Logical OR ($FD.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	adc [$22.b]		; 67 22 ; Add with carry (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $90, $00		; 90 00 ; Branch if carry clear to $90, $00 [Flow: branch]
	pea $9029.w		; F4 29 90 ; Push absolute address $9029.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	ora ($FD.b,X)		; 01 FD ; Logical OR ($FD.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $25.b,X		; 16 25 ; Arithmetic shift left $25.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $90, $00		; 90 00 ; Branch if carry clear to $90, $00 [Flow: branch]
	pea $9023.w		; F4 23 90 ; Push absolute address $9023.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	tsb $17.b		; 04 17 ; Test and set bits $17.b [Reads: Accumulator] [Flags: Z]
	tsb $1918.w		; 0C 18 19 ; Test and set bits $1918.w [Reads: Accumulator] [Flags: Z]
	adc [$22.b]		; 67 22 ; Add with carry (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $90, $00		; 90 00 ; Branch if carry clear to $90, $00 [Flow: branch]
	pea $9025.w		; F4 25 90 ; Push absolute address $9025.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	stz $1A.b		; 64 1A ; Store zero to $1A.b
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $90.b		; 25 90 ; Logical AND $90.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $1F6490.l		; 22 90 64 1F ; Jump to subroutine long $1F6490.l [Writes: Stack Pointer] [Flow: call]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $F40090.l		; 22 90 00 F4 ; Jump to subroutine long $F40090.l [Writes: Stack Pointer] [Flow: call]
	and $90.b		; 25 90 ; Logical AND $90.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $23.b		; 25 23 ; Logical AND $23.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc [$25.b]		; 67 25 ; Add with carry (long) [$25.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $90, $00		; 90 00 ; Branch if carry clear to $90, $00 [Flow: branch]
	pea $9022.w		; F4 22 90 ; Push absolute address $9022.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	cop $26.b		; 02 26 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $C4.b,X		; B5 C4 ; Load $C4.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $902267.l		; 22 67 22 90 ; Jump to subroutine long $902267.l [Writes: Stack Pointer] [Flow: call]
	asl $90F4.w		; 0E F4 90 ; Arithmetic shift left $90F4.w [Flags: NCZ]
	and [$28.b]		; 27 28 ; AND accumulator with memory (long) [$28.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $90, $F3		; 90 F3 ; Branch if carry clear to $90, $F3 [Flow: branch]
	.db $90, $94		; 90 94 ; Branch if carry clear to $90, $94 [Flow: branch]
	and #$C4B5.w		; 29 B5 C4 ; Logical AND #$C4B5.w with accumulator [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl $90.b,X		; 16 90 ; Arithmetic shift left $90.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $90, $67		; 90 67 ; Branch if carry clear to $90, $67 [Flow: branch]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	bit #$3303.w		; 89 03 33 ; Test bits #$3303.w with accumulator [Reads: Accumulator] [Flags: Z]
	bit $90.b,X		; 34 90 ; Test bits $90.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $90, $63		; 90 63 ; Branch if carry clear to $90, $63 [Flow: branch]
	and $00.b,X		; 35 00 ; Logical AND $00.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc [$62.b]		; 67 62 ; Add with carry (long) [$62.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and $DB05.w,Y		; 39 05 DB ; AND accumulator with memory $DB05.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $90, $94		; 90 94 ; Branch if carry clear to $90, $94 [Flow: branch]
	and #$F85A.w		; 29 5A F8 ; Logical AND #$F85A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	adc $3C.b		; 65 3C ; Add $3C.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	brk $67.b		; 00 67 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $42, $22		; 62 42 22 ; Push effective relative address $62, $42, $22 [Writes: Stack Pointer]
	.db $90, $02		; 90 02 ; Branch if carry clear to $90, $02 [Flow: branch]
	sty $F0.b,X		; 94 F0 ; Store Y register $F0.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	.db $10, $63		; 10 63 ; Branch if plus to $10, $63 [Flow: branch]
	eor $00.b		; 45 00 ; Exclusive OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	ror $49.b		; 66 49 ; Rotate right $49.b [Reads: Direct Page] [Flags: NCZ]
	brk $DB.b		; 00 DB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $500290.l		; 22 90 02 50 ; Jump to subroutine long $500290.l [Writes: Stack Pointer] [Flow: call]
	eor ($FD.b),Y		; 51 FD ; Exclusive OR accumulator with memory ($FD.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	stz $52.b		; 64 52 ; Store zero to $52.b
	cop $4D.b		; 02 4D ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor [$58.b],Y		; 57 58 ; Exclusive OR accumulator with memory (long indexed) [$58.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $0C.b		; 24 0C ; Test bits $0C.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	eor $5A5A.w,Y		; 59 5A 5A ; Exclusive OR accumulator with memory $5A5A.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tsb $5B0C.w		; 0C 0C 5B ; Test and set bits $5B0C.w [Reads: Accumulator] [Flags: Z]
	jmp $620C0C.l		; 5C 0C 0C 62 ; Jump long to $620C0C.l [Flow: jump]
	eor $1423.w,X		; 5D 23 14 ; Exclusive OR accumulator with memory $1423.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cop $60.b		; 02 60 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	adc ($26.b,X)		; 61 26 ; Add with carry ($26.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	trb $62.b		; 14 62 ; Test and reset bits $62.b [Reads: Accumulator] [Flags: Z]
	.db $62, $02, $D6		; 62 02 D6 ; Push effective relative address $62, $02, $D6 [Writes: Stack Pointer]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc $FF.b		; 65 FF ; Add $FF.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $0E10.w		; 0E 10 0E ; Arithmetic shift left $0E10.w [Flags: NCZ]
	asl $1010.w		; 0E 10 10 ; Arithmetic shift left $1010.w [Flags: NCZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $10.b		; 24 10 ; Test bits $10.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	jsl $050301.l		; 22 01 03 05 ; Jump to subroutine long $050301.l [Writes: Stack Pointer] [Flow: call]
	asl $0E0F.w		; 0E 0F 0E ; Arithmetic shift left $0E0F.w [Flags: NCZ]
	and $10.b,S		; 23 10 ; AND accumulator with stack relative $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $020310.l		; 22 10 03 02 ; Jump to subroutine long $020310.l [Writes: Stack Pointer] [Flow: call]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	ora ($43.b,X)		; 01 43 ; Logical OR ($43.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $10, $0E		; 10 0E ; Branch if plus to $10, $0E [Flow: branch]
	eor $0E.b,S		; 43 0E ; Exclusive OR accumulator with stack relative $0E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $10, $0B		; 10 0B ; Branch if plus to $10, $0B [Flow: branch]
	tsb $0E10.w		; 0C 10 0E ; Test and set bits $0E10.w [Reads: Accumulator] [Flags: Z]
	ora $000601.l		; 0F 01 06 00 ; OR accumulator with memory (long) $000601.l [Writes: Accumulator] [Flags: NZ]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	ora ($0E.b,X)		; 01 0E ; Logical OR ($0E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $1025.w		; 0E 25 10 ; Arithmetic shift left $1025.w [Flags: NCZ]
	.db $62, $0E, $01		; 62 0E 01 ; Push effective relative address $62, $0E, $01 [Writes: Stack Pointer]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $0E0001.l		; 22 01 00 0E ; Jump to subroutine long $0E0001.l [Writes: Stack Pointer] [Flow: call]
	and $10.b,S		; 23 10 ; AND accumulator with stack relative $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $0E.b		; 06 0E ; Arithmetic shift left $0E.b [Reads: Direct Page] [Flags: NCZ]
	ora $10.b,S		; 03 10 ; OR accumulator with stack relative $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ora ($22.b)		; 12 22 ; OR accumulator with memory (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $100C.w		; 0E 0C 10 ; Arithmetic shift left $100C.w [Flags: NCZ]
	.db $10, $0E		; 10 0E ; Branch if plus to $10, $0E [Flow: branch]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: NCZ]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $10.b		; 02 10 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $10.b,S		; 03 10 ; OR accumulator with stack relative $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $10090E.l		; 22 0E 09 10 ; Jump to subroutine long $10090E.l [Writes: Stack Pointer] [Flow: call]
	.db $10, $0E		; 10 0E ; Branch if plus to $10, $0E [Flow: branch]
	cop $10.b		; 02 10 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($0E.b,X)		; 01 0E ; Logical OR ($0E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $1022.w		; 0E 22 10 ; Arithmetic shift left $1022.w [Flags: NCZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $031022.l		; 0F 22 10 03 ; OR accumulator with memory (long) $031022.l [Writes: Accumulator] [Flags: NZ]
	ora $091010.l		; 0F 10 10 09 ; OR accumulator with memory (long) $091010.l [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ror $1022.w,X		; 7E 22 10 ; Rotate right $1022.w,X [Reads: X Index] [Flags: NCZ]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $830006.l		; 0F 06 00 83 ; OR accumulator with memory (long) $830006.l [Writes: Accumulator] [Flags: NZ]
	brk $89.b		; 00 89 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	ora $02.b		; 05 02 ; Logical OR $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $020110.l		; 22 10 01 02 ; Jump to subroutine long $020110.l [Writes: Stack Pointer] [Flow: call]
	ora $021022.l		; 0F 22 10 02 ; OR accumulator with memory (long) $021022.l [Writes: Accumulator] [Flags: NZ]
	ora $220904.l		; 0F 04 09 22 ; OR accumulator with memory (long) $220904.l [Writes: Accumulator] [Flags: NZ]
	.db $10, $03		; 10 03 ; Branch if plus to $10, $03 [Flow: branch]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $10, $05		; 10 05 ; Branch if plus to $10, $05 [Flow: branch]
	jsl $0B0110.l		; 22 10 01 0B ; Jump to subroutine long $0B0110.l [Writes: Stack Pointer] [Flow: call]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $89.b		; 00 89 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $0A0E.w		; 0E 0E 0A ; Arithmetic shift left $0A0E.w [Flags: NCZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $10.b,S		; 23 10 ; AND accumulator with stack relative $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0F.b		; 05 0F ; Logical OR $0F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $10.b		; 05 10 ; Logical OR $10.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $03		; 10 03 ; Branch if plus to $10, $03 [Flow: branch]
	.db $10, $22		; 10 22 ; Branch if plus to $10, $22 [Flow: branch]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $10, $01		; 10 01 ; Branch if plus to $10, $01 [Flow: branch]
	asl $230E.w		; 0E 0E 23 ; Arithmetic shift left $230E.w [Flags: NCZ]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	asl $0083.w		; 0E 83 00 ; Arithmetic shift left $0083.w [Flags: NCZ]
	mvn $01,$00		; 54 00 01 ; Move block negative $01,$00 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	jsl $0E0110.l		; 22 10 01 0E ; Jump to subroutine long $0E0110.l [Writes: Stack Pointer] [Flow: call]
	.db $10, $24		; 10 24 ; Branch if plus to $10, $24 [Flow: branch]
	asl $0083.w		; 0E 83 00 ; Arithmetic shift left $0083.w [Flags: NCZ]
	cmp $1023.w,Y		; D9 23 10 ; Compare accumulator $1023.w,Y [Reads: Y Index] [Flags: NCZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	asl $0E02.w,X		; 1E 02 0E ; Arithmetic shift left $0E02.w,X [Reads: X Index] [Flags: NCZ]
	asl $2210.w		; 0E 10 22 ; Arithmetic shift left $2210.w [Flags: NCZ]
	asl $1000.w		; 0E 00 10 ; Arithmetic shift left $1000.w [Flags: NCZ]
	jsl $01FF03.l		; 22 03 FF 01 ; Jump to subroutine long $01FF03.l [Writes: Stack Pointer] [Flow: call]
	ror $09.b		; 66 09 ; Rotate right $09.b [Reads: Direct Page] [Flags: NCZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cop $C4.b		; 02 C4 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc [$E6.b]		; 67 E6 ; Add with carry (long) [$E6.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $62, $67, $01		; 62 67 01 ; Push effective relative address $62, $67, $01 [Writes: Stack Pointer]
	trb $15.b		; 14 15 ; Test and reset bits $15.b [Reads: Accumulator] [Flags: Z]
	adc $6A.b,S		; 63 6A ; Add with carry (stack relative) $6A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	brk $69.b		; 00 69 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $B50315.l		; 22 15 03 B5 ; Jump to subroutine long $B50315.l [Writes: Stack Pointer] [Flow: call]
	cpy $DF.b		; C4 DF ; Compare $DF.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	adc [$63.b]		; 67 63 ; Add with carry (long) [$63.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ror $231B.w		; 6E 1B 23 ; Rotate right $231B.w [Flags: NCZ]
	adc ($73.b)		; 72 73 ; Add with carry (indirect) ($73.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ror $7402.w		; 6E 02 74 ; Rotate right $7402.w [Flags: NCZ]
	adc $22.b,X		; 75 22 ; Add $22.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $F6.b,X		; 76 F6 ; Rotate right $F6.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc [$A8.b]		; 67 A8 ; Add with carry (long) [$A8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc [$67.b],Y		; 77 67 ; Add with carry (long indexed) [$67.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cop $79.b		; 02 79 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $8C.b,S		; C3 8C ; Compare accumulator (stack relative) $8C.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	asl $1D6A.w,X		; 1E 6A 1D ; Arithmetic shift left $1D6A.w,X [Reads: X Index] [Flags: NCZ]
	lda $977177.l,X		; BF 77 71 97 ; Load long $977177.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $7A.b		; 64 7A ; Store zero to $7A.b
	cpx #$794B.w		; E0 4B 79 ; Compare #$794B.w with X register [Reads: X Index] [Flags: NCZ]
	sta [$8C.b],Y		; 97 8C ; Store accumulator (long indexed) [$8C.b],Y [Reads: Direct Page, Y Index, Accumulator]
	adc $418A1D.l,X		; 7F 1D 8A 41 ; Add long $418A1D.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	jmp $232367.l		; 5C 67 23 23 ; Jump long to $232367.l [Flow: jump]
	.db $80, $81		; 80 81 ; Branch always to $80, $81 [Flow: branch]
	cpy $82E6.w		; CC E6 82 ; Compare $82E6.w with Y register [Reads: Y Index] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $8A.b,S		; 83 8A ; Store accumulator (stack relative) $8A.b,S [Reads: Stack Pointer, Accumulator]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sty $52.b		; 84 52 ; Store Y register to $52.b [Reads: Y Index]
	eor ($85.b,S),Y		; 53 85 ; XOR accumulator (stack relative indirect indexed) ($85.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldy $67.b,X		; B4 67 ; Load Y register $67.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	adc [$86.b]		; 67 86 ; Add with carry (long) [$86.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta [$CC.b]		; 87 CC ; Store accumulator (long) [$CC.b] [Reads: Direct Page, Accumulator]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr $22.b,X		; 56 22 ; Logical shift right $22.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	bit #$501D.w		; 89 1D 50 ; Test bits #$501D.w with accumulator [Reads: Accumulator] [Flags: Z]
	eor ($33.b),Y		; 51 33 ; Exclusive OR accumulator with memory ($33.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jmp $6767.w		; 4C 67 67 ; Jump to $6767.w [Flow: jump]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta [$CC.b]		; 87 CC ; Store accumulator (long) [$CC.b] [Reads: Direct Page, Accumulator]
	sed		; F8 ; Set decimal flag [Flags: D]
	bit #$A98B.w		; 89 8B A9 ; Test bits #$A98B.w with accumulator [Reads: Accumulator] [Flags: Z]
	adc $C58C.w,Y		; 79 8C C5 ; Add $C58C.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr $57.b,X		; 56 57 ; Logical shift right $57.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	adc [$67.b]		; 67 67 ; Add with carry (long) [$67.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sty $8D87.w		; 8C 87 8D ; Store Y register to $8D87.w [Reads: Y Index]
	cop $8C.b		; 02 8C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stx $798F.w		; 8E 8F 79 ; Store X register to $798F.w [Reads: X Index]
	sty $8F8E.w		; 8C 8E 8F ; Store Y register to $8F8E.w [Reads: Y Index]
	cmp $E5BA.w,Y		; D9 BA E5 ; Compare accumulator $E5BA.w,Y [Reads: Y Index] [Flags: NCZ]
	jmp $624C.w		; 4C 4C 62 ; Jump to $624C.w [Flow: jump]
	.db $90, $0C		; 90 0C ; Branch if carry clear to $90, $0C [Flow: branch]
	adc #$6A8C.w		; 69 8C 6A ; Add #$6A8C.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	adc $938C.w,Y		; 79 8C 93 ; Add $938C.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sty $8D.b,X		; 94 8D ; Store Y register $8D.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	jmp $F8F8.w		; 4C F8 F8 ; Jump to $F8F8.w [Flow: jump]
	.db $62, $95, $00		; 62 95 00 ; Push effective relative address $62, $95, $00 [Writes: Stack Pointer]
	adc #$0084.w		; 69 84 00 ; Add #$0084.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	stx $08.b		; 86 08 ; Store X register to $08.b [Reads: X Index]
	lda $0F98FC.l,X		; BF FC 98 0F ; Load long $0F98FC.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $1010.w,Y		; 99 10 10 ; Store accumulator to $1010.w,Y [Reads: Y Index, Accumulator]
	stx $FF.b,Y		; 96 FF ; Store X register $FF.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	.db $62, $9A, $E0		; 62 9A E0 ; Push effective relative address $62, $9A, $E0 [Writes: Stack Pointer]
	rol $4E.b,X		; 36 4E ; Rotate left $4E.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	eor ($79.b,X)		; 41 79 ; Exclusive OR accumulator with memory ($79.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sty $9E9D.w		; 8C 9D 9E ; Store Y register to $9E9D.w [Reads: Y Index]
	asl $F8.b,X		; 16 F8 ; Arithmetic shift left $F8.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sta [$14.b],Y		; 97 14 ; Store accumulator (long indexed) [$14.b],Y [Reads: Direct Page, Y Index, Accumulator]
	sbc $0E9AFF.l,X		; FF FF 9A 0E ; Subtract with carry (long,X) $0E9AFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $5C4059.l,X		; 9F 59 40 5C ; Store accumulator (long,X) $5C4059.l,X [Reads: Accumulator, X Index]
	ldy #$8DA1.w		; A0 A1 8D ; Load #$8DA1.w into Y register [Writes: Y Index] [Flags: NZ]
	ldx #$0903.w		; A2 03 09 ; Load #$0903.w into X register [Writes: X Index] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lda $A3.b,S		; A3 A3 ; Load accumulator (stack relative) $A3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldy $0E.b		; A4 0E ; Load $0E.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	adc [$2A.b]		; 67 2A ; Add with carry (long) [$2A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda $10.b		; A5 10 ; Load $10.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $AF.b		; 85 AF ; Store accumulator to $AF.b [Reads: Accumulator]
	mvp $A6,$8D		; 44 8D A6 ; Move block positive $A6,$8D [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora ($15.b,S),Y		; 13 15 ; OR accumulator (stack relative indirect indexed) ($15.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	trb $14.b		; 14 14 ; Test and reset bits $14.b [Reads: Accumulator] [Flags: Z]
	ora $D8.b,X		; 15 D8 ; OR accumulator with memory $D8.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lda [$C3.b]		; A7 C3 ; Load accumulator (long) [$C3.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc [$97.b]		; 67 97 ; Add with carry (long) [$97.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inc $67.b		; E6 67 ; Increment $67.b [Reads: Direct Page] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $638D44.l		; AF 44 8D 63 ; Load long $638D44.l into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$C30D.w		; A9 0D C3 ; Load #$C30D.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp $97ADB7.l,X		; DF B7 AD 97 ; Compare accumulator (long,X) $97ADB7.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	adc [$A8.b]		; 67 A8 ; Add with carry (long) [$A8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta [$B4.b],Y		; 97 B4 ; Store accumulator (long indexed) [$B4.b],Y [Reads: Direct Page, Y Index, Accumulator]
	adc [$AE.b]		; 67 AE ; Add with carry (long) [$AE.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	sbc $0F0F09.l,X		; FF 09 0F 0F ; Subtract with carry (long,X) $0F0F09.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $10.b,S		; 03 10 ; OR accumulator with stack relative $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $44		; 10 44 ; Branch if plus to $10, $44 [Flow: branch]
	ora $0F.b		; 05 0F ; Logical OR $0F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $021110.l		; 22 10 11 02 ; Jump to subroutine long $021110.l [Writes: Stack Pointer] [Flow: call]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $10.b,S		; 03 10 ; OR accumulator with stack relative $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $10, $09		; 10 09 ; Branch if plus to $10, $09 [Flow: branch]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $0D10.w		; 0D 10 0D ; Logical OR $0D10.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0083.w		; 0D 83 00 ; Logical OR $0083.w with accumulator [Writes: Accumulator] [Flags: NZ]
	trb $0F.b		; 14 0F ; Test and reset bits $0F.b [Reads: Accumulator] [Flags: Z]
	ora $10.b		; 05 10 ; Logical OR $10.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $05		; 10 05 ; Branch if plus to $10, $05 [Flow: branch]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $1010.w		; 0E 10 10 ; Arithmetic shift left $1010.w [Flags: NCZ]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $008305.l		; 0F 05 83 00 ; OR accumulator with memory (long) $008305.l [Writes: Accumulator] [Flags: NZ]
	asl $43.b		; 06 43 ; Arithmetic shift left $43.b [Reads: Direct Page] [Flags: NCZ]
	asl $0001.w		; 0E 01 00 ; Arithmetic shift left $0001.w [Flags: NCZ]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $36.b		; 00 36 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $080210.l		; 22 10 02 08 ; Jump to subroutine long $080210.l [Writes: Stack Pointer] [Flow: call]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $10.b		; 25 10 ; Logical AND $10.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $05.b		; 24 05 ; Test bits $05.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $100105.l		; 22 05 01 10 ; Jump to subroutine long $100105.l [Writes: Stack Pointer] [Flow: call]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $10, $01		; 10 01 ; Branch if plus to $10, $01 [Flow: branch]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $050705.l		; 0F 05 07 05 ; OR accumulator with memory (long) $050705.l [Writes: Accumulator] [Flags: NZ]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	ora $1010.w		; 0D 10 10 ; Logical OR $1010.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $05220A.l		; 22 0A 22 05 ; Jump to subroutine long $05220A.l [Writes: Stack Pointer] [Flow: call]
	ora $10.b		; 05 10 ; Logical OR $10.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: NCZ]
	.db $10, $03		; 10 03 ; Branch if plus to $10, $03 [Flow: branch]
	ora $09.b		; 05 09 ; Logical OR $09.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $220F.w		; 0E 0F 22 ; Arithmetic shift left $220F.w [Flags: NCZ]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$1022.w		; 09 22 10 ; Logical OR #$1022.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $1022.w		; 0E 22 10 ; Arithmetic shift left $1022.w [Flags: NCZ]
	ora #$0707.w		; 09 07 07 ; Logical OR #$0707.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $10, $05		; 10 05 ; Branch if plus to $10, $05 [Flow: branch]
	.db $10, $09		; 10 09 ; Branch if plus to $10, $09 [Flow: branch]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $250F.w		; 0C 0F 25 ; Test and set bits $250F.w [Reads: Accumulator] [Flags: Z]
	.db $10, $07		; 10 07 ; Branch if plus to $10, $07 [Flow: branch]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $05100F.l		; 0F 0F 10 05 ; OR accumulator with memory (long) $05100F.l [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $83.b		; 05 83 ; Logical OR $83.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $73.b		; 00 73 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $0A.b		; 06 0A ; Arithmetic shift left $0A.b [Reads: Direct Page] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $10, $08		; 10 08 ; Branch if plus to $10, $08 [Flow: branch]
	ora [$09.b]		; 07 09 ; OR accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $07		; 10 07 ; Branch if plus to $10, $07 [Flow: branch]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ldy $0501.w		; AC 01 05 ; Load $0501.w into Y register [Writes: Y Index] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	jsl $102205.l		; 22 05 22 10 ; Jump to subroutine long $102205.l [Writes: Stack Pointer] [Flow: call]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $10.b		; 25 10 ; Logical AND $10.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	jsl $008310.l		; 22 10 83 00 ; Jump to subroutine long $008310.l [Writes: Stack Pointer] [Flow: call]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	asl $05.b		; 06 05 ; Arithmetic shift left $05.b [Reads: Direct Page] [Flags: NCZ]
	ora $102C05.l		; 0F 05 2C 10 ; OR accumulator with memory (long) $102C05.l [Writes: Accumulator] [Flags: NZ]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $012310.l		; 22 10 23 01 ; Jump to subroutine long $012310.l [Writes: Stack Pointer] [Flow: call]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $1003.w		; 0D 03 10 ; Logical OR $1003.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $1003.w		; 0D 03 10 ; Logical OR $1003.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($02.b),Y		; 11 02 ; OR accumulator with memory ($02.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	ora ($01.b),Y		; 11 01 ; OR accumulator with memory ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $377C09.l,X		; FF 09 7C 37 ; Subtract with carry (long,X) $377C09.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr $6AB2.w		; 4E B2 6A ; Logical shift right $6AB2.w [Flags: NCZ]
	ldx $AF.b,Y		; B6 AF ; Load X register $AF.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	sta $E5.b,X		; 95 E5 ; Store accumulator to $E5.b,X [Reads: Accumulator, X Index]
	.db $B0, $44		; B0 44 ; Branch if carry set to $B0, $44 [Flow: branch]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $B162.w,Y		; B9 62 B1 ; Load $B162.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$D23D.w		; E0 3D D2 ; Compare #$D23D.w with X register [Reads: X Index] [Flags: NCZ]
	dec $44.b		; C6 44 ; Decrement $44.b [Reads: Direct Page] [Flags: NZ]
	mvp $B5,$B4		; 44 B4 B5 ; Move block positive $B5,$B4 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	ldx $B7.b,Y		; B6 B7 ; Load X register $B7.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	lda $A6B2.w,Y		; B9 B2 A6 ; Load $A6B2.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	ldx $A9.b		; A6 A9 ; Load $A9.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ldy $BDD7.w,X		; BC D7 BD ; Load Y register $BDD7.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda [$A8.b],Y		; B7 A8 ; Load accumulator (long indexed) [$A8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ldx $E5B9.w,Y		; BE B9 E5 ; Load X register $E5B9.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	bit $06.b		; 24 06 ; Test bits $06.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sbc ($06.b)		; F2 06 ; Subtract with carry (indirect) ($06.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda $C1C0D6.l,X		; BF D6 C0 C1 ; Load long $C1C0D6.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$978E]		; DC 8E 97 ; Jump long indirect [$978E] [Flow: jump]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $C2A8.w,Y		; B9 A8 C2 ; Load $C2A8.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $E5.b		; 24 E5 ; Test bits $E5.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cmp $7C.b,S		; C3 7C ; Compare accumulator (stack relative) $7C.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	asl $E1.b		; 06 E1 ; Arithmetic shift left $E1.b [Reads: Direct Page] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc $DCC4.w,X		; FD C4 DC ; Subtract with carry $DCC4.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	stx $B797.w		; 8E 97 B7 ; Store X register to $B797.w [Reads: X Index]
	cmp $C6.b		; C5 C6 ; Compare $C6.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	lda ($E5.b)		; B2 E5 ; Load accumulator (indirect) ($E5.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $65.b		; 24 65 ; Test bits $65.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cmp [$06.b]		; C7 06 ; Compare accumulator (long) [$06.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	mvn $8E,$8D		; 54 8D 8E ; Move block negative $8E,$8D [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sta [$C1.b],Y		; 97 C1 ; Store accumulator (long indexed) [$C1.b],Y [Reads: Direct Page, Y Index, Accumulator]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	cmp $E522.w		; CD 22 E5 ; Compare $E522.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora ($CE.b,X)		; 01 CE ; Logical OR ($CE.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $62, $CF, $1B		; 62 CF 1B ; Push effective relative address $62, $CF, $1B [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc $8ED2.w,X		; FD D2 8E ; Subtract with carry $8ED2.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta [$B7.b],Y		; 97 B7 ; Store accumulator (long indexed) [$B7.b],Y [Reads: Direct Page, Y Index, Accumulator]
	dec $96.b		; C6 96 ; Decrement $96.b [Reads: Direct Page] [Flags: NZ]
	sbc $3B.b		; E5 3B ; Subtract $3B.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cpx $D3.b		; E4 D3 ; Compare $D3.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	pei ($76.b)		; D4 76 ; Push effective indirect address ($76.b) [Reads: Direct Page] [Writes: Stack Pointer]
	cmp $D6.b,X		; D5 D6 ; Compare accumulator $D6.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	and $FD.b		; 25 FD ; Logical AND $FD.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor ($8E.b,X)		; 41 8E ; Exclusive OR accumulator with memory ($8E.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$D7CA.w		; C9 CA D7 ; Compare #$D7CA.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	sbc $3B.b		; E5 3B ; Subtract $3B.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $E5.b		; E5 E5 ; Subtract $E5.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sty $62.b,X		; 94 62 ; Store Y register $62.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	cld		; D8 ; Clear decimal flag [Flags: D]
	ora [$B8.b]		; 07 B8 ; OR accumulator with memory (long) [$B8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	jmp.w [$8096]		; DC 96 80 ; Jump long indirect [$8096] [Flow: jump]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	sta $00E522.l,X		; 9F 22 E5 00 ; Store accumulator (long,X) $00E522.l,X [Reads: Accumulator, X Index]
	rol $DD62.w,X		; 3E 62 DD ; Rotate left $DD62.w,X [Reads: X Index] [Flags: NCZ]
	ora ($0C.b,X)		; 01 0C ; Logical OR ($0C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $E062.w		; 0D 62 E0 ; Logical OR $E062.w with accumulator [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	jsl $C1E31C.l		; 22 1C E3 C1 ; Jump to subroutine long $C1E31C.l [Writes: Stack Pointer] [Flow: call]
.ACCU 16
.INDEX 16
	rep #$3E		; C2 3E
	sbc $3B.b		; E5 3B ; Subtract $3B.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda $EC.b,X		; B5 EC ; Load $EC.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cpx $E5.b		; E4 E5 ; Compare $E5.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	adc $E5.b,S		; 63 E5 ; Add with carry (stack relative) $E5.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $2495.w,X		; 1D 95 24 ; OR accumulator with memory $2495.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	stx $E98F.w		; 8E 8F E9 ; Store X register to $E98F.w [Reads: X Index]
	cpx $B2.b		; E4 B2 ; Compare $B2.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	cpx $D0.b		; E4 D0 ; Compare $D0.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	stx $14.b,Y		; 96 14 ; Store X register $14.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	trb $09.b		; 14 09 ; Test and reset bits $09.b [Reads: Accumulator] [Flags: Z]
	.db $F0, $14		; F0 14 ; Branch if equal to $F0, $14 [Flow: branch]
	nop		; EA ; No operation
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $42, $4F		; 42 4F ; Reserved instruction
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpx $DFE5.w		; EC E5 DF ; Compare $DFE5.w with X register [Reads: X Index] [Flags: NCZ]
	sbc $FF14EC.l,X		; FF EC 14 FF ; Subtract with carry (long,X) $FF14EC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx $62FF.w		; EC FF 62 ; Compare $62FF.w with X register [Reads: X Index] [Flags: NCZ]
	sbc $CB00.w		; ED 00 CB ; Subtract $CB00.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	adc $F0.b		; 65 F0 ; Add $F0.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cop $FF.b		; 02 FF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$6209.w		; 09 09 62 ; Logical OR #$6209.w with accumulator [Writes: Accumulator] [Flags: NZ]
	inc $09.b,X		; F6 09 ; Increment memory $09.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	sbc $F9EEFF.l,X		; FF FF EE F9 ; Subtract with carry (long,X) $F9EEFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $EC09.w,X		; FE 09 EC ; Increment memory $EC09.w,X [Reads: X Index] [Flags: NZ]
	rol $F4.b		; 26 F4 ; Rotate left $F4.b [Reads: Direct Page] [Flags: NCZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	jsl $FB6207.l		; 22 07 62 FB ; Jump to subroutine long $FB6207.l [Writes: Stack Pointer] [Flow: call]
	ora #$FEF7.w		; 09 F7 FE ; Logical OR #$FEF7.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $5006A4.l,X		; FF A4 06 50 ; Subtract with carry (long,X) $5006A4.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $A4.b		; 00 A4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	jsl $EC0CEB.l		; 22 EB 0C EC ; Jump to subroutine long $EC0CEB.l [Writes: Stack Pointer] [Flow: call]
	sta $F1144A.l,X		; 9F 4A 14 F1 ; Store accumulator (long,X) $F1144A.l,X [Reads: Accumulator, X Index]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $01.b,X		; 15 01 ; OR accumulator with memory $01.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($61.b),Y		; D1 61 ; Compare accumulator ($61.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	ora $01.b,X		; 15 01 ; OR accumulator with memory $01.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sbc $060718.l,X		; FF 18 07 06 ; Subtract with carry (long,X) $060718.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $11.b		; 02 11 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b),Y		; 11 03 ; OR accumulator with memory ($03.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $09.b,S		; 03 09 ; OR accumulator with stack relative $09.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora #$1105.w		; 09 05 11 ; Logical OR #$1105.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($09.b,X)		; 01 09 ; Logical OR ($09.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $05.b,S		; 23 05 ; AND accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $071101.l		; 0F 01 11 07 ; OR accumulator with memory (long) $071101.l [Writes: Accumulator] [Flags: NZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $0511.w		; 0E 11 05 ; Arithmetic shift left $0511.w [Flags: NCZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$43.b]		; 07 43 ; OR accumulator with memory (long) [$43.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0F.b		; 05 0F ; Logical OR $0F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $08.b		; 05 08 ; Logical OR $08.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $10.b		; 05 10 ; Logical OR $10.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($22.b),Y		; 11 22 ; OR accumulator with memory ($22.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $0A.b		; 05 0A ; Logical OR $0A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $010E01.l		; 0F 01 0E 01 ; OR accumulator with memory (long) $010E01.l [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$1123.w		; 09 23 11 ; Logical OR #$1123.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $08.b		; 05 08 ; Logical OR $08.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$09.b]		; 07 09 ; OR accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$11.b]		; 07 11 ; OR accumulator with memory (long) [$11.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b),Y		; 11 01 ; OR accumulator with memory ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tsb $0C09.w		; 0C 09 0C ; Test and set bits $0C09.w [Reads: Accumulator] [Flags: Z]
	bit $11.b		; 24 11 ; Test bits $11.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $05.b		; 24 05 ; Test bits $05.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $100605.l		; 22 05 06 10 ; Jump to subroutine long $100605.l [Writes: Stack Pointer] [Flow: call]
	ora $11.b		; 05 11 ; Logical OR $11.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $07		; 10 07 ; Branch if plus to $10, $07 [Flow: branch]
	ora #$2408.w		; 09 08 24 ; Logical OR #$2408.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $09.b,S		; 03 09 ; OR accumulator with stack relative $09.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($10.b),Y		; 11 10 ; OR accumulator with memory ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $05.b,S		; 23 05 ; AND accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $090505.l		; 0F 05 05 09 ; OR accumulator with memory (long) $090505.l [Writes: Accumulator] [Flags: NZ]
	ora $11.b		; 05 11 ; Logical OR $11.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $0F.b,S		; 23 0F ; AND accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($09.b,X)		; 01 09 ; Logical OR ($09.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$23.b]		; 07 23 ; OR accumulator with memory (long) [$23.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $44.b		; 05 44 ; Logical OR $44.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $11.b		; 24 11 ; Test bits $11.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$2207.w		; 09 07 22 ; Logical OR #$2207.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $050411.l		; 22 11 04 05 ; Jump to subroutine long $050411.l [Writes: Stack Pointer] [Flow: call]
	ora $0F.b		; 05 0F ; Logical OR $0F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $0F.b		; 24 0F ; Test bits $0F.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	jsl $110107.l		; 22 07 01 11 ; Jump to subroutine long $110107.l [Writes: Stack Pointer] [Flow: call]
	ora $23.b		; 05 23 ; Logical OR $23.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $001128.l		; 0F 28 11 00 ; OR accumulator with memory (long) $001128.l [Writes: Accumulator] [Flags: NZ]
	asl $83.b		; 06 83 ; Arithmetic shift left $83.b [Reads: Direct Page] [Flags: NCZ]
	brk $B8.b		; 00 B8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $05.b,S		; 23 05 ; AND accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $11.b,S		; 23 11 ; AND accumulator with stack relative $11.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	tsb $100A.w		; 0C 0A 10 ; Test and set bits $100A.w [Reads: Accumulator] [Flags: Z]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $10.b		; 24 10 ; Test bits $10.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $110010.l		; 22 10 00 11 ; Jump to subroutine long $110010.l [Writes: Stack Pointer] [Flow: call]
	and $10.b		; 25 10 ; Logical AND $10.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $1023.w		; 0E 23 10 ; Arithmetic shift left $1023.w [Flags: NCZ]
	cop $0F.b		; 02 0F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $10.b		; 24 10 ; Test bits $10.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora [$11.b]		; 07 11 ; OR accumulator with memory (long) [$11.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $0F.b		; 06 0F ; Arithmetic shift left $0F.b [Reads: Direct Page] [Flags: NCZ]
	ora $1003.w		; 0D 03 10 ; Logical OR $1003.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $FF11.w		; 0D 11 FF ; Logical OR $FF11.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cpx #$3B42.w		; E0 42 3B ; Compare #$3B42.w with X register [Reads: X Index] [Flags: NCZ]
	asl $08E6.w		; 0E E6 08 ; Arithmetic shift left $08E6.w [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda ($B3.b)		; B2 B3 ; Load accumulator (indirect) ($B3.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	sbc $04.b		; E5 04 ; Subtract $04.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	eor ($CC.b)		; 52 CC ; Exclusive OR accumulator with memory (indirect) ($CC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $A5.b		; 25 A5 ; Logical AND $A5.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $FB1A.w,X		; 1E 1A FB ; Arithmetic shift left $FB1A.w,X [Reads: X Index] [Flags: NCZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $1F.b		; 45 1F ; Exclusive OR $1F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $E5.b,S		; A3 E5 ; Load accumulator (stack relative) $E5.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $E6.b		; E5 E6 ; Subtract $E6.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	eor #$2405.w		; 49 05 24 ; Exclusive OR #$2405.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $18.b		; E5 18 ; Subtract $18.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and #$E506.w		; 29 06 E5 ; Logical AND #$E506.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $4A.b		; E5 4A ; Subtract $4A.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	rol $E5.b,X		; 36 E5 ; Rotate left $E5.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	dec $C8E6.w,X		; DE E6 C8 ; Decrement memory $C8E6.w,X [Reads: X Index] [Flags: NZ]
	eor #$076A.w		; 49 6A 07 ; Exclusive OR #$076A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $B2.b		; E5 B2 ; Subtract $B2.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $E3.b		; E5 E3 ; Subtract $E3.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ldx $E5E5.w		; AE E5 E5 ; Load $E5E5.w into X register [Writes: X Index] [Flags: NZ]
	ora #$E50A.w		; 09 0A E5 ; Logical OR #$E50A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	eor ($CC.b)		; 52 CC ; Exclusive OR accumulator with memory (indirect) ($CC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $48.b		; 00 48 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($E5.b,X)		; 01 E5 ; Logical OR ($E5.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $3E.b		; E5 3E ; Subtract $3E.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc $0B.b,S		; 63 0B ; Add with carry (stack relative) $0B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc $B2.b		; E5 B2 ; Subtract $B2.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $90, $A5		; 90 A5 ; Branch if carry clear to $90, $A5 [Flow: branch]
	eor ($0F.b)		; 52 0F ; Exclusive OR accumulator with memory (indirect) ($0F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $06		; 10 06 ; Branch if plus to $10, $06 [Flow: branch]
	sbc $3E.b,X		; F5 3E ; Subtract $3E.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	mvn $11,$64		; 54 64 11 ; Move block negative $11,$64 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc $E5.b		; E5 E5 ; Subtract $E5.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	bit $E5.b		; 24 E5 ; Test bits $E5.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	stz $AAB5.w		; 9C B5 AA ; Store zero to $AAB5.w
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	jsl $E312E5.l		; 22 E5 12 E3 ; Jump to subroutine long $E312E5.l [Writes: Stack Pointer] [Flow: call]
	ldx $B116.w		; AE 16 B1 ; Load $B116.w into X register [Writes: X Index] [Flags: NZ]
	.db $90, $3E		; 90 3E ; Branch if carry clear to $90, $3E [Flow: branch]
	lda ($E5.b)		; B2 E5 ; Load accumulator (indirect) ($E5.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $AF.b		; E5 AF ; Subtract $AF.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ldx $B5.b		; A6 B5 ; Load $B5.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	eor ($3E.b)		; 52 3E ; Exclusive OR accumulator with memory (indirect) ($3E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda ($90.b)		; B2 90 ; Load accumulator (indirect) ($90.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	stx $B917.w		; 8E 17 B9 ; Store X register to $B917.w [Reads: X Index]
	and $E5.b,S		; 23 E5 ; AND accumulator with stack relative $E5.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $B2.b		; E5 B2 ; Subtract $B2.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda $E54AA6.l		; AF A6 4A E5 ; Load long $E54AA6.l into accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $3E.b		; E5 3E ; Subtract $3E.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $18.b		; E5 18 ; Subtract $18.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and $C5.b,S		; 23 C5 ; AND accumulator with stack relative $C5.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($5A.b,X)		; 01 5A ; Logical OR ($5A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $E522.w,X		; 1D 22 E5 ; OR accumulator with memory $E522.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $AF.b		; 05 AF ; Logical OR $AF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $E5.b		; 45 E5 ; Exclusive OR $E5.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $E5.b		; 24 E5 ; Test bits $E5.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ror $1962.w		; 6E 62 19 ; Rotate right $1962.w [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	trb $5AD7.w		; 1C D7 5A ; Test and reset bits $5AD7.w [Reads: Accumulator] [Flags: Z]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx $E4.b		; E4 E4 ; Compare $E4.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc $4A.b		; E5 4A ; Subtract $4A.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $E5.b		; E5 E5 ; Subtract $E5.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ror $1D62.w		; 6E 62 1D ; Rotate right $1D62.w [Flags: NCZ]
	tsb $FF.b		; 04 FF ; Test and set bits $FF.b [Reads: Accumulator] [Flags: Z]
	sbc $D7E226.l,X		; FF 26 E2 D7 ; Subtract with carry (long,X) $D7E226.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $C5.b		; 24 C5 ; Test bits $C5.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	tsb $26.b		; 04 26 ; Test and set bits $26.b [Reads: Accumulator] [Flags: Z]
	rol $75.b		; 26 75 ; Rotate left $75.b [Reads: Direct Page] [Flags: NCZ]
	jsr $63FE.w		; 20 FE 63 ; Jump to subroutine at $63FE.w [Writes: Stack Pointer] [Flow: call]
	and ($01.b,X)		; 21 01 ; Logical AND ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rol $25.b		; 26 25 ; Rotate left $25.b [Reads: Direct Page] [Flags: NCZ]
	bit $1B.b		; 24 1B ; Test bits $1B.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	.db $62, $26, $04		; 62 26 04 ; Push effective relative address $62, $26, $04 [Writes: Stack Pointer]
	tsb $29.b		; 04 29 ; Test and set bits $29.b [Reads: Accumulator] [Flags: Z]
	cpx $2B2A.w		; EC 2A 2B ; Compare $2B2A.w with X register [Reads: X Index] [Flags: NCZ]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $FF132C.l		; 22 2C 13 FF ; Jump to subroutine long $FF132C.l [Writes: Stack Pointer] [Flow: call]
	inc $96F9.w		; EE F9 96 ; Increment $96F9.w [Flags: NZ]
	.db $10, $96		; 10 96 ; Branch if plus to $10, $96 [Flow: branch]
	sbc $069A09.l,X		; FF 09 9A 06 ; Subtract with carry (long,X) $069A09.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$FF.b]		; 07 FF ; OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $072E2D.l,X		; FF 2D 2E 07 ; Subtract with carry (long,X) $072E2D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$50.b]		; 07 50 ; OR accumulator with memory (long) [$50.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$0C.b],Y		; F7 0C ; Subtract with carry (long indexed) [$0C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy $0E.b		; A4 0E ; Load $0E.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	sta $FD44EB.l,X		; 9F EB 44 FD ; Store accumulator (long,X) $FD44EB.l,X [Reads: Accumulator, X Index]
	sbc [$FE.b],Y		; F7 FE ; Subtract with carry (long indexed) [$FE.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$46.b]		; 07 46 ; OR accumulator with memory (long) [$46.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $226130.l		; 2F 30 61 22 ; AND accumulator with memory (long) $226130.l [Writes: Accumulator] [Flags: NZ]
	trb $08.b		; 14 08 ; Test and reset bits $08.b [Reads: Accumulator] [Flags: Z]
	ora $31.b,X		; 15 31 ; OR accumulator with memory $31.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ldx $1A.b		; A6 1A ; Load $1A.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	sta $F1144A.l,X		; 9F 4A 14 F1 ; Store accumulator (long,X) $F1144A.l,X [Reads: Accumulator, X Index]
	and $3DE4FF.l		; 2F FF E4 3D ; AND accumulator with memory (long) $3DE4FF.l [Writes: Accumulator] [Flags: NZ]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $E4.b		; 00 E4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$FF11.w		; C0 11 FF ; Compare #$FF11.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $62, $32, $00		; 62 32 00 ; Push effective relative address $62, $32, $00 [Writes: Stack Pointer]
	and ($65.b)		; 32 65 ; AND accumulator with memory (indirect) ($65.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $62.b,X		; 35 62 ; Logical AND $62.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	adc $38.b		; 65 38 ; Add $38.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	brk $3B.b		; 00 3B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $3E, $02		; 62 3E 02 ; Push effective relative address $62, $3E, $02 [Writes: Stack Pointer]
	bit $32.b,X		; 34 32 ; Test bits $32.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and $62.b,X		; 35 62 ; Logical AND $62.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($62.b,X)		; 41 62 ; Exclusive OR accumulator with memory ($62.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($08.b,X)		; 41 08 ; Exclusive OR accumulator with memory ($08.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $383A.w,Y		; 39 3A 38 ; AND accumulator with memory $383A.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	mvp $3F,$45		; 44 45 3F ; Move block positive $3F,$45 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	lsr $3D.b		; 46 3D ; Logical shift right $3D.b [Reads: Direct Page] [Flags: NCZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	stz $47.b		; 64 47 ; Store zero to $47.b
	ora $49.b,S		; 03 49 ; OR accumulator with stack relative $49.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jmp $3332.w		; 4C 32 33 ; Jump to $3332.w [Flow: jump]
	.db $62, $4D, $03		; 62 4D 03 ; Push effective relative address $62, $4D, $03 [Writes: Stack Pointer]
	and $443837.l,X		; 3F 37 38 44 ; AND accumulator with memory (long,X) $443837.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	stz $50.b		; 64 50 ; Store zero to $50.b
	ora [$1F.b]		; 07 1F ; OR accumulator with memory (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $3B.b,X		; 55 3B ; Exclusive OR accumulator with memory $3B.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	bit $5756.w,X		; 3C 56 57 ; Test bits $5756.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	and $58683F.l,X		; 3F 3F 68 58 ; AND accumulator with memory (long,X) $58683F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($5C.b,X)		; 01 5C ; Logical OR ($5C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $6166.w,Y		; 39 66 61 ; AND accumulator with memory $6166.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $3B.b		; 00 3B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $68.b		; 65 68 ; Add $68.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cop $69.b		; 02 69 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($35.b)		; 32 35 ; AND accumulator with memory (indirect) ($35.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc [$6E.b]		; 67 6E ; Add with carry (long) [$6E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($69.b,X)		; 01 69 ; Logical OR ($69.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $62, $76, $01		; 62 76 01 ; Push effective relative address $62, $76, $01 [Writes: Stack Pointer]
	adc #$683B.w		; 69 3B 68 ; Add #$683B.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	adc $6900.w,Y		; 79 00 69 ; Add $6900.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $82.b,S		; 63 82 ; Add with carry (stack relative) $82.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	tsb $69.b		; 04 69 ; Test and set bits $69.b [Reads: Accumulator] [Flags: Z]
	and $866C.w,Y		; 39 6C 86 ; AND accumulator with memory $866C.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor ($63.b)		; 52 63 ; Exclusive OR accumulator with memory (indirect) ($63.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta [$00.b]		; 87 00 ; Store accumulator (long) [$00.b] [Reads: Direct Page, Accumulator]
	eor $62.b,X		; 55 62 ; Exclusive OR accumulator with memory $62.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	ora $6B.b		; 05 6B ; Logical OR $6B.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc ($62.b,X)		; 61 62 ; Add with carry ($62.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc #$3332.w		; 69 32 33 ; Add #$3332.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	adc $8E.b		; 65 8E ; Add $8E.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora #$5255.w		; 09 55 52 ; Logical OR #$5255.w with accumulator [Writes: Accumulator] [Flags: NZ]
	eor ($94.b)		; 52 94 ; Exclusive OR accumulator with memory (indirect) ($94.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $35.b,X		; 95 35 ; Store accumulator to $35.b,X [Reads: Accumulator, X Index]
	ror $3B8C.w		; 6E 8C 3B ; Rotate right $3B8C.w [Flags: NCZ]
	bit $9664.w,X		; 3C 64 96 ; Test bits $9664.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	jmp $9B5F5D.l		; 5C 5D 5F 9B ; Jump long to $9B5F5D.l [Flow: jump]
	stz $473B.w		; 9C 3B 47 ; Store zero to $473B.w
	sta $3955.w,X		; 9D 55 39 ; Store accumulator to $3955.w,X [Reads: Accumulator, X Index]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $62, $63, $9E		; 62 63 9E ; Push effective relative address $62, $63, $9E [Writes: Stack Pointer]
	ora $69.b		; 05 69 ; Logical OR $69.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $82, $6B, $6C		; 82 6B 6C ; Branch always long to $82, $6B, $6C [Flow: branch]
	ldx #$6244.w		; A2 44 62 ; Load #$6244.w into X register [Writes: X Index] [Flags: NZ]
	lda $0B.b,S		; A3 0B ; Load accumulator (stack relative) $0B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($33.b)		; 32 33 ; AND accumulator with memory (indirect) ($33.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	stz $A69F.w,X		; 9E 9F A6 ; Store zero to $A69F.w,X [Reads: X Index]
	lda [$69.b]		; A7 69 ; Load accumulator (long) [$69.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $82, $76, $77		; 82 76 77 ; Branch always long to $82, $76, $77 [Flow: branch]
	bit $63.b,X		; 34 63 ; Test bits $63.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	ora ($3B.b),Y		; 11 3B ; OR accumulator with memory ($3B.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $9E96.w,X		; 3C 96 9E ; Test bits $9E96.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	sta $69ADAC.l,X		; 9F AC AD 69 ; Store accumulator (long,X) $69ADAC.l,X [Reads: Accumulator, X Index]
	.db $82, $83, $AE		; 82 83 AE ; Branch always long to $82, $83, $AE [Flow: branch]
	and $AF3B.w,X		; 3D 3B AF ; AND accumulator with memory $AF3B.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $52.b,X		; 55 52 ; Exclusive OR accumulator with memory $52.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $633A.w,Y		; 39 3A 63 ; AND accumulator with memory $633A.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $0C		; B0 0C ; Branch if carry set to $B0, $0C [Flow: branch]
	lda ($8C.b,S),Y		; B3 8C ; Load accumulator (stack relative indirect indexed) ($8C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldy $B5.b,X		; B4 B5 ; Load Y register $B5.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	and [$B6.b],Y		; 37 B6 ; AND accumulator with memory (long indexed) [$B6.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $B8B7.w,Y		; 39 B7 B8 ; AND accumulator with memory $B8B7.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor ($32.b)		; 52 32 ; Exclusive OR accumulator with memory (indirect) ($32.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $B9.b,X		; 35 B9 ; Logical AND $B9.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $52.b,S		; 23 52 ; AND accumulator with stack relative $52.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	eor ($BB.b)		; 52 BB ; Exclusive OR accumulator with memory (indirect) ($BB.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	bit $32.b,X		; 34 32 ; Test bits $32.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and ($BC.b,S),Y		; 33 BC ; AND accumulator (stack relative indirect indexed) ($BC.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor ($FF.b)		; 52 FF ; Exclusive OR accumulator with memory (indirect) ($FF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx $39.b		; E4 39 ; Compare $39.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $2C.b		; 00 2C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b),Y		; 11 03 ; OR accumulator with memory ($03.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $33.b		; E4 33 ; Compare $33.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($04.b),Y		; 11 04 ; OR accumulator with memory ($04.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($12.b)		; 12 12 ; OR accumulator with memory (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($12.b),Y		; 11 12 ; OR accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($24.b)		; 12 24 ; OR accumulator with memory (indirect) ($24.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($22.b),Y		; 11 22 ; OR accumulator with memory ($22.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b)		; 12 01 ; OR accumulator with memory (indirect) ($01.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $110212.l		; 22 12 02 11 ; Jump to subroutine long $110212.l [Writes: Stack Pointer] [Flow: call]
	ora ($12.b)		; 12 12 ; OR accumulator with memory (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $11.b,S		; 23 11 ; AND accumulator with stack relative $11.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($12.b,X)		; 01 12 ; Logical OR ($12.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($22.b)		; 12 22 ; OR accumulator with memory (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($22.b),Y		; 11 22 ; OR accumulator with memory ($22.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($43.b)		; 12 43 ; OR accumulator with memory (indirect) ($43.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($12.b),Y		; 11 12 ; OR accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	ora ($22.b),Y		; 11 22 ; OR accumulator with memory ($22.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($43.b)		; 12 43 ; OR accumulator with memory (indirect) ($43.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($12.b),Y		; 11 12 ; OR accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($12.b,X)		; 01 12 ; Logical OR ($12.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($25.b),Y		; 11 25 ; OR accumulator with memory ($25.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b)		; 12 00 ; OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($22.b),Y		; 11 22 ; OR accumulator with memory ($22.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($46.b)		; 12 46 ; OR accumulator with memory (indirect) ($46.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($12.b),Y		; 11 12 ; OR accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cop $11.b		; 02 11 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($12.b)		; 12 12 ; OR accumulator with memory (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $124611.l		; 22 11 46 12 ; Jump to subroutine long $124611.l [Writes: Stack Pointer] [Flow: call]
	ora ($23.b),Y		; 11 23 ; OR accumulator with memory ($23.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($25.b)		; 12 25 ; OR accumulator with memory (indirect) ($25.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b),Y		; 11 02 ; OR accumulator with memory ($02.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b)		; 12 11 ; OR accumulator with memory (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($22.b)		; 12 22 ; OR accumulator with memory (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($23.b),Y		; 11 23 ; OR accumulator with memory ($23.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($23.b)		; 12 23 ; OR accumulator with memory (indirect) ($23.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($FF.b),Y		; 11 FF ; OR accumulator with memory ($FF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $38, $62		; 62 38 62 ; Push effective relative address $62, $38, $62 [Writes: Stack Pointer]
	sec		; 38 ; Set carry flag [Flags: C]
	bit #$0000.w		; 89 00 00 ; Test bits #$0000.w with accumulator [Reads: Accumulator] [Flags: Z]
	ora $41.b,S		; 03 41 ; OR accumulator with stack relative $41.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $42, $77		; 42 77 ; Reserved instruction
	eor $BD62.w		; 4D 62 BD ; Exclusive OR $BD62.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $62, $BD, $02		; 62 BD 02 ; Push effective relative address $62, $BD, $02 [Writes: Stack Pointer]
	lda $3477.w,X		; BD 77 34 ; Load $3477.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $32, $02		; 62 32 02 ; Push effective relative address $62, $32, $02 [Writes: Stack Pointer]
	cpy #$84C1.w		; C0 C1 84 ; Compare #$84C1.w with Y register [Reads: Y Index] [Flags: NCZ]
	adc $C2.b,S		; 63 C2 ; Add with carry (stack relative) $C2.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $62, $C3, $02		; 62 C3 02 ; Push effective relative address $62, $C3, $02 [Writes: Stack Pointer]
	cmp $C6.b,S		; C3 C6 ; Compare accumulator (stack relative) $C6.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	and $3B62.w,X		; 3D 62 3B ; AND accumulator with memory $3B62.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $BB.b		; 04 BB ; Test and set bits $BB.b [Reads: Accumulator] [Flags: Z]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cmp [$C8.b]		; C7 C8 ; Compare accumulator (long) [$C8.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	eor ($62.b)		; 52 62 ; Exclusive OR accumulator with memory (indirect) ($62.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$C902.w		; C9 02 C9 ; Compare #$C902.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	eor ($1F.b)		; 52 1F ; Exclusive OR accumulator with memory (indirect) ($1F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $CC.b,S		; 63 CC ; Add with carry (stack relative) $CC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cmp $95D0.w		; CD D0 95 ; Compare $95D0.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	and ($BC.b,S),Y		; 33 BC ; AND accumulator (stack relative indirect indexed) ($BC.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp ($D1.b),Y		; D1 D1 ; Compare accumulator ($D1.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	eor ($52.b)		; 52 52 ; Exclusive OR accumulator with memory (indirect) ($52.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $D1.b,S		; 63 D1 ; Add with carry (stack relative) $D1.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	asl $A3.b		; 06 A3 ; Arithmetic shift left $A3.b [Reads: Direct Page] [Flags: NCZ]
	cmp $52.b,X		; D5 52 ; Compare accumulator $52.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cmp ($D6.b),Y		; D1 D6 ; Compare accumulator ($D6.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $D766.w,X		; 3C 66 D7 ; Test bits $D766.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	ora $AC.b,S		; 03 AC ; OR accumulator with stack relative $AC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $1F1F.w,X		; DE 1F 1F ; Decrement memory $1F1F.w,X [Reads: X Index] [Flags: NZ]
	adc $DF.b,S		; 63 DF ; Add with carry (stack relative) $DF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora ($3A.b,X)		; 01 3A ; Logical OR ($3A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $B0, $62		; B0 62 ; Branch if carry set to $B0, $62 [Flow: branch]
	sbc $00.b,S		; E3 00 ; Subtract stack-relative $00.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	eor ($66.b)		; 52 66 ; Exclusive OR accumulator with memory (indirect) ($66.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $05.b		; E6 05 ; Increment $05.b [Reads: Direct Page] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $43EE.w		; ED EE 43 ; Subtract $43EE.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sbc $F06452.l		; EF 52 64 F0 ; Subtract with carry (long) $F06452.l [Writes: Accumulator] [Flags: NCVZ]
	.db $62, $3B, $03		; 62 3B 03 ; Push effective relative address $62, $3B, $03 [Writes: Stack Pointer]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $74.b,X		; F5 74 ; Subtract $74.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $82, $62, $F6		; 82 62 F6 ; Branch always long to $82, $62, $F6 [Flow: branch]
	ora [$52.b],Y		; 17 52 ; OR accumulator with memory (long indexed) [$52.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor ($F9.b)		; 52 F9 ; Exclusive OR accumulator with memory (indirect) ($F9.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	and $FC3A.w,Y		; 39 3A FC ; AND accumulator with memory $FC3A.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	stz $FD.b,X		; 74 FD ; Store zero to $FD.b,X [Reads: X Index]
	ldx #$FFFE.w		; A2 FE FF ; Load #$FFFE.w into X register [Writes: X Index] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $33.b,X		; 95 33 ; Store accumulator to $33.b,X [Reads: Accumulator, X Index]
	bit $32.b,X		; 34 32 ; Test bits $32.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and $62.b,X		; 35 62 ; Logical AND $62.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	bit $BB.b,X		; 34 BB ; Test bits $BB.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	eor ($09.b)		; 52 09 ; Exclusive OR accumulator with memory (indirect) ($09.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	trb $0B.b		; 14 0B ; Test and reset bits $0B.b [Reads: Accumulator] [Flags: Z]
	tsb $46BB.w		; 0C BB 46 ; Test and set bits $46BB.w [Reads: Accumulator] [Flags: Z]
	and $070D.w,X		; 3D 0D 07 ; AND accumulator with memory $070D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $0F5C.w		; 0E 5C 0F ; Arithmetic shift left $0F5C.w [Flags: NCZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $E2		; 10 E2 ; Branch if plus to $10, $E2 [Flow: branch]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	jsr ($5074.w,X)		; FC 74 50 ; Jump to subroutine indirect indexed ($5074.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	eor ($BB.b)		; 52 BB ; Exclusive OR accumulator with memory (indirect) ($BB.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and [$B6.b],Y		; 37 B6 ; AND accumulator with memory (long indexed) [$B6.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $11, $05		; 62 11 05 ; Push effective relative address $62, $11, $05 [Writes: Stack Pointer]
	adc #$9F14.w		; 69 14 9F ; Add #$9F14.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	ora $16.b,X		; 15 16 ; OR accumulator with memory $16.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $65.b,X		; 35 65 ; Logical AND $65.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$0D.b],Y		; 17 0D ; OR accumulator with memory (long indexed) [$0D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $1A.b,X		; 34 1A ; Test bits $1A.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora $691E.w,X		; 1D 1E 69 ; OR accumulator with memory $691E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	trb $9F.b		; 14 9F ; Test and reset bits $9F.b [Reads: Accumulator] [Flags: Z]
	ora $9D0B3B.l,X		; 1F 3B 0B 9D ; Logical OR long $9D0B3B.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpx $20.b		; E4 20 ; Compare $20.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	and ($62.b,X)		; 21 62 ; Logical AND ($62.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$22.b],Y		; 17 22 ; OR accumulator with memory (long indexed) [$22.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $69.b,S		; 23 69 ; AND accumulator with stack relative $69.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	trb $9F.b		; 14 9F ; Test and reset bits $9F.b [Reads: Accumulator] [Flags: Z]
	bit $74.b		; 24 74 ; Test bits $74.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	.db $50, $52		; 50 52 ; Branch if overflow clear to $50, $52 [Flow: branch]
	eor ($25.b)		; 52 25 ; Exclusive OR accumulator with memory (indirect) ($25.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	and $38C7.w,Y		; 39 C7 38 ; AND accumulator with memory $38C7.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc ($74.b,S),Y		; 73 74 ; Add with carry (stack relative indirect indexed) ($74.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	rol $8C.b		; 26 8C ; Rotate left $8C.b [Reads: Direct Page] [Flags: NCZ]
	and [$B2.b]		; 27 B2 ; AND accumulator with memory (long) [$B2.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda ($B3.b,S),Y		; B3 B3 ; Load accumulator (stack relative indirect indexed) ($B3.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $28.b,S		; 63 28 ; Add with carry (stack relative) $28.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	trb $28FF.w		; 1C FF 28 ; Test and reset bits $28FF.w [Reads: Accumulator] [Flags: Z]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($12.b,X)		; 01 12 ; Logical OR ($12.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $01.b		; 24 01 ; Test bits $01.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	rol $01.b		; 26 01 ; Rotate left $01.b [Reads: Direct Page] [Flags: NCZ]
	ora ($12.b,X)		; 01 12 ; Logical OR ($12.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($26.b,X)		; 01 26 ; Logical OR ($26.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $27.b		; 00 27 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($01.b)		; 12 01 ; OR accumulator with memory (indirect) ($01.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $29.b		; 00 29 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $000101.l		; 22 01 01 00 ; Jump to subroutine long $000101.l [Writes: Stack Pointer] [Flow: call]
	brk $26.b		; 00 26 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($12.b)		; 12 12 ; OR accumulator with memory (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora ($22.b)		; 12 22 ; OR accumulator with memory (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($84.b)		; 12 84 ; OR accumulator with memory (indirect) ($84.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rol $01.b		; 26 01 ; Rotate left $01.b [Reads: Direct Page] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $01.b,S		; 23 01 ; AND accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $01.b		; 24 01 ; Test bits $01.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $01.b,S		; 23 01 ; AND accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and #$0001.w		; 29 01 00 ; Logical AND #$0001.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $2A.b		; 00 2A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $2C.b		; 00 2C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $95.b		; 00 95 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $62, $06, $05		; 62 06 05 ; Push effective relative address $62, $06, $05 [Writes: Stack Pointer]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	inc $00FF.w,X		; FE FF 00 ; Increment memory $00FF.w,X [Reads: X Index] [Flags: NZ]
	bit $0222.w		; 2C 22 02 ; Test bits $0222.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $62.b,S		; 03 62 ; OR accumulator with stack relative $62.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $62.b		; 00 62 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $06.b,S		; 23 06 ; AND accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($2C.b,X)		; 01 2C ; Logical OR ($2C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $62.b,S		; 03 62 ; OR accumulator with stack relative $62.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora #$0962.w		; 09 62 09 ; Logical OR #$0962.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $07, $22		; 62 07 22 ; Push effective relative address $62, $07, $22 [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tsb $0B.b		; 04 0B ; Test and set bits $0B.b [Reads: Accumulator] [Flags: Z]
	tsb $0E2D.w		; 0C 2D 0E ; Test and set bits $0E2D.w [Reads: Accumulator] [Flags: Z]
	ora $020083.l		; 0F 83 00 02 ; OR accumulator with memory (long) $020083.l [Writes: Accumulator] [Flags: NZ]
	adc $10.b,S		; 63 10 ; Add with carry (stack relative) $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	jsl $166215.l		; 22 15 62 16 ; Jump to subroutine long $166215.l [Writes: Stack Pointer] [Flow: call]
	tsb $1D.b		; 04 1D ; Test and set bits $1D.b [Reads: Accumulator] [Flags: Z]
	ora $001A.w,Y		; 19 1A 00 ; OR accumulator with memory $001A.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tsb $62.b		; 04 62 ; Test and set bits $62.b [Reads: Accumulator] [Flags: Z]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	cop $5A.b		; 02 5A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $216421.l,X		; 1F 21 64 21 ; Logical OR long $216421.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ldx $26.b,Y		; B6 26 ; Load X register $26.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	and [$09.b]		; 27 09 ; AND accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$28.b]		; 07 28 ; OR accumulator with memory (long) [$28.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$9999.w		; 29 99 99 ; Logical AND #$9999.w with accumulator [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	adc $2B.b,S		; 63 2B ; Add with carry (stack relative) $2B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora ($25.b,X)		; 01 25 ; Logical OR ($25.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora #$2F63.w		; 09 63 2F ; Logical OR #$2F63.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $1D7C.w		; 0C 7C 1D ; Test and set bits $1D7C.w [Reads: Accumulator] [Flags: Z]
	ora $2F2E.w,X		; 1D 2E 2F ; OR accumulator with memory $2F2E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $D1		; D0 D1 ; Branch if not equal to $D0, $D1 [Flow: branch]
	.db $30, $37		; 30 37 ; Branch if minus to $30, $37 [Flow: branch]
	rol $0725.w		; 2E 25 07 ; Rotate left $0725.w [Flags: NCZ]
	and ($63.b)		; 32 63 ; AND accumulator with memory (indirect) ($63.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	cop $1D.b		; 02 1D ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($33.b),Y		; 31 33 ; AND accumulator with memory ($33.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	stz $32.b		; 64 32 ; Store zero to $32.b
	asl $2E.b		; 06 2E ; Arithmetic shift left $2E.b [Reads: Direct Page] [Flags: NCZ]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $3B.b		; 04 3B ; Test and set bits $3B.b [Reads: Accumulator] [Flags: Z]
	sta ($8E.b),Y		; 91 8E ; Store accumulator ($8E.b),Y [Reads: Direct Page, Y Index, Accumulator]
	jsl $45001D.l		; 22 1D 00 45 ; Jump to subroutine long $45001D.l [Writes: Stack Pointer] [Flow: call]
	jsl $41001D.l		; 22 1D 00 41 ; Jump to subroutine long $41001D.l [Writes: Stack Pointer] [Flow: call]
	.db $62, $48, $04		; 62 48 04 ; Push effective relative address $62, $48, $04 [Writes: Stack Pointer]
	ora #$4B07.w		; 09 07 4B ; Logical OR #$4B07.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jmp $431D.w		; 4C 1D 43 ; Jump to $431D.w [Flow: jump]
	ora $0199.w,X		; 1D 99 01 ; OR accumulator with memory $0199.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $50, $51		; 50 51 ; Branch if overflow clear to $50, $51 [Flow: branch]
	stz $51.b		; 64 51 ; Store zero to $51.b
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$32.b]		; 07 32 ; OR accumulator with memory (long) [$32.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr $43.b,X		; 56 43 ; Logical shift right $43.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	mvp $1D,$1D		; 44 1D 1D ; Move block positive $1D,$1D [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	and [$5A.b],Y		; 37 5A ; AND accumulator with memory (long indexed) [$5A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $411D.w,X		; 1D 1D 41 ; OR accumulator with memory $411D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $5B.b,S		; 63 5B ; Add with carry (stack relative) $5B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	asl $00.b,X		; 16 00 ; Arithmetic shift left $00.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tsb $5F.b		; 04 5F ; Test and set bits $5F.b [Reads: Accumulator] [Flags: Z]
	lsr $1D4F.w		; 4E 4F 1D ; Logical shift right $1D4F.w [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	asl $6261.w,X		; 1E 61 62 ; Arithmetic shift left $6261.w,X [Reads: X Index] [Flags: NCZ]
	eor ($48.b,X)		; 41 48 ; Exclusive OR accumulator with memory ($48.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$6463.w		; 49 63 64 ; Exclusive OR #$6463.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$57.b]		; 07 57 ; OR accumulator with memory (long) [$57.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	adc $1D.b		; 65 1D ; Add $1D.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $6662.w,X		; 1D 62 66 ; OR accumulator with memory $6662.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $5352.w		; 0D 52 53 ; Logical OR $5352.w with accumulator [Writes: Accumulator] [Flags: NZ]
	adc $69.b,S		; 63 69 ; Add with carry (stack relative) $69.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	eor #$076A.w		; 49 6A 07 ; Exclusive OR #$076A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and ($6B.b)		; 32 6B ; AND accumulator with memory (indirect) ($6B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jmp ($6D98.w)		; 6C 98 6D ; Jump indirect to ($6D98.w) [Flow: jump]
	and $632D.w		; 2D 2D 63 ; Logical AND $632D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ror $690A.w		; 6E 0A 69 ; Rotate right $690A.w [Flags: NCZ]
	eor #$066A.w		; 49 6A 06 ; Exclusive OR #$066A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $4B723C.l,X		; 7F 3C 72 4B ; Add long $4B723C.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	jsl $70106D.l		; 22 6D 10 70 ; Jump to subroutine long $70106D.l [Writes: Stack Pointer] [Flow: call]
	adc ($73.b),Y		; 71 73 ; Add with carry ($73.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $09.b		; 06 09 ; Arithmetic shift left $09.b [Reads: Direct Page] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	stz $1D.b,X		; 74 1D ; Store zero to $1D.b,X [Reads: X Index]
	adc $76.b,X		; 75 76 ; Add $76.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($76.b)		; 72 76 ; Add with carry (indirect) ($76.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $7772.w,X		; 1D 72 77 ; OR accumulator with memory $7772.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sbc $001231.l,X		; FF 31 12 00 ; Subtract with carry (long,X) $001231.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($01.b)		; 12 01 ; OR accumulator with memory (indirect) ($01.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rol $12.b		; 26 12 ; Rotate left $12.b [Reads: Direct Page] [Flags: NCZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $27.b		; 00 27 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($07.b)		; 12 07 ; OR accumulator with memory (indirect) ($07.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	ora ($28.b)		; 12 28 ; OR accumulator with memory (indirect) ($28.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($E4.b,X)		; 01 E4 ; Logical OR ($E4.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $12.b,S		; 23 12 ; AND accumulator with stack relative $12.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($26.b,X)		; 01 26 ; Logical OR ($26.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($26.b)		; 12 26 ; OR accumulator with memory (indirect) ($26.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($01.b)		; 12 01 ; OR accumulator with memory (indirect) ($01.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($08.b)		; 12 08 ; OR accumulator with memory (indirect) ($08.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($00.b)		; 12 00 ; OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	tsb $27.b		; 04 27 ; Test and set bits $27.b [Reads: Accumulator] [Flags: Z]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($01.b)		; 12 01 ; OR accumulator with memory (indirect) ($01.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $12.b		; 04 12 ; Test and set bits $12.b [Reads: Accumulator] [Flags: Z]
	ora ($12.b,X)		; 01 12 ; Logical OR ($12.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $83.b		; 02 83 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	ora ($12.b)		; 12 12 ; OR accumulator with memory (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $12.b		; 25 12 ; Logical AND $12.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $01.b,S		; 43 01 ; Exclusive OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($23.b)		; 12 23 ; OR accumulator with memory (indirect) ($23.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $26.b		; 00 26 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($26.b)		; 12 26 ; OR accumulator with memory (indirect) ($26.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($00.b)		; 12 00 ; OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $12.b		; 24 12 ; Test bits $12.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	bit $01.b		; 24 01 ; Test bits $01.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ldy #$0E05.w		; A0 05 0E ; Load #$0E05.w into Y register [Writes: Y Index] [Flags: NZ]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b)		; 12 02 ; OR accumulator with memory (indirect) ($02.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($24.b)		; 12 24 ; OR accumulator with memory (indirect) ($24.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $27.b		; 02 27 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($FF.b)		; 12 FF ; OR accumulator with memory (indirect) ($FF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc ($38.b),Y		; 71 38 ; Add with carry ($38.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $88.b		; 02 88 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $62, $4B, $01		; 62 4B 01 ; Push effective relative address $62, $4B, $01 [Writes: Stack Pointer]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	bit #$4E66.w		; 89 66 4E ; Test bits #$4E66.w with accumulator [Reads: Accumulator] [Flags: Z]
	ora [$93.b]		; 07 93 ; OR accumulator with memory (long) [$93.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda ($30.b)		; B2 30 ; Load accumulator (indirect) ($30.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($C3.b),Y		; 31 C3 ; AND accumulator with memory ($C3.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy $63AA.w		; CC AA 63 ; Compare $63AA.w with Y register [Reads: Y Index] [Flags: NCZ]
	eor $22.b,X		; 55 22 ; Exclusive OR accumulator with memory $22.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor $5A09.w,Y		; 59 09 5A ; Exclusive OR accumulator with memory $5A09.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $5F9FA0.l,X		; 9F A0 9F 5F ; Store accumulator (long,X) $5F9FA0.l,X [Reads: Accumulator, X Index]
	trb $5F1D.w		; 1C 1D 5F ; Test and reset bits $5F1D.w [Reads: Accumulator] [Flags: Z]
	lda ($55.b)		; B2 55 ; Load accumulator (indirect) ($55.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $62, $5B, $22		; 62 5B 22 ; Push effective relative address $62, $5B, $22 [Writes: Stack Pointer]
	lsr $5F03.w,X		; 5E 03 5F ; Logical shift right $5F03.w,X [Reads: X Index] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$24AA.w		; A9 AA 24 ; Load #$24AA.w into accumulator [Writes: Accumulator] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	ora ($AC.b,X)		; 01 AC ; Logical OR ($AC.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda $6166.w		; AD 66 61 ; Load $6166.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($60.b,X)		; 01 60 ; Logical OR ($60.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	bit $69.b		; 24 69 ; Test bits $69.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	bit $75.b		; 24 75 ; Test bits $75.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	adc $76.b		; 65 76 ; Add $76.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($C3.b,X)		; 01 C3 ; Logical OR ($C3.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpy $66.b		; C4 66 ; Compare $66.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	jmp ($C324.w,X)		; 7C 24 C3 ; Jump indirect indexed to ($C324.w,X) [Reads: X Index] [Flow: jump]
	asl $8A.b		; 06 8A ; Arithmetic shift left $8A.b [Reads: Direct Page] [Flags: NCZ]
	cpy $CD83.w		; CC 83 CD ; Compare $CD83.w with Y register [Reads: Y Index] [Flags: NCZ]
	dec $8584.w		; CE 84 85 ; Decrement $8584.w [Flags: NZ]
	.db $62, $85, $0A		; 62 85 0A ; Push effective relative address $62, $85, $0A [Writes: Stack Pointer]
	cmp ($9F.b),Y		; D1 9F ; Compare accumulator ($9F.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	sta $1C.b,S		; 83 1C ; Store accumulator (stack relative) $1C.b,S [Reads: Stack Pointer, Accumulator]
	sta ($08.b,X)		; 81 08 ; Store accumulator ($08.b,X) [Reads: Direct Page, Accumulator, X Index]
	dec $9F.b		; C6 9F ; Decrement $9F.b [Reads: Direct Page] [Flags: NZ]
	sta ($D6.b,X)		; 81 D6 ; Store accumulator ($D6.b,X) [Reads: Direct Page, Accumulator, X Index]
	cmp [$23.b],Y		; D7 23 ; Compare accumulator (long indexed) [$23.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cmp $13.b,S		; C3 13 ; Compare accumulator (stack relative) $13.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	cmp $DB88.w,Y		; D9 88 DB ; Compare accumulator $DB88.w,Y [Reads: Y Index] [Flags: NCZ]
	sta $89.b		; 85 89 ; Store accumulator to $89.b [Reads: Accumulator]
	cop $8A.b		; 02 8A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($89.b,X)		; 61 89 ; Add with carry ($89.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
.ACCU 8
	sep #$E3		; E2 E3
	trb $839F.w		; 1C 9F 83 ; Test and reset bits $839F.w [Reads: Accumulator] [Flags: Z]
	sta $B2.b,S		; 83 B2 ; Store accumulator (stack relative) $B2.b,S [Reads: Stack Pointer, Accumulator]
	cpx $E5.b		; E4 E5 ; Compare $E5.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	lsr $8B65.w,X		; 5E 65 8B ; Logical shift right $8B65.w,X [Reads: X Index] [Flags: NCZ]
	tsb $EEED.w		; 0C ED EE ; Test and set bits $EEED.w [Reads: Accumulator] [Flags: Z]
	sta ($F0.b),Y		; 91 F0 ; Store accumulator ($F0.b),Y [Reads: Direct Page, Y Index, Accumulator]
	sta ($1D.b)		; 92 1D ; Store accumulator (indirect) ($1D.b) [Reads: Direct Page, Accumulator]
	sta $931D1C.l,X		; 9F 1C 1D 93 ; Store accumulator (long,X) $931D1C.l,X [Reads: Accumulator, X Index]
	.db $90, $94		; 90 94 ; Branch if carry clear to $90, $94 [Flow: branch]
	sta $22.b,X		; 95 22 ; Store accumulator to $22.b,X [Reads: Accumulator, X Index]
	stx $01.b,Y		; 96 01 ; Store X register $01.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	sbc $63ED.w		; ED ED 63 ; Subtract $63ED.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	tsb $F2.b		; 04 F2 ; Test and set bits $F2.b [Reads: Accumulator] [Flags: Z]
	sta $9F.b,S		; 83 9F ; Store accumulator (stack relative) $9F.b,S [Reads: Stack Pointer, Accumulator]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	tsb $24.b		; 04 24 ; Test and set bits $24.b [Reads: Accumulator] [Flags: Z]
	stx $83.b,Y		; 96 83 ; Store X register $83.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sbc $F2FB00.l,X		; FF 00 FB F2 ; Subtract with carry (long,X) $F2FB00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	sta $06043C.l,X		; 9F 3C 04 06 ; Store accumulator (long,X) $06043C.l,X [Reads: Accumulator, X Index]
	sta [$5B.b],Y		; 97 5B ; Store accumulator (long indexed) [$5B.b],Y [Reads: Direct Page, Y Index, Accumulator]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	.db $D0, $00		; D0 00 ; Branch if not equal to $D0, $00 [Flow: branch]
	ora $84.b,S		; 03 84 ; OR accumulator with stack relative $84.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $D5.b		; 00 D5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $44.b		; 04 44 ; Test and set bits $44.b [Reads: Accumulator] [Flags: Z]
	eor $1C.b		; 45 1C ; Exclusive OR $1C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $B2.b,S		; 83 B2 ; Store accumulator (stack relative) $B2.b,S [Reads: Stack Pointer, Accumulator]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	cpx #$0302.w		; E0 02 03 ; Compare #$0302.w with X register [Reads: X Index] [Flags: NCZ]
	brk $99.b		; 00 99 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $9A.b		; 26 9A ; Rotate left $9A.b [Reads: Direct Page] [Flags: NCZ]
	sbc $122CE4.l,X		; FF E4 2C 12 ; Subtract with carry (long,X) $122CE4.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $0512.w		; 2E 12 05 ; Rotate left $0512.w [Flags: NCZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($12.b,X)		; 01 12 ; Logical OR ($12.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($02.b)		; 12 02 ; OR accumulator with memory (indirect) ($02.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$12.b		; 29 12 ; Logical AND #$12.b with accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $120302.l		; 22 02 03 12 ; Jump to subroutine long $120302.l [Writes: Stack Pointer] [Flow: call]
	ora ($01.b)		; 12 01 ; OR accumulator with memory (indirect) ($01.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $27.b		; 00 27 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($25.b)		; 12 25 ; OR accumulator with memory (indirect) ($25.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($28.b,X)		; 01 28 ; Logical OR ($28.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $22.b		; 05 22 ; Logical OR $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $02.b		; 25 02 ; Logical AND $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora ($02.b)		; 12 02 ; OR accumulator with memory (indirect) ($02.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($02.b)		; 12 02 ; OR accumulator with memory (indirect) ($02.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $012402.l		; 22 02 24 01 ; Jump to subroutine long $012402.l [Writes: Stack Pointer] [Flow: call]
	ora [$02.b]		; 07 02 ; OR accumulator with memory (long) [$02.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($12.b,X)		; 01 12 ; Logical OR ($12.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($23.b)		; 12 23 ; OR accumulator with memory (indirect) ($23.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8D.b		; 00 8D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $040012.l		; 22 12 00 04 ; Jump to subroutine long $040012.l [Writes: Stack Pointer] [Flow: call]
	jsl $010402.l		; 22 02 04 01 ; Jump to subroutine long $010402.l [Writes: Stack Pointer] [Flow: call]
	tsb $12.b		; 04 12 ; Test and set bits $12.b [Reads: Accumulator] [Flags: Z]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	sta $23.b,S		; 83 23 ; Store accumulator (stack relative) $23.b,S [Reads: Stack Pointer, Accumulator]
	ora ($01.b)		; 12 01 ; OR accumulator with memory (indirect) ($01.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $12.b,S		; 43 12 ; Exclusive OR accumulator with stack relative $12.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $25.b		; 06 25 ; Arithmetic shift left $25.b [Reads: Direct Page] [Flags: NCZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($12.b)		; 12 12 ; OR accumulator with memory (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$83.b]		; 07 83 ; OR accumulator with memory (long) [$83.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $B3.b		; 00 B3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $12.b,S		; 03 12 ; OR accumulator with stack relative $12.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora ($12.b,X)		; 01 12 ; Logical OR ($12.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $010602.l		; 22 02 06 01 ; Jump to subroutine long $010602.l [Writes: Stack Pointer] [Flow: call]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$09.b]		; 07 09 ; OR accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $122302.l		; 22 02 23 12 ; Jump to subroutine long $122302.l [Writes: Stack Pointer] [Flow: call]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0B.b,S		; 03 0B ; OR accumulator with stack relative $0B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($84.b)		; 12 84 ; OR accumulator with memory (indirect) ($84.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $94.b		; 00 94 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($12.b,X)		; 01 12 ; Logical OR ($12.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($25.b,X)		; 01 25 ; Logical OR ($25.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($00.b)		; 12 00 ; OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $9B2B.w		; EC 2B 9B ; Compare $9B2B.w with X register [Reads: X Index] [Flags: NCZ]
	brk $31.b		; 00 31 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $05C7.w		; 6E C7 05 ; Rotate right $05C7.w [Flags: NCZ]
	ora $C33E.w,X		; 1D 3E C3 ; OR accumulator with memory $C33E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dec $D7.b,X		; D6 D7 ; Decrement memory $D7.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	eor ($69.b,X)		; 41 69 ; Exclusive OR accumulator with memory ($69.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	asl $4B.b		; 06 4B ; Arithmetic shift left $4B.b [Reads: Direct Page] [Flags: NCZ]
	jmp $E24C.w		; 4C 4C E2 ; Jump to $E24C.w [Flow: jump]
	eor $AACC.w		; 4D CC AA ; Exclusive OR $AACC.w with accumulator [Writes: Accumulator] [Flags: NZ]
	adc [$E3.b]		; 67 E3 ; Add with carry (long) [$E3.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $4948.w,Y		; 19 48 49 ; OR accumulator with memory $4948.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy $1D1C.w		; CC 1C 1D ; Compare $1D1C.w with Y register [Reads: Y Index] [Flags: NCZ]
	sta $AA1D1D.l,X		; 9F 1D 1D AA ; Store accumulator (long,X) $AA1D1D.l,X [Reads: Accumulator, X Index]
	ora $1CB2.w,X		; 1D B2 1C ; OR accumulator with memory $1CB2.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rol $0600.w		; 2E 00 06 ; Rotate left $0600.w [Flags: NCZ]
	eor $1DAA.w,X		; 5D AA 1D ; Exclusive OR accumulator with memory $1DAA.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $AA.b,S		; 83 AA ; Store accumulator (stack relative) $AA.b,S [Reads: Stack Pointer, Accumulator]
	lda $2460.w,Y		; B9 60 24 ; Load $2460.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc ($0B.b,X)		; 61 0B ; Add with carry ($0B.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	adc $17.b,S		; 63 17 ; Add with carry (stack relative) $17.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	tsb $08EC.w		; 0C EC 08 ; Test and set bits $08EC.w [Reads: Accumulator] [Flags: Z]
	dec $AA.b		; C6 AA ; Decrement $AA.b [Reads: Direct Page] [Flags: NZ]
	ora $0265.w,X		; 1D 65 02 ; OR accumulator with memory $0265.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $0C6662.l		; 22 62 66 0C ; Jump to subroutine long $0C6662.l [Writes: Stack Pointer] [Flow: call]
	jsl $030323.l		; 22 23 03 03 ; Jump to subroutine long $030323.l [Writes: Stack Pointer] [Flow: call]
	ora [$69.b],Y		; 17 69 ; OR accumulator with memory (long indexed) [$69.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cop $8A.b		; 02 8A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	lda $6F6E.w,Y		; B9 6E 6F ; Load $6F6E.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $7163.w		; ED 63 71 ; Subtract $7163.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	tsb $B2.b		; 04 B2 ; Test and set bits $B2.b [Reads: Accumulator] [Flags: Z]
	cpx $03.b		; E4 03 ; Compare $03.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	adc $71.b,X		; 75 71 ; Add $71.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $62, $EE, $00		; 62 EE 00 ; Push effective relative address $62, $EE, $00 [Writes: Stack Pointer]
	cmp #$62.b		; C9 62 ; Compare #$62.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	ora ($2D.b)		; 12 2D ; OR accumulator with memory (indirect) ($2D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $F1.b,S		; 03 F1 ; OR accumulator with stack relative $F1.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $811D80.l,X		; 7F 80 1D 81 ; Add long $811D80.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $82, $71, $94		; 82 71 94 ; Branch always long to $82, $71, $94 [Flow: branch]
	sta $F2.b,X		; 95 F2 ; Store accumulator to $F2.b,X [Reads: Accumulator, X Index]
	sbc ($9F.b,S),Y		; F3 9F ; Subtract with carry (stack relative indirect indexed) ($9F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sta [$F4.b]		; 87 F4 ; Store accumulator (long) [$F4.b] [Reads: Direct Page, Accumulator]
	sbc $3EF5.w,Y		; F9 F5 3E ; Subtract with carry $3EF5.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $8B.b		; 65 8B ; Add $8B.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	stx $96.b,Y		; 96 96 ; Store X register $96.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	asl $F6.b		; 06 F6 ; Arithmetic shift left $F6.b [Reads: Direct Page] [Flags: NCZ]
	lda ($92.b)		; B2 92 ; Load accumulator (indirect) ($92.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc [$F1.b],Y		; F7 F1 ; Subtract with carry (long indexed) [$F1.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $2D.b		; 45 2D ; Exclusive OR $2D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $62, $96, $06		; 62 96 06 ; Push effective relative address $62, $96, $06 [Writes: Stack Pointer]
	eor ($6A.b,S),Y		; 53 6A ; XOR accumulator (stack relative indirect indexed) ($6A.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $06.b		; 04 06 ; Test and set bits $06.b [Reads: Accumulator] [Flags: Z]
	sbc $9F.b		; E5 9F ; Subtract $9F.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $9962.w,X		; 1D 62 99 ; OR accumulator with memory $9962.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $F9, $E0		; 62 F9 E0 ; Push effective relative address $62, $F9, $E0 [Writes: Stack Pointer]
	bit $83.b		; 24 83 ; Test bits $83.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	rol $9F82.w		; 2E 82 9F ; Rotate left $9F82.w [Flags: NCZ]
	jsr $4544.w		; 20 44 45 ; Jump to subroutine at $4544.w [Writes: Stack Pointer] [Flow: call]
	lda ($9A.b,X)		; A1 9A ; Load accumulator ($9A.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	jsr ($A4A3.w,X)		; FC A3 A4 ; Jump to subroutine indirect indexed ($A4A3.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $A7A6.w,X		; FD A6 A7 ; Subtract with carry $A7A6.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $03A82E.l,X		; 9F 2E A8 03 ; Store accumulator (long,X) $03A82E.l,X [Reads: Accumulator, X Index]
	sed		; F8 ; Set decimal flag [Flags: D]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	sta $919A.w,Y		; 99 9A 91 ; Store accumulator to $919A.w,Y [Reads: Y Index, Accumulator]
	inc $9A9A.w,X		; FE 9A 9A ; Increment memory $9A9A.w,X [Reads: X Index] [Flags: NZ]
	ldy $0303.w		; AC 03 03 ; Load $0303.w into Y register [Writes: Y Index] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $261200.l,X		; FF 00 12 26 ; Subtract with carry (long,X) $261200.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($01.b,S),Y		; 13 01 ; OR accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($12.b)		; 12 12 ; OR accumulator with memory (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $13.b		; 25 13 ; Logical AND $13.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$13.b]		; 27 13 ; AND accumulator with memory (long) [$13.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($12.b,X)		; 01 12 ; Logical OR ($12.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($22.b)		; 12 22 ; OR accumulator with memory (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,S),Y		; 13 00 ; OR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($2A.b)		; 12 2A ; OR accumulator with memory (indirect) ($2A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,S),Y		; 13 00 ; OR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($24.b)		; 12 24 ; OR accumulator with memory (indirect) ($24.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,S),Y		; 13 00 ; OR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($2E.b,X)		; 01 2E ; Logical OR ($2E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($22.b,S),Y		; 13 22 ; OR accumulator (stack relative indirect indexed) ($22.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	ora ($01.b,S),Y		; 13 01 ; OR accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $000102.l		; 22 02 01 00 ; Jump to subroutine long $000102.l [Writes: Stack Pointer] [Flow: call]
	cop $28.b		; 02 28 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,S),Y		; 13 01 ; OR accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $02.b,S		; 23 02 ; AND accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	ora ($02.b,S),Y		; 13 02 ; OR accumulator (stack relative indirect indexed) ($02.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($83.b,S),Y		; 13 83 ; OR accumulator (stack relative indirect indexed) ($83.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $51.b		; 00 51 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	ora ($01.b,S),Y		; 13 01 ; OR accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $130302.l		; 22 02 03 13 ; Jump to subroutine long $130302.l [Writes: Stack Pointer] [Flow: call]
	ora ($02.b)		; 12 02 ; OR accumulator with memory (indirect) ($02.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($22.b,S),Y		; 13 22 ; OR accumulator (stack relative indirect indexed) ($22.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($22.b)		; 12 22 ; OR accumulator with memory (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,S),Y		; 13 01 ; OR accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $02.b		; 25 02 ; Logical AND $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $130112.l		; 22 12 01 13 ; Jump to subroutine long $130112.l [Writes: Stack Pointer] [Flow: call]
	ora ($22.b)		; 12 22 ; OR accumulator with memory (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($22.b,S),Y		; 13 22 ; OR accumulator (stack relative indirect indexed) ($22.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $13.b,S		; 03 13 ; OR accumulator with stack relative $13.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($12.b,S),Y		; 13 12 ; OR accumulator (stack relative indirect indexed) ($12.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and [$13.b]		; 27 13 ; AND accumulator with memory (long) [$13.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $030002.l		; 22 02 00 03 ; Jump to subroutine long $030002.l [Writes: Stack Pointer] [Flow: call]
	and #$13.b		; 29 13 ; Logical AND #$13.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($12.b,X)		; 01 12 ; Logical OR ($12.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($22.b,S),Y		; 13 22 ; OR accumulator (stack relative indirect indexed) ($22.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $23.b,S		; 03 23 ; OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,S),Y		; 13 00 ; OR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($24.b)		; 12 24 ; OR accumulator with memory (indirect) ($24.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,S),Y		; 13 02 ; OR accumulator (stack relative indirect indexed) ($02.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($12.b)		; 12 12 ; OR accumulator with memory (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $2B.b,S		; 03 2B ; OR accumulator with stack relative $2B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,S),Y		; 13 00 ; OR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $2F.b,S		; 03 2F ; OR accumulator with stack relative $2F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($2F.b,X)		; 01 2F ; Logical OR ($2F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $FF.b,S		; 03 FF ; OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $00.b		; 66 00 ; Rotate right $00.b [Reads: Direct Page] [Flags: NCZ]
	ora ($46.b,X)		; 01 46 ; Logical OR ($46.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lsr $65.b		; 46 65 ; Logical shift right $65.b [Reads: Direct Page] [Flags: NCZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	adc [$0D.b]		; 67 0D ; Add with carry (long) [$0D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($46.b,X)		; 01 46 ; Logical OR ($46.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lsr $62.b		; 46 62 ; Logical shift right $62.b [Reads: Direct Page] [Flags: NCZ]
	ora $01.b,X		; 15 01 ; OR accumulator with memory $01.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lda #$0C.b		; A9 0C ; Load #$0C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	stz $18.b		; 64 18 ; Store zero to $18.b
	ora ($16.b,X)		; 01 16 ; Logical OR ($16.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $62.b,X		; 16 62 ; Arithmetic shift left $62.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $4606.w,X		; 1D 06 46 ; OR accumulator with memory $4606.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$20.b]		; 07 20 ; OR accumulator with memory (long) [$20.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $21.b,X		; 16 21 ; Arithmetic shift left $21.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	jsl $2362C3.l		; 22 C3 62 23 ; Jump to subroutine long $2362C3.l [Writes: Stack Pointer] [Flow: call]
	tsb $0C.b		; 04 0C ; Test and set bits $0C.b [Reads: Accumulator] [Flags: Z]
	rol $27.b		; 26 27 ; Rotate left $27.b [Reads: Direct Page] [Flags: NCZ]
	asl $16.b,X		; 16 16 ; Arithmetic shift left $16.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ror $28.b		; 66 28 ; Rotate right $28.b [Reads: Direct Page] [Flags: NCZ]
	tsb $CC.b		; 04 CC ; Test and set bits $CC.b [Reads: Accumulator] [Flags: Z]
	cmp $C331.w		; CD 31 C3 ; Compare $C331.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp $68.b,S		; C3 68 ; Compare accumulator (stack relative) $68.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	and $C3C301.l		; 2F 01 C3 C3 ; AND accumulator with memory (long) $C3C301.l [Writes: Accumulator] [Flags: NZ]
	.db $62, $D1, $05		; 62 D1 05 ; Push effective relative address $62, $D1, $05 [Writes: Stack Pointer]
	ora $38D4.w,X		; 1D D4 38 ; OR accumulator with memory $38D4.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $3A16.w,Y		; 39 16 3A ; AND accumulator with memory $3A16.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $3B0316.l		; 22 16 03 3B ; Jump to subroutine long $3B0316.l [Writes: Stack Pointer] [Flow: call]
	bit $A99F.w,X		; 3C 9F A9 ; Test bits $A99F.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	adc $DB.b,S		; 63 DB ; Add with carry (stack relative) $DB.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cop $AA.b		; 02 AA ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $243E.w,X		; 3D 3E 24 ; AND accumulator with memory $243E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $414008.l,X		; 3F 08 40 41 ; AND accumulator with memory (long,X) $414008.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $DC42B2.l,X		; 9F B2 42 DC ; Store accumulator (long,X) $DC42B2.l,X [Reads: Accumulator, X Index]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	ora $68E9.w,X		; 1D E9 68 ; OR accumulator with memory $68E9.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $0B.b,S		; 43 0B ; Exclusive OR accumulator with stack relative $0B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	sta $F3DCF2.l,X		; 9F F2 DC F3 ; Store accumulator (long,X) $F3DCF2.l,X [Reads: Accumulator, X Index]
	jmp $AA9A.w		; 4C 9A AA ; Jump to $AA9A.w [Flow: jump]
	eor $4543.w		; 4D 43 45 ; Exclusive OR $4543.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lsr $62.b		; 46 62 ; Logical shift right $62.b [Reads: Direct Page] [Flags: NCZ]
	lsr $F704.w		; 4E 04 F7 ; Logical shift right $F704.w [Flags: NCZ]
	sbc ($F8.b)		; F2 F8 ; Subtract with carry (indirect) ($F8.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($DC.b)		; F2 DC ; Subtract with carry (indirect) ($DC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $62, $F9, $04		; 62 F9 04 ; Push effective relative address $62, $F9, $04 [Writes: Stack Pointer]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc [$A8.b],Y		; 77 A8 ; Add with carry (long indexed) [$A8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($52.b),Y		; 51 52 ; Exclusive OR accumulator with memory ($52.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $52, $62		; 62 52 62 ; Push effective relative address $62, $52, $62 [Writes: Stack Pointer]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($DC.b)		; F2 DC ; Subtract with carry (indirect) ($DC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $55.b,S		; 03 55 ; OR accumulator with stack relative $55.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lsr $77.b,X		; 56 77 ; Logical shift right $77.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tsb $2257.w		; 0C 57 22 ; Test and set bits $2257.w [Reads: Accumulator] [Flags: Z]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl $59.b,X		; 16 59 ; Arithmetic shift left $59.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	mvn $69,$09		; 54 09 69 ; Move block negative $69,$09 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sbc ($DC.b)		; F2 DC ; Subtract with carry (indirect) ($DC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	tsb $660C.w		; 0C 0C 66 ; Test and set bits $660C.w [Reads: Accumulator] [Flags: Z]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	ora ($B9.b,X)		; 01 B9 ; Logical OR ($B9.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $62, $85, $00		; 62 85 00 ; Push effective relative address $62, $85, $00 [Writes: Stack Pointer]
	lda $5C6302.l		; AF 02 63 5C ; Load long $5C6302.l into accumulator [Writes: Accumulator] [Flags: NZ]
	mvp $64,$64		; 44 64 64 ; Move block positive $64,$64 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cop $C8.b		; 02 C8 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	adc #$62.b		; 69 62 ; Add #$62.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	ora ($63.b,S),Y		; 13 63 ; OR accumulator (stack relative indirect indexed) ($63.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc #$62.b		; 69 62 ; Add #$62.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	jmp ($6C05.w)		; 6C 05 6C ; Jump indirect to ($6C05.w) [Flow: jump]
	adc $716A70.l		; 6F 70 6A 71 ; Add with carry (long) $716A70.l [Writes: Accumulator] [Flags: NCVZ]
	ora $2E062F.l,X		; 1F 2F 06 2E ; Logical OR long $2E062F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsr $2100.w		; 20 00 21 ; Jump to subroutine at $2100.w [Writes: Stack Pointer] [Flow: call]
	sbc $001326.l,X		; FF 26 13 00 ; Subtract with carry (long,X) $001326.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($2B.b)		; 12 2B ; OR accumulator with memory (indirect) ($2B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($04.b,S),Y		; 13 04 ; OR accumulator (stack relative indirect indexed) ($04.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b)		; 12 01 ; OR accumulator with memory (indirect) ($01.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,S),Y		; 13 01 ; OR accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($00.b,S),Y		; 13 00 ; OR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($26.b)		; 12 26 ; OR accumulator with memory (indirect) ($26.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($0A.b,S),Y		; 13 0A ; OR accumulator (stack relative indirect indexed) ($0A.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($00.b,S),Y		; 13 00 ; OR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,S),Y		; 13 03 ; OR accumulator (stack relative indirect indexed) ($03.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($24.b)		; 12 24 ; OR accumulator with memory (indirect) ($24.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($0D.b,S),Y		; 13 0D ; OR accumulator (stack relative indirect indexed) ($0D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $13.b,S		; 03 13 ; OR accumulator with stack relative $13.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b)		; 12 01 ; OR accumulator with memory (indirect) ($01.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,S),Y		; 13 03 ; OR accumulator (stack relative indirect indexed) ($03.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($12.b,X)		; 01 12 ; Logical OR ($12.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $030113.l		; 22 13 01 03 ; Jump to subroutine long $030113.l [Writes: Stack Pointer] [Flow: call]
	cop $83.b		; 02 83 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: NCZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$13.b]		; 27 13 ; AND accumulator with memory (long) [$13.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $030601.l		; 22 01 06 03 ; Jump to subroutine long $030601.l [Writes: Stack Pointer] [Flow: call]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($12.b,X)		; 01 12 ; Logical OR ($12.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $120713.l		; 22 13 07 12 ; Jump to subroutine long $120713.l [Writes: Stack Pointer] [Flow: call]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $23.b,S		; 03 23 ; OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $12.b		; 02 12 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $030113.l		; 22 13 01 03 ; Jump to subroutine long $030113.l [Writes: Stack Pointer] [Flow: call]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	adc $0701.w		; 6D 01 07 ; Add $0701.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($29.b,S),Y		; 13 29 ; OR accumulator (stack relative indirect indexed) ($29.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b)		; 12 02 ; OR accumulator with memory (indirect) ($02.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,S),Y		; 13 01 ; OR accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $23.b,S		; 03 23 ; OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $01.b,S		; 23 01 ; AND accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $03.b		; 25 03 ; Logical AND $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $01.b,S		; 23 01 ; AND accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($27.b,S),Y		; 13 27 ; OR accumulator (stack relative indirect indexed) ($27.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b)		; 12 02 ; OR accumulator with memory (indirect) ($02.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($22.b,S),Y		; 13 22 ; OR accumulator (stack relative indirect indexed) ($22.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $13.b		; 05 13 ; Logical OR $13.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $03.b,S		; 23 03 ; AND accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $01.b		; 24 01 ; Test bits $01.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	and $03.b		; 25 03 ; Logical AND $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $130101.l		; 22 01 01 13 ; Jump to subroutine long $130101.l [Writes: Stack Pointer] [Flow: call]
	ora ($25.b,S),Y		; 13 25 ; OR accumulator (stack relative indirect indexed) ($25.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $62, $72, $00		; 62 72 00 ; Push effective relative address $62, $72, $00 [Writes: Stack Pointer]
	ora ($62.b,X)		; 01 62 ; Logical OR ($62.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	adc $00.b,X		; 75 00 ; Add $00.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	adc #$78.b		; 69 78 ; Add #$78.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	asl $7E.b		; 06 7E ; Arithmetic shift left $7E.b [Reads: Direct Page] [Flags: NCZ]
	.db $82, $49, $88		; 82 49 88 ; Branch always long to $82, $49, $88 [Flow: branch]
	sta $8B.b,S		; 83 8B ; Store accumulator (stack relative) $8B.b,S [Reads: Stack Pointer, Accumulator]
	bit #$62.b		; 89 62 ; Test bits #$62.b with accumulator [Reads: Accumulator] [Flags: Z]
	sty $12.b		; 84 12 ; Store Y register to $12.b [Reads: Y Index]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $24.b,S		; 23 24 ; AND accumulator with stack relative $24.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ror $0C87.w,X		; 7E 87 0C ; Rotate right $0C87.w,X [Reads: X Index] [Flags: NCZ]
	adc $88.b		; 65 88 ; Add $88.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta ($F2.b,S),Y		; 93 F2 ; Store accumulator (stack relative indirect indexed) ($F2.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	bit #$1C.b		; 89 1C ; Test bits #$1C.b with accumulator [Reads: Accumulator] [Flags: Z]
	ora $8A32.w,X		; 1D 32 8A ; OR accumulator with memory $8A32.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	bit $CC.b,X		; 34 CC ; Test bits $CC.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $30, $4A		; 30 4A ; Branch if minus to $30, $4A [Flow: branch]
	stz $8B.b		; 64 8B ; Store zero to $8B.b
	ora $903A.w,X		; 1D 3A 90 ; OR accumulator with memory $903A.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	ldy #$ADA1.w		; A0 A1 AD ; Load #$ADA1.w into Y register [Writes: Y Index] [Flags: NZ]
	sta ($3D.b),Y		; 91 3D ; Store accumulator ($3D.b),Y [Reads: Direct Page, Y Index, Accumulator]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	sta $C33130.l,X		; 9F 30 31 C3 ; Store accumulator (long,X) $C33130.l,X [Reads: Accumulator, X Index]
	cmp [$92.b]		; C7 92 ; Compare accumulator (long) [$92.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sta ($54.b,S),Y		; 93 54 ; Store accumulator (stack relative indirect indexed) ($54.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sty $95.b,X		; 94 95 ; Store Y register $95.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stx $42.b,Y		; 96 42 ; Store X register $42.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	jmp $4443.w		; 4C 43 44 ; Jump to $4443.w [Flow: jump]
	ora $663E.w,X		; 1D 3E 66 ; OR accumulator with memory $663E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta [$0B.b],Y		; 97 0B ; Store accumulator (long indexed) [$0B.b],Y [Reads: Direct Page, Y Index, Accumulator]
	stx $49.b,Y		; 96 49 ; Store X register $49.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	eor ($53.b)		; 52 53 ; Exclusive OR accumulator with memory (indirect) ($53.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	lda #$1C.b		; A9 1C ; Load #$1C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	eor $4A8B.w		; 4D 8B 4A ; Exclusive OR $4A8B.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $62, $9E, $0D		; 62 9E 0D ; Push effective relative address $62, $9E, $0D [Writes: Stack Pointer]
	sta [$4F.b]		; 87 4F ; Store accumulator (long) [$4F.b] [Reads: Direct Page, Accumulator]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	.db $50, $51		; 50 51 ; Branch if overflow clear to $50, $51 [Flow: branch]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	eor ($1D.b)		; 52 1D ; Exclusive OR accumulator with memory (indirect) ($1D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda ($1C.b)		; B2 1C ; Load accumulator (indirect) ($1C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $4A30.w,X		; 1D 30 4A ; OR accumulator with memory $4A30.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $A1, $01		; 62 A1 01 ; Push effective relative address $62, $A1, $01 [Writes: Stack Pointer]
	eor $9F.b,X		; 55 9F ; Exclusive OR accumulator with memory $9F.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc $56.b		; 65 56 ; Add $56.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $62, $5B, $08		; 62 5B 08 ; Push effective relative address $62, $5B, $08 [Writes: Stack Pointer]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ldy $8B.b		; A4 8B ; Load $8B.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	lsr $B61C.w,X		; 5E 1C B6 ; Logical shift right $B61C.w,X [Reads: X Index] [Flags: NCZ]
	sta $606256.l,X		; 9F 56 62 60 ; Store accumulator (long,X) $606256.l,X [Reads: Accumulator, X Index]
	tsb $06.b		; 04 06 ; Test and set bits $06.b [Reads: Accumulator] [Flags: Z]
	asl $63.b		; 06 63 ; Arithmetic shift left $63.b [Reads: Direct Page] [Flags: NCZ]
	sbc ($4C.b,S),Y		; F3 4C ; Subtract with carry (stack relative indirect indexed) ($4C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	and [$9A.b]		; 27 9A ; AND accumulator with memory (long) [$9A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $91.b		; 04 91 ; Test and set bits $91.b [Reads: Accumulator] [Flags: Z]
	inc $06A5.w,X		; FE A5 06 ; Increment memory $06A5.w,X [Reads: X Index] [Flags: NZ]
	asl $64.b		; 06 64 ; Arithmetic shift left $64.b [Reads: Direct Page] [Flags: NCZ]
	adc $23.b		; 65 23 ; Add $23.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora ($68.b,X)		; 01 68 ; Logical OR ($68.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	adc #$22.b		; 69 22 ; Add #$22.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $6A.b,S		; 63 6A ; Add with carry (stack relative) $6A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora ($70.b,X)		; 01 70 ; Logical OR ($70.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	adc $01E523.l		; 6F 23 E5 01 ; Add with carry (long) $01E523.l [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $6F		; 70 6F ; Branch if overflow set to $70, $6F [Flow: branch]
	jsl $6A62F8.l		; 22 F8 62 6A ; Jump to subroutine long $6A62F8.l [Writes: Stack Pointer] [Flow: call]
	ora ($6C.b,X)		; 01 6C ; Logical OR ($6C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ldx $27.b		; A6 27 ; Load $27.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	ora $72.b,S		; 03 72 ; OR accumulator with stack relative $72.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	stz $22.b,X		; 74 22 ; Store zero to $22.b,X [Reads: X Index]
	jmp ($A700.w)		; 6C 00 A7 ; Jump indirect to ($A700.w) [Flow: jump]
	jsl $480176.l		; 22 76 01 48 ; Jump to subroutine long $480176.l [Writes: Stack Pointer] [Flow: call]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	jsl $770376.l		; 22 76 03 77 ; Jump to subroutine long $770376.l [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	stz $22.b,X		; 74 22 ; Store zero to $22.b,X [Reads: X Index]
	jmp ($6D00.w)		; 6C 00 6D ; Jump indirect to ($6D00.w) [Flow: jump]
	jsl $6E01F8.l		; 22 F8 01 6E ; Jump to subroutine long $6E01F8.l [Writes: Stack Pointer] [Flow: call]
	adc $F824.w,Y		; 79 24 F8 ; Add $F824.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($7A.b,X)		; 01 7A ; Logical OR ($7A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	stz $22.b,X		; 74 22 ; Store zero to $22.b,X [Reads: X Index]
	jmp ($6D00.w)		; 6C 00 6D ; Jump indirect to ($6D00.w) [Flow: jump]
	jsl $A901F8.l		; 22 F8 01 A9 ; Jump to subroutine long $A901F8.l [Writes: Stack Pointer] [Flow: call]
	lda $24.b		; A5 24 ; Load $24.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $221200.l,X		; FF 00 12 22 ; Subtract with carry (long,X) $221200.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($00.b,S),Y		; 13 00 ; OR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($29.b)		; 12 29 ; OR accumulator with memory (indirect) ($29.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,S),Y		; 13 03 ; OR accumulator (stack relative indirect indexed) ($03.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($13.b)		; 12 13 ; OR accumulator with memory (indirect) ($13.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($12.b,S),Y		; 13 12 ; OR accumulator (stack relative indirect indexed) ($12.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	ora ($01.b,S),Y		; 13 01 ; OR accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($13.b)		; 12 13 ; OR accumulator with memory (indirect) ($13.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $12.b		; 24 12 ; Test bits $12.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	and [$01.b]		; 27 01 ; AND accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $13.b		; 24 13 ; Test bits $13.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($25.b,S),Y		; 13 25 ; OR accumulator (stack relative indirect indexed) ($25.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $032213.l		; 22 13 22 03 ; Jump to subroutine long $032213.l [Writes: Stack Pointer] [Flow: call]
	jsl $010200.l		; 22 00 02 01 ; Jump to subroutine long $010200.l [Writes: Stack Pointer] [Flow: call]
	ora $13.b,S		; 03 13 ; OR accumulator with stack relative $13.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	eor ($02.b,X)		; 41 02 ; Exclusive OR accumulator with memory ($02.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,S),Y		; 13 03 ; OR accumulator (stack relative indirect indexed) ($03.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($22.b,S),Y		; 13 22 ; OR accumulator (stack relative indirect indexed) ($22.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,S),Y		; 13 01 ; OR accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $030113.l		; 22 13 01 03 ; Jump to subroutine long $030113.l [Writes: Stack Pointer] [Flow: call]
	ora ($83.b,S),Y		; 13 83 ; OR accumulator (stack relative indirect indexed) ($83.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $3A.b		; 00 3A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $000303.l		; 22 03 03 00 ; Jump to subroutine long $000303.l [Writes: Stack Pointer] [Flow: call]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($22.b,S),Y		; 13 22 ; OR accumulator (stack relative indirect indexed) ($22.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($0B.b,X)		; 01 0B ; Logical OR ($0B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($13.b,S),Y		; 13 13 ; OR accumulator (stack relative indirect indexed) ($13.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($13.b)		; 12 13 ; OR accumulator with memory (indirect) ($13.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $13.b,S		; 03 13 ; OR accumulator with stack relative $13.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,S),Y		; 13 01 ; OR accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	mvp $00,$13		; 44 13 00 ; Move block positive $00,$13 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $72.b		; 00 72 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,S),Y		; 13 03 ; OR accumulator (stack relative indirect indexed) ($03.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $44.b		; 04 44 ; Test and set bits $44.b [Reads: Accumulator] [Flags: Z]
	ora $13.b,S		; 03 13 ; OR accumulator with stack relative $13.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $83.b		; 02 83 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $01, $28		; 62 01 28 ; Push effective relative address $62, $01, $28 [Writes: Stack Pointer]
	ora ($00.b,S),Y		; 13 00 ; OR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $83.b,S		; 03 83 ; OR accumulator with stack relative $83.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $26.b		; 00 26 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b,S),Y		; 13 02 ; OR accumulator (stack relative indirect indexed) ($02.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,S),Y		; 13 01 ; OR accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $132200.l		; 22 00 22 13 ; Jump to subroutine long $132200.l [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $02.b		; 05 02 ; Logical OR $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($12.b)		; 12 12 ; OR accumulator with memory (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($13.b,S),Y		; 13 13 ; OR accumulator (stack relative indirect indexed) ($13.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($13.b,S),Y		; 13 13 ; OR accumulator (stack relative indirect indexed) ($13.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($22.b)		; 12 22 ; OR accumulator with memory (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($22.b,S),Y		; 13 22 ; OR accumulator (stack relative indirect indexed) ($22.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $26.b,S		; 03 26 ; OR accumulator with stack relative $26.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,S),Y		; 13 01 ; OR accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($12.b)		; 12 12 ; OR accumulator with memory (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $120013.l		; 22 13 00 12 ; Jump to subroutine long $120013.l [Writes: Stack Pointer] [Flow: call]
	jsl $132203.l		; 22 03 22 13 ; Jump to subroutine long $132203.l [Writes: Stack Pointer] [Flow: call]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $13.b		; 26 13 ; Rotate left $13.b [Reads: Direct Page] [Flags: NCZ]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $144412.l		; 22 12 44 14 ; Jump to subroutine long $144412.l [Writes: Stack Pointer] [Flow: call]
	ora ($00.b)		; 12 00 ; OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($FF.b)		; 12 FF ; OR accumulator with memory (indirect) ($FF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $A9.b		; 05 A9 ; Logical OR $A9.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $ABAA.w		; 0C AA AB ; Test and set bits $ABAA.w [Reads: Accumulator] [Flags: Z]
	eor ($02.b)		; 52 02 ; Exclusive OR accumulator with memory (indirect) ($02.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	ldy $4613.w		; AC 13 46 ; Load $4613.w into Y register [Writes: Y Index] [Flags: NZ]
	lda $B6.b,X		; B5 B6 ; Load $B6.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
.ACCU 8
.INDEX 8
	sep #$B7		; E2 B7
	lda [$A1.b],Y		; B7 A1 ; Load accumulator (long indexed) [$A1.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda ($78.b,X)		; A1 78 ; Load accumulator ($78.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	lda $0B78.w,Y		; B9 78 0B ; Load $0B78.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	eor $46.b		; 45 46 ; Exclusive OR $46.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $42, $E2		; 42 E2 ; Reserved instruction
	eor $8B23.w		; 4D 23 8B ; Exclusive OR $8B23.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $89.b		; 05 89 ; Logical OR $89.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $8A.b,S		; C3 8A ; Compare accumulator (stack relative) $8A.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	bit #$BB.b		; 89 BB ; Test bits #$BB.b with accumulator [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $62, $BC, $01		; 62 BC 01 ; Push effective relative address $62, $BC, $01 [Writes: Stack Pointer]
	cmp $8A.b,S		; C3 8A ; Compare accumulator (stack relative) $8A.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	.db $62, $BF, $E0		; 62 BF E0 ; Push effective relative address $62, $BF, $E0 [Writes: Stack Pointer]
	and ($9F.b,X)		; 21 9F ; Logical AND ($9F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda ($AA.b)		; B2 AA ; Load accumulator (indirect) ($AA.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $3EB2.w,X		; 1D B2 3E ; OR accumulator with memory $3EB2.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $23.b,S		; C3 23 ; Compare accumulator (stack relative) $23.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	rep #$C3		; C2 C3 ; Reset processor status bits #$C3 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	mvp $86,$44		; 44 44 86 ; Move block positive $86,$44 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	lda #$1C.b		; A9 1C ; Load #$1C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $4441.w,X		; 1D 41 44 ; OR accumulator with memory $4441.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy $44.b		; C4 44 ; Compare $44.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	stx $1C.b		; 86 1C ; Store X register to $1C.b [Reads: X Index]
	trb $8AA4.w		; 1C A4 8A ; Test and reset bits $8AA4.w [Reads: Accumulator] [Flags: Z]
	cmp $4B.b		; C5 4B ; Compare $4B.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sty $B28D.w		; 8C 8D B2 ; Store Y register to $B28D.w [Reads: Y Index]
	ora $48C6.w,X		; 1D C6 48 ; OR accumulator with memory $48C6.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $C7, $E0		; 62 C7 E0 ; Push effective relative address $62, $C7, $E0 [Writes: Stack Pointer]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $1CCA.w		; 8D CA 1C ; Store accumulator to $1CCA.w [Reads: Accumulator]
	lda ($AD.b,X)		; A1 AD ; Load accumulator ($AD.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	jsr $9594.w		; 20 94 95 ; Jump to subroutine at $9594.w [Writes: Stack Pointer] [Flow: call]
	ora $52AA.w,X		; 1D AA 52 ; OR accumulator with memory $52AA.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	wai		; CB ; Wait for interrupt
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	bit #$CC.b		; 89 CC ; Test bits #$CC.b with accumulator [Reads: Accumulator] [Flags: Z]
	cmp $9AAA.w		; CD AA 9A ; Compare $9AAA.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	dec $9CF8.w		; CE F8 9C ; Decrement $9CF8.w [Flags: NZ]
	sta $C1C0.w,X		; 9D C0 C1 ; Store accumulator to $C1C0.w,X [Reads: Accumulator, X Index]
	adc [$CF.b],Y		; 77 CF ; Add with carry (long indexed) [$CF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $1DD0.w,X		; 1D D0 1D ; OR accumulator with memory $1DD0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($DD.b),Y		; D1 DD ; Compare accumulator ($DD.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	trb $D2A4.w		; 1C A4 D2 ; Test and reset bits $D2A4.w [Reads: Accumulator] [Flags: Z]
	cmp ($F8.b,S),Y		; D3 F8 ; Compare accumulator (stack relative indirect indexed) ($F8.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	lda [$A8.b]		; A7 A8 ; Load accumulator (long) [$A8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	pei ($50.b)		; D4 50 ; Push effective indirect address ($50.b) [Reads: Direct Page] [Writes: Stack Pointer]
	sta ($B2.b)		; 92 B2 ; Store accumulator (indirect) ($B2.b) [Reads: Direct Page, Accumulator]
	cmp $B3.b,X		; D5 B3 ; Compare accumulator $B3.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	dec $AC.b,X		; D6 AC ; Decrement memory $AC.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	lda #$3E.b		; A9 3E ; Load #$3E.b into accumulator [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	cmp [$AE.b],Y		; D7 AE ; Compare accumulator (long indexed) [$AE.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	lda $B68AF2.l		; AF F2 8A B6 ; Load long $B68AF2.l into accumulator [Writes: Accumulator] [Flags: NZ]
	ror $D8.b		; 66 D8 ; Rotate right $D8.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cpy #$C1.b		; C0 C1 ; Compare #$C1.b with Y register [Reads: Y Index] [Flags: NCZ]
	lda [$DF.b],Y		; B7 DF ; Load accumulator (long indexed) [$DF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: NCZ]
	lda $A99F.w,Y		; B9 9F A9 ; Load $A99F.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ror $E1.b		; 66 E1 ; Rotate right $E1.b [Reads: Direct Page] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda ($AA.b,X)		; A1 AA ; Load accumulator ($AA.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor $620C.w		; 4D 0C 62 ; Exclusive OR $620C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ldy $9FF2.w,X		; BC F2 9F ; Load Y register $9FF2.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	trb $621D.w		; 1C 1D 62 ; Test and reset bits $621D.w [Reads: Accumulator] [Flags: Z]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $51AA.w,X		; 1D AA 51 ; OR accumulator with memory $51AA.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc [$EB.b],Y		; 77 EB ; Add with carry (long indexed) [$EB.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $ABFB3A.l		; 8F 3A FB AB ; Store accumulator (long) $ABFB3A.l [Reads: Accumulator]
	ldy $C222.w		; AC 22 C2 ; Load $C222.w into Y register [Writes: Y Index] [Flags: NZ]
	asl $A0.b		; 06 A0 ; Arithmetic shift left $A0.b [Reads: Direct Page] [Flags: NCZ]
	sta $EC731D.l,X		; 9F 1D 73 EC ; Store accumulator (long,X) $EC731D.l,X [Reads: Accumulator, X Index]
	dec $626D.w		; CE 6D 62 ; Decrement $626D.w [Flags: NZ]
	sbc $C862.w		; ED 62 C8 ; Subtract $C862.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	jsl $A962FB.l		; 22 FB 62 A9 ; Jump to subroutine long $A962FB.l [Writes: Stack Pointer] [Flow: call]
	brk $CB.b		; 00 CB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $F0.b		; 65 F0 ; Add $F0.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $75EF.w		; 0D EF 75 ; Logical OR $75EF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ror $56.b,X		; 76 56 ; Rotate right $56.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	inc $9B.b,X		; F6 9B ; Increment memory $9B.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $D0, $C9		; D0 C9 ; Branch if not equal to $D0, $C9 [Flow: branch]
	cmp ($F7.b),Y		; D1 F7 ; Compare accumulator ($F7.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	adc $F8.b		; 65 F8 ; Add $F8.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	eor [$66.b]		; 47 66 ; Exclusive OR accumulator with memory (long) [$66.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $0000.w,Y		; F9 00 00 ; Subtract with carry $0000.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $62, $73, $03		; 62 73 03 ; Push effective relative address $62, $73, $03 [Writes: Stack Pointer]
	ora ($6D.b,X)		; 01 6D ; Logical OR ($6D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $45.b		; 02 45 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $241100.l,X		; FF 00 11 24 ; Subtract with carry (long,X) $241100.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	trb $43.b		; 14 43 ; Test and reset bits $43.b [Reads: Accumulator] [Flags: Z]
	ora ($14.b),Y		; 11 14 ; OR accumulator with memory ($14.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $11.b,S		; 23 11 ; AND accumulator with stack relative $11.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $14.b,S		; 03 14 ; OR accumulator with stack relative $14.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	trb $11.b		; 14 11 ; Test and reset bits $11.b [Reads: Accumulator] [Flags: Z]
	ora ($23.b),Y		; 11 23 ; OR accumulator with memory ($23.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $01.b		; 14 01 ; Test and reset bits $01.b [Reads: Accumulator] [Flags: Z]
	ora ($14.b),Y		; 11 14 ; OR accumulator with memory ($14.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008311.l		; 22 11 83 00 ; Jump to subroutine long $008311.l [Writes: Stack Pointer] [Flow: call]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	trb $22.b		; 14 22 ; Test and reset bits $22.b [Reads: Accumulator] [Flags: Z]
	ora ($25.b),Y		; 11 25 ; OR accumulator with memory ($25.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $02.b		; 14 02 ; Test and reset bits $02.b [Reads: Accumulator] [Flags: Z]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $22.b		; 14 22 ; Test and reset bits $22.b [Reads: Accumulator] [Flags: Z]
	ora ($84.b),Y		; 11 84 ; OR accumulator with memory ($84.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $14,$11		; 44 11 14 ; Move block positive $14,$11 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	jsl $110214.l		; 22 14 02 11 ; Jump to subroutine long $110214.l [Writes: Stack Pointer] [Flow: call]
	trb $14.b		; 14 14 ; Test and reset bits $14.b [Reads: Accumulator] [Flags: Z]
	and $11.b,S		; 23 11 ; AND accumulator with stack relative $11.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $14.b,S		; 23 14 ; AND accumulator with stack relative $14.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ora $1143.w		; 0D 43 11 ; Logical OR $1143.w with accumulator [Writes: Accumulator] [Flags: NZ]
	trb $22.b		; 14 22 ; Test and reset bits $22.b [Reads: Accumulator] [Flags: Z]
	ora ($23.b),Y		; 11 23 ; OR accumulator with memory ($23.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $01.b		; 14 01 ; Test and reset bits $01.b [Reads: Accumulator] [Flags: Z]
	ora ($12.b),Y		; 11 12 ; OR accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $11.b,S		; 43 11 ; Exclusive OR accumulator with stack relative $11.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	trb $02.b		; 14 02 ; Test and reset bits $02.b [Reads: Accumulator] [Flags: Z]
	trb $11.b		; 14 11 ; Test and reset bits $11.b [Reads: Accumulator] [Flags: Z]
	trb $24.b		; 14 24 ; Test and reset bits $24.b [Reads: Accumulator] [Flags: Z]
	ora ($83.b),Y		; 11 83 ; OR accumulator with memory ($83.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $54.b		; 00 54 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $11.b		; 45 11 ; Exclusive OR $11.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $00.b		; 14 00 ; Test and reset bits $00.b [Reads: Accumulator] [Flags: Z]
	trb $22.b		; 14 22 ; Test and reset bits $22.b [Reads: Accumulator] [Flags: Z]
	ora ($84.b),Y		; 11 84 ; OR accumulator with memory ($84.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	eor [$03.b],Y		; 57 03 ; Exclusive OR accumulator with memory (long indexed) [$03.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b)		; 12 11 ; OR accumulator with memory (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $14.b		; 14 14 ; Test and reset bits $14.b [Reads: Accumulator] [Flags: Z]
	and $11.b,S		; 23 11 ; AND accumulator with stack relative $11.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $14.b		; 26 14 ; Rotate left $14.b [Reads: Direct Page] [Flags: NCZ]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $14.b,S		; 23 14 ; AND accumulator with stack relative $14.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $11.b,S		; 23 11 ; AND accumulator with stack relative $11.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $14.b		; 26 14 ; Rotate left $14.b [Reads: Direct Page] [Flags: NCZ]
	tsb $11.b		; 04 11 ; Test and set bits $11.b [Reads: Accumulator] [Flags: Z]
	ora ($11.b)		; 12 11 ; OR accumulator with memory (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($14.b),Y		; 11 14 ; OR accumulator with memory ($14.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $11.b,S		; 23 11 ; AND accumulator with stack relative $11.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $14.b		; 25 14 ; Logical AND $14.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $11.b,S		; 03 11 ; OR accumulator with stack relative $11.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($12.b),Y		; 11 12 ; OR accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($22.b),Y		; 11 22 ; OR accumulator with memory ($22.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $01.b		; 14 01 ; Test and reset bits $01.b [Reads: Accumulator] [Flags: Z]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and [$14.b]		; 27 14 ; AND accumulator with memory (long) [$14.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $112314.l		; 22 14 23 11 ; Jump to subroutine long $112314.l [Writes: Stack Pointer] [Flow: call]
	ora ($14.b,X)		; 01 14 ; Logical OR ($14.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($44.b)		; 12 44 ; OR accumulator with memory (indirect) ($44.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($14.b),Y		; 11 14 ; OR accumulator with memory ($14.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	and $11.b		; 25 11 ; Logical AND $11.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($14.b,X)		; 01 14 ; Logical OR ($14.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	trb $22.b		; 14 22 ; Test and reset bits $22.b [Reads: Accumulator] [Flags: Z]
	ora ($26.b),Y		; 11 26 ; OR accumulator with memory ($26.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $01.b		; 14 01 ; Test and reset bits $01.b [Reads: Accumulator] [Flags: Z]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $14.b		; 24 14 ; Test bits $14.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($26.b),Y		; 11 26 ; OR accumulator with memory ($26.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $86.b		; 14 86 ; Test and reset bits $86.b [Reads: Accumulator] [Flags: Z]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $11.b,S		; 23 11 ; AND accumulator with stack relative $11.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $14.b,S		; 43 14 ; Exclusive OR accumulator with stack relative $14.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($FF.b),Y		; 11 FF ; OR accumulator with memory ($FF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $3B.b		; 00 3B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $03.b		; 64 03 ; Store zero to $03.b
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	eor ($08.b)		; 52 08 ; Exclusive OR accumulator with memory (indirect) ($08.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit #$09.b		; 89 09 ; Test bits #$09.b with accumulator [Reads: Accumulator] [Flags: Z]
	lsr $3D.b		; 46 3D ; Logical shift right $3D.b [Reads: Direct Page] [Flags: NCZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $0B0A.w,X		; 3C 0A 0B ; Test bits $0B0A.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	and $636C.w,Y		; 39 6C 63 ; AND accumulator with memory $636C.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tsb $5E0C.w		; 0C 0C 5E ; Test and set bits $5E0C.w [Reads: Accumulator] [Flags: Z]
	.db $10, $BB		; 10 BB ; Branch if plus to $10, $BB [Flow: branch]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cmp [$11.b]		; C7 11 ; Compare accumulator (long) [$11.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora ($CF.b)		; 12 CF ; OR accumulator with memory (indirect) ($CF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($14.b,S),Y		; 13 14 ; OR accumulator (stack relative indirect indexed) ($14.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($35.b)		; 32 35 ; AND accumulator with memory (indirect) ($35.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror $1565.w		; 6E 65 15 ; Rotate right $1565.w [Flags: NCZ]
	ora $1B4376.l		; 0F 76 43 1B ; OR accumulator with memory (long) $1B4376.l [Writes: Accumulator] [Flags: NZ]
	sbc $52.b		; E5 52 ; Subtract $52.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp ($1C.b),Y		; D1 1C ; Compare accumulator ($1C.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $CA1E.w,X		; 1D 1E CA ; OR accumulator with memory $CA1E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	wai		; CB ; Wait for interrupt
	ora $8115B3.l,X		; 1F B3 15 81 ; Logical OR long $8115B3.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $20, $06		; 62 20 06 ; Push effective relative address $62, $20, $06 [Writes: Stack Pointer]
	eor ($23.b)		; 52 23 ; Exclusive OR accumulator with memory (indirect) ($23.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $98.b		; 24 98 ; Test bits $98.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	and $866C.w,Y		; 39 6C 86 ; AND accumulator with memory $866C.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $25.b,S		; 63 25 ; Add with carry (stack relative) $25.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	and #$2A.b		; 29 2A ; Logical AND #$2A.b with accumulator [Writes: Accumulator] [Flags: NZ]
	eor ($52.b)		; 52 52 ; Exclusive OR accumulator with memory (indirect) ($52.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	jmp ($9F2C.w)		; 6C 2C 9F ; Jump indirect to ($9F2C.w) [Flow: jump]
	and ($33.b)		; 32 33 ; AND accumulator with memory (indirect) ($33.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $2D.b,S		; 63 2D ; Add with carry (stack relative) $2D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora #$5C.b		; 09 5C ; Logical OR #$5C.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $983198.l		; 0F 98 31 98 ; OR accumulator with memory (long) $983198.l [Writes: Accumulator] [Flags: NZ]
	and ($33.b)		; 32 33 ; AND accumulator with memory (indirect) ($33.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $34.b,X		; 35 34 ; Logical AND $34.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sta $1F3B62.l,X		; 9F 62 3B 1F ; Store accumulator (long,X) $1F3B62.l,X [Reads: Accumulator, X Index]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $18.b,X		; 35 18 ; Logical AND $18.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc #$14.b		; 69 14 ; Add #$14.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $379F36.l,X		; 9F 36 9F 37 ; Store accumulator (long,X) $379F36.l,X [Reads: Accumulator, X Index]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	and $399F.w,Y		; 39 9F 39 ; AND accumulator with memory $399F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	mvp $3C,$3B		; 44 3B 3C ; Move block positive $3C,$3B [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	adc #$14.b		; 69 14 ; Add #$14.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $249F3D.l,X		; 9F 3D 9F 24 ; Store accumulator (long,X) $249F3D.l,X [Reads: Accumulator, X Index]
	stz $3E.b,X		; 74 3E ; Store zero to $3E.b,X [Reads: X Index]
	and $3332B2.l,X		; 3F B2 32 33 ; AND accumulator with memory (long,X) $3332B2.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $4066.w		; 4D 66 40 ; Exclusive OR $4066.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $9F.b		; 00 9F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $47.b,S		; 63 47 ; Add with carry (stack relative) $47.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $52.b,S		; 03 52 ; OR accumulator with stack relative $52.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $6656.w,X		; 3C 56 66 ; Test bits $6656.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sta $3C3B1F.l,X		; 9F 1F 3B 3C ; Store accumulator (long,X) $3C3B1F.l,X [Reads: Accumulator, X Index]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	eor ($39.b)		; 52 39 ; Exclusive OR accumulator with memory (indirect) ($39.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $62, $65, $52		; 62 65 52 ; Push effective relative address $62, $65, $52 [Writes: Stack Pointer]
	ora $9E.b,S		; 03 9E ; OR accumulator with stack relative $9E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $627424.l,X		; 9F 24 74 62 ; Store accumulator (long,X) $627424.l,X [Reads: Accumulator, X Index]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	tsb $32.b		; 04 32 ; Test and set bits $32.b [Reads: Accumulator] [Flags: Z]
	and ($5B.b,S),Y		; 33 5B ; AND accumulator (stack relative indirect indexed) ($5B.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor ($53.b)		; 52 53 ; Exclusive OR accumulator with memory (indirect) ($53.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $5C.b,S		; 63 5C ; Add with carry (stack relative) $5C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora ($3F.b,X)		; 01 3F ; Logical OR ($3F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda ($62.b)		; B2 62 ; Load accumulator (indirect) ($62.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	eor ($42.b,X)		; 41 42 ; Exclusive OR accumulator with memory ($42.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $2863.w,X		; 3C 63 28 ; Test bits $2863.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	eor $26.b,X		; 55 26 ; Exclusive OR accumulator with memory $26.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lsr $5E64.w,X		; 5E 64 5E ; Logical shift right $5E64.w,X [Reads: X Index] [Flags: NCZ]
	lsr $6665.w,X		; 5E 65 66 ; Logical shift right $6665.w,X [Reads: X Index] [Flags: NCZ]
	eor ($67.b)		; 52 67 ; Exclusive OR accumulator with memory (indirect) ($67.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	eor #$39.b		; 49 39 ; Exclusive OR #$39.b with accumulator [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	eor $53.b,X		; 55 53 ; Exclusive OR accumulator with memory $53.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jmp ($66A2.w)		; 6C A2 66 ; Jump indirect to ($66A2.w) [Flow: jump]
	adc #$01.b		; 69 01 ; Add #$01.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	and ($33.b)		; 32 33 ; AND accumulator with memory (indirect) ($33.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	stz $70.b		; 64 70 ; Store zero to $70.b
	ora ($77.b,X)		; 01 77 ; Logical OR ($77.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $65.b,X		; 34 65 ; Test bits $65.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	adc $08.b,X		; 75 08 ; Add $08.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $3C3B.w		; 2E 3B 3C ; Rotate left $3C3B.w [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $7C3B.w,X		; 3D 3B 7C ; AND accumulator with memory $7C3B.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldx $0083.w		; AE 83 00 ; Load $0083.w into X register [Writes: X Index] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $7B.b,S		; 03 7B ; OR accumulator with stack relative $7B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $7D.b		; 85 7D ; Store accumulator to $7D.b [Reads: Accumulator]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $231422.l,X		; FF 22 14 23 ; Subtract with carry (long,X) $231422.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($03.b),Y		; 11 03 ; OR accumulator with memory ($03.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $00.b		; 14 00 ; Test and reset bits $00.b [Reads: Accumulator] [Flags: Z]
	trb $14.b		; 14 14 ; Test and reset bits $14.b [Reads: Accumulator] [Flags: Z]
	bit $11.b		; 24 11 ; Test bits $11.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	trb $14.b		; 14 14 ; Test and reset bits $14.b [Reads: Accumulator] [Flags: Z]
	ora ($14.b),Y		; 11 14 ; OR accumulator with memory ($14.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $26.b		; 14 26 ; Test and reset bits $26.b [Reads: Accumulator] [Flags: Z]
	ora ($23.b),Y		; 11 23 ; OR accumulator with memory ($23.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $43.b		; 14 43 ; Test and reset bits $43.b [Reads: Accumulator] [Flags: Z]
	ora ($14.b),Y		; 11 14 ; OR accumulator with memory ($14.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and [$11.b]		; 27 11 ; AND accumulator with memory (long) [$11.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $14.b,S		; 03 14 ; OR accumulator with stack relative $14.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b)		; 12 11 ; OR accumulator with memory (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($23.b),Y		; 11 23 ; OR accumulator with memory ($23.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $02.b		; 14 02 ; Test and reset bits $02.b [Reads: Accumulator] [Flags: Z]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $25.b		; 14 25 ; Test and reset bits $25.b [Reads: Accumulator] [Flags: Z]
	ora ($01.b),Y		; 11 01 ; OR accumulator with memory ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $11.b		; 14 11 ; Test and reset bits $11.b [Reads: Accumulator] [Flags: Z]
	bit $14.b		; 24 14 ; Test bits $14.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($22.b),Y		; 11 22 ; OR accumulator with memory ($22.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $22.b		; 14 22 ; Test and reset bits $22.b [Reads: Accumulator] [Flags: Z]
	ora ($29.b),Y		; 11 29 ; OR accumulator with memory ($29.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $25.b		; 14 25 ; Test and reset bits $25.b [Reads: Accumulator] [Flags: Z]
	ora ($2B.b),Y		; 11 2B ; OR accumulator with memory ($2B.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $83.b		; 14 83 ; Test and reset bits $83.b [Reads: Accumulator] [Flags: Z]
	brk $26.b		; 00 26 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $14.b,S		; 23 14 ; AND accumulator with stack relative $14.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $14.b		; 26 14 ; Rotate left $14.b [Reads: Direct Page] [Flags: NCZ]
	bit $11.b		; 24 11 ; Test bits $11.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	and $0014.w		; 2D 14 00 ; Logical AND $0014.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($23.b),Y		; 11 23 ; OR accumulator with memory ($23.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $00.b		; 14 00 ; Test and reset bits $00.b [Reads: Accumulator] [Flags: Z]
	ora ($22.b),Y		; 11 22 ; OR accumulator with memory ($22.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $00.b		; 14 00 ; Test and reset bits $00.b [Reads: Accumulator] [Flags: Z]
	ora ($43.b)		; 12 43 ; OR accumulator with memory (indirect) ($43.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($14.b),Y		; 11 14 ; OR accumulator with memory ($14.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	rol $11.b		; 26 11 ; Rotate left $11.b [Reads: Direct Page] [Flags: NCZ]
	cop $14.b		; 02 14 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $11.b		; 14 11 ; Test and reset bits $11.b [Reads: Accumulator] [Flags: Z]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $112214.l		; 22 14 22 11 ; Jump to subroutine long $112214.l [Writes: Stack Pointer] [Flow: call]
	and $14.b,S		; 23 14 ; AND accumulator with stack relative $14.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $120211.l		; 22 11 02 12 ; Jump to subroutine long $120211.l [Writes: Stack Pointer] [Flow: call]
	ora ($11.b)		; 12 11 ; OR accumulator with memory (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $008414.l		; 22 14 84 00 ; Jump to subroutine long $008414.l [Writes: Stack Pointer] [Flow: call]
	rol $1400.w		; 2E 00 14 ; Rotate left $1400.w [Flags: NCZ]
	eor $14.b		; 45 14 ; Exclusive OR $14.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b),Y		; 11 02 ; OR accumulator with memory ($02.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($14.b),Y		; 11 14 ; OR accumulator with memory ($14.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $24.b		; 14 24 ; Test and reset bits $24.b [Reads: Accumulator] [Flags: Z]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $24.b		; 14 24 ; Test and reset bits $24.b [Reads: Accumulator] [Flags: Z]
	ora ($01.b),Y		; 11 01 ; OR accumulator with memory ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $11.b		; 14 11 ; Test and reset bits $11.b [Reads: Accumulator] [Flags: Z]
	and $14.b,S		; 23 14 ; AND accumulator with stack relative $14.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($24.b),Y		; 11 24 ; OR accumulator with memory ($24.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $25.b		; 14 25 ; Test and reset bits $25.b [Reads: Accumulator] [Flags: Z]
	ora ($22.b),Y		; 11 22 ; OR accumulator with memory ($22.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $2D.b		; 14 2D ; Test and reset bits $2D.b [Reads: Accumulator] [Flags: Z]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $22.b		; 14 22 ; Test and reset bits $22.b [Reads: Accumulator] [Flags: Z]
	ora ($FF.b),Y		; 11 FF ; OR accumulator with memory ($FF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tsb $7F7E.w		; 0C 7E 7F ; Test and set bits $7F7E.w [Reads: Accumulator] [Flags: Z]
	jsl $52C952.l		; 22 52 C9 52 ; Jump to subroutine long $52C952.l [Writes: Stack Pointer] [Flow: call]
	eor ($80.b)		; 52 80 ; Exclusive OR accumulator with memory (indirect) ($80.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $468126.l,X		; 1F 26 81 46 ; Logical OR long $468126.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $3B62.w,X		; 3D 62 3B ; AND accumulator with memory $3B62.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	.db $82, $83, $BA		; 82 83 BA ; Branch always long to $82, $83, $BA [Flow: branch]
	eor ($0B.b)		; 52 0B ; Exclusive OR accumulator with memory (indirect) ($0B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sty $DA.b		; 84 DA ; Store Y register to $DA.b [Reads: Y Index]
	sta $86.b		; 85 86 ; Store accumulator to $86.b [Reads: Accumulator]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cmp [$62.b]		; C7 62 ; Compare accumulator (long) [$62.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sec		; 38 ; Set carry flag [Flags: C]
	ora $8738.w		; 0D 38 87 ; Logical OR $8738.w with accumulator [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	bit #$A6.b		; 89 A6 ; Test bits #$A6.b with accumulator [Reads: Accumulator] [Flags: Z]
	.db $82, $E5, $8A		; 82 E5 8A ; Branch always long to $82, $E5, $8A [Flow: branch]
	sbc $BB.b		; E5 BB ; Subtract $BB.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ror $77.b,X		; 76 77 ; Rotate right $77.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	bit $62.b,X		; 34 62 ; Test bits $62.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and ($03.b)		; 32 03 ; AND accumulator with memory (indirect) ($03.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	tsb $F952.w		; 0C 52 F9 ; Test and set bits $F952.w [Reads: Accumulator] [Flags: Z]
	adc $8C.b,S		; 63 8C ; Add with carry (stack relative) $8C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $52.b,S		; 03 52 ; OR accumulator with stack relative $52.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	.db $90, $84		; 90 84 ; Branch if carry clear to $90, $84 [Flow: branch]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	tsb $A002.w		; 0C 02 A0 ; Test and set bits $A002.w [Reads: Accumulator] [Flags: Z]
	sty $89.b		; 84 89 ; Store Y register to $89.b [Reads: Y Index]
	stz $91.b		; 64 91 ; Store zero to $91.b
	ora ($52.b,X)		; 01 52 ; Logical OR ($52.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	.db $62, $96, $02		; 62 96 02 ; Push effective relative address $62, $96, $02 [Writes: Stack Pointer]
.ACCU 8
.INDEX 8
	sep #$3A		; E2 3A
	sec		; 38 ; Set carry flag [Flags: C]
	adc #$99.b		; 69 99 ; Add #$99.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	ora [$B3.b]		; 07 B3 ; OR accumulator with memory (long) [$B3.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda ($81.b,S),Y		; B3 81 ; Load accumulator (stack relative indirect indexed) ($81.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ror $77.b,X		; 76 77 ; Rotate right $77.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	bit $A3.b,X		; 34 A3 ; Test bits $A3.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sta $00A462.l,X		; 9F 62 A4 00 ; Store accumulator (long,X) $00A462.l,X [Reads: Accumulator, X Index]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	adc $A7.b,S		; 63 A7 ; Add with carry (stack relative) $A7.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $4F.b		; 05 4F ; Logical OR $4F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	ldy $3D84.w		; AC 84 3D ; Load $3D84.w into Y register [Writes: Y Index] [Flags: NZ]
	adc $AD.b,S		; 63 AD ; Add with carry (stack relative) $AD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora ($BB.b,X)		; 01 BB ; Logical OR ($BB.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta $B163.w,Y		; 99 63 B1 ; Store accumulator to $B163.w,Y [Reads: Y Index, Accumulator]
	tsb $B556.w		; 0C 56 B5 ; Test and set bits $B556.w [Reads: Accumulator] [Flags: Z]
	cmp ($BB.b),Y		; D1 BB ; Compare accumulator ($BB.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	and [$38.b],Y		; 37 38 ; AND accumulator with memory (long indexed) [$38.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	stx $B6.b,Y		; 96 B6 ; Store X register $B6.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	lda [$29.b],Y		; B7 29 ; Load accumulator (long indexed) [$29.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	sta $00B962.l,X		; 9F 62 B9 00 ; Store accumulator (long,X) $00B962.l,X [Reads: Accumulator, X Index]
	lsr $BC63.w,X		; 5E 63 BC ; Logical shift right $BC63.w,X [Reads: X Index] [Flags: NCZ]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $C0.b,S		; 63 C0 ; Add with carry (stack relative) $C0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	brk $52.b		; 00 52 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $C4, $04		; 62 C4 04 ; Push effective relative address $62, $C4, $04 [Writes: Stack Pointer]
	tsb $C789.w		; 0C 89 C7 ; Test and set bits $C789.w [Reads: Accumulator] [Flags: Z]
	eor ($C8.b)		; 52 C8 ; Exclusive OR accumulator with memory (indirect) ($C8.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $62, $3B, $0A		; 62 3B 0A ; Push effective relative address $62, $3B, $0A [Writes: Stack Pointer]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	stx $52.b		; 86 52 ; Store X register to $52.b [Reads: X Index]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	cmp #$CA.b		; C9 CA ; Compare #$CA.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	lda ($19.b,S),Y		; B3 19 ; Load accumulator (stack relative indirect indexed) ($19.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor ($CB.b)		; 52 CB ; Exclusive OR accumulator with memory (indirect) ($CB.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldx #$62.b		; A2 62 ; Load #$62.b into X register [Writes: X Index] [Flags: NZ]
	cpy $C702.w		; CC 02 C7 ; Compare $C702.w with Y register [Reads: Y Index] [Flags: NCZ]
	sec		; 38 ; Set carry flag [Flags: C]
	eor $63.b,S		; 43 63 ; Exclusive OR accumulator with stack relative $63.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $52CB16.l		; CF 16 CB 52 ; Compare accumulator (long) $52CB16.l [Reads: Accumulator] [Flags: NCZ]
	eor ($2A.b)		; 52 2A ; Exclusive OR accumulator with memory (indirect) ($2A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	eor $D4D3.w		; 4D D3 D4 ; Exclusive OR $D4D3.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and ($33.b,S),Y		; 33 33 ; AND accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $21.b,X		; 34 21 ; Test bits $21.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	tsb $D5CA.w		; 0C CA D5 ; Test and set bits $D5CA.w [Reads: Accumulator] [Flags: Z]
	rol $5E.b		; 26 5E ; Rotate left $5E.b [Reads: Direct Page] [Flags: NCZ]
	dec $9B.b,X		; D6 9B ; Decrement memory $9B.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	cmp [$46.b],Y		; D7 46 ; Compare accumulator (long indexed) [$46.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
.INDEX 16
	rep #$D8		; C2 D8
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	stz $890A.w		; 9C 0A 89 ; Store zero to $890A.w
	lsr $5210.w,X		; 5E 10 52 ; Logical shift right $5210.w,X [Reads: X Index] [Flags: NCZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	cmp $3A3A.w,Y		; D9 3A 3A ; Compare accumulator $3A3A.w,Y [Reads: Y Index] [Flags: NCZ]
	.db $62, $CC, $01		; 62 CC 01 ; Push effective relative address $62, $CC, $01 [Writes: Stack Pointer]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	stz $DA.b		; 64 DA ; Store zero to $DA.b
	ora ($95.b,X)		; 01 95 ; Logical OR ($95.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and ($83.b,S),Y		; 33 83 ; AND accumulator (stack relative indirect indexed) ($83.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $2C.b		; 00 2C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $DF.b		; 05 DF ; Logical OR $DF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx #$3333.w		; E0 33 33 ; Compare #$3333.w with X register [Reads: X Index] [Flags: NCZ]
	bit $3C.b,X		; 34 3C ; Test bits $3C.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	tsb $3B00.w		; 0C 00 3B ; Test and set bits $3B00.w [Reads: Accumulator] [Flags: Z]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	sbc ($62.b,X)		; E1 62 ; Subtract with carry ($62.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $14000A.l,X		; FF 0A 00 14 ; Subtract with carry (long,X) $14000A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $01.b		; 14 01 ; Test and reset bits $01.b [Reads: Accumulator] [Flags: Z]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	trb $22.b		; 14 22 ; Test and reset bits $22.b [Reads: Accumulator] [Flags: Z]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	trb $83.b		; 14 83 ; Test and reset bits $83.b [Reads: Accumulator] [Flags: Z]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $000101.l		; 22 01 01 00 ; Jump to subroutine long $000101.l [Writes: Stack Pointer] [Flow: call]
	ora ($25.b,X)		; 01 25 ; Logical OR ($25.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	trb $09.b		; 14 09 ; Test and reset bits $09.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $14.b		; 25 14 ; Logical AND $14.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $010300.l		; 22 00 03 01 ; Jump to subroutine long $010300.l [Writes: Stack Pointer] [Flow: call]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	ora ($25.b,X)		; 01 25 ; Logical OR ($25.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	trb $06.b		; 14 06 ; Test and reset bits $06.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $25.b		; 04 25 ; Test and set bits $25.b [Reads: Accumulator] [Flags: Z]
	ora ($0C.b,X)		; 01 0C ; Logical OR ($0C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	trb $07.b		; 14 07 ; Test and reset bits $07.b [Reads: Accumulator] [Flags: Z]
	trb $14.b		; 14 14 ; Test and reset bits $14.b [Reads: Accumulator] [Flags: Z]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $15.b		; 04 15 ; Test and set bits $15.b [Reads: Accumulator] [Flags: Z]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	jsl $010515.l		; 22 15 05 01 ; Jump to subroutine long $010515.l [Writes: Stack Pointer] [Flow: call]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $15.b		; 00 15 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $22.b,X		; 15 22 ; OR accumulator with memory $22.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $150000.l		; 22 00 00 15 ; Jump to subroutine long $150000.l [Writes: Stack Pointer] [Flow: call]
	jsl $040801.l		; 22 01 08 04 ; Jump to subroutine long $040801.l [Writes: Stack Pointer] [Flow: call]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $05.b,X		; 15 05 ; OR accumulator with memory $05.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	jsl $000008.l		; 22 08 00 00 ; Jump to subroutine long $000008.l [Writes: Stack Pointer] [Flow: call]
	jsl $030C04.l		; 22 04 0C 03 ; Jump to subroutine long $030C04.l [Writes: Stack Pointer] [Flow: call]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $22.b,X		; 15 22 ; OR accumulator with memory $22.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($84.b,X)		; 01 84 ; Logical OR ($84.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $B2.b		; 00 B2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $15.b,S		; 03 15 ; OR accumulator with stack relative $15.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $22.b,X		; 15 22 ; OR accumulator with memory $22.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $0C22.w		; 0E 22 0C ; Arithmetic shift left $0C22.w [Flags: NCZ]
	asl $08.b		; 06 08 ; Arithmetic shift left $08.b [Reads: Direct Page] [Flags: NCZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $15.b		; 00 15 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $010300.l		; 22 00 03 01 ; Jump to subroutine long $010300.l [Writes: Stack Pointer] [Flow: call]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $22.b,X		; 15 22 ; OR accumulator with memory $22.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $08.b,S		; 23 08 ; AND accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $15.b		; 06 15 ; Arithmetic shift left $15.b [Reads: Direct Page] [Flags: NCZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $15.b,X		; 15 15 ; OR accumulator with memory $15.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $010300.l		; 22 00 03 01 ; Jump to subroutine long $010300.l [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$24.b]		; 07 24 ; OR accumulator with memory (long) [$24.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $00.b,X		; 15 00 ; OR accumulator with memory $00.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $E2070A.l,X		; FF 0A 07 E2 ; Subtract with carry (long,X) $E2070A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $1D1D.w,X		; 3C 1D 1D ; Test bits $1D1D.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	bit $3CE3.w,X		; 3C E3 3C ; Test bits $3CE3.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	ora $771D.w,X		; 1D 1D 77 ; OR accumulator with memory $771D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $E4.b,S		; 63 E4 ; Add with carry (stack relative) $E4.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sbc [$00.b]		; E7 00 ; Subtract with carry (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($7F.b,X)		; 01 7F ; Logical OR ($7F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	stz $72.b,X		; 74 72 ; Store zero to $72.b,X [Reads: X Index]
	ora $6261.w,X		; 1D 61 62 ; OR accumulator with memory $6261.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	eor ($5B.b,X)		; 41 5B ; Exclusive OR accumulator with memory ($5B.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc $E8.b,S		; 63 E8 ; Add with carry (stack relative) $E8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc [$09.b]		; E7 09 ; Subtract with carry (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	stz $EC.b,X		; 74 EC ; Store zero to $EC.b,X [Reads: X Index]
	and $1E.b,X		; 35 1E ; Logical AND $1E.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc [$68.b]		; 67 68 ; Add with carry (long) [$68.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $6548.w,X		; 1D 48 65 ; OR accumulator with memory $6548.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $070B.w		; ED 0B 07 ; Subtract $070B.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	bit $1D74.w,X		; 3C 74 1D ; Test bits $1D74.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	cmp $2E1D29.l,X		; DF 29 1D 2E ; Compare accumulator (long,X) $2E1D29.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	sbc ($E7.b,S),Y		; F3 E7 ; Subtract with carry (stack relative indirect indexed) ($E7.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	adc $F4.b,S		; 63 F4 ; Add with carry (stack relative) $F4.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora #$00.b		; 09 00 ; Logical OR #$00.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($7F.b,X)		; 01 7F ; Logical OR ($7F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $B95A.w,X		; 3C 5A B9 ; Test bits $B95A.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	ora $081E.w,X		; 1D 1E 08 ; OR accumulator with memory $081E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $F8, $62		; 62 F8 62 ; Push effective relative address $62, $F8, $62 [Writes: Stack Pointer]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	asl $0A09.w,X		; 1E 09 0A ; Arithmetic shift left $0A09.w,X [Reads: X Index] [Flags: NCZ]
	stz $B9.b,X		; 74 B9 ; Store zero to $B9.b,X [Reads: X Index]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ldy $1D3C.w,X		; BC 3C 1D ; Load Y register $1D3C.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	cpx $03.b		; E4 03 ; Compare $03.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $62, $FD, $F4		; 62 FD F4 ; Push effective relative address $62, $FD, $F4 [Writes: Stack Pointer]
	inc $79FF.w,X		; FE FF 79 ; Increment memory $79FF.w,X [Reads: X Index] [Flags: NZ]
	sbc $BD.b		; E5 BD ; Subtract $BD.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	brk $DB.b		; 00 DB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $42, $1D		; 42 1D ; Reserved instruction
	cpx $E5.b		; E4 E5 ; Compare $E5.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc $78.b		; E5 78 ; Subtract $78.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $62.b,S		; 03 62 ; OR accumulator with stack relative $62.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $7A.b		; E5 7A ; Subtract $7A.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $04A5.w,X		; 1D A5 04 ; OR accumulator with memory $04A5.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $22.b		; 05 22 ; Logical OR $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; [PATTERN: Memory clearing operation] 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $B6C6.w		; 0C C6 B6 ; Test and set bits $B6C6.w [Reads: Accumulator] [Flags: Z]
	and $F3.b,X		; 35 F3 ; Logical AND $F3.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	stz $0A.b		; 64 0A ; Store zero to $0A.b
	stz $D9.b,X		; 74 D9 ; Store zero to $D9.b,X [Reads: X Index]
	and ($1D.b,X)		; 21 1D ; Logical AND ($1D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	trb $061D.w		; 1C 1D 06 ; Test and reset bits $061D.w [Reads: Accumulator] [Flags: Z]
	jsl $C70CE5.l		; 22 E5 0C C7 ; Jump to subroutine long $C70CE5.l [Writes: Stack Pointer] [Flow: call]
	lda ($08.b)		; B2 08 ; Load accumulator (indirect) ($08.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$67.b]		; 07 67 ; OR accumulator with memory (long) [$67.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($0B.b,S),Y		; 93 0B ; Store accumulator (stack relative indirect indexed) ($0B.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	stz $1D.b		; 64 1D ; Store zero to $1D.b
	cpy #$D4C1.w		; C0 C1 D4 ; Compare #$D4C1.w with Y register [Reads: Y Index] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	.db $62, $31, $0C		; 62 31 0C ; Push effective relative address $62, $31, $0C [Writes: Stack Pointer]
	lsr $BA.b,X		; 56 BA ; Logical shift right $BA.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc $77.b		; E5 77 ; Subtract $77.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $71.b		; 02 71 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $C5.b		; 26 C5 ; Rotate left $C5.b [Reads: Direct Page] [Flags: NCZ]
	eor ($4B.b,S),Y		; 53 4B ; XOR accumulator (stack relative indirect indexed) ($4B.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	.db $62, $3C, $E0		; 62 3C E0 ; Push effective relative address $62, $3C, $E0 [Writes: Stack Pointer]
	mvp $5A,$74		; 44 74 5A ; Move block positive $5A,$74 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $0856.w,X		; 1D 56 08 ; OR accumulator with memory $0856.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora #$2F.b		; 09 2F ; Logical OR #$2F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	eor $56.b,X		; 55 56 ; Exclusive OR accumulator with memory $56.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $1D, $61		; 62 1D 61 ; Push effective relative address $62, $1D, $61 [Writes: Stack Pointer]
	ldy $3CA5.w		; AC A5 3C ; Load $3CA5.w into Y register [Writes: Y Index] [Flags: NZ]
	ora #$1C.b		; 09 1C ; Logical OR #$1C.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $080A.w,X		; 1D 0A 08 ; OR accumulator with memory $080A.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	and ($7C.b)		; 32 7C ; AND accumulator with memory (indirect) ($7C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $0D070B.l,X		; FF 0B 07 0D ; Subtract with carry (long,X) $0D070B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx #$30AA.w		; A2 AA 30 ; Load #$30AA.w into X register [Writes: X Index] [Flags: NZ]
	adc ($62.b,X)		; 61 62 ; Add with carry ($62.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $3D.b		; 00 3D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda [$53.b]		; A7 53 ; Load accumulator (long) [$53.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	trb $671D.w		; 1C 1D 67 ; Test and reset bits $671D.w [Reads: Accumulator] [Flags: Z]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	cmp ($0A.b)		; D2 0A ; Compare accumulator (indirect) ($0A.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora #$07.b		; 09 07 ; Logical OR #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $A4A3.w,X		; 1D A3 A4 ; OR accumulator with memory $A4A3.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda $0BAE.w		; AD AE 0B ; Load $0BAE.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp $DFAA.w,Y		; D9 AA DF ; Compare accumulator $DFAA.w,Y [Reads: Y Index] [Flags: NCZ]
	and #$0C.b		; 29 0C ; Logical AND #$0C.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0084.w		; 0D 84 00 ; Logical OR $0084.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cpy #$1D01.w		; C0 01 1D ; Compare #$1D01.w with Y register [Reads: Y Index] [Flags: NCZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $1D.b		; 24 1D ; Test bits $1D.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora $E6.b,S		; 03 E6 ; OR accumulator with stack relative $E6.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $1D0A.w,X		; 1D 0A 1D ; OR accumulator with memory $1D0A.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $220124.l,X		; FF 24 01 22 ; Subtract with carry (long,X) $220124.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $26.b,S		; 03 26 ; OR accumulator with stack relative $26.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $27.b,S		; 03 27 ; OR accumulator with stack relative $27.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$01.b]		; 27 01 ; AND accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $84.b		; 04 84 ; Test and set bits $84.b [Reads: Accumulator] [Flags: Z]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $01.b		; 26 01 ; Rotate left $01.b [Reads: Direct Page] [Flags: NCZ]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($12.b,X)		; 01 12 ; Logical OR ($12.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $26.b,S		; 03 26 ; OR accumulator with stack relative $26.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($15.b)		; 12 15 ; OR accumulator with memory (indirect) ($15.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $26.b,S		; 03 26 ; OR accumulator with stack relative $26.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($15.b,X)		; 01 15 ; Logical OR ($15.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $22.b,X		; 15 22 ; OR accumulator with memory $22.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	lsr $08.b,X		; 56 08 ; Logical shift right $08.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	ora ($00.b)		; 12 00 ; OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $84.b		; 04 84 ; Test and set bits $84.b [Reads: Accumulator] [Flags: Z]
	brk $73.b		; 00 73 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora ($12.b)		; 12 12 ; OR accumulator with memory (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $15.b		; 04 15 ; Test and set bits $15.b [Reads: Accumulator] [Flags: Z]
	ora $04.b,X		; 15 04 ; OR accumulator with memory $04.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $12.b,X		; 15 12 ; OR accumulator with memory $12.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($22.b)		; 12 22 ; OR accumulator with memory (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	ora $15.b,S		; 03 15 ; OR accumulator with stack relative $15.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $04.b,X		; 15 04 ; OR accumulator with memory $04.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	ora $01.b,X		; 15 01 ; OR accumulator with memory $01.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b)		; 12 00 ; OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	adc ($04.b),Y		; 71 04 ; Add with carry ($04.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	jsl $010103.l		; 22 03 01 01 ; Jump to subroutine long $010103.l [Writes: Stack Pointer] [Flow: call]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $06.b		; 04 06 ; Test and set bits $06.b [Reads: Accumulator] [Flags: Z]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $15.b		; 04 15 ; Test and set bits $15.b [Reads: Accumulator] [Flags: Z]
	ora ($12.b)		; 12 12 ; OR accumulator with memory (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $85.b,X		; 15 85 ; OR accumulator with memory $85.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $6E.b		; 00 6E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	and $04.b		; 25 04 ; Logical AND $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $12.b		; 04 12 ; Test and set bits $12.b [Reads: Accumulator] [Flags: Z]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $040201.l		; 22 01 02 04 ; Jump to subroutine long $040201.l [Writes: Stack Pointer] [Flow: call]
	ora ($05.b)		; 12 05 ; OR accumulator with memory (indirect) ($05.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $15.b,S		; 23 15 ; AND accumulator with stack relative $15.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	ora ($12.b)		; 12 12 ; OR accumulator with memory (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $22.b,X		; 15 22 ; OR accumulator with memory $22.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b)		; 12 01 ; OR accumulator with memory (indirect) ($01.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	sbc $EDED04.l,X		; FF 04 ED ED ; Subtract with carry (long,X) $EDED04.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $22FF.w,Y		; F9 FF 22 ; Subtract with carry $22FF.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	rol $F8.b		; 26 F8 ; Rotate left $F8.b [Reads: Direct Page] [Flags: NCZ]
	tsb $75.b		; 04 75 ; Test and set bits $75.b [Reads: Accumulator] [Flags: Z]
	sbc $F9E5.w		; ED E5 F9 ; Subtract $F9E5.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	adc [$22.b],Y		; 77 22 ; Add with carry (long indexed) [$22.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	rol $F8.b		; 26 F8 ; Rotate left $F8.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	dec $86.b,X		; D6 86 ; Decrement memory $86.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	ora $569F.w,X		; 1D 9F 56 ; OR accumulator with memory $569F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor [$03.b],Y		; 57 03 ; Exclusive OR accumulator with memory (long indexed) [$03.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $5A.b,S		; 03 5A ; OR accumulator with stack relative $5A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $F8.b		; 26 F8 ; Rotate left $F8.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	dec $DD.b,X		; D6 DD ; Decrement memory $DD.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	ora $B2.b,S		; 03 B2 ; OR accumulator with stack relative $B2.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $5756.w,X		; 1D 56 57 ; OR accumulator with memory $5756.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $5A.b,S		; 03 5A ; OR accumulator with stack relative $5A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $F8.b		; 26 F8 ; Rotate left $F8.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	adc $ABF3.w,X		; 7D F3 AB ; Add $ABF3.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($83.b)		; F2 83 ; Subtract with carry (indirect) ($83.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $5756.w,X		; 1D 56 57 ; OR accumulator with memory $5756.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	rol $F8.b		; 26 F8 ; Rotate left $F8.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jmp ($697E.w)		; 6C 7E 69 ; Jump indirect to ($697E.w) [Flow: jump]
	asl $8061.w		; 0E 61 80 ; Arithmetic shift left $8061.w [Flags: NCZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	lsr $BA.b,X		; 56 BA ; Logical shift right $BA.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	rol $E5.b		; 26 E5 ; Rotate left $E5.b [Reads: Direct Page] [Flags: NCZ]
	ora $156C6C.l,X		; 1F 6C 6C 15 ; Logical OR long $156C6C.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $E61610.l		; 0F 10 16 E6 ; OR accumulator with memory (long) $E61610.l [Writes: Accumulator] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	ora $9F1D.w,X		; 1D 1D 9F ; OR accumulator with memory $9F1D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $0881.w,X		; 1D 81 08 ; OR accumulator with memory $0881.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	lda ($6C.b)		; B2 6C ; Load accumulator (indirect) ($6C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jmp ($5815.w)		; 6C 15 58 ; Jump indirect to ($5815.w) [Flow: jump]
	eor $0316.w,Y		; 59 16 03 ; Exclusive OR accumulator with memory $0316.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sty $1D.b		; 84 1D ; Store Y register to $1D.b [Reads: Y Index]
	sta $1D.b,S		; 83 1D ; Store accumulator (stack relative) $1D.b,S [Reads: Stack Pointer, Accumulator]
	sta $86.b		; 85 86 ; Store accumulator to $86.b [Reads: Accumulator]
	sbc $E6.b		; E5 E6 ; Subtract $E6.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $62, $87, $1F		; 62 87 1F ; Push effective relative address $62, $87, $1F [Writes: Stack Pointer]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc ($23.b,X)		; 61 23 ; Add with carry ($23.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $8A.b		; 24 8A ; Test bits $8A.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sta $83.b,S		; 83 83 ; Store accumulator (stack relative) $83.b,S [Reads: Stack Pointer, Accumulator]
	ora $A88B.w,X		; 1D 8B A8 ; OR accumulator with memory $A88B.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda ($E4.b)		; B2 E4 ; Load accumulator (indirect) ($E4.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $8C.b		; E5 8C ; Subtract $8C.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	ora $03B2.w,X		; 1D B2 03 ; OR accumulator with memory $03B2.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $8A2E.w,X		; 1D 2E 8A ; OR accumulator with memory $8A2E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $11.b,S		; 03 11 ; OR accumulator with stack relative $11.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($8F.b)		; 12 8F ; OR accumulator with memory (indirect) ($8F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($FC.b,S),Y		; 13 FC ; OR accumulator (stack relative indirect indexed) ($FC.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc ($1D.b)		; F2 1D ; Subtract with carry (indirect) ($1D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $03.b,S		; E3 03 ; Subtract stack-relative $03.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	sta $22.b,S		; 83 22 ; Store accumulator (stack relative) $22.b,S [Reads: Stack Pointer, Accumulator]
	ora $911A.w,X		; 1D 1A 91 ; OR accumulator with memory $911A.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta ($B2.b)		; 92 B2 ; Store accumulator (indirect) ($B2.b) [Reads: Direct Page, Accumulator]
	trb $15.b		; 14 15 ; Test and reset bits $15.b [Reads: Accumulator] [Flags: Z]
	sta $96.b,X		; 95 96 ; Store accumulator to $96.b,X [Reads: Accumulator, X Index]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	asl $F0.b,X		; 16 F0 ; Arithmetic shift left $F0.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc $1D.b,S		; E3 1D ; Subtract stack-relative $1D.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	sta $1D831D.l,X		; 9F 1D 83 1D ; Store accumulator (long,X) $1D831D.l,X [Reads: Accumulator, X Index]
	sta [$03.b],Y		; 97 03 ; Store accumulator (long indexed) [$03.b],Y [Reads: Direct Page, Y Index, Accumulator]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	stz $986C.w		; 9C 6C 98 ; Store zero to $986C.w
	adc [$5A.b],Y		; 77 5A ; Add with carry (long indexed) [$5A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $2295.w,Y		; F9 95 22 ; Subtract with carry $2295.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	ora ($99.b,X)		; 01 99 ; Logical OR ($99.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta $460083.l,X		; 9F 83 00 46 ; Store accumulator (long,X) $460083.l,X [Reads: Accumulator, X Index]
	ora $9C.b,X		; 15 9C ; OR accumulator with memory $9C.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	sbc $179C.w,Y		; F9 9C 17 ; Subtract with carry $179C.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc #$69.b		; 69 69 ; Add #$69.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ldy #$561D.w		; A0 1D 56 ; Load #$561D.w into Y register [Writes: Y Index] [Flags: NZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	sbc $BB.b		; E5 BB ; Subtract $BB.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ldx #$A419.w		; A2 19 A4 ; Load #$A419.w into X register [Writes: X Index] [Flags: NZ]
	lda $AB.b		; A5 AB ; Load $AB.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $62, $A6, $62		; 62 A6 62 ; Push effective relative address $62, $A6, $62 [Writes: Stack Pointer]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	tsb $9A.b		; 04 9A ; Test and set bits $9A.b [Reads: Accumulator] [Flags: Z]
	ldy #$1D1D.w		; A0 1D 1D ; Load #$1D1D.w into Y register [Writes: Y Index] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	jsl $AE02AB.l		; 22 AB 02 AE ; Jump to subroutine long $AE02AB.l [Writes: Stack Pointer] [Flow: call]
	adc #$25.b		; 69 25 ; Add #$25.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	adc $1A.b,S		; 63 1A ; Add with carry (stack relative) $1A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $46.b		; 05 46 ; Logical OR $46.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $AA.b,X		; B5 AA ; Load $AA.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	asl $6922.w,X		; 1E 22 69 ; Arithmetic shift left $6922.w,X [Reads: X Index] [Flags: NCZ]
	ora ($B7.b,X)		; 01 B7 ; Logical OR ($B7.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	sbc $000125.l,X		; FF 25 01 00 ; Subtract with carry (long,X) $000125.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $2E.b,S		; 03 2E ; OR accumulator with stack relative $2E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($0E.b,X)		; 01 0E ; Logical OR ($0E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $15.b,X		; 15 15 ; OR accumulator with memory $15.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $29.b,S		; 03 29 ; OR accumulator with stack relative $29.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $26.b,S		; 03 26 ; OR accumulator with stack relative $26.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	ora $28.b,S		; 03 28 ; OR accumulator with stack relative $28.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	jsl $000604.l		; 22 04 06 00 ; Jump to subroutine long $000604.l [Writes: Stack Pointer] [Flow: call]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b)		; 12 00 ; OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $01.b,S		; 23 01 ; AND accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $040902.l		; 22 02 09 04 ; Jump to subroutine long $040902.l [Writes: Stack Pointer] [Flow: call]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b)		; 12 00 ; OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($12.b)		; 12 12 ; OR accumulator with memory (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $24.b,X		; 15 24 ; OR accumulator with memory $24.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	cop $15.b		; 02 15 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	.db $80, $02		; 80 02 ; Branch always to $80, $02 [Flow: branch]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	ora $22.b		; 05 22 ; Logical OR $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($04.b)		; 12 04 ; OR accumulator with memory (indirect) ($04.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $000104.l		; 22 04 01 00 ; Jump to subroutine long $000104.l [Writes: Stack Pointer] [Flow: call]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $23.b		; 04 23 ; Test and set bits $23.b [Reads: Accumulator] [Flags: Z]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $15.b,S		; 03 15 ; OR accumulator with stack relative $15.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $12.b,S		; 23 12 ; AND accumulator with stack relative $12.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	eor $06.b,S		; 43 06 ; Exclusive OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $12.b		; 02 12 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	ora ($01.b)		; 12 01 ; OR accumulator with memory (indirect) ($01.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($12.b,X)		; 01 12 ; Logical OR ($12.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	ora ($05.b)		; 12 05 ; OR accumulator with memory (indirect) ($05.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $15.b		; 04 15 ; Test and set bits $15.b [Reads: Accumulator] [Flags: Z]
	ora $15.b		; 05 15 ; Logical OR $15.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	and $12.b,S		; 23 12 ; AND accumulator with stack relative $12.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl L000304.l		; 22 04 83 00 ; Jump to subroutine long L000304.l [Writes: Stack Pointer] [Flow: call]
	inc $06FF.w		; EE FF 06 ; Increment $06FF.w [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $F8F8.w		; ED F8 F8 ; Subtract $F8F8.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sbc $F8245A.l,X		; FF 5A 24 F8 ; Subtract with carry (long,X) $F8245A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $F82203.l		; 22 03 22 F8 ; Jump to subroutine long $F82203.l [Writes: Stack Pointer] [Flow: call]
	stx $00.b		; 86 00 ; Store X register to $00.b [Reads: X Index]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $F8F8.w		; EC F8 F8 ; Compare $F8F8.w with X register [Reads: X Index] [Flags: NCZ]
	jsl $F82203.l		; 22 03 22 F8 ; Jump to subroutine long $F82203.l [Writes: Stack Pointer] [Flow: call]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsl $F82203.l		; 22 03 22 F8 ; Jump to subroutine long $F82203.l [Writes: Stack Pointer] [Flow: call]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $F87220.l,X		; 1F 20 72 F8 ; Logical OR long $F87220.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $F82203.l		; 22 03 22 F8 ; Jump to subroutine long $F82203.l [Writes: Stack Pointer] [Flow: call]
	ora $ED.b		; 05 ED ; Logical OR $ED.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $E5.b		; E5 E5 ; Subtract $E5.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc [$5A.b],Y		; 77 5A ; Add with carry (long indexed) [$5A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $62, $75, $00		; 62 75 00 ; Push effective relative address $62, $75, $00 [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsl $F80703.l		; 22 03 07 F8 ; Jump to subroutine long $F80703.l [Writes: Stack Pointer] [Flow: call]
	sbc $E5.b		; E5 E5 ; Subtract $E5.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	lda $56BA.w,Y		; B9 BA 56 ; Load $56BA.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	bit $E5.b		; 24 E5 ; Test bits $E5.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	jsl $F81E03.l		; 22 03 1E F8 ; Jump to subroutine long $F81E03.l [Writes: Stack Pointer] [Flow: call]
	ora $A9.b,S		; 03 A9 ; OR accumulator with stack relative $A9.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $BCBB.w,Y		; B9 BB BC ; Load $BCBB.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lda ($1C.b)		; B2 1C ; Load accumulator (indirect) ($1C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $B2.b,S		; 03 B2 ; OR accumulator with stack relative $B2.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	trb $9F83.w		; 1C 83 9F ; Test and reset bits $9F83.w [Reads: Accumulator] [Flags: Z]
	cpx $03.b		; E4 03 ; Compare $03.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $F8.b,S		; 03 F8 ; OR accumulator with stack relative $F8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	adc $9FBD.w,Y		; 79 BD 9F ; Add $9FBD.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $B9.b,S		; 83 B9 ; Store accumulator (stack relative) $B9.b,S [Reads: Stack Pointer, Accumulator]
	ldx $831C.w,Y		; BE 1C 83 ; Load X register $831C.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	sta $9F.b,S		; 83 9F ; Store accumulator (stack relative) $9F.b,S [Reads: Stack Pointer, Accumulator]
	ora $84E4.w,X		; 1D E4 84 ; OR accumulator with memory $84E4.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $4E.b		; 00 4E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $9F.b		; 04 9F ; Test and set bits $9F.b [Reads: Accumulator] [Flags: Z]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $C079.w,Y		; B9 79 C0 ; Load $C079.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	adc $1C05.w,Y		; 79 05 1C ; Add $1C05.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $E5E4.w,X		; 1D E4 E5 ; OR accumulator with memory $E5E4.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	stx $2221.w		; 8E 21 22 ; Store X register to $2221.w [Reads: X Index]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cpx #$7926.w		; E0 26 79 ; Compare #$7926.w with X register [Reads: X Index] [Flags: NCZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	ora $B283.w,X		; 1D 83 B2 ; OR accumulator with memory $B283.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	trb $AA1D.w		; 1C 1D AA ; Test and reset bits $AA1D.w [Reads: Accumulator] [Flags: Z]
	ora $15B2.w,X		; 1D B2 15 ; OR accumulator with memory $15B2.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc [$7B.b]		; 67 7B ; Add with carry (long) [$7B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $E5.b		; E5 E5 ; Subtract $E5.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	ora $BAB9.w,X		; 1D B9 BA ; OR accumulator with memory $BAB9.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1CAA9F.l,X		; 5F 9F AA 1C ; Exclusive OR accumulator with memory (long,X) $1CAA9F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $03.b,S		; 83 03 ; Store accumulator (stack relative) $03.b,S [Reads: Stack Pointer, Accumulator]
	sta $C7989C.l,X		; 9F 9C 98 C7 ; Store accumulator (long,X) $C7989C.l,X [Reads: Accumulator, X Index]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta $BBB91C.l,X		; 9F 1C B9 BB ; Store accumulator (long,X) $BBB91C.l,X [Reads: Accumulator, X Index]
	ldy $C861.w,X		; BC 61 C8 ; Load Y register $C861.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	stx $AB23.w		; 8E 23 AB ; Store X register to $AB23.w [Reads: X Index]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lsr $B1.b,X		; 56 B1 ; Logical shift right $B1.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	adc ($61.b,X)		; 61 61 ; Add with carry ($61.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp #$BD.b		; C9 BD ; Compare #$BD.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	adc $B1.b,S		; 63 B1 ; Add with carry (stack relative) $B1.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	jsl $E06923.l		; 22 23 69 E0 ; Jump to subroutine long $E06923.l [Writes: Stack Pointer] [Flow: call]
	jsl $03F2AB.l		; 22 AB F2 03 ; Jump to subroutine long $03F2AB.l [Writes: Stack Pointer] [Flow: call]
	lsr $22.b,X		; 56 22 ; Logical shift right $22.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	jsl $FCA104.l		; 22 04 A1 FC ; Jump to subroutine long $FCA104.l [Writes: Stack Pointer] [Flow: call]
	sbc ($56.b)		; F2 56 ; Subtract with carry (indirect) ($56.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jsl $A8CCCB.l		; 22 CB CC A8 ; Jump to subroutine long $A8CCCB.l [Writes: Stack Pointer] [Flow: call]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	adc #$FB.b		; 69 FB ; Add #$FB.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sbc ($83.b)		; F2 83 ; Subtract with carry (indirect) ($83.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $FB.b,S		; 03 FB ; OR accumulator with stack relative $FB.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda ($CD.b,X)		; A1 CD ; Load accumulator ($CD.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	dec $9A99.w		; CE 99 9A ; Decrement $9A99.w [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	cmp $3C23.w		; CD 23 3C ; Compare $3C23.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	bit $A8.b		; 24 A8 ; Test bits $A8.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cmp ($99.b)		; D2 99 ; Compare accumulator (indirect) ($99.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	jsl $CD099A.l		; 22 9A 09 CD ; Jump to subroutine long $CD099A.l [Writes: Stack Pointer] [Flow: call]
	and $76.b		; 25 76 ; Logical AND $76.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pei ($B5.b)		; D4 B5 ; Push effective indirect address ($B5.b) [Reads: Direct Page] [Writes: Stack Pointer]
	lda $25.b,X		; B5 25 ; Load $25.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $D6.b		; 25 D6 ; Logical AND $D6.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp [$FF.b],Y		; D7 FF ; Compare accumulator (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $15.b		; 02 15 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $15.b,S		; 43 15 ; Exclusive OR accumulator with stack relative $15.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	tsb $15.b		; 04 15 ; Test and set bits $15.b [Reads: Accumulator] [Flags: Z]
	ora $04.b,X		; 15 04 ; OR accumulator with memory $04.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	and $01.b,S		; 23 01 ; AND accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $02.b,X		; 15 02 ; OR accumulator with memory $02.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $01.b,X		; 15 01 ; OR accumulator with memory $01.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	and $15.b,S		; 23 15 ; AND accumulator with stack relative $15.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $01.b		; 24 01 ; Test bits $01.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cop $15.b		; 02 15 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $04.b,X		; 15 04 ; OR accumulator with memory $04.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008315.l		; 22 15 83 00 ; Jump to subroutine long $008315.l [Writes: Stack Pointer] [Flow: call]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $25.b,S		; 03 25 ; OR accumulator with stack relative $25.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $150204.l		; 22 04 02 15 ; Jump to subroutine long $150204.l [Writes: Stack Pointer] [Flow: call]
	ora $04.b,X		; 15 04 ; OR accumulator with memory $04.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	rol $01.b		; 26 01 ; Rotate left $01.b [Reads: Direct Page] [Flags: NCZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	asl $83.b		; 06 83 ; Arithmetic shift left $83.b [Reads: Direct Page] [Flags: NCZ]
	brk $4A.b		; 00 4A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $01.b,S		; 23 01 ; AND accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $15.b		; 00 15 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $25.b		; 04 25 ; Test and set bits $25.b [Reads: Accumulator] [Flags: Z]
	ora $22.b,X		; 15 22 ; OR accumulator with memory $22.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $61.b		; 00 61 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $080015.l		; 22 15 00 08 ; Jump to subroutine long $080015.l [Writes: Stack Pointer] [Flow: call]
	jsl $010800.l		; 22 00 08 01 ; Jump to subroutine long $010800.l [Writes: Stack Pointer] [Flow: call]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b)		; 12 00 ; OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $04.b,X		; 15 04 ; OR accumulator with memory $04.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	asl $0B.b		; 06 0B ; Arithmetic shift left $0B.b [Reads: Direct Page] [Flags: NCZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b)		; 12 00 ; OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $15.b,X		; 15 15 ; OR accumulator with memory $15.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	sta [$09.b]		; 87 09 ; Store accumulator (long) [$09.b] [Reads: Direct Page, Accumulator]
	ora ($15.b)		; 12 15 ; OR accumulator with memory (indirect) ($15.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b)		; 12 00 ; OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($12.b,S),Y		; 13 12 ; OR accumulator (stack relative indirect indexed) ($12.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $15.b		; 04 15 ; Test and set bits $15.b [Reads: Accumulator] [Flags: Z]
	jsl $150105.l		; 22 05 01 15 ; Jump to subroutine long $150105.l [Writes: Stack Pointer] [Flow: call]
	ora $43.b,X		; 15 43 ; OR accumulator with memory $43.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($44.b,X)		; 01 44 ; Logical OR ($44.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	cop $15.b		; 02 15 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $05.b,X		; 15 05 ; OR accumulator with memory $05.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $050515.l		; 22 15 05 05 ; Jump to subroutine long $050515.l [Writes: Stack Pointer] [Flow: call]
	ora $05.b,X		; 15 05 ; OR accumulator with memory $05.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($12.b)		; 12 12 ; OR accumulator with memory (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $23.b		; 04 23 ; Test and set bits $23.b [Reads: Accumulator] [Flags: Z]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $04.b,X		; 15 04 ; OR accumulator with memory $04.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $152205.l		; 22 05 22 15 ; Jump to subroutine long $152205.l [Writes: Stack Pointer] [Flow: call]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $150604.l		; 22 04 06 15 ; Jump to subroutine long $150604.l [Writes: Stack Pointer] [Flow: call]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $15.b,X		; 15 15 ; OR accumulator with memory $15.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	eor ($23.b)		; 52 23 ; Exclusive OR accumulator with memory (indirect) ($23.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $05.b,X		; 15 05 ; OR accumulator with memory $05.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $22.b		; 05 22 ; Logical OR $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $22.b,X		; 15 22 ; OR accumulator with memory $22.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	ora $05.b,X		; 15 05 ; OR accumulator with memory $05.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $04.b,X		; 15 04 ; OR accumulator with memory $04.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $050015.l		; 22 15 00 05 ; Jump to subroutine long $050015.l [Writes: Stack Pointer] [Flow: call]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	adc $83.b,X		; 75 83 ; Add $83.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $A5.b		; 00 A5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $15.b		; 00 15 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $F2060F.l,X		; FF 0F 06 F2 ; Subtract with carry (long,X) $F2060F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $26.b		; 26 26 ; Rotate left $26.b [Reads: Direct Page] [Flags: NCZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	and [$D9.b]		; 27 D9 ; AND accumulator with memory (long) [$D9.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	and #$DD.b		; 29 DD ; Logical AND #$DD.b with accumulator [Writes: Accumulator] [Flags: NZ]
	dec $F85A.w,X		; DE 5A F8 ; Decrement memory $F85A.w,X [Reads: X Index] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora #$84.b		; 09 84 ; Logical OR #$84.b with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $2A.b		; 64 2A ; Store zero to $2A.b
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	dec $5A03.w,X		; DE 03 5A ; Decrement memory $5A03.w,X [Reads: X Index] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora ($20.b,S),Y		; 13 20 ; OR accumulator (stack relative indirect indexed) ($20.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $D82626.l		; 2F 26 26 D8 ; AND accumulator with memory (long) $D82626.l [Writes: Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	adc $30.b,S		; 63 30 ; Add with carry (stack relative) $30.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	brk $E7.b		; 00 E7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tsb $F8.b		; 04 F8 ; Test and set bits $F8.b [Reads: Accumulator] [Flags: Z]
	sbc $2634.w		; ED 34 26 ; Subtract $2634.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	.db $62, $35, $03		; 62 35 03 ; Push effective relative address $62, $35, $03 [Writes: Stack Pointer]
	nop		; EA ; No operation
	sec		; 38 ; Set carry flag [Flags: C]
	and $85E7.w,Y		; 39 E7 85 ; AND accumulator with memory $85E7.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $2C.b		; 00 2C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $ED.b		; 04 ED ; Test and set bits $ED.b [Reads: Accumulator] [Flags: Z]
	bit $ED.b,X		; 34 ED ; Test bits $ED.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $62, $F0, $06		; 62 F0 06 ; Push effective relative address $62, $F0, $06 [Writes: Stack Pointer]
	bit $F53D.w,X		; 3C 3D F5 ; Test bits $F53D.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	sbc $E5.b		; E5 E5 ; Subtract $E5.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($F8.b,S),Y		; 13 F8 ; OR accumulator (stack relative indirect indexed) ($F8.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $F612ED.l		; 22 ED 12 F6 ; Jump to subroutine long $F612ED.l [Writes: Stack Pointer] [Flow: call]
	sbc [$3E.b],Y		; F7 3E ; Subtract with carry (long indexed) [$3E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and $40FBFA.l,X		; 3F FA FB 40 ; AND accumulator with memory (long,X) $40FBFA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($FE.b,X)		; 41 FE ; Exclusive OR accumulator with memory ($FE.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cpy $1FAA.w		; CC AA 1F ; Compare $1FAA.w with Y register [Reads: Y Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $7AED.w		; ED ED 7A ; Subtract $7AED.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ora $D842.w,X		; 1D 42 D8 ; OR accumulator with memory $D842.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $43.b,S		; 63 43 ; Add with carry (stack relative) $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$294E.w		; E0 4E 29 ; Compare #$294E.w with X register [Reads: X Index] [Flags: NCZ]
	eor [$AA.b]		; 47 AA ; Exclusive OR accumulator with memory (long) [$AA.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $F81C.w		; 1C 1C F8 ; Test and reset bits $F81C.w [Reads: Accumulator] [Flags: Z]
	sbc $1C7A.w		; ED 7A 1C ; Subtract $1C7A.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $1CD873.l,X		; 9F 73 D8 1C ; Store accumulator (long,X) $1CD873.l,X [Reads: Accumulator, X Index]
	ora $4948.w,X		; 1D 48 49 ; OR accumulator with memory $4948.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$BF.b		; 29 BF ; Logical AND #$BF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $E5B2AA.l,X		; 9F AA B2 E5 ; Store accumulator (long,X) $E5B2AA.l,X [Reads: Accumulator, X Index]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	sta $429F83.l,X		; 9F 83 9F 42 ; Store accumulator (long,X) $429F83.l,X [Reads: Accumulator, X Index]
	cld		; D8 ; Clear decimal flag [Flags: D]
	and ($22.b,X)		; 21 22 ; Logical AND ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp $29D9.w,Y		; D9 D9 29 ; Compare accumulator $29D9.w,Y [Reads: Y Index] [Flags: NCZ]
	eor [$AA.b]		; 47 AA ; Exclusive OR accumulator with memory (long) [$AA.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	stx $1CAB.w		; 8E AB 1C ; Store X register to $1CAB.w [Reads: X Index]
	sta $AA8383.l,X		; 9F 83 83 AA ; Store accumulator (long,X) $AA8383.l,X [Reads: Accumulator, X Index]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	trb $F01D.w		; 1C 1D F0 ; Test and reset bits $F01D.w [Reads: Accumulator] [Flags: Z]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	jmp $9F69.w		; 4C 69 9F ; Jump to $9F69.w [Flow: jump]
	lda ($8E.b)		; B2 8E ; Load accumulator (indirect) ($8E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jmp $CD9A.w		; 4C 9A CD ; Jump to $CD9A.w [Flow: jump]
	eor $1D1C.w		; 4D 1C 1D ; Exclusive OR $1D1C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and ($4E.b,X)		; 21 4E ; Logical AND ($4E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor $47B546.l		; 4F 46 B5 47 ; Exclusive OR accumulator with memory (long) $47B546.l [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	ldx $B524.w		; AE 24 B5 ; Load $B524.w into X register [Writes: X Index] [Flags: NZ]
	and $E1.b		; 25 E1 ; Logical AND $E1.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $50, $51		; 50 51 ; Branch if overflow clear to $50, $51 [Flow: branch]
	and [$62.b]		; 27 62 ; AND accumulator with memory (long) [$62.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor ($05.b)		; 52 05 ; Exclusive OR accumulator with memory (indirect) ($05.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $1C55.w		; 2C 55 1C ; Test bits $1C55.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	adc #$69.b		; 69 69 ; Add #$69.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	lda [$62.b],Y		; B7 62 ; Load accumulator (long indexed) [$62.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	cop $28.b		; 02 28 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $D9.b,X		; 56 D9 ; Logical shift right $D9.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $62, $2F, $11		; 62 2F 11 ; Push effective relative address $62, $2F, $11 [Writes: Stack Pointer]
	sec		; 38 ; Set carry flag [Flags: C]
	eor [$58.b],Y		; 57 58 ; Exclusive OR accumulator with memory (long indexed) [$58.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $A8.b,X		; 34 A8 ; Test bits $A8.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	eor $8F36.w,Y		; 59 36 8F ; Exclusive OR accumulator with memory $8F36.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	cmp $0A39.w,Y		; D9 39 0A ; Compare accumulator $0A39.w,Y [Reads: Y Index] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc ($F3.b)		; F2 F3 ; Subtract with carry (indirect) ($F3.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc $3A.b,S		; 63 3A ; Add with carry (stack relative) $3A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	tsb $5C.b		; 04 5C ; Test and set bits $5C.b [Reads: Accumulator] [Flags: Z]
	and $41B340.l,X		; 3F 40 B3 41 ; AND accumulator with memory (long,X) $41B340.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $5D, $06		; 62 5D 06 ; Push effective relative address $62, $5D, $06 [Writes: Stack Pointer]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	eor $27.b		; 45 27 ; Exclusive OR $27.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dec $62.b,X		; D6 62 ; Decrement memory $62.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	adc ($0B.b,X)		; 61 0B ; Add with carry ($0B.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr $47.b		; 46 47 ; Logical shift right $47.b [Reads: Direct Page] [Flags: NCZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	trb $641D.w		; 1C 1D 64 ; Test and reset bits $641D.w [Reads: Accumulator] [Flags: Z]
	adc $D9.b		; 65 D9 ; Add $D9.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ror $3A.b		; 66 3A ; Rotate right $3A.b [Reads: Direct Page] [Flags: NCZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc [$FF.b]		; 67 FF ; Add with carry (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and $03.b,S		; 23 03 ; AND accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $030101.l		; 22 01 01 03 ; Jump to subroutine long $030101.l [Writes: Stack Pointer] [Flow: call]
	ora $25.b,X		; 15 25 ; OR accumulator with memory $25.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $22.b		; 05 22 ; Logical OR $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $83.b,S		; 03 83 ; OR accumulator with stack relative $83.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$04.b]		; 07 04 ; OR accumulator with memory (long) [$04.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $12.b,X		; 15 12 ; OR accumulator with memory $12.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $24.b		; 02 24 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0B.b		; 05 0B ; Logical OR $0B.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $15.b		; 02 15 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	sec		; 38 ; Set carry flag [Flags: C]
	asl $05.b		; 06 05 ; Arithmetic shift left $05.b [Reads: Direct Page] [Flags: NCZ]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	rol $43.b,X		; 36 43 ; Rotate left $43.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0101.w		; 0C 01 01 ; Test and set bits $0101.w [Reads: Accumulator] [Flags: Z]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $83.b,S		; 03 83 ; OR accumulator with stack relative $83.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($62.b)		; 12 62 ; OR accumulator with memory (indirect) ($62.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $26.b		; 02 26 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($05.b)		; 12 05 ; OR accumulator with memory (indirect) ($05.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $010C12.l		; 22 12 0C 01 ; Jump to subroutine long $010C12.l [Writes: Stack Pointer] [Flow: call]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($03.b)		; 12 03 ; OR accumulator with memory (indirect) ($03.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $050704.l		; 22 04 07 05 ; Jump to subroutine long $050704.l [Writes: Stack Pointer] [Flow: call]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $12.b		; 02 12 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($05.b)		; 12 05 ; OR accumulator with memory (indirect) ($05.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($22.b)		; 12 22 ; OR accumulator with memory (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $22.b		; 05 22 ; Logical OR $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $01.b,X		; 15 01 ; OR accumulator with memory $01.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl L000304.l		; 22 04 83 00 ; Jump to subroutine long L000304.l [Writes: Stack Pointer] [Flow: call]
	sta ($01.b,S),Y		; 93 01 ; Store accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $05.b		; 24 05 ; Test bits $05.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora ($01.b),Y		; 11 01 ; OR accumulator with memory ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $05.b,X		; 15 05 ; OR accumulator with memory $05.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $15.b		; 05 15 ; Logical OR $15.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($04.b)		; 12 04 ; OR accumulator with memory (indirect) ($04.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $02.b,X		; 15 02 ; OR accumulator with memory $02.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($83.b)		; 12 83 ; OR accumulator with memory (indirect) ($83.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $9E.b		; 00 9E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0415.w		; 0E 15 04 ; Arithmetic shift left $0415.w [Flags: NCZ]
	ora ($12.b)		; 12 12 ; OR accumulator with memory (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $04.b,X		; 15 04 ; OR accumulator with memory $04.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $05.b,X		; 15 05 ; OR accumulator with memory $05.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cop $15.b		; 02 15 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $04.b,X		; 15 04 ; OR accumulator with memory $04.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $12.b		; 04 12 ; Test and set bits $12.b [Reads: Accumulator] [Flags: Z]
	tsb $83.b		; 04 83 ; Test and set bits $83.b [Reads: Accumulator] [Flags: Z]
	brk $D7.b		; 00 D7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $04.b		; 06 04 ; Arithmetic shift left $04.b [Reads: Direct Page] [Flags: NCZ]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $05.b,X		; 15 05 ; OR accumulator with memory $05.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $040215.l		; 22 15 02 04 ; Jump to subroutine long $040215.l [Writes: Stack Pointer] [Flow: call]
	tsb $15.b		; 04 15 ; Test and set bits $15.b [Reads: Accumulator] [Flags: Z]
	sbc $226B00.l,X		; FF 00 6B 22 ; Subtract with carry (long,X) $226B00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp ($9805.w)		; 6C 05 98 ; Jump indirect to ($9805.w) [Flow: jump]
	sbc $E5.b		; E5 E5 ; Subtract $E5.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	adc $68.b,X		; 75 68 ; Add $68.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $F8.b		; 24 F8 ; Test bits $F8.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $880A6C.l		; 22 6C 0A 88 ; Jump to subroutine long $880A6C.l [Writes: Stack Pointer] [Flow: call]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ldy $E54B.w		; AC 4B E5 ; Load $E54B.w into Y register [Writes: Y Index] [Flags: NZ]
	sbc $F8.b		; E5 F8 ; Subtract $F8.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	adc #$7B.b		; 69 7B ; Add #$7B.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	asl $8807.w		; 0E 07 88 ; Arithmetic shift left $8807.w [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda ($1E.b,X)		; A1 1E ; Load accumulator ($1E.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda ($64.b,X)		; A1 64 ; Load accumulator ($64.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	cpx #$0350.w		; E0 50 03 ; Compare #$0350.w with X register [Reads: X Index] [Flags: NCZ]
	jmp ($A888.w)		; 6C 88 A8 ; Jump indirect to ($A888.w) [Flow: jump]
	sta $69029A.l,X		; 9F 9A 02 69 ; Store accumulator (long,X) $69029A.l,X [Reads: Accumulator, X Index]
	ora $AA51.w,X		; 1D 51 AA ; OR accumulator with memory $AA51.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	eor ($59.b)		; 52 59 ; Exclusive OR accumulator with memory (indirect) ($59.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	eor ($54.b,S),Y		; 53 54 ; XOR accumulator (stack relative indirect indexed) ($54.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	trb $5583.w		; 1C 83 55 ; Test and reset bits $5583.w [Reads: Accumulator] [Flags: Z]
	lsr $6A.b,X		; 56 6A ; Logical shift right $6A.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	trb $8658.w		; 1C 58 86 ; Test and reset bits $8658.w [Reads: Accumulator] [Flags: Z]
	trb $9F83.w		; 1C 83 9F ; Test and reset bits $9F83.w [Reads: Accumulator] [Flags: Z]
	sta $41.b,S		; 83 41 ; Store accumulator (stack relative) $41.b,S [Reads: Stack Pointer, Accumulator]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	eor $B9DB.w,Y		; 59 DB B9 ; Exclusive OR accumulator with memory $B9DB.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ror $5A1D.w		; 6E 1D 5A ; Rotate right $5A1D.w [Flags: NCZ]
	lda ($79.b)		; B2 79 ; Load accumulator (indirect) ($79.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($A9.b),Y		; 91 A9 ; Store accumulator ($A9.b),Y [Reads: Direct Page, Y Index, Accumulator]
	trb $5B8D.w		; 1C 8D 5B ; Test and reset bits $5B8D.w [Reads: Accumulator] [Flags: Z]
	jmp $5DAA49.l		; 5C 49 AA 5D ; Jump long to $5DAA49.l [Flow: jump]
	lsr $7AC9.w,X		; 5E C9 7A ; Logical shift right $7AC9.w,X [Reads: X Index] [Flags: NCZ]
	eor $7ABA56.l,X		; 5F 56 BA 7A ; Exclusive OR accumulator with memory (long,X) $7ABA56.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	sta [$EA.b],Y		; 97 EA ; Store accumulator (long indexed) [$EA.b],Y [Reads: Direct Page, Y Index, Accumulator]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $9F.b,S		; 83 9F ; Store accumulator (stack relative) $9F.b,S [Reads: Stack Pointer, Accumulator]
	ora $619F04.l,X		; 1F 04 9F 61 ; Logical OR long $619F04.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ora $8685.w,X		; 1D 85 86 ; OR accumulator with memory $8685.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $62.b		; E5 62 ; Subtract $62.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $82, $00, $06		; 82 00 06 ; Branch always long to $82, $00, $06 [Flow: branch]
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: NCZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	tsb $83F2.w		; 0C F2 83 ; Test and set bits $83F2.w [Reads: Accumulator] [Flags: Z]
	adc $B1.b,S		; 63 B1 ; Add with carry (stack relative) $B1.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	adc ($B4.b,X)		; 61 B4 ; Add with carry ($B4.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	sta $656454.l,X		; 9F 54 64 65 ; Store accumulator (long,X) $656454.l,X [Reads: Accumulator, X Index]
	jsr $2220.w		; 20 20 22 ; Jump to subroutine at $2220.w [Writes: Stack Pointer] [Flow: call]
	adc #$0C.b		; 69 0C ; Add #$0C.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc ($9F.b)		; F2 9F ; Subtract with carry (indirect) ($9F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lsr $22.b,X		; 56 22 ; Logical shift right $22.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ror $1C.b		; 66 1C ; Rotate right $1C.b [Reads: Direct Page] [Flags: NCZ]
	sta $50.b,S		; 83 50 ; Store accumulator (stack relative) $50.b,S [Reads: Stack Pointer, Accumulator]
	adc [$5A.b]		; 67 5A ; Add with carry (long) [$5A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsl $680DA8.l		; 22 A8 0D 68 ; Jump to subroutine long $680DA8.l [Writes: Stack Pointer] [Flow: call]
	adc #$AA.b		; 69 AA ; Add #$AA.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	lda ($9A.b,X)		; A1 9A ; Load accumulator ($9A.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	jsr ($836A.w,X)		; FC 6A 83 ; Jump to subroutine indirect indexed ($836A.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	lsr $57.b,X		; 56 57 ; Logical shift right $57.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora $6C62.w,X		; 1D 62 6C ; OR accumulator with memory $6C62.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	eor ($51.b,X)		; 41 51 ; Exclusive OR accumulator with memory ($51.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $CEB5.w		; CD B5 CE ; Compare $CEB5.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc ($AA.b)		; F2 AA ; Subtract with carry (indirect) ($AA.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lsr $BA.b,X		; 56 BA ; Logical shift right $BA.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc $64.b		; E5 64 ; Subtract $64.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ror $CC11.w		; 6E 11 CC ; Rotate right $CC11.w [Flags: NCZ]
	adc ($74.b,S),Y		; 73 74 ; Add with carry (stack relative indirect indexed) ($74.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	adc $FBD276.l		; 6F 76 D2 FB ; Add with carry (long) $FBD276.l [Writes: Accumulator] [Flags: NCVZ]
	adc [$6A.b],Y		; 77 6A ; Add with carry (long indexed) [$6A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	adc $D129.w,Y		; 79 29 D1 ; Add $D129.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $8E83.w,X		; 1D 83 8E ; OR accumulator with memory $8E83.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	wai		; CB ; Wait for interrupt
	.db $62, $70, $E0		; 62 70 E0 ; Push effective relative address $62, $70, $E0 [Writes: Stack Pointer]
	rol $2A.b		; 26 2A ; Rotate left $2A.b [Reads: Direct Page] [Flags: NCZ]
	cmp ($69.b)		; D2 69 ; Compare accumulator (indirect) ($69.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	ldx $73B7.w		; AE B7 73 ; Load $73B7.w into X register [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	jmp $74B7.w		; 4C B7 74 ; Jump to $74B7.w [Flow: jump]
	and $7675D1.l		; 2F D1 75 76 ; AND accumulator with memory (long) $7675D1.l [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	cmp ($69.b)		; D2 69 ; Compare accumulator (indirect) ($69.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	lda [$77.b],Y		; B7 77 ; Load accumulator (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	lsr $B5.b		; 46 B5 ; Logical shift right $B5.b [Reads: Direct Page] [Flags: NCZ]
	lda $47.b,X		; B5 47 ; Load $47.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	adc $2084.w,Y		; 79 84 20 ; Add $2084.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $7A.b		; 85 7A ; Store accumulator to $7A.b [Reads: Accumulator]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror $A8.b,X		; 76 A8 ; Rotate right $A8.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	jmp ($01FF.w,X)		; 7C FF 01 ; Jump indirect indexed to ($01FF.w,X) [Reads: X Index] [Flow: jump]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $02.b,X		; 15 02 ; OR accumulator with memory $02.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $28.b		; 05 28 ; Logical OR $28.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $08.b,X		; 15 08 ; OR accumulator with memory $08.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	asl $05.b		; 06 05 ; Arithmetic shift left $05.b [Reads: Direct Page] [Flags: NCZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $22.b		; 05 22 ; Logical OR $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $00.b,X		; 15 00 ; OR accumulator with memory $00.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $00.b,X		; 15 00 ; OR accumulator with memory $00.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: NCZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	eor $05.b,S		; 43 05 ; Exclusive OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$23.b]		; 07 23 ; OR accumulator with memory (long) [$23.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0E.b,X		; 15 0E ; OR accumulator with memory $0E.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $06150F.l		; 0F 0F 15 06 ; OR accumulator with memory (long) $06150F.l [Writes: Accumulator] [Flags: NZ]
	ora ($15.b,X)		; 01 15 ; Logical OR ($15.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $08.b		; 05 08 ; Logical OR $08.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $05.b,X		; 15 05 ; OR accumulator with memory $05.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $150505.l		; 0F 05 05 15 ; OR accumulator with memory (long) $150505.l [Writes: Accumulator] [Flags: NZ]
	ora [$23.b]		; 07 23 ; OR accumulator with memory (long) [$23.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,X		; 15 03 ; OR accumulator with memory $03.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $110315.l		; 22 15 03 11 ; Jump to subroutine long $110315.l [Writes: Stack Pointer] [Flow: call]
	ora $25060F.l		; 0F 0F 06 25 ; OR accumulator with memory (long) $25060F.l [Writes: Accumulator] [Flags: NZ]
	ora [$02.b]		; 07 02 ; OR accumulator with memory (long) [$02.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $15.b,X		; 15 15 ; OR accumulator with memory $15.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $22.b		; 05 22 ; Logical OR $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $01.b,X		; 15 01 ; OR accumulator with memory $01.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $05		; 10 05 ; Branch if plus to $10, $05 [Flow: branch]
	jsl $000615.l		; 22 15 06 00 ; Jump to subroutine long $000615.l [Writes: Stack Pointer] [Flow: call]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $15.b,X		; 15 15 ; OR accumulator with memory $15.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $15.b,S		; 03 15 ; OR accumulator with stack relative $15.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	eor $22.b		; 45 22 ; Exclusive OR $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $08.b,X		; 15 08 ; OR accumulator with memory $08.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $0104.w		; 0D 04 01 ; Logical OR $0104.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $15.b,X		; 15 15 ; OR accumulator with memory $15.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $05.b		; 24 05 ; Test bits $05.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	ora ($15.b,X)		; 01 15 ; Logical OR ($15.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $0C.b		; 02 0C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $01.b,S		; 23 01 ; AND accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	ora #$08.b		; 09 08 ; Logical OR #$08.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $15.b		; 05 15 ; Logical OR $15.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $03.b,S		; 43 03 ; Exclusive OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $83.b		; 05 83 ; Logical OR $83.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $2B.b		; 00 2B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $15.b		; 02 15 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $05.b,S		; 23 05 ; AND accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($15.b,X)		; 01 15 ; Logical OR ($15.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	jsl $030115.l		; 22 15 01 03 ; Jump to subroutine long $030115.l [Writes: Stack Pointer] [Flow: call]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $150705.l		; 22 05 07 15 ; Jump to subroutine long $150705.l [Writes: Stack Pointer] [Flow: call]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	ora $05.b,X		; 15 05 ; OR accumulator with memory $05.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	ora $01.b,X		; 15 01 ; OR accumulator with memory $01.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $0F0215.l		; 22 15 02 0F ; Jump to subroutine long $0F0215.l [Writes: Stack Pointer] [Flow: call]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $030101.l		; 22 01 01 03 ; Jump to subroutine long $030101.l [Writes: Stack Pointer] [Flow: call]
	ora $22.b		; 05 22 ; Logical OR $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $0C.b		; 06 0C ; Arithmetic shift left $0C.b [Reads: Direct Page] [Flags: NCZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $06.b,X		; 15 06 ; OR accumulator with memory $06.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $0F.b,X		; 15 0F ; OR accumulator with memory $0F.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $06.b,X		; 15 06 ; OR accumulator with memory $06.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $23.b,S		; 03 23 ; OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $43.b		; 06 43 ; Arithmetic shift left $43.b [Reads: Direct Page] [Flags: NCZ]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $15.b,S		; 23 15 ; AND accumulator with stack relative $15.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: NCZ]
	ora $24.b		; 05 24 ; Logical OR $24.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: NCZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $010115.l		; 22 15 01 01 ; Jump to subroutine long $010115.l [Writes: Stack Pointer] [Flow: call]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $87.b		; 02 87 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $287D.w		; 0E 7D 28 ; Arithmetic shift left $287D.w [Flags: NCZ]
	ror $7F06.w,X		; 7E 06 7F ; Rotate right $7F06.w,X [Reads: X Index] [Flags: NCZ]
	.db $82, $E2, $03		; 82 E2 03 ; Branch always long to $82, $E2, $03 [Flow: branch]
	sta ($87.b)		; 92 87 ; Store accumulator (indirect) ($87.b) [Reads: Direct Page, Accumulator]
	sta ($28.b,S),Y		; 93 28 ; Store accumulator (stack relative indirect indexed) ($28.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	.db $80, $08		; 80 08 ; Branch always to $80, $08 [Flow: branch]
	ora $E2.b,S		; 03 E2 ; OR accumulator with stack relative $E2.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jmp ($9A92.w)		; 6C 92 9A ; Jump indirect to ($9A92.w) [Flow: jump]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sbc $62.b		; E5 62 ; Subtract $62.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta ($00.b,X)		; 81 00 ; Store accumulator ($00.b,X) [Reads: Direct Page, Accumulator, X Index]
	.db $90, $62		; 90 62 ; Branch if carry clear to $90, $62 [Flow: branch]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	asl $0322.w		; 0E 22 03 ; Arithmetic shift left $0322.w [Flags: NCZ]
	ora $87.b		; 05 87 ; Logical OR $87.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldx #$1DA3.w		; A2 A3 1D ; Load #$1DA3.w into X register [Writes: X Index] [Flags: NZ]
	sbc $1D.b		; E5 1D ; Subtract $1D.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc $87.b,S		; 63 87 ; Add with carry (stack relative) $87.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	asl $8FA4.w		; 0E A4 8F ; Arithmetic shift left $8FA4.w [Flags: NCZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora $8C.b,S		; 03 8C ; OR accumulator with stack relative $8C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	sta [$8D.b],Y		; 97 8D ; Store accumulator (long indexed) [$8D.b],Y [Reads: Direct Page, Y Index, Accumulator]
	sbc $79.b		; E5 79 ; Subtract $79.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $E5.b		; E5 E5 ; Subtract $E5.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	stx $6326.w		; 8E 26 63 ; Store X register to $6326.w [Reads: X Index]
	sta $BE2703.l		; 8F 03 27 BE ; Store accumulator (long) $BE2703.l [Reads: Accumulator]
	.db $82, $8E, $62		; 82 8E 62 ; Branch always long to $82, $8E, $62 [Flow: branch]
	sta ($03.b,S),Y		; 93 03 ; Store accumulator (stack relative indirect indexed) ($03.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	lda $9F.b		; A5 9F ; Load $9F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($25.b,X)		; 21 25 ; Logical AND ($25.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $9602.w		; 2C 02 96 ; Test bits $9602.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	sta [$8E.b],Y		; 97 8E ; Store accumulator (long indexed) [$8E.b],Y [Reads: Direct Page, Y Index, Accumulator]
	.db $62, $98, $01		; 62 98 01 ; Push effective relative address $62, $98, $01 [Writes: Stack Pointer]
	ldx $C1.b,Y		; B6 C1 ; Load X register $C1.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	.db $62, $9B, $0A		; 62 9B 0A ; Push effective relative address $62, $9B, $0A [Writes: Stack Pointer]
	ora $C21D.w,X		; 1D 1D C2 ; OR accumulator with memory $C21D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	stz $4D9F.w,X		; 9E 9F 4D ; Store zero to $4D9F.w,X [Reads: X Index]
	ldy #$C98E.w		; A0 8E C9 ; Load #$C98E.w into Y register [Writes: Y Index] [Flags: NZ]
	lda ($24.b,X)		; A1 24 ; Load accumulator ($24.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $A2, $08		; 62 A2 08 ; Push effective relative address $62, $A2, $08 [Writes: Stack Pointer]
	cpx $5E.b		; E4 5E ; Compare $5E.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	cmp $DB80.w		; CD 80 DB ; Compare $DB80.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	stz $41A5.w,X		; 9E A5 41 ; Store zero to $41A5.w,X [Reads: X Index]
	rol $D662.w		; 2E 62 D6 ; Rotate left $D662.w [Flags: NCZ]
	asl $E5E5.w,X		; 1E E5 E5 ; Arithmetic shift left $E5E5.w,X [Reads: X Index] [Flags: NCZ]
	ldx $A7.b		; A6 A7 ; Load $A7.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $A823DE.l,X		; 1F DE 23 A8 ; Logical OR long $A823DE.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	eor #$CD.b		; 49 CD ; Exclusive OR #$CD.b with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp $3EE3.w		; CD E3 3E ; Compare $3EE3.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	lda ($E6.b)		; B2 E6 ; Load accumulator (indirect) ($E6.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda #$88.b		; A9 88 ; Load #$88.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sbc #$D9.b		; E9 D9 ; Subtract #$D9.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	nop		; EA ; No operation
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	eor ($53.b)		; 52 53 ; Exclusive OR accumulator with memory (indirect) ($53.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	dec $D6.b,X		; D6 D6 ; Decrement memory $D6.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	adc $EF.b,S		; 63 EF ; Add with carry (stack relative) $EF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora ($AC.b,X)		; 01 AC ; Logical OR ($AC.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora #$62.b		; 09 62 ; Logical OR #$62.b with accumulator [Writes: Accumulator] [Flags: NZ]
	lda $4906.w		; AD 06 49 ; Load $4906.w into accumulator [Writes: Accumulator] [Flags: NZ]
	bit $77.b		; 24 77 ; Test bits $77.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	adc ($06.b),Y		; 71 06 ; Add with carry ($06.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta [$D6.b]		; 87 D6 ; Store accumulator (long) [$D6.b] [Reads: Direct Page, Accumulator]
	.db $62, $FA, $11		; 62 FA 11 ; Push effective relative address $62, $FA, $11 [Writes: Stack Pointer]
	.db $B0, $CC		; B0 CC ; Branch if carry set to $B0, $CC [Flow: branch]
	ora $6A.b,S		; 03 6A ; OR accumulator with stack relative $6A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldy #$5FB1.w		; A0 B1 5F ; Load #$5FB1.w into Y register [Writes: Y Index] [Flags: NZ]
	ora $7177.w,X		; 1D 77 71 ; OR accumulator with memory $7177.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $92.b		; 06 92 ; Arithmetic shift left $92.b [Reads: Direct Page] [Flags: NCZ]
	sta [$88.b]		; 87 88 ; Store accumulator (long) [$88.b] [Reads: Direct Page, Accumulator]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda ($A0.b)		; B2 A0 ; Load accumulator (indirect) ($A0.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $62, $B3, $07		; 62 B3 07 ; Push effective relative address $62, $B3, $07 [Writes: Stack Pointer]
	.db $50, $61		; 50 61 ; Branch if overflow clear to $50, $61 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	adc [$71.b],Y		; 77 71 ; Add with carry (long indexed) [$71.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $6C.b		; 06 6C ; Arithmetic shift left $6C.b [Reads: Direct Page] [Flags: NCZ]
	sta ($62.b)		; 92 62 ; Store accumulator (indirect) ($62.b) [Reads: Direct Page, Accumulator]
	tsb $030C.w		; 0C 0C 03 ; Test and set bits $030C.w [Reads: Accumulator] [Flags: Z]
	cmp $11B6.w,Y		; D9 B6 11 ; Compare accumulator $11B6.w,Y [Reads: Y Index] [Flags: NCZ]
	lda [$20.b],Y		; B7 20 ; Load accumulator (long indexed) [$20.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $B1.b,S		; 63 B1 ; Add with carry (stack relative) $B1.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	asl $0C.b,X		; 16 0C ; Arithmetic shift left $0C.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	jmp ($636C.w)		; 6C 6C 63 ; Jump indirect to ($636C.w) [Flow: jump]
	ora [$04.b],Y		; 17 04 ; OR accumulator with memory (long indexed) [$04.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $1B.b,S		; 03 1B ; OR accumulator with stack relative $1B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$1C.b],Y		; 17 1C ; OR accumulator with memory (long indexed) [$1C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda [$62.b],Y		; B7 62 ; Load accumulator (long indexed) [$62.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda $0303.w,Y		; B9 03 03 ; Load $0303.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $63A26C.l,X		; 1F 6C A2 63 ; Logical OR long $63A26C.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsr $1A04.w		; 20 04 1A ; Jump to subroutine at $1A04.w [Writes: Stack Pointer] [Flow: call]
	ora $75.b,S		; 03 75 ; OR accumulator with stack relative $75.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $63.b		; 00 63 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $BC, $01		; 62 BC 01 ; Push effective relative address $62, $BC, $01 [Writes: Stack Pointer]
	sbc ($71.b,S),Y		; F3 71 ; Subtract with carry (stack relative indirect indexed) ($71.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc $000003.l,X		; FF 03 00 00 ; Subtract with carry (long,X) $000003.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $24.b		; 06 24 ; Arithmetic shift left $24.b [Reads: Direct Page] [Flags: NCZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $23.b		; 06 23 ; Arithmetic shift left $23.b [Reads: Direct Page] [Flags: NCZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	and ($05.b,X)		; 21 05 ; Logical AND ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $06.b		; 04 06 ; Test and set bits $06.b [Reads: Accumulator] [Flags: Z]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $25.b		; 06 25 ; Arithmetic shift left $25.b [Reads: Direct Page] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($25.b,X)		; 01 25 ; Logical OR ($25.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: NCZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $24.b		; 04 24 ; Test and set bits $24.b [Reads: Accumulator] [Flags: Z]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,X		; 15 03 ; OR accumulator with memory $03.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $06.b,X		; 15 06 ; OR accumulator with memory $06.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $15.b,S		; 23 15 ; AND accumulator with stack relative $15.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$01.b		; 09 01 ; Logical OR #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $04.b		; 06 04 ; Arithmetic shift left $04.b [Reads: Direct Page] [Flags: NCZ]
	ora $15.b,X		; 15 15 ; OR accumulator with memory $15.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $06.b		; 04 06 ; Test and set bits $06.b [Reads: Accumulator] [Flags: Z]
	asl $26.b		; 06 26 ; Arithmetic shift left $26.b [Reads: Direct Page] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $15.b,X		; 15 15 ; OR accumulator with memory $15.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($15.b,X)		; 01 15 ; Logical OR ($15.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $04.b,X		; 15 04 ; OR accumulator with memory $04.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $15.b,X		; 15 15 ; OR accumulator with memory $15.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	eor $06.b,S		; 43 06 ; Exclusive OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $49.b		; 00 49 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,X		; 15 00 ; OR accumulator with memory $00.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	adc $02.b		; 65 02 ; Add $02.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $24.b		; 06 24 ; Arithmetic shift left $24.b [Reads: Direct Page] [Flags: NCZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $15.b		; 06 15 ; Arithmetic shift left $15.b [Reads: Direct Page] [Flags: NCZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $04.b		; 06 04 ; Arithmetic shift left $04.b [Reads: Direct Page] [Flags: NCZ]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $23.b		; 06 23 ; Arithmetic shift left $23.b [Reads: Direct Page] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $26.b		; 06 26 ; Arithmetic shift left $26.b [Reads: Direct Page] [Flags: NCZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: NCZ]
	asl $24.b		; 06 24 ; Arithmetic shift left $24.b [Reads: Direct Page] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $23.b		; 06 23 ; Arithmetic shift left $23.b [Reads: Direct Page] [Flags: NCZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $26.b		; 00 26 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$62.b]		; 27 62 ; AND accumulator with memory (long) [$62.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stx $00.b		; 86 00 ; Store X register to $00.b [Reads: X Index]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora #$28.b		; 09 28 ; Logical OR #$28.b with accumulator [Writes: Accumulator] [Flags: NZ]
	and #$62.b		; 29 62 ; Logical AND #$62.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$01.b		; 09 01 ; Logical OR #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$0A.b		; 09 0A ; Logical OR #$0A.b with accumulator [Writes: Accumulator] [Flags: NZ]
	stx $00.b		; 86 00 ; Store X register to $00.b [Reads: X Index]
	.db $10, $05		; 10 05 ; Branch if plus to $10, $05 [Flow: branch]
	asl $10.b		; 06 10 ; Arithmetic shift left $10.b [Reads: Direct Page] [Flags: NCZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	and ($93.b),Y		; 31 93 ; AND accumulator with memory ($93.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $06, $00		; 62 06 00 ; Push effective relative address $62, $06, $00 [Writes: Stack Pointer]
	.db $F0, $84		; F0 84 ; Branch if equal to $F0, $84 [Flow: branch]
	brk $21.b		; 00 21 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $02F0.w		; 0E F0 02 ; Arithmetic shift left $02F0.w [Flags: NCZ]
	adc ($2C.b),Y		; 71 2C ; Add with carry ($2C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($39.b,S),Y		; 53 39 ; XOR accumulator (stack relative indirect indexed) ($39.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $010002.l,X		; 3F 02 00 01 ; AND accumulator with memory (long,X) $010002.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $1C.b,S		; 83 1C ; Store accumulator (stack relative) $1C.b,S [Reads: Stack Pointer, Accumulator]
	lsr $D12D.w,X		; 5E 2D D1 ; Logical shift right $D12D.w,X [Reads: X Index] [Flags: NCZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	asl $2F0A.w		; 0E 0A 2F ; Arithmetic shift left $2F0A.w [Flags: NCZ]
	rol $9291.w		; 2E 91 92 ; Rotate left $9291.w [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora #$0A.b		; 09 0A ; Logical OR #$0A.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sty $1D29.w		; 8C 29 1D ; Store Y register to $1D29.w [Reads: Y Index]
	inc $0084.w		; EE 84 00 ; Increment $0084.w [Flags: NZ]
	ora $23E0.w,X		; 1D E0 23 ; OR accumulator with memory $23E0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $306261.l		; 2F 61 62 30 ; AND accumulator with memory (long) $306261.l [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $64		; F0 64 ; Branch if equal to $F0, $64 [Flow: branch]
	ora $3131.w,X		; 1D 31 31 ; OR accumulator with memory $3131.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta ($06.b,S),Y		; 93 06 ; Store accumulator (stack relative indirect indexed) ($06.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	cop $71.b		; 02 71 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $67.b		; 26 67 ; Rotate left $67.b [Reads: Direct Page] [Flags: NCZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	ora $841B.w,Y		; 19 1B 84 ; OR accumulator with memory $841B.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	trb $FF27.w		; 1C 27 FF ; Test and reset bits $FF27.w [Reads: Accumulator] [Flags: Z]
	and $023F.w,Y		; 39 3F 02 ; AND accumulator with memory $023F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora #$BF.b		; 09 BF ; Logical OR #$BF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp $62B7C0.l,X		; DF C0 B7 62 ; Compare accumulator (long,X) $62B7C0.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	cmp ($1A.b,X)		; C1 1A ; Compare accumulator ($1A.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	cmp ($6A.b,X)		; C1 6A ; Compare accumulator ($6A.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	jsl $929174.l		; 22 74 91 92 ; Jump to subroutine long $929174.l [Writes: Stack Pointer] [Flow: call]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	ora [$FE.b]		; 07 FE ; OR accumulator with memory (long) [$FE.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	cmp #$FE.b		; C9 FE ; Compare #$FE.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	eor #$0C.b		; 49 0C ; Exclusive OR #$0C.b with accumulator [Writes: Accumulator] [Flags: NZ]
	cpy $C5.b		; C4 C5 ; Compare $C5.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	stz $33.b		; 64 33 ; Store zero to $33.b
	bit $C9.b,X		; 34 C9 ; Test bits $C9.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sta ($06.b,S),Y		; 93 06 ; Store accumulator (stack relative indirect indexed) ($06.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($7F.b,X)		; 01 7F ; Logical OR ($7F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	bit $04.b,X		; 34 04 ; Test bits $04.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	tsb $1B.b		; 04 1B ; Test and set bits $1B.b [Reads: Accumulator] [Flags: Z]
	trb $C7C6.w		; 1C C6 C7 ; Test and reset bits $C7C6.w [Reads: Accumulator] [Flags: Z]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	adc $0A00.w		; 6D 00 0A ; Add $0A00.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	jmp ($0906.w,X)		; 7C 06 09 ; Jump indirect indexed to ($0906.w,X) [Reads: X Index] [Flow: jump]
	ora [$C8.b]		; 07 C8 ; OR accumulator with memory (long) [$C8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	wai		; CB ; Wait for interrupt
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ror $931A.w,X		; 7E 1A 93 ; Rotate right $931A.w,X [Reads: X Index] [Flags: NCZ]
	bit $301D.w,X		; 3C 1D 30 ; Test bits $301D.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	ora [$32.b]		; 07 32 ; OR accumulator with memory (long) [$32.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jmp ($2DB2.w,X)		; 7C B2 2D ; Jump indirect indexed to ($2DB2.w,X) [Reads: X Index] [Flow: jump]
	ora $93C9.w,X		; 1D C9 93 ; OR accumulator with memory $93C9.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $CC.b		; 04 CC ; Test and set bits $CC.b [Reads: Accumulator] [Flags: Z]
	ora $1A19.w,X		; 1D 19 1A ; OR accumulator with memory $1A19.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $3F27.w,X		; 1D 27 3F ; OR accumulator with memory $3F27.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	and $4009.w,X		; 3D 09 40 ; AND accumulator with memory $4009.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $431D.w		; CD 1D 43 ; Compare $431D.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	mvp $07,$09		; 44 09 07 ; Move block positive $07,$09 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	eor $46.b		; 45 46 ; Exclusive OR $46.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $160083.l		; 22 83 00 16 ; Jump to subroutine long $160083.l [Writes: Stack Pointer] [Flow: call]
	ora #$7A.b		; 09 7A ; Logical OR #$7A.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$FE.b]		; 07 FE ; OR accumulator with memory (long) [$FE.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor [$D9.b]		; 47 D9 ; Exclusive OR accumulator with memory (long) [$D9.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	eor #$07.b		; 49 07 ; Exclusive OR #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc $837C.w,X		; FE 7C 83 ; Increment memory $837C.w,X [Reads: X Index] [Flags: NZ]
	brk $B4.b		; 00 B4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ldx $0103.w,Y		; BE 03 01 ; Load X register $0103.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cmp $834B.w,Y		; D9 4B 83 ; Compare accumulator $834B.w,Y [Reads: Y Index] [Flags: NCZ]
	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($1D.b,X)		; 01 1D ; Logical OR ($1D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and ($83.b)		; 32 83 ; AND accumulator with memory (indirect) ($83.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $22002A.l,X		; FF 2A 00 22 ; Subtract with carry (long,X) $22002A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $2D.b,X		; 15 2D ; OR accumulator with memory $2D.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $2D.b,X		; 15 2D ; OR accumulator with memory $2D.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $04.b		; 06 04 ; Arithmetic shift left $04.b [Reads: Direct Page] [Flags: NCZ]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $0000.w		; 0D 00 00 ; Logical OR $0000.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $23.b,X		; 15 23 ; OR accumulator with memory $23.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($25.b,X)		; 01 25 ; Logical OR ($25.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $0A.b,X		; 15 0A ; OR accumulator with memory $0A.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $0D.b,S		; 03 0D ; OR accumulator with stack relative $0D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $15.b		; 05 15 ; Logical OR $15.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	trb $07.b		; 14 07 ; Test and reset bits $07.b [Reads: Accumulator] [Flags: Z]
	ora [$15.b]		; 07 15 ; OR accumulator with memory (long) [$15.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $24.b		; 04 24 ; Test and set bits $24.b [Reads: Accumulator] [Flags: Z]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $4B.b		; 00 4B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $010215.l		; 22 15 02 01 ; Jump to subroutine long $010215.l [Writes: Stack Pointer] [Flow: call]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $15.b,S		; 23 15 ; AND accumulator with stack relative $15.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	and ($06.b)		; 32 06 ; AND accumulator with memory (indirect) ($06.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $00.b,X		; 15 00 ; OR accumulator with memory $00.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0B1523.l		; 0F 23 15 0B ; OR accumulator with memory (long) $0B1523.l [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	tsb $000C.w		; 0C 0C 00 ; Test and set bits $000C.w [Reads: Accumulator] [Flags: Z]
	trb $04.b		; 14 04 ; Test and reset bits $04.b [Reads: Accumulator] [Flags: Z]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: NCZ]
	ora $06.b,X		; 15 06 ; OR accumulator with memory $06.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $0C00.w		; 0D 00 0C ; Logical OR $0C00.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsl $010200.l		; 22 00 02 01 ; Jump to subroutine long $010200.l [Writes: Stack Pointer] [Flow: call]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	and $15.b,S		; 23 15 ; AND accumulator with stack relative $15.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $23.b		; 04 23 ; Test and set bits $23.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsl $011100.l		; 22 00 11 01 ; Jump to subroutine long $011100.l [Writes: Stack Pointer] [Flow: call]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0F.b,X		; 15 0F ; OR accumulator with memory $0F.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $150000.l		; 0F 00 00 15 ; OR accumulator with memory (long) $150000.l [Writes: Accumulator] [Flags: NZ]
	asl $15.b		; 06 15 ; Arithmetic shift left $15.b [Reads: Direct Page] [Flags: NCZ]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	tsb $1522.w		; 0C 22 15 ; Test and set bits $1522.w [Reads: Accumulator] [Flags: Z]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $12.b,X		; 15 12 ; OR accumulator with memory $12.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $06.b,X		; 15 06 ; OR accumulator with memory $06.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $02.b,X		; 15 02 ; OR accumulator with memory $02.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	asl $15.b		; 06 15 ; Arithmetic shift left $15.b [Reads: Direct Page] [Flags: NCZ]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	jsl $150300.l		; 22 00 03 15 ; Jump to subroutine long $150300.l [Writes: Stack Pointer] [Flow: call]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	tsb $1523.w		; 0C 23 15 ; Test and set bits $1523.w [Reads: Accumulator] [Flags: Z]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $0C.b		; 04 0C ; Test and set bits $0C.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	.db $B0, $02		; B0 02 ; Branch if carry set to $B0, $02 [Flow: branch]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $23.b		; 04 23 ; Test and set bits $23.b [Reads: Accumulator] [Flags: Z]
	ora $04.b,X		; 15 04 ; OR accumulator with memory $04.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $06.b,X		; 15 06 ; OR accumulator with memory $06.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $830B01.l		; 0F 01 0B 83 ; OR accumulator with memory (long) $830B01.l [Writes: Accumulator] [Flags: NZ]
	brk $EC.b		; 00 EC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $620062.l,X		; FF 62 00 62 ; Subtract with carry (long,X) $620062.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $84.b		; 00 84 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $CE, $01		; 62 CE 01 ; Push effective relative address $62, $CE, $01 [Writes: Stack Pointer]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $09, $62		; 62 09 62 ; Push effective relative address $62, $09, $62 [Writes: Stack Pointer]
	ora #$84.b		; 09 84 ; Logical OR #$84.b with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $8C.b		; 06 8C ; Arithmetic shift left $8C.b [Reads: Direct Page] [Flags: NCZ]
	cmp ($92.b),Y		; D1 92 ; Compare accumulator ($92.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora #$07.b		; 09 07 ; Logical OR #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $62, $06, $00		; 62 06 00 ; Push effective relative address $62, $06, $00 [Writes: Stack Pointer]
	asl $84.b		; 06 84 ; Arithmetic shift left $84.b [Reads: Direct Page] [Flags: NCZ]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $3C.b		; 04 3C ; Test and set bits $3C.b [Reads: Accumulator] [Flags: Z]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($B0.b,S),Y		; 33 B0 ; AND accumulator (stack relative indirect indexed) ($B0.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $0083.w		; 0E 83 00 ; Arithmetic shift left $0083.w [Flags: NCZ]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1B.b		; 04 1B ; Test and set bits $1B.b [Reads: Accumulator] [Flags: Z]
	sty $3A.b		; 84 3A ; Store Y register to $3A.b [Reads: Y Index]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	sty $3A.b		; 84 3A ; Store Y register to $3A.b [Reads: Y Index]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $A01D.w		; ED 1D A0 ; Subtract $A01D.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cmp ($83.b)		; D2 83 ; Compare accumulator (indirect) ($83.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $D3.b,S		; 63 D3 ; Add with carry (stack relative) $D3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	tsb $D5D4.w		; 0C D4 D5 ; Test and set bits $D5D4.w [Reads: Accumulator] [Flags: Z]
	lda ($EE.b,S),Y		; B3 EE ; Load accumulator (stack relative indirect indexed) ($EE.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $A2D7.w,Y		; 59 D7 A2 ; Exclusive OR accumulator with memory $A2D7.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	pea $F3FE.w		; F4 FE F3 ; Push absolute address $F3FE.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	pea $86D8.w		; F4 D8 86 ; Push absolute address $86D8.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	bit $E5.b		; 24 E5 ; Test bits $E5.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	sbc $C9D95D.l		; EF 5D D9 C9 ; Subtract with carry (long) $C9D95D.l [Writes: Accumulator] [Flags: NCVZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	ora $E5.b,S		; 03 E5 ; OR accumulator with stack relative $E5.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	adc $DC.b,S		; 63 DC ; Add with carry (stack relative) $DC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	and $A91D.w		; 2D 1D A9 ; Logical AND $A91D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $E01F.w,X		; 1E 1F E0 ; Arithmetic shift left $E01F.w,X [Reads: X Index] [Flags: NCZ]
	ora #$0A.b		; 09 0A ; Logical OR #$0A.b with accumulator [Writes: Accumulator] [Flags: NZ]
	stz $1D.b,X		; 74 1D ; Store zero to $1D.b,X [Reads: X Index]
	ora $6309.w,X		; 1D 09 63 ; OR accumulator with memory $6309.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($0B.b,X)		; E1 0B ; Subtract with carry ($0B.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	and $3231.w		; 2D 31 32 ; Logical AND $3231.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$0D.b]		; [PATTERN: Memory clearing operation] 07 0D ; OR accumulator with memory (long) [$0D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$E2.b]		; 07 E2 ; OR accumulator with memory (long) [$E2.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	stz $5F.b		; 64 5F ; Store zero to $5F.b
	stz $62.b,X		; 74 62 ; Store zero to $62.b,X [Reads: X Index]
	sbc $0C.b		; E5 0C ; Subtract $0C.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$321D.w		; C0 1D 32 ; Compare #$321D.w with Y register [Reads: Y Index] [Flags: NCZ]
	bit $A73D.w,X		; 3C 3D A7 ; Test bits $A73D.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	eor ($00.b,S),Y		; 53 00 ; XOR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	trb $A930.w		; 1C 30 A9 ; Test and reset bits $A930.w [Reads: Accumulator] [Flags: Z]
	adc $E8.b,S		; 63 E8 ; Add with carry (stack relative) $E8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	adc $A330.w		; 6D 30 A3 ; Add $A330.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	ldy $AD.b		; A4 AD ; Load $AD.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	lsr $09.b,X		; 56 09 ; Logical shift right $09.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sty $EC29.w		; 8C 29 EC ; Store Y register to $EC29.w [Reads: Y Index]
	ldy #$10EC.w		; A0 EC 10 ; Load #$10EC.w into Y register [Writes: Y Index] [Flags: NZ]
	ora #$1F.b		; 09 1F ; Logical OR #$1F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $EE8EED.l,X		; 1F ED 8E EE ; Logical OR long $EE8EED.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
.ACCU 16
	rep #$67		; C2 67
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	stz $42.b		; 64 42 ; Store zero to $42.b
	.db $62, $EF, $07		; 62 EF 07 ; Push effective relative address $62, $EF, $07 [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora #$F2A0.w		; 09 A0 F2 ; Logical OR #$F2A0.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sty $D2.b,X		; 94 D2 ; Store Y register $D2.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	stx $83DF.w		; 8E DF 83 ; Store X register to $83DF.w [Reads: X Index]
	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($27.b)		; 12 27 ; OR accumulator with memory (indirect) ($27.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $4FF31F.l,X		; FF 1F F3 4F ; Subtract with carry (long,X) $4FF31F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($F4.b)		; 92 F4 ; Store accumulator (indirect) ($F4.b) [Reads: Direct Page, Accumulator]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	sta [$A0.b],Y		; 97 A0 ; Store accumulator (long indexed) [$A0.b],Y [Reads: Direct Page, Y Index, Accumulator]
	ora #$8C0A.w		; 09 0A 8C ; Logical OR #$8C0A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $22.b,X		; F5 22 ; Subtract $22.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	stz $31.b,X		; 74 31 ; Store zero to $31.b,X [Reads: X Index]
	adc $F6.b,S		; 63 F6 ; Add with carry (stack relative) $F6.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	cpy #$32C1.w		; C0 C1 32 ; Compare #$32C1.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora [$C1.b]		; 07 C1 ; OR accumulator with memory (long) [$C1.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tsb $0B93.w		; 0C 93 0B ; Test and set bits $0B93.w [Reads: Accumulator] [Flags: Z]
	stz $63.b		; 64 63 ; Store zero to $63.b
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	ora ($C5.b,X)		; 01 C5 ; Logical OR ($C5.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor ($84.b,S),Y		; 53 84 ; XOR accumulator (stack relative indirect indexed) ($84.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $8D.b		; 00 8D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	cop $09.b		; 02 09 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($FE.b),Y		; 71 FE ; Add with carry ($FE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $4208.w,Y		; F9 08 42 ; Subtract with carry $4208.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $DA46DB.l		; 4F DB 46 DA ; Exclusive OR accumulator with memory (long) $DA46DB.l [Writes: Accumulator] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	sbc $010022.l,X		; FF 22 00 01 ; Subtract with carry (long,X) $010022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $15.b,X		; 15 15 ; OR accumulator with memory $15.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $011600.l		; 22 00 16 01 ; Jump to subroutine long $011600.l [Writes: Stack Pointer] [Flow: call]
	brk $16.b		; 00 16 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	asl $00.b,X		; 16 00 ; Arithmetic shift left $00.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	ora $16.b,S		; 03 16 ; OR accumulator with stack relative $16.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	asl $02.b		; 06 02 ; Arithmetic shift left $02.b [Reads: Direct Page] [Flags: NCZ]
	asl $16.b,X		; 16 16 ; Arithmetic shift left $16.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($16.b,X)		; 01 16 ; Logical OR ($16.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $0F.b		; 25 0F ; Logical AND $0F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $01010F.l		; 0F 0F 01 01 ; OR accumulator with memory (long) $01010F.l [Writes: Accumulator] [Flags: NZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $16.b,X		; 16 16 ; Arithmetic shift left $16.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $0F.b,X		; 16 0F ; Arithmetic shift left $0F.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	ora ($0B.b,X)		; 01 0B ; Logical OR ($0B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $16.b,X		; 16 16 ; Arithmetic shift left $16.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $0D.b,X		; 16 0D ; Arithmetic shift left $0D.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$0C.b]		; 07 0C ; OR accumulator with memory (long) [$0C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $4C.b		; 00 4C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $16.b,X		; 15 16 ; OR accumulator with memory $16.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $0D01.w		; 0D 01 0D ; Logical OR $0D01.w with accumulator [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $16.b,X		; 16 16 ; Arithmetic shift left $16.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0B.b,X		; 16 0B ; Arithmetic shift left $0B.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $061A07.l		; 22 07 1A 06 ; Jump to subroutine long $061A07.l [Writes: Stack Pointer] [Flow: call]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $16.b,X		; 15 16 ; OR accumulator with memory $16.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $16.b		; 04 16 ; Test and set bits $16.b [Reads: Accumulator] [Flags: Z]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $16.b		; 00 16 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $16.b		; 04 16 ; Test and set bits $16.b [Reads: Accumulator] [Flags: Z]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	.db $82, $09, $0A		; 82 09 0A ; Branch always long to $82, $09, $0A [Flow: branch]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $19.b		; 00 19 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $02.b		; 05 02 ; Logical OR $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $23.b		; 06 23 ; Arithmetic shift left $23.b [Reads: Direct Page] [Flags: NCZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $16.b		; 24 16 ; Test bits $16.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $16.b,S		; 23 16 ; AND accumulator with stack relative $16.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $161306.l		; 22 06 13 16 ; Jump to subroutine long $161306.l [Writes: Stack Pointer] [Flow: call]
	asl $07.b,X		; 16 07 ; Arithmetic shift left $07.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	asl $0B.b		; 06 0B ; Arithmetic shift left $0B.b [Reads: Direct Page] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	cop $16.b		; 02 16 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $16.b		; 06 16 ; Arithmetic shift left $16.b [Reads: Direct Page] [Flags: NCZ]
	ora ($07.b)		; 12 07 ; OR accumulator with memory (indirect) ($07.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	asl $04.b		; 06 04 ; Arithmetic shift left $04.b [Reads: Direct Page] [Flags: NCZ]
	tsb $1616.w		; 0C 16 16 ; Test and set bits $1616.w [Reads: Accumulator] [Flags: Z]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	tsb $16.b		; 04 16 ; Test and set bits $16.b [Reads: Accumulator] [Flags: Z]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	adc $080405.l		; 6F 05 04 08 ; Add with carry (long) $080405.l [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	.db $90, $24		; 90 24 ; Branch if carry clear to $90, $24 [Flow: branch]
	tsb $06.b		; 04 06 ; Test and set bits $06.b [Reads: Accumulator] [Flags: Z]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $06.b		; 04 06 ; Test and set bits $06.b [Reads: Accumulator] [Flags: Z]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	asl $16.b,X		; 16 16 ; Arithmetic shift left $16.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	asl $FF.b		; 06 FF ; Arithmetic shift left $FF.b [Reads: Direct Page] [Flags: NCZ]
	cpx #$01AC.w		; E0 AC 01 ; Compare #$01AC.w with X register [Reads: X Index] [Flags: NCZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $3B.b		; 04 3B ; Test and set bits $3B.b [Reads: Accumulator] [Flags: Z]
	ora $1DB2.w,X		; 1D B2 1D ; OR accumulator with memory $1DB2.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ora $FBA9.w,X		; 1D A9 FB ; OR accumulator with memory $FBA9.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda #$0AD2.w		; A9 D2 0A ; Load #$0AD2.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $090B0A.l,X		; FF 0A 0B 09 ; Subtract with carry (long,X) $090B0A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$1C.b]		; 07 1C ; OR accumulator with memory (long) [$1C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $B2.b		; 00 B2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $01FC.w,X		; 1D FC 01 ; OR accumulator with memory $01FC.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $1E74.w,X		; 1D 74 1E ; OR accumulator with memory $1E74.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	stx $9F02.w		; 8E 02 9F ; Store X register to $9F02.w [Reads: X Index]
	.db $62, $B0, $0E		; 62 B0 0E ; Push effective relative address $62, $B0, $0E [Writes: Stack Pointer]
	and $0403A1.l		; 2F A1 03 04 ; AND accumulator with memory (long) $0403A1.l [Writes: Accumulator] [Flags: NZ]
	ldy #$AA1D.w		; A0 1D AA ; Load #$AA1D.w into Y register [Writes: Y Index] [Flags: NZ]
	cpy #$D4C1.w		; C0 C1 D4 ; Compare #$D4C1.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora $DB.b		; 05 DB ; Logical OR $DB.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $10A1A1.l,X		; 9F A1 A1 10 ; Store accumulator (long,X) $10A1A1.l,X [Reads: Accumulator, X Index]
	lda ($AA.b,X)		; A1 AA ; Load accumulator ($AA.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc [$68.b]		; 67 68 ; Add with carry (long) [$68.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp $1DA0.w,Y		; D9 A0 1D ; Compare accumulator $1DA0.w,Y [Reads: Y Index] [Flags: NCZ]
	cmp $53.b		; C5 53 ; Compare $53.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	cpx $5E.b		; E4 5E ; Compare $5E.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	adc ($A2.b,X)		; 61 A2 ; Add with carry ($A2.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	sta $7308.w,X		; 9D 08 73 ; Store accumulator to $7308.w,X [Reads: Accumulator, X Index]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	adc ($42.b,S),Y		; 73 42 ; Add with carry (stack relative indirect indexed) ($42.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	eor $FB0A09.l		; 4F 09 0A FB ; Exclusive OR accumulator with memory (long) $FB0A09.l [Writes: Accumulator] [Flags: NZ]
	ora $0BC922.l,X		; 1F 22 C9 0B ; Logical OR long $0BC922.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $C932.w		; EE 32 C9 ; Increment $C932.w [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	mvn $93,$52		; 54 52 93 ; Move block negative $93,$52 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	eor $0C4E.w		; 4D 4E 0C ; Exclusive OR $0C4E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0D1E1D.l,X		; 1F 1D 1E 0D ; Logical OR long $0D1E1D.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $71EF22.l		; CF 22 EF 71 ; Compare accumulator (long) $71EF22.l [Reads: Accumulator] [Flags: NCZ]
	adc ($E5.b)		; 72 E5 ; Add with carry (indirect) ($E5.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $90, $52		; 90 52 ; Branch if carry clear to $90, $52 [Flow: branch]
	cpy $5868.w		; CC 68 58 ; Compare $5868.w with Y register [Reads: Y Index] [Flags: NCZ]
	asl $1C0F.w		; 0E 0F 1C ; Arithmetic shift left $1C0F.w [Flags: NCZ]
	ora $5910.w,X		; 1D 10 59 ; OR accumulator with memory $5910.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($2D.b,S),Y		; 33 2D ; AND accumulator (stack relative indirect indexed) ($2D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $4973.w,X		; 3E 73 49 ; Rotate left $4973.w,X [Reads: X Index] [Flags: NCZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cmp $04BB.w,Y		; D9 BB 04 ; Compare accumulator $04BB.w,Y [Reads: Y Index] [Flags: NCZ]
	ora ($80.b),Y		; 11 80 ; OR accumulator with memory ($80.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($FB.b)		; 12 FB ; OR accumulator with memory (indirect) ($FB.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $4C3E.w,X		; 3D 3E 4C ; AND accumulator with memory $4C3E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $733E.w,X		; 1D 3E 73 ; OR accumulator with memory $733E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$18E5.w		; 49 E5 18 ; Exclusive OR #$18E5.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ldx $FBBF.w,Y		; BE BF FB ; Load X register $FBBF.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ora ($23.b,S),Y		; 13 23 ; OR accumulator (stack relative indirect indexed) ($23.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $08.b		; E6 08 ; Increment $08.b [Reads: Direct Page] [Flags: NZ]
	lsr $47.b		; 46 47 ; Logical shift right $47.b [Reads: Direct Page] [Flags: NCZ]
	trb $2D.b		; 14 2D ; Test and reset bits $2D.b [Reads: Accumulator] [Flags: Z]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	rol $9C73.w,X		; 3E 73 9C ; Rotate left $9C73.w,X [Reads: X Index] [Flags: NCZ]
	tsb $6F.b		; 04 6F ; Test and set bits $6F.b [Reads: Accumulator] [Flags: Z]
	eor $1E.b,X		; 55 1E ; Exclusive OR accumulator with memory $1E.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	rol $E41D.w,X		; 3E 1D E4 ; Rotate left $E41D.w,X [Reads: X Index] [Flags: NCZ]
	sbc $4A.b		; E5 4A ; Subtract $4A.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lsr $A90C.w		; 4E 0C A9 ; Logical shift right $A90C.w [Flags: NCZ]
	stz $1E.b,X		; 74 1E ; Store zero to $1E.b,X [Reads: X Index]
	rol $7171.w,X		; 3E 71 71 ; Rotate left $7171.w,X [Reads: X Index] [Flags: NCZ]
	eor #$74A9.w		; 49 A9 74 ; Exclusive OR #$74A9.w with accumulator [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	jsl $51041D.l		; 22 1D 04 51 ; Jump to subroutine long $51041D.l [Writes: Stack Pointer] [Flow: call]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	adc $1D.b		; 65 1D ; Add $1D.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	asl $1564.w,X		; 1E 64 15 ; Arithmetic shift left $1564.w,X [Reads: X Index] [Flags: NCZ]
	ora ($42.b,X)		; 01 42 ; Logical OR ($42.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $62.b,X		; 15 62 ; OR accumulator with memory $62.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	asl $91.b,X		; 16 91 ; Arithmetic shift left $91.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ldy #$1DA0.w		; A0 A0 1D ; Load #$1DA0.w into Y register [Writes: Y Index] [Flags: NZ]
	asl $9609.w,X		; 1E 09 96 ; Arithmetic shift left $9609.w,X [Reads: X Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $1F72.w,Y		; F9 72 1F ; Subtract with carry $1F72.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy #$9620.w		; A0 20 96 ; Load #$9620.w into Y register [Writes: Y Index] [Flags: NZ]
	asl $F8.b		; 06 F8 ; Arithmetic shift left $F8.b [Reads: Direct Page] [Flags: NCZ]
	sta [$32.b],Y		; 97 32 ; Store accumulator (long indexed) [$32.b],Y [Reads: Direct Page, Y Index, Accumulator]
	ora [$21.b]		; 07 21 ; OR accumulator with memory (long) [$21.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $431DA7.l		; 22 A7 1D 43 ; Jump to subroutine long $431DA7.l [Writes: Stack Pointer] [Flow: call]
	ora $0FB7.w,X		; 1D B7 0F ; OR accumulator with memory $0FB7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($23.b),Y		; 31 23 ; AND accumulator with memory ($23.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $45.b		; 24 45 ; Test bits $45.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	stx $3DAB.w		; 8E AB 3D ; Store X register to $3DAB.w [Reads: X Index]
	lda [$53.b]		; A7 53 ; Load accumulator (long) [$53.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	ora $311D.w,X		; 1D 1D 31 ; OR accumulator with memory $311D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($25.b)		; 32 25 ; AND accumulator with memory (indirect) ($25.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	.db $62, $3C, $08		; 62 3C 08 ; Push effective relative address $62, $3C, $08 [Writes: Stack Pointer]
	stx $C9AE.w		; 8E AE C9 ; Store X register to $C9AE.w [Reads: X Index]
	lsr $DA.b		; 46 DA ; Logical shift right $DA.b [Reads: Direct Page] [Flags: NCZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	.db $62, $1D, $1D		; 62 1D 1D ; Push effective relative address $62, $1D, $1D [Writes: Stack Pointer]
	.db $62, $3C, $06		; 62 3C 06 ; Push effective relative address $62, $3C, $06 [Writes: Stack Pointer]
	ora $4661.w,X		; 1D 61 46 ; OR accumulator with memory $4661.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor [$26.b]		; 47 26 ; Exclusive OR accumulator with memory (long) [$26.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and [$A4.b]		; 27 A4 ; AND accumulator with memory (long) [$A4.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $060401.l,X		; FF 01 04 06 ; Subtract with carry (long,X) $060401.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $060001.l		; 22 01 00 06 ; Jump to subroutine long $060001.l [Writes: Stack Pointer] [Flow: call]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $041400.l		; 22 00 14 04 ; Jump to subroutine long $041400.l [Writes: Stack Pointer] [Flow: call]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($16.b,X)		; 01 16 ; Logical OR ($16.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $01.b,X		; 16 01 ; Arithmetic shift left $01.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($16.b,X)		; 01 16 ; Logical OR ($16.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $02.b,X		; 16 02 ; Arithmetic shift left $02.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ora $06.b,X		; 15 06 ; OR accumulator with memory $06.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($16.b,X)		; 01 16 ; Logical OR ($16.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $02.b,X		; 16 02 ; Arithmetic shift left $02.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	asl $83.b		; 06 83 ; Arithmetic shift left $83.b [Reads: Direct Page] [Flags: NCZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $16.b		; 05 16 ; Logical OR $16.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $00.b,X		; 16 00 ; Arithmetic shift left $00.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: NCZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $00.b,X		; 16 00 ; Arithmetic shift left $00.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	jsl $0D0906.l		; 22 06 09 0D ; Jump to subroutine long $0D0906.l [Writes: Stack Pointer] [Flow: call]
	ora [$16.b]		; 07 16 ; OR accumulator with memory (long) [$16.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $07.b,X		; 16 07 ; Arithmetic shift left $07.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	asl $01.b,X		; 16 01 ; Arithmetic shift left $01.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	asl $85.b,X		; 16 85 ; Arithmetic shift left $85.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $49.b		; 00 49 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $04.b,X		; 16 04 ; Arithmetic shift left $04.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	and $16.b,S		; 23 16 ; AND accumulator with stack relative $16.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $01.b,X		; 16 01 ; Arithmetic shift left $01.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$16.b]		; 27 16 ; AND accumulator with memory (long) [$16.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl $02.b		; 06 02 ; Arithmetic shift left $02.b [Reads: Direct Page] [Flags: NCZ]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $16.b		; 00 16 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	tsb $83.b		; 04 83 ; Test and set bits $83.b [Reads: Accumulator] [Flags: Z]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	and $16.b,S		; 23 16 ; AND accumulator with stack relative $16.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	asl $06.b,X		; 16 06 ; Arithmetic shift left $06.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $162700.l		; 22 00 27 16 ; Jump to subroutine long $162700.l [Writes: Stack Pointer] [Flow: call]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $06.b,S		; 23 06 ; AND accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	eor ($01.b,S),Y		; 53 01 ; XOR accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $010106.l		; 2F 06 01 01 ; AND accumulator with memory (long) $010106.l [Writes: Accumulator] [Flags: NZ]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $24.b		; 06 24 ; Arithmetic shift left $24.b [Reads: Direct Page] [Flags: NCZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	ora ($2F.b,X)		; 01 2F ; Logical OR ($2F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $2F.b,S		; 03 2F ; OR accumulator with stack relative $2F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $FF.b		; 06 FF ; Arithmetic shift left $FF.b [Reads: Direct Page] [Flags: NCZ]
	ora $91.b		; 05 91 ; Logical OR $91.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jmp $EDF8.w		; 4C F8 ED ; Jump to $EDF8.w [Flow: jump]
	sep #$4D		; E2 4D ; Set processor status bits #$4D [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	.db $62, $06, $02		; 62 06 02 ; Push effective relative address $62, $06, $02 [Writes: Stack Pointer]
	sbc $836300.l,X		; FF 00 63 83 ; Subtract with carry (long,X) $836300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $F85A97.l,X		; 1F 97 5A F8 ; Logical OR long $F85A97.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $2928.w		; ED 28 29 ; Subtract $2928.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($09.b,S),Y		; 13 09 ; OR accumulator (stack relative indirect indexed) ($09.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $1A2A.w,X		; FD 2A 1A ; Subtract with carry $1A2A.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $BA.b,X		; 56 BA ; Logical shift right $BA.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc $2B.b		; E5 2B ; Subtract $2B.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc $272C.w,Y		; 79 2C 27 ; Add $272C.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora #$E407.w		; 09 07 E4 ; Logical OR #$E407.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $7A2E.w		; 2D 2E 7A ; Logical AND $7A2E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and [$09.b]		; 27 09 ; AND accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	jsl $C90C61.l		; 22 61 0C C9 ; Jump to subroutine long $C90C61.l [Writes: Stack Pointer] [Flow: call]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	eor [$30.b],Y		; 57 30 ; Exclusive OR accumulator with memory (long indexed) [$30.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $1D2F.w		; 0E 2F 1D ; Arithmetic shift left $1D2F.w [Flags: NCZ]
	and $301D30.l		; 2F 30 1D 30 ; AND accumulator with memory (long) $301D30.l [Writes: Accumulator] [Flags: NZ]
	asl $2262.w		; 0E 62 22 ; Arithmetic shift left $2262.w [Flags: NCZ]
	jsl $3125E0.l		; 22 E0 25 31 ; Jump to subroutine long $3125E0.l [Writes: Stack Pointer] [Flow: call]
	ora $6A5C.w,X		; 1D 5C 6A ; OR accumulator with memory $6A5C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $1C.b,S		; 63 1C ; Add with carry (stack relative) $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ldy $3332.w		; AC 32 33 ; Load $3332.w into Y register [Writes: Y Index] [Flags: NZ]
	ldy $2D34.w		; AC 34 2D ; Load $2D34.w into Y register [Writes: Y Index] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	lda $1D1DAA.l,X		; BF AA 1D 1D ; Load long $1D1DAA.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jmp $356D74.l		; 5C 74 6D 35 ; Jump long to $356D74.l [Flow: jump]
	lda ($36.b,S),Y		; B3 36 ; Load accumulator (stack relative indirect indexed) ($36.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and [$B3.b],Y		; 37 B3 ; AND accumulator with memory (long indexed) [$B3.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	and [$1D.b],Y		; 37 1D ; AND accumulator with memory (long indexed) [$1D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $398A.w,X		; 1D 8A 39 ; OR accumulator with memory $398A.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda $1E5C1D.l,X		; BF 1D 5C 1E ; Load long $1E5C1D.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta ($57.b,X)		; 81 57 ; Store accumulator ($57.b,X) [Reads: Direct Page, Accumulator, X Index]
	adc $3A.b,S		; 63 3A ; Add with carry (stack relative) $3A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	tsb $65.b		; 04 65 ; Test and set bits $65.b [Reads: Accumulator] [Flags: Z]
	and [$78.b],Y		; 37 78 ; AND accumulator with memory (long indexed) [$78.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	jmp.w [$3E62]		; DC 62 3E ; Jump long indirect [$3E62] [Flow: jump]
	ora ($6E.b,X)		; 01 6E ; Logical OR ($6E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	adc $41.b		; 65 41 ; Add $41.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	asl $42.b,X		; 16 42 ; Arithmetic shift left $42.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	eor [$80.b]		; 47 80 ; Exclusive OR accumulator with memory (long) [$80.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	dec $1D.b		; C6 1D ; Decrement $1D.b [Reads: Direct Page] [Flags: NZ]
	ora $7A48.w,X		; 1D 48 7A ; OR accumulator with memory $7A48.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $1F81.w,X		; 1D 81 1F ; OR accumulator with memory $1F81.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	bit $49.b		; 24 49 ; Test bits $49.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and [$1F.b],Y		; 37 1F ; AND accumulator with memory (long indexed) [$1F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sty $80.b		; 84 80 ; Store Y register to $80.b [Reads: Y Index]
	sbc $C7.b		; E5 C7 ; Subtract $C7.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda ($BE.b)		; B2 BE ; Load accumulator (indirect) ($BE.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $81011D.l		; 22 1D 01 81 ; Jump to subroutine long $81011D.l [Writes: Stack Pointer] [Flow: call]
	ora $064B63.l,X		; 1F 63 4B 06 ; Logical OR long $064B63.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $1D874F.l,X		; 1F 4F 87 1D ; Logical OR long $1D874F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr $BA.b,X		; 56 BA ; Logical shift right $BA.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cpy #$1D22.w		; C0 22 1D ; Compare #$1D22.w with Y register [Reads: Y Index] [Flags: NCZ]
	adc $50.b		; 65 50 ; Add $50.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tsb $51.b		; 04 51 ; Test and set bits $51.b [Reads: Accumulator] [Flags: Z]
	lsr $1D.b,X		; 56 1D ; Logical shift right $1D.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ldy #$238E.w		; A0 8E 23 ; Load #$238E.w into Y register [Writes: Y Index] [Flags: NZ]
	ora $6A00.w,X		; 1D 00 6A ; OR accumulator with memory $6A00.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $8F, $05		; 62 8F 05 ; Push effective relative address $62, $8F, $05 [Writes: Stack Pointer]
	ora $8F1D.w,X		; 1D 1D 8F ; OR accumulator with memory $8F1D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta ($1D.b,S),Y		; 93 1D ; Store accumulator (stack relative indirect indexed) ($1D.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	ora $9664.w,X		; 1D 64 96 ; OR accumulator with memory $9664.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $99.b		; 00 99 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $9B, $09		; 62 9B 09 ; Push effective relative address $62, $9B, $09 [Writes: Stack Pointer]
	sta [$A0.b],Y		; 97 A0 ; Store accumulator (long indexed) [$A0.b],Y [Reads: Direct Page, Y Index, Accumulator]
	ldy #$9F9E.w		; A0 9E 9F ; Load #$9F9E.w into Y register [Writes: Y Index] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ldy #$ABAB.w		; A0 AB AB ; Load #$ABAB.w into Y register [Writes: Y Index] [Flags: NZ]
	lda ($22.b,X)		; A1 22 ; Load accumulator ($22.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ldx #$A300.w		; A2 00 A3 ; Load #$A300.w into X register [Writes: X Index] [Flags: NZ]
	bit $AB.b		; 24 AB ; Test bits $AB.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	.db $62, $A1, $00		; 62 A1 00 ; Push effective relative address $62, $A1, $00 [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	and $A42FC9.l		; 2F C9 2F A4 ; AND accumulator with memory (long) $A42FC9.l [Writes: Accumulator] [Flags: NZ]
	sbc $010023.l,X		; FF 23 00 01 ; Subtract with carry (long,X) $010023.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	and $06.b,S		; 23 06 ; AND accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $27.b		; 06 27 ; Arithmetic shift left $27.b [Reads: Direct Page] [Flags: NCZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $01.b		; 24 01 ; Test bits $01.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $23.b		; 06 23 ; Arithmetic shift left $23.b [Reads: Direct Page] [Flags: NCZ]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: NCZ]
	asl $07.b,X		; 16 07 ; Arithmetic shift left $07.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	asl $03.b,X		; 16 03 ; Arithmetic shift left $03.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	stx $00.b		; 86 00 ; Store X register to $00.b [Reads: X Index]
	and ($04.b,S),Y		; 33 04 ; AND accumulator (stack relative indirect indexed) ($04.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $09.b		; 06 09 ; Arithmetic shift left $09.b [Reads: Direct Page] [Flags: NCZ]
	asl $16.b,X		; 16 16 ; Arithmetic shift left $16.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0C.b,S		; 03 0C ; OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $16.b		; 06 16 ; Arithmetic shift left $16.b [Reads: Direct Page] [Flags: NCZ]
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: NCZ]
	asl $00.b,X		; 16 00 ; Arithmetic shift left $00.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $02.b,X		; 16 02 ; Arithmetic shift left $02.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $2C.b		; 06 2C ; Arithmetic shift left $2C.b [Reads: Direct Page] [Flags: NCZ]
	asl $03.b,X		; 16 03 ; Arithmetic shift left $03.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $0D.b		; 06 0D ; Arithmetic shift left $0D.b [Reads: Direct Page] [Flags: NCZ]
	rol $16.b		; 26 16 ; Rotate left $16.b [Reads: Direct Page] [Flags: NCZ]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $16.b		; 24 16 ; Test bits $16.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $2D.b		; 06 2D ; Arithmetic shift left $2D.b [Reads: Direct Page] [Flags: NCZ]
	asl $02.b,X		; 16 02 ; Arithmetic shift left $02.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $162C.w		; 0D 2C 16 ; Logical OR $162C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $2E.b		; 00 2E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $22.b,X		; 16 22 ; Arithmetic shift left $22.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	asl $02.b,X		; 16 02 ; Arithmetic shift left $02.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	bit $16.b		; 24 16 ; Test bits $16.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $16.b,S		; 23 16 ; AND accumulator with stack relative $16.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $23.b		; 06 23 ; Arithmetic shift left $23.b [Reads: Direct Page] [Flags: NCZ]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $02.b		; 06 02 ; Arithmetic shift left $02.b [Reads: Direct Page] [Flags: NCZ]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$24.b]		; 07 24 ; OR accumulator with memory (long) [$24.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $23.b		; 06 23 ; Arithmetic shift left $23.b [Reads: Direct Page] [Flags: NCZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $062F03.l		; 2F 03 2F 06 ; AND accumulator with memory (long) $062F03.l [Writes: Accumulator] [Flags: NZ]
	sbc $020662.l,X		; FF 62 06 02 ; Subtract with carry (long,X) $020662.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $A5.b		; 06 A5 ; Arithmetic shift left $A5.b [Reads: Direct Page] [Flags: NCZ]
	adc ($43.b),Y		; 71 43 ; Add with carry ($43.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx $A7.b		; A6 A7 ; Load $A7.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	cop $DC.b		; 02 DC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $62, $06, $16		; 62 06 16 ; Push effective relative address $62, $06, $16 [Writes: Stack Pointer]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda #$0C16.w		; A9 16 0C ; Load #$0C16.w into accumulator [Writes: Accumulator] [Flags: NZ]
	asl $A7.b		; 06 A7 ; Arithmetic shift left $A7.b [Reads: Direct Page] [Flags: NCZ]
	asl $DC.b		; 06 DC ; Arithmetic shift left $DC.b [Reads: Direct Page] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	and $010002.l,X		; 3F 02 00 01 ; AND accumulator with memory (long,X) $010002.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora #$8C0A.w		; 09 0A 8C ; Logical OR #$8C0A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	ora $09.b,S		; 03 09 ; OR accumulator with stack relative $09.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $AE0D0A.l		; 22 0A 0D AE ; Jump to subroutine long $AE0D0A.l [Writes: Stack Pointer] [Flow: call]
	lda $090B92.l		; AF 92 0B 09 ; Load long $090B92.l into accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $B0, $0E		; B0 0E ; Branch if carry set to $B0, $0E [Flow: branch]
	.db $62, $34, $1D		; 62 34 1D ; Push effective relative address $62, $34, $1D [Writes: Stack Pointer]
	cpx $13.b		; E4 13 ; Compare $13.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	lda ($62.b),Y		; B1 62 ; Load accumulator ($62.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor [$13.b],Y		; 57 13 ; Exclusive OR accumulator with memory (long indexed) [$13.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	and ($B0.b,S),Y		; 33 B0 ; AND accumulator (stack relative indirect indexed) ($B0.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $1D62.w		; 0E 62 1D ; Arithmetic shift left $1D62.w [Flags: NCZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	inc $B7.b		; E6 B7 ; Increment $B7.b [Reads: Direct Page] [Flags: NZ]
	ora $B81F2D.l,X		; 1F 2D 1F B8 ; Logical OR long $B81F2D.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	jmp $5D77BA.l		; 5C BA 77 5D ; Jump long to $5D77BA.l [Flow: jump]
	eor $2274.w,X		; 5D 74 22 ; Exclusive OR accumulator with memory $2274.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $5F04.w,X		; 1D 04 5F ; OR accumulator with memory $5F04.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($C0.b),Y		; 31 C0 ; AND accumulator with memory ($C0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr $62D1.w,X		; 5E D1 62 ; Logical shift right $62D1.w,X [Reads: X Index] [Flags: NCZ]
	eor $62A800.l,X		; 5F 00 A8 62 ; Exclusive OR accumulator with memory (long,X) $62A800.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $05, $74		; 62 05 74 ; Push effective relative address $62, $05, $74 [Writes: Stack Pointer]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cmp $65.b		; C5 65 ; Compare $65.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ror $5D.b		; 66 5D ; Rotate right $5D.b [Reads: Direct Page] [Flags: NCZ]
	adc $67.b,S		; 63 67 ; Add with carry (stack relative) $67.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora ($6A.b,X)		; 01 6A ; Logical OR ($6A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	adc #$6B63.w		; 69 63 6B ; Add #$6B63.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	tsb $74.b		; 04 74 ; Test and set bits $74.b [Reads: Accumulator] [Flags: Z]
	ora $72D1.w,X		; 1D D1 72 ; OR accumulator with memory $72D1.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $016F65.l		; 6F 65 6F 01 ; Add with carry (long) $016F65.l [Writes: Accumulator] [Flags: NCVZ]
	brk $54.b		; 00 54 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $75.b,S		; 63 75 ; Add with carry (stack relative) $75.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora ($1D.b,X)		; 01 1D ; Logical OR ($1D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $80, $6D		; 80 6D ; Branch always to $80, $6D [Flow: branch]
	adc $1D02.w,Y		; 79 02 1D ; Add $1D02.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc ($6A.b)		; 72 6A ; Add with carry (indirect) ($6A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta [$03.b]		; 87 03 ; Store accumulator (long) [$03.b] [Reads: Direct Page, Accumulator]
	sta $92.b		; 85 92 ; Store accumulator to $92.b [Reads: Accumulator]
	sbc ($1D.b),Y		; F1 1D ; Subtract with carry ($1D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	stz $93.b		; 64 93 ; Store zero to $93.b
	brk $91.b		; 00 91 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $98.b,S		; 63 98 ; Add with carry (stack relative) $98.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora #$9C9A.w		; 09 9A 9C ; Logical OR #$9C9A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $92.b		; 85 92 ; Store accumulator to $92.b [Reads: Accumulator]
	sta $99F9.w,X		; 9D F9 99 ; Store accumulator to $99F9.w,X [Reads: Accumulator, X Index]
	sta $9B9E.w,Y		; 99 9E 9B ; Store accumulator to $9B9E.w,Y [Reads: Y Index, Accumulator]
	stz $9F.b		; 64 9F ; Store zero to $9F.b
	asl $8C.b		; 06 8C ; Arithmetic shift left $8C.b [Reads: Direct Page] [Flags: NCZ]
	lda $9F.b,S		; A3 9F ; Load accumulator (stack relative) $9F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldx #$1DA4.w		; A2 A4 1D ; Load #$1DA4.w into X register [Writes: X Index] [Flags: NZ]
	stx $63.b,Y		; 96 63 ; Store X register $63.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	ldy #$0802.w		; A0 02 08 ; Load #$0802.w into Y register [Writes: Y Index] [Flags: NZ]
	sta $2409.w,Y		; 99 09 24 ; Store accumulator to $2409.w,Y [Reads: Y Index, Accumulator]
	ldy #$AB00.w		; A0 00 AB ; Load #$AB00.w into Y register [Writes: Y Index] [Flags: NZ]
	.db $62, $A1, $23		; 62 A1 23 ; Push effective relative address $62, $A1, $23 [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	cop $0A.b		; 02 0A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx #$220B.w		; A2 0B 22 ; Load #$220B.w into X register [Writes: X Index] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	ora ($0C.b,X)		; 01 0C ; Logical OR ($0C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $C92F.w		; 0D 2F C9 ; Logical OR $C92F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $03FFA4.l		; 2F A4 FF 03 ; AND accumulator with memory (long) $03FFA4.l [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $030001.l		; 22 01 00 03 ; Jump to subroutine long $030001.l [Writes: Stack Pointer] [Flow: call]
	and $07.b,S		; 23 07 ; AND accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$24.b]		; 07 24 ; OR accumulator with memory (long) [$24.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $01.b		; 24 01 ; Test bits $01.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	trb $0602.w		; 1C 02 06 ; Test and reset bits $0602.w [Reads: Accumulator] [Flags: Z]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $070201.l		; 22 01 02 07 ; Jump to subroutine long $070201.l [Writes: Stack Pointer] [Flow: call]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $060307.l		; 22 07 03 06 ; Jump to subroutine long $060307.l [Writes: Stack Pointer] [Flow: call]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	ora ($29.b,X)		; 01 29 ; Logical OR ($29.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$02.b]		; 07 02 ; OR accumulator with memory (long) [$02.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $24.b		; 06 24 ; Arithmetic shift left $24.b [Reads: Direct Page] [Flags: NCZ]
	ora [$04.b]		; 07 04 ; OR accumulator with memory (long) [$04.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $83.b		; 02 83 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $55.b		; 00 55 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $000407.l		; 22 07 04 00 ; Jump to subroutine long $000407.l [Writes: Stack Pointer] [Flow: call]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $07.b		; 25 07 ; Logical AND $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0705.w		; 0D 05 07 ; Logical OR $0705.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	rol $08.b,X		; 36 08 ; Rotate left $08.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: NCZ]
	ora [$04.b]		; 07 04 ; OR accumulator with memory (long) [$04.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $22.b		; 05 22 ; Logical OR $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	asl $02.b		; 06 02 ; Arithmetic shift left $02.b [Reads: Direct Page] [Flags: NCZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $07.b,S		; 23 07 ; AND accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor $06.b,S		; 43 06 ; Exclusive OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $07.b		; 26 07 ; Rotate left $07.b [Reads: Direct Page] [Flags: NCZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $06.b,S		; 43 06 ; Exclusive OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$04.b]		; 07 04 ; OR accumulator with memory (long) [$04.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($25.b,X)		; 01 25 ; Logical OR ($25.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $83.b		; 06 83 ; Arithmetic shift left $83.b [Reads: Direct Page] [Flags: NCZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	rep #$03		; C2 03 ; Reset processor status bits #$03 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $010007.l		; 22 07 00 01 ; Jump to subroutine long $010007.l [Writes: Stack Pointer] [Flow: call]
	and $07.b		; 25 07 ; Logical AND $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	stx $00.b		; 86 00 ; Store X register to $00.b [Reads: X Index]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora $25.b,S		; 03 25 ; OR accumulator with stack relative $25.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$0C.b]		; 07 0C ; OR accumulator with memory (long) [$0C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$32.b]		; 07 32 ; OR accumulator with memory (long) [$32.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $060600.l,X		; FF 00 06 06 ; Subtract with carry (long,X) $060600.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $63.b,S		; 63 63 ; Add with carry (stack relative) $63.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	asl $160C.w		; 0E 0C 16 ; Arithmetic shift left $160C.w [Flags: NCZ]
	ora ($0B.b)		; 12 0B ; OR accumulator with memory (indirect) ($0B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $0002.w		; 20 02 00 ; Jump to subroutine at $0002.w [Writes: Stack Pointer] [Flow: call]
	tsb $13.b		; 04 13 ; Test and set bits $13.b [Reads: Accumulator] [Flags: Z]
	ora #$0A0A.w		; 09 0A 0A ; Logical OR #$0A0A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $62E2.w,X		; FD E2 62 ; Subtract with carry $62E2.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	trb $0F.b		; 14 0F ; Test and reset bits $0F.b [Reads: Accumulator] [Flags: Z]
	ora $9C.b,S		; 03 9C ; OR accumulator with stack relative $9C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $F8.b,X		; 16 F8 ; Arithmetic shift left $F8.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora #$E407.w		; 09 07 E4 ; Logical OR #$E407.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($15.b,S),Y		; 13 15 ; OR accumulator (stack relative indirect indexed) ($15.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $01.b,X		; 15 01 ; OR accumulator with memory $01.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $1817.w		; ED 17 18 ; Subtract $1817.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	trb $B008.w		; 1C 08 B0 ; Test and reset bits $B008.w [Reads: Accumulator] [Flags: Z]
	asl $1E19.w		; 0E 19 1E ; Arithmetic shift left $1E19.w [Flags: NCZ]
	ora $1B1A22.l,X		; 1F 22 1A 1B ; Logical OR long $1B1A22.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $1C62.w,X		; 9D 62 1C ; Store accumulator to $1C62.w,X [Reads: Accumulator, X Index]
	cop $1A.b		; 02 1A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $FB4320.l,X		; 1F 20 43 FB ; Logical OR long $FB4320.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $6A02.w,X		; 1D 02 6A ; OR accumulator with memory $6A02.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	bit $2167.w,X		; 3C 67 21 ; Test bits $2167.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	tsb $2927.w		; 0C 27 29 ; Test and set bits $2927.w [Reads: Accumulator] [Flags: Z]
	ora $1D6A.w,X		; 1D 6A 1D ; OR accumulator with memory $1D6A.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	stx $082A.w		; 8E 2A 08 ; Store X register to $082A.w [Reads: X Index]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	sbc $E6.b		; E5 E6 ; Subtract $E6.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and ($24.b,X)		; 21 24 ; Logical AND ($24.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $E608.w		; 2C 08 E6 ; Test bits $E608.w with accumulator [Reads: Accumulator] [Flags: NVZ]
.INDEX 16
	rep #$1D		; C2 1D
	ldx $FBFA.w		; AE FA FB ; Load $FBFA.w into X register [Writes: X Index] [Flags: NZ]
	ora $62E6A3.l,X		; 1F A3 E6 62 ; Logical OR long $62E6A3.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rol $1D04.w		; 2E 04 1D ; Rotate left $1D04.w [Flags: NCZ]
	and [$FF.b]		; 27 FF ; AND accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $1D.b		; E6 1D ; Increment $1D.b [Reads: Direct Page] [Flags: NZ]
	adc $31.b,S		; 63 31 ; Add with carry (stack relative) $31.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $3680.w,X		; 1D 80 36 ; OR accumulator with memory $3680.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $37.b		; E5 37 ; Subtract $37.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta [$38.b],Y		; 97 38 ; Store accumulator (long indexed) [$38.b],Y [Reads: Direct Page, Y Index, Accumulator]
	stz $6A.b,X		; 74 6A ; Store zero to $6A.b,X [Reads: X Index]
	jsl $1DDE74.l		; 22 74 DE 1D ; Jump to subroutine long $1DDE74.l [Writes: Stack Pointer] [Flow: call]
	and $3287.w,Y		; 39 87 32 ; AND accumulator with memory $3287.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$3B3A.w		; C9 3A 3B ; Compare #$3B3A.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	sbc $3C.b		; E5 3C ; Subtract $3C.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and $3EF0.w,X		; 3D F0 3E ; AND accumulator with memory $3EF0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and ($34.b,S),Y		; 33 34 ; AND accumulator (stack relative indirect indexed) ($34.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $3F.b		; E6 3F ; Increment $3F.b [Reads: Direct Page] [Flags: NZ]
	.db $30, $FB		; 30 FB ; Branch if minus to $30, $FB [Flow: branch]
	stz $40.b		; 64 40 ; Store zero to $40.b
	cpx #$AF21.w		; E0 21 AF ; Compare #$AF21.w with X register [Reads: X Index] [Flags: NCZ]
	eor $2D.b		; 45 2D ; Exclusive OR $2D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr $FB.b		; 46 FB ; Logical shift right $FB.b [Reads: Direct Page] [Flags: NCZ]
	and [$FF.b]		; 27 FF ; AND accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc ($87.b,X)		; 61 87 ; Add with carry ($87.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor [$6A.b]		; 47 6A ; Exclusive OR accumulator with memory (long) [$6A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $30, $40		; 30 40 ; Branch if minus to $30, $40 [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	jsl $4AE549.l		; 22 49 E5 4A ; Jump to subroutine long $4AE549.l [Writes: Stack Pointer] [Flow: call]
	and $4B.b,X		; 35 4B ; Logical AND $4B.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	jmp $7422.w		; 4C 22 74 ; Jump to $7422.w [Flow: jump]
	adc [$8F.b]		; 67 8F ; Add with carry (long) [$8F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	eor $08A0.w		; 4D A0 08 ; Exclusive OR $08A0.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lsr $4F5E.w		; 4E 5E 4F ; Logical shift right $4F5E.w [Flags: NCZ]
	.db $50, $49		; 50 49 ; Branch if overflow clear to $50, $49 [Flow: branch]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $62, $51, $09		; 62 51 09 ; Push effective relative address $62, $51, $09 [Writes: Stack Pointer]
	and ($34.b,S),Y		; 33 34 ; AND accumulator (stack relative indirect indexed) ($34.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	mvn $55,$9C		; 54 9C 55 ; Move block negative $55,$9C [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	eor $56.b,S		; 43 56 ; Exclusive OR accumulator with stack relative $56.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor [$43.b],Y		; 57 43 ; Exclusive OR accumulator with memory (long indexed) [$43.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	mvp $58,$65		; 44 65 58 ; Move block positive $58,$65 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $416A.w		; 0D 6A 41 ; Logical OR $416A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	mvp $5E,$0D		; 44 0D 5E ; Move block positive $5E,$0D [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	lsr $605F.w		; 4E 5F 60 ; Logical shift right $605F.w [Flags: NCZ]
	lsr $804F.w		; 4E 4F 80 ; Logical shift right $804F.w [Flags: NCZ]
	adc ($62.b,X)		; 61 62 ; Add with carry ($62.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $62.b		; E5 62 ; Subtract $62.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc $00.b,S		; 63 00 ; Add with carry (stack relative) $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	adc $66.b		; 65 66 ; Add $66.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora [$58.b]		; 07 58 ; OR accumulator with memory (long) [$58.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $6C.b		; 65 6C ; Add $6C.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc $6EC9.w		; 6D C9 6E ; Add $6EC9.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	adc $706249.l		; 6F 49 62 70 ; Add with carry (long) $706249.l [Writes: Accumulator] [Flags: NCVZ]
	ora $747320.l		; 0F 20 73 74 ; OR accumulator with memory (long) $747320.l [Writes: Accumulator] [Flags: NZ]
	eor $1D1D92.l		; 4F 92 1D 1D ; Exclusive OR accumulator with memory (long) $1D1D92.l [Writes: Accumulator] [Flags: NZ]
	and $C932.w,Y		; 39 32 C9 ; AND accumulator with memory $C932.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $4F.b,X		; 75 4F ; Add $4F.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $77		; 30 77 ; Branch if minus to $30, $77 [Flow: branch]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $01FF.w,X		; 1D FF 01 ; OR accumulator with memory $01FF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $070201.l		; 22 01 02 07 ; Jump to subroutine long $070201.l [Writes: Stack Pointer] [Flow: call]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and [$07.b]		; 27 07 ; AND accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $020401.l		; 22 01 04 02 ; Jump to subroutine long $020401.l [Writes: Stack Pointer] [Flow: call]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $07.b,S		; 23 07 ; AND accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $010207.l		; 22 07 02 01 ; Jump to subroutine long $010207.l [Writes: Stack Pointer] [Flow: call]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $07.b,S		; 23 07 ; AND accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$07.b]		; 27 07 ; AND accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $24.b		; 05 24 ; Logical OR $24.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $29.b		; 06 29 ; Arithmetic shift left $29.b [Reads: Direct Page] [Flags: NCZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $23.b		; 06 23 ; Arithmetic shift left $23.b [Reads: Direct Page] [Flags: NCZ]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $07.b,S		; 23 07 ; AND accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $07.b		; 24 07 ; Test bits $07.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	eor ($01.b,S),Y		; 53 01 ; XOR accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $07.b		; 25 07 ; Logical AND $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $25.b		; 00 25 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($25.b,X)		; 01 25 ; Logical OR ($25.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	eor ($06.b)		; 52 06 ; Exclusive OR accumulator with memory (indirect) ($06.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	asl $15.b,X		; 16 15 ; Arithmetic shift left $15.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	asl $16.b,X		; 16 16 ; Arithmetic shift left $16.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $6E.b		; 00 6E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: NCZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $150C16.l		; 22 16 0C 15 ; Jump to subroutine long $150C16.l [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $0D0016.l		; 22 16 00 0D ; Jump to subroutine long $0D0016.l [Writes: Stack Pointer] [Flow: call]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	bit #$010C.w		; 89 0C 01 ; Test bits #$010C.w with accumulator [Reads: Accumulator] [Flags: Z]
	ora [$04.b]		; 07 04 ; OR accumulator with memory (long) [$04.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $12.b,X		; 16 12 ; Arithmetic shift left $12.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($16.b)		; 12 16 ; OR accumulator with memory (indirect) ($16.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $03.b,X		; 16 03 ; Arithmetic shift left $03.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	cop $28.b		; 02 28 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	cmp $27.b		; C5 27 ; Compare $27.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $D1.b		; 00 D1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $07.b		; 26 07 ; Rotate left $07.b [Reads: Direct Page] [Flags: NCZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $030307.l		; 22 07 03 03 ; Jump to subroutine long $030307.l [Writes: Stack Pointer] [Flow: call]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $FF.b		; 05 FF ; Logical OR $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx #$2032.w		; E0 32 20 ; Compare #$2032.w with X register [Reads: X Index] [Flags: NCZ]
	ror $ED.b,X		; 76 ED ; Rotate right $ED.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	adc [$F8.b],Y		; 77 F8 ; Add with carry (long indexed) [$F8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$78.b],Y		; 17 78 ; OR accumulator with memory (long indexed) [$78.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $7879.w,Y		; 79 79 78 ; Add $7879.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($7A.b)		; 12 7A ; OR accumulator with memory (indirect) ($7A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $FBED.w		; ED ED FB ; Subtract $FBED.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	adc [$FB.b],Y		; 77 FB ; Add with carry (long indexed) [$FB.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $7C.b,S		; 03 7C ; OR accumulator with stack relative $7C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $7C7D.w,X		; 7D 7D 7C ; Add $7C7D.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	stz $7F7E.w		; 9C 7E 7F ; Store zero to $7F7E.w
	adc $9DEDF8.l,X		; 7F F8 ED 9D ; Add long $9DEDF8.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	sta ($80.b,X)		; 81 80 ; Store accumulator ($80.b,X) [Reads: Direct Page, Accumulator, X Index]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $82, $83, $83		; 82 83 83 ; Branch always long to $82, $83, $83 [Flow: branch]
	.db $82, $1F, $84		; 82 1F 84 ; Branch always long to $82, $1F, $84 [Flow: branch]
	sta $85.b		; 85 85 ; Store accumulator to $85.b [Reads: Accumulator]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sta $2386.w,X		; 9D 86 23 ; Store accumulator to $2386.w,X [Reads: Accumulator, X Index]
	rol $05.b		; 26 05 ; Rotate left $05.b [Reads: Direct Page] [Flags: NCZ]
	ora $8887.w,Y		; 19 87 88 ; OR accumulator with memory $8887.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta [$36.b]		; 87 36 ; Store accumulator (long) [$36.b] [Reads: Direct Page, Accumulator]
	.db $62, $89, $02		; 62 89 02 ; Push effective relative address $62, $89, $02 [Writes: Stack Pointer]
	and #$218C.w		; 29 8C 21 ; Logical AND #$218C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $62, $8D, $17		; 62 8D 17 ; Push effective relative address $62, $8D, $17 [Writes: Stack Pointer]
	bit $4922.w		; 2C 22 49 ; Test bits $4922.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	sbc $90.b		; E5 90 ; Subtract $90.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $2E.b		; E6 2E ; Increment $2E.b [Reads: Direct Page] [Flags: NZ]
	sta $922C91.l		; 8F 91 2C 92 ; Store accumulator (long) $922C91.l [Reads: Accumulator]
	and $9309EE.l		; 2F EE 09 93 ; AND accumulator with memory (long) $9309EE.l [Writes: Accumulator] [Flags: NZ]
	asl $9594.w,X		; 1E 94 95 ; Arithmetic shift left $9594.w,X [Reads: X Index] [Flags: NCZ]
	bit $E5.b		; 24 E5 ; Test bits $E5.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	inc $2E.b		; E6 2E ; Increment $2E.b [Reads: Direct Page] [Flags: NZ]
	and $059662.l		; 2F 62 96 05 ; AND accumulator with memory (long) $059662.l [Writes: Accumulator] [Flags: NZ]
	cmp #$99FE.w		; C9 FE 99 ; Compare #$99FE.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	and ($32.b),Y		; 31 32 ; AND accumulator with memory ($32.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jmp ($9A62.w,X)		; 7C 62 9A ; Jump indirect indexed to ($9A62.w,X) [Reads: X Index] [Flow: jump]
	asl $8B.b		; 06 8B ; Arithmetic shift left $8B.b [Reads: Direct Page] [Flags: NCZ]
	sta $8D2F.w,X		; 9D 2F 8D ; Store accumulator to $8D2F.w,X [Reads: Accumulator, X Index]
	stz $1D9F.w,X		; 9E 9F 1D ; Store zero to $1D9F.w,X [Reads: X Index]
	.db $62, $39, $62		; 62 39 62 ; Push effective relative address $62, $39, $62 [Writes: Stack Pointer]
	and $A065.w,Y		; 39 65 A0 ; AND accumulator with memory $A065.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora [$97.b],Y		; 17 97 ; OR accumulator with memory (long indexed) [$97.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta [$A6.b],Y		; 97 A6 ; Store accumulator (long indexed) [$A6.b],Y [Reads: Direct Page, Y Index, Accumulator]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sta ($A7.b),Y		; 91 A7 ; Store accumulator ($A7.b),Y [Reads: Direct Page, Y Index, Accumulator]
	and $DDA5A8.l,X		; 3F A8 A5 DD ; AND accumulator with memory (long,X) $DDA5A8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldx $A7.b		; A6 A7 ; Load $A7.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	ora $1DAFAE.l,X		; 1F AE AF 1D ; Logical OR long $1DAFAE.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rol $96A0.w		; 2E A0 96 ; Rotate left $96A0.w [Flags: NCZ]
	.db $62, $4B, $22		; 62 4B 22 ; Push effective relative address $62, $4B, $22 [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora #$A862.w		; 09 62 A8 ; Logical OR #$A862.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $1FE4.w		; 0C E4 1F ; Test and set bits $1FE4.w [Reads: Accumulator] [Flags: Z]
	ora $2EB6B5.l,X		; 1F B5 B6 2E ; Logical OR long $2EB6B5.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldy #$68B7.w		; A0 B7 68 ; Load #$68B7.w into Y register [Writes: Y Index] [Flags: NZ]
	ldx $0630.w,Y		; BE 30 06 ; Load X register $0630.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	.db $10, $62		; 10 62 ; Branch if plus to $10, $62 [Flow: branch]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	cpx #$C022.w		; E0 22 C0 ; Compare #$C022.w with X register [Reads: X Index] [Flags: NCZ]
	ora $1DBDBC.l,X		; 1F BC BD 1D ; Logical OR long $1DBDBC.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	inc $BE.b		; E6 BE ; Increment $BE.b [Reads: Direct Page] [Flags: NZ]
	and #$196A.w		; 29 6A 19 ; Logical AND #$196A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	adc ($AE.b),Y		; 71 AE ; Add with carry ($AE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($34.b,S),Y		; 33 34 ; AND accumulator (stack relative indirect indexed) ($34.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $C244B0.l		; AF B0 44 C2 ; Load long $C244B0.l into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $C324E4.l,X		; 9F E4 24 C3 ; Store accumulator (long,X) $C324E4.l,X [Reads: Accumulator, X Index]
	sta [$44.b],Y		; 97 44 ; Store accumulator (long indexed) [$44.b],Y [Reads: Direct Page, Y Index, Accumulator]
	stx $27.b		; 86 27 ; Store X register to $27.b [Reads: X Index]
	ora #$B72F.w		; 09 2F B7 ; Logical OR #$B72F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cpy $8D.b		; C4 8D ; Compare $8D.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	stz $649F.w,X		; 9E 9F 64 ; Store zero to $649F.w,X [Reads: X Index]
	cmp $07.b		; C5 07 ; Compare $07.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sta $CB8DCA.l,X		; 9F CA 8D CB ; Store accumulator (long,X) $CB8DCA.l,X [Reads: Accumulator, X Index]
	asl $CC2F.w		; 0E 2F CC ; Arithmetic shift left $CC2F.w [Flags: NCZ]
	sta $CD67.w		; 8D 67 CD ; Store accumulator to $CD67.w [Reads: Accumulator]
	ora $A9.b,S		; 03 A9 ; OR accumulator with stack relative $A9.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $22D6D5.l		; 4F D5 D6 22 ; Exclusive OR accumulator with memory (long) $22D6D5.l [Writes: Accumulator] [Flags: NZ]
	jmp $D711.w		; 4C 11 D7 ; Jump to $D711.w [Flow: jump]
	dec $D848.w		; CE 48 D8 ; Decrement $D848.w [Flags: NZ]
	sta $D2D9.w		; 8D D9 D2 ; Store accumulator to $D2D9.w [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	lda #$4FDC.w		; A9 DC 4F ; Load #$4FDC.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp $DDDE.w,X		; DD DE DD ; Compare accumulator $DDDE.w,X [Reads: X Index] [Flags: NCZ]
	cmp $48DF.w,X		; DD DF 48 ; Compare accumulator $48DF.w,X [Reads: X Index] [Flags: NCZ]
	.db $62, $E0, $03		; 62 E0 03 ; Push effective relative address $62, $E0, $03 [Writes: Stack Pointer]
	sta $E396.w		; 8D 96 E3 ; Store accumulator to $E396.w [Reads: Accumulator]
	sbc $1622FF.l,X		; FF FF 22 16 ; Subtract with carry (long,X) $1622FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $16.b		; 06 16 ; Arithmetic shift left $16.b [Reads: Direct Page] [Flags: NCZ]
	asl $06.b,X		; 16 06 ; Arithmetic shift left $06.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $01.b,X		; 16 01 ; Arithmetic shift left $01.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $010B16.l		; 22 16 0B 01 ; Jump to subroutine long $010B16.l [Writes: Stack Pointer] [Flow: call]
	ora $16.b		; 05 16 ; Logical OR $16.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$0507.w		; 09 07 05 ; Logical OR #$0507.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $16.b,X		; 16 16 ; Arithmetic shift left $16.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tsb $1616.w		; 0C 16 16 ; Test and set bits $1616.w [Reads: Accumulator] [Flags: Z]
	ora $23.b,S		; 03 23 ; OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $08.b,X		; 16 08 ; Arithmetic shift left $08.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	asl $05.b		; 06 05 ; Arithmetic shift left $05.b [Reads: Direct Page] [Flags: NCZ]
	ora #$0705.w		; 09 05 07 ; Logical OR #$0705.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $16.b,X		; 16 16 ; Arithmetic shift left $16.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tsb $2205.w		; 0C 05 22 ; Test and set bits $2205.w [Reads: Accumulator] [Flags: Z]
	asl $00.b,X		; 16 00 ; Arithmetic shift left $00.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $25.b,S		; 03 25 ; OR accumulator with stack relative $25.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$09.b]		; 07 09 ; OR accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora [$16.b]		; 07 16 ; OR accumulator with memory (long) [$16.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $0A.b,X		; 16 0A ; Arithmetic shift left $0A.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	asl $06.b,X		; 16 06 ; Arithmetic shift left $06.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tsb $1601.w		; 0C 01 16 ; Test and set bits $1601.w [Reads: Accumulator] [Flags: Z]
	eor $0A.b,S		; 43 0A ; Exclusive OR accumulator with stack relative $0A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$16.b]		; 07 16 ; OR accumulator with memory (long) [$16.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $16.b		; 00 16 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $05.b,S		; 23 05 ; AND accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $16.b,S		; 03 16 ; OR accumulator with stack relative $16.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $07.b,X		; 16 07 ; Arithmetic shift left $07.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $E0.b		; 02 E0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $000B.w		; 20 0B 00 ; Jump to subroutine at $000B.w [Writes: Stack Pointer] [Flow: call]
	brk $16.b		; 00 16 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $16.b		; 05 16 ; Logical OR $16.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $05.b,X		; 16 05 ; Arithmetic shift left $05.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	asl $07.b,X		; 16 07 ; Arithmetic shift left $07.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora [$16.b]		; 07 16 ; OR accumulator with memory (long) [$16.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $0002.w		; 0C 02 00 ; Test and set bits $0002.w [Reads: Accumulator] [Flags: Z]
	asl $16.b,X		; 16 16 ; Arithmetic shift left $16.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl $03.b,X		; 16 03 ; Arithmetic shift left $03.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	asl $01.b,X		; 16 01 ; Arithmetic shift left $01.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $16.b		; 02 16 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ror $03.b		; 66 03 ; Rotate right $03.b [Reads: Direct Page] [Flags: NCZ]
	tsb $0A0A.w		; 0C 0A 0A ; Test and set bits $0A0A.w [Reads: Accumulator] [Flags: Z]
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: NCZ]
	asl $06.b,X		; 16 06 ; Arithmetic shift left $06.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $0F.b,X		; 16 0F ; Arithmetic shift left $0F.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $26.b		; 00 26 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b,X		; 16 00 ; Arithmetic shift left $00.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $10, $24		; 10 24 ; Branch if plus to $10, $24 [Flow: branch]
	asl $03.b,X		; 16 03 ; Arithmetic shift left $03.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $16.b		; 24 16 ; Test bits $16.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $16.b,X		; 16 16 ; Arithmetic shift left $16.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tsb $10.b		; 04 10 ; Test and set bits $10.b [Reads: Accumulator] [Flags: Z]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $28.b		; 02 28 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $83.b,X		; 16 83 ; Arithmetic shift left $83.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $71.b		; 00 71 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $16030D.l		; 22 0D 03 16 ; Jump to subroutine long $16030D.l [Writes: Stack Pointer] [Flow: call]
	asl $02.b,X		; 16 02 ; Arithmetic shift left $02.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cop $43.b		; 02 43 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($16.b,X)		; 01 16 ; Logical OR ($16.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $16.b,S		; 03 16 ; OR accumulator with stack relative $16.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	jsl $000416.l		; 22 16 04 00 ; Jump to subroutine long $000416.l [Writes: Stack Pointer] [Flow: call]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $07.b,X		; 16 07 ; Arithmetic shift left $07.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	cpy #$1601.w		; C0 01 16 ; Compare #$1601.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora $000522.l		; 0F 22 05 00 ; OR accumulator with memory (long) $000522.l [Writes: Accumulator] [Flags: NZ]
	ora $0D0084.l		; 0F 84 00 0D ; OR accumulator with memory (long) $0D0084.l [Writes: Accumulator] [Flags: NZ]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	lsr $1602.w		; 4E 02 16 ; Logical shift right $1602.w [Flags: NCZ]
	asl $0A.b,X		; 16 0A ; Arithmetic shift left $0A.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	jsl $170716.l		; 22 16 07 17 ; Jump to subroutine long $170716.l [Writes: Stack Pointer] [Flow: call]
	ora ($16.b,X)		; 01 16 ; Logical OR ($16.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $10.b,X		; 16 10 ; Arithmetic shift left $10.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $17.b		; 05 17 ; Logical OR $17.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $28.b,X		; 15 28 ; OR accumulator with memory $28.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$04.b],Y		; 17 04 ; OR accumulator with memory (long indexed) [$04.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $07.b,X		; 16 07 ; Arithmetic shift left $07.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cop $17.b		; 02 17 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$FF.b],Y		; 17 FF ; OR accumulator with memory (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lda ($B1.b),Y		; B1 B1 ; Load accumulator ($B1.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda ($47.b)		; B2 47 ; Load accumulator (indirect) ($47.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldx $B4B3.w		; AE B3 B4 ; Load $B4B3.w into X register [Writes: X Index] [Flags: NZ]
	ora $82.b,S		; 03 82 ; OR accumulator with stack relative $82.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $65.b		; 00 65 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $B5, $E0		; 62 B5 E0 ; Push effective relative address $62, $B5, $E0 [Writes: Stack Pointer]
	and ($77.b,X)		; 21 77 ; Logical AND ($77.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	adc ($B8.b),Y		; 71 B8 ; Add with carry ($B8.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	lda $A215.w,Y		; B9 15 A2 ; Load $A215.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	lda $75.b		; A5 75 ; Load $75.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
.ACCU 8
.INDEX 8
	sep #$BB		; E2 BB
	ldy $BD99.w,X		; BC 99 BD ; Load Y register $BD99.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda [$50.b],Y		; B7 50 ; Load accumulator (long indexed) [$50.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ldx $BFBF.w,Y		; BE BF BF ; Load X register $BFBF.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	cpy #$A4.b		; C0 A4 ; Compare #$A4.b with Y register [Reads: Y Index] [Flags: NCZ]
	lda $A5.b,S		; A3 A5 ; Load accumulator (stack relative) $A5.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $75.b		; E5 75 ; Subtract $75.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp ($C2.b,X)		; C1 C2 ; Compare accumulator ($C2.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	sta $BDEC.w,Y		; 99 EC BD ; Store accumulator to $BDEC.w,Y [Reads: Y Index, Accumulator]
	cmp $C4.b,S		; C3 C4 ; Compare accumulator (stack relative) $C4.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	eor [$25.b],Y		; 57 25 ; Exclusive OR accumulator with memory (long indexed) [$25.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	ora #$04.b		; 09 04 ; Logical OR #$04.b with accumulator [Writes: Accumulator] [Flags: NZ]
	adc $14C6C5.l		; 6F C5 C6 14 ; Add with carry (long) $14C6C5.l [Writes: Accumulator] [Flags: NCVZ]
	ldx $09.b,Y		; B6 09 ; Load X register $09.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	stx $E6.b,Y		; 96 E6 ; Store X register $E6.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	cpy $43.b		; C4 43 ; Compare $43.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	ora #$DE.b		; 09 DE ; Logical OR #$DE.b with accumulator [Writes: Accumulator] [Flags: NZ]
	cpx #$39.b		; E0 39 ; Compare #$39.b with X register [Reads: X Index] [Flags: NCZ]
	dec $71C7.w,X		; DE C7 71 ; Decrement memory $71C7.w,X [Reads: X Index] [Flags: NZ]
	eor #$1D.b		; 49 1D ; Exclusive OR #$1D.b with accumulator [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sbc $FFF9F9.l,X		; FF F9 F9 FF ; Subtract with carry (long,X) $FFF9F9.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp #$CA.b		; C9 CA ; Compare #$CA.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp $4C4B44.l		; CF 44 4B 4C ; Compare accumulator (long) $4C4B44.l [Reads: Accumulator] [Flags: NCZ]
	cpy $AA4E.w		; CC 4E AA ; Compare $AA4E.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora $EBCB.w,X		; 1D CB EB ; OR accumulator with memory $EBCB.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$C5.b		; 09 C5 ; Logical OR #$C5.b with accumulator [Writes: Accumulator] [Flags: NZ]
	cpy $EDCD.w		; CC CD ED ; Compare $EDCD.w with Y register [Reads: Y Index] [Flags: NCZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sta $91CE9F.l,X		; 9F 9F CE 91 ; Store accumulator (long,X) $91CE9F.l,X [Reads: Accumulator, X Index]
	sta ($EF.b),Y		; 91 EF ; Store accumulator ($EF.b),Y [Reads: Direct Page, Y Index, Accumulator]
	cmp ($1D.b,S),Y		; D3 1D ; Compare accumulator (stack relative indirect indexed) ($1D.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	cmp $FFF9D0.l		; CF D0 F9 FF ; Compare accumulator (long) $FFF9D0.l [Reads: Accumulator] [Flags: NCZ]
	ora $F0.b,X		; 15 F0 ; OR accumulator with memory $F0.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($A0.b),Y		; D1 A0 ; Compare accumulator ($A0.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cmp ($D5.b)		; D2 D5 ; Compare accumulator (indirect) ($D5.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	lda ($81.b)		; B2 81 ; Load accumulator (indirect) ($81.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cmp ($DD.b,S),Y		; D3 DD ; Compare accumulator (stack relative indirect indexed) ($DD.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	sta $9ED5D4.l,X		; 9F D4 D5 9E ; Store accumulator (long,X) $9ED5D4.l,X [Reads: Accumulator, X Index]
	ora ($13.b,S),Y		; 13 13 ; OR accumulator (stack relative indirect indexed) ($13.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $62.b		; 06 62 ; Arithmetic shift left $62.b [Reads: Direct Page] [Flags: NCZ]
	dec $06.b,X		; D6 06 ; Decrement memory $06.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	sta $D985.w,Y		; 99 85 D9 ; Store accumulator to $D985.w,Y [Reads: Y Index, Accumulator]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	sbc $1D91.w		; ED 91 1D ; Subtract $1D91.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ror $DA.b		; 66 DA ; Rotate right $DA.b [Reads: Direct Page] [Flags: NCZ]
	brk $98.b		; [PATTERN: Memory clearing operation] 00 98 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $E1.b		; 64 E1 ; Store zero to $E1.b
	ora $7A.b,S		; 03 7A ; OR accumulator with stack relative $7A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $565F.w,X		; 1D 5F 56 ; OR accumulator with memory $565F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	stz $E6.b		; 64 E6 ; Store zero to $E6.b
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cmp $16.b,S		; C3 16 ; Compare accumulator (stack relative) $16.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	sbc ($EB.b,X)		; E1 EB ; Subtract with carry ($EB.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sty $4288.w		; 8C 88 42 ; Store Y register to $4288.w [Reads: Y Index]
	ora $5F5F.w,X		; 1D 5F 5F ; OR accumulator with memory $5F5F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dec $EC66.w,X		; DE 66 EC ; Decrement memory $EC66.w,X [Reads: X Index] [Flags: NZ]
	ora [$E1.b],Y		; 17 E1 ; OR accumulator with memory (long indexed) [$E1.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sbc $1D.b,S		; E3 1D ; Subtract stack-relative $1D.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	lda $FA60.w,Y		; B9 60 FA ; Load $FA60.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	cmp $F4F3.w		; CD F3 F4 ; Compare $F4F3.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	eor $7359.w,Y		; 59 59 73 ; Exclusive OR accumulator with memory $7359.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cpx $E1.b		; E4 E1 ; Compare $E1.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sbc $D9.b,S		; E3 D9 ; Subtract stack-relative $D9.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	adc $94.b		; 65 94 ; Add $94.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and $25.b		; 25 25 ; Logical AND $25.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $62, $F5, $E0		; 62 F5 E0 ; Push effective relative address $62, $F5, $E0 [Writes: Stack Pointer]
	rol $AA.b		; 26 AA ; Rotate left $AA.b [Reads: Direct Page] [Flags: NCZ]
	eor ($2E.b,X)		; 41 2E ; Exclusive OR accumulator with memory ($2E.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	stx $E1.b,Y		; 96 E1 ; Store X register $E1.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sbc $86.b,S		; E3 86 ; Subtract stack-relative $86.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	sed		; F8 ; Set decimal flag [Flags: D]
	and $F9C5F9.l		; 2F F9 C5 F9 ; AND accumulator with memory (long) $F9C5F9.l [Writes: Accumulator] [Flags: NZ]
	.db $30, $F9		; 30 F9 ; Branch if minus to $30, $F9 [Flow: branch]
	eor ($48.b,X)		; 41 48 ; Exclusive OR accumulator with memory ($48.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	cmp [$50.b],Y		; D7 50 ; Compare accumulator (long indexed) [$50.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	sbc ($FB.b,X)		; E1 FB ; Subtract with carry ($FB.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $8D.b,X		; D5 8D ; Compare accumulator $8D.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	jsr ($6BFD.w,X)		; FC FD 6B ; Jump to subroutine indirect indexed ($6BFD.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $FFFE.w,X		; FE FE FF ; Increment memory $FFFE.w,X [Reads: X Index] [Flags: NZ]
	brk $48.b		; 00 48 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	cmp [$98.b],Y		; D7 98 ; Compare accumulator (long indexed) [$98.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	lda ($01.b,X)		; A1 01 ; Load accumulator ($01.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lda [$62.b],Y		; B7 62 ; Load accumulator (long indexed) [$62.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cop $24.b		; 02 24 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $CE.b		; 06 CE ; Arithmetic shift left $CE.b [Reads: Direct Page] [Flags: NCZ]
	adc ($97.b)		; 72 97 ; Add with carry (indirect) ($97.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $020022.l,X		; FF 22 00 02 ; Subtract with carry (long,X) $020022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $26.b		; 04 26 ; Test and set bits $26.b [Reads: Accumulator] [Flags: Z]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $04.b		; 06 04 ; Arithmetic shift left $04.b [Reads: Direct Page] [Flags: NCZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	ora $04.b,X		; 15 04 ; OR accumulator with memory $04.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$23.b]		; 07 23 ; OR accumulator with memory (long) [$23.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $26.b,S		; 03 26 ; OR accumulator with stack relative $26.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$04.b]		; 07 04 ; OR accumulator with memory (long) [$04.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $26.b		; 06 26 ; Arithmetic shift left $26.b [Reads: Direct Page] [Flags: NCZ]
	ora [$10.b]		; 07 10 ; OR accumulator with memory (long) [$10.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$17.b],Y		; 17 17 ; OR accumulator with memory (long indexed) [$17.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($17.b,X)		; 01 17 ; Logical OR ($17.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$04.b],Y		; 17 04 ; OR accumulator with memory (long indexed) [$04.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	asl $17.b		; 06 17 ; Arithmetic shift left $17.b [Reads: Direct Page] [Flags: NCZ]
	ora [$07.b],Y		; 17 07 ; OR accumulator with memory (long indexed) [$07.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $010207.l		; 22 07 02 01 ; Jump to subroutine long $010207.l [Writes: Stack Pointer] [Flow: call]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	lsr $00.b		; 46 00 ; Logical shift right $00.b [Reads: Direct Page] [Flags: NCZ]
	brk $84.b		; 00 84 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $4B.b		; 00 4B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($0B.b,X)		; 01 0B ; Logical OR ($0B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$00.b],Y		; 17 00 ; OR accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $08.b		; 25 08 ; Logical AND $08.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$07.b		; 09 07 ; Logical OR #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $08.b		; 06 08 ; Arithmetic shift left $08.b [Reads: Direct Page] [Flags: NCZ]
	ora [$17.b]		; 07 17 ; OR accumulator with memory (long) [$17.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($25.b,X)		; 01 25 ; Logical OR ($25.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora #$07.b		; 09 07 ; Logical OR #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $08.b		; 24 08 ; Test bits $08.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $08.b		; 26 08 ; Rotate left $08.b [Reads: Direct Page] [Flags: NCZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$01.b],Y		; 17 01 ; OR accumulator with memory (long indexed) [$01.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsl $082217.l		; 22 17 22 08 ; Jump to subroutine long $082217.l [Writes: Stack Pointer] [Flow: call]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	and $08.b,S		; 23 08 ; AND accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $17.b		; 02 17 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $17.b,S		; 23 17 ; AND accumulator with stack relative $17.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	.db $90, $43		; 90 43 ; Branch if carry clear to $90, $43 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$01.b],Y		; 17 01 ; OR accumulator with memory (long indexed) [$01.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora [$08.b],Y		; 17 08 ; OR accumulator with memory (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $17.b,S		; 23 17 ; AND accumulator with stack relative $17.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	adc $241722.l		; 6F 22 17 24 ; Add with carry (long) $241722.l [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsl L000317.l		; 22 17 83 00 ; Jump to subroutine long L000317.l [Writes: Stack Pointer] [Flow: call]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	ora [$27.b]		; 07 27 ; OR accumulator with memory (long) [$27.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	cmp $0001.w		; CD 01 00 ; Compare $0001.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $08.b		; 25 08 ; Logical AND $08.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $17.b		; 02 17 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$FF.b],Y		; 17 FF ; OR accumulator with memory (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $0B.b		; 05 0B ; Logical OR $0B.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$0A.b		; 09 0A ; Logical OR #$0A.b with accumulator [Writes: Accumulator] [Flags: NZ]
	stz $E4.b,X		; 74 E4 ; Store zero to $E4.b,X [Reads: X Index]
	jsl $000083.l		; 22 83 00 00 ; Jump to subroutine long $000083.l [Writes: Stack Pointer] [Flow: call]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	.db $62, $06, $07		; 62 06 07 ; Push effective relative address $62, $06, $07 [Writes: Stack Pointer]
	bit $3347.w,X		; 3C 47 33 ; Test bits $3347.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	.db $B0, $0E		; B0 0E ; Branch if carry set to $B0, $0E [Flow: branch]
	.db $62, $34, $3B		; 62 34 3B ; Push effective relative address $62, $34, $3B [Writes: Stack Pointer]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ora $05.b,X		; 15 05 ; OR accumulator with memory $05.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $02		; B0 02 ; Branch if carry set to $B0, $02 [Flow: branch]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor [$23.b]		; 47 23 ; Exclusive OR accumulator with memory (long) [$23.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $62E662.l,X		; 5F 62 E6 62 ; Exclusive OR accumulator with memory (long,X) $62E662.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	ora $E7.b		; 05 E7 ; Logical OR $E7.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora #$07.b		; 09 07 ; Logical OR #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cpx $A022.w		; EC 22 A0 ; Compare $A022.w with X register [Reads: X Index] [Flags: NCZ]
	adc $ED.b,S		; 63 ED ; Add with carry (stack relative) $ED.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $62, $F0, $10		; 62 F0 10 ; Push effective relative address $62, $F0, $10 [Writes: Stack Pointer]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	sbc ($F4.b,S),Y		; F3 F4 ; Subtract with carry (stack relative indirect indexed) ($F4.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora #$0A.b		; 09 0A ; Logical OR #$0A.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$0B.b		; A0 0B ; Load #$0B.b into Y register [Writes: Y Index] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	lda $EEBA.w,Y		; B9 BA EE ; Load $EEBA.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $42, $0C		; 42 0C ; Reserved instruction
	ora $F2F7.w		; 0D F7 F2 ; Logical OR $F2F7.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $F962.w		; 2D 62 F9 ; Logical AND $F962.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cpx #$20.b		; E0 20 ; Compare #$20.b with X register [Reads: X Index] [Flags: NCZ]
	sbc $D9.b		; E5 D9 ; Subtract $D9.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	rep #$0E		; C2 0E ; Reset processor status bits #$0E [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ldy $1DEE.w,X		; BC EE 1D ; Load Y register $1DEE.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ora $F2F710.l		; 0F 10 F7 F2 ; OR accumulator with memory (long) $F2F710.l [Writes: Accumulator] [Flags: NZ]
	tsb $090B.w		; 0C 0B 09 ; Test and set bits $090B.w [Reads: Accumulator] [Flags: Z]
	ora ($98.b),Y		; 11 98 ; OR accumulator with memory ($98.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpx $E5.b		; E4 E5 ; Compare $E5.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc $BD.b		; E5 BD ; Subtract $BD.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $6AEE.w,X		; 1D EE 6A ; OR accumulator with memory $6AEE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $F2F729.l,X		; DF 29 F7 F2 ; Compare accumulator (long,X) $F2F729.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	ora ($06.b)		; 12 06 ; OR accumulator with memory (indirect) ($06.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $2F		; 10 2F ; Branch if plus to $10, $2F [Flow: branch]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $0B.b		; 02 0B ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $DB59.w		; EE 59 DB ; Increment $DB59.w [Flags: NZ]
	rol $F203.w,X		; 3E 03 F2 ; Rotate left $F203.w,X [Reads: X Index] [Flags: NCZ]
	ora ($02.b,S),Y		; 13 02 ; OR accumulator (stack relative indirect indexed) ($02.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc ($26.b),Y		; 71 26 ; Add with carry ($26.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $080A07.l		; 22 07 0A 08 ; Jump to subroutine long $080A07.l [Writes: Stack Pointer] [Flow: call]
	inc $5E5D.w		; EE 5D 5E ; Increment $5E5D.w [Flags: NZ]
	adc ($09.b,X)		; 61 09 ; Add with carry ($09.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc ($0B.b,X)		; 61 0B ; Add with carry ($0B.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora #$2F.b		; 09 2F ; Logical OR #$2F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	stz $0B.b		; 64 0B ; Store zero to $0B.b
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $11.b		; 65 11 ; Add $11.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $14.b		; 05 14 ; Logical OR $14.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $10.b		; 06 10 ; Arithmetic shift left $10.b [Reads: Direct Page] [Flags: NCZ]
	and $62370B.l		; 2F 0B 37 62 ; AND accumulator with memory (long) $62370B.l [Writes: Accumulator] [Flags: NZ]
	ora $01.b,X		; 15 01 ; OR accumulator with memory $01.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	.db $62, $18, $62		; 62 18 62 ; Push effective relative address $62, $18, $62 [Writes: Stack Pointer]
	ora $710208.l,X		; 1F 08 02 71 ; Logical OR long $710208.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rol $0B.b		; 26 0B ; Rotate left $0B.b [Reads: Direct Page] [Flags: NCZ]
	jsl $1B2465.l		; 22 65 24 1B ; Jump to subroutine long $1B2465.l [Writes: Stack Pointer] [Flow: call]
	rol $64.b		; 26 64 ; Rotate left $64.b [Reads: Direct Page] [Flags: NCZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora ($2B.b,X)		; 01 2B ; Logical OR ($2B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $0083.w		; 2C 83 00 ; Test bits $0083.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	.db $90, $05		; 90 05 ; Branch if carry clear to $90, $05 [Flow: branch]
	and $2F0B.w		; 2D 0B 2F ; Logical AND $2F0B.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $1B14.w		; 20 14 1B ; Jump to subroutine at $1B14.w [Writes: Stack Pointer] [Flow: call]
	.db $62, $21, $02		; 62 21 02 ; Push effective relative address $62, $21, $02 [Writes: Stack Pointer]
	ora $83240C.l,X		; 1F 0C 24 83 ; Logical OR long $83240C.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $34.b		; 05 34 ; Logical OR $34.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($25.b)		; 12 25 ; OR accumulator with memory (indirect) ($25.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $36.b		; 26 36 ; Rotate left $36.b [Reads: Direct Page] [Flags: NCZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	.db $62, $37, $02		; 62 37 02 ; Push effective relative address $62, $37, $02 [Writes: Stack Pointer]
	ora $832827.l,X		; 1F 27 28 83 ; Logical OR long $832827.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $B0.b		; 00 B0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E7.b		; 00 E7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $3C.b		; 64 3C ; Store zero to $3C.b
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ora ($2D.b,X)		; 01 2D ; Logical OR ($2D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and #$83.b		; 29 83 ; Logical AND #$83.b with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $2B.b		; 04 2B ; Test and set bits $2B.b [Reads: Accumulator] [Flags: Z]
	.db $42, $E4		; 42 E4 ; Reserved instruction
	eor $44.b,S		; 43 44 ; Exclusive OR accumulator with stack relative $44.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	cmp $4501.w,Y		; D9 01 45 ; Compare accumulator $4501.w,Y [Reads: Y Index] [Flags: NCZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc $040026.l,X		; FF 26 00 04 ; Subtract with carry (long,X) $040026.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $08.b,S		; 23 08 ; AND accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	rol $07.b		; 26 07 ; Rotate left $07.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	rol $07.b		; 26 07 ; Rotate left $07.b [Reads: Direct Page] [Flags: NCZ]
	eor $08.b,S		; 43 08 ; Exclusive OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$04.b]		; 07 04 ; OR accumulator with memory (long) [$04.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($27.b,X)		; 01 27 ; Logical OR ($27.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$22.b],Y		; 17 22 ; OR accumulator with memory (long indexed) [$22.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and [$17.b]		; 27 17 ; AND accumulator with memory (long) [$17.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $24E008.l		; 22 08 E0 24 ; Jump to subroutine long $24E008.l [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $08.b,S		; 03 08 ; OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $17.b		; 06 17 ; Arithmetic shift left $17.b [Reads: Direct Page] [Flags: NCZ]
	ora [$0B.b],Y		; 17 0B ; OR accumulator with memory (long indexed) [$0B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora [$08.b],Y		; 17 08 ; OR accumulator with memory (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora [$17.b],Y		; 17 17 ; OR accumulator with memory (long indexed) [$17.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$03.b],Y		; 17 03 ; OR accumulator with memory (long indexed) [$03.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0717.w		; 0D 17 07 ; Logical OR $0717.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0204.w		; 0D 04 02 ; Logical OR $0204.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	ora [$17.b]		; 07 17 ; OR accumulator with memory (long) [$17.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $25.b		; 05 25 ; Logical OR $25.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $09.b		; 02 09 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	cop $17.b		; 02 17 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $02.b		; 06 02 ; Arithmetic shift left $02.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$2D.b]		; 07 2D ; OR accumulator with memory (long) [$2D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$2D.b],Y		; 17 2D ; OR accumulator with memory (long indexed) [$2D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $08.b,S		; 43 08 ; Exclusive OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$17.b]		; 07 17 ; OR accumulator with memory (long) [$17.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$07.b],Y		; 17 07 ; OR accumulator with memory (long indexed) [$07.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	rol $08.b		; 26 08 ; Rotate left $08.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $17.b,S		; 03 17 ; OR accumulator with stack relative $17.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$08.b],Y		; 17 08 ; OR accumulator with memory (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$07.b],Y		; 17 07 ; OR accumulator with memory (long indexed) [$07.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora [$24.b]		; 07 24 ; OR accumulator with memory (long) [$24.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cop $17.b		; 02 17 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	cpy #$22.b		; C0 22 ; Compare #$22.b with Y register [Reads: Y Index] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$26.b],Y		; 17 26 ; OR accumulator with memory (long indexed) [$26.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	cpy #$03.b		; C0 03 ; Compare #$03.b with Y register [Reads: Y Index] [Flags: NCZ]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $08.b,S		; 43 08 ; Exclusive OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $008508.l		; 22 08 85 00 ; Jump to subroutine long $008508.l [Writes: Stack Pointer] [Flow: call]
	lda ($01.b,S),Y		; B3 01 ; Load accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $070108.l		; 22 08 01 07 ; Jump to subroutine long $070108.l [Writes: Stack Pointer] [Flow: call]
	ora $FF.b		; 05 FF ; Logical OR $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $62, $09, $62		; 62 09 62 ; Push effective relative address $62, $09, $62 [Writes: Stack Pointer]
	ora #$05.b		; 09 05 ; Logical OR #$05.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$2F.b		; 09 2F ; Logical OR #$2F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	eor [$48.b]		; 47 48 ; Exclusive OR accumulator with memory (long) [$48.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $634E.w		; 4D 4E 63 ; Exclusive OR $634E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	eor #$0A.b		; 49 0A ; Exclusive OR #$0A.b with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $B062.w		; 0E 62 B0 ; Arithmetic shift left $B062.w [Flags: NCZ]
	asl $B062.w		; 0E 62 B0 ; Arithmetic shift left $B062.w [Flags: NCZ]
	asl $4D2F.w		; 0E 2F 4D ; Arithmetic shift left $4D2F.w [Flags: NCZ]
	lsr $6457.w		; 4E 57 64 ; Logical shift right $6457.w [Flags: NCZ]
	eor $08E826.l		; 4F 26 E8 08 ; Exclusive OR accumulator with memory (long) $08E826.l [Writes: Accumulator] [Flags: NZ]
	and $543DEA.l,X		; 3F EA 3D 54 ; AND accumulator with memory (long,X) $543DEA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $551D74.l		; 22 74 1D 55 ; Jump to subroutine long $551D74.l [Writes: Stack Pointer] [Flow: call]
	lsr $26.b,X		; 56 26 ; Logical shift right $26.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $F0, $08		; F0 08 ; Branch if equal to $F0, $08 [Flow: branch]
	mvp $35,$EE		; 44 EE 35 ; Move block positive $35,$EE [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	inc $3433.w		; EE 33 34 ; Increment $3433.w [Flags: NZ]
	ora $675B.w,X		; 1D 5B 67 ; OR accumulator with memory $675B.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	stz $2B.b		; 64 2B ; Store zero to $2B.b
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	bit $1130.w		; 2C 30 11 ; Test bits $1130.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	eor $1DE560.l,X		; 5F 60 E5 1D ; Exclusive OR accumulator with memory (long,X) $1DE560.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda ($61.b,X)		; A1 61 ; Load accumulator ($61.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $64, $31		; 62 64 31 ; Push effective relative address $62, $64, $31 [Writes: Stack Pointer]
	cop $31.b		; 02 31 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($36.b)		; 32 36 ; AND accumulator with memory (indirect) ($36.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $62, $68, $E0		; 62 68 E0 ; Push effective relative address $62, $68, $E0 [Writes: Stack Pointer]
	bit $1D.b		; 24 1D ; Test bits $1D.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora $6B9A.w,X		; 1D 9A 6B ; OR accumulator with memory $6B9A.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldy $37.b		; A4 37 ; Load $37.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	bit $0B.b		; 24 0B ; Test bits $0B.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	adc $3837.w		; 6D 37 38 ; Add $3837.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	bit $B9.b		; 24 B9 ; Test bits $B9.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ldx $E5EE.w,Y		; BE EE E5 ; Load X register $E5EE.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	and $32.b		; 25 32 ; Logical AND $32.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$E5.b		; C9 E5 ; Compare #$E5.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora $600D.w		; 0D 0D 60 ; Logical OR $600D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $600D.w		; 20 0D 60 ; Jump to subroutine at $600D.w [Writes: Stack Pointer] [Flow: call]
	lda $C960.w,Y		; B9 60 C9 ; Load $C960.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$EE.b		; C0 EE ; Compare #$EE.b with Y register [Reads: Y Index] [Flags: NCZ]
	jsr $711E.w		; 20 1E 71 ; Jump to subroutine at $711E.w [Writes: Stack Pointer] [Flow: call]
	adc ($E5.b)		; 72 E5 ; Add with carry (indirect) ($E5.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and $61.b		; 25 61 ; Logical AND $61.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$C9.b		; 09 C9 ; Logical OR #$C9.b with accumulator [Writes: Accumulator] [Flags: NZ]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $EE.b		; 26 EE ; Rotate left $EE.b [Reads: Direct Page] [Flags: NCZ]
	sbc $42.b		; E5 42 ; Subtract $42.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	rol $4973.w,X		; 3E 73 49 ; Rotate left $4973.w,X [Reads: X Index] [Flags: NCZ]
	and $14.b		; 25 14 ; Logical AND $14.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $74.b		; 00 74 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $750612.l		; 22 12 06 75 ; Jump to subroutine long $750612.l [Writes: Stack Pointer] [Flow: call]
	ora ($12.b)		; 12 12 ; OR accumulator with memory (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror $3E.b,X		; 76 3E ; Rotate right $3E.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	adc [$39.b],Y		; 77 39 ; Add with carry (long indexed) [$39.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $79.b,S		; 63 79 ; Add with carry (stack relative) $79.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	adc $7C.b,S		; 63 7C ; Add with carry (stack relative) $7C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	jsl $816280.l		; 22 80 62 81 ; Jump to subroutine long $816280.l [Writes: Stack Pointer] [Flow: call]
	ora #$32.b		; 09 32 ; Logical OR #$32.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sty $F0.b		; 84 F0 ; Store Y register to $F0.b [Reads: Y Index]
	sta $F2.b		; 85 F2 ; Store accumulator to $F2.b [Reads: Accumulator]
	sbc $3A.b		; E5 3A ; Subtract $3A.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc ($2D.b)		; F2 2D ; Subtract with carry (indirect) ($2D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $62, $0D, $62		; 62 0D 62 ; Push effective relative address $62, $0D, $62 [Writes: Stack Pointer]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ora #$32.b		; 09 32 ; Logical OR #$32.b with accumulator [Writes: Accumulator] [Flags: NZ]
	bit $8D25.w,X		; 3C 25 8D ; Test bits $8D25.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	sbc ($6A.b)		; F2 6A ; Subtract with carry (indirect) ($6A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sbc [$F2.b],Y		; F7 F2 ; Subtract with carry (long indexed) [$F2.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $1762.w		; 0C 62 17 ; Test and set bits $1762.w [Reads: Accumulator] [Flags: Z]
	tsb $3D8E.w		; 0C 8E 3D ; Test and set bits $3D8E.w [Reads: Accumulator] [Flags: Z]
	ldx $3E90.w		; AE 90 3E ; Load $3E90.w into X register [Writes: X Index] [Flags: NZ]
	and $5BF293.l,X		; 3F 93 F2 5B ; AND accumulator with memory (long,X) $5BF293.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	stx $87.b		; 86 87 ; Store X register to $87.b [Reads: X Index]
	sbc ($0B.b)		; F2 0B ; Subtract with carry (indirect) ($0B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $62, $23, $63		; 62 23 63 ; Push effective relative address $62, $23, $63 [Writes: Stack Pointer]
	sty $0F.b,X		; 94 0F ; Store Y register $0F.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rol $9A.b		; 26 9A ; Rotate left $9A.b [Reads: Direct Page] [Flags: NCZ]
	sbc ($1D.b)		; F2 1D ; Subtract with carry (indirect) ($1D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and $F7.b		; 25 F7 ; Logical AND $F7.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc ($22.b)		; F2 22 ; Subtract with carry (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $F71F2F.l,X		; 1F 2F 1F F7 ; Logical OR long $F71F2F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	adc ($C9.b,X)		; 61 C9 ; Add with carry ($C9.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $62, $9C, $84		; 62 9C 84 ; Push effective relative address $62, $9C, $84 [Writes: Stack Pointer]
	brk $B3.b		; 00 B3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0C.b]		; 07 0C ; OR accumulator with memory (long) [$0C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $A09F25.l,X		; 1F 25 9F A0 ; Logical OR long $A09F25.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	adc ($C9.b,X)		; 61 C9 ; Add with carry ($C9.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $220400.l,X		; FF 00 04 22 ; Subtract with carry (long,X) $220400.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $01.b,S		; 43 01 ; Exclusive OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$04.b]		; 07 04 ; OR accumulator with memory (long) [$04.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $000308.l		; 22 08 03 00 ; Jump to subroutine long $000308.l [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $08.b,S		; 23 08 ; AND accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $001101.l		; 22 01 11 00 ; Jump to subroutine long $001101.l [Writes: Stack Pointer] [Flow: call]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $2D.b		; 00 2D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $004301.l		; 22 01 43 00 ; Jump to subroutine long $004301.l [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	and ($00.b),Y		; 31 00 ; AND accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora [$62.b]		; 07 62 ; OR accumulator with memory (long) [$62.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	and ($22.b)		; 32 22 ; AND accumulator with memory (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	eor ($22.b)		; 52 22 ; Exclusive OR accumulator with memory (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $84.b		; 00 84 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3B.b		; 00 3B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $030707.l		; 22 07 07 03 ; Jump to subroutine long $030707.l [Writes: Stack Pointer] [Flow: call]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	ora [$17.b],Y		; 17 17 ; OR accumulator with memory (long indexed) [$17.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $1722.w		; 0D 22 17 ; Logical OR $1722.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	asl $0300.w,X		; 1E 00 03 ; Arithmetic shift left $0300.w,X [Reads: X Index] [Flags: NCZ]
	jsl $040101.l		; 22 01 01 04 ; Jump to subroutine long $040101.l [Writes: Stack Pointer] [Flow: call]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	ora [$07.b],Y		; 17 07 ; OR accumulator with memory (long indexed) [$07.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	mvp $01,$08		; 44 08 01 ; Move block positive $01,$08 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$22.b],Y		; 17 22 ; OR accumulator with memory (long indexed) [$22.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	jmp ($0702.w,X)		; 7C 02 07 ; Jump indirect indexed to ($0702.w,X) [Reads: X Index] [Flow: jump]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	jsl $040201.l		; 22 01 02 04 ; Jump to subroutine long $040201.l [Writes: Stack Pointer] [Flow: call]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $008308.l		; 22 08 83 00 ; Jump to subroutine long $008308.l [Writes: Stack Pointer] [Flow: call]
	jmp ($0503.w,X)		; 7C 03 05 ; Jump indirect indexed to ($0503.w,X) [Reads: X Index] [Flow: jump]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $29.b		; 00 29 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0C.b		; 06 0C ; Arithmetic shift left $0C.b [Reads: Direct Page] [Flags: NCZ]
	asl $17.b		; 06 17 ; Arithmetic shift left $17.b [Reads: Direct Page] [Flags: NCZ]
	asl $0F.b		; 06 0F ; Arithmetic shift left $0F.b [Reads: Direct Page] [Flags: NCZ]
	ora [$07.b],Y		; 17 07 ; OR accumulator with memory (long indexed) [$07.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $090905.l		; 22 05 09 09 ; Jump to subroutine long $090905.l [Writes: Stack Pointer] [Flow: call]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0B.b],Y		; 17 0B ; OR accumulator with memory (long indexed) [$0B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $8400.w		; 0D 00 84 ; Logical OR $8400.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $9C.b		; 00 9C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $08.b		; 06 08 ; Arithmetic shift left $08.b [Reads: Direct Page] [Flags: NCZ]
	ora [$0D.b],Y		; 17 0D ; OR accumulator with memory (long indexed) [$0D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $0D0017.l		; 22 17 00 0D ; Jump to subroutine long $0D0017.l [Writes: Stack Pointer] [Flow: call]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	cpy $0105.w		; CC 05 01 ; Compare $0105.w with Y register [Reads: Y Index] [Flags: NCZ]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $84.b		; 04 84 ; Test and set bits $84.b [Reads: Accumulator] [Flags: Z]
	brk $E2.b		; 00 E2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $08.b,S		; 03 08 ; OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $04.b		; 06 04 ; Arithmetic shift left $04.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $FF.b		; 05 FF ; Logical OR $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $4E.b		; 05 4E ; Logical OR $4E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda ($4C.b,X)		; A1 4C ; Load accumulator ($4C.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ldx #$1D.b		; A2 1D ; Load #$1D.b into X register [Writes: X Index] [Flags: NZ]
	trb $A362.w		; 1C 62 A3 ; Test and reset bits $A362.w [Reads: Accumulator] [Flags: Z]
	asl $B2.b,X		; 16 B2 ; Arithmetic shift left $B2.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	adc [$4A.b]		; 67 4A ; Add with carry (long) [$4A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lsr $95A6.w		; 4E A6 95 ; Logical shift right $95A6.w [Flags: NCZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $53A7.w,X		; 3D A7 53 ; AND accumulator with memory $53A7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda ($A9.b)		; B2 A9 ; Load accumulator (indirect) ($A9.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldx $26.b,Y		; B6 26 ; Load X register $26.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	ora $AA1D.w,X		; 1D 1D AA ; OR accumulator with memory $AA1D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($58.b),Y		; 51 58 ; Exclusive OR accumulator with memory ($58.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	sta $E5.b,X		; 95 E5 ; Store accumulator to $E5.b,X [Reads: Accumulator, X Index]
	adc $AC.b,S		; 63 AC ; Add with carry (stack relative) $AC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$36.b		; E0 36 ; Compare #$36.b with X register [Reads: X Index] [Flags: NCZ]
	ldx $B0.b,Y		; B6 B0 ; Load X register $B0.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	ora #$93.b		; 09 93 ; Logical OR #$93.b with accumulator [Writes: Accumulator] [Flags: NZ]
	adc ($62.b,X)		; 61 62 ; Add with carry ($62.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $FEC9.w		; 2D C9 FE ; Logical AND $FEC9.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lda ($95.b),Y		; B1 95 ; Load accumulator ($95.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda ($B3.b)		; B2 B3 ; Load accumulator (indirect) ($B3.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $EEC2.w,Y		; 99 C2 EE ; Store accumulator to $EEC2.w,Y [Reads: Y Index, Accumulator]
	ora #$B4.b		; 09 B4 ; Logical OR #$B4.b with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $67F6.w		; 0E F6 67 ; Arithmetic shift left $67F6.w [Flags: NCZ]
	lda $1C.b,X		; B5 1C ; Load $1C.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $B63A.w,Y		; 39 3A B6 ; AND accumulator with memory $B63A.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $B2.b,X		; 95 B2 ; Store accumulator to $B2.b,X [Reads: Accumulator, X Index]
	lda [$67.b],Y		; B7 67 ; Load accumulator (long indexed) [$67.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ldy #$30.b		; A0 30 ; Load #$30.b into Y register [Writes: Y Index] [Flags: NZ]
	asl $B8F6.w		; 0E F6 B8 ; Arithmetic shift left $B8F6.w [Flags: NCZ]
	ldx $B9.b,Y		; B6 B9 ; Load X register $B9.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	and #$24.b		; 29 24 ; Logical AND #$24.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($8E.b),Y		; 91 8E ; Store accumulator ($8E.b),Y [Reads: Direct Page, Y Index, Accumulator]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	sta $E5.b,X		; 95 E5 ; Store accumulator to $E5.b,X [Reads: Accumulator, X Index]
	ldy $20.b		; A4 20 ; Load $20.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	cmp $61BB.w,Y		; D9 BB 61 ; Compare accumulator $61BB.w,Y [Reads: Y Index] [Flags: NCZ]
	.db $62, $EE, $09		; 62 EE 09 ; Push effective relative address $62, $EE, $09 [Writes: Stack Pointer]
	and $832499.l		; 2F 99 24 83 ; AND accumulator with memory (long) $832499.l [Writes: Accumulator] [Flags: NZ]
	brk $2B.b		; 00 2B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($3B.b,X)		; 01 3B ; Logical OR ($3B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $BD62.w,X		; 1D 62 BD ; OR accumulator with memory $BD62.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $67.b		; 06 67 ; Arithmetic shift left $67.b [Reads: Direct Page] [Flags: NCZ]
	lda $30.b,X		; B5 30 ; Load $30.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	asl $AAF6.w		; 0E F6 AA ; Arithmetic shift left $AAF6.w [Flags: NCZ]
	ora $0084.w,X		; 1D 84 00 ; OR accumulator with memory $0084.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ror $556F.w		; 6E 6F 55 ; Rotate right $556F.w [Flags: NCZ]
	cmp $FF2729.l,X		; DF 29 27 FF ; Compare accumulator (long,X) $FF2729.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	eor ($42.b,X)		; 41 42 ; Exclusive OR accumulator with memory ($42.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	stz $62.b,X		; 74 62 ; Store zero to $62.b,X [Reads: X Index]
	eor $04.b,S		; 43 04 ; Exclusive OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $E5.b,X		; 95 E5 ; Store accumulator to $E5.b,X [Reads: Accumulator, X Index]
	cmp #$CA.b		; C9 CA ; Compare #$CA.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	eor #$62.b		; 49 62 ; Exclusive OR #$62.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $42, $12		; 42 12 ; Reserved instruction
	jsl $474674.l		; 22 74 46 47 ; Jump to subroutine long $474674.l [Writes: Stack Pointer] [Flow: call]
	sta ($48.b,S),Y		; 93 48 ; Store accumulator (stack relative indirect indexed) ($48.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	bit $49.b		; 24 49 ; Test bits $49.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sta $E5.b,X		; 95 E5 ; Store accumulator to $E5.b,X [Reads: Accumulator, X Index]
	eor ($CC.b)		; 52 CC ; Exclusive OR accumulator with memory (indirect) ($CC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy #$CD.b		; A0 CD ; Load #$CD.b into Y register [Writes: Y Index] [Flags: NZ]
	lsr $33CE.w		; 4E CE 33 ; Logical shift right $33CE.w [Flags: NCZ]
	cmp $17624A.l		; CF 4A 62 17 ; Compare accumulator (long) $17624A.l [Reads: Accumulator] [Flags: NCZ]
	tsb $4C4B.w		; 0C 4B 4C ; Test and set bits $4C4B.w [Reads: Accumulator] [Flags: Z]
	sta $E5.b,X		; 95 E5 ; Store accumulator to $E5.b,X [Reads: Accumulator, X Index]
	clc		; 18 ; Clear carry flag [Flags: C]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	adc ($57.b,S),Y		; 73 57 ; Add with carry (stack relative indirect indexed) ($57.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	adc $BF.b		; 65 BF ; Add $BF.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $6206.w,X		; 1D 06 62 ; OR accumulator with memory $6206.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $E0.b,S		; 23 E0 ; AND accumulator with stack relative $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	eor $954E.w		; 4D 4E 95 ; Exclusive OR $954E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $E5.b		; E5 E5 ; Subtract $E5.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	eor ($93.b)		; 52 93 ; Exclusive OR accumulator with memory (indirect) ($93.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $6261.w,X		; 1D 61 62 ; OR accumulator with memory $6261.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta [$98.b],Y		; 97 98 ; Store accumulator (long indexed) [$98.b],Y [Reads: Direct Page, Y Index, Accumulator]
	asl $3E.b		; 06 3E ; Arithmetic shift left $3E.b [Reads: Direct Page] [Flags: NCZ]
	eor $4909B7.l		; 4F B7 09 49 ; Exclusive OR accumulator with memory (long) $4909B7.l [Writes: Accumulator] [Flags: NZ]
	sta $E5.b,X		; 95 E5 ; Store accumulator to $E5.b,X [Reads: Accumulator, X Index]
	inc $F2.b		; E6 F2 ; Increment $F2.b [Reads: Direct Page] [Flags: NZ]
	and $C2.b,S		; 23 C2 ; AND accumulator with stack relative $C2.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc [$B5.b]		; 67 B5 ; Add with carry (long) [$B5.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $501D.w,X		; 1D 1D 50 ; OR accumulator with memory $501D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jmp $1F8C.w		; 4C 8C 1F ; Jump to $1F8C.w [Flow: jump]
	eor ($4C.b),Y		; 51 4C ; Exclusive OR accumulator with memory ($4C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $E5.b,X		; 95 E5 ; Store accumulator to $E5.b,X [Reads: Accumulator, X Index]
	eor ($D5.b)		; 52 D5 ; Exclusive OR accumulator with memory (indirect) ($D5.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor ($60.b)		; 52 60 ; Exclusive OR accumulator with memory (indirect) ($60.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $1D1D29.l,X		; DF 29 1D 1D ; Compare accumulator (long,X) $1D1D29.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	.db $62, $53, $0C		; 62 53 0C ; Push effective relative address $62, $53, $0C [Writes: Stack Pointer]
	stz $56.b,X		; 74 56 ; Store zero to $56.b,X [Reads: X Index]
	eor [$95.b],Y		; 57 95 ; Exclusive OR accumulator with memory (long indexed) [$95.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $52.b		; E5 52 ; Subtract $52.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp $4843.w,Y		; D9 43 48 ; Compare accumulator $4843.w,Y [Reads: Y Index] [Flags: NCZ]
	eor #$43.b		; 49 43 ; Exclusive OR #$43.b with accumulator [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	eor #$84.b		; 49 84 ; Exclusive OR #$84.b with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $E2.b		; 00 E2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	jmp.w [$E595]		; DC 95 E5 ; Jump long indirect [$E595] [Flow: jump]
	eor ($DD.b)		; 52 DD ; Exclusive OR accumulator with memory (indirect) ($DD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	jmp $A14E.w		; 4C 4E A1 ; Jump to $A14E.w [Flow: jump]
	jmp $A14E.w		; 4C 4E A1 ; Jump to $A14E.w [Flow: jump]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	sbc ($02.b,S),Y		; F3 02 ; Subtract with carry (stack relative indirect indexed) ($02.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	dec $E595.w,X		; DE 95 E5 ; Decrement memory $E595.w,X [Reads: X Index] [Flags: NZ]
	sbc $174FE4.l,X		; FF E4 4F 17 ; Subtract with carry (long,X) $174FE4.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$2D.b]		; 07 2D ; OR accumulator with memory (long) [$2D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$01.b],Y		; 17 01 ; OR accumulator with memory (long indexed) [$01.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $0117.w		; 2D 17 01 ; Logical AND $0117.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $0117.w		; 2D 17 01 ; Logical AND $0117.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $0117.w		; 2D 17 01 ; Logical AND $0117.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $0117.w		; 2D 17 01 ; Logical AND $0117.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $0117.w		; 2D 17 01 ; Logical AND $0117.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $0117.w		; 2D 17 01 ; Logical AND $0117.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $0117.w		; 2D 17 01 ; Logical AND $0117.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $0117.w		; 2D 17 01 ; Logical AND $0117.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $0117.w		; 2D 17 01 ; Logical AND $0117.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $FF17.w		; 2D 17 FF ; Logical AND $FF17.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cpx $2C.b		; E4 2C ; Compare $2C.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	cop $59.b		; 02 59 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	and $58.b		; 25 58 ; Logical AND $58.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $5C.b		; 02 5C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $665B.w,X		; 5D 5B 66 ; Exclusive OR accumulator with memory $665B.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr $5802.w,X		; 5E 02 58 ; Logical shift right $5802.w,X [Reads: X Index] [Flags: NCZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	jmp $036565.l		; 5C 65 65 03 ; Jump long to $036565.l [Flow: jump]
	.db $62, $6B, $6C		; 62 6B 6C ; Push effective relative address $62, $6B, $6C [Writes: Stack Pointer]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $62, $6D, $01		; 62 6D 01 ; Push effective relative address $62, $6D, $01 [Writes: Stack Pointer]
	sbc $75.b		; E5 75 ; Subtract $75.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ror $70.b		; 66 70 ; Rotate right $70.b [Reads: Direct Page] [Flags: NCZ]
	ora $6D.b,S		; 03 6D ; OR accumulator with stack relative $6D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $62, $6C, $62		; 62 6C 62 ; Push effective relative address $62, $6C, $62 [Writes: Stack Pointer]
	.db $62, $77, $0A		; 62 77 0A ; Push effective relative address $62, $77, $0A [Writes: Stack Pointer]
	sbc $75.b		; E5 75 ; Subtract $75.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc #$7C.b		; 69 7C ; Add #$7C.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	adc ($72.b),Y		; 71 72 ; Add with carry ($72.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $6B.b,X		; 76 6B ; Rotate right $6B.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	adc $7D64.w		; 6D 64 7D ; Add $7D64.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc $75.b		; E5 75 ; Subtract $75.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $82, $74, $75		; 82 74 75 ; Branch always long to $82, $74, $75 [Flow: branch]
	sta $7B.b,S		; 83 7B ; Store accumulator (stack relative) $7B.b,S [Reads: Stack Pointer, Accumulator]
	adc #$76.b		; 69 76 ; Add #$76.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	.db $62, $6B, $64		; 62 6B 64 ; Push effective relative address $62, $6B, $64 [Writes: Stack Pointer]
	sty $84.b		; 84 84 ; Store Y register to $84.b [Reads: Y Index]
	brk $50.b		; 00 50 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $89.b		; 00 89 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	lsr $64.b,X		; 56 64 ; Logical shift right $64.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $8F.b		; 00 8F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ror $65.b		; 66 65 ; Rotate right $65.b [Reads: Direct Page] [Flags: NCZ]
	.db $90, $84		; 90 84 ; Branch if carry clear to $90, $84 [Flow: branch]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $96.b		; 06 96 ; Arithmetic shift left $96.b [Reads: Direct Page] [Flags: NCZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc #$76.b		; 69 76 ; Add #$76.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta [$98.b],Y		; 97 98 ; Store accumulator (long indexed) [$98.b],Y [Reads: Direct Page, Y Index, Accumulator]
	sta ($63.b),Y		; 91 63 ; Store accumulator ($63.b),Y [Reads: Direct Page, Y Index, Accumulator]
	sta $0084.w,Y		; 99 84 00 ; Store accumulator to $0084.w,Y [Reads: Y Index, Accumulator]
	.db $50, $00		; 50 00 ; Branch if overflow clear to $50, $00 [Flow: branch]
	sta $7462.w,X		; 9D 62 74 ; Store accumulator to $7462.w,X [Reads: Accumulator, X Index]
	ror $9E.b		; 66 9E ; Rotate right $9E.b [Reads: Direct Page] [Flags: NCZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora ($A5.b,X)		; 01 A5 ; Logical OR ($A5.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	adc ($64.b),Y		; 71 64 ; Add with carry ($64.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx $62.b		; A6 62 ; Load $62.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	brk $AC.b		; 00 AC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	.db $70, $05		; 70 05 ; Branch if overflow set to $70, $05 [Flow: branch]
	adc #$AD.b		; 69 AD ; Add #$AD.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta [$AE.b],Y		; 97 AE ; Store accumulator (long indexed) [$AE.b],Y [Reads: Direct Page, Y Index, Accumulator]
	lda $B06381.l		; AF 81 63 B0 ; Load long $B06381.l into accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($9B.b,X)		; 01 9B ; Logical OR ($9B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	.db $50, $00		; 50 00 ; Branch if overflow clear to $50, $00 [Flow: branch]
	adc $62.b,X		; 75 62 ; Add $62.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy $00.b,X		; B4 00 ; Load Y register $00.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	lda $66.b,X		; B5 66 ; Load $66.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lda [$83.b],Y		; B7 83 ; Load accumulator (long indexed) [$83.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ldx $C800.w,Y		; BE 00 C8 ; Load X register $C800.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	sbc $175CE4.l,X		; FF E4 5C 17 ; Subtract with carry (long,X) $175CE4.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $0217.w		; 2C 17 02 ; Test bits $0217.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $2C.b		; 05 2C ; Logical OR $2C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$02.b],Y		; 17 02 ; OR accumulator with memory (long indexed) [$02.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $2C.b		; 05 2C ; Logical OR $2C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$02.b],Y		; 17 02 ; OR accumulator with memory (long indexed) [$02.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $2C.b		; 05 2C ; Logical OR $2C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$02.b],Y		; 17 02 ; OR accumulator with memory (long indexed) [$02.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $23.b		; 05 23 ; Logical OR $23.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$22.b],Y		; 17 22 ; OR accumulator with memory (long indexed) [$22.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $17.b		; 25 17 ; Logical AND $17.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: NCZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$18.b],Y		; 17 18 ; OR accumulator with memory (long indexed) [$18.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	ora [$83.b],Y		; 17 83 ; OR accumulator with memory (long indexed) [$83.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $5D.b		; 00 5D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $18.b,S		; 23 18 ; AND accumulator with stack relative $18.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $172318.l		; 22 18 23 17 ; Jump to subroutine long $172318.l [Writes: Stack Pointer] [Flow: call]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	ora [$00.b],Y		; 17 00 ; OR accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsl $030217.l		; 22 17 02 03 ; Jump to subroutine long $030217.l [Writes: Stack Pointer] [Flow: call]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $18.b,S		; 23 18 ; AND accumulator with stack relative $18.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $18.b		; 25 18 ; Logical AND $18.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	clc		; 18 ; Clear carry flag [Flags: C]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	jmp $583FFF.l		; 5C FF 3F 58 ; Jump long to $583FFF.l [Flow: jump]
	cop $5B.b		; 02 5B ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp #$CA.b		; C9 CA ; Compare #$CA.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	bit $6858.w		; 2C 58 68 ; Test bits $6858.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	wai		; CB ; Wait for interrupt
	rol $58.b		; 26 58 ; Rotate left $58.b [Reads: Direct Page] [Flags: NCZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	pei ($00.b)		; D4 00 ; Push effective indirect address ($00.b) [Reads: Direct Page] [Writes: Stack Pointer]
	cmp ($22.b,S),Y		; D3 22 ; Compare accumulator (stack relative indirect indexed) ($22.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	tsb $E0.b		; 04 E0 ; Test and set bits $E0.b [Reads: Accumulator] [Flags: Z]
	sbc ($D9.b,X)		; E1 D9 ; Subtract with carry ($D9.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sep #$CC		; E2 CC ; Set processor status bits #$CC [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	adc $E3.b		; 65 E3 ; Add $E3.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tsb $E7.b		; 04 E7 ; Test and set bits $E7.b [Reads: Accumulator] [Flags: Z]
	jmp.w [$C932]		; DC 32 C9 ; Jump long indirect [$C932] [Flow: jump]
	sbc $63.b		; E5 63 ; Subtract $63.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc #$0B.b		; E9 0B ; Subtract #$0B.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cmp $D6.b,X		; D5 D6 ; Compare accumulator $D6.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc $E7E5.w		; ED E5 E7 ; Subtract $E7E5.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	jmp.w [$DCE8]		; DC E8 DC ; Jump long indirect [$DCE8] [Flow: jump]
	inc $32.b		; E6 32 ; Increment $32.b [Reads: Direct Page] [Flags: NZ]
	cmp #$E5.b		; C9 E5 ; Compare #$E5.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	adc $EE.b,S		; 63 EE ; Add with carry (stack relative) $EE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	cld		; D8 ; Clear decimal flag [Flags: D]
	cmp $E5F2.w,Y		; D9 F2 E5 ; Compare accumulator $E5F2.w,Y [Reads: Y Index] [Flags: NCZ]
	jmp.w [$E8E6]		; DC E6 E8 ; Jump long indirect [$E8E6] [Flow: jump]
	inc $E7.b		; E6 E7 ; Increment $E7.b [Reads: Direct Page] [Flags: NZ]
	and ($C9.b)		; 32 C9 ; AND accumulator with memory (indirect) ($C9.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $64.b		; E5 64 ; Subtract $64.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($84.b,S),Y		; F3 84 ; Subtract with carry (stack relative indirect indexed) ($84.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	brk $55.b		; 00 55 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	ora ($94.b,X)		; 01 94 ; Logical OR ($94.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta $64.b,X		; 95 64 ; Store accumulator to $64.b,X [Reads: Accumulator, X Index]
	sbc $E503.w,Y		; F9 03 E5 ; Subtract with carry $E503.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$DC.b]		; E7 DC ; Subtract with carry (long) [$DC.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $84.b		; E5 84 ; Subtract $84.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	brk $6B.b		; 00 6B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $9B.b,S		; 03 9B ; OR accumulator with stack relative $9B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	inc $62FF.w,X		; FE FF 62 ; Increment memory $62FF.w,X [Reads: X Index] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $DC.b		; E5 DC ; Subtract $DC.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inc $E5.b		; E6 E5 ; Increment $E5.b [Reads: Direct Page] [Flags: NZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	tda		; [PATTERN: Memory clearing operation] 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: NCZ]
	stz $0504.w,X		; 9E 04 05 ; Store zero to $0504.w,X [Reads: X Index]
	ror $9E.b,X		; 76 9E ; Rotate right $9E.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	stz $E562.w,X		; 9E 62 E5 ; Store zero to $E562.w,X [Reads: X Index]
	brk $E5.b		; 00 E5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ldy $0706.w		; AC 06 07 ; Load $0706.w into Y register [Writes: Y Index] [Flags: NZ]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy $0906.w		; AC 06 09 ; Load $0906.w into Y register [Writes: Y Index] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	brk $99.b		; 00 99 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$9C.b]		; 07 9C ; OR accumulator with memory (long) [$9C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	stz $9B9C.w		; 9C 9C 9B ; Store zero to $9B9C.w
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tsb $0C0D.w		; 0C 0D 0C ; Test and set bits $0C0D.w [Reads: Accumulator] [Flags: Z]
	asl $0FB5.w		; 0E B5 0F ; Arithmetic shift left $0FB5.w [Flags: NCZ]
	.db $10, $0C		; 10 0C ; Branch if plus to $10, $0C [Flow: branch]
	tsb $1211.w		; 0C 11 12 ; Test and set bits $1211.w [Reads: Accumulator] [Flags: Z]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora ($83.b,S),Y		; 13 83 ; OR accumulator (stack relative indirect indexed) ($83.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $6C.b		; 00 6C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $010704.l,X		; FF 04 07 01 ; Subtract with carry (long,X) $010704.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$09.b]		; 07 09 ; OR accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: NCZ]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$09.b		; 09 09 ; Logical OR #$09.b with accumulator [Writes: Accumulator] [Flags: NZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$06.b		; 09 06 ; Logical OR #$06.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	asl $1800.w		; 0E 00 18 ; Arithmetic shift left $1800.w [Flags: NCZ]
	jsl $020601.l		; 22 01 06 02 ; Jump to subroutine long $020601.l [Writes: Stack Pointer] [Flow: call]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $10, $85		; 10 85 ; Branch if plus to $10, $85 [Flow: branch]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $030501.l		; 22 01 05 03 ; Jump to subroutine long $030501.l [Writes: Stack Pointer] [Flow: call]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$18.b]		; 07 18 ; OR accumulator with memory (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$85.b]		; 07 85 ; OR accumulator with memory (long) [$85.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $18.b,S		; 03 18 ; OR accumulator with stack relative $18.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora #$01.b		; 09 01 ; Logical OR #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	and [$10.b],Y		; 37 10 ; AND accumulator with memory (long indexed) [$10.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $18.b		; 06 18 ; Arithmetic shift left $18.b [Reads: Direct Page] [Flags: NCZ]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $18.b,X		; 15 18 ; OR accumulator with memory $18.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: NCZ]
	ora #$03.b		; 09 03 ; Logical OR #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $031718.l		; 22 18 17 03 ; Jump to subroutine long $031718.l [Writes: Stack Pointer] [Flow: call]
	ora $09.b		; 05 09 ; Logical OR $09.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $09.b		; 04 09 ; Test and set bits $09.b [Reads: Accumulator] [Flags: Z]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora #$18.b		; 09 18 ; Logical OR #$18.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$00.b		; 09 00 ; Logical OR #$00.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($84.b,X)		; 01 84 ; Logical OR ($84.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $4F.b		; 00 4F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $09.b		; 05 09 ; Logical OR $09.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$05.b		; 09 05 ; Logical OR #$05.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $88.b,X		; 15 88 ; OR accumulator with memory $88.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $7A.b		; 00 7A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0609.w		; 0C 09 06 ; Test and set bits $0609.w [Reads: Accumulator] [Flags: Z]
	ora #$04.b		; 09 04 ; Logical OR #$04.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$09.b		; 09 09 ; Logical OR #$09.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$04.b		; 09 04 ; Logical OR #$04.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $62, $07, $12		; 62 07 12 ; Push effective relative address $62, $07, $12 [Writes: Stack Pointer]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora #$09.b		; 09 09 ; Logical OR #$09.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $08.b		; 05 08 ; Logical OR $08.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$09.b]		; 07 09 ; OR accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $18.b		; 06 18 ; Arithmetic shift left $18.b [Reads: Direct Page] [Flags: NCZ]
	ora $230402.l		; 0F 02 04 23 ; OR accumulator with memory (long) $230402.l [Writes: Accumulator] [Flags: NZ]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora #$07.b		; 09 07 ; Logical OR #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $060E09.l		; 22 09 0E 06 ; Jump to subroutine long $060E09.l [Writes: Stack Pointer] [Flow: call]
	asl $05.b		; 06 05 ; Arithmetic shift left $05.b [Reads: Direct Page] [Flags: NCZ]
	ora [$09.b]		; 07 09 ; OR accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$04.b		; 09 04 ; Logical OR #$04.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	bit $07.b		; 24 07 ; Test bits $07.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora $0A.b,S		; 03 0A ; OR accumulator with stack relative $0A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$0A.b]		; 07 0A ; OR accumulator with memory (long) [$0A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($0A.b,X)		; 01 0A ; Logical OR ($0A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $03010A.l		; 22 0A 01 03 ; Jump to subroutine long $03010A.l [Writes: Stack Pointer] [Flow: call]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsl $000206.l		; 22 06 02 00 ; Jump to subroutine long $000206.l [Writes: Stack Pointer] [Flow: call]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $010100.l		; 22 00 01 01 ; Jump to subroutine long $010100.l [Writes: Stack Pointer] [Flow: call]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc $935204.l,X		; FF 04 52 93 ; Subtract with carry (long,X) $935204.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	stz $B8.b,X		; 74 B8 ; Store zero to $B8.b,X [Reads: X Index]
	sta ($22.b)		; 92 22 ; Store accumulator (indirect) ($22.b) [Reads: Direct Page, Accumulator]
	ora $3212.w,X		; 1D 12 32 ; OR accumulator with memory $3212.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$75.b		; C9 75 ; Compare #$75.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	lda $8A773B.l,X		; BF 3B 77 8A ; Load long $8A773B.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $9352.w,X		; 1D 52 93 ; OR accumulator with memory $9352.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	stx $1D.b,Y		; 96 1D ; Store X register $1D.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	ora $BE81.w,X		; 1D 81 BE ; OR accumulator with memory $BE81.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $6275.w		; 0D 75 62 ; Logical OR $6275.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $1D8A05.l,X		; 1F 05 8A 1D ; Logical OR long $1D8A05.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jmp $22C093.l		; 5C 93 C0 22 ; Jump long to $22C093.l [Flow: jump]
	.db $62, $42, $06		; 62 42 06 ; Push effective relative address $62, $42, $06 [Writes: Stack Pointer]
	lda ($AD.b,X)		; A1 AD ; Load accumulator ($AD.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$75.b		; C9 75 ; Compare #$75.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	lda $839E23.l,X		; BF 23 9E 83 ; Load long $839E23.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($B8.b,X)		; 01 B8 ; Logical OR ($B8.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $62.b		; 24 62 ; Test bits $62.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	eor $9A05.w		; 4D 05 9A ; Exclusive OR $9A05.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7523.w,X		; 9D 23 75 ; Store accumulator to $7523.w,X [Reads: Accumulator, X Index]
	and $B6.b		; 25 B6 ; Logical AND $B6.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	ora $C91A.w		; 0D 1A C9 ; Logical OR $C91A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	rol $CB.b		; 26 CB ; Rotate left $CB.b [Reads: Direct Page] [Flags: NCZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	and [$32.b]		; 27 32 ; AND accumulator with memory (long) [$32.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$3B.b		; C9 3B ; Compare #$3B.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	adc $28.b,X		; 75 28 ; Add $28.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $9229.w,X		; 3E 29 92 ; Rotate left $9229.w,X [Reads: X Index] [Flags: NCZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	eor ($93.b)		; 52 93 ; Exclusive OR accumulator with memory (indirect) ($93.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $2B2A.w,X		; 1D 2A 2B ; OR accumulator with memory $2B2A.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta ($1D.b,S),Y		; 93 1D ; Store accumulator (stack relative indirect indexed) ($1D.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	bit $812D.w		; 2C 2D 81 ; Test bits $812D.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	rol $6ABF.w		; 2E BF 6A ; Rotate left $6ABF.w [Flags: NCZ]
	.db $62, $D9, $03		; 62 D9 03 ; Push effective relative address $62, $D9, $03 [Writes: Stack Pointer]
	eor ($93.b)		; 52 93 ; Exclusive OR accumulator with memory (indirect) ($93.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $63DC.w,X		; 1D DC 63 ; OR accumulator with memory $63DC.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $C925E0.l		; 2F E0 25 C9 ; AND accumulator with memory (long) $C925E0.l [Writes: Accumulator] [Flags: NZ]
	sbc $BF75.w,X		; FD 75 BF ; Subtract with carry $BF75.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($A5.b)		; 32 A5 ; AND accumulator with memory (indirect) ($A5.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc [$8A.b],Y		; 77 8A ; Add with carry (long indexed) [$8A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $93.b,S		; E3 93 ; Subtract stack-relative $93.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	dec $33C9.w,X		; DE C9 33 ; Decrement memory $33C9.w,X [Reads: X Index] [Flags: NZ]
	sbc $1D.b		; E5 1D ; Subtract $1D.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and ($C9.b)		; 32 C9 ; AND accumulator with memory (indirect) ($C9.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $34.b		; 02 34 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $77A5E6.l,X		; BF E6 A5 77 ; Load long $77A5E6.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($93.b)		; 52 93 ; Exclusive OR accumulator with memory (indirect) ($93.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $EC35.w,X		; 1D 35 EC ; OR accumulator with memory $EC35.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda $1D.b		; A5 1D ; Load $1D.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $87C9.w		; ED C9 87 ; Subtract $87C9.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	rol $BF.b,X		; 36 BF ; Rotate left $BF.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cmp $841D.w,Y		; D9 1D 84 ; Compare accumulator $841D.w,Y [Reads: Y Index] [Flags: NCZ]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$2C.b		; E0 2C ; Compare #$2C.b with X register [Reads: X Index] [Flags: NCZ]
	.db $F0, $A0		; F0 A0 ; Branch if equal to $F0, $A0 [Flow: branch]
	sbc ($85.b),Y		; F1 85 ; Subtract with carry ($85.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($E5.b)		; F2 E5 ; Subtract with carry (indirect) ($E5.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc $BF.b,X		; 75 BF ; Add $BF.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $F398.w,X		; 1D 98 F3 ; OR accumulator with memory $F398.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($CC.b)		; 52 CC ; Exclusive OR accumulator with memory (indirect) ($CC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pea $1DF2.w		; F4 F2 1D ; Push absolute address $1DF2.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sbc $F6.b,X		; F5 F6 ; Subtract $F6.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $B2.b,S		; A3 B2 ; Load accumulator (stack relative) $B2.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ror $556F.w		; 6E 6F 55 ; Rotate right $556F.w [Flags: NCZ]
	ora $CD8D.w,X		; 1D 8D CD ; OR accumulator with memory $CD8D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dec $1AF7.w		; CE F7 1A ; Decrement $1AF7.w [Flags: NZ]
	and [$9E.b],Y		; 37 9E ; AND accumulator with memory (long indexed) [$9E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc ($C9.b,X)		; 61 C9 ; Add with carry ($C9.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$3B.b],Y		; 17 3B ; OR accumulator with memory (long indexed) [$3B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ror $496F.w		; 6E 6F 49 ; Rotate right $496F.w [Flags: NCZ]
	ora $CDFC.w,X		; 1D FC CD ; OR accumulator with memory $CDFC.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dec $6248.w		; CE 48 62 ; Decrement $6248.w [Flags: NZ]
	sbc $A40F.w,X		; FD 0F A4 ; Subtract with carry $A40F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy $B0.b		; A4 B0 ; Load $B0.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	trb $7598.w		; 1C 98 75 ; Test and reset bits $7598.w [Reads: Accumulator] [Flags: Z]
	eor $F31D1D.l		; 4F 1D 1D F3 ; Exclusive OR accumulator with memory (long) $F31D1D.l [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	cpx #$02.b		; E0 02 ; Compare #$02.b with X register [Reads: X Index] [Flags: NCZ]
	ora $8A.b,S		; 03 8A ; OR accumulator with stack relative $8A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $8B.b,S		; 23 8B ; AND accumulator with stack relative $8B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $6F04.w		; 0D 04 6F ; Logical OR $6F04.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $44.b		; 05 44 ; Logical OR $44.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp [$CD.b]		; C7 CD ; Compare accumulator (long) [$CD.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	and $E6062E.l		; 2F 2E 06 E6 ; AND accumulator with memory (long) $E6062E.l [Writes: Accumulator] [Flags: NZ]
	sbc ($07.b)		; F2 07 ; Subtract with carry (indirect) ($07.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc ($71.b),Y		; 71 71 ; Add with carry ($71.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $62, $08, $17		; 62 08 17 ; Push effective relative address $62, $08, $17 [Writes: Stack Pointer]
	eor #$48.b		; 49 48 ; Exclusive OR #$48.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ror $D2.b		; 66 D2 ; Rotate right $D2.b [Reads: Direct Page] [Flags: NCZ]
	and $0B2E1D.l		; 2F 1D 2E 0B ; AND accumulator with memory (long) $0B2E1D.l [Writes: Accumulator] [Flags: NZ]
	eor ($93.b)		; 52 93 ; Exclusive OR accumulator with memory (indirect) ($93.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpy $38A0.w		; CC A0 38 ; Compare $38A0.w with Y register [Reads: Y Index] [Flags: NCZ]
	sta $9399.w,Y		; 99 99 93 ; Store accumulator to $9399.w,Y [Reads: Y Index, Accumulator]
	ora $A02E.w,X		; 1D 2E A0 ; OR accumulator with memory $A02E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda $1D.b		; A5 1D ; Load $1D.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $2E.b		; A5 2E ; Load $2E.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sbc $230A23.l,X		; FF 23 0A 23 ; Subtract with carry (long,X) $230A23.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $0A.b		; 25 0A ; Logical AND $0A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $18.b,S		; 23 18 ; AND accumulator with stack relative $18.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	.db $10, $23		; 10 23 ; Branch if plus to $10, $23 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora ($0A.b,X)		; 01 0A ; Logical OR ($0A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and $0118.w		; 2D 18 01 ; Logical AND $0118.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $1831.w		; 0D 31 18 ; Logical OR $1831.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $05.b,S		; 23 05 ; AND accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx $20.b		; E4 20 ; Compare $20.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $05.b,S		; 23 05 ; AND accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx $4F.b		; E4 4F ; Compare $4F.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $0118.w		; 2E 18 01 ; Rotate left $0118.w [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and $0118.w		; 2D 18 01 ; Logical AND $0118.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and $FF18.w,X		; 3D 18 FF ; AND accumulator with memory $FF18.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $390310.l		; 22 10 03 39 ; Jump to subroutine long $390310.l [Writes: Stack Pointer] [Flow: call]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $10.b		; 25 10 ; Logical AND $10.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $3B3C.w		; 0D 3C 3B ; Logical OR $3B3C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($12.b),Y		; 11 12 ; OR accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $3E3DFF.l,X		; FF FF 3D 3E ; Subtract with carry (long,X) $3E3DFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $133F.w,X		; 3E 3F 13 ; Rotate left $133F.w,X [Reads: X Index] [Flags: NCZ]
	trb $FF.b		; 14 FF ; Test and reset bits $FF.b [Reads: Accumulator] [Flags: Z]
	cpx $4063.w		; EC 63 40 ; Compare $4063.w with X register [Reads: X Index] [Flags: NCZ]
	cop $11.b		; 02 11 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	mvp $45,$22		; 44 22 45 ; Move block positive $45,$22 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora ($46.b,X)		; 01 46 ; Logical OR ($46.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor $63.b		; 45 63 ; Exclusive OR $63.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor [$00.b]		; 47 00 ; Exclusive OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $62.b		; 45 62 ; Exclusive OR $62.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	ora $11.b,S		; 03 11 ; OR accumulator with stack relative $11.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $4E.b,S		; 03 4E ; OR accumulator with stack relative $4E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $693E25.l		; 4F 25 3E 69 ; Exclusive OR accumulator with memory (long) $693E25.l [Writes: Accumulator] [Flags: NZ]
	.db $50, $02		; 50 02 ; Branch if overflow clear to $50, $02 [Flow: branch]
	sbc $235A14.l,X		; FF 14 5A 23 ; Subtract with carry (long,X) $235A14.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $0A5B65.l,X		; FF 65 5B 0A ; Subtract with carry (long,X) $0A5B65.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($54.b,S),Y		; 53 54 ; XOR accumulator (stack relative indirect indexed) ($54.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc ($62.b,X)		; 61 62 ; Add with carry ($62.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	adc $64.b,S		; 63 64 ; Add with carry (stack relative) $64.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	adc $22.b		; 65 22 ; Add $22.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	rol $3F05.w,X		; 3E 05 3F ; Rotate left $3F05.w,X [Reads: X Index] [Flags: NCZ]
	ror $67.b		; 66 67 ; Rotate right $67.b [Reads: Direct Page] [Flags: NCZ]
	lsr $5853.w		; 4E 53 58 ; Logical shift right $5853.w [Flags: NCZ]
	adc $68.b		; 65 68 ; Add $68.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	brk $53.b		; 00 53 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $6E.b		; 02 6E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $70624E.l		; 6F 4E 62 70 ; Add with carry (long) $70624E.l [Writes: Accumulator] [Flags: NCVZ]
	brk $68.b		; 00 68 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc ($09.b,S),Y		; 73 09 ; Add with carry (stack relative indirect indexed) ($09.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	eor $807F52.l,X		; 5F 52 7F 80 ; Exclusive OR accumulator with memory (long,X) $807F52.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ror $81.b,X		; 76 81 ; Rotate right $81.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	stz $82.b,X		; 74 82 ; Store zero to $82.b,X [Reads: X Index]
	eor $624E.w,Y		; 59 4E 62 ; Exclusive OR accumulator with memory $624E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $01.b,S		; 83 01 ; Store accumulator (stack relative) $01.b,S [Reads: Stack Pointer, Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stx $83.b		; 86 83 ; Store X register to $83.b [Reads: X Index]
	brk $62.b		; 00 62 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $87, $0A		; 62 87 0A ; Push effective relative address $62, $87, $0A [Writes: Stack Pointer]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $5E.b,X		; 55 5E ; Exclusive OR accumulator with memory $5E.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor $8B.b,S		; 43 8B ; Exclusive OR accumulator with stack relative $8B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sty $5360.w		; 8C 60 53 ; Store Y register to $5360.w [Reads: Y Index]
	sta $6553.w		; 8D 53 65 ; Store accumulator to $6553.w [Reads: Accumulator]
	stx $6803.w		; 8E 03 68 ; Store X register to $6803.w [Reads: X Index]
	sty $95.b,X		; 94 95 ; Store Y register $95.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	eor ($62.b,S),Y		; 53 62 ; XOR accumulator (stack relative indirect indexed) ($62.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	stx $00.b,Y		; 96 00 ; Store X register $00.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	and $629966.l,X		; 3F 66 99 62 ; AND accumulator with memory (long,X) $629966.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $A28404.l,X		; 9F 04 84 A2 ; Store accumulator (long,X) $A28404.l,X [Reads: Accumulator, X Index]
	lsr $46.b		; 46 46 ; Logical shift right $46.b [Reads: Direct Page] [Flags: NCZ]
	ora ($63.b),Y		; 11 63 ; OR accumulator with memory ($63.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda $02.b,S		; A3 02 ; Load accumulator (stack relative) $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta [$A7.b],Y		; 97 A7 ; Store accumulator (long indexed) [$A7.b],Y [Reads: Direct Page, Y Index, Accumulator]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	jsl $A90197.l		; 22 97 01 A9 ; Jump to subroutine long $A90197.l [Writes: Stack Pointer] [Flow: call]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	jsl $11033E.l		; 22 3E 03 11 ; Jump to subroutine long $11033E.l [Writes: Stack Pointer] [Flow: call]
	clc		; 18 ; Clear carry flag [Flags: C]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	sty $AB22.w		; 8C 22 AB ; Store Y register to $AB22.w [Reads: Y Index]
	adc $AC.b,S		; 63 AC ; Add with carry (stack relative) $AC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	brk $AF.b		; 00 AF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $B106B0.l		; 22 B0 06 B1 ; Jump to subroutine long $B106B0.l [Writes: Stack Pointer] [Flow: call]
	ora ($12.b),Y		; 11 12 ; OR accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ldx $B2.b		; A6 B2 ; Load $B2.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	lda ($97.b,S),Y		; B3 97 ; Load accumulator (stack relative indirect indexed) ($97.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $B3.b,S		; 63 B3 ; Add with carry (stack relative) $B3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	bit $B7.b		; 24 B7 ; Test bits $B7.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora ($B8.b,X)		; 01 B8 ; Logical OR ($B8.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lsr $62.b,X		; 56 62 ; Logical shift right $62.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	lda $4822.w,Y		; B9 22 48 ; Load $4822.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $BC.b,S		; 63 BC ; Add with carry (stack relative) $BC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	eor $C0.b,S		; 43 C0 ; Exclusive OR accumulator with stack relative $C0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp ($00.b,X)		; C1 00 ; Compare accumulator ($00.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
.ACCU 16
.INDEX 16
	rep #$FF		; C2 FF
	ora $0A.b,S		; 03 0A ; OR accumulator with stack relative $0A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	ora $18.b		; 05 18 ; Logical OR $18.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $2A.b		; 05 2A ; Logical OR $2A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	ora $00182A.l		; 0F 2A 18 00 ; OR accumulator with memory (long) $00182A.l [Writes: Accumulator] [Flags: NZ]
	ora ($2E.b,X)		; 01 2E ; Logical OR ($2E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $0018.w		; 2E 18 00 ; Rotate left $0018.w [Flags: NCZ]
	ora ($2E.b,X)		; 01 2E ; Logical OR ($2E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $0518.w		; 2E 18 05 ; Rotate left $0518.w [Flags: NCZ]
	ora ($18.b,X)		; 01 18 ; Logical OR ($18.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $0519.w,Y		; 19 19 05 ; OR accumulator with memory $0519.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	and #$0419.w		; 29 19 04 ; Logical AND #$0419.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($0A.b,X)		; 01 0A ; Logical OR ($0A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $0519.w,Y		; 19 19 05 ; OR accumulator with memory $0519.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $0100.w,Y		; 19 00 01 ; OR accumulator with memory $0100.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $050218.l		; 22 18 02 05 ; Jump to subroutine long $050218.l [Writes: Stack Pointer] [Flow: call]
	ora $2219.w,Y		; 19 19 22 ; OR accumulator with memory $2219.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora ($19.b,X)		; 01 19 ; Logical OR ($19.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $19.b,S		; 23 19 ; AND accumulator with stack relative $19.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $050218.l		; 22 18 02 05 ; Jump to subroutine long $050218.l [Writes: Stack Pointer] [Flow: call]
	ora $2219.w,Y		; 19 19 22 ; OR accumulator with memory $2219.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $19.b		; 25 19 ; Logical AND $19.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $192418.l		; 22 18 24 19 ; Jump to subroutine long $192418.l [Writes: Stack Pointer] [Flow: call]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $19.b		; 24 19 ; Test bits $19.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ror $1801.w		; 6E 01 18 ; Rotate right $1801.w [Flags: NCZ]
	ora $22.b		; 05 22 ; Logical OR $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0501.w,Y		; 19 01 05 ; OR accumulator with memory $0501.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $19.b		; 25 19 ; Logical AND $19.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $23.b		; 05 23 ; Logical OR $23.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0083.w,Y		; 19 83 00 ; OR accumulator with memory $0083.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lda [$01.b]		; A7 01 ; Load accumulator (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	eor $18.b,S		; 43 18 ; Exclusive OR accumulator with stack relative $18.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0103.w,Y		; 19 03 01 ; OR accumulator with memory $0103.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $2418.w,Y		; 19 18 24 ; OR accumulator with memory $2418.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $1802.w,Y		; 19 02 18 ; OR accumulator with memory $1802.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $22.b		; 05 22 ; Logical OR $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	tsb $19.b		; 04 19 ; Test and set bits $19.b [Reads: Accumulator] [Flags: Z]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	dec $02.b,X		; D6 02 ; Decrement memory $02.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $0A.b,S		; 23 0A ; AND accumulator with stack relative $0A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($19.b,X)		; 01 19 ; Logical OR ($19.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $10.b		; 04 10 ; Test and set bits $10.b [Reads: Accumulator] [Flags: Z]
	bit $103B.w,X		; 3C 3B 10 ; Test bits $103B.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	and $C362.w,Y		; 39 62 C3 ; AND accumulator with memory $C362.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and $B7.b		; 25 B7 ; Logical AND $B7.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $C6.b		; 05 C6 ; Logical OR $C6.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc ($FF.b),Y		; 71 FF ; Add with carry ($FF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr $FF53.w		; 4E 53 FF ; Logical shift right $FF53.w [Flags: NCZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cmp [$03.b]		; C7 03 ; Compare accumulator (long) [$03.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	adc ($FF.b),Y		; 71 FF ; Add with carry ($FF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp ($D3.b)		; D2 D3 ; Compare accumulator (indirect) ($D3.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ora ($67.b,S),Y		; 13 67 ; OR accumulator (stack relative indirect indexed) ($67.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	pei ($07.b)		; D4 07 ; Push effective indirect address ($07.b) [Reads: Direct Page] [Writes: Stack Pointer]
	adc ($47.b),Y		; 71 47 ; Add with carry ($47.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp.w [$AB8C]		; DC 8C AB ; Jump long indirect [$AB8C] [Flow: jump]
	cmp $C9DE.w,X		; DD DE C9 ; Compare accumulator $C9DE.w,X [Reads: X Index] [Flags: NCZ]
	adc [$DF.b]		; 67 DF ; Add with carry (long) [$DF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cop $71.b		; 02 71 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($E7.b)		; 52 E7 ; Exclusive OR accumulator with memory (indirect) ($E7.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $E80197.l		; 22 97 01 E8 ; Jump to subroutine long $E80197.l [Writes: Stack Pointer] [Flow: call]
	cmp #$E967.w		; C9 67 E9 ; Compare #$E967.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	adc ($4E.b),Y		; 71 4E ; Add with carry ($4E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $F1		; 70 F1 ; Branch if overflow set to $70, $F1 [Flow: branch]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	eor $F2.b		; 45 F2 ; Exclusive OR $F2.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$65E9.w		; C9 E9 65 ; Compare #$65E9.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	sbc ($08.b,S),Y		; F3 08 ; Subtract with carry (stack relative indirect indexed) ($08.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $71		; F0 71 ; Branch if equal to $F0, $71 [Flow: branch]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	sbc $51FA.w,Y		; F9 FA 51 ; Subtract with carry $51FA.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	jsr ($AB22.w,X)		; FC 22 AB ; Jump to subroutine indirect indexed ($AB22.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	tsb $FEFD.w		; 0C FD FE ; Test and set bits $FEFD.w [Reads: Accumulator] [Flags: Z]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	sbc $00A671.l,X		; FF 71 A6 00 ; Subtract with carry (long,X) $00A671.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp [$02.b]		; C7 02 ; Compare accumulator (long) [$02.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $0B.b		; 04 0B ; Test and set bits $0B.b [Reads: Accumulator] [Flags: Z]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	ora [$71.b]		; 07 71 ; OR accumulator with memory (long) [$71.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $FF0908.l,X		; 9F 08 09 FF ; Store accumulator (long,X) $FF0908.l,X [Reads: Accumulator, X Index]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	eor [$0C.b]		; 47 0C ; Exclusive OR accumulator with memory (long) [$0C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0E0C.w		; 0D 0C 0E ; Logical OR $0E0C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	adc ($AB.b),Y		; 71 AB ; Add with carry ($AB.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $FFDE.w,X		; DD DE FF ; Compare accumulator $FFDE.w,X [Reads: X Index] [Flags: NCZ]
	ora $ABAB10.l		; 0F 10 AB AB ; OR accumulator with memory (long) $ABAB10.l [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	ora ($48.b),Y		; 11 48 ; OR accumulator with memory ($48.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $12.b,S		; 63 12 ; Add with carry (stack relative) $12.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora #$9771.w		; 09 71 97 ; Logical OR #$9771.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta [$E8.b],Y		; 97 E8 ; Store accumulator (long indexed) [$E8.b],Y [Reads: Direct Page, Y Index, Accumulator]
	sbc $971716.l,X		; FF 16 17 97 ; Subtract with carry (long,X) $971716.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta [$84.b],Y		; 97 84 ; Store accumulator (long indexed) [$84.b],Y [Reads: Direct Page, Y Index, Accumulator]
	adc $18.b		; 65 18 ; Add $18.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $71.b,S		; 03 71 ; OR accumulator with stack relative $71.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $45.b		; 45 45 ; Exclusive OR $45.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc ($64.b)		; F2 64 ; Subtract with carry (indirect) ($64.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	asl $4E00.w,X		; 1E 00 4E ; Arithmetic shift left $4E00.w,X [Reads: X Index] [Flags: NCZ]
	stz $23.b		; 64 23 ; Store zero to $23.b
	ora $F0.b		; 05 F0 ; Logical OR $F0.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc ($3E.b),Y		; 71 3E ; Add with carry ($3E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sbc $012962.l,X		; FF 62 29 01 ; Subtract with carry (long,X) $012962.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $2C634E.l,X		; FF 4E 63 2C ; Subtract with carry (long,X) $2C634E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $22.b,X		; 15 22 ; OR accumulator with memory $22.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $71		; 30 71 ; Branch if minus to $30, $71 [Flow: branch]
	sbc $31100F.l,X		; FF 0F 10 31 ; Subtract with carry (long,X) $31100F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($AB.b)		; 32 AB ; AND accumulator with memory (indirect) ($AB.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy $3332.w		; AC 32 33 ; Load $3332.w into Y register [Writes: Y Index] [Flags: NZ]
	adc [$9F.b]		; 67 9F ; Add with carry (long) [$9F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	.db $10, $AB		; 10 AB ; Branch if plus to $10, $AB [Flow: branch]
	bit $71.b,X		; 34 71 ; Test bits $71.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	trb $16.b		; 14 16 ; Test and reset bits $16.b [Reads: Accumulator] [Flags: Z]
	sta [$62.b],Y		; 97 62 ; Store accumulator (long indexed) [$62.b],Y [Reads: Direct Page, Y Index, Accumulator]
	and $14.b,X		; 35 14 ; Logical AND $14.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $36.b,X		; 35 36 ; Logical AND $36.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sta [$A9.b],Y		; 97 A9 ; Store accumulator (long indexed) [$A9.b],Y [Reads: Direct Page, Y Index, Accumulator]
	sbc $9797A6.l,X		; FF A6 97 97 ; Subtract with carry (long,X) $9797A6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sec		; 38 ; Set carry flag [Flags: C]
	adc ($FF.b),Y		; 71 FF ; Add with carry ($FF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $14		; F0 14 ; Branch if equal to $F0, $14 [Flow: branch]
	cmp [$2F.b]		; C7 2F ; Compare accumulator (long) [$2F.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	and $C8C7.w,Y		; 39 C7 C8 ; AND accumulator with memory $C8C7.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $229F09.l,X		; FF 09 9F 22 ; Subtract with carry (long,X) $229F09.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $01		; F0 01 ; Branch if equal to $F0, $01 [Flow: branch]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	adc ($FF.b),Y		; 71 FF ; Add with carry ($FF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora #$0100.w		; 09 00 01 ; Logical OR #$0100.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $08.b		; 06 08 ; Arithmetic shift left $08.b [Reads: Direct Page] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$07.b],Y		; 17 07 ; OR accumulator with memory (long indexed) [$07.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $0B.b		; 25 0B ; Logical AND $0B.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0B.b],Y		; 17 0B ; OR accumulator with memory (long indexed) [$0B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr $0B.b		; 46 0B ; Logical shift right $0B.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$07.b],Y		; 17 07 ; OR accumulator with memory (long indexed) [$07.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsl $0B0119.l		; 22 19 01 0B ; Jump to subroutine long $0B0119.l [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	stx $00.b		; 86 00 ; Store X register to $00.b [Reads: X Index]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $070B.w,Y		; 19 0B 07 ; OR accumulator with memory $070B.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	bit $19.b		; 24 19 ; Test bits $19.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	.db $10, $05		; 10 05 ; Branch if plus to $10, $05 [Flow: branch]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tsb $0B.b		; 04 0B ; Test and set bits $0B.b [Reads: Accumulator] [Flags: Z]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $19.b,S		; 23 19 ; AND accumulator with stack relative $19.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	jsr $0083.w		; 20 83 00 ; Jump to subroutine at $0083.w [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsl $170019.l		; 22 19 00 17 ; Jump to subroutine long $170019.l [Writes: Stack Pointer] [Flow: call]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	and $010827.l		; 2F 27 08 01 ; AND accumulator with memory (long) $010827.l [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$83.b],Y		; 17 83 ; OR accumulator with memory (long indexed) [$83.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $1D.b		; 00 1D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $0B.b		; 25 0B ; Logical AND $0B.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $07.b		; 24 07 ; Test bits $07.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora $08.b,S		; 03 08 ; OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($25.b,X)		; 01 25 ; Logical OR ($25.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	jsl L000307.l		; 22 07 83 00 ; Jump to subroutine long L000307.l [Writes: Stack Pointer] [Flow: call]
	and $030B25.l		; 2F 25 0B 03 ; AND accumulator with memory (long) $030B25.l [Writes: Accumulator] [Flags: NZ]
	ora $0B.b		; 05 0B ; Logical OR $0B.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$22.b],Y		; 17 22 ; OR accumulator with memory (long indexed) [$22.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $84.b		; 04 84 ; Test and set bits $84.b [Reads: Accumulator] [Flags: Z]
	brk $4D.b		; 00 4D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $0708.w,Y		; 19 08 07 ; OR accumulator with memory $0708.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$19.b],Y		; 17 19 ; OR accumulator with memory (long indexed) [$19.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $000B.w,Y		; 19 0B 00 ; OR accumulator with memory $000B.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0B22.w,Y		; 19 22 0B ; OR accumulator with memory $0B22.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	jsl $080217.l		; 22 17 02 08 ; Jump to subroutine long $080217.l [Writes: Stack Pointer] [Flow: call]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	jsl $080019.l		; 22 19 00 08 ; Jump to subroutine long $080019.l [Writes: Stack Pointer] [Flow: call]
	eor $08.b,S		; 43 08 ; Exclusive OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	jsl $000A17.l		; 22 17 0A 00 ; Jump to subroutine long $000A17.l [Writes: Stack Pointer] [Flow: call]
	ora ($17.b,X)		; 01 17 ; Logical OR ($17.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora ($0B.b,X)		; 01 0B ; Logical OR ($0B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($2C.b,X)		; 01 2C ; Logical OR ($2C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $050B.w		; 2D 0B 05 ; Logical AND $050B.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	pea $09FF.w		; F4 FF 09 ; Push absolute address $09FF.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	asl $10.b		; 06 10 ; Arithmetic shift left $10.b [Reads: Direct Page] [Flags: NCZ]
	and $0B030B.l		; 2F 0B 03 0B ; AND accumulator with memory (long) $0B030B.l [Writes: Accumulator] [Flags: NZ]
	eor [$1F.b]		; 47 1F ; Exclusive OR accumulator with memory (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $1B.b		; 04 1B ; Test and set bits $1B.b [Reads: Accumulator] [Flags: Z]
	and $05.b,S		; 23 05 ; AND accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($06.b,S),Y		; 13 06 ; OR accumulator (stack relative indirect indexed) ($06.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $02.b		; 06 02 ; Arithmetic shift left $02.b [Reads: Direct Page] [Flags: NCZ]
	adc ($26.b),Y		; 71 26 ; Add with carry ($26.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor [$25.b]		; 47 25 ; Exclusive OR accumulator with memory (long) [$25.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	adc $096908.l,X		; 7F 08 69 09 ; Add long $096908.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $0A		; 80 0A ; Branch always to $80, $0A [Flow: branch]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora #$0085.w		; 09 85 00 ; Logical OR #$0085.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $EE.b		; 14 EE ; Test and reset bits $EE.b [Reads: Accumulator] [Flags: Z]
	and $3B62.w		; 2D 62 3B ; Logical AND $3B62.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($0E.b,X)		; 01 0E ; Logical OR ($0E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $10, $84		; 10 84 ; Branch if plus to $10, $84 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $12.b		; 05 12 ; Logical OR $12.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor [$3E.b]		; 47 3E ; Exclusive OR accumulator with memory (long) [$3E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $EE.b		; 04 EE ; Test and set bits $EE.b [Reads: Accumulator] [Flags: Z]
	and $3F64.w		; 2D 64 3F ; Logical AND $3F64.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	.db $10, $06		; 10 06 ; Branch if plus to $10, $06 [Flow: branch]
	trb $15.b		; 14 15 ; Test and reset bits $15.b [Reads: Accumulator] [Flags: Z]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $17.b,X		; 16 17 ; Arithmetic shift left $17.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	inc $632D.w		; EE 2D 63 ; Increment $632D.w [Flags: NZ]
	mvp $14,$00		; 44 00 14 ; Move block positive $14,$00 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	jsr $1D06.w		; 20 06 1D ; Jump to subroutine at $1D06.w [Writes: Stack Pointer] [Flow: call]
	asl $1F12.w,X		; 1E 12 1F ; Arithmetic shift left $1F12.w,X [Reads: X Index] [Flags: NCZ]
	jsr $2D60.w		; 20 60 2D ; Jump to subroutine at $2D60.w [Writes: Stack Pointer] [Flow: call]
	.db $62, $48, $00		; 62 48 00 ; Push effective relative address $62, $48, $00 [Writes: Stack Pointer]
	jsr $0084.w		; 20 84 00 ; Jump to subroutine at $0084.w [Writes: Stack Pointer] [Flow: call]
	and $083762.l		; 2F 62 37 08 ; AND accumulator with memory (long) $083762.l [Writes: Accumulator] [Flags: NZ]
	and [$38.b],Y		; 37 38 ; AND accumulator with memory (long indexed) [$38.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	eor $25.b		; 45 25 ; Exclusive OR $25.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($26.b)		; 12 26 ; OR accumulator with memory (indirect) ($26.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $8327.w,X		; 9D 27 83 ; Store accumulator to $8327.w,X [Reads: Accumulator, X Index]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $29.b		; 24 29 ; Test bits $29.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	bit $E8.b		; 24 E8 ; Test bits $E8.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora $3F.b		; 05 3F ; Logical OR $3F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora #$2A2F.w		; 09 2F 2A ; Logical OR #$2A2F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	jsl $2D032C.l		; 22 2C 03 2D ; Jump to subroutine long $2D032C.l [Writes: Stack Pointer] [Flow: call]
	.db $F0, $2E		; F0 2E ; Branch if equal to $F0, $2E [Flow: branch]
	rol $F022.w		; 2E 22 F0 ; Rotate left $F022.w [Flags: NCZ]
	tsb $2C.b		; 04 2C ; Test and set bits $2C.b [Reads: Accumulator] [Flags: Z]
	asl $10.b		; 06 10 ; Arithmetic shift left $10.b [Reads: Direct Page] [Flags: NCZ]
	and $30232F.l		; 2F 2F 23 30 ; AND accumulator with memory (long) $30232F.l [Writes: Accumulator] [Flags: NZ]
	tsb $31.b		; 04 31 ; Test and set bits $31.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and ($33.b)		; 32 33 ; AND accumulator with memory (indirect) ($33.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	.db $62, $34, $14		; 62 34 14 ; Push effective relative address $62, $34, $14 [Writes: Stack Pointer]
	cop $71.b		; 02 71 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	jmp $1F20.w		; 4C 20 1F ; Jump to $1F20.w [Flow: jump]
	ora $740B3E.l,X		; 1F 3E 0B 74 ; Logical OR long $740B3E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $4D.b		; 25 4D ; Logical AND $4D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr $0B1C.w		; 4E 1C 0B ; Logical shift right $0B1C.w [Flags: NCZ]
	ora #$404F.w		; 09 4F 40 ; Logical OR #$404F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $50, $62		; 50 62 ; Branch if overflow clear to $50, $62 [Flow: branch]
	eor ($09.b,X)		; 41 09 ; Exclusive OR accumulator with memory ($09.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	stz $44.b,X		; 74 44 ; Store zero to $44.b,X [Reads: X Index]
	eor $26.b		; 45 26 ; Exclusive OR $26.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $20.b		; 25 20 ; Logical AND $20.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $B0		; 10 B0 ; Branch if plus to $10, $B0 [Flow: branch]
	asl $5162.w		; 0E 62 51 ; Arithmetic shift left $5162.w [Flags: NCZ]
	ora ($C5.b,S),Y		; 13 C5 ; OR accumulator (stack relative indirect indexed) ($C5.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor ($4B.b,S),Y		; 53 4B ; XOR accumulator (stack relative indirect indexed) ($4B.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	jmp $120B.w		; 4C 0B 12 ; Jump to $120B.w [Flow: jump]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $4B145A.l,X		; 1F 5A 14 4B ; Logical OR long $4B145A.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	eor $424E.w		; 4D 4E 42 ; Exclusive OR $424E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	eor $2A62DB.l		; 4F DB 62 2A ; Exclusive OR accumulator with memory (long) $2A62DB.l [Writes: Accumulator] [Flags: NZ]
	bit $50.b		; 24 50 ; Test bits $50.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ror $51.b		; 66 51 ; Rotate right $51.b [Reads: Direct Page] [Flags: NCZ]
	brk $A1.b		; 00 A1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $58.b		; 65 58 ; Add $58.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $62, $5B, $01		; 62 5B 01 ; Push effective relative address $62, $5B, $01 [Writes: Stack Pointer]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	mvn $5E,$62		; 54 62 5E ; Move block negative $5E,$62 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $3D.b		; 05 3D ; Logical OR $3D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda [$53.b]		; A7 53 ; Load accumulator (long) [$53.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $53A7.w,X		; 3D A7 53 ; AND accumulator with memory $53A7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	pea $27FF.w		; F4 FF 27 ; Push absolute address $27FF.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	and $07.b,S		; 23 07 ; AND accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0B.b		; 05 0B ; Logical OR $0B.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	and $08.b,S		; 23 08 ; AND accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($0B.b,X)		; 01 0B ; Logical OR ($0B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	and $19.b,S		; 23 19 ; AND accumulator with stack relative $19.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	tsb $0801.w		; 0C 01 08 ; Test and set bits $0801.w [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $19.b,S		; 23 19 ; AND accumulator with stack relative $19.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsl $0D0019.l		; 22 19 00 0D ; Jump to subroutine long $0D0019.l [Writes: Stack Pointer] [Flow: call]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	trb $1700.w		; 1C 00 17 ; Test and reset bits $1700.w [Reads: Accumulator] [Flags: Z]
	and $19.b,S		; 23 19 ; AND accumulator with stack relative $19.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $1616.w,Y		; 19 16 16 ; OR accumulator with memory $1616.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	stx $00.b		; 86 00 ; Store X register to $00.b [Reads: X Index]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	and $19.b,S		; 23 19 ; AND accumulator with stack relative $19.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $08.b		; 05 08 ; Logical OR $08.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $1912.w,Y		; 19 12 19 ; OR accumulator with memory $1912.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $0B22.w,Y		; 19 22 0B ; OR accumulator with memory $0B22.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	ora $09.b,X		; 15 09 ; OR accumulator with memory $09.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0B.b],Y		; 17 0B ; OR accumulator with memory (long indexed) [$0B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $85.b,S		; 03 85 ; OR accumulator with stack relative $85.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $4F.b		; 00 4F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $0B.b,S		; 23 0B ; AND accumulator with stack relative $0B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $008419.l		; 22 19 84 00 ; Jump to subroutine long $008419.l [Writes: Stack Pointer] [Flow: call]
	jmp $030B2B.l		; 5C 2B 0B 03 ; Jump long to $030B2B.l [Flow: jump]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$0B.b]		; 07 0B ; OR accumulator with memory (long) [$0B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	bit $19.b		; 24 19 ; Test bits $19.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $1906.w,Y		; 19 06 19 ; OR accumulator with memory $1906.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	cop $0B.b		; 02 0B ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and [$19.b]		; 27 19 ; AND accumulator with memory (long) [$19.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	bit #$0822.w		; 89 22 08 ; Test bits #$0822.w with accumulator [Reads: Accumulator] [Flags: Z]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $19.b		; 25 19 ; Logical AND $19.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $0B0108.l		; 22 08 01 0B ; Jump to subroutine long $0B0108.l [Writes: Stack Pointer] [Flow: call]
	ora ($25.b,X)		; 01 25 ; Logical OR ($25.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $0845.w,Y		; 19 45 08 ; OR accumulator with memory $0845.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $0B.b,S		; 03 0B ; OR accumulator with stack relative $0B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$25.b],Y		; 17 25 ; OR accumulator with memory (long indexed) [$25.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $0806.w,Y		; 19 06 08 ; OR accumulator with memory $0806.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $0B.b,S		; 23 0B ; AND accumulator with stack relative $0B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $0B27.w,Y		; 19 27 0B ; OR accumulator with memory $0B27.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $070B.w		; 2D 0B 07 ; Logical AND $070B.w with accumulator [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	.db $F0, $01		; F0 01 ; Branch if equal to $F0, $01 [Flow: branch]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	sbc $0607FF.l		; EF FF 07 06 ; Subtract with carry (long) $0607FF.l [Writes: Accumulator] [Flags: NCVZ]
	asl $61.b		; 06 61 ; Arithmetic shift left $61.b [Reads: Direct Page] [Flags: NCZ]
	.db $62, $06, $06		; 62 06 06 ; Push effective relative address $62, $06, $06 [Writes: Stack Pointer]
	adc ($63.b,X)		; 61 63 ; Add with carry ($63.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $EA.b,S		; 23 EA ; AND accumulator with stack relative $EA.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $64.b		; 05 64 ; Logical OR $64.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	adc ($C9.b,X)		; 61 C9 ; Add with carry ($C9.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $66.b		; 65 66 ; Add $66.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and $80.b,S		; 23 80 ; AND accumulator with stack relative $80.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $67.b		; 02 67 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	mvn $55,$22		; 54 22 55 ; Move block negative $55,$22 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $6B.b		; 05 6B ; Logical OR $6B.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	adc ($C9.b,X)		; 61 C9 ; Add with carry ($C9.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	sta $015663.l		; 8F 63 56 01 ; Store accumulator (long) $015663.l [Reads: Accumulator]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $62, $5A, $01		; 62 5A 01 ; Push effective relative address $62, $5A, $01 [Writes: Stack Pointer]
	cmp $8375.w,X		; DD 75 83 ; Compare accumulator $8375.w,X [Reads: X Index] [Flags: NCZ]
	brk $1D.b		; 00 1D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and $5E5D.w,X		; 3D 5D 5E ; AND accumulator with memory $5E5D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	eor $602A9A.l,X		; 5F 9A 2A 60 ; Exclusive OR accumulator with memory (long,X) $602A9A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldy $C0AD.w		; AC AD C0 ; Load $C0AD.w into Y register [Writes: Y Index] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	bit $6163.w		; 2C 63 61 ; Test bits $6163.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	ora $652A9A.l,X		; 1F 9A 2A 65 ; Logical OR long $652A9A.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($66.b,S),Y		; 33 66 ; AND accumulator (stack relative indirect indexed) ($66.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc [$75.b]		; 67 75 ; Add with carry (long) [$75.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta [$88.b]		; 87 88 ; Store accumulator (long) [$88.b] [Reads: Direct Page, Accumulator]
	cmp #$891B.w		; C9 1B 89 ; Compare #$891B.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	adc #$8C8B.w		; 69 8B 8C ; Add #$8C8B.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr $8D0B.w		; 20 0B 8D ; Jump to subroutine at $8D0B.w [Writes: Stack Pointer] [Flow: call]
	sta $1BC932.l		; 8F 32 C9 1B ; Store accumulator (long) $1BC932.l [Reads: Accumulator]
	stx $6A20.w		; 8E 20 6A ; Store X register to $6A20.w [Reads: X Index]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $9162.w,X		; 1D 62 91 ; OR accumulator with memory $9162.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $6C, $00		; 62 6C 00 ; Push effective relative address $62, $6C, $00 [Writes: Stack Pointer]
	sta $83.b,X		; 95 83 ; Store accumulator to $83.b,X [Reads: Accumulator, X Index]
	brk $5D.b		; 00 5D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $96.b		; 04 96 ; Test and set bits $96.b [Reads: Accumulator] [Flags: Z]
	and #$9897.w		; 29 97 98 ; Logical AND #$9897.w with accumulator [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	jsl $990729.l		; 22 29 07 99 ; Jump to subroutine long $990729.l [Writes: Stack Pointer] [Flow: call]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	sta $1B9C40.l		; [PATTERN: Memory clearing operation] 8F 40 9C 1B ; Store accumulator (long) $1B9C40.l [Reads: Accumulator]
	stz $6F.b		; 64 6F ; Store zero to $6F.b
	asl $F0A2.w		; 0E A2 F0 ; Arithmetic shift left $F0A2.w [Flags: NCZ]
	.db $F0, $A3		; F0 A3 ; Branch if equal to $F0, $A3 [Flow: branch]
	stz $5E.b,X		; 74 5E ; Store zero to $5E.b,X [Reads: X Index]
	adc $A6.b,X		; 75 A6 ; Add $A6.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $A7		; 30 A7 ; Branch if minus to $30, $A7 [Flow: branch]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ror $77.b,X		; 76 77 ; Rotate right $77.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	and $78635E.l,X		; 3F 5E 63 78 ; AND accumulator with memory (long,X) $78635E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	lda $657C.w		; AD 7C 65 ; Load $657C.w into accumulator [Writes: Accumulator] [Flags: NZ]
	adc $12B0.w,X		; 7D B0 12 ; Add $12B0.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($1B.b)		; 12 1B ; OR accumulator with memory (indirect) ($1B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda ($7E.b),Y		; B1 7E ; Load accumulator ($7E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $806240.l,X		; 7F 40 62 80 ; Add long $806240.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	sta $6F.b,S		; 83 6F ; Store accumulator (stack relative) $6F.b,S [Reads: Stack Pointer, Accumulator]
	sty $B5.b		; 84 B5 ; Store Y register to $B5.b [Reads: Y Index]
	adc #$1B69.w		; 69 69 1B ; Add #$1B69.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	lda ($37.b),Y		; B1 37 ; Load accumulator ($37.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $44, $62		; 62 44 62 ; Push effective relative address $62, $44, $62 [Writes: Stack Pointer]
	sta $0B.b		; 85 0B ; Store accumulator to $0B.b [Reads: Accumulator]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	.db $B0, $12		; B0 12 ; Branch if carry set to $B0, $12 [Flow: branch]
	lda [$8F.b],Y		; B7 8F ; Load accumulator (long indexed) [$8F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	lda $B11B.w,Y		; B9 1B B1 ; Load $B11B.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and $48.b		; 25 48 ; Logical AND $48.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor #$8863.w		; 49 63 88 ; Exclusive OR #$8863.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $69B58D.l		; 0F 8D B5 69 ; OR accumulator with memory (long) $69B58D.l [Writes: Accumulator] [Flags: NZ]
	adc #$C5BA.w		; 69 BA C5 ; Add #$C5BA.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	eor ($BB.b,S),Y		; 53 BB ; XOR accumulator (stack relative indirect indexed) ($BB.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldy $5150.w,X		; BC 50 51 ; Load Y register $5150.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $5050.w		; 8C 50 50 ; Store Y register to $5050.w [Reads: Y Index]
	stz $BE.b		; 64 BE ; Store zero to $BE.b
	ora $4F.b,S		; 03 4F ; OR accumulator with stack relative $4F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	jmp $5B625D.l		; 5C 5D 62 5B ; Jump long to $5B625D.l [Flow: jump]
	brk $5B.b		; 00 5B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	cpx #$C363.w		; E0 63 C3 ; Compare #$C363.w with X register [Reads: X Index] [Flags: NCZ]
	ora [$A1.b]		; 07 A1 ; OR accumulator with memory (long) [$A1.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	and $53A7.w,X		; 3D A7 53 ; AND accumulator with memory $53A7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $53A7.w,X		; 3D A7 53 ; AND accumulator with memory $53A7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	.db $F0, $05		; F0 05 ; Branch if equal to $F0, $05 [Flow: branch]
	rol $C74F.w,X		; 3E 4F C7 ; Rotate left $C74F.w,X [Reads: X Index] [Flags: NCZ]
	and $53A7.w,X		; 3D A7 53 ; AND accumulator with memory $53A7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $64FFFF.l,X		; FF FF FF 64 ; Subtract with carry (long,X) $64FFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $30C2.w,X		; 1D C2 30 ; OR accumulator with memory $30C2.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldx #$19C6.w		; A2 C6 19 ; Load #$19C6.w into X register [Writes: X Index] [Flags: NZ]
	lda $8A.b		; A5 8A ; Load $8A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$0080.w		; C9 80 00 ; Compare #$0080.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $0B		; D0 0B ; Branch if not equal to $D0, $0B [Flow: branch]
	lda $A0.b		; A5 A0 ; Load $A0.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$0181.w		; C9 81 01 ; Compare #$0181.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $30		; D0 30 ; Branch if not equal to $D0, $30 [Flow: branch]
	inc $1D.b		; E6 1D ; Increment $1D.b [Reads: Direct Page] [Flags: NZ]
	.db $80, $1F		; 80 1F ; Branch always to $80, $1F [Flow: branch]
	cmp #$0081.w		; C9 81 00 ; Compare #$0081.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $27		; F0 27 ; Branch if equal to $F0, $27 [Flow: branch]
	ldx #$0000.w		; A2 00 00 ; Load #$0000.w into X register [Writes: X Index] [Flags: NZ]
	cmp #$005B.w		; C9 5B 00 ; Compare #$005B.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $1F		; F0 1F ; Branch if equal to $F0, $1F [Flow: branch]
	and #$00BF.w		; 29 BF 00 ; Logical AND #$00BF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$0003.w		; C9 03 00 ; Compare #$0003.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $17		; F0 17 ; Branch if equal to $F0, $17 [Flow: branch]
	cmp #$0005.w		; C9 05 00 ; Compare #$0005.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $12		; F0 12 ; Branch if equal to $F0, $12 [Flow: branch]
	cmp #$0007.w		; C9 07 00 ; Compare #$0007.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $0D		; F0 0D ; Branch if equal to $F0, $0D [Flow: branch]
	ldx #$2669.w		; A2 69 26 ; Load #$2669.w into X register [Writes: X Index] [Flags: NZ]
	lda $8A.b		; A5 8A ; Load $8A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$0040.w		; 29 40 00 ; Logical AND #$0040.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	ldx #$2A32.w		; A2 32 2A ; Load #$2A32.w into X register [Writes: X Index] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $7EC500.l		; 8F 00 C5 7E ; Store accumulator (long) $7EC500.l [Reads: Accumulator]
	sta $7EC300.l		; 8F 00 C3 7E ; Store accumulator (long) $7EC300.l [Reads: Accumulator]
	sta $7EC540.l		; 8F 40 C5 7E ; Store accumulator (long) $7EC540.l [Reads: Accumulator]
	sta $7EC340.l		; 8F 40 C3 7E ; Store accumulator (long) $7EC340.l [Reads: Accumulator]
	lda #$4020.w		; A9 20 40 ; Load #$4020.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $9C.b		; 85 9C ; Store accumulator to $9C.b [Reads: Accumulator]
	lda #$8040.w		; A9 40 80 ; Load #$8040.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $9D.b		; 85 9D ; Store accumulator to $9D.b [Reads: Accumulator]
	lda $8A.b		; A5 8A ; Load $8A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $40		; F0 40 ; Branch if equal to $F0, $40 [Flow: branch]
	cmp #$0070.w		; C9 70 00 ; Compare #$0070.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	jmp $FF9D.w		; 4C 9D FF ; Jump to $FF9D.w [Flow: jump]
	cmp #$0040.w		; C9 40 00 ; Compare #$0040.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $33		; F0 33 ; Branch if equal to $F0, $33 [Flow: branch]
	cmp #$005B.w		; C9 5B 00 ; Compare #$005B.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $2E		; F0 2E ; Branch if equal to $F0, $2E [Flow: branch]
	ldx #$4C26.w		; A2 26 4C ; Load #$4C26.w into X register [Writes: X Index] [Flags: NZ]
	ldy #$8C4C.w		; A0 4C 8C ; Load #$8C4C.w into Y register [Writes: Y Index] [Flags: NZ]
	cmp #$0003.w		; C9 03 00 ; Compare #$0003.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $1F		; F0 1F ; Branch if equal to $F0, $1F [Flow: branch]
	cmp #$0005.w		; C9 05 00 ; Compare #$0005.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $1A		; F0 1A ; Branch if equal to $F0, $1A [Flow: branch]
	cmp #$0007.w		; C9 07 00 ; Compare #$0007.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $15		; F0 15 ; Branch if equal to $F0, $15 [Flow: branch]
	ldx #$4A26.w		; A2 26 4A ; Load #$4A26.w into X register [Writes: X Index] [Flags: NZ]
	ldy #$874A.w		; A0 4A 87 ; Load #$874A.w into Y register [Writes: Y Index] [Flags: NZ]
	cmp #$0043.w		; C9 43 00 ; Compare #$0043.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $0A		; F0 0A ; Branch if equal to $F0, $0A [Flow: branch]
	cmp #$0045.w		; C9 45 00 ; Compare #$0045.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $05		; F0 05 ; Branch if equal to $F0, $05 [Flow: branch]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	inc $15.b		; E6 15 ; Increment $15.b [Reads: Direct Page] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stx $9C.b		; 86 9C ; Store X register to $9C.b [Reads: X Index]
	sty $9D.b		; 84 9D ; Store Y register to $9D.b [Reads: Y Index]
	lda $11.b		; A5 11 ; Load $11.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$FF.b		; 29 FF ; Logical AND #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $C9.b		; 00 C9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	.db $F0, $58		; F0 58 ; Branch if equal to $F0, $58 [Flow: branch]
	lda $E8.b		; A5 E8 ; Load $E8.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $E6.b		; 85 E6 ; Store accumulator to $E6.b [Reads: Accumulator]
	lda $E2.b		; A5 E2 ; Load $E2.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $E0.b		; 85 E0 ; Store accumulator to $E0.b [Reads: Accumulator]
	lda $8A.b		; A5 8A ; Load $8A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$3F.b		; 29 3F ; Logical AND #$3F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $C9.b		; 00 C9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $E2A5.w		; 6D A5 E2 ; Add $E2A5.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$78.b		; E9 78 ; Subtract #$78.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ora [$4A.b]		; 07 4A ; OR accumulator with memory (long) [$4A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	and #$00.b		; 29 00 ; Logical AND #$00.b with accumulator [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $F0, $05		; F0 05 ; Branch if equal to $F0, $05 [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora #$00.b		; 09 00 ; Logical OR #$00.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $80, $A8		; 80 A8 ; Branch always to $80, $A8 [Flow: branch]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	lda $E2.b		; A5 E2 ; Load $E2.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $00.b		; E5 00 ; Subtract $00.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $E0.b		; 85 E0 ; Store accumulator to $E0.b [Reads: Accumulator]
	lda $E6.b		; A5 E6 ; Load $E6.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$C0.b		; C9 C0 ; Compare #$C0.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	asl $90.b		; 06 90 ; Arithmetic shift left $90.b [Reads: Direct Page] [Flags: NCZ]
	ora [$38.b],Y		; 17 38 ; OR accumulator with memory (long indexed) [$38.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc #$00.b		; E9 00 ; Subtract #$00.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	asl $29.b		; 06 29 ; Arithmetic shift left $29.b [Reads: Direct Page] [Flags: NCZ]
	sbc $80C903.l,X		; FF 03 C9 80 ; Subtract with carry (long,X) $80C903.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($B0.b,X)		; 01 B0 ; Logical OR ($B0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $4A.b		; 06 4A ; Arithmetic shift left $4A.b [Reads: Direct Page] [Flags: NCZ]
	ora #$00.b		; 09 00 ; Logical OR #$00.b with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $80.b		; 06 80 ; Arithmetic shift left $80.b [Reads: Direct Page] [Flags: NCZ]
	asl $C0A9.w		; 0E A9 C0 ; Arithmetic shift left $C0A9.w [Flags: NCZ]
	asl $80.b		; 06 80 ; Arithmetic shift left $80.b [Reads: Direct Page] [Flags: NCZ]
	ora #$A5.b		; 09 A5 ; Logical OR #$A5.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc $29.b		; E6 29 ; Increment $29.b [Reads: Direct Page] [Flags: NZ]
	sbc $094A00.l,X		; FF 00 4A 09 ; Subtract with carry (long,X) $094A00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $E6.b		; 85 E6 ; Store accumulator to $E6.b [Reads: Accumulator]
	.db $80, $27		; 80 27 ; Branch always to $80, $27 [Flow: branch]
	lda $8A.b		; A5 8A ; Load $8A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$3F.b		; 29 3F ; Logical AND #$3F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $C9.b		; 00 C9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $E8A5.w,X		; 1D A5 E8 ; OR accumulator with memory $E8A5.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $E6.b		; 85 E6 ; Store accumulator to $E6.b [Reads: Accumulator]
	lda $E2.b		; A5 E2 ; Load $E2.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $E0.b		; 85 E0 ; Store accumulator to $E0.b [Reads: Accumulator]
	lda $0410.w		; AD 10 04 ; Load $0410.w into accumulator [Writes: Accumulator] [Flags: NZ]
	and #$FF.b		; 29 FF ; Logical AND #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $C9.b		; 00 C9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $A9.b		; 05 A9 ; Logical OR $A9.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sta $E0.b		; 85 E0 ; Store accumulator to $E0.b [Reads: Accumulator]
	lda #$C0.b		; A9 C0 ; Load #$C0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	asl $85.b		; 06 85 ; Arithmetic shift left $85.b [Reads: Direct Page] [Flags: NCZ]
	inc $E2.b		; E6 E2 ; Increment $E2.b [Reads: Direct Page] [Flags: NZ]
	jsr $01A9.w		; 20 A9 01 ; Jump to subroutine at $01A9.w [Writes: Stack Pointer] [Flow: call]
	sta $1D.b		; 85 1D ; Store accumulator to $1D.b [Reads: Accumulator]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	inc $15.b		; E6 15 ; Increment $15.b [Reads: Direct Page] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $02A1C7.l		; 22 C7 A1 02 ; Jump to subroutine long $02A1C7.l [Writes: Stack Pointer] [Flow: call]
	jsl $02B929.l		; 22 29 B9 02 ; Jump to subroutine long $02B929.l [Writes: Stack Pointer] [Flow: call]
	jsl $09C44E.l		; [PATTERN: Memory clearing operation] 22 4E C4 09 ; Jump to subroutine long $09C44E.l [Writes: Stack Pointer] [Flow: call]
	stz $04AA.w		; 9C AA 04 ; Store zero to $04AA.w
	lda #$11.b		; A9 11 ; Load #$11.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $10.b		; 85 10 ; Store accumulator to $10.b [Reads: Accumulator]
	stz $11.b		; 64 11 ; Store zero to $11.b
	stz $14.b		; [PATTERN: Memory clearing operation] 64 14 ; Store zero to $14.b
	stz $0345.w		; 9C 45 03 ; Store zero to $0345.w
	sta $005E.w		; 8D 5E 00 ; Store accumulator to $005E.w [Reads: Accumulator]
	stz $03F3.w		; 9C F3 03 ; Store zero to $03F3.w
	stz $0322.w		; 9C 22 03 ; Store zero to $0322.w
	stz $02E4.w		; [PATTERN: Memory clearing operation] 9C E4 02 ; Store zero to $02E4.w
	stz $0ABD.w		; 9C BD 0A ; Store zero to $0ABD.w
	stz $036B.w		; 9C 6B 03 ; Store zero to $036B.w
	stz $0373.w		; 9C 73 03 ; Store zero to $0373.w
	stz $27.b		; 64 27 ; Store zero to $27.b
	stz $28.b		; [PATTERN: Memory clearing operation] 64 28 ; Store zero to $28.b
	stz $29.b		; 64 29 ; Store zero to $29.b
	stz $24.b		; 64 24 ; Store zero to $24.b
	stz $0351.w		; 9C 51 03 ; Store zero to $0351.w
	stz $0316.w		; 9C 16 03 ; Store zero to $0316.w
	stz $031F.w		; [PATTERN: Memory clearing operation] 9C 1F 03 ; Store zero to $031F.w
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $5D.b		; 85 5D ; Store accumulator to $5D.b [Reads: Accumulator]
	stz $4B.b		; 64 4B ; Store zero to $4B.b
	jsl $09AC6B.l		; 22 6B AC 09 ; Jump to subroutine long $09AC6B.l [Writes: Stack Pointer] [Flow: call]
	jmp $07F1A3.l		; 5C A3 F1 07 ; Jump long to $07F1A3.l [Flow: jump]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $FF		; Opcode FF overrunning bank boundry at 05FFFE. Skipping. ; Subtract with carry (long,X) $FF [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $FF		; Opcode FF overrunning bank boundry at 05FFFF. Skipping. ; Subtract with carry (long,X) $FF [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
.ENDS
