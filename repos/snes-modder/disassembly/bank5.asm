.BANK 5 SLOT 0
.ORG $0000

.SECTION "Bank5" FORCE

	jsr ($0400.w,X)		; FC 00 04 ; Jump to subroutine indirect indexed ($0400.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc $000000.l,X		; FF 00 00 00 ; Subtract with carry (long,X) $000000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$D003.w		; 29 03 D0 ; Logical AND #$D003.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $70, $DA		; 70 DA ; Branch if overflow set to $70, $DA [Flow: branch]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$AA03.w		; 29 03 AA ; Logical AND #$AA03.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lda $058000.l,X		; BF 00 80 05 ; Load long $058000.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $058004.l,X		; BF 04 80 05 ; Load long $058004.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $01.b		; 85 01 ; Store accumulator to $01.b [Reads: Accumulator]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$AA03.w		; 29 03 AA ; Logical AND #$AA03.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lda $058000.l,X		; BF 00 80 05 ; Load long $058000.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	lda $058004.l,X		; BF 04 80 05 ; Load long $058004.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $03.b		; 85 03 ; Store accumulator to $03.b [Reads: Accumulator]
	ldx #$BF1D.w		; A2 1D BF ; Load #$BF1D.w into X register [Writes: X Index] [Flags: NZ]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $CA04F0.l,X		; 7F F0 04 CA ; Add long $CA04F0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $F7		; 10 F7 ; Branch if plus to $10, $F7 [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	lda #$9F12.w		; A9 12 9F ; Load #$9F12.w into accumulator [Writes: Accumulator] [Flags: NZ]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $0FB48D.l,X		; 7F 8D B4 0F ; Add long $0FB48D.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $0D10.w,Y		; B9 10 0D ; Load $0D10.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $00.b		; 65 00 ; Add $00.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $7FF83C.l,X		; 9F 3C F8 7F ; Store accumulator (long,X) $7FF83C.l,X [Reads: Accumulator, X Index]
	lda $0D30.w,Y		; B9 30 0D ; Load $0D30.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $01.b		; 65 01 ; Add $01.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $7FF878.l,X		; 9F 78 F8 7F ; Store accumulator (long,X) $7FF878.l,X [Reads: Accumulator, X Index]
	lda $0D00.w,Y		; B9 00 0D ; Load $0D00.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $02.b		; 65 02 ; Add $02.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $7FF81E.l,X		; 9F 1E F8 7F ; Store accumulator (long,X) $7FF81E.l,X [Reads: Accumulator, X Index]
	lda $0D20.w,Y		; B9 20 0D ; Load $0D20.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $03.b		; 65 03 ; Add $03.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $7FF85A.l,X		; 9F 5A F8 7F ; Store accumulator (long,X) $7FF85A.l,X [Reads: Accumulator, X Index]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $7FF92C.l,X		; 9F 2C F9 7F ; Store accumulator (long,X) $7FF92C.l,X [Reads: Accumulator, X Index]
	lda #$9F0F.w		; A9 0F 9F ; Load #$9F0F.w into accumulator [Writes: Accumulator] [Flags: NZ]
	asl $7FF9.w		; 0E F9 7F ; Arithmetic shift left $7FF9.w [Flags: NCZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $1DEDD6.l		; 22 D6 ED 1D ; Jump to subroutine long $1DEDD6.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $10		; F0 10 ; Branch if equal to $F0, $10 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $BC		; 80 BC ; Branch always to $80, $BC [Flow: branch]
	cpx #$BD0D.w		; E0 0D BD ; Compare #$BD0D.w with X register [Reads: X Index] [Flags: NCZ]
	.db $10, $0E		; 10 0E ; Branch if plus to $10, $0E [Flow: branch]
	cmp #$B901.w		; C9 01 B9 ; Compare #$B901.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $80, $69		; 80 69 ; Branch always to $80, $69 [Flow: branch]
	brk $9D.b		; 00 9D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$BD0D.w		; C0 0D BD ; Compare #$BD0D.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $50, $0F		; 50 0F ; Branch if overflow clear to $50, $0F [Flow: branch]
	and #$19BF.w		; 29 BF 19 ; Logical AND #$19BF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sty $9D80.w		; 8C 80 9D ; Store Y register to $9D80.w [Reads: Y Index]
	.db $50, $0F		; 50 0F ; Branch if overflow clear to $50, $0F [Flow: branch]
	jsl $06DBF0.l		; 22 F0 DB 06 ; Jump to subroutine long $06DBF0.l [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0D		; D0 0D ; Branch if not equal to $D0, $0D [Flow: branch]
	lda #$9D80.w		; A9 80 9D ; Load #$9D80.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0D		; F0 0D ; Branch if equal to $F0, $0D [Flow: branch]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$9D01.w		; 49 01 9D ; Exclusive OR #$9D01.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $90, $0D		; 90 0D ; Branch if carry clear to $90, $0D [Flow: branch]
	ldy $0D90.w,X		; BC 90 0D ; Load Y register $0D90.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $8084.w,Y		; B9 84 80 ; Load $8084.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $8086.w,Y		; B9 86 80 ; Load $8086.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	jsr $F9ED.w		; 20 ED F9 ; Jump to subroutine at $F9ED.w [Writes: Stack Pointer] [Flow: call]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $1A.b		; 65 1A ; Add $1A.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and #$D01F.w		; 29 1F D0 ; Logical AND #$D01F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $A9.b		; 05 A9 ; Logical OR $A9.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $9D		; 10 9D ; Branch if plus to $10, $9D [Flow: branch]
	.db $10, $0E		; 10 0E ; Branch if plus to $10, $0E [Flow: branch]
	lda $0E10.w,X		; BD 10 0E ; Load $0E10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$F001.w		; C9 01 F0 ; Compare #$F001.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora ($60.b,X)		; 01 60 ; Logical OR ($60.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda $0F00.w,X		; BD 00 0F ; Load $0F00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $6B		; D0 6B ; Branch if not equal to $D0, $6B [Flow: branch]
	lda #$A06B.w		; A9 6B A0 ; Load #$A06B.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $5F22.w		; 0D 22 5F ; Logical OR $5F22.w with accumulator [Writes: Accumulator] [Flags: NZ]
	inc $1D.b,X		; F6 1D ; Increment memory $1D.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	.db $30, $61		; 30 61 ; Branch if minus to $30, $61 [Flow: branch]
	lda #$2207.w		; A9 07 22 ; Load #$2207.w into accumulator [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ora $01A9.w		; 0D A9 01 ; Logical OR $01A9.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DB0.w,Y		; 99 B0 0D ; Store accumulator to $0DB0.w,Y [Reads: Y Index, Accumulator]
	sta $0DC0.w,Y		; 99 C0 0D ; Store accumulator to $0DC0.w,Y [Reads: Y Index, Accumulator]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $815E.w,X		; 7D 5E 81 ; Add $815E.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,Y		; 99 10 0D ; Store accumulator to $0D10.w,Y [Reads: Y Index, Accumulator]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $8162.w,X		; 7D 62 81 ; Add $8162.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D30.w,Y		; 99 30 0D ; Store accumulator to $0D30.w,Y [Reads: Y Index, Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $8166.w,X		; 7D 66 81 ; Add $8166.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,Y		; 99 00 0D ; Store accumulator to $0D00.w,Y [Reads: Y Index, Accumulator]
	lda $03.b		; A5 03 ; Load $03.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $816A.w,X		; 7D 6A 81 ; Add $816A.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D20.w,Y		; 99 20 0D ; Store accumulator to $0D20.w,Y [Reads: Y Index, Accumulator]
	lda $816E.w,X		; BD 6E 81 ; Load $816E.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,Y		; 99 50 0D ; Store accumulator to $0D50.w,Y [Reads: Y Index, Accumulator]
	lda $8172.w,X		; BD 72 81 ; Load $8172.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,Y		; 99 40 0D ; Store accumulator to $0D40.w,Y [Reads: Y Index, Accumulator]
	lda $0E40.w,Y		; B9 40 0E ; Load $0E40.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and #$09F0.w		; 29 F0 09 ; Logical AND #$09F0.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($99.b,X)		; 01 99 ; Logical OR ($99.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	asl $60B9.w		; 0E B9 60 ; Arithmetic shift left $60B9.w [Flags: NCZ]
	asl $4709.w		; 0E 09 47 ; Arithmetic shift left $4709.w [Flags: NCZ]
	sta $0E60.w,Y		; 99 60 0E ; Store accumulator to $0E60.w,Y [Reads: Y Index, Accumulator]
	lda $0CAA.w,Y		; B9 AA 0C ; Load $0CAA.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora #$9944.w		; 09 44 99 ; Logical OR #$9944.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tsb $20A9.w		; 0C A9 20 ; Test and set bits $20A9.w [Reads: Accumulator] [Flags: Z]
	sta $0DF0.w,Y		; 99 F0 0D ; Store accumulator to $0DF0.w,Y [Reads: Y Index, Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	.db $30, $60		; 30 60 ; Branch if minus to $30, $60 [Flow: branch]
	.db $90, $C0		; 90 C0 ; Branch if carry clear to $90, $C0 [Flow: branch]
	brk $4F.b		; 00 4F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $5A5A4F.l		; 4F 4F 5A 5A ; Exclusive OR accumulator with memory (long) $5A5A4F.l [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	tsb $151C.w		; 0C 1C 15 ; Test and set bits $151C.w [Reads: Accumulator] [Flags: Z]
	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	stz $0B88.w		; 9C 88 0B ; Store zero to $0B88.w
	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc #$9D08.w		; E9 08 9D ; Subtract #$9D08.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx #$A907.w		; A2 07 A9 ; Load #$A907.w into X register [Writes: X Index] [Flags: NZ]
	adc $9D.b		; 65 9D ; Add $9D.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jsr $A90E.w		; 20 0E A9 ; Jump to subroutine at $A90E.w [Writes: Stack Pointer] [Flow: call]
	ora #$D09D.w		; 09 9D D0 ; Logical OR #$D09D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $1822.w		; 0D 22 18 ; Logical OR $1822.w with accumulator [Writes: Accumulator] [Flags: NZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	ora $23A5.w		; 0D A5 23 ; Logical OR $23A5.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D30.w,X		; 9D 30 0D ; Store accumulator to $0D30.w,X [Reads: Accumulator, X Index]
	lda $8176.w,X		; BD 76 81 ; Load $8176.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D10.w,X		; 9D 10 0D ; Store accumulator to $0D10.w,X [Reads: Accumulator, X Index]
	lda $21.b		; A5 21 ; Load $21.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D20.w,X		; 9D 20 0D ; Store accumulator to $0D20.w,X [Reads: Accumulator, X Index]
	lda $817E.w,X		; BD 7E 81 ; Load $817E.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D00.w,X		; 9D 00 0D ; Store accumulator to $0D00.w,X [Reads: Accumulator, X Index]
	lda $8186.w,X		; BD 86 81 ; Load $8186.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D90.w,X		; 9D 90 0D ; Store accumulator to $0D90.w,X [Reads: Accumulator, X Index]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $818E.w,Y		; B9 8E 81 ; Load $818E.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $8190.w,Y		; B9 90 81 ; Load $8190.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0F60.w,X		; 9D 60 0F ; Store accumulator to $0F60.w,X [Reads: Accumulator, X Index]
	lda #$9D0D.w		; A9 0D 9D ; Load #$9D0D.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $50, $0F		; 50 0F ; Branch if overflow clear to $50, $0F [Flow: branch]
	lda $EE.b		; A5 EE ; Load $EE.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0F20.w,X		; 9D 20 0F ; Store accumulator to $0F20.w,X [Reads: Accumulator, X Index]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	sta $0E80.w,X		; 9D 80 0E ; Store accumulator to $0E80.w,X [Reads: Accumulator, X Index]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $D0, $B1		; D0 B1 ; Branch if not equal to $D0, $B1 [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	inc $0BA0.w,X		; FE A0 0B ; Increment memory $0BA0.w,X [Reads: X Index] [Flags: NZ]
	lda $7EF377.l		; AF 77 F3 7E ; Load long $7EF377.l into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E30.w,X		; 9D 30 0E ; Store accumulator to $0E30.w,X [Reads: Accumulator, X Index]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0E30.w,X		; BD 30 0E ; Load $0E30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $7EF377.l		; 8F 77 F3 7E ; Store accumulator (long) $7EF377.l [Reads: Accumulator]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	ora [$82.b],Y		; 17 82 ; OR accumulator with memory (long indexed) [$82.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $4E83.w,Y		; D9 83 4E ; Compare accumulator $4E83.w,Y [Reads: Y Index] [Flags: NCZ]
	sty $03.b		; 84 03 ; Store Y register to $03.b [Reads: Y Index]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	cop $AD.b		; 02 AD ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $D00B.w,Y		; 99 0B D0 ; Store accumulator to $D00B.w,Y [Reads: Y Index, Accumulator]
	ora $EE.b,S		; 03 EE ; OR accumulator with stack relative $EE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	jsl $0DDAC4.l		; 22 C4 DA 0D ; Jump to subroutine long $0DDAC4.l [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	lda #$9D00.w		; A9 00 9D ; Load #$9D00.w into accumulator [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $F12922.l		; 0F 22 29 F1 ; OR accumulator with memory (long) $F12922.l [Writes: Accumulator] [Flags: NZ]
	asl $90.b		; 06 90 ; Arithmetic shift left $90.b [Reads: Direct Page] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	jsl $0FF540.l		; 22 40 F5 0F ; Jump to subroutine long $0FF540.l [Writes: Stack Pointer] [Flow: call]
	stz $5E.b		; 64 5E ; Store zero to $5E.b
	jsl $0791B9.l		; 22 B9 91 07 ; Jump to subroutine long $0791B9.l [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $13		; F0 13 ; Branch if equal to $F0, $13 [Flow: branch]
	and #$D007.w		; 29 07 D0 ; Logical AND #$D007.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $A9.b		; 06 A9 ; Arithmetic shift left $A9.b [Reads: Direct Page] [Flags: NCZ]
	ora ($22.b),Y		; 11 22 ; OR accumulator with memory ($22.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jmp ($0DBB.w,X)		; 7C BB 0D ; Jump indirect indexed to ($0DBB.w,X) [Reads: X Index] [Flow: jump]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$4A04.w		; 29 04 4A ; Logical AND #$4A04.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $80, $12		; 80 12 ; Branch always to $80, $12 [Flow: branch]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $09		; F0 09 ; Branch if equal to $F0, $09 [Flow: branch]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$A803.w		; 29 03 A8 ; Logical AND #$A803.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lda $8213.w,Y		; B9 13 82 ; Load $8213.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$F002.w		; C9 02 F0 ; Compare #$F002.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	adc $C9.b		; 65 C9 ; Add $C9.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($F0.b,X)		; 01 F0 ; Logical OR ($F0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	cmp #$D003.w		; C9 03 D0 ; Compare #$D003.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	tsb $E8AD.w		; 0C AD E8 ; Test and set bits $E8AD.w [Reads: Accumulator] [Flags: Z]
	trb $3ED0.w		; 1C D0 3E ; Test and reset bits $3ED0.w [Reads: Accumulator] [Flags: Z]
	lda #$9D01.w		; A9 01 9D ; Load #$9D01.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $80, $0D		; 80 0D ; Branch always to $80, $0D [Flow: branch]
	.db $80, $1D		; 80 1D ; Branch always to $80, $1D [Flow: branch]
	lda #$9D0A.w		; A9 0A 9D ; Load #$9D0A.w into accumulator [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $F12922.l		; 0F 22 29 F1 ; OR accumulator with memory (long) $F12922.l [Writes: Accumulator] [Flags: NZ]
	asl $90.b		; 06 90 ; Arithmetic shift left $90.b [Reads: Direct Page] [Flags: NCZ]
	tsb $F6A5.w		; 0C A5 F6 ; Test and set bits $F6A5.w [Reads: Accumulator] [Flags: Z]
	.db $10, $08		; 10 08 ; Branch if plus to $10, $08 [Flow: branch]
	lda #$2085.w		; A9 85 20 ; Load #$2085.w into accumulator [Writes: Accumulator] [Flags: NZ]
	lda $80FE82.l,X		; BF 82 FE 80 ; Load long $80FE82.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $AD60.w		; 0D 60 AD ; Logical OR $AD60.w with accumulator [Writes: Accumulator] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	trb $1AD0.w		; 1C D0 1A ; Test and reset bits $1AD0.w [Reads: Accumulator] [Flags: Z]
.ACCU 16
	rep #$20		; C2 20
	lda $7EF360.l		; [PATTERN: Memory clearing operation] AF 60 F3 7E ; Load long $7EF360.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$0014.w		; C9 14 00 ; Compare #$0014.w with accumulator [Reads: Accumulator] [Flags: NCZ]
.ACCU 8
	sep #$20		; E2 20
	.db $90, $20		; 90 20 ; Branch if carry clear to $90, $20 [Flow: branch]
	stz $0EB0.w,X		; 9E B0 0E ; Store zero to $0EB0.w,X [Reads: X Index]
	stz $0B88.w		; 9C 88 0B ; Store zero to $0B88.w
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$86.b		; A9 86 ; Load #$86.b into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $80, $05		; [PATTERN: Memory clearing operation] 80 05 ; Branch always to $80, $05 [Flow: branch]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	lda #$87.b		; A9 87 ; Load #$87.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1CF0.w		; 8D F0 1C ; Store accumulator to $1CF0.w [Reads: Accumulator]
	stz $1CF1.w		; 9C F1 1C ; Store zero to $1CF1.w
	jsl $05FA8E.l		; [PATTERN: Memory clearing operation] 22 8E FA 05 ; Jump to subroutine long $05FA8E.l [Writes: Stack Pointer] [Flow: call]
	stz $0DF0.w,X		; 9E F0 0D ; Store zero to $0DF0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	lda #$87.b		; A9 87 ; Load #$87.b into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $80, $EB		; 80 EB ; Branch always to $80, $EB [Flow: branch]
	lda $0EB0.w,X		; BD B0 0E ; Load $0EB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $23		; D0 23 ; Branch if not equal to $D0, $23 [Flow: branch]
	lda #$05.b		; A9 05 ; Load #$05.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0B99.w		; 8D 99 0B ; Store accumulator to $0B99.w [Reads: Accumulator]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0FFD86.l		; 22 86 FD 0F ; Jump to subroutine long $0FFD86.l [Writes: Stack Pointer] [Flow: call]
	lda #$27.b		; A9 27 ; Load #$27.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E00.w,X		; 9D 00 0E ; Store accumulator to $0E00.w,X [Reads: Accumulator, X Index]
.ACCU 16
	rep #$20		; C2 20
	lda $7EF360.l		; AF 60 F3 7E ; Load long $7EF360.l into accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$0014.w		; E9 14 00 ; Subtract #$0014.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $7EF360.l		; 8F 60 F3 7E ; Store accumulator (long) $7EF360.l [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	inc $0EB0.w,X		; FE B0 0E ; Increment memory $0EB0.w,X [Reads: X Index] [Flags: NZ]
	lda #$34.b		; A9 34 ; Load #$34.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBA80.l		; 22 80 BA 0D ; Jump to subroutine long $0DBA80.l [Writes: Stack Pointer] [Flow: call]
	jsr $FA50.w		; 20 50 FA ; Jump to subroutine at $FA50.w [Writes: Stack Pointer] [Flow: call]
	ldy $0B99.w		; AC 99 0B ; Load $0B99.w into Y register [Writes: Y Index] [Flags: NZ]
	sty $0D.b		; 84 0D ; Store Y register to $0D.b [Reads: Y Index]
	lda $0E00.w,X		; BD 00 0E ; Load $0E00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $09		; F0 09 ; Branch if equal to $F0, $09 [Flow: branch]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $8381.w,Y		; B9 81 83 ; Load $8381.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D.b		; 85 0D ; Store accumulator to $0D.b [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	lda $0D.b		; A5 0D ; Load $0D.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$07.b		; 69 07 ; Add #$07.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ldy #$A500.w		; A0 00 A5 ; Load #$A500.w into Y register [Writes: Y Index] [Flags: NZ]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc #$EC.b		; 69 EC ; Add #$EC.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	adc $8387.w,X		; 7D 87 83 ; Add $8387.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$D0.b		; 69 D0 ; Add #$D0.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	adc $8399.w,X		; 7D 99 83 ; Add $8399.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $83AB.w,X		; BD AB 83 ; Load $83AB.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $83BD.w,X		; BD BD 83 ; Load $83BD.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($92.b),Y		; 91 92 ; Store accumulator ($92.b),Y [Reads: Direct Page, Y Index, Accumulator]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $D1		; 10 D1 ; Branch if plus to $10, $D1 [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda $0B99.w		; AD 99 0B ; Load $0B99.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0F10.w,X		; 1D 10 0F ; OR accumulator with memory $0F10.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $0C4A.w		; 0D 4A 0C ; Logical OR $0C4A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0C4B.w		; 0D 4B 0C ; Logical OR $0C4B.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0C4C.w		; 0D 4C 0C ; Logical OR $0C4C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0C4D.w		; 0D 4D 0C ; Logical OR $0C4D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0C4E.w		; 0D 4E 0C ; Logical OR $0C4E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $17		; D0 17 ; Branch if not equal to $D0, $17 [Flow: branch]
	lda #$0A.b		; A9 0A ; Load #$0A.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F60.w,X		; 9D 60 0F ; Store accumulator to $0F60.w,X [Reads: Accumulator, X Index]
	jsl $06F129.l		; 22 29 F1 06 ; Jump to subroutine long $06F129.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $0C		; 90 0C ; Branch if carry clear to $90, $0C [Flow: branch]
	lda $F6.b		; A5 F6 ; Load $F6.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $08		; 10 08 ; Branch if plus to $10, $08 [Flow: branch]
	lda #$88.b		; A9 88 ; Load #$88.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $82BF.w		; 20 BF 82 ; Jump to subroutine at $82BF.w [Writes: Stack Pointer] [Flow: call]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsr $2820.w		; 20 20 28 ; Jump to subroutine at $2820.w [Writes: Stack Pointer] [Flow: call]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $F8		; 10 F8 ; Branch if plus to $10, $F8 [Flow: branch]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	adc $73.b,S		; 63 73 ; Add with carry (stack relative) $73.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	adc $73.b,S		; 63 73 ; Add with carry (stack relative) $73.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	adc $73.b,S		; 63 73 ; Add with carry (stack relative) $73.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	adc $73.b,S		; 63 73 ; Add with carry (stack relative) $73.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	adc $73.b,S		; 63 73 ; Add with carry (stack relative) $73.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	and ($33.b,S),Y		; 33 33 ; AND accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda ($B3.b,S),Y		; B3 B3 ; Load accumulator (stack relative indirect indexed) ($B3.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc ($73.b,S),Y		; 73 73 ; Add with carry (stack relative indirect indexed) ($73.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($F3.b,S),Y		; F3 F3 ; Subtract with carry (stack relative indirect indexed) ($F3.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	and ($32.b)		; 32 32 ; AND accumulator with memory (indirect) ($32.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($32.b)		; 32 32 ; AND accumulator with memory (indirect) ($32.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($32.b)		; 32 32 ; AND accumulator with memory (indirect) ($32.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($32.b)		; 32 32 ; AND accumulator with memory (indirect) ($32.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($32.b)		; 32 32 ; AND accumulator with memory (indirect) ($32.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	adc $63.b,S		; 63 63 ; Add with carry (stack relative) $63.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	adc $63.b,S		; 63 63 ; Add with carry (stack relative) $63.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	adc $BD.b,S		; 63 BD ; Add with carry (stack relative) $BD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $D0, $0E		; D0 0E ; Branch if not equal to $D0, $0E [Flow: branch]
	cmp #$05.b		; C9 05 ; Compare #$05.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $05		; 90 05 ; Branch if carry clear to $90, $05 [Flow: branch]
	lda #$06.b		; A9 06 ; Load #$06.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DA0.w,X		; 9D A0 0D ; Store accumulator to $0DA0.w,X [Reads: Accumulator, X Index]
	lda $0E40.w,X		; BD 40 0E ; Load $0E40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$E0.b		; 29 E0 ; Logical AND #$E0.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E40.w,X		; 9D 40 0E ; Store accumulator to $0E40.w,X [Reads: Accumulator, X Index]
	lda $0E10.w,X		; BD 10 0E ; Load $0E10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $06		; D0 06 ; Branch if not equal to $D0, $06 [Flow: branch]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$04.b		; 29 04 ; Logical AND #$04.b with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$BF.b		; 29 BF ; Logical AND #$BF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	lda $0FDA.w		; AD DA 0F ; Load $0FDA.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$03.b		; E9 03 ; Subtract #$03.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0FDA.w		; 8D DA 0F ; Store accumulator to $0FDA.w [Reads: Accumulator]
	jsl $06DBF0.l		; 22 F0 DB 06 ; Jump to subroutine long $06DBF0.l [Writes: Stack Pointer] [Flow: call]
	lda $0E10.w,X		; BD 10 0E ; Load $0E10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $30		; F0 30 ; Branch if equal to $F0, $30 [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda $0E40.w,X		; BD 40 0E ; Load $0E40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$05.b		; 09 05 ; Logical OR #$05.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E40.w,X		; 9D 40 0E ; Store accumulator to $0E40.w,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	cmp #$60.b		; C9 60 ; Compare #$60.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $1F		; D0 1F ; Branch if not equal to $D0, $1F [Flow: branch]
	lda $11.b		; A5 11 ; Load $11.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $1B		; D0 1B ; Branch if not equal to $D0, $1B [Flow: branch]
	lda #$70.b		; A9 70 ; Load #$70.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w		; 8D F0 0D ; Store accumulator to $0DF0.w [Reads: Accumulator]
	ldy $0DA0.w,X		; BC A0 0D ; Load Y register $0DA0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lda $83CE.w,Y		; B9 CE 83 ; Load $83CE.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $7EF360.l		; 6F 60 F3 7E ; Add with carry (long) $7EF360.l [Writes: Accumulator] [Flags: NCVZ]
	sta $7EF360.l		; 8F 60 F3 7E ; Store accumulator (long) $7EF360.l [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	jsr $84CF.w		; 20 CF 84 ; Jump to subroutine at $84CF.w [Writes: Stack Pointer] [Flow: call]
	.db $80, $15		; 80 15 ; Branch always to $80, $15 [Flow: branch]
	lda $0E40.w,X		; BD 40 0E ; Load $0E40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$E0.b		; 29 E0 ; Logical AND #$E0.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E40.w,X		; 9D 40 0E ; Store accumulator to $0E40.w,X [Reads: Accumulator, X Index]
	lda $0FDA.w		; AD DA 0F ; Load $0FDA.w into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$03.b		; 69 03 ; Add #$03.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0FDA.w		; 8D DA 0F ; Store accumulator to $0FDA.w [Reads: Accumulator]
	jsl $06DBF0.l		; 22 F0 DB 06 ; Jump to subroutine long $06DBF0.l [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	lda $0EE0.w,X		; BD E0 0E ; Load $0EE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $05		; D0 05 ; Branch if not equal to $D0, $05 [Flow: branch]
	lda #$3C.b		; A9 3C ; Load #$3C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012E.w		; 8D 2E 01 ; Store accumulator to $012E.w [Reads: Accumulator]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	jsr $F9F4.w		; 20 F4 F9 ; Jump to subroutine at $F9F4.w [Writes: Stack Pointer] [Flow: call]
	lda $0E00.w,X		; BD 00 0E ; Load $0E00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $15		; D0 15 ; Branch if not equal to $D0, $15 [Flow: branch]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0BA0.w,X		; 9D A0 0B ; Store accumulator to $0BA0.w,X [Reads: Accumulator, X Index]
	.db $D0, $10		; D0 10 ; Branch if not equal to $D0, $10 [Flow: branch]
	jsr $B88D.w		; 20 8D B8 ; Jump to subroutine at $B88D.w [Writes: Stack Pointer] [Flow: call]
	.db $F0, $08		; F0 08 ; Branch if equal to $F0, $08 [Flow: branch]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	stz $0E10.w,X		; 9E 10 0E ; Store zero to $0E10.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cmp #$01.b		; C9 01 ; Compare #$01.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $16		; D0 16 ; Branch if not equal to $D0, $16 [Flow: branch]
	ldy $0DC0.w,X		; BC C0 0D ; Load Y register $0DC0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $8492.w,Y		; B9 92 84 ; Load $8492.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D10.w,X		; 9D 10 0D ; Store accumulator to $0D10.w,X [Reads: Accumulator, X Index]
	lda $23.b		; A5 23 ; Load $23.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D30.w,X		; 9D 30 0D ; Store accumulator to $0D30.w,X [Reads: Accumulator, X Index]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E00.w,X		; 9D 00 0E ; Store accumulator to $0E00.w,X [Reads: Accumulator, X Index]
	stz $0ED0.w,X		; 9E D0 0E ; Store zero to $0ED0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $E8		; 10 E8 ; Branch if plus to $10, $E8 [Flow: branch]
	.db $F0, $EC		; F0 EC ; Branch if equal to $F0, $EC [Flow: branch]
	cpx $0BEC.w		; EC EC 0B ; Compare $0BEC.w with X register [Reads: X Index] [Flags: NCZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ldx $02.b,Y		; B6 02 ; Load X register $02.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	.db $30, $38		; 30 38 ; Branch if minus to $30, $38 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	bit $35.b,X		; 34 35 ; Test bits $35.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and $12.b,X		; 35 12 ; Logical AND $12.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and ($31.b)		; 32 31 ; AND accumulator with memory (indirect) ($31.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($7C.b,S),Y		; 33 7C ; AND accumulator (stack relative indirect indexed) ($7C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jmp ($0222.w,X)		; 7C 22 02 ; Jump indirect indexed to ($0222.w,X) [Reads: X Index] [Flow: jump]
	ora ($33.b)		; 12 33 ; OR accumulator with memory (indirect) ($33.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $FA50.w		; 20 50 FA ; Jump to subroutine at $FA50.w [Writes: Stack Pointer] [Flow: call]
	lda $0DA0.w,X		; BD A0 0D ; Load $0DA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx #$A004.w		; A2 04 A0 ; Load #$A004.w into X register [Writes: X Index] [Flags: NZ]
	tsb $A5.b		; 04 A5 ; Test and set bits $A5.b [Reads: Accumulator] [Flags: Z]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $84AF.w,X		; 7D AF 84 ; Add $84AF.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $84B4.w,X		; 7D B4 84 ; Add $84B4.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	cpx #$D004.w		; E0 04 D0 ; Compare #$D004.w with X register [Reads: X Index] [Flags: NCZ]
	ora #$DA.b		; 09 DA ; Logical OR #$DA.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ldx $06.b		; A6 06 ; Load $06.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	lda $84C8.w,X		; BD C8 84 ; Load $84C8.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	.db $80, $10		; 80 10 ; Branch always to $80, $10 [Flow: branch]
	cpx #$D003.w		; E0 03 D0 ; Compare #$D003.w with X register [Reads: X Index] [Flags: NCZ]
	ora #$DA.b		; 09 DA ; Logical OR #$DA.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ldx $06.b		; A6 06 ; Load $06.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	lda $84C2.w,X		; BD C2 84 ; Load $84C2.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	.db $80, $03		; 80 03 ; Branch always to $80, $03 [Flow: branch]
	lda $84B9.w,X		; BD B9 84 ; Load $84B9.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	cmp #$7C.b		; C9 7C ; Compare #$7C.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	lda $84BE.w,X		; BD BE 84 ; Load $84BE.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $90, $02		; 90 02 ; Branch if carry clear to $90, $02 [Flow: branch]
	and #$FE.b		; 29 FE ; Logical AND #$FE.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($92.b),Y		; 91 92 ; Store accumulator ($92.b),Y [Reads: Direct Page, Y Index, Accumulator]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $B5		; 10 B5 ; Branch if plus to $10, $B5 [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	jsl $06A72F.l		; 22 2F A7 06 ; Jump to subroutine long $06A72F.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $00FF01.l,X		; FF 01 FF 00 ; Subtract with carry (long,X) $00FF01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr $F93F.w		; 20 3F F9 ; Jump to subroutine at $F93F.w [Writes: Stack Pointer] [Flow: call]
	lda $0E.b		; A5 0E ; Load $0E.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$20.b		; 69 20 ; Add #$20.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$40.b		; C9 40 ; Compare #$40.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $0F		; B0 0F ; Branch if carry set to $B0, $0F [Flow: branch]
	lda $0F.b		; A5 0F ; Load $0F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$20.b		; 69 20 ; Add #$20.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$40.b		; C9 40 ; Compare #$40.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $06		; B0 06 ; Branch if carry set to $B0, $06 [Flow: branch]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBA84.l		; 22 84 BA 0D ; Jump to subroutine long $0DBA84.l [Writes: Stack Pointer] [Flow: call]
	jsr $86E4.w		; 20 E4 86 ; Jump to subroutine at $86E4.w [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	ldy $0EB0.w,X		; BC B0 0E ; Load Y register $0EB0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $0DD0.w,Y		; B9 D0 0D ; Load $0DD0.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$06.b		; C9 06 ; Compare #$06.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $13		; D0 13 ; Branch if not equal to $D0, $13 [Flow: branch]
	sta $0DD0.w,X		; 9D D0 0D ; Store accumulator to $0DD0.w,X [Reads: Accumulator, X Index]
	lda $0DF0.w,Y		; B9 F0 0D ; Load $0DF0.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda $0E40.w,X		; BD 40 0E ; Load $0E40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$04.b		; 69 04 ; Add #$04.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0E40.w,X		; 9D 40 0E ; Store accumulator to $0E40.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $59		; B0 59 ; Branch if carry set to $B0, $59 [Flow: branch]
	jsl $06F129.l		; 22 29 F1 06 ; Jump to subroutine long $06F129.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $53		; 90 53 ; Branch if carry clear to $90, $53 [Flow: branch]
	jsl $0791B9.l		; 22 B9 91 07 ; Jump to subroutine long $0791B9.l [Writes: Stack Pointer] [Flow: call]
	lda $F6.b		; A5 F6 ; Load $F6.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$10.b		; 29 10 ; Logical AND #$10.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $05		; D0 05 ; Branch if not equal to $D0, $05 [Flow: branch]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0B7B.w		; 8D 7B 0B ; Store accumulator to $0B7B.w [Reads: Accumulator]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06EA12.l		; 22 12 EA 06 ; Jump to subroutine long $06EA12.l [Writes: Stack Pointer] [Flow: call]
	ldy #$A500.w		; A0 00 A5 ; Load #$A500.w into Y register [Writes: Y Index] [Flags: NZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $49.b		; 04 49 ; Test and set bits $49.b [Reads: Accumulator] [Flags: Z]
	sbc $18C81A.l,X		; FF 1A C8 18 ; Subtract with carry (long,X) $18C81A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $0D90.w,X		; 7D 90 0D ; Add $0D90.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D90.w,X		; 9D 90 0D ; Store accumulator to $0D90.w,X [Reads: Accumulator, X Index]
	.db $90, $0C		; 90 0C ; Branch if carry clear to $90, $0C [Flow: branch]
	lda $852D.w,Y		; B9 2D 85 ; Load $852D.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0B7E.w		; 8D 7E 0B ; Store accumulator to $0B7E.w [Reads: Accumulator]
	lda $852F.w,Y		; B9 2F 85 ; Load $852F.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0B7F.w		; 8D 7F 0B ; Store accumulator to $0B7F.w [Reads: Accumulator]
	ldy #$A500.w		; A0 00 A5 ; Load #$A500.w into Y register [Writes: Y Index] [Flags: NZ]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $49.b		; 04 49 ; Test and set bits $49.b [Reads: Accumulator] [Flags: Z]
	sbc $18C81A.l,X		; FF 1A C8 18 ; Subtract with carry (long,X) $18C81A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $0DA0.w,X		; 7D A0 0D ; Add $0DA0.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0DA0.w,X		; 9D A0 0D ; Store accumulator to $0DA0.w,X [Reads: Accumulator, X Index]
	.db $90, $0C		; 90 0C ; Branch if carry clear to $90, $0C [Flow: branch]
	lda $852D.w,Y		; B9 2D 85 ; Load $852D.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0B7C.w		; 8D 7C 0B ; Store accumulator to $0B7C.w [Reads: Accumulator]
	lda $852F.w,Y		; B9 2F 85 ; Load $852F.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0B7D.w		; 8D 7D 0B ; Store accumulator to $0B7D.w [Reads: Accumulator]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	dec $F585.w,X		; DE 85 F5 ; Decrement memory $F585.w,X [Reads: X Index] [Flags: NZ]
	sta $0F.b		; 85 0F ; Store accumulator to $0F.b [Reads: Accumulator]
	stx $34.b		; 86 34 ; Store X register to $34.b [Reads: X Index]
	stx $A9.b		; 86 A9 ; Store X register to $A9.b [Reads: X Index]
	asl $9D.b		; 06 9D ; Arithmetic shift left $9D.b [Reads: Direct Page] [Flags: NCZ]
	cpy #$BD0D.w		; C0 0D BD ; Compare #$BD0D.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $F0, $0D		; F0 0D ; Branch if equal to $F0, $0D [Flow: branch]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$3F.b		; A9 3F ; Load #$3F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $09		; D0 09 ; Branch if not equal to $D0, $09 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$FF.b		; A9 FF ; Load #$FF.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $85F1.w,Y		; B9 F1 85 ; Load $85F1.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$0F.b		; 29 0F ; Logical AND #$0F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0D		; D0 0D ; Branch if not equal to $D0, $0D [Flow: branch]
	inc $0DC0.w,X		; FE C0 0D ; Increment memory $0DC0.w,X [Reads: X Index] [Flags: NZ]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $03		; 90 03 ; Branch if carry clear to $90, $03 [Flow: branch]
	stz $0DC0.w,X		; 9E C0 0D ; Store zero to $0DC0.w,X [Reads: X Index]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	lda #$3F.b		; A9 3F ; Load #$3F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $09		; D0 09 ; Branch if not equal to $D0, $09 [Flow: branch]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $8630.w,Y		; B9 30 86 ; Load $8630.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $F80008.l,X		; FF 08 00 F8 ; Subtract with carry (long,X) $F80008.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F80008.l,X		; FF 08 00 F8 ; Subtract with carry (long,X) $F80008.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F80008.l,X		; FF 08 00 F8 ; Subtract with carry (long,X) $F80008.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F80008.l,X		; FF 08 00 F8 ; Subtract with carry (long,X) $F80008.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F80008.l,X		; FF 08 00 F8 ; Subtract with carry (long,X) $F80008.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $000008.l,X		; FF 08 00 00 ; Subtract with carry (long,X) $000008.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $F80008.l,X		; FF 08 00 F8 ; Subtract with carry (long,X) $F80008.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F80008.l,X		; FF 08 00 F8 ; Subtract with carry (long,X) $F80008.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $08FFF8.l,X		; FF F8 FF 08 ; Subtract with carry (long,X) $08FFF8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $08FFF8.l,X		; FF F8 FF 08 ; Subtract with carry (long,X) $08FFF8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $08FFF8.l,X		; FF F8 FF 08 ; Subtract with carry (long,X) $08FFF8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $08FFF8.l,X		; FF F8 FF 08 ; Subtract with carry (long,X) $08FFF8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	jsl $022222.l		; 22 22 22 02 ; Jump to subroutine long $022222.l [Writes: Stack Pointer] [Flow: call]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $29.b		; 02 29 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and #$29.b		; 29 29 ; Logical AND #$29.b with accumulator [Writes: Accumulator] [Flags: NZ]
	and #$39.b		; 29 39 ; Logical AND #$39.b with accumulator [Writes: Accumulator] [Flags: NZ]
	and $3939.w,Y		; 39 39 39 ; AND accumulator with memory $3939.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $FA50.w		; 20 50 FA ; Jump to subroutine at $FA50.w [Writes: Stack Pointer] [Flow: call]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$06.b		; C9 06 ; Compare #$06.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $5E		; F0 5E ; Branch if equal to $F0, $5E [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $86DE.w,X		; BD DE 86 ; Load $86DE.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D.b		; 85 0D ; Store accumulator to $0D.b [Reads: Accumulator]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	ldx #$DA03.w		; A2 03 DA ; Load #$DA03.w into X register [Writes: X Index] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $06.b		; 65 06 ; Add $06.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $864E.w,X		; 7D 4E 86 ; Add $864E.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	and #$0100.w		; 29 00 01 ; Logical AND #$0100.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E.b		; 85 0E ; Store accumulator to $0E.b [Reads: Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $867E.w,X		; 7D 7E 86 ; Add $867E.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0010.w		; 69 10 00 ; Add #$0010.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0100.w		; C9 00 01 ; Compare #$0100.w with accumulator [Reads: Accumulator] [Flags: NCZ]
.ACCU 8
	sep #$20		; E2 20
	.db $90, $04		; 90 04 ; Branch if carry clear to $90, $04 [Flow: branch]
	lda #$F0.b		; A9 F0 ; Load #$F0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda $86AE.w,X		; BD AE 86 ; Load $86AE.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $86C6.w,X		; BD C6 86 ; Load $86C6.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $0D.b		; A5 0D ; Load $0D.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0F.b		; 05 0F ; Logical OR $0F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($92.b),Y		; 91 92 ; Store accumulator ($92.b),Y [Reads: Direct Page, Y Index, Accumulator]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $B1		; 10 B1 ; Branch if plus to $10, $B1 [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $8857.w		; 20 57 88 ; Jump to subroutine at $8857.w [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	.db $62, $87, $75		; 62 87 75 ; Push effective relative address $62, $87, $75 [Writes: Stack Pointer]
	sta [$92.b]		; 87 92 ; Store accumulator (long) [$92.b] [Reads: Direct Page, Accumulator]
	sta [$CA.b]		; 87 CA ; Store accumulator (long) [$CA.b] [Reads: Direct Page, Accumulator]
	sta [$BD.b]		; 87 BD ; Store accumulator (long) [$BD.b] [Reads: Direct Page, Accumulator]
	.db $F0, $0D		; F0 0D ; Branch if equal to $F0, $0D [Flow: branch]
	sta $0BA0.w,X		; 9D A0 0B ; Store accumulator to $0BA0.w,X [Reads: Accumulator, X Index]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$1F.b		; A9 1F ; Load #$1F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsr $AB93.w		; 20 93 AB ; Jump to subroutine at $AB93.w [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $09		; D0 09 ; Branch if not equal to $D0, $09 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$80.b		; A9 80 ; Load #$80.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $8773.w,Y		; B9 73 87 ; Load $8773.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $AB93.w		; 20 93 AB ; Jump to subroutine at $AB93.w [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $09		; D0 09 ; Branch if not equal to $D0, $09 [Flow: branch]
	lda #$1F.b		; A9 1F ; Load #$1F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	and #$1F.b		; 29 1F ; Logical AND #$1F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0ED0.w,X		; 1D D0 0E ; OR accumulator with memory $0ED0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $11.b		; 05 11 ; Logical OR $11.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0F00.w,X		; 1D 00 0F ; OR accumulator with memory $0F00.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $0FC1.w		; 0D C1 0F ; Logical OR $0FC1.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $04		; D0 04 ; Branch if not equal to $D0, $04 [Flow: branch]
	jsl $0DDA06.l		; 22 06 DA 0D ; Jump to subroutine long $0DDA06.l [Writes: Stack Pointer] [Flow: call]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$02.b		; 69 02 ; Add #$02.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $AB93.w		; 20 93 AB ; Jump to subroutine at $AB93.w [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $09		; D0 09 ; Branch if not equal to $D0, $09 [Flow: branch]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	lda #$DF.b		; A9 DF ; Load #$DF.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $87C8.w,Y		; B9 C8 87 ; Load $87C8.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $06FFFE.l,X		; FF FE FF 06 ; Subtract with carry (long,X) $06FFFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FCFFFC.l,X		; FF FC FF FC ; Subtract with carry (long,X) $FCFFFC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FCFFFC.l,X		; FF FC FF FC ; Subtract with carry (long,X) $FCFFFC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FCFFFC.l,X		; FF FC FF FC ; Subtract with carry (long,X) $FCFFFC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $00FFFC.l,X		; FF FC FF 00 ; Subtract with carry (long,X) $00FFFC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $D8.b		; 00 D8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cld		; D8 ; Clear decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $00D9.w,Y		; D9 D9 00 ; Compare accumulator $00D9.w,Y [Reads: Y Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $2020.w		; 20 20 20 ; Jump to subroutine at $2020.w [Writes: Stack Pointer] [Flow: call]
	ora ($41.b,X)		; 01 41 ; Logical OR ($41.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $68		; F0 68 ; Branch if equal to $F0, $68 [Flow: branch]
	jsr $FA50.w		; 20 50 FA ; Jump to subroutine at $FA50.w [Writes: Stack Pointer] [Flow: call]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx #$DA03.w		; A2 03 DA ; Load #$DA03.w into X register [Writes: X Index] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $06.b		; 65 06 ; Add $06.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $87E7.w,X		; 7D E7 87 ; Add $87E7.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	and #$0100.w		; 29 00 01 ; Logical AND #$0100.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E.b		; 85 0E ; Store accumulator to $0E.b [Reads: Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $8807.w,X		; 7D 07 88 ; Add $8807.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0010.w		; 69 10 00 ; Add #$0010.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0100.w		; C9 00 01 ; Compare #$0100.w with accumulator [Reads: Accumulator] [Flags: NCZ]
.ACCU 8
	sep #$20		; E2 20
	.db $90, $04		; 90 04 ; Branch if carry clear to $90, $04 [Flow: branch]
	lda #$F0.b		; A9 F0 ; Load #$F0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda $8827.w,X		; BD 27 88 ; Load $8827.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $8837.w,X		; BD 37 88 ; Load $8837.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	and #$0F.b		; 29 0F ; Logical AND #$0F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$01.b		; C9 01 ; Compare #$01.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	eor $05.b		; 45 05 ; Exclusive OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $02		; B0 02 ; Branch if carry set to $B0, $02 [Flow: branch]
	and #$F0.b		; 29 F0 ; Logical AND #$F0.b with accumulator [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $8847.w,X		; BD 47 88 ; Load $8847.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $0F.b		; 05 0F ; Logical OR $0F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($92.b),Y		; 91 92 ; Store accumulator ($92.b),Y [Reads: Direct Page, Y Index, Accumulator]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $A6		; 10 A6 ; Branch if plus to $10, $A6 [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	dec $88.b,X		; D6 88 ; Decrement memory $88.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	jmp.w [$EA89]		; DC 89 EA ; Jump long indirect [$EA89] [Flow: jump]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$8D.b		; 29 8D ; Logical AND #$8D.b with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $8A.b,X		; 16 8A ; Arithmetic shift left $8A.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	lda $10.b		; A5 10 ; Load $10.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$1A.b		; C9 1A ; Compare #$1A.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $0F		; F0 0F ; Branch if equal to $F0, $0F [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx $8A.b		; A6 8A ; Load $8A.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	lda $7EF280.l,X		; BF 80 F2 7E ; Load long $7EF280.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	and #$40.b		; 29 40 ; Logical AND #$40.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	jmp $89C6.w		; 4C C6 89 ; Jump to $89C6.w [Flow: jump]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$05.b		; C9 05 ; Compare #$05.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	jsr $8DA8.w		; 20 A8 8D ; Jump to subroutine at $8DA8.w [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	bit #$4D.b		; 89 4D ; Test bits #$4D.b with accumulator [Reads: Accumulator] [Flags: Z]
	bit #$68.b		; 89 68 ; Test bits #$68.b with accumulator [Reads: Accumulator] [Flags: Z]
	bit #$7E.b		; 89 7E ; Test bits #$7E.b with accumulator [Reads: Accumulator] [Flags: Z]
	bit #$9D.b		; 89 9D ; Test bits #$9D.b with accumulator [Reads: Accumulator] [Flags: Z]
	bit #$C6.b		; 89 C6 ; Test bits #$C6.b with accumulator [Reads: Accumulator] [Flags: Z]
	bit #$22.b		; 89 22 ; Test bits #$22.b with accumulator [Reads: Accumulator] [Flags: Z]
	.db $D0, $F4		; D0 F4 ; Branch if not equal to $D0, $F4 [Flow: branch]
	ora [$B0.b]		; 07 B0 ; OR accumulator with memory (long) [$B0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $2922.w,X		; 3E 22 29 ; Rotate left $2922.w,X [Reads: X Index] [Flags: NCZ]
	sbc ($06.b),Y		; F1 06 ; Subtract with carry ($06.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $90, $38		; 90 38 ; Branch if carry clear to $90, $38 [Flow: branch]
	lda $2F.b		; A5 2F ; Load $2F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $32		; D0 32 ; Branch if not equal to $D0, $32 [Flow: branch]
	lda $F6.b		; A5 F6 ; Load $F6.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $2E		; 10 2E ; Branch if plus to $10, $2E [Flow: branch]
	lda $7EF374.l		; AF 74 F3 7E ; Load long $7EF374.l into accumulator [Writes: Accumulator] [Flags: NZ]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$07.b		; C9 07 ; Compare #$07.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $24		; D0 24 ; Branch if not equal to $D0, $24 [Flow: branch]
	lda #$0A.b		; A9 0A ; Load #$0A.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012C.w		; 8D 2C 01 ; Store accumulator to $012C.w [Reads: Accumulator]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $037B.w		; 8D 7B 03 ; Store accumulator to $037B.w [Reads: Accumulator]
	lda #$09.b		; A9 09 ; Load #$09.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $8CD3.w		; 20 D3 8C ; Jump to subroutine at $8CD3.w [Writes: Stack Pointer] [Flow: call]
	lda #$0B.b		; A9 0B ; Load #$0B.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $8CD3.w		; 20 D3 8C ; Jump to subroutine at $8CD3.w [Writes: Stack Pointer] [Flow: call]
	lda #$0F.b		; A9 0F ; Load #$0F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $8CD3.w		; 20 D3 8C ; Jump to subroutine at $8CD3.w [Writes: Stack Pointer] [Flow: call]
	jsr $8AB6.w		; 20 B6 8A ; Jump to subroutine at $8AB6.w [Writes: Stack Pointer] [Flow: call]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$F0.b		; A9 F0 ; Load #$F0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0B		; D0 0B ; Branch if not equal to $D0, $0B [Flow: branch]
	jsr $8AD0.w		; 20 D0 8A ; Jump to subroutine at $8AD0.w [Writes: Stack Pointer] [Flow: call]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$C0.b		; A9 C0 ; Load #$C0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda #$0A.b		; A9 0A ; Load #$0A.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0377.w		; 8D 77 03 ; Store accumulator to $0377.w [Reads: Accumulator]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $02E4.w		; 8D E4 02 ; Store accumulator to $02E4.w [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0D		; D0 0D ; Branch if not equal to $D0, $0D [Flow: branch]
	ldy #$20FF.w		; A0 FF 20 ; Load #$20FF.w into Y register [Writes: Y Index] [Flags: NZ]
	.db $62, $8B, $FE		; 62 8B FE ; Push effective relative address $62, $8B, $FE [Writes: Stack Pointer]
	.db $80, $0D		; 80 0D ; Branch always to $80, $0D [Flow: branch]
	lda #$08.b		; A9 08 ; Load #$08.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda #$0A.b		; A9 0A ; Load #$0A.b into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $80, $16		; 80 16 ; Branch always to $80, $16 [Flow: branch]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0F		; D0 0F ; Branch if not equal to $D0, $0F [Flow: branch]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$20FF.w		; A0 FF 20 ; Load #$20FF.w into Y register [Writes: Y Index] [Flags: NZ]
	.db $62, $8B, $FE		; 62 8B FE ; Push effective relative address $62, $8B, $FE [Writes: Stack Pointer]
	.db $80, $0D		; 80 0D ; Branch always to $80, $0D [Flow: branch]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda #$0B.b		; A9 0B ; Load #$0B.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0377.w		; 8D 77 03 ; Store accumulator to $0377.w [Reads: Accumulator]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $02E4.w		; 8D E4 02 ; Store accumulator to $02E4.w [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $23		; D0 23 ; Branch if not equal to $D0, $23 [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx $8A.b		; A6 8A ; Load $8A.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	lda $7EF280.l,X		; BF 80 F2 7E ; Load long $7EF280.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$40.b		; 09 40 ; Logical OR #$40.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF280.l,X		; 9F 80 F2 7E ; Store accumulator (long,X) $7EF280.l,X [Reads: Accumulator, X Index]
	ldy #$9C01.w		; A0 01 9C ; Load #$9C01.w into Y register [Writes: Y Index] [Flags: NZ]
	sbc #$02.b		; E9 02 ; Subtract #$02.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	jsl $0799AD.l		; 22 AD 99 07 ; Jump to subroutine long $0799AD.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda #$05.b		; A9 05 ; Load #$05.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF3C7.l		; [PATTERN: Memory clearing operation] 8F C7 F3 7E ; Store accumulator (long) $7EF3C7.l [Reads: Accumulator]
	stz $0377.w		; 9C 77 03 ; Store zero to $0377.w
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $8A94.w		; 20 94 8A ; Jump to subroutine at $8A94.w [Writes: Stack Pointer] [Flow: call]
	inc $0D90.w,X		; FE 90 0D ; Increment memory $0D90.w,X [Reads: X Index] [Flags: NZ]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $06		; D0 06 ; Branch if not equal to $D0, $06 [Flow: branch]
	inc $0DB0.w,X		; FE B0 0D ; Increment memory $0DB0.w,X [Reads: X Index] [Flags: NZ]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $89CA.w,Y		; B9 CA 89 ; Load $89CA.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	lda $89D3.w,Y		; B9 D3 89 ; Load $89D3.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0B		; F0 0B ; Branch if equal to $F0, $0B [Flow: branch]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $8B62.w		; 20 62 8B ; Jump to subroutine at $8B62.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $8A94.w		; 20 94 8A ; Jump to subroutine at $8A94.w [Writes: Stack Pointer] [Flow: call]
	inc $0D90.w,X		; FE 90 0D ; Increment memory $0D90.w,X [Reads: X Index] [Flags: NZ]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $06		; D0 06 ; Branch if not equal to $D0, $06 [Flow: branch]
	inc $0DB0.w,X		; FE B0 0D ; Increment memory $0DB0.w,X [Reads: X Index] [Flags: NZ]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	sbc $820004.l,X		; FF 04 00 82 ; Subtract with carry (long,X) $820004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $FA.b		; 02 FA ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $820004.l,X		; FF 04 00 82 ; Subtract with carry (long,X) $820004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	sbc $820004.l,X		; FF 04 00 82 ; Subtract with carry (long,X) $820004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$0200.w		; C0 00 02 ; Compare #$0200.w with Y register [Reads: Y Index] [Flags: NCZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	sbc $820004.l,X		; FF 04 00 82 ; Subtract with carry (long,X) $820004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	cop $FA.b		; 02 FA ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $A00004.l,X		; FF 04 00 A0 ; Subtract with carry (long,X) $A00004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $FA.b		; 02 FA ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $A00004.l,X		; FF 04 00 A0 ; Subtract with carry (long,X) $A00004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	sbc $A00004.l,X		; FF 04 00 A0 ; Subtract with carry (long,X) $A00004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$0200.w		; C0 00 02 ; Compare #$0200.w with Y register [Reads: Y Index] [Flags: NCZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	sbc $A00004.l,X		; FF 04 00 A0 ; Subtract with carry (long,X) $A00004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	cop $FA.b		; 02 FA ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $800004.l,X		; FF 04 00 80 ; Subtract with carry (long,X) $800004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $FA.b		; 02 FA ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $800004.l,X		; FF 04 00 80 ; Subtract with carry (long,X) $800004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	sbc $800004.l,X		; FF 04 00 80 ; Subtract with carry (long,X) $800004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$0200.w		; C0 00 02 ; Compare #$0200.w with Y register [Reads: Y Index] [Flags: NCZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	sbc $800004.l,X		; FF 04 00 80 ; Subtract with carry (long,X) $800004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	cop $A9.b		; 02 A9 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	ora $C0BD.w		; 0D BD C0 ; Logical OR $C0BD.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0A0A.w		; 0D 0A 0A ; Logical OR $0A0A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	adc $0DE0.w,X		; 7D E0 0D ; Add $0DE0.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc #$34.b		; 69 34 ; Add #$34.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
	lda #$8A.b		; A9 8A ; Load #$8A.b into accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $09.b		; 85 09 ; Store accumulator to $09.b [Reads: Accumulator]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $05DF6C.l		; 22 6C DF 05 ; Jump to subroutine long $05DF6C.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$62.b		; A9 62 ; Load #$62.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	jsl $09AE64.l		; 22 64 AE 09 ; Jump to subroutine long $09AE64.l [Writes: Stack Pointer] [Flow: call]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E80.w,Y		; 99 80 0E ; Store accumulator to $0E80.w,Y [Reads: Y Index, Accumulator]
	lda #$05.b		; A9 05 ; Load #$05.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,Y		; 99 50 0F ; Store accumulator to $0F50.w,Y [Reads: Y Index, Accumulator]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E40.w,Y		; 99 40 0E ; Store accumulator to $0E40.w,Y [Reads: Y Index, Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$62.b		; A9 62 ; Load #$62.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	jsl $09AE64.l		; 22 64 AE 09 ; Jump to subroutine long $09AE64.l [Writes: Stack Pointer] [Flow: call]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E80.w,Y		; 99 80 0E ; Store accumulator to $0E80.w,Y [Reads: Y Index, Accumulator]
	lda #$05.b		; A9 05 ; Load #$05.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,Y		; 99 50 0F ; Store accumulator to $0F50.w,Y [Reads: Y Index, Accumulator]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E40.w,Y		; 99 40 0E ; Store accumulator to $0E40.w,Y [Reads: Y Index, Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $06DBF0.l		; 22 F0 DB 06 ; Jump to subroutine long $06DBF0.l [Writes: Stack Pointer] [Flow: call]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0C		; F0 0C ; Branch if equal to $F0, $0C [Flow: branch]
	jsr $F9ED.w		; 20 ED F9 ; Jump to subroutine at $F9ED.w [Writes: Stack Pointer] [Flow: call]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0B		; D0 0B ; Branch if not equal to $D0, $0B [Flow: branch]
	jsr $8B20.w		; 20 20 8B ; Jump to subroutine at $8B20.w [Writes: Stack Pointer] [Flow: call]
	dec $0DA0.w,X		; DE A0 0D ; Decrement memory $0DA0.w,X [Reads: X Index] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy #$60D0.w		; A0 D0 60 ; Load #$60D0.w into Y register [Writes: Y Index] [Flags: NZ]
	.db $30, $A0		; 30 A0 ; Branch if minus to $30, $A0 [Flow: branch]
	.db $D0, $60		; D0 60 ; Branch if not equal to $D0, $60 [Flow: branch]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	.db $D0, $01		; D0 01 ; Branch if not equal to $D0, $01 [Flow: branch]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $05.b		; 45 05 ; Exclusive OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $A9.b		; 05 A9 ; Logical OR $A9.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $62, $22, $5D		; 62 22 5D ; Push effective relative address $62, $22, $5D [Writes: Stack Pointer]
	inc $1D.b,X		; F6 1D ; Increment memory $1D.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	.db $30, $39		; 30 39 ; Branch if minus to $30, $39 [Flow: branch]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,Y		; 99 10 0D ; Store accumulator to $0D10.w,Y [Reads: Y Index, Accumulator]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D30.w,Y		; 99 30 0D ; Store accumulator to $0D30.w,Y [Reads: Y Index, Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,Y		; 99 00 0D ; Store accumulator to $0D00.w,Y [Reads: Y Index, Accumulator]
	lda $03.b		; A5 03 ; Load $03.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D20.w,Y		; 99 20 0D ; Store accumulator to $0D20.w,Y [Reads: Y Index, Accumulator]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E80.w,Y		; 99 80 0E ; Store accumulator to $0E80.w,Y [Reads: Y Index, Accumulator]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DA0.w,Y		; 99 A0 0D ; Store accumulator to $0DA0.w,Y [Reads: Y Index, Accumulator]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,Y		; 99 C0 0D ; Store accumulator to $0DC0.w,Y [Reads: Y Index, Accumulator]
	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,Y		; 99 50 0F ; Store accumulator to $0F50.w,Y [Reads: Y Index, Accumulator]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E40.w,Y		; 99 40 0E ; Store accumulator to $0E40.w,Y [Reads: Y Index, Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda #$62.b		; A9 62 ; Load #$62.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	.db $10, $03		; 10 03 ; Branch if plus to $10, $03 [Flow: branch]
	jmp $8CD0.w		; 4C D0 8C ; Jump to $8CD0.w [Flow: jump]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$04.b		; E9 04 ; Subtract #$04.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,Y		; 99 10 0D ; Store accumulator to $0D10.w,Y [Reads: Y Index, Accumulator]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc #$00.b		; E9 00 ; Subtract #$00.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0D30.w,Y		; 99 30 0D ; Store accumulator to $0D30.w,Y [Reads: Y Index, Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$04.b		; 69 04 ; Add #$04.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,Y		; 99 00 0D ; Store accumulator to $0D00.w,Y [Reads: Y Index, Accumulator]
	lda $03.b		; A5 03 ; Load $03.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D20.w,Y		; 99 20 0D ; Store accumulator to $0D20.w,Y [Reads: Y Index, Accumulator]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E80.w,Y		; 99 80 0E ; Store accumulator to $0E80.w,Y [Reads: Y Index, Accumulator]
	sta $0D90.w,Y		; 99 90 0D ; Store accumulator to $0D90.w,Y [Reads: Y Index, Accumulator]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E40.w,Y		; 99 40 0E ; Store accumulator to $0E40.w,Y [Reads: Y Index, Accumulator]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $8B08.w,X		; BD 08 8B ; Load $8B08.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,Y		; 99 50 0D ; Store accumulator to $0D50.w,Y [Reads: Y Index, Accumulator]
	lda $8B10.w,X		; BD 10 8B ; Load $8B10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,Y		; 99 40 0D ; Store accumulator to $0D40.w,Y [Reads: Y Index, Accumulator]
	lda $8B18.w,X		; BD 18 8B ; Load $8B18.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,Y		; 99 C0 0D ; Store accumulator to $0DC0.w,Y [Reads: Y Index, Accumulator]
	lda $8B1C.w,X		; BD 1C 8B ; Load $8B1C.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,Y		; 99 50 0F ; Store accumulator to $0F50.w,Y [Reads: Y Index, Accumulator]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $0DA0.w,Y		; 99 A0 0D ; Store accumulator to $0DA0.w,Y [Reads: Y Index, Accumulator]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda #$62.b		; A9 62 ; Load #$62.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	.db $10, $03		; 10 03 ; Branch if plus to $10, $03 [Flow: branch]
	jmp $8CD0.w		; 4C D0 8C ; Jump to $8CD0.w [Flow: jump]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$04.b		; E9 04 ; Subtract #$04.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,Y		; 99 10 0D ; Store accumulator to $0D10.w,Y [Reads: Y Index, Accumulator]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc #$00.b		; E9 00 ; Subtract #$00.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0D30.w,Y		; 99 30 0D ; Store accumulator to $0D30.w,Y [Reads: Y Index, Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$04.b		; 69 04 ; Add #$04.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,Y		; 99 00 0D ; Store accumulator to $0D00.w,Y [Reads: Y Index, Accumulator]
	lda $03.b		; A5 03 ; Load $03.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D20.w,Y		; 99 20 0D ; Store accumulator to $0D20.w,Y [Reads: Y Index, Accumulator]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E80.w,Y		; 99 80 0E ; Store accumulator to $0E80.w,Y [Reads: Y Index, Accumulator]
	sta $0D90.w,Y		; 99 90 0D ; Store accumulator to $0D90.w,Y [Reads: Y Index, Accumulator]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E40.w,Y		; 99 40 0E ; Store accumulator to $0E40.w,Y [Reads: Y Index, Accumulator]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $8B0A.w,X		; BD 0A 8B ; Load $8B0A.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,Y		; 99 50 0D ; Store accumulator to $0D50.w,Y [Reads: Y Index, Accumulator]
	lda $8B12.w,X		; BD 12 8B ; Load $8B12.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,Y		; 99 40 0D ; Store accumulator to $0D40.w,Y [Reads: Y Index, Accumulator]
	lda $8B18.w,X		; BD 18 8B ; Load $8B18.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,Y		; 99 C0 0D ; Store accumulator to $0DC0.w,Y [Reads: Y Index, Accumulator]
	lda $8B1C.w,X		; BD 1C 8B ; Load $8B1C.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,Y		; 99 50 0F ; Store accumulator to $0F50.w,Y [Reads: Y Index, Accumulator]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $0DA0.w,Y		; 99 A0 0D ; Store accumulator to $0DA0.w,Y [Reads: Y Index, Accumulator]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda #$62.b		; A9 62 ; Load #$62.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	.db $10, $03		; 10 03 ; Branch if plus to $10, $03 [Flow: branch]
	jmp $8CD0.w		; 4C D0 8C ; Jump to $8CD0.w [Flow: jump]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$04.b		; E9 04 ; Subtract #$04.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,Y		; 99 10 0D ; Store accumulator to $0D10.w,Y [Reads: Y Index, Accumulator]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc #$00.b		; E9 00 ; Subtract #$00.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0D30.w,Y		; 99 30 0D ; Store accumulator to $0D30.w,Y [Reads: Y Index, Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$04.b		; 69 04 ; Add #$04.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,Y		; 99 00 0D ; Store accumulator to $0D00.w,Y [Reads: Y Index, Accumulator]
	lda $03.b		; A5 03 ; Load $03.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D20.w,Y		; 99 20 0D ; Store accumulator to $0D20.w,Y [Reads: Y Index, Accumulator]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E80.w,Y		; 99 80 0E ; Store accumulator to $0E80.w,Y [Reads: Y Index, Accumulator]
	sta $0D90.w,Y		; 99 90 0D ; Store accumulator to $0D90.w,Y [Reads: Y Index, Accumulator]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E40.w,Y		; 99 40 0E ; Store accumulator to $0E40.w,Y [Reads: Y Index, Accumulator]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $8B0C.w,X		; BD 0C 8B ; Load $8B0C.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,Y		; 99 50 0D ; Store accumulator to $0D50.w,Y [Reads: Y Index, Accumulator]
	lda $8B14.w,X		; BD 14 8B ; Load $8B14.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,Y		; 99 40 0D ; Store accumulator to $0D40.w,Y [Reads: Y Index, Accumulator]
	lda $8B1A.w,X		; BD 1A 8B ; Load $8B1A.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,Y		; 99 C0 0D ; Store accumulator to $0DC0.w,Y [Reads: Y Index, Accumulator]
	lda $8B1E.w,X		; BD 1E 8B ; Load $8B1E.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,Y		; 99 50 0F ; Store accumulator to $0F50.w,Y [Reads: Y Index, Accumulator]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $0DA0.w,Y		; 99 A0 0D ; Store accumulator to $0DA0.w,Y [Reads: Y Index, Accumulator]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda #$62.b		; A9 62 ; Load #$62.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $4D		; 30 4D ; Branch if minus to $30, $4D [Flow: branch]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$04.b		; E9 04 ; Subtract #$04.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,Y		; 99 10 0D ; Store accumulator to $0D10.w,Y [Reads: Y Index, Accumulator]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc #$00.b		; E9 00 ; Subtract #$00.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0D30.w,Y		; 99 30 0D ; Store accumulator to $0D30.w,Y [Reads: Y Index, Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$04.b		; 69 04 ; Add #$04.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,Y		; 99 00 0D ; Store accumulator to $0D00.w,Y [Reads: Y Index, Accumulator]
	lda $03.b		; A5 03 ; Load $03.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D20.w,Y		; 99 20 0D ; Store accumulator to $0D20.w,Y [Reads: Y Index, Accumulator]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E80.w,Y		; 99 80 0E ; Store accumulator to $0E80.w,Y [Reads: Y Index, Accumulator]
	sta $0D90.w,Y		; 99 90 0D ; Store accumulator to $0D90.w,Y [Reads: Y Index, Accumulator]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E40.w,Y		; 99 40 0E ; Store accumulator to $0E40.w,Y [Reads: Y Index, Accumulator]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $8B0E.w,X		; BD 0E 8B ; Load $8B0E.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,Y		; 99 50 0D ; Store accumulator to $0D50.w,Y [Reads: Y Index, Accumulator]
	lda $8B16.w,X		; BD 16 8B ; Load $8B16.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,Y		; 99 40 0D ; Store accumulator to $0D40.w,Y [Reads: Y Index, Accumulator]
	lda $8B1A.w,X		; BD 1A 8B ; Load $8B1A.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,Y		; 99 C0 0D ; Store accumulator to $0DC0.w,Y [Reads: Y Index, Accumulator]
	lda $8B1E.w,X		; BD 1E 8B ; Load $8B1E.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,Y		; 99 50 0F ; Store accumulator to $0F50.w,Y [Reads: Y Index, Accumulator]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $0DA0.w,Y		; 99 A0 0D ; Store accumulator to $0DA0.w,Y [Reads: Y Index, Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda #$62.b		; A9 62 ; Load #$62.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $0F50.w,Y		; 99 50 0F ; Store accumulator to $0F50.w,Y [Reads: Y Index, Accumulator]
	lda $22.b		; A5 22 ; Load $22.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D10.w,Y		; 99 10 0D ; Store accumulator to $0D10.w,Y [Reads: Y Index, Accumulator]
	lda $23.b		; A5 23 ; Load $23.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D30.w,Y		; 99 30 0D ; Store accumulator to $0D30.w,Y [Reads: Y Index, Accumulator]
	lda $20.b		; A5 20 ; Load $20.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$08.b		; 69 08 ; Add #$08.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,Y		; 99 00 0D ; Store accumulator to $0D00.w,Y [Reads: Y Index, Accumulator]
	lda $21.b		; A5 21 ; Load $21.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D20.w,Y		; 99 20 0D ; Store accumulator to $0D20.w,Y [Reads: Y Index, Accumulator]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,Y		; 99 C0 0D ; Store accumulator to $0DC0.w,Y [Reads: Y Index, Accumulator]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E80.w,Y		; 99 80 0E ; Store accumulator to $0E80.w,Y [Reads: Y Index, Accumulator]
	lda #$40.b		; A9 40 ; Load #$40.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E40.w,Y		; 99 40 0E ; Store accumulator to $0E40.w,Y [Reads: Y Index, Accumulator]
	lda #$E4.b		; A9 E4 ; Load #$E4.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,Y		; 99 F0 0D ; Store accumulator to $0DF0.w,Y [Reads: Y Index, Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	lda $0F50.w,Y		; B9 50 0F ; Load $0F50.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $8D21.w,X		; BD 21 8D ; Load $8D21.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,Y		; 99 50 0D ; Store accumulator to $0D50.w,Y [Reads: Y Index, Accumulator]
	lda $8D25.w,X		; BD 25 8D ; Load $8D25.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,Y		; 99 40 0D ; Store accumulator to $0D40.w,Y [Reads: Y Index, Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr ($0004.w,X)		; FC 04 00 ; Jump to subroutine indirect indexed ($0004.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $FCFC.w,X		; FE FC FC ; Increment memory $FCFC.w,X [Reads: X Index] [Flags: NZ]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBA84.l		; 22 84 BA 0D ; Jump to subroutine long $0DBA84.l [Writes: Stack Pointer] [Flow: call]
	jsl $06DBF0.l		; 22 F0 DB 06 ; Jump to subroutine long $06DBF0.l [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sta $8D57.w		; 8D 57 8D ; Store accumulator to $8D57.w [Reads: Accumulator]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	sta $ED20.w		; 8D 20 ED ; Store accumulator to $ED20.w [Reads: Accumulator]
	sbc $F0BD.w,Y		; F9 BD F0 ; Subtract with carry $F0BD.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $0ED0.w		; 0D D0 0E ; Logical OR $0ED0.w with accumulator [Writes: Accumulator] [Flags: NZ]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$D0.b		; A9 D0 ; Load #$D0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D90.w,X		; 9D 90 0D ; Store accumulator to $0D90.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$F1.b		; 29 F1 ; Logical AND #$F1.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$0E.b		; 29 0E ; Logical AND #$0E.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0F50.w,X		; 1D 50 0F ; OR accumulator with memory $0F50.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $09		; D0 09 ; Branch if not equal to $D0, $09 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $F9ED.w		; 20 ED F9 ; Jump to subroutine at $F9ED.w [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0B		; D0 0B ; Branch if not equal to $D0, $0B [Flow: branch]
	asl $0D50.w,X		; 1E 50 0D ; Arithmetic shift left $0D50.w,X [Reads: X Index] [Flags: NCZ]
	asl $0D40.w,X		; 1E 40 0D ; Arithmetic shift left $0D40.w,X [Reads: X Index] [Flags: NCZ]
	lda #$06.b		; A9 06 ; Load #$06.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	inc $0E90.w,X		; FE 90 0E ; Increment memory $0E90.w,X [Reads: X Index] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sed		; F8 ; Set decimal flag [Flags: D]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cmp $C4.b,S		; C3 C4 ; Compare accumulator (stack relative) $C4.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	cmp ($D4.b,S),Y		; D3 D4 ; Compare accumulator (stack relative indirect indexed) ($D4.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	cpx #$20F0.w		; E0 F0 20 ; Compare #$20F0.w with X register [Reads: X Index] [Flags: NCZ]
	.db $50, $FA		; 50 FA ; Branch if overflow clear to $50, $FA [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx #$A505.w		; A2 05 A5 ; Load #$A505.w into X register [Writes: X Index] [Flags: NZ]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $8D96.w,X		; 7D 96 8D ; Add $8D96.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $8D9C.w,X		; 7D 9C 8D ; Add $8D9C.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $8DA2.w,X		; BD A2 8D ; Load $8DA2.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	lda $05.b		; A5 05 ; Load $05.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $E0		; 10 E0 ; Branch if plus to $10, $E0 [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	ldy #$A900.w		; A0 00 A9 ; Load #$A900.w into Y register [Writes: Y Index] [Flags: NZ]
	ora $22.b		; 05 22 ; Logical OR $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy $FE.b,X		; B4 FE ; Load Y register $FE.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	asl $60.b		; 06 60 ; Arithmetic shift left $60.b [Reads: Direct Page] [Flags: NCZ]
	.db $F0, $10		; F0 10 ; Branch if equal to $F0, $10 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $10		; F0 10 ; Branch if equal to $F0, $10 [Flow: branch]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$02.b		; 29 02 ; Logical AND #$02.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	jsr $8EE3.w		; 20 E3 8E ; Jump to subroutine at $8EE3.w [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	jsr $AB93.w		; 20 93 AB ; Jump to subroutine at $AB93.w [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0D		; D0 0D ; Branch if not equal to $D0, $0D [Flow: branch]
	lda #$70.b		; A9 70 ; Load #$70.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$01.b		; 49 01 ; Exclusive OR #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $8DD8.w,Y		; B9 D8 8D ; Load $8DD8.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $8DDA.w,Y		; B9 DA 8D ; Load $8DDA.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	jsr $F9ED.w		; 20 ED F9 ; Jump to subroutine at $F9ED.w [Writes: Stack Pointer] [Flow: call]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	jsr $3000.w		; 20 00 30 ; Jump to subroutine at $3000.w [Writes: Stack Pointer] [Flow: call]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $50.b		; 00 50 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $50.b		; 00 50 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $50.b		; 00 50 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $50.b		; 00 50 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; [PATTERN: Memory clearing operation] 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8E.b		; 00 8E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $9E9E.w,X		; 9E 9E 9E ; Store zero to $9E9E.w,X [Reads: X Index]
	stz $9E9E.w,X		; 9E 9E 9E ; Store zero to $9E9E.w,X [Reads: X Index]
	stx $9E8E.w		; [PATTERN: Memory clearing operation] 8E 8E 9E ; Store X register to $9E8E.w [Reads: X Index]
	stz $9E9E.w,X		; 9E 9E 9E ; Store zero to $9E9E.w,X [Reads: X Index]
	stz $8E9E.w,X		; 9E 9E 8E ; Store zero to $8E9E.w,X [Reads: X Index]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	bit #$89.b		; 89 89 ; Test bits #$89.b with accumulator [Reads: Accumulator] [Flags: Z]
	bit #$89.b		; 89 89 ; Test bits #$89.b with accumulator [Reads: Accumulator] [Flags: Z]
	bit #$89.b		; 89 89 ; Test bits #$89.b with accumulator [Reads: Accumulator] [Flags: Z]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	bit #$89.b		; 89 89 ; Test bits #$89.b with accumulator [Reads: Accumulator] [Flags: Z]
	bit #$89.b		; 89 89 ; Test bits #$89.b with accumulator [Reads: Accumulator] [Flags: Z]
	bit #$89.b		; 89 89 ; Test bits #$89.b with accumulator [Reads: Accumulator] [Flags: Z]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cpy #$4040.w		; C0 40 40 ; Compare #$4040.w with Y register [Reads: Y Index] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cpy #$0000.w		; C0 00 00 ; Compare #$0000.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr $FA50.w		; 20 50 FA ; Jump to subroutine at $FA50.w [Writes: Stack Pointer] [Flow: call]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $8EA1.w,Y		; B9 A1 8E ; Load $8EA1.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldy $0D80.w,X		; BC 80 0D ; Load Y register $0D80.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ldx $8EE1.w,Y		; BE E1 8E ; Load X register $8EE1.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ldy #$DA00.w		; A0 00 DA ; Load #$DA00.w into Y register [Writes: Y Index] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $06.b		; 65 06 ; Add $06.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $8E21.w,X		; 7D 21 8E ; Add $8E21.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	and #$0100.w		; 29 00 01 ; Logical AND #$0100.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E.b		; 85 0E ; Store accumulator to $0E.b [Reads: Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $8E61.w,X		; 7D 61 8E ; Add $8E61.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0010.w		; 69 10 00 ; Add #$0010.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0100.w		; C9 00 01 ; Compare #$0100.w with accumulator [Reads: Accumulator] [Flags: NCZ]
.ACCU 8
	sep #$20		; E2 20
	.db $90, $04		; 90 04 ; Branch if carry clear to $90, $04 [Flow: branch]
	lda #$F0.b		; A9 F0 ; Load #$F0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda $08.b		; A5 08 ; Load $08.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	lda $8EA1.w,X		; BD A1 8E ; Load $8EA1.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	stz $08.b		; 64 08 ; Store zero to $08.b
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $8EC1.w,X		; BD C1 8E ; Load $8EC1.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0F.b		; 05 0F ; Logical OR $0F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($92.b),Y		; 91 92 ; Store accumulator ($92.b),Y [Reads: Direct Page, Y Index, Accumulator]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $AB		; 10 AB ; Branch if plus to $10, $AB [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DB0.w,X		; BD B0 0D ; Load $0DB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0A		; F0 0A ; Branch if equal to $F0, $0A [Flow: branch]
	cmp #$01.b		; C9 01 ; Compare #$01.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	jmp $91B5.w		; 4C B5 91 ; Jump to $91B5.w [Flow: jump]
	jmp $92DA.w		; 4C DA 92 ; Jump to $92DA.w [Flow: jump]
	jsr $9068.w		; 20 68 90 ; Jump to subroutine at $9068.w [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	jsr $B88D.w		; 20 8D B8 ; Jump to subroutine at $B88D.w [Writes: Stack Pointer] [Flow: call]
	jsl $06F121.l		; 22 21 F1 06 ; Jump to subroutine long $06F121.l [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $32		; F0 32 ; Branch if equal to $F0, $32 [Flow: branch]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $25		; D0 25 ; Branch if not equal to $D0, $25 [Flow: branch]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0D		; D0 0D ; Branch if not equal to $D0, $0D [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$50.b		; A9 50 ; Load #$50.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	jsl $0DB85C.l		; 22 5C B8 0D ; Jump to subroutine long $0DB85C.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cmp #$0F.b		; C9 0F ; Compare #$0F.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $05		; D0 05 ; Branch if not equal to $D0, $05 [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	jsr $8FC2.w		; 20 C2 8F ; Jump to subroutine at $8FC2.w [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$0E.b		; 29 0E ; Logical AND #$0E.b with accumulator [Writes: Accumulator] [Flags: NZ]
	eor $0F50.w,X		; 5D 50 0F ; Exclusive OR accumulator with memory $0F50.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0B		; D0 0B ; Branch if not equal to $D0, $0B [Flow: branch]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0F.b		; 85 0F ; Store accumulator to $0F.b [Reads: Accumulator]
	jsr $C612.w		; 20 12 C6 ; Jump to subroutine at $C612.w [Writes: Stack Pointer] [Flow: call]
	inc $0DE0.w,X		; FE E0 0D ; Increment memory $0DE0.w,X [Reads: X Index] [Flags: NZ]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$3F.b		; 29 3F ; Logical AND #$3F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0B6A.w		; AD 6A 0B ; Load $0B6A.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$04.b		; C9 04 ; Compare #$04.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $F8		; B0 F8 ; Branch if carry set to $B0, $F8 [Flow: branch]
	lda #$61.b		; A9 61 ; Load #$61.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $F0		; 30 F0 ; Branch if minus to $30, $F0 [Flow: branch]
	lda #$19.b		; A9 19 ; Load #$19.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB8A.l		; 22 8A BB 0D ; Jump to subroutine long $0DBB8A.l [Writes: Stack Pointer] [Flow: call]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx #$AD00.w		; A2 00 AD ; Load #$AD00.w into X register [Writes: X Index] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	ora $CA0110.l		; 0F 10 01 CA ; OR accumulator with memory (long) $CA0110.l [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $00.b		; 65 00 ; Add $00.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,Y		; 99 10 0D ; Store accumulator to $0D10.w,Y [Reads: Y Index, Accumulator]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $01.b		; 65 01 ; Add $01.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D30.w,Y		; 99 30 0D ; Store accumulator to $0D30.w,Y [Reads: Y Index, Accumulator]
	ldx #$AD00.w		; A2 00 AD ; Load #$AD00.w into X register [Writes: X Index] [Flags: NZ]
	lda #$0F.b		; A9 0F ; Load #$0F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $10, $01		; 10 01 ; Branch if plus to $10, $01 [Flow: branch]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $02.b		; 65 02 ; Add $02.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,Y		; 99 00 0D ; Store accumulator to $0D00.w,Y [Reads: Y Index, Accumulator]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $03.b		; 65 03 ; Add $03.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D20.w,Y		; 99 20 0D ; Store accumulator to $0D20.w,Y [Reads: Y Index, Accumulator]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06EA12.l		; 22 12 EA 06 ; Jump to subroutine long $06EA12.l [Writes: Stack Pointer] [Flow: call]
	lda #$3F.b		; A9 3F ; Load #$3F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E40.w,Y		; 99 40 0E ; Store accumulator to $0E40.w,Y [Reads: Y Index, Accumulator]
	lda #$54.b		; A9 54 ; Load #$54.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F60.w,Y		; 99 60 0F ; Store accumulator to $0F60.w,Y [Reads: Y Index, Accumulator]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DB0.w,Y		; 99 B0 0D ; Store accumulator to $0DB0.w,Y [Reads: Y Index, Accumulator]
	lda #$48.b		; A9 48 ; Load #$48.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0CAA.w,Y		; 99 AA 0C ; Store accumulator to $0CAA.w,Y [Reads: Y Index, Accumulator]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,Y		; 99 50 0F ; Store accumulator to $0F50.w,Y [Reads: Y Index, Accumulator]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0CD2.w,Y		; 99 D2 0C ; Store accumulator to $0CD2.w,Y [Reads: Y Index, Accumulator]
	lda #$0C.b		; A9 0C ; Load #$0C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E00.w,Y		; 99 00 0E ; Store accumulator to $0E00.w,Y [Reads: Y Index, Accumulator]
	lda $0B6A.w		; AD 6A 0B ; Load $0B6A.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,Y		; 99 C0 0D ; Store accumulator to $0DC0.w,Y [Reads: Y Index, Accumulator]
	inc $0B6A.w		; EE 6A 0B ; Increment $0B6A.w [Flags: NZ]
	lda #$1F.b		; A9 1F ; Load #$1F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	ldx $0DC0.w,Y		; BE C0 0D ; Load X register $0DC0.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $91B1.w,X		; 7D B1 91 ; Add $91B1.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $0D10.w,Y		; B9 10 0D ; Load $0D10.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $7FFD80.l,X		; 9F 80 FD 7F ; Store accumulator (long,X) $7FFD80.l,X [Reads: Accumulator, X Index]
	lda $0D30.w,Y		; B9 30 0D ; Load $0D30.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $7FFE00.l,X		; 9F 00 FE 7F ; Store accumulator (long,X) $7FFE00.l,X [Reads: Accumulator, X Index]
	lda $0D00.w,Y		; B9 00 0D ; Load $0D00.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $7FFE80.l,X		; 9F 80 FE 7F ; Store accumulator (long,X) $7FFE80.l,X [Reads: Accumulator, X Index]
	lda $0D20.w,Y		; B9 20 0D ; Load $0D20.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $7FFF00.l,X		; 9F 00 FF 7F ; Store accumulator (long,X) $7FFF00.l,X [Reads: Accumulator, X Index]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	dec $00.b		; C6 00 ; Decrement $00.b [Reads: Direct Page] [Flags: NZ]
	.db $10, $DF		; 10 DF ; Branch if plus to $10, $DF [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $F0, $FF		; F0 FF ; Branch if equal to $F0, $FF [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	jsr $FA50.w		; 20 50 FA ; Jump to subroutine at $FA50.w [Writes: Stack Pointer] [Flow: call]
	ldy #$BD00.w		; A0 00 BD ; Load #$BD00.w into Y register [Writes: Y Index] [Flags: NZ]
	cpx #$C90D.w		; E0 0D C9 ; Compare #$C90D.w with X register [Reads: X Index] [Flags: NCZ]
	jsr $0AB0.w		; 20 B0 0A ; Jump to subroutine at $0AB0.w [Writes: Stack Pointer] [Flow: call]
	lda #$0C.b		; A9 0C ; Load #$0C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBA84.l		; 22 84 BA 0D ; Jump to subroutine long $0DBA84.l [Writes: Stack Pointer] [Flow: call]
	ldy #$8004.w		; A0 04 80 ; Load #$8004.w into Y register [Writes: Y Index] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	lda #$0C.b		; A9 0C ; Load #$0C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBA88.l		; 22 88 BA 0D ; Jump to subroutine long $0DBA88.l [Writes: Stack Pointer] [Flow: call]
	ldy #$DA00.w		; A0 00 DA ; Load #$DA00.w into Y register [Writes: Y Index] [Flags: NZ]
	ldx #$DA01.w		; A2 01 DA ; Load #$DA01.w into X register [Writes: X Index] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	and #$0100.w		; 29 00 01 ; Logical AND #$0100.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E.b		; 85 0E ; Store accumulator to $0E.b [Reads: Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $9062.w,X		; 7D 62 90 ; Add $9062.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0010.w		; 69 10 00 ; Add #$0010.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0100.w		; C9 00 01 ; Compare #$0100.w with accumulator [Reads: Accumulator] [Flags: NCZ]
.ACCU 8
	sep #$20		; E2 20
	.db $90, $04		; 90 04 ; Branch if carry clear to $90, $04 [Flow: branch]
	lda #$F0.b		; A9 F0 ; Load #$F0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda $9066.w,X		; BD 66 90 ; Load $9066.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $05.b		; A5 05 ; Load $05.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0F.b		; 05 0F ; Logical OR $0F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($92.b),Y		; 91 92 ; Store accumulator ($92.b),Y [Reads: Direct Page, Y Index, Accumulator]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $BD		; 10 BD ; Branch if plus to $10, $BD [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	jsr $9151.w		; 20 51 91 ; Jump to subroutine at $9151.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $020100.l,X		; FF 00 01 02 ; Subtract with carry (long,X) $020100.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tsb $0E0D.w		; 0C 0D 0E ; Test and set bits $0E0D.w [Reads: Accumulator] [Flags: Z]
	ora $0F1110.l		; 0F 10 11 0F ; OR accumulator with memory (long) $0F1110.l [Writes: Accumulator] [Flags: NZ]
	asl $0C0D.w		; 0E 0D 0C ; Arithmetic shift left $0C0D.w [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tsb $0E0D.w		; 0C 0D 0E ; Test and set bits $0E0D.w [Reads: Accumulator] [Flags: Z]
	asl $0F0F.w		; 0E 0F 0F ; Arithmetic shift left $0F0F.w [Flags: NCZ]
	ora $0F0F0F.l		; 0F 0F 0F 0F ; OR accumulator with memory (long) $0F0F0F.l [Writes: Accumulator] [Flags: NZ]
	asl $0D0E.w		; 0E 0E 0D ; Arithmetic shift left $0D0E.w [Flags: NCZ]
	tsb $0A0B.w		; 0C 0B 0A ; Test and set bits $0A0B.w [Reads: Accumulator] [Flags: Z]
	ora #$08.b		; 09 08 ; Logical OR #$08.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora #$0A.b		; 09 0A ; Logical OR #$0A.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	jmp $4C4C.w		; 4C 4C 4C ; Jump to $4C4C.w [Flow: jump]
	jmp $4C4C.w		; 4C 4C 4C ; Jump to $4C4C.w [Flow: jump]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	jmp $4C4C.w		; 4C 4C 4C ; Jump to $4C4C.w [Flow: jump]
	jmp $4C4C.w		; 4C 4C 4C ; Jump to $4C4C.w [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy #$BD08.w		; A0 08 BD ; Load #$BD08.w into Y register [Writes: Y Index] [Flags: NZ]
	cpx #$C90D.w		; E0 0D C9 ; Compare #$C90D.w with X register [Reads: X Index] [Flags: NCZ]
	jsr $02B0.w		; 20 B0 02 ; Jump to subroutine at $02B0.w [Writes: Stack Pointer] [Flow: call]
	ldy #$8400.w		; A0 00 84 ; Load #$8400.w into Y register [Writes: Y Index] [Flags: NZ]
	asl $0F64.w		; 0E 64 0F ; Arithmetic shift left $0F64.w [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $90D1.w,X		; BD D1 90 ; Load $90D1.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$03.b		; E9 03 ; Subtract #$03.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0FA8.w		; 8D A8 0F ; Store accumulator to $0FA8.w [Reads: Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $00.b		; 65 00 ; Add $00.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $90F1.w,X		; BD F1 90 ; Load $90F1.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$12.b		; E9 12 ; Subtract #$12.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0FA9.w		; 8D A9 0F ; Store accumulator to $0FA9.w [Reads: Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $02.b		; 65 02 ; Add $02.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $9111.w,X		; BD 11 91 ; Load $9111.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $05.b		; A5 05 ; Load $05.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$31.b		; 29 31 ; Logical AND #$31.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $9131.w,X		; 1D 31 91 ; OR accumulator with memory $9131.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$0A.b		; 09 0A ; Logical OR #$0A.b with accumulator [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	lda $0E.b		; A5 0E ; Load $0E.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $90.b		; 65 90 ; Add $90.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $90.b		; 85 90 ; Store accumulator to $90.b [Reads: Accumulator]
	lda $0E.b		; A5 0E ; Load $0E.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $92.b		; 65 92 ; Add $92.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $92.b		; 85 92 ; Store accumulator to $92.b [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	ldy #$9800.w		; A0 00 98 ; Load #$9800.w into Y register [Writes: Y Index] [Flags: NZ]
	jsl $06FEB4.l		; 22 B4 FE 06 ; Jump to subroutine long $06FEB4.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0E00.w,X		; BD 00 0E ; Load $0E00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $5D		; D0 5D ; Branch if not equal to $D0, $5D [Flow: branch]
	jsr $925B.w		; 20 5B 92 ; Jump to subroutine at $925B.w [Writes: Stack Pointer] [Flow: call]
	lda $0DD0.w,X		; BD D0 0D ; Load $0DD0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $04		; D0 04 ; Branch if not equal to $D0, $04 [Flow: branch]
	dec $0B6A.w		; CE 6A 0B ; Decrement $0B6A.w [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	ldy #$5A03.w		; A0 03 5A ; Load #$5A03.w into Y register [Writes: Y Index] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	lda $0D10.w,X		; BD 10 0D ; Load $0D10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda $0D30.w,X		; BD 30 0D ; Load $0D30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda $0D20.w,X		; BD 20 0D ; Load $0D20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$1F.b		; 29 1F ; Logical AND #$1F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ldy $0DC0.w,X		; BC C0 0D ; Load Y register $0DC0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $91B1.w,Y		; 79 B1 91 ; Add $91B1.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $7FFF00.l,X		; 9F 00 FF 7F ; Store accumulator (long,X) $7FFF00.l,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $7FFE80.l,X		; 9F 80 FE 7F ; Store accumulator (long,X) $7FFE80.l,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $7FFE00.l,X		; 9F 00 FE 7F ; Store accumulator (long,X) $7FFE00.l,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $7FFD80.l,X		; 9F 80 FD 7F ; Store accumulator (long,X) $7FFD80.l,X [Reads: Accumulator, X Index]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	jsr $F9ED.w		; 20 ED F9 ; Jump to subroutine at $F9ED.w [Writes: Stack Pointer] [Flow: call]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $10, $C2		; 10 C2 ; Branch if plus to $10, $C2 [Flow: branch]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0A		; F0 0A ; Branch if equal to $F0, $0A [Flow: branch]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $06		; D0 06 ; Branch if not equal to $D0, $06 [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	dec $0B6A.w		; CE 6A 0B ; Decrement $0B6A.w [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $06F129.l		; 22 29 F1 06 ; Jump to subroutine long $06F129.l [Writes: Stack Pointer] [Flow: call]
	.db $B0, $05		; B0 05 ; Branch if carry set to $B0, $05 [Flow: branch]
	jsr $B88D.w		; 20 8D B8 ; Jump to subroutine at $B88D.w [Writes: Stack Pointer] [Flow: call]
	.db $F0, $33		; F0 33 ; Branch if equal to $F0, $33 [Flow: branch]
	lda #$26.b		; A9 26 ; Load #$26.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB8A.l		; 22 8A BB 0D ; Jump to subroutine long $0DBB8A.l [Writes: Stack Pointer] [Flow: call]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	jsr $C4F9.w		; 20 F9 C4 ; Jump to subroutine at $C4F9.w [Writes: Stack Pointer] [Flow: call]
	lda #$61.b		; A9 61 ; Load #$61.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $18		; 30 18 ; Branch if minus to $30, $18 [Flow: branch]
	jsl $09AE64.l		; 22 64 AE 09 ; Jump to subroutine long $09AE64.l [Writes: Stack Pointer] [Flow: call]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,Y		; 99 F0 0D ; Store accumulator to $0DF0.w,Y [Reads: Y Index, Accumulator]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E40.w,Y		; 99 40 0E ; Store accumulator to $0E40.w,Y [Reads: Y Index, Accumulator]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DB0.w,Y		; 99 B0 0D ; Store accumulator to $0DB0.w,Y [Reads: Y Index, Accumulator]
	lda #$40.b		; A9 40 ; Load #$40.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E60.w,Y		; 99 60 0E ; Store accumulator to $0E60.w,Y [Reads: Y Index, Accumulator]
	lda #$80.b		; A9 80 ; Load #$80.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D20.w,X		; 9D 20 0D ; Store accumulator to $0D20.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $FA50.w		; 20 50 FA ; Jump to subroutine at $FA50.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $9257.w		; 20 57 92 ; Jump to subroutine at $9257.w [Writes: Stack Pointer] [Flow: call]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	lda #$1F.b		; A9 1F ; Load #$1F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D.b		; 85 0D ; Store accumulator to $0D.b [Reads: Accumulator]
	ldy $0DC0.w,X		; BC C0 0D ; Load Y register $0DC0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $91B1.w,Y		; 79 B1 91 ; Add $91B1.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ldy #$BF00.w		; A0 00 BF ; Load #$BF00.w into Y register [Writes: Y Index] [Flags: NZ]
	.db $80, $FD		; 80 FD ; Branch always to $80, $FD [Flow: branch]
	adc $BF0085.l,X		; 7F 85 00 BF ; Add long $BF0085.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $BF0185.l,X		; 7F 85 01 BF ; Add long $BF0185.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $FE		; 80 FE ; Branch always to $80, $FE [Flow: branch]
	adc $BF0285.l,X		; 7F 85 02 BF ; Add long $BF0285.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $C20385.l,X		; 7F 85 03 C2 ; Add long $C20385.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr $00A5.w		; 20 A5 00 ; Jump to subroutine at $00A5.w [Writes: Stack Pointer] [Flow: call]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $E2.b		; E5 E2 ; Subtract $E2.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	and #$00.b		; 29 00 ; Logical AND #$00.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($85.b,X)		; 01 85 ; Logical OR ($85.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $02A5.w		; 0E A5 02 ; Arithmetic shift left $02A5.w [Flags: NCZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $E8.b		; E5 E8 ; Subtract $E8.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$10.b		; 69 10 ; Add #$10.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	brk $C9.b		; 00 C9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
.ACCU 8
	sep #$20		; E2 20
	.db $90, $04		; 90 04 ; Branch if carry clear to $90, $04 [Flow: branch]
	lda #$F0.b		; A9 F0 ; Load #$F0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda #$5C.b		; A9 5C ; Load #$5C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $05.b		; A5 05 ; Load $05.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $0F.b		; A5 0F ; Load $0F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($92.b),Y		; 91 92 ; Store accumulator ($92.b),Y [Reads: Direct Page, Y Index, Accumulator]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	dec $0D.b		; C6 0D ; Decrement $0D.b [Reads: Direct Page] [Flags: NZ]
	.db $10, $A9		; 10 A9 ; Branch if plus to $10, $A9 [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr ($04FF.w,X)		; FC FF 04 ; Jump to subroutine indirect indexed ($04FF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FC0004.l,X		; FF 04 00 FC ; Subtract with carry (long,X) $FC0004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $04FFFC.l,X		; FF FC FF 04 ; Subtract with carry (long,X) $04FFFC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $86.b		; 46 86 ; Logical shift right $86.b [Reads: Direct Page] [Flags: NCZ]
	dec $BD.b		; C6 BD ; Decrement $BD.b [Reads: Direct Page] [Flags: NZ]
	.db $F0, $0D		; F0 0D ; Branch if equal to $F0, $0D [Flow: branch]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	jsr $FA50.w		; 20 50 FA ; Jump to subroutine at $FA50.w [Writes: Stack Pointer] [Flow: call]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx #$DA03.w		; A2 03 DA ; Load #$DA03.w into X register [Writes: X Index] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $92C6.w,X		; 7D C6 92 ; Add $92C6.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	and #$0100.w		; 29 00 01 ; Logical AND #$0100.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E.b		; 85 0E ; Store accumulator to $0E.b [Reads: Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $92CE.w,X		; 7D CE 92 ; Add $92CE.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0010.w		; 69 10 00 ; Add #$0010.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0100.w		; C9 00 01 ; Compare #$0100.w with accumulator [Reads: Accumulator] [Flags: NCZ]
.ACCU 8
	sep #$20		; E2 20
	.db $90, $04		; 90 04 ; Branch if carry clear to $90, $04 [Flow: branch]
	lda #$F0.b		; A9 F0 ; Load #$F0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda #$D6.b		; A9 D6 ; Load #$D6.b into accumulator [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $05.b		; A5 05 ; Load $05.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$30.b		; 29 30 ; Logical AND #$30.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $92D6.w,X		; 1D D6 92 ; OR accumulator with memory $92D6.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $0F.b		; A5 0F ; Load $0F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($92.b),Y		; 91 92 ; Store accumulator ($92.b),Y [Reads: Direct Page, Y Index, Accumulator]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $B7		; 10 B7 ; Branch if plus to $10, $B7 [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $04.b		; 06 04 ; Arithmetic shift left $04.b [Reads: Direct Page] [Flags: NCZ]
	jsl $06DBF0.l		; 22 F0 DB 06 ; Jump to subroutine long $06DBF0.l [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$06.b		; 49 06 ; Exclusive OR #$06.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $43		; D0 43 ; Branch if not equal to $D0, $43 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	jsr $B88D.w		; 20 8D B8 ; Jump to subroutine at $B88D.w [Writes: Stack Pointer] [Flow: call]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda #$FF.b		; A9 FF ; Load #$FF.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	jsr $B88D.w		; 20 8D B8 ; Jump to subroutine at $B88D.w [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	ora $0E70.w,X		; 1D 70 0E ; OR accumulator with memory $0E70.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$04.b		; C9 04 ; Compare #$04.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $09		; B0 09 ; Branch if carry set to $B0, $09 [Flow: branch]
	ldy #$2900.w		; A0 00 29 ; Load #$2900.w into Y register [Writes: Y Index] [Flags: NZ]
	ora ($D0.b,X)		; 01 D0 ; Logical OR ($D0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($C8.b,X)		; 01 C8 ; Logical OR ($C8.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $80, $07		; 80 07 ; Branch always to $80, $07 [Flow: branch]
	ldy #$2902.w		; A0 02 29 ; Load #$2902.w into Y register [Writes: Y Index] [Flags: NZ]
	tsb $D0.b		; 04 D0 ; Test and set bits $D0.b [Reads: Accumulator] [Flags: Z]
	ora ($C8.b,X)		; 01 C8 ; Logical OR ($C8.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda $0E20.w,X		; BD 20 0E ; Load $0E20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$5C.b		; C9 5C ; Compare #$5C.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	lda $9337.w,Y		; B9 37 93 ; Load $9337.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$3F.b		; 29 3F ; Logical AND #$3F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $9333.w,Y		; 19 33 93 ; OR accumulator with memory $9333.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	jsr $F9ED.w		; 20 ED F9 ; Jump to subroutine at $F9ED.w [Writes: Stack Pointer] [Flow: call]
	jsl $06F121.l		; 22 21 F1 06 ; Jump to subroutine long $06F121.l [Writes: Stack Pointer] [Flow: call]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $C359.w,Y		; B9 59 C3 ; Load $C359.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $C361.w,Y		; B9 61 C3 ; Load $C361.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	jsr $B88D.w		; 20 8D B8 ; Jump to subroutine at $B88D.w [Writes: Stack Pointer] [Flow: call]
	lda $0E10.w,X		; BD 10 0E ; Load $0E10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0F		; F0 0F ; Branch if equal to $F0, $0F [Flow: branch]
	cmp #$06.b		; C9 06 ; Compare #$06.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $1B		; D0 1B ; Branch if not equal to $D0, $1B [Flow: branch]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $C399.w,Y		; B9 99 C3 ; Load $C399.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	.db $80, $10		; 80 10 ; Branch always to $80, $10 [Flow: branch]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $0E70.w,X		; BD 70 0E ; Load $0E70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $C389.w,Y		; 39 89 C3 ; AND accumulator with memory $C389.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $05		; D0 05 ; Branch if not equal to $D0, $05 [Flow: branch]
	lda #$0A.b		; A9 0A ; Load #$0A.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E10.w,X		; 9D 10 0E ; Store accumulator to $0E10.w,X [Reads: Accumulator, X Index]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $0E70.w,X		; BD 70 0E ; Load $0E70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $C381.w,Y		; 39 81 C3 ; AND accumulator with memory $C381.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $06		; F0 06 ; Branch if equal to $F0, $06 [Flow: branch]
	lda $C391.w,Y		; B9 91 C3 ; Load $C391.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $C369.w,Y		; B9 69 C3 ; Load $C369.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $C371.w,Y		; B9 71 C3 ; Load $C371.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0E00.w,X		; BD 00 0E ; Load $0E00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $38		; D0 38 ; Branch if not equal to $D0, $38 [Flow: branch]
	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$BF.b		; 29 BF ; Logical AND #$BF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ldy $0D50.w,X		; BC 50 0D ; Load Y register $0D50.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	.db $30, $02		; 30 02 ; Branch if minus to $30, $02 [Flow: branch]
	ora #$40.b		; 09 40 ; Logical OR #$40.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	jsl $06DBF0.l		; 22 F0 DB 06 ; Jump to subroutine long $06DBF0.l [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	jsr $F9ED.w		; 20 ED F9 ; Jump to subroutine at $F9ED.w [Writes: Stack Pointer] [Flow: call]
	jsr $FA2E.w		; 20 2E FA ; Jump to subroutine at $FA2E.w [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sty $4C.b,X		; 94 4C ; Store Y register $4C.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	sty $9E.b,X		; 94 9E ; Store Y register $9E.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	cpy #$BD0D.w		; C0 0D BD ; Compare #$BD0D.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $80, $0F		; 80 0F ; Branch always to $80, $0F [Flow: branch]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	cmp #$F1.b		; C9 F1 ; Compare #$F1.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $10, $03		; 10 03 ; Branch if plus to $10, $03 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0F80.w,X		; BD 80 0F ; Load $0F80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	cmp #$10.b		; C9 10 ; Compare #$10.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $30, $03		; 30 03 ; Branch if minus to $30, $03 [Flow: branch]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0E00.w,X		; BD 00 0E ; Load $0E00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $41		; D0 41 ; Branch if not equal to $D0, $41 [Flow: branch]
	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$BF.b		; 29 BF ; Logical AND #$BF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ldy $0D50.w,X		; BC 50 0D ; Load Y register $0D50.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	.db $30, $02		; 30 02 ; Branch if minus to $30, $02 [Flow: branch]
	ora #$40.b		; 09 40 ; Logical OR #$40.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	jsl $06DBF0.l		; 22 F0 DB 06 ; Jump to subroutine long $06DBF0.l [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	jsr $F9ED.w		; 20 ED F9 ; Jump to subroutine at $F9ED.w [Writes: Stack Pointer] [Flow: call]
	jsr $FA2E.w		; 20 2E FA ; Jump to subroutine at $FA2E.w [Writes: Stack Pointer] [Flow: call]
	lda $0F80.w,X		; BD 80 0F ; Load $0F80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $0D		; 10 0D ; Branch if plus to $10, $0D [Flow: branch]
	stz $0F70.w,X		; 9E 70 0F ; Store zero to $0F70.w,X [Reads: X Index]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	lda #$0C.b		; A9 0C ; Load #$0C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy $0DF0.w,X		; BC F0 0D ; Load Y register $0DF0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	.db $F0, $01		; F0 01 ; Branch if equal to $F0, $01 [Flow: branch]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	trb $00E4.w		; 1C E4 00 ; Test and reset bits $00E4.w [Reads: Accumulator] [Flags: Z]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pea $1020.w		; F4 20 10 ; Push absolute address $1020.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sta $20.b,X		; 95 20 ; Store accumulator to $20.b,X [Reads: Accumulator, X Index]
	lsr $20F9.w		; 4E F9 20 ; Logical shift right $20F9.w [Flags: NCZ]
	adc ($F9.b),Y		; 71 F9 ; Add with carry ($F9.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr $AB93.w		; 20 93 AB ; Jump to subroutine at $AB93.w [Writes: Stack Pointer] [Flow: call]
	jsr $F9ED.w		; 20 ED F9 ; Jump to subroutine at $F9ED.w [Writes: Stack Pointer] [Flow: call]
	jsr $B88D.w		; 20 8D B8 ; Jump to subroutine at $B88D.w [Writes: Stack Pointer] [Flow: call]
	.db $D0, $05		; D0 05 ; Branch if not equal to $D0, $05 [Flow: branch]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $10		; D0 10 ; Branch if not equal to $D0, $10 [Flow: branch]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$3F.b		; 29 3F ; Logical AND #$3F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$20.b		; 69 20 ; Add #$20.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $94AF.w,Y		; B9 AF 94 ; Load $94AF.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $94B1.w,Y		; B9 B1 94 ; Load $94B1.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cpy #$9002.w		; C0 02 90 ; Compare #$9002.w with Y register [Reads: Y Index] [Flags: NCZ]
	cop $4A.b		; 02 4A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $F80008.l,X		; FF 08 00 F8 ; Subtract with carry (long,X) $F80008.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $8E0008.l,X		; FF 08 00 8E ; Subtract with carry (long,X) $8E0008.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	stx $AEAE.w		; 8E AE AE ; Store X register to $AEAE.w [Reads: X Index]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $FA50.w		; 20 50 FA ; Jump to subroutine at $FA50.w [Writes: Stack Pointer] [Flow: call]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx #$DA01.w		; A2 01 DA ; Load #$DA01.w into X register [Writes: X Index] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $06.b		; 65 06 ; Add $06.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $9500.w,X		; 7D 00 95 ; Add $9500.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	and #$0100.w		; 29 00 01 ; Logical AND #$0100.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E.b		; 85 0E ; Store accumulator to $0E.b [Reads: Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0010.w		; 69 10 00 ; Add #$0010.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0100.w		; C9 00 01 ; Compare #$0100.w with accumulator [Reads: Accumulator] [Flags: NCZ]
.ACCU 8
	sep #$20		; E2 20
	.db $90, $04		; 90 04 ; Branch if carry clear to $90, $04 [Flow: branch]
	lda #$F0.b		; A9 F0 ; Load #$F0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda $9508.w,X		; BD 08 95 ; Load $9508.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $950C.w,X		; BD 0C 95 ; Load $950C.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0F.b		; 05 0F ; Logical OR $0F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($92.b),Y		; 91 92 ; Store accumulator ($92.b),Y [Reads: Direct Page, Y Index, Accumulator]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $B5		; 10 B5 ; Branch if plus to $10, $B5 [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	jsl $06DC54.l		; 22 54 DC 06 ; Jump to subroutine long $06DC54.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $9626.w		; 20 26 96 ; Jump to subroutine at $9626.w [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	jsl $06F129.l		; 22 29 F1 06 ; Jump to subroutine long $06F129.l [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $90, $08		; 90 08 ; Branch if carry clear to $90, $08 [Flow: branch]
	jsl $0FF540.l		; 22 40 F5 0F ; Jump to subroutine long $0FF540.l [Writes: Stack Pointer] [Flow: call]
	jsl $079291.l		; 22 91 92 07 ; Jump to subroutine long $079291.l [Writes: Stack Pointer] [Flow: call]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0C		; D0 0C ; Branch if not equal to $D0, $0C [Flow: branch]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $07		; 30 07 ; Branch if minus to $30, $07 [Flow: branch]
	.db $D0, $13		; D0 13 ; Branch if not equal to $D0, $13 [Flow: branch]
	lda $02F0.w		; AD F0 02 ; Load $02F0.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $01		; D0 01 ; Branch if not equal to $D0, $01 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sta $0D80.w,X		; 9D 80 0D ; Store accumulator to $0D80.w,X [Reads: Accumulator, X Index]
	lda #$80.b		; A9 80 ; Load #$80.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda #$07.b		; A9 07 ; Load #$07.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012D.w		; 8D 2D 01 ; Store accumulator to $012D.w [Reads: Accumulator]
	.db $90, $16		; 90 16 ; Branch if carry clear to $90, $16 [Flow: branch]
	lda $46.b		; A5 46 ; Load $46.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $12		; D0 12 ; Branch if not equal to $D0, $12 [Flow: branch]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $46.b		; 85 46 ; Store accumulator to $46.b [Reads: Accumulator]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06EA12.l		; 22 12 EA 06 ; Jump to subroutine long $06EA12.l [Writes: Stack Pointer] [Flow: call]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $28.b		; 85 28 ; Store accumulator to $28.b [Reads: Accumulator]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $27.b		; 85 27 ; Store accumulator to $27.b [Reads: Accumulator]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $95FC.w,Y		; B9 FC 95 ; Load $95FC.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $95FE.w,Y		; B9 FE 95 ; Load $95FE.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	jsr $F9ED.w		; 20 ED F9 ; Jump to subroutine at $F9ED.w [Writes: Stack Pointer] [Flow: call]
	jsr $B88D.w		; 20 8D B8 ; Jump to subroutine at $B88D.w [Writes: Stack Pointer] [Flow: call]
	.db $F0, $09		; F0 09 ; Branch if equal to $F0, $09 [Flow: branch]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $9602.w,Y		; B9 02 96 ; Load $9602.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $02E4.w		; 8D E4 02 ; Store accumulator to $02E4.w [Reads: Accumulator]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $12		; D0 12 ; Branch if not equal to $D0, $12 [Flow: branch]
	inc $0ED0.w,X		; FE D0 0E ; Increment memory $0ED0.w,X [Reads: X Index] [Flags: NZ]
	lda $0ED0.w,X		; BD D0 0E ; Load $0ED0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$82.b		; C9 82 ; Compare #$82.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	lda #$80.b		; A9 80 ; Load #$80.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D80.w,X		; 9D 80 0D ; Store accumulator to $0D80.w,X [Reads: Accumulator, X Index]
	stz $02E4.w		; 9C E4 02 ; Store zero to $02E4.w
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $10, $F0		; 10 F0 ; Branch if plus to $10, $F0 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $F0		; 10 F0 ; Branch if plus to $10, $F0 [Flow: branch]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $8EFFF8.l,X		; FF F8 FF 8E ; Subtract with carry (long,X) $8EFFF8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $00408E.l,X		; FF 8E 40 00 ; Subtract with carry (long,X) $00408E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $F8.b		; 02 F8 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $AE0008.l,X		; FF 08 00 AE ; Subtract with carry (long,X) $AE0008.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $AE.b		; 00 AE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$01.b		; C9 01 ; Compare #$01.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $0A		; D0 0A ; Branch if not equal to $D0, $0A [Flow: branch]
	ldy #$8C1B.w		; A0 1B 8C ; Load #$8C1B.w into Y register [Writes: Y Index] [Flags: NZ]
	and $05A001.l		; 2F 01 A0 05 ; AND accumulator with memory (long) $05A001.l [Writes: Accumulator] [Flags: NZ]
	sty $012D.w		; 8C 2D 01 ; Store Y register to $012D.w [Reads: Y Index]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0FD8.w		; 6D D8 0F ; Add $0FD8.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0FD8.w		; 8D D8 0F ; Store accumulator to $0FD8.w [Reads: Accumulator]
	jsr $F93F.w		; 20 3F F9 ; Jump to subroutine at $F93F.w [Writes: Stack Pointer] [Flow: call]
	lda $0F.b		; A5 0F ; Load $0F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$20.b		; 69 20 ; Add #$20.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$40.b		; C9 40 ; Compare #$40.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $0F		; B0 0F ; Branch if carry set to $B0, $0F [Flow: branch]
	lda $0E.b		; A5 0E ; Load $0E.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$20.b		; 69 20 ; Add #$20.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$40.b		; C9 40 ; Compare #$40.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $06		; B0 06 ; Branch if carry set to $B0, $06 [Flow: branch]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBA84.l		; 22 84 BA 0D ; Jump to subroutine long $0DBA84.l [Writes: Stack Pointer] [Flow: call]
.ACCU 16
	rep #$20		; C2 20
	lda #$9606.w		; A9 06 96 ; Load #$9606.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jmp $8AB1.w		; 4C B1 8A ; Jump to $8AB1.w [Flow: jump]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	jsr ($0310.w,X)		; FC 10 03 ; Jump to subroutine indirect indexed ($0310.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	lda $0E90.w,X		; BD 90 0E ; Load $0E90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	jmp $9725.w		; 4C 25 97 ; Jump to $9725.w [Flow: jump]
	sta $0BA0.w,X		; 9D A0 0B ; Store accumulator to $0BA0.w,X [Reads: Accumulator, X Index]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $06		; F0 06 ; Branch if equal to $F0, $06 [Flow: branch]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBA88.l		; 22 88 BA 0D ; Jump to subroutine long $0DBA88.l [Writes: Stack Pointer] [Flow: call]
	jsl $06DBF8.l		; 22 F8 DB 06 ; Jump to subroutine long $06DBF8.l [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	jsl $09B020.l		; 22 20 B0 09 ; Jump to subroutine long $09B020.l [Writes: Stack Pointer] [Flow: call]
	jsl $06F121.l		; 22 21 F1 06 ; Jump to subroutine long $06F121.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $04		; 90 04 ; Branch if carry clear to $90, $04 [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $F9ED.w		; 20 ED F9 ; Jump to subroutine at $F9ED.w [Writes: Stack Pointer] [Flow: call]
	lda $1B.b		; A5 1B ; Load $1B.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $11		; F0 11 ; Branch if equal to $F0, $11 [Flow: branch]
	lda $0E00.w,X		; BD 00 0E ; Load $0E00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0C		; D0 0C ; Branch if not equal to $D0, $0C [Flow: branch]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $05		; D0 05 ; Branch if not equal to $D0, $05 [Flow: branch]
	jsr $B88D.w		; 20 8D B8 ; Jump to subroutine at $B88D.w [Writes: Stack Pointer] [Flow: call]
	.db $D0, $E4		; D0 E4 ; Branch if not equal to $D0, $E4 [Flow: branch]
	lda $02E0.w		; AD E0 02 ; Load $02E0.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $037B.w		; 0D 7B 03 ; Logical OR $037B.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $5E		; D0 5E ; Branch if not equal to $D0, $5E [Flow: branch]
	lda $0308.w		; AD 08 03 ; Load $0308.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $30, $59		; 30 59 ; Branch if minus to $30, $59 [Flow: branch]
	lda $7EF35A.l		; AF 5A F3 7E ; Load long $7EF35A.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $51		; 90 51 ; Branch if carry clear to $90, $51 [Flow: branch]
	lda $EE.b		; A5 EE ; Load $EE.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $0F20.w,X		; DD 20 0F ; Compare accumulator $0F20.w,X [Reads: X Index] [Flags: NCZ]
	.db $D0, $4A		; D0 4A ; Branch if not equal to $D0, $4A [Flow: branch]
	jsl $0683EA.l		; 22 EA 83 06 ; Jump to subroutine long $0683EA.l [Writes: Stack Pointer] [Flow: call]
	lda $2F.b		; A5 2F ; Load $2F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $3C.b		; A5 3C ; Load $3C.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	lda $966E.w,Y		; B9 6E 96 ; Load $966E.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $22.b		; A5 22 ; Load $22.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $966A.w,Y		; 79 6A 96 ; Add $966A.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $23.b		; A5 23 ; Load $23.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $9670.w,Y		; 79 70 96 ; Add $9670.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
	lda $9675.w,Y		; B9 75 96 ; Load $9675.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	lda $20.b		; A5 20 ; Load $20.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $9673.w,Y		; 79 73 96 ; Add $9673.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $01.b		; 85 01 ; Store accumulator to $01.b [Reads: Accumulator]
	lda $21.b		; A5 21 ; Load $21.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $09.b		; 85 09 ; Store accumulator to $09.b [Reads: Accumulator]
	lda $9677.w,Y		; B9 77 96 ; Load $9677.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $03.b		; 85 03 ; Store accumulator to $03.b [Reads: Accumulator]
	jsl $0683E6.l		; 22 E6 83 06 ; Jump to subroutine long $0683E6.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $0D		; 90 0D ; Branch if carry clear to $90, $0D [Flow: branch]
	jsl $06F6D5.l		; 22 D5 F6 06 ; Jump to subroutine long $06F6D5.l [Writes: Stack Pointer] [Flow: call]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	lda #$06.b		; A9 06 ; Load #$06.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB7C.l		; 22 7C BB 0D ; Jump to subroutine long $0DBB7C.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $06		; D0 06 ; Branch if not equal to $D0, $06 [Flow: branch]
	jsl $06E416.l		; 22 16 E4 06 ; Jump to subroutine long $06E416.l [Writes: Stack Pointer] [Flow: call]
	.db $80, $03		; 80 03 ; Branch always to $80, $03 [Flow: branch]
	jsr $98F5.w		; 20 F5 98 ; Jump to subroutine at $98F5.w [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $1F		; F0 1F ; Branch if equal to $F0, $1F [Flow: branch]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $09		; F0 09 ; Branch if equal to $F0, $09 [Flow: branch]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	jmp $9824.w		; 4C 24 98 ; Jump to $9824.w [Flow: jump]
	jmp $97F1.w		; 4C F1 97 ; Jump to $97F1.w [Flow: jump]
	jmp $97C5.w		; 4C C5 97 ; Jump to $97C5.w [Flow: jump]
	cpx #$F0E8.w		; E0 E8 F0 ; Compare #$F0E8.w with X register [Reads: X Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $10, $18		; 10 18 ; Branch if plus to $10, $18 [Flow: branch]
	jsr $FFFF.w		; 20 FF FF ; Jump to subroutine at $FFFF.w [Writes: Stack Pointer] [Flow: call]
	sbc $0000FF.l,X		; FF FF 00 00 ; Subtract with carry (long,X) $0000FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0BA0.w,X		; 9D A0 0B ; Store accumulator to $0BA0.w,X [Reads: Accumulator, X Index]
	.db $D0, $52		; D0 52 ; Branch if not equal to $D0, $52 [Flow: branch]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $974A.w,Y		; 79 4A 97 ; Add $974A.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,X		; 9D 10 0D ; Store accumulator to $0D10.w,X [Reads: Accumulator, X Index]
	lda $0DA0.w,X		; BD A0 0D ; Load $0DA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $9752.w,Y		; 79 52 97 ; Add $9752.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D30.w,X		; 9D 30 0D ; Store accumulator to $0D30.w,X [Reads: Accumulator, X Index]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $0DB0.w,X		; BD B0 0D ; Load $0DB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $974A.w,Y		; 79 4A 97 ; Add $974A.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,X		; 9D 00 0D ; Store accumulator to $0D00.w,X [Reads: Accumulator, X Index]
	lda $0EB0.w,X		; BD B0 0E ; Load $0EB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $9752.w,Y		; 79 52 97 ; Add $9752.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D20.w,X		; 9D 20 0D ; Store accumulator to $0D20.w,X [Reads: Accumulator, X Index]
	jsl $0684BD.l		; 22 BD 84 06 ; Jump to subroutine long $0684BD.l [Writes: Stack Pointer] [Flow: call]
	jsr $B88D.w		; 20 8D B8 ; Jump to subroutine at $B88D.w [Writes: Stack Pointer] [Flow: call]
	lda $0FA5.w		; AD A5 0F ; Load $0FA5.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$08.b		; C9 08 ; Compare #$08.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $10		; D0 10 ; Branch if not equal to $D0, $10 [Flow: branch]
	lda #$7F.b		; A9 7F ; Load #$7F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda $0E60.w,X		; BD 60 0E ; Load $0E60.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$40.b		; 09 40 ; Logical OR #$40.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E60.w,X		; 9D 60 0E ; Store accumulator to $0E60.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0BA0.w,X		; 9D A0 0B ; Store accumulator to $0BA0.w,X [Reads: Accumulator, X Index]
	.db $D0, $11		; D0 11 ; Branch if not equal to $D0, $11 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$7F.b		; A9 7F ; Load #$7F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda $0E60.w,X		; BD 60 0E ; Load $0E60.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$BF.b		; 29 BF ; Logical AND #$BF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E60.w,X		; 9D 60 0E ; Store accumulator to $0E60.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $97B5.w,Y		; B9 B5 97 ; Load $97B5.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $0A.b		; 06 0A ; Arithmetic shift left $0A.b [Reads: Direct Page] [Flags: NCZ]
	asl $05.b		; 06 05 ; Arithmetic shift left $05.b [Reads: Direct Page] [Flags: NCZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $AB93.w		; 20 93 AB ; Jump to subroutine at $AB93.w [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $09		; D0 09 ; Branch if not equal to $D0, $09 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$17.b		; A9 17 ; Load #$17.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cmp #$30.b		; C9 30 ; Compare #$30.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $06		; D0 06 ; Branch if not equal to $D0, $06 [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	jsl $0DDA06.l		; 22 06 DA 0D ; Jump to subroutine long $0DDA06.l [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $97E9.w,Y		; B9 E9 97 ; Load $97E9.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tsb $090B.w		; 0C 0B 09 ; Test and set bits $090B.w [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0C		; [PATTERN: Memory clearing operation] D0 0C ; Branch if not equal to $D0, $0C [Flow: branch]
	lda #$80.b		; A9 80 ; Load #$80.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	stz $0DC0.w,X		; 9E C0 0D ; Store zero to $0DC0.w,X [Reads: X Index]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $9818.w,Y		; B9 18 98 ; Load $9818.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($0BFF.w,X)		; FC FF 0B ; Jump to subroutine indirect indexed ($0BFF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $F80012.l,X		; FF 12 00 F8 ; Subtract with carry (long,X) $F80012.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $040012.l,X		; FF 12 00 04 ; Subtract with carry (long,X) $040012.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FD0000.l,X		; FF 00 00 FD ; Subtract with carry (long,X) $FD0000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FDFFFD.l,X		; FF FD FF FD ; Subtract with carry (long,X) $FDFFFD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FDFFFD.l,X		; FF FD FF FD ; Subtract with carry (long,X) $FDFFFD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FDFFFD.l,X		; FF FD FF FD ; Subtract with carry (long,X) $FDFFFD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FAFFFA.l,X		; FF FA FF FA ; Subtract with carry (long,X) $FAFFFA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F7FFF8.l,X		; FF F8 FF F7 ; Subtract with carry (long,X) $F7FFF8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $05FFFD.l,X		; FF FD FF 05 ; Subtract with carry (long,X) $05FFFD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $F6.b		; 00 F6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $F6FFF5.l,X		; FF F5 FF F6 ; Subtract with carry (long,X) $F6FFF5.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $A8FFF5.l,X		; FF F5 FF A8 ; Subtract with carry (long,X) $A8FFF5.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ldy $88.b		; A4 88 ; Load $88.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	ldy $A4.b		; A4 A4 ; Load $A4.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	ldy $A6.b		; A4 A6 ; Load $A6.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	ldx $A4.b		; A6 A4 ; Load $A4.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	cpy #$8A8A.w		; C0 8A 8A ; Compare #$8A8A.w with Y register [Reads: Y Index] [Flags: NCZ]
	ldx $A6AF.w		; AE AF A6 ; Load $A6AF.w into X register [Writes: X Index] [Flags: NZ]
	sta $CFCF.w		; 8D CF CF ; Store accumulator to $CFCF.w [Reads: Accumulator]
	cmp $2525DF.l,X		; DF DF 25 25 ; Compare accumulator (long,X) $2525DF.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	and $25.b		; 25 25 ; Logical AND $25.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $E5.b		; E5 E5 ; Subtract $E5.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and $20.b		; 25 20 ; Logical AND $20.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $20.b		; E5 20 ; Subtract $20.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jsr $2020.w		; 20 20 20 ; Jump to subroutine at $2020.w [Writes: Stack Pointer] [Flow: call]
	jsr $2420.w		; 20 20 24 ; Jump to subroutine at $2420.w [Writes: Stack Pointer] [Flow: call]
	and $25.b		; [PATTERN: Memory clearing operation] 25 25 ; Logical AND $25.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $64.b		; 24 64 ; Test bits $64.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	jsr $2426.w		; 20 26 24 ; Jump to subroutine at $2426.w [Writes: Stack Pointer] [Flow: call]
	stz $24.b		; 64 24 ; Store zero to $24.b
	stz $00.b		; 64 00 ; Store zero to $00.b
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $50, $FA		; 50 FA ; Branch if overflow clear to $50, $FA [Flow: branch]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx #$DA01.w		; A2 01 DA ; Load #$DA01.w into X register [Writes: X Index] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $06.b		; 65 06 ; Add $06.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $983F.w,X		; 7D 3F 98 ; Add $983F.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	and #$0100.w		; 29 00 01 ; Logical AND #$0100.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E.b		; 85 0E ; Store accumulator to $0E.b [Reads: Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $9873.w,X		; 7D 73 98 ; Add $9873.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0010.w		; 69 10 00 ; Add #$0010.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0100.w		; C9 00 01 ; Compare #$0100.w with accumulator [Reads: Accumulator] [Flags: NCZ]
.ACCU 8
	sep #$20		; E2 20
	.db $90, $04		; 90 04 ; Branch if carry clear to $90, $04 [Flow: branch]
	lda #$F0.b		; A9 F0 ; Load #$F0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda $98A7.w,X		; BD A7 98 ; Load $98A7.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda #$0F.b		; A9 0F ; Load #$0F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D.b		; 85 0D ; Store accumulator to $0D.b [Reads: Accumulator]
	lda $98C1.w,X		; BD C1 98 ; Load $98C1.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	bit $0D.b		; 24 0D ; Test bits $0D.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	.db $D0, $02		; D0 02 ; Branch if not equal to $D0, $02 [Flow: branch]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $98DB.w,X		; BD DB 98 ; Load $98DB.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $0F.b		; 05 0F ; Logical OR $0F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($92.b),Y		; 91 92 ; Store accumulator ($92.b),Y [Reads: Direct Page, Y Index, Accumulator]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $A8		; 10 A8 ; Branch if plus to $10, $A8 [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $9CAB.w		; 20 AB 9C ; Jump to subroutine at $9CAB.w [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	sta $99D9.w,Y		; 99 D9 99 ; Store accumulator to $99D9.w,Y [Reads: Y Index, Accumulator]
	ora [$9A.b],Y		; 17 9A ; OR accumulator with memory (long indexed) [$9A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr $9A.b		; 46 9A ; Logical shift right $9A.b [Reads: Direct Page] [Flags: NCZ]
	cpx $9A.b		; E4 9A ; Compare $9A.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $50, $70		; 50 70 ; Branch if overflow clear to $50, $70 [Flow: branch]
	.db $50, $C2		; 50 C2 ; Branch if overflow clear to $50, $C2 [Flow: branch]
	jsr $22A5.w		; 20 A5 22 ; Jump to subroutine at $22A5.w [Writes: Stack Pointer] [Flow: call]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $0FD8.w		; ED D8 0F ; Subtract $0FD8.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$10.b		; 69 10 ; Add #$10.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	brk $C9.b		; 00 C9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $B000.w		; 20 00 B0 ; Jump to subroutine at $B000.w [Writes: Stack Pointer] [Flow: call]
	eor [$A5.b]		; 47 A5 ; Exclusive OR accumulator with memory (long) [$A5.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $ED38.w		; 20 38 ED ; Jump to subroutine at $ED38.w [Writes: Stack Pointer] [Flow: call]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ora $306918.l		; 0F 18 69 30 ; OR accumulator with memory (long) $306918.l [Writes: Accumulator] [Flags: NZ]
	brk $C9.b		; 00 C9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $B0.b		; 00 B0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
.ACCU 8
	sep #$20		; E2 20
	jsl $0791B9.l		; 22 B9 91 07 ; Jump to subroutine long $0791B9.l [Writes: Stack Pointer] [Flow: call]
	lda #$7F.b		; A9 7F ; Load #$7F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda #$35.b		; A9 35 ; Load #$35.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012E.w		; 8D 2E 01 ; Store accumulator to $012E.w [Reads: Accumulator]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	ldy #$CC0F.w		; A0 0F CC ; Load #$CC0F.w into Y register [Writes: Y Index] [Flags: NZ]
	ldy #$F00F.w		; A0 0F F0 ; Load #$F00F.w into Y register [Writes: Y Index] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	lda $0CAA.w,Y		; B9 AA 0C ; Load $0CAA.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $16		; 30 16 ; Branch if minus to $30, $16 [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	lda $0DD0.w,X		; [PATTERN: Memory clearing operation] BD D0 0D ; Load $0DD0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$0A.b		; C9 0A ; Compare #$0A.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $06		; D0 06 ; Branch if not equal to $D0, $06 [Flow: branch]
	stz $0308.w		; 9C 08 03 ; Store zero to $0308.w
	stz $0309.w		; 9C 09 03 ; Store zero to $0309.w
	jsl $09F1F8.l		; 22 F8 F1 09 ; Jump to subroutine long $09F1F8.l [Writes: Stack Pointer] [Flow: call]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $10, $DD		; 10 DD ; Branch if plus to $10, $DD [Flow: branch]
.ACCU 8
	sep #$20		; E2 20
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $14		; D0 14 ; Branch if not equal to $D0, $14 [Flow: branch]
	inc $0D80.w,X		; [PATTERN: Memory clearing operation] FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$7F.b		; A9 7F ; Load #$7F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	stz $011A.w		; 9C 1A 01 ; Store zero to $011A.w
	stz $011B.w		; 9C 1B 01 ; Store zero to $011B.w
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $99D5.w,Y		; B9 D5 99 ; Load $99D5.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $011A.w		; 8D 1A 01 ; Store accumulator to $011A.w [Reads: Accumulator]
	lda $99D7.w,Y		; B9 D7 99 ; Load $99D7.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $011B.w		; 8D 1B 01 ; Store accumulator to $011B.w [Reads: Accumulator]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $02E4.w		; 8D E4 02 ; Store accumulator to $02E4.w [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$08.b		; 09 08 ; Logical OR #$08.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$08.b		; 09 08 ; Logical OR #$08.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $09		; D0 09 ; Branch if not equal to $D0, $09 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$7F.b		; A9 7F ; Load #$7F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cmp #$1C.b		; C9 1C ; Compare #$1C.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $0A		; D0 0A ; Branch if not equal to $D0, $0A [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda #$0F.b		; A9 0F ; Load #$0F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E10.w,X		; 9D 10 0E ; Store accumulator to $0E10.w,X [Reads: Accumulator, X Index]
	jsr $9B40.w		; 20 40 9B ; Jump to subroutine at $9B40.w [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $9A07.w,Y		; B9 07 9A ; Load $9A07.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $09		; D0 09 ; Branch if not equal to $D0, $09 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$24.b		; A9 24 ; Load #$24.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $9A3E.w,Y		; B9 3E 9A ; Load $9A3E.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$50.b		; C9 50 ; Compare #$50.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $0D		; F0 0D ; Branch if equal to $F0, $0D [Flow: branch]
	cmp #$4F.b		; C9 4F ; Compare #$4F.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $18		; F0 18 ; Branch if equal to $F0, $18 [Flow: branch]
	cmp #$4E.b		; C9 4E ; Compare #$4E.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $1F		; F0 1F ; Branch if equal to $F0, $1F [Flow: branch]
	cmp #$4D.b		; C9 4D ; Compare #$4D.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $53		; F0 53 ; Branch if equal to $F0, $53 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$42.b		; A9 42 ; Load #$42.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1CF0.w		; 8D F0 1C ; Store accumulator to $1CF0.w [Reads: Accumulator]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1CF1.w		; 8D F1 1C ; Store accumulator to $1CF1.w [Reads: Accumulator]
	jsl $05FA8E.l		; 22 8E FA 05 ; Jump to subroutine long $05FA8E.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $1CE8.w		; AD E8 1C ; Load $1CE8.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $26		; D0 26 ; Branch if not equal to $D0, $26 [Flow: branch]
	lda #$43.b		; A9 43 ; Load #$43.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $9A75.w		; 20 75 9A ; Jump to subroutine at $9A75.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $1CE8.w		; AD E8 1C ; Load $1CE8.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $26		; D0 26 ; Branch if not equal to $D0, $26 [Flow: branch]
.ACCU 16
	rep #$20		; C2 20
	lda $7EF360.l		; AF 60 F3 7E ; Load long $7EF360.l into accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$01F4.w		; E9 F4 01 ; Subtract #$01F4.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	.db $90, $1A		; 90 1A ; Branch if carry clear to $90, $1A [Flow: branch]
	sta $7EF360.l		; 8F 60 F3 7E ; Store accumulator (long) $7EF360.l [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	lda #$44.b		; A9 44 ; Load #$44.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $9A75.w		; 20 75 9A ; Jump to subroutine at $9A75.w [Writes: Stack Pointer] [Flow: call]
	inc $0E90.w,X		; FE 90 0E ; Increment memory $0E90.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$46.b		; A9 46 ; Load #$46.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $9A75.w		; 20 75 9A ; Jump to subroutine at $9A75.w [Writes: Stack Pointer] [Flow: call]
	lda #$30.b		; A9 30 ; Load #$30.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

.ACCU 8
	sep #$20		; E2 20
	lda #$45.b		; A9 45 ; Load #$45.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $9A75.w		; 20 75 9A ; Jump to subroutine at $9A75.w [Writes: Stack Pointer] [Flow: call]
	lda #$30.b		; A9 30 ; Load #$30.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0E90.w,X		; BD 90 0E ; Load $0E90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	jsl $1DE1AA.l		; 22 AA E1 1D ; Jump to subroutine long $1DE1AA.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tsb $0C0C.w		; 0C 0C 0C ; Test and set bits $0C0C.w [Reads: Accumulator] [Flags: Z]
	tsb $0C0C.w		; 0C 0C 0C ; Test and set bits $0C0C.w [Reads: Accumulator] [Flags: Z]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	jsl $09F1F8.l		; 22 F8 F1 09 ; Jump to subroutine long $09F1F8.l [Writes: Stack Pointer] [Flow: call]
	stz $02E4.w		; 9C E4 02 ; Store zero to $02E4.w
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cmp #$1D.b		; C9 1D ; Compare #$1D.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $0A		; D0 0A ; Branch if not equal to $D0, $0A [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda #$0F.b		; A9 0F ; Load #$0F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E10.w,X		; 9D 10 0E ; Store accumulator to $0E10.w,X [Reads: Accumulator, X Index]
	jsr $9B40.w		; 20 40 9B ; Jump to subroutine at $9B40.w [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $9ACF.w,Y		; B9 CF 9A ; Load $9ACF.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sed		; F8 ; Set decimal flag [Flags: D]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	tsb $0D.b		; 04 0D ; Test and set bits $0D.b [Reads: Accumulator] [Flags: Z]
	.db $10, $0D		; 10 0D ; Branch if plus to $10, $0D [Flow: branch]
	tsb $FB.b		; 04 FB ; Test and set bits $FB.b [Reads: Accumulator] [Flags: Z]
	sbc $0000FF.l,X		; FF FF 00 00 ; Subtract with carry (long,X) $0000FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $FB.b		; 04 FB ; Test and set bits $FB.b [Reads: Accumulator] [Flags: Z]
	sed		; F8 ; Set decimal flag [Flags: D]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	tsb $0D.b		; 04 0D ; Test and set bits $0D.b [Reads: Accumulator] [Flags: Z]
	.db $10, $0D		; 10 0D ; Branch if plus to $10, $0D [Flow: branch]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0000FF.l,X		; FF FF 00 00 ; Subtract with carry (long,X) $0000FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $8B.b		; 06 8B ; Arithmetic shift left $8B.b [Reads: Direct Page] [Flags: NCZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $9B40.w		; 20 40 9B ; Jump to subroutine at $9B40.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$24.b		; A9 24 ; Load #$24.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB7C.l		; 22 7C BB 0D ; Jump to subroutine long $0DBB7C.l [Writes: Stack Pointer] [Flow: call]
	nop		; EA ; No operation
	lda #$07.b		; A9 07 ; Load #$07.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D.b		; 85 0D ; Store accumulator to $0D.b [Reads: Accumulator]
	lda #$08.b		; A9 08 ; Load #$08.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $63		; 30 63 ; Branch if minus to $30, $63 [Flow: branch]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DD0.w,Y		; 99 D0 0D ; Store accumulator to $0DD0.w,Y [Reads: Y Index, Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx $0D.b		; A6 0D ; Load $0D.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	lda $9B08.w,X		; BD 08 9B ; Load $9B08.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$04.b		; E9 04 ; Subtract #$04.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $00.b		; 65 00 ; Add $00.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,Y		; 99 10 0D ; Store accumulator to $0D10.w,Y [Reads: Y Index, Accumulator]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $9B10.w,X		; 7D 10 9B ; Add $9B10.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D30.w,Y		; 99 30 0D ; Store accumulator to $0D30.w,Y [Reads: Y Index, Accumulator]
	lda $9B18.w,X		; BD 18 9B ; Load $9B18.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$04.b		; E9 04 ; Subtract #$04.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $02.b		; 65 02 ; Add $02.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,Y		; 99 00 0D ; Store accumulator to $0D00.w,Y [Reads: Y Index, Accumulator]
	lda $03.b		; A5 03 ; Load $03.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $9B20.w,X		; 7D 20 9B ; Add $9B20.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D20.w,Y		; 99 20 0D ; Store accumulator to $0D20.w,Y [Reads: Y Index, Accumulator]
	lda $9B28.w,X		; BD 28 9B ; Load $9B28.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,Y		; 99 50 0D ; Store accumulator to $0D50.w,Y [Reads: Y Index, Accumulator]
	lda $9B30.w,X		; BD 30 9B ; Load $9B30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,Y		; 99 40 0D ; Store accumulator to $0D40.w,Y [Reads: Y Index, Accumulator]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D90.w,Y		; 99 90 0D ; Store accumulator to $0D90.w,Y [Reads: Y Index, Accumulator]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	and #$0F.b		; 29 0F ; Logical AND #$0F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$18.b		; 69 18 ; Add #$18.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0F80.w,Y		; 99 80 0F ; Store accumulator to $0F80.w,Y [Reads: Y Index, Accumulator]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D80.w,Y		; 99 80 0D ; Store accumulator to $0D80.w,Y [Reads: Y Index, Accumulator]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F70.w,Y		; 99 70 0F ; Store accumulator to $0F70.w,Y [Reads: Y Index, Accumulator]
	lda $0E60.w,Y		; B9 60 0E ; Load $0E60.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora #$40.b		; 09 40 ; Logical OR #$40.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E60.w,Y		; 99 60 0E ; Store accumulator to $0E60.w,Y [Reads: Y Index, Accumulator]
	sta $0BA0.w,Y		; 99 A0 0B ; Store accumulator to $0BA0.w,Y [Reads: Y Index, Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	dec $0D.b		; C6 0D ; Decrement $0D.b [Reads: Direct Page] [Flags: NZ]
	.db $10, $91		; 10 91 ; Branch if plus to $10, $91 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc [$09.b],Y		; F7 09 ; Subtract with carry (long indexed) [$09.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$09.b],Y		; F7 09 ; Subtract with carry (long indexed) [$09.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $0A.b,X		; F6 0A ; Increment memory $0A.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	inc $0A.b,X		; F6 0A ; Increment memory $0A.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	sbc $0B.b,X		; F5 0B ; Subtract $0B.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $0B.b,X		; F5 0B ; Subtract $0B.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $FEEE.w		; EE EE FE ; Increment $FEEE.w [Flags: NZ]
	inc $EEEE.w,X		; FE EE EE ; Increment memory $EEEE.w,X [Reads: X Index] [Flags: NZ]
	inc $EEFE.w,X		; FE FE EE ; Increment memory $EEFE.w,X [Reads: X Index] [Flags: NZ]
	inc $FEFE.w		; EE FE FE ; Increment $FEFE.w [Flags: NZ]
	pea $04F4.w		; F4 F4 04 ; Push absolute address $04F4.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpy #$E0C0.w		; C0 C0 E0 ; Compare #$E0C0.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpx #$EAC2.w		; E0 C2 EA ; Compare #$EAC2.w with X register [Reads: X Index] [Flags: NCZ]
.ACCU 8
	sep #$E2		; E2 E2
	nop		; EA ; No operation
.ACCU 16
	rep #$E2		; C2 E2
	sep #$C0		; E2 C0 ; Set processor status bits #$C0 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	cpy #$E6E4.w		; C0 E4 E6 ; Compare #$E6E4.w with Y register [Reads: Y Index] [Flags: NCZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cpy $C6.b		; C4 C6 ; Compare $C6.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	cpx $E6.b		; E4 E6 ; Compare $E6.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	dec $C4.b		; C6 C4 ; Decrement $C4.b [Reads: Direct Page] [Flags: NZ]
	inc $E4.b		; E6 E4 ; Increment $E4.b [Reads: Direct Page] [Flags: NZ]
	inc $E4.b		; E6 E4 ; Increment $E4.b [Reads: Direct Page] [Flags: NZ]
	dec $C4.b		; C6 C4 ; Decrement $C4.b [Reads: Direct Page] [Flags: NZ]
	cpx $E6.b		; E4 E6 ; Compare $E6.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	cpy $C6.b		; C4 C6 ; Compare $C6.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $C5.b		; C5 C5 ; Compare $C5.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp $C5.b		; C5 C5 ; Compare $C5.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $45.b		; 45 45 ; Exclusive OR $45.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $45.b		; 45 45 ; Exclusive OR $45.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $C5.b		; C5 C5 ; Compare $C5.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp $C5.b		; C5 C5 ; Compare $C5.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sta $85.b		; 85 85 ; Store accumulator to $85.b [Reads: Accumulator]
	sta $85.b		; 85 85 ; Store accumulator to $85.b [Reads: Accumulator]
	tsb $44.b		; 04 44 ; Test and set bits $44.b [Reads: Accumulator] [Flags: Z]
	sty $C4.b		; 84 C4 ; Store Y register to $C4.b [Reads: Y Index]
	tsb $44.b		; 04 44 ; Test and set bits $44.b [Reads: Accumulator] [Flags: Z]
	sty $C4.b		; 84 C4 ; Store Y register to $C4.b [Reads: Y Index]
	tsb $44.b		; 04 44 ; Test and set bits $44.b [Reads: Accumulator] [Flags: Z]
	sty $C4.b		; 84 C4 ; Store Y register to $C4.b [Reads: Y Index]
	sbc #$1717.w		; E9 17 17 ; Subtract #$1717.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ora [$EC.b],Y		; 17 EC ; OR accumulator with memory (long indexed) [$EC.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($0D.b),Y		; F1 0D ; Subtract with carry ($0D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($F8.b)		; 12 F8 ; OR accumulator with memory (indirect) ($F8.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $0000.w,Y		; F9 00 00 ; Subtract with carry $0000.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $AEAE.w,Y		; F9 AE AE ; Subtract with carry $AEAE.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx $ACAE.w		; AE AE AC ; Load $ACAE.w into X register [Writes: X Index] [Flags: NZ]
	ldy $ACAC.w		; AC AC AC ; Load $ACAC.w into Y register [Writes: Y Index] [Flags: NZ]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	jsr $FA50.w		; 20 50 FA ; Jump to subroutine at $FA50.w [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$9002.w		; C9 02 90 ; Compare #$9002.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx #$DA03.w		; A2 03 DA ; Load #$DA03.w into X register [Writes: X Index] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $06.b		; 65 06 ; Add $06.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $9BBB.w,X		; 7D BB 9B ; Add $9BBB.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	lda $9BEF.w,X		; BD EF 9B ; Load $9BEF.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $02.b		; 65 02 ; Add $02.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $9C23.w,X		; BD 23 9C ; Load $9C23.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda #$850F.w		; A9 0F 85 ; Load #$850F.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $9C57BD.l		; 0F BD 57 9C ; OR accumulator with memory (long) $9C57BD.l [Writes: Accumulator] [Flags: NZ]
	bit $0F.b		; 24 0F ; Test bits $0F.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	.db $D0, $02		; D0 02 ; Branch if not equal to $D0, $02 [Flow: branch]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ora #$9120.w		; 09 20 91 ; Logical OR #$9120.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $90, $C8		; 90 C8 ; Branch if carry clear to $90, $C8 [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $CC		; 10 CC ; Branch if plus to $10, $CC [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	ldy #$A902.w		; A0 02 A9 ; Load #$A902.w into Y register [Writes: Y Index] [Flags: NZ]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldy $FE.b,X		; B4 FE ; Load Y register $FE.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	asl $20.b		; 06 20 ; Arithmetic shift left $20.b [Reads: Direct Page] [Flags: NCZ]
	.db $50, $FA		; 50 FA ; Branch if overflow clear to $50, $FA [Flow: branch]
	lda $0E10.w,X		; BD 10 0E ; Load $0E10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $45		; F0 45 ; Branch if equal to $F0, $45 [Flow: branch]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$8504.w		; 29 04 85 ; Logical AND #$8504.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $A9.b		; 06 A9 ; Arithmetic shift left $A9.b [Reads: Direct Page] [Flags: NCZ]
	.db $10, $22		; 10 22 ; Branch if plus to $10, $22 [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	ora $00A0.w		; 0D A0 00 ; Logical OR $00A0.w with accumulator [Writes: Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx #$DA03.w		; A2 03 DA ; Load #$DA03.w into X register [Writes: X Index] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $06.b		; 65 06 ; Add $06.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $9C8B.w,X		; 7D 8B 9C ; Add $9C8B.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $9C93.w,X		; 7D 93 9C ; Add $9C93.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $9C9B.w,X		; BD 9B 9C ; Load $9C9B.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $9CA3.w,X		; BD A3 9C ; Load $9CA3.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$C824.w		; 09 24 C8 ; Logical OR #$C824.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda #$9102.w		; A9 02 91 ; Load #$9102.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($7A.b)		; 92 7A ; Store accumulator (indirect) ($7A.b) [Reads: Direct Page, Accumulator]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $CC		; 10 CC ; Branch if plus to $10, $CC [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0EA0.w,X		; BD A0 0E ; Load $0EA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $21		; F0 21 ; Branch if equal to $F0, $21 [Flow: branch]
	stz $0EA0.w,X		; 9E A0 0E ; Store zero to $0EA0.w,X [Reads: X Index]
	lda #$9D03.w		; A9 03 9D ; Load #$9D03.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$A90D.w		; A0 0D A9 ; Load #$A90D.w into Y register [Writes: Y Index] [Flags: NZ]
	cpy #$D09D.w		; C0 9D D0 ; Compare #$D09D.w with Y register [Reads: Y Index] [Flags: NCZ]
	asl $40BD.w		; 0E BD 40 ; Arithmetic shift left $40BD.w [Flags: NCZ]
	ora $0D509D.l		; 0F 9D 50 0D ; OR accumulator with memory (long) $0D509D.l [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ror $0D50.w,X		; 7E 50 0D ; Rotate right $0D50.w,X [Reads: X Index] [Flags: NCZ]
	lda $0F30.w,X		; BD 30 0F ; Load $0F30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ror $0D40.w,X		; 7E 40 0D ; Rotate right $0D40.w,X [Reads: X Index] [Flags: NCZ]
	lda $0DA0.w,X		; BD A0 0D ; Load $0DA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	adc $9D9C9D.l,X		; 7F 9D 9C 9D ; Add long $9D9C9D.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $9D.b,X		; D6 9D ; Decrement memory $9D.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	ror $9E.b		; 66 9E ; Rotate right $9E.b [Reads: Direct Page] [Flags: NCZ]
	jsl $06E416.l		; 22 16 E4 06 ; Jump to subroutine long $06E416.l [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $10		; D0 10 ; Branch if not equal to $D0, $10 [Flow: branch]
	lda #$9D7F.w		; A9 7F 9D ; Load #$9D7F.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0D		; F0 0D ; Branch if equal to $F0, $0D [Flow: branch]
	inc $0DA0.w,X		; FE A0 0D ; Increment memory $0DA0.w,X [Reads: X Index] [Flags: NZ]
	lda $0E60.w,X		; BD 60 0E ; Load $0E60.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$9D40.w		; 09 40 9D ; Logical OR #$9D40.w with accumulator [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	asl $2060.w		; 0E 60 20 ; Arithmetic shift left $2060.w [Flags: NCZ]
	sbc $98.b,X		; F5 98 ; Subtract $98.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0BA0.w,X		; 9D A0 0B ; Store accumulator to $0BA0.w,X [Reads: Accumulator, X Index]
	.db $D0, $21		; D0 21 ; Branch if not equal to $D0, $21 [Flow: branch]
	lda $0E60.w,X		; BD 60 0E ; Load $0E60.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$9DBF.w		; 29 BF 9D ; Logical AND #$9DBF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	asl $28A9.w		; 0E A9 28 ; Arithmetic shift left $28A9.w [Flags: NCZ]
	jsl $0DBB7C.l		; 22 7C BB 0D ; Jump to subroutine long $0DBB7C.l [Writes: Stack Pointer] [Flow: call]
	inc $0DA0.w,X		; FE A0 0D ; Increment memory $0DA0.w,X [Reads: X Index] [Flags: NZ]
	lda #$9D30.w		; A9 30 9D ; Load #$9D30.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $80, $0F		; 80 0F ; Branch always to $80, $0F [Flow: branch]
	jsr $F93F.w		; 20 3F F9 ; Jump to subroutine at $F93F.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $97B5.w,Y		; B9 B5 97 ; Load $97B5.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$4A08.w		; 29 08 4A ; Logical AND #$4A08.w with accumulator [Writes: Accumulator] [Flags: NZ]
	adc $0DE0.w,X		; 7D E0 0D ; Add $0DE0.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $BC9A.w,Y		; B9 9A BC ; Load $BC9A.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	jsr $9F08.w		; 20 08 9F ; Jump to subroutine at $9F08.w [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	jsr $AB93.w		; 20 93 AB ; Jump to subroutine at $AB93.w [Writes: Stack Pointer] [Flow: call]
	jsr $FA2E.w		; 20 2E FA ; Jump to subroutine at $FA2E.w [Writes: Stack Pointer] [Flow: call]
	lda $0F80.w,X		; BD 80 0F ; Load $0F80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$9D02.w		; E9 02 9D ; Subtract #$9D02.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $0F		; 80 0F ; Branch always to $80, $0F [Flow: branch]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $10, $2F		; 10 2F ; Branch if plus to $10, $2F [Flow: branch]
	lda $0F80.w,X		; BD 80 0F ; Load $0F80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$10F0.w		; C9 F0 10 ; Compare #$10F0.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora $20.b,S		; 03 20 ; OR accumulator with stack relative $20.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $9EC4.w,Y		; F9 C4 9E ; Subtract with carry $9EC4.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $0F		; 70 0F ; Branch if overflow set to $70, $0F [Flow: branch]
	stz $0F80.w,X		; 9E 80 0F ; Store zero to $0F80.w,X [Reads: X Index]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$D00F.w		; 29 0F D0 ; Logical AND #$D00F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsr $F93F.w		; 20 3F F9 ; Jump to subroutine at $F93F.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$D01F.w		; 29 1F D0 ; Logical AND #$D01F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	lda #$2208.w		; A9 08 22 ; Load #$2208.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($EA.b)		; 12 EA ; OR accumulator with memory (indirect) ($EA.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $20.b		; 06 20 ; Arithmetic shift left $20.b [Reads: Direct Page] [Flags: NCZ]
	sbc $20F9.w		; ED F9 20 ; Subtract $20F9.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $BDB8.w		; 8D B8 BD ; Store accumulator to $BDB8.w [Reads: Accumulator]
	.db $70, $0F		; 70 0F ; Branch if overflow set to $70, $0F [Flow: branch]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $10, $26		; 10 26 ; Branch if plus to $10, $26 [Flow: branch]
	jsr $9EDB.w		; 20 DB 9E ; Jump to subroutine at $9EDB.w [Writes: Stack Pointer] [Flow: call]
	lda $0FA5.w		; AD A5 0F ; Load $0FA5.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$D008.w		; C9 08 D0 ; Compare #$D008.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	trb $F822.w		; 1C 22 F8 ; Test and reset bits $F822.w [Reads: Accumulator] [Flags: Z]
	sbc ($09.b),Y		; F1 09 ; Subtract with carry ($09.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lda #$2228.w		; A9 28 22 ; Load #$2228.w into accumulator [Writes: Accumulator] [Flags: NZ]
	jmp ($0DBB.w,X)		; 7C BB 0D ; Jump indirect indexed to ($0DBB.w,X) [Reads: X Index] [Flow: jump]
	lda #$9D03.w		; A9 03 9D ; Load #$9D03.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0D		; D0 0D ; Branch if not equal to $D0, $0D [Flow: branch]
	lda #$9D0F.w		; A9 0F 9D ; Load #$9D0F.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0D		; F0 0D ; Branch if equal to $F0, $0D [Flow: branch]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	lda #$9D03.w		; A9 03 9D ; Load #$9D03.w into accumulator [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	asl $5220.w		; 0E 20 52 ; Arithmetic shift left $5220.w [Flags: NCZ]
	lda $2260.w,X		; BD 60 22 ; Load $2260.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	sbc ($06.b)		; F2 06 ; Subtract with carry (indirect) ($06.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$D003.w		; 29 03 D0 ; Logical AND #$D003.w with accumulator [Writes: Accumulator] [Flags: NZ]
	trb $D0DE.w		; 1C DE D0 ; Test and reset bits $D0DE.w [Reads: Accumulator] [Flags: Z]
	asl $17D0.w		; 0E D0 17 ; Arithmetic shift left $17D0.w [Flags: NCZ]
	lda #$9D02.w		; A9 02 9D ; Load #$9D02.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$BC0D.w		; A0 0D BC ; Load #$BC0D.w into Y register [Writes: Y Index] [Flags: NZ]
	.db $D0, $0D		; D0 0D ; Branch if not equal to $D0, $0D [Flow: branch]
	lda #$9D09.w		; A9 09 9D ; Load #$9D09.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0D		; D0 0D ; Branch if not equal to $D0, $0D [Flow: branch]
	cpy #$D00A.w		; C0 0A D0 ; Compare #$D00A.w with Y register [Reads: Y Index] [Flags: NCZ]
	asl $9C.b		; 06 9C ; Arithmetic shift left $9C.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $9C.b,S		; 03 9C ; OR accumulator with stack relative $9C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora #$BD03.w		; 09 03 BD ; Logical OR #$BD03.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0E		; D0 0E ; Branch if not equal to $D0, $0E [Flow: branch]
	cmp #$B030.w		; C9 30 B0 ; Compare #$B030.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora $291AA5.l,X		; 1F A5 1A 29 ; Logical OR long $291AA5.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($D0.b,X)		; 01 D0 ; Logical OR ($D0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $1AA5.w,Y		; 19 A5 1A ; OR accumulator with memory $1AA5.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$A801.w		; 29 01 A8 ; Logical AND #$A801.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lda $99D5.w,Y		; B9 D5 99 ; Load $99D5.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0D10.w,X		; 7D 10 0D ; Add $0D10.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,X		; 9D 10 0D ; Store accumulator to $0D10.w,X [Reads: Accumulator, X Index]
	lda $9EEE.w,Y		; [PATTERN: Memory clearing operation] B9 EE 9E ; Load $9EEE.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $0D30.w,X		; 7D 30 0D ; Add $0D30.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D30.w,X		; 9D 30 0D ; Store accumulator to $0D30.w,X [Reads: Accumulator, X Index]
	stz $0DC0.w,X		; 9E C0 0D ; Store zero to $0DC0.w,X [Reads: X Index]
	stz $0E70.w,X		; 9E 70 0E ; Store zero to $0E70.w,X [Reads: X Index]
	jsr $9FE0.w		; 20 E0 9F ; Jump to subroutine at $9FE0.w [Writes: Stack Pointer] [Flow: call]
	dec $0E40.w,X		; DE 40 0E ; Decrement memory $0E40.w,X [Reads: X Index] [Flags: NZ]
	dec $0E40.w,X		; DE 40 0E ; Decrement memory $0E40.w,X [Reads: X Index] [Flags: NZ]
	jsl $06DBF0.l		; 22 F0 DB 06 ; Jump to subroutine long $06DBF0.l [Writes: Stack Pointer] [Flow: call]
	inc $0E40.w,X		; FE 40 0E ; Increment memory $0E40.w,X [Reads: X Index] [Flags: NZ]
	inc $0E40.w,X		; FE 40 0E ; Increment memory $0E40.w,X [Reads: X Index] [Flags: NZ]
	stz $0EC0.w,X		; 9E C0 0E ; Store zero to $0EC0.w,X [Reads: X Index]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	jsr $F971.w		; 20 71 F9 ; Jump to subroutine at $F971.w [Writes: Stack Pointer] [Flow: call]
	jsr $F9ED.w		; 20 ED F9 ; Jump to subroutine at $F9ED.w [Writes: Stack Pointer] [Flow: call]
	jsl $06DFF2.l		; 22 F2 DF 06 ; Jump to subroutine long $06DFF2.l [Writes: Stack Pointer] [Flow: call]
	stz $0EC0.w,X		; 9E C0 0E ; Store zero to $0EC0.w,X [Reads: X Index]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0A		; D0 0A ; Branch if not equal to $D0, $0A [Flow: branch]
	lda $0FA5.w		; AD A5 0F ; Load $0FA5.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$D009.w		; C9 09 D0 ; Compare #$D009.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora $FE.b,S		; 03 FE ; OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpy #$600E.w		; C0 0E 60 ; Compare #$600E.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $A4CE.w		; CE CE A4 ; Decrement $A4CE.w [Flags: NZ]
	inc $0040.w		; EE 40 00 ; Increment $0040.w [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy $CCEC.w		; CC EC CC ; Compare $CCEC.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpx $E8E8.w		; EC E8 E8 ; Compare $E8E8.w with X register [Reads: X Index] [Flags: NCZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $9FE0.w		; 20 E0 9F ; Jump to subroutine at $9FE0.w [Writes: Stack Pointer] [Flow: call]
	jsr $FA50.w		; 20 50 FA ; Jump to subroutine at $FA50.w [Writes: Stack Pointer] [Flow: call]
	ldy #$BD00.w		; A0 00 BD ; Load #$BD00.w into Y register [Writes: Y Index] [Flags: NZ]
	cpy #$850D.w		; C0 0D 85 ; Compare #$850D.w with Y register [Reads: Y Index] [Flags: NCZ]
	asl $C9.b		; 06 C9 ; Arithmetic shift left $C9.b [Reads: Direct Page] [Flags: NCZ]
	tsb $B0.b		; 04 B0 ; Test and set bits $B0.b [Reads: Accumulator] [Flags: Z]
	tsb $C24A.w		; 0C 4A C2 ; Test and set bits $C24A.w [Reads: Accumulator] [Flags: Z]
	jsr $02A5.w		; 20 A5 02 ; Jump to subroutine at $02A5.w [Writes: Stack Pointer] [Flow: call]
	sbc #$0000.w		; E9 00 00 ; Subtract #$0000.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	lda $0EB0.w,X		; BD B0 0E ; Load $0EB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	and #$0100.w		; 29 00 01 ; Logical AND #$0100.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E.b		; 85 0E ; Store accumulator to $0E.b [Reads: Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$0006.w		; E9 06 00 ; Subtract #$0006.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0010.w		; 69 10 00 ; Add #$0010.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0100.w		; C9 00 01 ; Compare #$0100.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $05		; 90 05 ; Branch if carry clear to $90, $05 [Flow: branch]
	lda #$00F0.w		; A9 F0 00 ; Load #$00F0.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
.ACCU 8
	sep #$20		; E2 20
	lda $9EF0.w,X		; BD F0 9E ; Load $9EF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $9EF4.w,X		; BD F4 9E ; Load $9EF4.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0F.b		; 05 0F ; Logical OR $0F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($92.b)		; 92 92 ; Store accumulator (indirect) ($92.b) [Reads: Direct Page, Accumulator]
	lda $06.b		; A5 06 ; Load $06.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	and #$0100.w		; 29 00 01 ; Logical AND #$0100.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E.b		; 85 0E ; Store accumulator to $0E.b [Reads: Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0010.w		; 69 10 00 ; Add #$0010.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0100.w		; C9 00 01 ; Compare #$0100.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $05		; 90 05 ; Branch if carry clear to $90, $05 [Flow: branch]
	lda #$00F0.w		; A9 F0 00 ; Load #$00F0.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
.ACCU 8
	sep #$20		; E2 20
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda $9EF8.w,X		; BD F8 9E ; Load $9EF8.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $9F00.w,X		; BD 00 9F ; Load $9F00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	ldy #$A901.w		; A0 01 A9 ; Load #$A901.w into Y register [Writes: Y Index] [Flags: NZ]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $FA9291.l		; 0F 91 92 FA ; OR accumulator with memory (long) $FA9291.l [Writes: Accumulator] [Flags: NZ]
	lda $0EC0.w,X		; BD C0 0E ; Load $0EC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $04		; D0 04 ; Branch if not equal to $D0, $04 [Flow: branch]
	jsl $06DC54.l		; 22 54 DC 06 ; Jump to subroutine long $06DC54.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $D8.b		; 00 D8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D8.b		; 00 D8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($00.b,X)		; 41 00 ; Exclusive OR accumulator with memory ($00.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D9.b		; 00 D9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D9.b		; 00 D9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($00.b,X)		; 41 00 ; Exclusive OR accumulator with memory ($00.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DA.b		; 00 DA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DA.b		; 00 DA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($00.b,X)		; 41 00 ; Exclusive OR accumulator with memory ($00.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	.db $10, $BD		; 10 BD ; Branch if plus to $10, $BD [Flow: branch]
	cpy #$F00E.w		; C0 0E F0 ; Compare #$F00E.w with Y register [Reads: Y Index] [Flags: NCZ]
	trb $22.b		; 14 22 ; Test and reset bits $22.b [Reads: Accumulator] [Flags: Z]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	sta $20C205.l,X		; 9F 05 C2 20 ; Store accumulator (long,X) $20C205.l,X [Reads: Accumulator, X Index]
	lda $90.b		; A5 90 ; Load $90.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$08.b		; 69 08 ; Add #$08.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	brk $85.b		; 00 85 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $E6		; 90 E6 ; Branch if carry clear to $90, $E6 [Flow: branch]
	sta ($E6.b)		; 92 E6 ; Store accumulator (indirect) ($E6.b) [Reads: Direct Page, Accumulator]
	sta ($E2.b)		; 92 E2 ; Store accumulator (indirect) ($E2.b) [Reads: Direct Page, Accumulator]
	jsr $8B60.w		; 20 60 8B ; Jump to subroutine at $8B60.w [Writes: Stack Pointer] [Flow: call]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $9FDC.w,Y		; B9 DC 9F ; Load $9FDC.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$AC.b		; 69 AC ; Add #$AC.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
	lda #$9F.b		; A9 9F ; Load #$9F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $09.b		; 85 09 ; Store accumulator to $09.b [Reads: Accumulator]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $8AB1.w		; 20 B1 8A ; Jump to subroutine at $8AB1.w [Writes: Stack Pointer] [Flow: call]
	ldy #$B103.w		; A0 03 B1 ; Load #$B103.w into Y register [Writes: Y Index] [Flags: NZ]
	.db $90, $29		; 90 29 ; Branch if carry clear to $90, $29 [Flow: branch]
	.db $30, $09		; 30 09 ; Branch if minus to $30, $09 [Flow: branch]
	tsb $91.b		; 04 91 ; Test and set bits $91.b [Reads: Accumulator] [Flags: Z]
	.db $90, $A0		; 90 A0 ; Branch if carry clear to $90, $A0 [Flow: branch]
	ora [$09.b]		; 07 09 ; OR accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $9FE5.w		; 20 E5 9F ; Jump to subroutine at $9FE5.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($BD.b,X)		; 01 BD ; Logical OR ($BD.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit #$0B.b		; 89 0B ; Test bits #$0B.b with accumulator [Reads: Accumulator] [Flags: Z]
	ora #$30.b		; 09 30 ; Logical OR #$30.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0B89.w,X		; 9D 89 0B ; Store accumulator to $0B89.w,X [Reads: Accumulator, X Index]
	jsr $A274.w		; 20 74 A2 ; Jump to subroutine at $A274.w [Writes: Stack Pointer] [Flow: call]
	jsr $F955.w		; 20 55 F9 ; Jump to subroutine at $F955.w [Writes: Stack Pointer] [Flow: call]
	lda $0DD0.w,X		; BD D0 0D ; Load $0DD0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$09.b		; C9 09 ; Compare #$09.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $4D		; F0 4D ; Branch if equal to $F0, $4D [Flow: branch]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $3D		; D0 3D ; Branch if not equal to $D0, $3D [Flow: branch]
	dec $0FF8.w		; CE F8 0F ; Decrement $0FF8.w [Flags: NZ]
	lda $0FF8.w		; AD F8 0F ; Load $0FF8.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$01.b		; C9 01 ; Compare #$01.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $15		; D0 15 ; Branch if not equal to $D0, $15 [Flow: branch]
	ldy #$A905.w		; A0 05 A9 ; Load #$A905.w into Y register [Writes: Y Index] [Flags: NZ]
	.db $30, $99		; 30 99 ; Branch if minus to $30, $99 [Flow: branch]
	.db $50, $0E		; 50 0E ; Branch if overflow clear to $50, $0E [Flow: branch]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,Y		; 99 50 0D ; Store accumulator to $0D50.w,Y [Reads: Y Index, Accumulator]
	sta $0D40.w,Y		; 99 40 0D ; Store accumulator to $0D40.w,Y [Reads: Y Index, Accumulator]
	sta $0F80.w,Y		; 99 80 0F ; Store accumulator to $0F80.w,Y [Reads: Y Index, Accumulator]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $10, $ED		; 10 ED ; Branch if plus to $10, $ED [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	jsl $09AF32.l		; 22 32 AF 09 ; Jump to subroutine long $09AF32.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $14		; 90 14 ; Branch if carry clear to $90, $14 [Flow: branch]
	lda #$EA.b		; A9 EA ; Load #$EA.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	jsl $09AE64.l		; 22 64 AE 09 ; Jump to subroutine long $09AE64.l [Writes: Stack Pointer] [Flow: call]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F80.w,Y		; 99 80 0F ; Store accumulator to $0F80.w,Y [Reads: Y Index, Accumulator]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D90.w,Y		; 99 90 0D ; Store accumulator to $0D90.w,Y [Reads: Y Index, Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $A031.w,Y		; B9 31 A0 ; Load $A031.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $F9ED.w		; 20 ED F9 ; Jump to subroutine at $F9ED.w [Writes: Stack Pointer] [Flow: call]
	jsr $FA2E.w		; 20 2E FA ; Jump to subroutine at $FA2E.w [Writes: Stack Pointer] [Flow: call]
	lda $0F80.w,X		; BD 80 0F ; Load $0F80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$04.b		; E9 04 ; Subtract #$04.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0F80.w,X		; [PATTERN: Memory clearing operation] 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $1D		; 10 1D ; Branch if plus to $10, $1D [Flow: branch]
	stz $0F80.w,X		; 9E 80 0F ; Store zero to $0F80.w,X [Reads: X Index]
	stz $0F70.w,X		; 9E 70 0F ; Store zero to $0F70.w,X [Reads: X Index]
	lda $0FF8.w		; AD F8 0F ; Load $0FF8.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$01.b		; C9 01 ; Compare #$01.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $10		; F0 10 ; Branch if equal to $F0, $10 [Flow: branch]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0B		; F0 0B ; Branch if equal to $F0, $0B [Flow: branch]
	lda #$30.b		; A9 30 ; Load #$30.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	lda #$16.b		; A9 16 ; Load #$16.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB8A.l		; 22 8A BB 0D ; Jump to subroutine long $0DBB8A.l [Writes: Stack Pointer] [Flow: call]
	lda $0EA0.w,X		; [PATTERN: Memory clearing operation] BD A0 0E ; Load $0EA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $09		; F0 09 ; Branch if equal to $F0, $09 [Flow: branch]
	jsr $C4F9.w		; 20 F9 C4 ; Jump to subroutine at $C4F9.w [Writes: Stack Pointer] [Flow: call]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	stz $0ED0.w,X		; 9E D0 0E ; Store zero to $0ED0.w,X [Reads: X Index]
	jsr $F971.w		; 20 71 F9 ; Jump to subroutine at $F971.w [Writes: Stack Pointer] [Flow: call]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $54		; D0 54 ; Branch if not equal to $D0, $54 [Flow: branch]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $1E		; D0 1E ; Branch if not equal to $D0, $1E [Flow: branch]
	inc $0D90.w,X		; FE 90 0D ; Increment memory $0D90.w,X [Reads: X Index] [Flags: NZ]
	lda $0E40.w,X		; BD 40 0E ; Load $0E40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$7F.b		; 29 7F ; Logical AND #$7F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0E40.w,X		; 9D 40 0E ; Store accumulator to $0E40.w,X [Reads: Accumulator, X Index]
	lda $0CAA.w,X		; BD AA 0C ; Load $0CAA.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$FB.b		; 29 FB ; Logical AND #$FB.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0CAA.w,X		; 9D AA 0C ; Store accumulator to $0CAA.w,X [Reads: Accumulator, X Index]
	lda $0E60.w,X		; BD 60 0E ; Load $0E60.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$BF.b		; 29 BF ; Logical AND #$BF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E60.w,X		; 9D 60 0E ; Store accumulator to $0E60.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cmp #$40.b		; C9 40 ; Compare #$40.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $05		; D0 05 ; Branch if not equal to $D0, $05 [Flow: branch]
	ldy #$8C35.w		; A0 35 8C ; Load #$8C35.w into Y register [Writes: Y Index] [Flags: NZ]
	rol $B001.w		; 2E 01 B0 ; Rotate left $B001.w [Flags: NCZ]
	ora ($4A.b,S),Y		; 13 4A ; OR accumulator (stack relative indirect indexed) ($4A.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $0FA0.w		; 4D A0 0F ; Exclusive OR $0FA0.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $95FC.w,Y		; B9 FC 95 ; Load $95FC.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	jsr $F9F4.w		; 20 F4 F9 ; Jump to subroutine at $F9F4.w [Writes: Stack Pointer] [Flow: call]
	stz $0D50.w,X		; 9E 50 0D ; Store zero to $0D50.w,X [Reads: X Index]
	jsl $06F2AA.l		; 22 AA F2 06 ; Jump to subroutine long $06F2AA.l [Writes: Stack Pointer] [Flow: call]
	jsl $06F129.l		; 22 29 F1 06 ; Jump to subroutine long $06F129.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $08		; 90 08 ; Branch if carry clear to $90, $08 [Flow: branch]
	jsl $0FF540.l		; 22 40 F5 0F ; Jump to subroutine long $0FF540.l [Writes: Stack Pointer] [Flow: call]
	jsl $079291.l		; 22 91 92 07 ; Jump to subroutine long $079291.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0FF8.w		; AD F8 0F ; Load $0FF8.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$01.b		; C9 01 ; Compare #$01.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $50		; F0 50 ; Branch if equal to $F0, $50 [Flow: branch]
	jsr $AB93.w		; 20 93 AB ; Jump to subroutine at $AB93.w [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $2F		; D0 2F ; Branch if not equal to $D0, $2F [Flow: branch]
	jsr $A18F.w		; 20 8F A1 ; Jump to subroutine at $A18F.w [Writes: Stack Pointer] [Flow: call]
	jsl $0684BD.l		; 22 BD 84 06 ; Jump to subroutine long $0684BD.l [Writes: Stack Pointer] [Flow: call]
.ACCU 16
	rep #$20		; C2 20
	lda $04.b		; A5 04 ; Load $04.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $0FD8.w		; ED D8 0F ; Subtract $0FD8.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0002.w		; 69 02 00 ; Add #$0002.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0004.w		; C9 04 00 ; Compare #$0004.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $14		; B0 14 ; Branch if carry set to $B0, $14 [Flow: branch]
	lda $06.b		; A5 06 ; Load $06.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $0FDA.w		; ED DA 0F ; Subtract $0FDA.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0002.w		; 69 02 00 ; Add #$0002.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0004.w		; C9 04 00 ; Compare #$0004.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $05		; B0 05 ; Branch if carry set to $B0, $05 [Flow: branch]
.ACCU 8
	sep #$20		; E2 20
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
.ACCU 8
	sep #$20		; E2 20
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0B10.w,X		; BD 10 0B ; Load $0B10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D10.w,X		; 9D 10 0D ; Store accumulator to $0D10.w,X [Reads: Accumulator, X Index]
	lda $0B20.w,X		; BD 20 0B ; Load $0B20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D30.w,X		; 9D 30 0D ; Store accumulator to $0D30.w,X [Reads: Accumulator, X Index]
	lda $0B30.w,X		; BD 30 0B ; Load $0B30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D00.w,X		; 9D 00 0D ; Store accumulator to $0D00.w,X [Reads: Accumulator, X Index]
	lda $0B40.w,X		; BD 40 0B ; Load $0B40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D20.w,X		; 9D 20 0D ; Store accumulator to $0D20.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $1DEF76.l		; 22 76 EF 1D ; Jump to subroutine long $1DEF76.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0B10.w,X		; BD 10 0B ; Load $0B10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	lda $0B20.w,X		; BD 20 0B ; Load $0B20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $05.b		; 85 05 ; Store accumulator to $05.b [Reads: Accumulator]
	lda $0B30.w,X		; BD 30 0B ; Load $0B30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	lda $0B40.w,X		; BD 40 0B ; Load $0B40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $07.b		; 85 07 ; Store accumulator to $07.b [Reads: Accumulator]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06EA22.l		; 22 22 EA 06 ; Jump to subroutine long $06EA22.l [Writes: Stack Pointer] [Flow: call]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $F80008.l,X		; FF 08 00 F8 ; Subtract with carry (long,X) $F80008.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F60008.l,X		; FF 08 00 F6 ; Subtract with carry (long,X) $F60008.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F6000A.l,X		; FF 0A 00 F6 ; Subtract with carry (long,X) $F6000A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F6000A.l,X		; FF 0A 00 F6 ; Subtract with carry (long,X) $F6000A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F6000A.l,X		; FF 0A 00 F6 ; Subtract with carry (long,X) $F6000A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F4000A.l,X		; FF 0A 00 F4 ; Subtract with carry (long,X) $F4000A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F4000C.l,X		; FF 0C 00 F4 ; Subtract with carry (long,X) $F4000C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F2000C.l,X		; FF 0C 00 F2 ; Subtract with carry (long,X) $F2000C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F2000E.l,X		; FF 0E 00 F2 ; Subtract with carry (long,X) $F2000E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F0000E.l,X		; FF 0E 00 F0 ; Subtract with carry (long,X) $F0000E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F00018.l,X		; FF 18 00 F0 ; Subtract with carry (long,X) $F00018.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F80018.l,X		; FF 18 00 F8 ; Subtract with carry (long,X) $F80018.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $08FFF8.l,X		; FF F8 FF 08 ; Subtract with carry (long,X) $08FFF8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F6.b		; 00 F6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0AFFF6.l,X		; FF F6 FF 0A ; Subtract with carry (long,X) $0AFFF6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F6.b		; 00 F6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0AFFF6.l,X		; FF F6 FF 0A ; Subtract with carry (long,X) $0AFFF6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0CFFF4.l,X		; FF F4 FF 0C ; Subtract with carry (long,X) $0CFFF4.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F2.b		; 00 F2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0EFFF2.l,X		; FF F2 FF 0E ; Subtract with carry (long,X) $0EFFF2.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $18FFF0.l,X		; FF F0 FF 18 ; Subtract with carry (long,X) $18FFF0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
.ACCU 16
	rep #$E0		; C2 E0
	sep #$C0		; E2 C0 ; Set processor status bits #$C0 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
.ACCU 16
	rep #$E0		; C2 E0
	sep #$C4		; E2 C4 ; Set processor status bits #$C4 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	cpy $C4.b		; C4 C4 ; Compare $C4.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	cpy $C6.b		; C4 C6 ; Compare $C6.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	dec $C8.b		; C6 C8 ; Decrement $C8.b [Reads: Direct Page] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	cld		; D8 ; Clear decimal flag [Flags: D]
	cld		; D8 ; Clear decimal flag [Flags: D]
	cld		; D8 ; Clear decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $40		; 80 40 ; Branch always to $80, $40 [Flow: branch]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $40		; 80 40 ; Branch always to $80, $40 [Flow: branch]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $40		; 80 40 ; Branch always to $80, $40 [Flow: branch]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $02		; 80 02 ; Branch always to $80, $02 [Flow: branch]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$0938.w		; 09 38 09 ; Logical OR #$0938.w with accumulator [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	ora #$0948.w		; 09 48 09 ; Logical OR #$0948.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $50, $09		; 50 09 ; Branch if overflow clear to $50, $09 [Flow: branch]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	ora #$0A6C.w		; 09 6C 0A ; Logical OR #$0A6C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ror $700A.w		; 6E 0A 70 ; Rotate right $700A.w [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc ($0A.b)		; 72 0A ; Add with carry (indirect) ($0A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	stz $0A.b,X		; 74 0A ; Store zero to $0A.b,X [Reads: X Index]
	ror $0A.b,X		; 76 0A ; Rotate right $0A.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	jsr $FA50.w		; 20 50 FA ; Jump to subroutine at $FA50.w [Writes: Stack Pointer] [Flow: call]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0C		; D0 0C ; Branch if not equal to $D0, $0C [Flow: branch]
	lda $11.b		; A5 11 ; Load $11.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$F007.w		; C9 07 F0 ; Compare #$F007.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: NCZ]
	stz $F8.b		; 64 F8 ; Store zero to $F8.b
	asl $A0.b		; 06 A0 ; Arithmetic shift left $A0.b [Reads: Direct Page] [Flags: NCZ]
	brk $BD.b		; 00 BD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$0A0D.w		; C0 0D 0A ; Compare #$0A0D.w with Y register [Reads: Y Index] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx #$DA03.w		; A2 03 DA ; Load #$DA03.w into X register [Writes: X Index] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $06.b		; 65 06 ; Add $06.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $A1B4.w,X		; 7D B4 A1 ; Add $A1B4.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	and #$0100.w		; 29 00 01 ; Logical AND #$0100.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E.b		; 85 0E ; Store accumulator to $0E.b [Reads: Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $A1E4.w,X		; 7D E4 A1 ; Add $A1E4.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0010.w		; 69 10 00 ; Add #$0010.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0100.w		; C9 00 01 ; Compare #$0100.w with accumulator [Reads: Accumulator] [Flags: NCZ]
.ACCU 8
	sep #$20		; E2 20
	.db $90, $04		; 90 04 ; Branch if carry clear to $90, $04 [Flow: branch]
	lda #$F0.b		; A9 F0 ; Load #$F0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda $A214.w,X		; BD 14 A2 ; Load $A214.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $A22C.w,X		; BD 2C A2 ; Load $A22C.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $A244.w,X		; BD 44 A2 ; Load $A244.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $0F.b		; 05 0F ; Logical OR $0F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($92.b),Y		; 91 92 ; Store accumulator ($92.b),Y [Reads: Direct Page, Y Index, Accumulator]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $B0		; 10 B0 ; Branch if plus to $10, $B0 [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $01		; F0 01 ; Branch if equal to $F0, $01 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $11		; F0 11 ; Branch if equal to $F0, $11 [Flow: branch]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	lda $A25C.w,Y		; B9 5C A2 ; Load $A25C.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $90.b		; 85 90 ; Store accumulator to $90.b [Reads: Accumulator]
	lda $A268.w,Y		; B9 68 A2 ; Load $A268.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $92.b		; 85 92 ; Store accumulator to $92.b [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$20.b		; C9 20 ; Compare #$20.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $02		; 90 02 ; Branch if carry clear to $90, $02 [Flow: branch]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $07.b		; 85 07 ; Store accumulator to $07.b [Reads: Accumulator]
	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $E8.b		; E5 E8 ; Subtract $E8.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	lda $0D20.w,X		; BD 20 0D ; Load $0D20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $E9.b		; E5 E9 ; Subtract $E9.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $03.b		; 85 03 ; Store accumulator to $03.b [Reads: Accumulator]
	ldy #$A510.w		; A0 10 A5 ; Load #$A510.w into Y register [Writes: Y Index] [Flags: NZ]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc #$08.b		; E9 08 ; Subtract #$08.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $07.b		; 65 07 ; Add $07.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$10.b		; 69 10 ; Add #$10.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $07.b		; E5 07 ; Subtract $07.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ldy #$9114.w		; A0 14 91 ; Load #$9114.w into Y register [Writes: Y Index] [Flags: NZ]
	.db $90, $C2		; 90 C2 ; Branch if carry clear to $90, $C2 [Flow: branch]
	jsr $02A5.w		; 20 A5 02 ; Jump to subroutine at $02A5.w [Writes: Stack Pointer] [Flow: call]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0C.b		; 69 0C ; Add #$0C.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($91.b),Y		; 11 91 ; OR accumulator with memory ($91.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $90, $A0		; 90 A0 ; Branch if carry clear to $90, $A0 [Flow: branch]
	ora $91.b,X		; 15 91 ; OR accumulator with memory $91.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $90, $18		; 90 18 ; Branch if carry clear to $90, $18 [Flow: branch]
	adc #$10.b		; 69 10 ; Add #$10.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	brk $C9.b		; 00 C9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
.ACCU 8
	sep #$20		; E2 20
	.db $90, $08		; 90 08 ; Branch if carry clear to $90, $08 [Flow: branch]
	lda #$F0.b		; A9 F0 ; Load #$F0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	ldy #$9111.w		; A0 11 91 ; Load #$9111.w into Y register [Writes: Y Index] [Flags: NZ]
	.db $90, $A9		; 90 A9 ; Branch if carry clear to $90, $A9 [Flow: branch]
	cpx $A0.b		; E4 A0 ; Compare $A0.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($91.b)		; 12 91 ; OR accumulator with memory (indirect) ($91.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $90, $A0		; 90 A0 ; Branch if carry clear to $90, $A0 [Flow: branch]
	asl $91.b,X		; 16 91 ; Arithmetic shift left $91.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $90, $A9		; 90 A9 ; Branch if carry clear to $90, $A9 [Flow: branch]
	and $A0.b		; 25 A0 ; Logical AND $A0.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($91.b,S),Y		; 13 91 ; OR accumulator (stack relative indirect indexed) ($91.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $90, $09		; 90 09 ; Branch if carry clear to $90, $09 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	ldy #$9117.w		; A0 17 91 ; Load #$9117.w into Y register [Writes: Y Index] [Flags: NZ]
	.db $90, $A9		; 90 A9 ; Branch if carry clear to $90, $A9 [Flow: branch]
	cop $A0.b		; 02 A0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $91.b		; 04 91 ; Test and set bits $91.b [Reads: Accumulator] [Flags: Z]
	sta ($C8.b)		; 92 C8 ; Store accumulator (indirect) ($C8.b) [Reads: Direct Page, Accumulator]
	sta ($92.b),Y		; 91 92 ; Store accumulator ($92.b),Y [Reads: Direct Page, Y Index, Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	sbc $A377BF.l,X		; FF BF 77 A3 ; Subtract with carry (long,X) $A377BF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $9D.b		; 05 9D ; Logical OR $9D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0D		; F0 0D ; Branch if equal to $F0, $0D [Flow: branch]
	lda #$FF.b		; A9 FF ; Load #$FF.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F70.w,X		; 9D 70 0F ; Store accumulator to $0F70.w,X [Reads: Accumulator, X Index]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldy #$BF3F.w		; A0 3F BF ; Load #$BF3F.w into Y register [Writes: Y Index] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	lda $05.b		; A5 05 ; Load $05.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda #$FF.b		; A9 FF ; Load #$FF.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7FFE00.l,X		; 9F 00 FE 7F ; Store accumulator (long,X) $7FFE00.l,X [Reads: Accumulator, X Index]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $10, $F8		; 10 F8 ; Branch if plus to $10, $F8 [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda #$07.b		; A9 07 ; Load #$07.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7FF81E.l,X		; 9F 1E F8 7F ; Store accumulator (long,X) $7FF81E.l,X [Reads: Accumulator, X Index]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	clc		; 18 ; Clear carry flag [Flags: C]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	jsl $06E416.l		; 22 16 E4 06 ; Jump to subroutine long $06E416.l [Writes: Stack Pointer] [Flow: call]
	jsr $A64A.w		; 20 4A A6 ; Jump to subroutine at $A64A.w [Writes: Stack Pointer] [Flow: call]
	jsr $F955.w		; 20 55 F9 ; Jump to subroutine at $F955.w [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	lda $A3E6A3.l,X		; BF A3 E6 A3 ; Load long $A3E6A3.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($A4.b),Y		; 31 A4 ; AND accumulator with memory ($A4.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	wai		; CB ; Wait for interrupt
	ldy $F2.b		; A4 F2 ; Load $F2.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	ldy $29.b		; A4 29 ; Load $29.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	lda $BD.b		; A5 BD ; Load $BD.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0D		; F0 0D ; Branch if equal to $F0, $0D [Flow: branch]
	ora $0F00.w,X		; 1D 00 0F ; OR accumulator with memory $0F00.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0E		; D0 0E ; Branch if not equal to $D0, $0E [Flow: branch]
	lda #$7F.b		; A9 7F ; Load #$7F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$35.b		; A9 35 ; Load #$35.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB7C.l		; 22 7C BB 0D ; Jump to subroutine long $0DBB7C.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	.db $50, $60		; 50 60 ; Branch if overflow clear to $50, $60 [Flow: branch]
	.db $70, $80		; 70 80 ; Branch if overflow set to $70, $80 [Flow: branch]
	.db $90, $A0		; 90 A0 ; Branch if carry clear to $90, $A0 [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $70, $80		; 70 80 ; Branch if overflow set to $70, $80 [Flow: branch]
	.db $90, $A0		; 90 A0 ; Branch if carry clear to $90, $A0 [Flow: branch]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	.db $80, $BD		; 80 BD ; Branch always to $80, $BD [Flow: branch]
	.db $F0, $0D		; F0 0D ; Branch if equal to $F0, $0D [Flow: branch]
	.db $D0, $43		; D0 43 ; Branch if not equal to $D0, $43 [Flow: branch]
	jsl $1AF981.l		; 22 81 F9 1A ; Jump to subroutine long $1AF981.l [Writes: Stack Pointer] [Flow: call]
	lda #$13.b		; A9 13 ; Load #$13.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012D.w		; 8D 2D 01 ; Store accumulator to $012D.w [Reads: Accumulator]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $A3D6.w,Y		; B9 D6 A3 ; Load $A3D6.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DA0.w,X		; 9D A0 0D ; Store accumulator to $0DA0.w,X [Reads: Accumulator, X Index]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $A3DE.w,Y		; B9 DE A3 ; Load $A3DE.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DB0.w,X		; 9D B0 0D ; Store accumulator to $0DB0.w,X [Reads: Accumulator, X Index]
	inc $0D80.w,X		; [PATTERN: Memory clearing operation] FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	stz $0EC0.w,X		; 9E C0 0E ; Store zero to $0EC0.w,X [Reads: X Index]
	stz $0ED0.w,X		; 9E D0 0E ; Store zero to $0ED0.w,X [Reads: X Index]
	lda $0D10.w,X		; BD 10 0D ; Load $0D10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0E70.w,X		; 9D 70 0E ; Store accumulator to $0E70.w,X [Reads: Accumulator, X Index]
	lda #$4A.b		; A9 4A ; Load #$4A.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E00.w,X		; 9D 00 0E ; Store accumulator to $0E00.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cop $FE.b		; 02 FE ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $AB93.w		; 20 93 AB ; Jump to subroutine at $AB93.w [Writes: Stack Pointer] [Flow: call]
	jsr $FA2E.w		; 20 2E FA ; Jump to subroutine at $FA2E.w [Writes: Stack Pointer] [Flow: call]
	lda $0EC0.w,X		; BD C0 0E ; Load $0EC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $10		; D0 10 ; Branch if not equal to $D0, $10 [Flow: branch]
	lda $0F80.w,X		; BD 80 0F ; Load $0F80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$01.b		; E9 01 ; Subtract #$01.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	inc $0EC0.w,X		; FE C0 0E ; Increment memory $0EC0.w,X [Reads: X Index] [Flags: NZ]
	.db $80, $1E		; 80 1E ; Branch always to $80, $1E [Flow: branch]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $18		; D0 18 ; Branch if not equal to $D0, $18 [Flow: branch]
	lda $0ED0.w,X		; BD D0 0E ; Load $0ED0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $0F80.w,X		; BD 80 0F ; Load $0F80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $A42F.w,Y		; 79 2F A4 ; Add $A42F.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	cmp $95FC.w,Y		; D9 FC 95 ; Compare accumulator $95FC.w,Y [Reads: Y Index] [Flags: NCZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	inc $0ED0.w,X		; FE D0 0E ; Increment memory $0ED0.w,X [Reads: X Index] [Flags: NZ]
	lda $0DA0.w,X		; BD A0 0D ; Load $0DA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	lda $0D30.w,X		; BD 30 0D ; Load $0D30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $05.b		; 85 05 ; Store accumulator to $05.b [Reads: Accumulator]
	lda $0DB0.w,X		; BD B0 0D ; Load $0DB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	lda $0D20.w,X		; BD 20 0D ; Load $0D20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $07.b		; 85 07 ; Store accumulator to $07.b [Reads: Accumulator]
	lda $0D10.w,X		; BD 10 0D ; Load $0D10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $0D30.w,X		; BD 30 0D ; Load $0D30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $01.b		; 85 01 ; Store accumulator to $01.b [Reads: Accumulator]
	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	lda $0D20.w,X		; BD 20 0D ; Load $0D20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $03.b		; 85 03 ; Store accumulator to $03.b [Reads: Accumulator]
.ACCU 16
	rep #$20		; C2 20
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $04.b		; E5 04 ; Subtract $04.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0002.w		; 69 02 00 ; Add #$0002.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0004.w		; C9 04 00 ; Compare #$0004.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $13		; B0 13 ; Branch if carry set to $B0, $13 [Flow: branch]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $06.b		; E5 06 ; Subtract $06.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0002.w		; 69 02 00 ; Add #$0002.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0004.w		; C9 04 00 ; Compare #$0004.w with accumulator [Reads: Accumulator] [Flags: NCZ]
.ACCU 8
	sep #$20		; E2 20
	.db $B0, $03		; B0 03 ; Branch if carry set to $B0, $03 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
.ACCU 8
	sep #$20		; E2 20
	lda #$0A.b		; A9 0A ; Load #$0A.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06EA22.l		; 22 22 EA 06 ; Jump to subroutine long $06EA22.l [Writes: Stack Pointer] [Flow: call]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	jsr $F9ED.w		; 20 ED F9 ; Jump to subroutine at $F9ED.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $AB93.w		; 20 93 AB ; Jump to subroutine at $AB93.w [Writes: Stack Pointer] [Flow: call]
	jsr $F9ED.w		; 20 ED F9 ; Jump to subroutine at $F9ED.w [Writes: Stack Pointer] [Flow: call]
	jsr $FA2E.w		; 20 2E FA ; Jump to subroutine at $FA2E.w [Writes: Stack Pointer] [Flow: call]
	lda $0F80.w,X		; BD 80 0F ; Load $0F80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$EC.b		; C9 EC ; Compare #$EC.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $30, $06		; 30 06 ; Branch if minus to $30, $06 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$01.b		; E9 01 ; Subtract #$01.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $0B		; 10 0B ; Branch if plus to $10, $0B [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$80.b		; A9 80 ; Load #$80.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	jsr $A41C.w		; 20 1C A4 ; Jump to subroutine at $A41C.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $1D		; D0 1D ; Branch if not equal to $D0, $1D [Flow: branch]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $A3D6.w,Y		; B9 D6 A3 ; Load $A3D6.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D10.w,X		; 9D 10 0D ; Store accumulator to $0D10.w,X [Reads: Accumulator, X Index]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $A3DE.w,Y		; B9 DE A3 ; Load $A3DE.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D00.w,X		; 9D 00 0D ; Store accumulator to $0D00.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $18		; 10 18 ; Branch if plus to $10, $18 [Flow: branch]
	jsr $3028.w		; 20 28 30 ; Jump to subroutine at $3028.w [Writes: Stack Pointer] [Flow: call]
	sec		; 38 ; Set carry flag [Flags: C]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ldy #$A904.w		; A0 04 A9 ; Load #$A904.w into Y register [Writes: Y Index] [Flags: NZ]
	and #$22.b		; 29 22 ; Logical AND #$22.b with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp ($8B.b,X)		; C1 8B ; Compare accumulator ($8B.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	ora #$FA.b		; 09 FA ; Logical OR #$FA.b with accumulator [Writes: Accumulator] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ldy $0DF0.w,X		; BC F0 0D ; Load Y register $0DF0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	.db $D0, $1D		; D0 1D ; Branch if not equal to $D0, $1D [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	jsl $09AF32.l		; 22 32 AF 09 ; Jump to subroutine long $09AF32.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $14		; 90 14 ; Branch if carry clear to $90, $14 [Flow: branch]
	lda #$EA.b		; A9 EA ; Load #$EA.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	jsl $09AE64.l		; 22 64 AE 09 ; Jump to subroutine long $09AE64.l [Writes: Stack Pointer] [Flow: call]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F80.w,Y		; 99 80 0F ; Store accumulator to $0F80.w,Y [Reads: Y Index, Accumulator]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D90.w,Y		; 99 90 0D ; Store accumulator to $0D90.w,Y [Reads: Y Index, Accumulator]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$20.b		; C9 20 ; Compare #$20.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $C2		; 90 C2 ; Branch if carry clear to $90, $C2 [Flow: branch]
	cmp #$A0.b		; C9 A0 ; Compare #$A0.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $BE		; B0 BE ; Branch if carry set to $B0, $BE [Flow: branch]
	and #$0F.b		; 29 0F ; Logical AND #$0F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $BA		; D0 BA ; Branch if not equal to $D0, $BA [Flow: branch]
	lda $7FF81E.l,X		; BF 1E F8 7F ; Load long $7FF81E.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $A515.w,Y		; F9 15 A5 ; Subtract with carry $A515.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and #$3F.b		; 29 3F ; Logical AND #$3F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $A5DA.w,X		; 7D DA A5 ; Add $A5DA.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $7FFC00.l,X		; BF 00 FC 7F ; Load long $7FFC00.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $E2.b		; E5 E2 ; Subtract $E2.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $0A.b		; 85 0A ; Store accumulator to $0A.b [Reads: Accumulator]
	lda $7FFD00.l,X		; BF 00 FD 7F ; Load long $7FFD00.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $7FFE00.l,X		; FF 00 FE 7F ; Subtract with carry (long,X) $7FFE00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $E8.b		; E5 E8 ; Subtract $E8.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $0B.b		; 85 0B ; Store accumulator to $0B.b [Reads: Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $4B		; 30 4B ; Branch if minus to $30, $4B [Flow: branch]
	lda #$0B.b		; A9 0B ; Load #$0B.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0AAA.w		; 8D AA 0A ; Store accumulator to $0AAA.w [Reads: Accumulator]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DD0.w,Y		; 99 D0 0D ; Store accumulator to $0DD0.w,Y [Reads: Y Index, Accumulator]
	lda #$1F.b		; A9 1F ; Load #$1F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,Y		; 99 F0 0D ; Store accumulator to $0DF0.w,Y [Reads: Y Index, Accumulator]
	sta $0D90.w,Y		; 99 90 0D ; Store accumulator to $0D90.w,Y [Reads: Y Index, Accumulator]
	lda $0A.b		; A5 0A ; Load $0A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $E2.b		; 65 E2 ; Add $E2.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,Y		; 99 10 0D ; Store accumulator to $0D10.w,Y [Reads: Y Index, Accumulator]
	lda $E3.b		; A5 E3 ; Load $E3.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D30.w,Y		; 99 30 0D ; Store accumulator to $0D30.w,Y [Reads: Y Index, Accumulator]
	lda $0B.b		; A5 0B ; Load $0B.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $E8.b		; 65 E8 ; Add $E8.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,Y		; 99 00 0D ; Store accumulator to $0D00.w,Y [Reads: Y Index, Accumulator]
	lda $E9.b		; A5 E9 ; Load $E9.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D20.w,Y		; 99 20 0D ; Store accumulator to $0D20.w,Y [Reads: Y Index, Accumulator]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E40.w,Y		; 99 40 0E ; Store accumulator to $0E40.w,Y [Reads: Y Index, Accumulator]
	lda #$0C.b		; A9 0C ; Load #$0C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,Y		; 99 50 0F ; Store accumulator to $0F50.w,Y [Reads: Y Index, Accumulator]
	lda #$0C.b		; A9 0C ; Load #$0C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB7C.l		; 22 7C BB 0D ; Jump to subroutine long $0DBB7C.l [Writes: Stack Pointer] [Flow: call]
	lda $7FF81E.l,X		; BF 1E F8 7F ; Load long $7FF81E.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $05		; 30 05 ; Branch if minus to $30, $05 [Flow: branch]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $7FF81E.l,X		; 9F 1E F8 7F ; Store accumulator (long,X) $7FF81E.l,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($F9.b,X)		; 01 F9 ; Logical OR ($F9.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpy $E2.b		; C4 E2 ; Compare $E2.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
.ACCU 16
	rep #$E0		; C2 E0
	cpy #$C2E0.w		; C0 E0 C2 ; Compare #$C2E0.w with Y register [Reads: Y Index] [Flags: NCZ]
	sep #$C4		; E2 C4 ; Set processor status bits #$C4 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	sep #$C2		; E2 C2 ; Set processor status bits #$C2 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	cpx #$E0C0.w		; E0 C0 E0 ; Compare #$E0C0.w with X register [Reads: X Index] [Flags: NCZ]
.ACCU 16
	rep #$E2		; C2 E2
	cpy $CAE4.w		; CC E4 CA ; Compare $CAE4.w with Y register [Reads: Y Index] [Flags: NCZ]
	inc $C8.b		; E6 C8 ; Increment $C8.b [Reads: Direct Page] [Flags: NZ]
	inc $CA.b		; E6 CA ; Increment $CA.b [Reads: Direct Page] [Flags: NZ]
	cpx $CC.b		; E4 CC ; Compare $CC.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	cpx $CA.b		; E4 CA ; Compare $CA.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	inc $C8.b		; E6 C8 ; Increment $C8.b [Reads: Direct Page] [Flags: NZ]
	inc $CA.b		; E6 CA ; Increment $CA.b [Reads: Direct Page] [Flags: NZ]
	cpx $C0.b		; E4 C0 ; Compare $C0.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	cpy #$C0C0.w		; C0 C0 C0 ; Compare #$C0C0.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	inc $0A.b,X		; F6 0A ; Increment memory $0A.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	.db $F0, $10		; F0 10 ; Branch if equal to $F0, $10 [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	jsr $0000.w		; 20 00 00 ; Jump to subroutine at $0000.w [Writes: Stack Pointer] [Flow: call]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	nop		; EA ; No operation
	nop		; EA ; No operation
	nop		; EA ; No operation
	nop		; EA ; No operation
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $09		; 30 09 ; Branch if minus to $30, $09 [Flow: branch]
	.db $F0, $08		; F0 08 ; Branch if equal to $F0, $08 [Flow: branch]
	.db $B0, $08		; B0 08 ; Branch if carry set to $B0, $08 [Flow: branch]
	.db $70, $08		; 70 08 ; Branch if overflow set to $70, $08 [Flow: branch]
	jmp ($5C0A.w)		; 6C 0A 5C ; Jump indirect to ($5C0A.w) [Flow: jump]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	jmp $3C0A.w		; 4C 0A 3C ; Jump to $3C0A.w [Flow: jump]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	lda $A63A.w,Y		; B9 3A A6 ; Load $A63A.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $90.b		; 85 90 ; Store accumulator to $90.b [Reads: Accumulator]
	lda $A642.w,Y		; B9 42 A6 ; Load $A642.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $92.b		; 85 92 ; Store accumulator to $92.b [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	lda $0D40.w,X		; BD 40 0D ; Load $0D40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $0F80.w,X		; FD 80 0F ; Subtract with carry $0F80.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $0D50.w,X		; BD 50 0D ; Load $0D50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $01.b		; 85 01 ; Store accumulator to $01.b [Reads: Accumulator]
	jsl $1DF614.l		; 22 14 F6 1D ; Jump to subroutine long $1DF614.l [Writes: Stack Pointer] [Flow: call]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	lda $A5DA.w,X		; BD DA A5 ; Load $A5DA.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	lda $0D10.w,X		; BD 10 0D ; Load $0D10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	sta $05.b		; 85 05 ; Store accumulator to $05.b [Reads: Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $04.b		; 65 04 ; Add $04.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $7FFF00.l,X		; 9F 00 FF 7F ; Store accumulator (long,X) $7FFF00.l,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $7FFE00.l,X		; 9F 00 FE 7F ; Store accumulator (long,X) $7FFE00.l,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $7FFD00.l,X		; 9F 00 FD 7F ; Store accumulator (long,X) $7FFD00.l,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $7FFC00.l,X		; 9F 00 FC 7F ; Store accumulator (long,X) $7FFC00.l,X [Reads: Accumulator, X Index]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda $0DD0.w,X		; BD D0 0D ; Load $0DD0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$09.b		; C9 09 ; Compare #$09.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $10		; D0 10 ; Branch if not equal to $D0, $10 [Flow: branch]
	lda $11.b		; A5 11 ; Load $11.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0FC1.w		; 0D C1 0F ; Logical OR $0FC1.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $09		; D0 09 ; Branch if not equal to $D0, $09 [Flow: branch]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	and #$3F.b		; 29 3F ; Logical AND #$3F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E80.w,X		; 9D 80 0E ; Store accumulator to $0E80.w,X [Reads: Accumulator, X Index]
	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $0B89.w,X		; 1D 89 0B ; OR accumulator with memory $0B89.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $03.b		; 85 03 ; Store accumulator to $03.b [Reads: Accumulator]
	lda $7FF81E.l,X		; BF 1E F8 7F ; Load long $7FF81E.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $01		; 10 01 ; Branch if plus to $10, $01 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	sta $0E.b		; 85 0E ; Store accumulator to $0E.b [Reads: Accumulator]
	lda $0D40.w,X		; BD 40 0D ; Load $0D40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $A5E0.w,X		; BD E0 A5 ; Load $A5E0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0C.b		; 85 0C ; Store accumulator to $0C.b [Reads: Accumulator]
	ldy $A5DE.w,X		; BC DE A5 ; Load Y register $A5DE.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	stx $0B.b		; 86 0B ; Store X register to $0B.b [Reads: X Index]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	stx $0D.b		; 86 0D ; Store X register to $0D.b [Reads: X Index]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $04.b		; 65 04 ; Add $04.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$08.b		; E9 08 ; Subtract #$08.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	and #$3F.b		; 29 3F ; Logical AND #$3F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	lda $7FFC00.l,X		; BF 00 FC 7F ; Load long $7FFC00.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $E2.b		; E5 E2 ; Subtract $E2.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	lda $7FFE00.l,X		; BF 00 FE 7F ; Load long $7FFE00.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $0E		; 30 0E ; Branch if minus to $30, $0E [Flow: branch]
	lda $7FFD00.l,X		; BF 00 FD 7F ; Load long $7FFD00.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $7FFE00.l,X		; FF 00 FE 7F ; Subtract with carry (long,X) $7FFE00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $E8.b		; E5 E8 ; Subtract $E8.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	lda $7FFF00.l,X		; BF 00 FF 7F ; Load long $7FFF00.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ldy $0D.b		; A4 0D ; Load $0D.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	lda $0B.b		; A5 0B ; Load $0B.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$07.b		; C9 07 ; Compare #$07.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $04		; D0 04 ; Branch if not equal to $D0, $04 [Flow: branch]
	cpy #$F000.w		; C0 00 F0 ; Compare #$F000.w with Y register [Reads: Y Index] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	lda #$C6.b		; A9 C6 ; Load #$C6.b into accumulator [Writes: Accumulator] [Flags: NZ]
	cpy $0B.b		; C4 0B ; Compare $0B.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	lda $A5E2.w,X		; BD E2 A5 ; Load $A5E2.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $80, $03		; 80 03 ; Branch always to $80, $03 [Flow: branch]
	lda $A5F2.w,X		; BD F2 A5 ; Load $A5F2.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $A602.w,X		; BD 02 A6 ; Load $A602.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($92.b),Y		; 91 92 ; Store accumulator ($92.b),Y [Reads: Direct Page, Y Index, Accumulator]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0C.b		; 65 0C ; Add $0C.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $92		; 10 92 ; Branch if plus to $10, $92 [Flow: branch]
	ldx $0E.b		; A6 0E ; Load $0E.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	ldy #$DA20.w		; A0 20 DA ; Load #$DA20.w into Y register [Writes: Y Index] [Flags: NZ]
	lda $05.b		; A5 05 ; Load $05.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $04.b		; 65 04 ; Add $04.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $05.b		; A5 05 ; Load $05.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$08.b		; E9 08 ; Subtract #$08.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	and #$3F.b		; 29 3F ; Logical AND #$3F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $05.b		; 85 05 ; Store accumulator to $05.b [Reads: Accumulator]
	lda $7FFC00.l,X		; BF 00 FC 7F ; Load long $7FFC00.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $E2.b		; E5 E2 ; Subtract $E2.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	lda $7FFE00.l,X		; BF 00 FE 7F ; Load long $7FFE00.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $0C		; 30 0C ; Branch if minus to $30, $0C [Flow: branch]
	lda $7FFD00.l,X		; BF 00 FD 7F ; Load long $7FFD00.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0A.b		; 69 0A ; Add #$0A.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $E8.b		; E5 E8 ; Subtract $E8.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda #$6C.b		; A9 6C ; Load #$6C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda #$34.b		; A9 34 ; Load #$34.b into accumulator [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($92.b),Y		; 91 92 ; Store accumulator ($92.b),Y [Reads: Direct Page, Y Index, Accumulator]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $BB		; 10 BB ; Branch if plus to $10, $BB [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$01.b		; C9 01 ; Compare #$01.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	jmp $A820.w		; 4C 20 A8 ; Jump to $A820.w [Flow: jump]
	cmp #$05.b		; C9 05 ; Compare #$05.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $76		; F0 76 ; Branch if equal to $F0, $76 [Flow: branch]
	lda $0E00.w,X		; BD 00 0E ; Load $0E00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $71		; F0 71 ; Branch if equal to $F0, $71 [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda $0D40.w,X		; BD 40 0D ; Load $0D40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	eor $0D80.w,X		; 5D 80 0D ; Exclusive OR accumulator with memory $0D80.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$02.b		; 29 02 ; Logical AND #$02.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $08		; F0 08 ; Branch if equal to $F0, $08 [Flow: branch]
	lda #$08.b		; A9 08 ; Load #$08.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBA84.l		; 22 84 BA 0D ; Jump to subroutine long $0DBA84.l [Writes: Stack Pointer] [Flow: call]
	.db $80, $06		; 80 06 ; Branch always to $80, $06 [Flow: branch]
	lda #$08.b		; A9 08 ; Load #$08.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBA88.l		; 22 88 BA 0D ; Jump to subroutine long $0DBA88.l [Writes: Stack Pointer] [Flow: call]
	ldy #$6800.w		; A0 00 68 ; Load #$6800.w into Y register [Writes: Y Index] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	eor #$03.b		; 49 03 ; Exclusive OR #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $E2.b		; E5 E2 ; Subtract $E2.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $0E70.w,X		; BD 70 0E ; Load $0E70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $E8.b		; E5 E8 ; Subtract $E8.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx #$DA01.w		; A2 01 DA ; Load #$DA01.w into X register [Writes: X Index] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $06.b		; 65 06 ; Add $06.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $A612.w,X		; 7D 12 A6 ; Add $A612.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $A61A.w,X		; 7D 1A A6 ; Add $A61A.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $A622.w,X		; BD 22 A6 ; Load $A622.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $A62A.w,X		; BD 2A A6 ; Load $A62A.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$31.b		; 09 31 ; Logical OR #$31.b with accumulator [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $A632.w,X		; BD 32 A6 ; Load $A632.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta ($92.b),Y		; 91 92 ; Store accumulator ($92.b),Y [Reads: Direct Page, Y Index, Accumulator]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $CB		; 10 CB ; Branch if plus to $10, $CB [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBA84.l		; 22 84 BA 0D ; Jump to subroutine long $0DBA84.l [Writes: Stack Pointer] [Flow: call]
	lda $0D10.w,X		; BD 10 0D ; Load $0D10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $E2.b		; E5 E2 ; Subtract $E2.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $E8.b		; E5 E8 ; Subtract $E8.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx $A870.w,Y		; BE 70 A8 ; Load X register $A870.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ldy #$A500.w		; A0 00 A5 ; Load #$A500.w into Y register [Writes: Y Index] [Flags: NZ]
	brk $91.b		; 00 91 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $A5		; 90 A5 ; Branch if carry clear to $90, $A5 [Flow: branch]
	cop $C8.b		; 02 C8 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $A864.w,X		; BD 64 A8 ; Load $A864.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $A86A.w,X		; BD 6A A8 ; Load $A86A.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$31.b		; 09 31 ; Logical OR #$31.b with accumulator [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($92.b),Y		; 91 92 ; Store accumulator ($92.b),Y [Reads: Direct Page, Y Index, Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	inc $ECEE.w		; EE EE EC ; Increment $ECEE.w [Flags: NZ]
	cpx $CECE.w		; EC CE CE ; Compare $CECE.w with X register [Reads: X Index] [Flags: NCZ]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $080F.w		; 0E 0F 08 ; Arithmetic shift left $080F.w [Flags: NCZ]
	ora #$04.b		; 09 04 ; Logical OR #$04.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($0C.b,X)		; 01 0C ; Logical OR ($0C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $90BC.w		; 0D BC 90 ; Logical OR $90BC.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $80B9.w		; 0D B9 80 ; Logical OR $80B9.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$3F.b		; 29 3F ; Logical AND #$3F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $A890.w,Y		; 19 90 A8 ; OR accumulator with memory $A890.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	jsl $06DBF0.l		; 22 F0 DB 06 ; Jump to subroutine long $06DBF0.l [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	jsr $F971.w		; 20 71 F9 ; Jump to subroutine at $F971.w [Writes: Stack Pointer] [Flow: call]
	jsr $AB93.w		; 20 93 AB ; Jump to subroutine at $AB93.w [Writes: Stack Pointer] [Flow: call]
	jsr $F9ED.w		; 20 ED F9 ; Jump to subroutine at $F9ED.w [Writes: Stack Pointer] [Flow: call]
	jsr $B88D.w		; 20 8D B8 ; Jump to subroutine at $B88D.w [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $3B		; D0 3B ; Branch if not equal to $D0, $3B [Flow: branch]
	jsr $C4F9.w		; 20 F9 C4 ; Jump to subroutine at $C4F9.w [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $15		; D0 15 ; Branch if not equal to $D0, $15 [Flow: branch]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	and #$7F.b		; 29 7F ; Logical AND #$7F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$40.b		; 69 40 ; Add #$40.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $A8A0.w,Y		; B9 A0 A8 ; Load $A8A0.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D90.w,X		; 9D 90 0D ; Store accumulator to $0D90.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	clc		; 18 ; Clear carry flag [Flags: C]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $13		; D0 13 ; Branch if not equal to $D0, $13 [Flow: branch]
	lda $0FFF.w		; AD FF 0F ; Load $0FFF.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $06		; D0 06 ; Branch if not equal to $D0, $06 [Flow: branch]
	lda #$17.b		; A9 17 ; Load #$17.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB8A.l		; 22 8A BB 0D ; Jump to subroutine long $0DBB8A.l [Writes: Stack Pointer] [Flow: call]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	lda #$50.b		; A9 50 ; Load #$50.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $0E70.w,X		; BD 70 0E ; Load $0E70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $07		; F0 07 ; Branch if equal to $F0, $07 [Flow: branch]
	lda $A913.w,Y		; B9 13 A9 ; Load $A913.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $A90B.w,Y		; B9 0B A9 ; Load $A90B.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $A90F.w,Y		; B9 0F A9 ; Load $A90F.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $A8A8.w,Y		; B9 A8 A8 ; Load $A8A8.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D90.w,X		; 9D 90 0D ; Store accumulator to $0D90.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	ldy $0D90.w,X		; BC 90 0D ; Load Y register $0D90.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $A95B.w,Y		; B9 5B A9 ; Load $A95B.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$3F.b		; 29 3F ; Logical AND #$3F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $A963.w,Y		; 19 63 A9 ; OR accumulator with memory $A963.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	jsl $06DBF0.l		; 22 F0 DB 06 ; Jump to subroutine long $06DBF0.l [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	lda $0E90.w,X		; BD 90 0E ; Load $0E90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $39		; F0 39 ; Branch if equal to $F0, $39 [Flow: branch]
	ldy #$B103.w		; A0 03 B1 ; Load #$B103.w into Y register [Writes: Y Index] [Flags: NZ]
	.db $90, $09		; 90 09 ; Branch if carry clear to $90, $09 [Flow: branch]
	.db $30, $91		; 30 91 ; Branch if minus to $30, $91 [Flow: branch]
	.db $90, $BD		; 90 BD ; Branch if carry clear to $90, $BD [Flow: branch]
	.db $70, $0F		; 70 0F ; Branch if overflow set to $70, $0F [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	jsr $FA2E.w		; 20 2E FA ; Jump to subroutine at $FA2E.w [Writes: Stack Pointer] [Flow: call]
	lda $0F80.w,X		; BD 80 0F ; Load $0F80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$C0.b		; C9 C0 ; Compare #$C0.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $30, $06		; 30 06 ; Branch if minus to $30, $06 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$02.b		; E9 02 ; Subtract #$02.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	eor $0F70.w,X		; 5D 70 0F ; Exclusive OR accumulator with memory $0F70.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $16		; [PATTERN: Memory clearing operation] 10 16 ; Branch if plus to $10, $16 [Flow: branch]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $11		; 10 11 ; Branch if plus to $10, $11 [Flow: branch]
	stz $0F70.w,X		; 9E 70 0F ; Store zero to $0F70.w,X [Reads: X Index]
	stz $0F80.w,X		; 9E 80 0F ; Store zero to $0F80.w,X [Reads: X Index]
	stz $0E90.w,X		; 9E 90 0E ; Store zero to $0E90.w,X [Reads: X Index]
	lda $0E60.w,X		; BD 60 0E ; Load $0E60.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$EF.b		; 29 EF ; Logical AND #$EF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E60.w,X		; 9D 60 0E ; Store accumulator to $0E60.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $0E40.w,X		; 9E 40 0E ; Store zero to $0E40.w,X [Reads: X Index]
	jsr $F971.w		; 20 71 F9 ; Jump to subroutine at $F971.w [Writes: Stack Pointer] [Flow: call]
	jsr $AB93.w		; 20 93 AB ; Jump to subroutine at $AB93.w [Writes: Stack Pointer] [Flow: call]
	jsr $F9ED.w		; 20 ED F9 ; Jump to subroutine at $F9ED.w [Writes: Stack Pointer] [Flow: call]
	jsr $B88D.w		; 20 8D B8 ; Jump to subroutine at $B88D.w [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $64		; D0 64 ; Branch if not equal to $D0, $64 [Flow: branch]
	jsr $C4F9.w		; 20 F9 C4 ; Jump to subroutine at $C4F9.w [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $36		; D0 36 ; Branch if not equal to $D0, $36 [Flow: branch]
	stz $0ED0.w,X		; 9E D0 0E ; Store zero to $0ED0.w,X [Reads: X Index]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	and #$7F.b		; 29 7F ; Logical AND #$7F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$40.b		; 69 40 ; Add #$40.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	jsr $F93F.w		; 20 3F F9 ; Jump to subroutine at $F93F.w [Writes: Stack Pointer] [Flow: call]
	lda $0E.b		; A5 0E ; Load $0E.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$10.b		; 69 10 ; Add #$10.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$20.b		; C9 20 ; Compare #$20.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $09		; 90 09 ; Branch if carry clear to $90, $09 [Flow: branch]
	lda $0F.b		; A5 0F ; Load $0F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$18.b		; 69 18 ; Add #$18.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$20.b		; C9 20 ; Compare #$20.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $09		; B0 09 ; Branch if carry set to $B0, $09 [Flow: branch]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0ED0.w,X		; 9D D0 0E ; Store accumulator to $0ED0.w,X [Reads: Accumulator, X Index]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $A96B.w,Y		; B9 6B A9 ; Load $A96B.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D90.w,X		; 9D 90 0D ; Store accumulator to $0D90.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $F0		; 10 F0 ; Branch if plus to $10, $F0 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $F0		; 10 F0 ; Branch if plus to $10, $F0 [Flow: branch]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $0E70.w,X		; BD 70 0E ; Load $0E70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $07		; F0 07 ; Branch if equal to $F0, $07 [Flow: branch]
	lda $AA40.w,Y		; B9 40 AA ; Load $AA40.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0ED0.w,X		; 7D D0 0E ; Add $0ED0.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $AA30.w,Y		; B9 30 AA ; Load $AA30.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $AA38.w,Y		; B9 38 AA ; Load $AA38.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpy #$B004.w		; C0 04 B0 ; Compare #$B004.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora ($4A.b,X)		; 01 4A ; Logical OR ($4A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $A96B.w,Y		; B9 6B A9 ; Load $A96B.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D90.w,X		; 9D 90 0D ; Store accumulator to $0D90.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cop $0A.b		; 02 0A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0E.b		; 06 0E ; Arithmetic shift left $0E.b [Reads: Direct Page] [Flags: NCZ]
	lda $0B89.w,X		; BD 89 0B ; Load $0B89.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$30.b		; 09 30 ; Logical OR #$30.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0B89.w,X		; 9D 89 0B ; Store accumulator to $0B89.w,X [Reads: Accumulator, X Index]
	jsl $06DBF0.l		; 22 F0 DB 06 ; Jump to subroutine long $06DBF0.l [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	jsr $F971.w		; 20 71 F9 ; Jump to subroutine at $F971.w [Writes: Stack Pointer] [Flow: call]
	jsr $AB93.w		; 20 93 AB ; Jump to subroutine at $AB93.w [Writes: Stack Pointer] [Flow: call]
	jsr $F9ED.w		; 20 ED F9 ; Jump to subroutine at $F9ED.w [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $5C		; D0 5C ; Branch if not equal to $D0, $5C [Flow: branch]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0DF0.w,X		; 1D F0 0D ; OR accumulator with memory $0DF0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $2F		; D0 2F ; Branch if not equal to $D0, $2F [Flow: branch]
	jsr $F93F.w		; 20 3F F9 ; Jump to subroutine at $F93F.w [Writes: Stack Pointer] [Flow: call]
	lda $0E.b		; A5 0E ; Load $0E.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$28.b		; 69 28 ; Add #$28.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$50.b		; C9 50 ; Compare #$50.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $23		; B0 23 ; Branch if carry set to $B0, $23 [Flow: branch]
	lda $0F.b		; A5 0F ; Load $0F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$28.b		; 69 28 ; Add #$28.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$50.b		; C9 50 ; Compare #$50.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $1A		; B0 1A ; Branch if carry set to $B0, $1A [Flow: branch]
	lda #$1E.b		; A9 1E ; Load #$1E.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB8A.l		; 22 8A BB 0D ; Jump to subroutine long $0DBB8A.l [Writes: Stack Pointer] [Flow: call]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$40.b		; A9 40 ; Load #$40.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	sta $0DA0.w,X		; 9D A0 0D ; Store accumulator to $0DA0.w,X [Reads: Accumulator, X Index]
	jsr $F93F.w		; 20 3F F9 ; Jump to subroutine at $F93F.w [Writes: Stack Pointer] [Flow: call]
	lda $AA87.w,Y		; B9 87 AA ; Load $AA87.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D90.w,X		; 9D 90 0D ; Store accumulator to $0D90.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	asl $0E10.w		; 0E 10 0E ; Arithmetic shift left $0E10.w [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $F2.b,X		; F5 F2 ; Subtract $F2.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $F2		; F0 F2 ; Branch if equal to $F0, $F2 [Flow: branch]
	sbc $F8.b,X		; F5 F8 ; Subtract $F8.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $F2		; F0 F2 ; Branch if equal to $F0, $F2 [Flow: branch]
	sbc $F8.b,X		; F5 F8 ; Subtract $F8.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	asl $0E10.w		; 0E 10 0E ; Arithmetic shift left $0E10.w [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $F2.b,X		; F5 F2 ; Subtract $F2.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0F		; [PATTERN: Memory clearing operation] D0 0F ; Branch if not equal to $D0, $0F [Flow: branch]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	lda #$40.b		; A9 40 ; Load #$40.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	stz $0DC0.w,X		; 9E C0 0D ; Store zero to $0DC0.w,X [Reads: X Index]
	jsr $C4F9.w		; 20 F9 C4 ; Jump to subroutine at $C4F9.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $1B		; D0 1B ; Branch if not equal to $D0, $1B [Flow: branch]
	lda $0DA0.w,X		; BD A0 0D ; Load $0DA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $AAE2.w,Y		; 79 E2 AA ; Add $AAE2.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D90.w,X		; 9D 90 0D ; Store accumulator to $0D90.w,X [Reads: Accumulator, X Index]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	inc $0DA0.w,X		; FE A0 0D ; Increment memory $0DA0.w,X [Reads: X Index] [Flags: NZ]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$0F.b		; 29 0F ; Logical AND #$0F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $AAE4.w,Y		; B9 E4 AA ; Load $AAE4.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $AAF4.w,Y		; B9 F4 AA ; Load $AAF4.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $06DBF0.l		; 22 F0 DB 06 ; Jump to subroutine long $06DBF0.l [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	jsr $F9ED.w		; 20 ED F9 ; Jump to subroutine at $F9ED.w [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$1E.b		; C9 1E ; Compare #$1E.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $06		; D0 06 ; Branch if not equal to $D0, $06 [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	jsl $05AB9C.l		; 22 9C AB 05 ; Jump to subroutine long $05AB9C.l [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	cmp #$00.b		; C9 00 ; Compare #$00.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $24		; D0 24 ; Branch if not equal to $D0, $24 [Flow: branch]
	jsr $B88D.w		; 20 8D B8 ; Jump to subroutine at $B88D.w [Writes: Stack Pointer] [Flow: call]
	.db $F0, $1F		; F0 1F ; Branch if equal to $F0, $1F [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	lda $0D10.w,X		; BD 10 0D ; Load $0D10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$04.b		; 69 04 ; Add #$04.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,X		; 9D 10 0D ; Store accumulator to $0D10.w,X [Reads: Accumulator, X Index]
	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$04.b		; 69 04 ; Add #$04.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,X		; 9D 00 0D ; Store accumulator to $0D00.w,X [Reads: Accumulator, X Index]
	jsl $06F6D5.l		; 22 D5 F6 06 ; Jump to subroutine long $06F6D5.l [Writes: Stack Pointer] [Flow: call]
	lda #$05.b		; A9 05 ; Load #$05.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB7C.l		; 22 7C BB 0D ; Jump to subroutine long $0DBB7C.l [Writes: Stack Pointer] [Flow: call]
	jsl $06F2AA.l		; 22 AA F2 06 ; Jump to subroutine long $06F2AA.l [Writes: Stack Pointer] [Flow: call]
	jsl $06F121.l		; 22 21 F1 06 ; Jump to subroutine long $06F121.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ldx #$BF1D.w		; A2 1D BF ; Load #$BF1D.w into X register [Writes: X Index] [Flags: NZ]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $CA04F0.l,X		; 7F F0 04 CA ; Add long $CA04F0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $F7		; 10 F7 ; Branch if plus to $10, $F7 [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	lda #$0A.b		; A9 0A ; Load #$0A.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7FF800.l,X		; 9F 00 F8 7F ; Store accumulator (long,X) $7FF800.l,X [Reads: Accumulator, X Index]
	sta $0FB4.w		; 8D B4 0F ; Store accumulator to $0FB4.w [Reads: Accumulator]
	lda $0D10.w,Y		; B9 10 0D ; Load $0D10.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $7FF83C.l,X		; 9F 3C F8 7F ; Store accumulator (long,X) $7FF83C.l,X [Reads: Accumulator, X Index]
	lda $0D30.w,Y		; B9 30 0D ; Load $0D30.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $7FF878.l,X		; 9F 78 F8 7F ; Store accumulator (long,X) $7FF878.l,X [Reads: Accumulator, X Index]
	lda $0D00.w,Y		; B9 00 0D ; Load $0D00.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$10.b		; 69 10 ; Add #$10.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $7FF81E.l,X		; 9F 1E F8 7F ; Store accumulator (long,X) $7FF81E.l,X [Reads: Accumulator, X Index]
	lda $0D20.w,Y		; B9 20 0D ; Load $0D20.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $7FF85A.l,X		; 9F 5A F8 7F ; Store accumulator (long,X) $7FF85A.l,X [Reads: Accumulator, X Index]
	lda $0F20.w,Y		; B9 20 0F ; Load $0F20.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $7FF92C.l,X		; 9F 2C F9 7F ; Store accumulator (long,X) $7FF92C.l,X [Reads: Accumulator, X Index]
	lda #$0F.b		; A9 0F ; Load #$0F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7FF90E.l,X		; 9F 0E F9 7F ; Store accumulator (long,X) $7FF90E.l,X [Reads: Accumulator, X Index]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DB0.w,X		; BD B0 0D ; Load $0DB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	jmp $AB54.w		; 4C 54 AB ; Jump to $AB54.w [Flow: jump]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	lda $0E00.w,X		; BD 00 0E ; Load $0E00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $06		; F0 06 ; Branch if equal to $F0, $06 [Flow: branch]
	lda $B5CB.w,Y		; B9 CB B5 ; Load $B5CB.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	jsr $AEF9.w		; 20 F9 AE ; Jump to subroutine at $AEF9.w [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	jsr $AB93.w		; 20 93 AB ; Jump to subroutine at $AB93.w [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
.ACCU 16
.INDEX 16
	rep #$30		; C2 30
	and #$00FF.w		; 29 FF 00 ; Logical AND #$00FF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $AC1A.w,Y		; B9 1A AC ; Load $AC1A.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	bit $AC.b		; 24 AC ; Test bits $AC.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	eor ($AC.b)		; 52 AC ; Exclusive OR accumulator with memory (indirect) ($AC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc ($AC.b)		; F2 AC ; Subtract with carry (indirect) ($AC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($AD.b)		; 12 AD ; OR accumulator with memory (indirect) ($AD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	lda $909E.w		; AD 9E 90 ; Load $909E.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $F0BD.w		; 0D BD F0 ; Logical OR $F0BD.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $25D0.w		; 0D D0 25 ; Logical OR $25D0.w with accumulator [Writes: Accumulator] [Flags: NZ]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$60.b		; A9 60 ; Load #$60.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	jsr $F93F.w		; 20 3F F9 ; Jump to subroutine at $F93F.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	cmp $0DE0.w,X		; DD E0 0D ; Compare accumulator $0DE0.w,X [Reads: X Index] [Flags: NCZ]
	.db $F0, $0C		; F0 0C ; Branch if equal to $F0, $0C [Flow: branch]
	eor $0DE0.w,X		; 5D E0 0D ; Exclusive OR accumulator with memory $0DE0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$02.b		; 29 02 ; Logical AND #$02.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $05		; D0 05 ; Branch if not equal to $D0, $05 [Flow: branch]
	lda #$0C.b		; A9 0C ; Load #$0C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E00.w,X		; 9D 00 0E ; Store accumulator to $0E00.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy $0DF0.w,X		; BC F0 0D ; Load Y register $0DF0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	.db $F0, $22		; F0 22 ; Branch if equal to $F0, $22 [Flow: branch]
	cpy #$30.b		; C0 30 ; Compare #$30.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $B0, $02		; B0 02 ; Branch if carry set to $B0, $02 [Flow: branch]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D90.w,X		; 9D 90 0D ; Store accumulator to $0D90.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $10, $F0		; 10 F0 ; Branch if plus to $10, $F0 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $00E818.l,X		; FF 18 E8 00 ; Subtract with carry (long,X) $00E818.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda #$6B.b		; A9 6B ; Load #$6B.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $5E		; 30 5E ; Branch if minus to $30, $5E [Flow: branch]
	lda #$07.b		; A9 07 ; Load #$07.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB8A.l		; 22 8A BB 0D ; Jump to subroutine long $0DBB8A.l [Writes: Stack Pointer] [Flow: call]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DB0.w,Y		; 99 B0 0D ; Store accumulator to $0DB0.w,Y [Reads: Y Index, Accumulator]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $AC63.w,X		; 7D 63 AC ; Add $AC63.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,Y		; 99 10 0D ; Store accumulator to $0D10.w,Y [Reads: Y Index, Accumulator]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $AC67.w,X		; 7D 67 AC ; Add $AC67.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D30.w,Y		; 99 30 0D ; Store accumulator to $0D30.w,Y [Reads: Y Index, Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $AC6B.w,X		; 7D 6B AC ; Add $AC6B.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,Y		; 99 00 0D ; Store accumulator to $0D00.w,Y [Reads: Y Index, Accumulator]
	lda $03.b		; A5 03 ; Load $03.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $AC6F.w,X		; 7D 6F AC ; Add $AC6F.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D20.w,Y		; 99 20 0D ; Store accumulator to $0D20.w,Y [Reads: Y Index, Accumulator]
	lda $AC73.w,X		; BD 73 AC ; Load $AC73.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,Y		; 99 50 0D ; Store accumulator to $0D50.w,Y [Reads: Y Index, Accumulator]
	lda $AC77.w,X		; BD 77 AC ; Load $AC77.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,Y		; 99 40 0D ; Store accumulator to $0D40.w,Y [Reads: Y Index, Accumulator]
	lda $0E40.w,Y		; B9 40 0E ; Load $0E40.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and #$F0.b		; 29 F0 ; Logical AND #$F0.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$01.b		; 09 01 ; Logical OR #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E40.w,Y		; 99 40 0E ; Store accumulator to $0E40.w,Y [Reads: Y Index, Accumulator]
	lda $0E60.w,Y		; B9 60 0E ; Load $0E60.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora #$47.b		; 09 47 ; Logical OR #$47.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E60.w,Y		; 99 60 0E ; Store accumulator to $0E60.w,Y [Reads: Y Index, Accumulator]
	lda $0CAA.w,Y		; B9 AA 0C ; Load $0CAA.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora #$44.b		; 09 44 ; Logical OR #$44.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0CAA.w,Y		; 99 AA 0C ; Store accumulator to $0CAA.w,Y [Reads: Y Index, Accumulator]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,Y		; 99 F0 0D ; Store accumulator to $0DF0.w,Y [Reads: Y Index, Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpx #$20.b		; E0 20 ; Compare #$20.b with X register [Reads: X Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$20.b		; E0 20 ; Compare #$20.b with X register [Reads: X Index] [Flags: NCZ]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $ACEA.w,Y		; B9 EA AC ; Load $ACEA.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $ACEE.w,Y		; B9 EE AC ; Load $ACEE.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	jsr $F9ED.w		; 20 ED F9 ; Jump to subroutine at $F9ED.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	lda #$80.b		; A9 80 ; Load #$80.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $AD20.w,Y		; B9 20 AD ; Load $AD20.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $AD24.w,Y		; B9 24 AD ; Load $AD24.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	jsr $F9ED.w		; 20 ED F9 ; Jump to subroutine at $F9ED.w [Writes: Stack Pointer] [Flow: call]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D90.w,X		; 9D 90 0D ; Store accumulator to $0D90.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr ($04FF.w,X)		; FC FF 04 ; Jump to subroutine indirect indexed ($04FF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000004.l,X		; FF 04 00 00 ; Subtract with carry (long,X) $000004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000004.l,X		; FF 04 00 00 ; Subtract with carry (long,X) $000004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $F8FFF8.l,X		; FF F8 FF F8 ; Subtract with carry (long,X) $F8FFF8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $040004.l,X		; FF 04 00 04 ; Subtract with carry (long,X) $040004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $F8FFF8.l,X		; FF F8 FF F8 ; Subtract with carry (long,X) $F8FFF8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $040004.l,X		; FF 04 00 04 ; Subtract with carry (long,X) $040004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $090009.l,X		; FF 09 00 09 ; Subtract with carry (long,X) $090009.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000004.l,X		; FF 04 00 00 ; Subtract with carry (long,X) $000004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000004.l,X		; FF 04 00 00 ; Subtract with carry (long,X) $000004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000004.l,X		; FF 04 00 00 ; Subtract with carry (long,X) $000004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FCFFFC.l,X		; FF FC FF FC ; Subtract with carry (long,X) $FCFFFC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $080008.l,X		; FF 08 00 08 ; Subtract with carry (long,X) $080008.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $08FFFC.l,X		; FF FC FF 08 ; Subtract with carry (long,X) $08FFFC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $08FFFC.l,X		; FF FC FF 08 ; Subtract with carry (long,X) $08FFFC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $00FFFF.l,X		; FF FF FF 00 ; Subtract with carry (long,X) $00FFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $070007.l,X		; FF 07 00 07 ; Subtract with carry (long,X) $070007.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $070007.l,X		; FF 07 00 07 ; Subtract with carry (long,X) $070007.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FD0007.l,X		; FF 07 00 FD ; Subtract with carry (long,X) $FD0007.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F70000.l,X		; FF 00 00 F7 ; Subtract with carry (long,X) $F70000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $000000.l,X		; FF 00 00 00 ; Subtract with carry (long,X) $000000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000000.l,X		; FF 00 00 00 ; Subtract with carry (long,X) $000000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000000.l,X		; FF 00 00 00 ; Subtract with carry (long,X) $000000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000000.l,X		; FF 00 00 00 ; Subtract with carry (long,X) $000000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $F4FFF7.l,X		; FF F7 FF F4 ; Subtract with carry (long,X) $F4FFF7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $000000.l,X		; FF 00 00 00 ; Subtract with carry (long,X) $000000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $F4FFF7.l,X		; FF F7 FF F4 ; Subtract with carry (long,X) $F4FFF7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $000000.l,X		; FF 00 00 00 ; Subtract with carry (long,X) $000000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $00FFFD.l,X		; FF FD FF 00 ; Subtract with carry (long,X) $00FFFD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000000.l,X		; FF 00 00 00 ; Subtract with carry (long,X) $000000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000000.l,X		; FF 00 00 00 ; Subtract with carry (long,X) $000000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000000.l,X		; FF 00 00 00 ; Subtract with carry (long,X) $000000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $46.b		; 00 46 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $00.b		; 46 00 ; Logical shift right $00.b [Reads: Direct Page] [Flags: NCZ]
	bit $24.b		; 24 24 ; Test bits $24.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	eor #$00.b		; 49 00 ; Exclusive OR #$00.b with accumulator [Writes: Accumulator] [Flags: NZ]
	bit $24.b		; 24 24 ; Test bits $24.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	lsr $06.b		; 46 06 ; Logical shift right $06.b [Reads: Direct Page] [Flags: NCZ]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $26024E.l		; 2F 4E 02 26 ; AND accumulator with memory (long) $26024E.l [Writes: Accumulator] [Flags: NZ]
	rol $26.b		; 26 26 ; Rotate left $26.b [Reads: Direct Page] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cop $26.b		; 02 26 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $26.b		; 26 26 ; Rotate left $26.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cop $26.b		; 02 26 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $64282F.l		; 2F 2F 28 64 ; AND accumulator with memory (long) $64282F.l [Writes: Accumulator] [Flags: NZ]
	stz $04.b		; 64 04 ; Store zero to $04.b
	tsb $28.b		; 04 28 ; Test and set bits $28.b [Reads: Accumulator] [Flags: Z]
	ror $67.b		; 66 67 ; Rotate right $67.b [Reads: Direct Page] [Flags: NCZ]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	stz $04.b		; 64 04 ; Store zero to $04.b
	and $26024E.l		; 2F 4E 02 26 ; AND accumulator with memory (long) $26024E.l [Writes: Accumulator] [Flags: NZ]
	rol $26.b		; 26 26 ; Rotate left $26.b [Reads: Direct Page] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cop $26.b		; 02 26 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $26.b		; 26 26 ; Rotate left $26.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cop $26.b		; 02 26 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $40002F.l		; 2F 2F 00 40 ; AND accumulator with memory (long) $40002F.l [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$03.b		; 09 03 ; Logical OR #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $FA50.w		; 20 50 FA ; Jump to subroutine at $FA50.w [Writes: Stack Pointer] [Flow: call]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $AEF5.w,Y		; B9 F5 AE ; Load $AEF5.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0D90.w,X		; 7D 90 0D ; Add $0D90.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc $06.b		; 65 06 ; Add $06.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx #$04.b		; A2 04 ; Load #$04.b into X register [Writes: X Index] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $06.b		; 65 06 ; Add $06.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $AD51.w,X		; 7D 51 AD ; Add $AD51.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	and #$0100.w		; 29 00 01 ; Logical AND #$0100.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E.b		; 85 0E ; Store accumulator to $0E.b [Reads: Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $ADC9.w,X		; 7D C9 AD ; Add $ADC9.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0010.w		; 69 10 00 ; Add #$0010.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0100.w		; C9 00 01 ; Compare #$0100.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $05		; 90 05 ; Branch if carry clear to $90, $05 [Flow: branch]
	lda #$00F0.w		; A9 F0 00 ; Load #$00F0.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
.ACCU 8
	sep #$20		; E2 20
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda $AE41.w,X		; BD 41 AE ; Load $AE41.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$24.b		; E9 24 ; Subtract #$24.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cmp #$05.b		; C9 05 ; Compare #$05.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	lda $AE7D.w,X		; BD 7D AE ; Load $AE7D.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $04		; B0 04 ; Branch if carry set to $B0, $04 [Flow: branch]
	and #$F1.b		; 29 F1 ; Logical AND #$F1.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$06.b		; 09 06 ; Logical OR #$06.b with accumulator [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $AEB9.w,X		; BD B9 AE ; Load $AEB9.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $0F.b		; 05 0F ; Logical OR $0F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($92.b),Y		; 91 92 ; Store accumulator ($92.b),Y [Reads: Direct Page, Y Index, Accumulator]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $A4		; 10 A4 ; Branch if plus to $10, $A4 [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$80.b		; C0 80 ; Compare #$80.b with Y register [Reads: Y Index] [Flags: NCZ]
	lda $7EF3CA.l		; AF CA F3 7E ; Load long $7EF3CA.l into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $64		; D0 64 ; Branch if not equal to $D0, $64 [Flow: branch]
	lda $8A.b		; A5 8A ; Load $8A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$80.b		; C9 80 ; Compare #$80.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $01		; 90 01 ; Branch if carry clear to $90, $01 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $11.b		; A5 11 ; Load $11.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$23.b		; C9 23 ; Compare #$23.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $0B		; F0 0B ; Branch if equal to $F0, $0B [Flow: branch]
	lda $0FC6.w		; AD C6 0F ; Load $0FC6.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $04		; B0 04 ; Branch if carry set to $B0, $04 [Flow: branch]
	jsl $06DBF0.l		; 22 F0 DB 06 ; Jump to subroutine long $06DBF0.l [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$3F.b		; 29 3F ; Logical AND #$3F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $AF71.w,Y		; 19 71 AF ; OR accumulator with memory $AF71.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	jsl $07F4D0.l		; 22 D0 F4 07 ; Jump to subroutine long $07F4D0.l [Writes: Stack Pointer] [Flow: call]
	.db $B0, $6A		; B0 6A ; Branch if carry set to $B0, $6A [Flow: branch]
	jsl $06F129.l		; 22 29 F1 06 ; Jump to subroutine long $06F129.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $30		; 90 30 ; Branch if carry clear to $90, $30 [Flow: branch]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $38		; F0 38 ; Branch if equal to $F0, $38 [Flow: branch]
	lda $037B.w		; AD 7B 03 ; Load $037B.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $031F.w		; 0D 1F 03 ; Logical OR $031F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $30		; D0 30 ; Branch if not equal to $D0, $30 [Flow: branch]
	lda $02E4.w		; AD E4 02 ; Load $02E4.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $2B		; D0 2B ; Branch if not equal to $D0, $2B [Flow: branch]
	lda #$23.b		; A9 23 ; Load #$23.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $11.b		; [PATTERN: Memory clearing operation] 85 11 ; Store accumulator to $11.b [Reads: Accumulator]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $02DB.w		; 8D DB 02 ; Store accumulator to $02DB.w [Reads: Accumulator]
	stz $B0.b		; 64 B0 ; Store zero to $B0.b
	stz $27.b		; 64 27 ; Store zero to $27.b
	stz $28.b		; 64 28 ; Store zero to $28.b
	lda #$14.b		; A9 14 ; Load #$14.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $5D.b		; 85 5D ; Store accumulator to $5D.b [Reads: Accumulator]
	lda $8A.b		; A5 8A ; Load $8A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$40.b		; 29 40 ; Logical AND #$40.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7B.b		; 85 7B ; Store accumulator to $7B.b [Reads: Accumulator]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	.db $80, $0D		; 80 0D ; Branch always to $80, $0D [Flow: branch]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D90.w,X		; 9D 90 0D ; Store accumulator to $0D90.w,X [Reads: Accumulator, X Index]
	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$FF.b		; 29 FF ; Logical AND #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	inc $0DA0.w,X		; FE A0 0D ; Increment memory $0DA0.w,X [Reads: X Index] [Flags: NZ]
	.db $D0, $05		; D0 05 ; Branch if not equal to $D0, $05 [Flow: branch]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D90.w,X		; 9D 90 0D ; Store accumulator to $0D90.w,X [Reads: Accumulator, X Index]
	lda $1ABF.w		; AD BF 1A ; Load $1ABF.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D10.w,X		; 9D 10 0D ; Store accumulator to $0D10.w,X [Reads: Accumulator, X Index]
	lda $1ACF.w		; AD CF 1A ; Load $1ACF.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D30.w,X		; 9D 30 0D ; Store accumulator to $0D30.w,X [Reads: Accumulator, X Index]
	lda $1ADF.w		; AD DF 1A ; Load $1ADF.w into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$08.b		; 69 08 ; Add #$08.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,X		; 9D 00 0D ; Store accumulator to $0D00.w,X [Reads: Accumulator, X Index]
	lda $1AEF.w		; AD EF 1A ; Load $1AEF.w into accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D20.w,X		; 9D 20 0D ; Store accumulator to $0D20.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $442010.l		; 22 10 20 44 ; Jump to subroutine long $442010.l [Writes: Stack Pointer] [Flow: call]
	lda ($BD.b),Y		; B1 BD ; Load accumulator ($BD.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $80, $0D		; 80 0D ; Branch always to $80, $0D [Flow: branch]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $05		; B0 05 ; Branch if carry set to $B0, $05 [Flow: branch]
	lda #$80.b		; A9 80 ; Load #$80.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0FAB.w		; 8D AB 0F ; Store accumulator to $0FAB.w [Reads: Accumulator]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	jsl $06EB5E.l		; 22 5E EB 06 ; Jump to subroutine long $06EB5E.l [Writes: Stack Pointer] [Flow: call]
	ldy $0D80.w,X		; BC 80 0D ; Load Y register $0D80.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $B017.w,Y		; B9 17 B0 ; Load $B017.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0D90.w,X		; 7D 90 0D ; Add $0D90.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D90.w,X		; 9D 90 0D ; Store accumulator to $0D90.w,X [Reads: Accumulator, X Index]
	lda $0DA0.w,X		; BD A0 0D ; Load $0DA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DA0.w,X		; 9D A0 0D ; Store accumulator to $0DA0.w,X [Reads: Accumulator, X Index]
	jsr $F971.w		; 20 71 F9 ; Jump to subroutine at $F971.w [Writes: Stack Pointer] [Flow: call]
	jsr $B88D.w		; 20 8D B8 ; Jump to subroutine at $B88D.w [Writes: Stack Pointer] [Flow: call]
	jsr $F9ED.w		; 20 ED F9 ; Jump to subroutine at $F9ED.w [Writes: Stack Pointer] [Flow: call]
	jsl $06F121.l		; 22 21 F1 06 ; Jump to subroutine long $06F121.l [Writes: Stack Pointer] [Flow: call]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$0F.b		; 29 0F ; Logical AND #$0F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $07		; D0 07 ; Branch if not equal to $D0, $07 [Flow: branch]
	jsr $F93F.w		; 20 3F F9 ; Jump to subroutine at $F93F.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
.ACCU 16
.INDEX 16
	rep #$30		; C2 30
	and #$00FF.w		; 29 FF 00 ; Logical AND #$00FF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $B075.w,Y		; B9 75 B0 ; Load $B075.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc $E7B0.w,X		; 7D B0 E7 ; Add $E7B0.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $B0, $FC		; B0 FC ; Branch if carry set to $B0, $FC [Flow: branch]
	.db $B0, $2E		; B0 2E ; Branch if carry set to $B0, $2E [Flow: branch]
	lda ($8A.b),Y		; B1 8A ; Load accumulator ($8A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$0F.b		; 29 0F ; Logical AND #$0F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $27		; D0 27 ; Branch if not equal to $D0, $27 [Flow: branch]
	lda $0EB0.w,X		; BD B0 0E ; Load $0EB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	lda $0E.b		; A5 0E ; Load $0E.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$40.b		; 69 40 ; Add #$40.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$68.b		; C9 68 ; Compare #$68.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $12		; B0 12 ; Branch if carry set to $B0, $12 [Flow: branch]
	lda $0F.b		; A5 0F ; Load $0F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$30.b		; 69 30 ; Add #$30.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$60.b		; C9 60 ; Compare #$60.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $09		; B0 09 ; Branch if carry set to $B0, $09 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$08.b		; A9 08 ; Load #$08.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06EA12.l		; 22 12 EA 06 ; Jump to subroutine long $06EA12.l [Writes: Stack Pointer] [Flow: call]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $B0C7.w,Y		; B9 C7 B0 ; Load $B0C7.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $10, $11		; 10 11 ; Branch if plus to $10, $11 [Flow: branch]
	ora ($13.b)		; 12 13 ; OR accumulator with memory (indirect) ($13.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $11		; 10 11 ; Branch if plus to $10, $11 [Flow: branch]
	ora ($13.b)		; 12 13 ; OR accumulator with memory (indirect) ($13.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora #$06.b		; 09 06 ; Logical OR #$06.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$00.b		; 09 00 ; Logical OR #$00.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $0A.b		; 05 0A ; Logical OR $0A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tsb $0A0D.w		; 0C 0D 0A ; Test and set bits $0A0D.w [Reads: Accumulator] [Flags: Z]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	asl $200F.w		; 0E 0F 20 ; Arithmetic shift left $200F.w [Flags: NCZ]
	sbc $BDC4.w,Y		; F9 C4 BD ; Subtract with carry $BDC4.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $0D		; F0 0D ; Branch if equal to $F0, $0D [Flow: branch]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	lda #$30.b		; A9 30 ; Load #$30.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $19		; D0 19 ; Branch if not equal to $D0, $19 [Flow: branch]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lda $0DA0.w,X		; BD A0 0D ; Load $0DA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $B0F8.w,Y		; B9 F8 B0 ; Load $B0F8.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $0EB0.w,X		; DD B0 0E ; Compare accumulator $0EB0.w,X [Reads: X Index] [Flags: NCZ]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$1F.b		; A9 1F ; Load #$1F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E10.w,X		; 9D 10 0E ; Store accumulator to $0E10.w,X [Reads: Accumulator, X Index]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	jsr $B0AB.w		; 20 AB B0 ; Jump to subroutine at $B0AB.w [Writes: Stack Pointer] [Flow: call]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$0F.b		; 29 0F ; Logical AND #$0F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $06		; D0 06 ; Branch if not equal to $D0, $06 [Flow: branch]
	lda #$06.b		; A9 06 ; Load #$06.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB8A.l		; 22 8A BB 0D ; Jump to subroutine long $0DBB8A.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $C4F9.w		; 20 F9 C4 ; Jump to subroutine at $C4F9.w [Writes: Stack Pointer] [Flow: call]
	lda $0E10.w,X		; BD 10 0E ; Load $0E10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	cmp #$10.b		; C9 10 ; Compare #$10.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $DD		; B0 DD ; Branch if carry set to $B0, $DD [Flow: branch]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	jsr $B0AB.w		; 20 AB B0 ; Jump to subroutine at $B0AB.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $FA50.w		; 20 50 FA ; Jump to subroutine at $FA50.w [Writes: Stack Pointer] [Flow: call]
	jsr $B15E.w		; 20 5E B1 ; Jump to subroutine at $B15E.w [Writes: Stack Pointer] [Flow: call]
	jsr $B3CB.w		; 20 CB B3 ; Jump to subroutine at $B3CB.w [Writes: Stack Pointer] [Flow: call]
	jsr $B468.w		; 20 68 B4 ; Jump to subroutine at $B468.w [Writes: Stack Pointer] [Flow: call]
	jsr $FA50.w		; 20 50 FA ; Jump to subroutine at $FA50.w [Writes: Stack Pointer] [Flow: call]
	jmp $C68C.w		; 4C 8C C6 ; Jump to $C68C.w [Flow: jump]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	lda $0EB0.w,X		; BD B0 0E ; Load $0EB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	and #$0100.w		; 29 00 01 ; Logical AND #$0100.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E.b		; 85 0E ; Store accumulator to $0E.b [Reads: Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$0009.w		; E9 09 00 ; Subtract #$0009.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0010.w		; 69 10 00 ; Add #$0010.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0100.w		; C9 00 01 ; Compare #$0100.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $05		; 90 05 ; Branch if carry clear to $90, $05 [Flow: branch]
	lda #$00F0.w		; A9 F0 00 ; Load #$00F0.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
.ACCU 8
	sep #$20		; E2 20
	lda $B156.w,X		; BD 56 B1 ; Load $B156.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $B15A.w,X		; BD 5A B1 ; Load $B15A.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0F.b		; 05 0F ; Logical OR $0F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($92.b),Y		; 91 92 ; Store accumulator ($92.b),Y [Reads: Direct Page, Y Index, Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr ($04FF.w,X)		; FC FF 04 ; Jump to subroutine indirect indexed ($04FF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0D0004.l,X		; FF 04 00 0D ; Subtract with carry (long,X) $0D0004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0D0004.l,X		; FF 04 00 0D ; Subtract with carry (long,X) $0D0004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0D0004.l,X		; FF 04 00 0D ; Subtract with carry (long,X) $0D0004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0D0004.l,X		; FF 04 00 0D ; Subtract with carry (long,X) $0D0004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0D0004.l,X		; FF 04 00 0D ; Subtract with carry (long,X) $0D0004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FA0004.l,X		; FF 04 00 FA ; Subtract with carry (long,X) $FA0004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $04FFFC.l,X		; FF FC FF 04 ; Subtract with carry (long,X) $04FFFC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $04FFFC.l,X		; FF FC FF 04 ; Subtract with carry (long,X) $04FFFC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $04FFFC.l,X		; FF FC FF 04 ; Subtract with carry (long,X) $04FFFC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $04FFFC.l,X		; FF FC FF 04 ; Subtract with carry (long,X) $04FFFC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $04FFFC.l,X		; FF FC FF 04 ; Subtract with carry (long,X) $04FFFC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000000.l,X		; FF 00 00 00 ; Subtract with carry (long,X) $000000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $040004.l,X		; FF 04 00 04 ; Subtract with carry (long,X) $040004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $040004.l,X		; FF 04 00 04 ; Subtract with carry (long,X) $040004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000000.l,X		; FF 00 00 00 ; Subtract with carry (long,X) $000000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000000.l,X		; FF 00 00 00 ; Subtract with carry (long,X) $000000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000000.l,X		; FF 00 00 00 ; Subtract with carry (long,X) $000000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000000.l,X		; FF 00 00 00 ; Subtract with carry (long,X) $000000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000000.l,X		; FF 00 00 00 ; Subtract with carry (long,X) $000000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000000.l,X		; FF 00 00 00 ; Subtract with carry (long,X) $000000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000000.l,X		; FF 00 00 00 ; Subtract with carry (long,X) $000000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000000.l,X		; FF 00 00 00 ; Subtract with carry (long,X) $000000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000000.l,X		; FF 00 00 00 ; Subtract with carry (long,X) $000000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000000.l,X		; FF 00 00 00 ; Subtract with carry (long,X) $000000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000000.l,X		; FF 00 00 00 ; Subtract with carry (long,X) $000000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000000.l,X		; FF 00 00 00 ; Subtract with carry (long,X) $000000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $46.b		; 00 46 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $2F.b		; 06 2F ; Arithmetic shift left $2F.b [Reads: Direct Page] [Flags: NCZ]
	lsr $06.b		; 46 06 ; Logical shift right $06.b [Reads: Direct Page] [Flags: NCZ]
	and $2F0D48.l		; 2F 48 0D 2F ; AND accumulator with memory (long) $2F0D48.l [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	ora $492F.w		; 0D 2F 49 ; Logical OR $492F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $492F.w		; 0C 2F 49 ; Test and set bits $492F.w [Reads: Accumulator] [Flags: Z]
	tsb $082F.w		; 0C 2F 08 ; Test and set bits $082F.w [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $2F0808.l		; 2F 08 08 2F ; AND accumulator with memory (long) $2F0808.l [Writes: Accumulator] [Flags: NZ]
	jsl $222F22.l		; 22 22 2F 22 ; Jump to subroutine long $222F22.l [Writes: Stack Pointer] [Flow: call]
	jsl $640A2F.l		; 22 2F 0A 64 ; Jump to subroutine long $640A2F.l [Writes: Stack Pointer] [Flow: call]
	and $2F640A.l		; 2F 0A 64 2F ; AND accumulator with memory (long) $2F640A.l [Writes: Accumulator] [Flags: NZ]
	bit $2F67.w		; 2C 67 2F ; Test bits $2F67.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	bit $2F67.w		; 2C 67 2F ; Test bits $2F67.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	and $2F66.w		; 2D 66 2F ; Logical AND $2F66.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $2F66.w		; 2D 66 2F ; Logical AND $2F66.w with accumulator [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $2F0808.l		; 2F 08 08 2F ; AND accumulator with memory (long) $2F0808.l [Writes: Accumulator] [Flags: NZ]
	jsl $222F22.l		; 22 22 2F 22 ; Jump to subroutine long $222F22.l [Writes: Stack Pointer] [Flow: call]
	jsl $62622F.l		; 22 2F 62 62 ; Jump to subroutine long $62622F.l [Writes: Stack Pointer] [Flow: call]
	.db $62, $62, $62		; 62 62 62 ; Push effective relative address $62, $62, $62 [Writes: Stack Pointer]
	.db $62, $46, $4B		; 62 46 4B ; Push effective relative address $62, $46, $4B [Writes: Stack Pointer]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	adc #$64.b		; 69 64 ; Add #$64.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	stz $00.b		; 64 00 ; Store zero to $00.b
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ldy #$14.b		; A0 14 ; Load #$14.b into Y register [Writes: Y Index] [Flags: NZ]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc $0DC0.w,X		; 7D C0 0D ; Add $0DC0.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $B3B3.w,X		; 7D B3 B3 ; Add $B3B3.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $B39B.w,X		; BD 9B B3 ; Load $B39B.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $06.b		; 65 06 ; Add $06.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $B1A3.w,X		; 7D A3 B1 ; Add $B1A3.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	and #$0100.w		; 29 00 01 ; Logical AND #$0100.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E.b		; 85 0E ; Store accumulator to $0E.b [Reads: Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $B233.w,X		; 7D 33 B2 ; Add $B233.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0010.w		; 69 10 00 ; Add #$0010.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0100.w		; C9 00 01 ; Compare #$0100.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $05		; 90 05 ; Branch if carry clear to $90, $05 [Flow: branch]
	lda #$00F0.w		; A9 F0 00 ; Load #$00F0.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
.ACCU 8
	sep #$20		; E2 20
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda $B2C3.w,X		; BD C3 B2 ; Load $B2C3.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $B30B.w,X		; BD 0B B3 ; Load $B30B.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $B353.w,X		; BD 53 B3 ; Load $B353.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $0F.b		; 05 0F ; Logical OR $0F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($92.b),Y		; 91 92 ; Store accumulator ($92.b),Y [Reads: Direct Page, Y Index, Accumulator]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	cpx #$02.b		; E0 02 ; Compare #$02.b with X register [Reads: X Index] [Flags: NCZ]
	.db $D0, $04		; D0 04 ; Branch if not equal to $D0, $04 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $A7		; 10 A7 ; Branch if plus to $10, $A7 [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $10, $12		; 10 12 ; Branch if plus to $10, $12 [Flow: branch]
	trb $16.b		; 14 16 ; Test and reset bits $16.b [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	trb $201E.w		; 1C 1E 20 ; Test and reset bits $201E.w [Reads: Accumulator] [Flags: Z]
	jsl $282624.l		; 22 24 26 28 ; Jump to subroutine long $282624.l [Writes: Stack Pointer] [Flow: call]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	bit $302E.w		; 2C 2E 30 ; Test bits $302E.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	rol $2A2C.w		; 2E 2C 2A ; Rotate left $2A2C.w [Flags: NCZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	rol $24.b		; 26 24 ; Rotate left $24.b [Reads: Direct Page] [Flags: NCZ]
	jsl $1C1E20.l		; 22 20 1E 1C ; Jump to subroutine long $1C1E20.l [Writes: Stack Pointer] [Flow: call]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	asl $14.b,X		; 16 14 ; Arithmetic shift left $14.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($04.b)		; 12 04 ; OR accumulator with memory (indirect) ($04.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $0C.b		; 04 0C ; Test and set bits $0C.b [Reads: Accumulator] [Flags: Z]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	inc $FAFE.w,X		; FE FE FA ; Increment memory $FAFE.w,X [Reads: X Index] [Flags: NZ]
	jsr ($00A5.w,X)		; FC A5 00 ; Jump to subroutine indirect indexed ($00A5.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sta $0FA8.w		; 8D A8 0F ; Store accumulator to $0FA8.w [Reads: Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0FA9.w		; 8D A9 0F ; Store accumulator to $0FA9.w [Reads: Accumulator]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $0DA0.w,X		; BD A0 0D ; Load $0DA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $01.b		; 85 01 ; Store accumulator to $01.b [Reads: Accumulator]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy $0D80.w,X		; BC 80 0D ; Load Y register $0D80.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	cpy #$02.b		; C0 02 ; Compare #$02.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $90, $07		; 90 07 ; Branch if carry clear to $90, $07 [Flow: branch]
	lda $0E10.w,X		; BD 10 0E ; Load $0E10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $B440.w,Y		; B9 40 B4 ; Load $B440.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0F.b		; 85 0F ; Store accumulator to $0F.b [Reads: Accumulator]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $B460.w,Y		; B9 60 B4 ; Load $B460.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0C.b		; 85 0C ; Store accumulator to $0C.b [Reads: Accumulator]
	lda $B464.w,Y		; B9 64 B4 ; Load $B464.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D.b		; 85 0D ; Store accumulator to $0D.b [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
.ACCU 16
.INDEX 16
	rep #$30		; C2 30
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$01FF.w		; 29 FF 01 ; Logical AND #$01FF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $0A.b		; 85 0A ; Store accumulator to $0A.b [Reads: Accumulator]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0080.w		; 69 80 00 ; Add #$0080.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	and #$01FF.w		; 29 FF 01 ; Logical AND #$01FF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$00FF.w		; 29 FF 00 ; Logical AND #$00FF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $04E800.l,X		; BF 00 E8 04 ; Load long $04E800.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$00FF.w		; 29 FF 00 ; Logical AND #$00FF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $04E800.l,X		; BF 00 E8 04 ; Load long $04E800.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda $04.b		; A5 04 ; Load $04.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta WRMPYA.w		; 8D 02 42 ; Store accumulator to WRMPYA.w [Reads: Accumulator]
	lda $0F.b		; A5 0F ; Load $0F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy $05.b		; A4 05 ; Load $05.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	.db $D0, $0E		; D0 0E ; Branch if not equal to $D0, $0E [Flow: branch]
	sta WRMPYB.w		; 8D 03 42 ; Store accumulator to WRMPYB.w [Reads: Accumulator]
	jsr $B5BE.w		; 20 BE B5 ; Jump to subroutine at $B5BE.w [Writes: Stack Pointer] [Flow: call]
	asl $4216.w		; 0E 16 42 ; Arithmetic shift left $4216.w [Flags: NCZ]
	lda RDMPYH.w		; AD 17 42 ; Load RDMPYH.w into accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0E.b		; 85 0E ; Store accumulator to $0E.b [Reads: Accumulator]
	lsr $01.b		; 46 01 ; Logical shift right $01.b [Reads: Direct Page] [Flags: NCZ]
	.db $90, $03		; 90 03 ; Branch if carry clear to $90, $03 [Flow: branch]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	lda $06.b		; A5 06 ; Load $06.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta WRMPYA.w		; 8D 02 42 ; Store accumulator to WRMPYA.w [Reads: Accumulator]
	lda $0F.b		; A5 0F ; Load $0F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy $07.b		; A4 07 ; Load $07.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	.db $D0, $0E		; D0 0E ; Branch if not equal to $D0, $0E [Flow: branch]
	sta WRMPYB.w		; 8D 03 42 ; Store accumulator to WRMPYB.w [Reads: Accumulator]
	jsr $B5BE.w		; 20 BE B5 ; Jump to subroutine at $B5BE.w [Writes: Stack Pointer] [Flow: call]
	asl $4216.w		; 0E 16 42 ; Arithmetic shift left $4216.w [Flags: NCZ]
	lda RDMPYH.w		; AD 17 42 ; Load RDMPYH.w into accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0F.b		; 85 0F ; Store accumulator to $0F.b [Reads: Accumulator]
	lsr $03.b		; 46 03 ; Logical shift right $03.b [Reads: Direct Page] [Flags: NCZ]
	.db $90, $03		; 90 03 ; Branch if carry clear to $90, $03 [Flow: branch]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	lda $04.b		; A5 04 ; Load $04.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$04.b		; E9 04 ; Subtract #$04.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0C.b		; 65 0C ; Add $0C.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $0FAB.w		; 8D AB 0F ; Store accumulator to $0FAB.w [Reads: Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0FA8.w		; 6D A8 0F ; Add $0FA8.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $06.b		; A5 06 ; Load $06.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$04.b		; E9 04 ; Subtract #$04.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0D.b		; 65 0D ; Add $0D.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $0FAA.w		; 8D AA 0F ; Store accumulator to $0FAA.w [Reads: Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0FA9.w		; 6D A9 0F ; Add $0FA9.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda #$2A.b		; A9 2A ; Load #$2A.b into accumulator [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda #$2D.b		; A9 2D ; Load #$2D.b into accumulator [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($92.b)		; 92 92 ; Store accumulator (indirect) ($92.b) [Reads: Direct Page, Accumulator]
	ldy #$04.b		; A0 04 ; Load #$04.b into Y register [Writes: Y Index] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx #$03.b		; A2 03 ; Load #$03.b into X register [Writes: X Index] [Flags: NZ]
	lda $0E.b		; A5 0E ; Load $0E.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta WRMPYA.w		; 8D 02 42 ; Store accumulator to WRMPYA.w [Reads: Accumulator]
	lda $B5BA.w,X		; BD BA B5 ; Load $B5BA.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta WRMPYB.w		; 8D 03 42 ; Store accumulator to WRMPYB.w [Reads: Accumulator]
	jsr $B5BE.w		; 20 BE B5 ; Jump to subroutine at $B5BE.w [Writes: Stack Pointer] [Flow: call]
	lda $04.b		; A5 04 ; Load $04.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lda RDMPYH.w		; AD 17 42 ; Load RDMPYH.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $90, $03		; 90 03 ; Branch if carry clear to $90, $03 [Flow: branch]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0FA8.w		; 6D A8 0F ; Add $0FA8.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0C.b		; 65 0C ; Add $0C.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $0F.b		; A5 0F ; Load $0F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta WRMPYA.w		; 8D 02 42 ; Store accumulator to WRMPYA.w [Reads: Accumulator]
	lda $B5BA.w,X		; BD BA B5 ; Load $B5BA.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta WRMPYB.w		; 8D 03 42 ; Store accumulator to WRMPYB.w [Reads: Accumulator]
	jsr $B5BE.w		; 20 BE B5 ; Jump to subroutine at $B5BE.w [Writes: Stack Pointer] [Flow: call]
	lda $06.b		; A5 06 ; Load $06.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lda RDMPYH.w		; AD 17 42 ; Load RDMPYH.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $90, $03		; 90 03 ; Branch if carry clear to $90, $03 [Flow: branch]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0FA9.w		; 6D A9 0F ; Add $0FA9.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0D.b		; 65 0D ; Add $0D.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda #$3F.b		; A9 3F ; Load #$3F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda #$2D.b		; A9 2D ; Load #$2D.b into accumulator [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($92.b),Y		; 91 92 ; Store accumulator ($92.b),Y [Reads: Direct Page, Y Index, Accumulator]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $A3		; 10 A3 ; Branch if plus to $10, $A3 [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	ldy #$FF.b		; A0 FF ; Load #$FF.b into Y register [Writes: Y Index] [Flags: NZ]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06FEB4.l		; 22 B4 FE 06 ; Jump to subroutine long $06FEB4.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	and ($66.b,S),Y		; 33 66 ; AND accumulator (stack relative indirect indexed) ($66.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $EACC.w,Y		; 99 CC EA ; Store accumulator to $EACC.w,Y [Reads: Y Index, Accumulator]
	nop		; EA ; No operation
	nop		; EA ; No operation
	nop		; EA ; No operation
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $B5D3.w		; 20 D3 B5 ; Jump to subroutine at $B5D3.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $BD.b		; 05 BD ; Logical OR $BD.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $380E.w		; 20 0E 38 ; Jump to subroutine at $380E.w [Writes: Stack Pointer] [Flow: call]
	sbc #$41.b		; E9 41 ; Subtract #$41.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
.ACCU 16
.INDEX 16
	rep #$30		; C2 30
	and #$00FF.w		; 29 FF 00 ; Logical AND #$00FF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $B5E8.w,Y		; B9 E8 B5 ; Load $B5E8.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	eor $C1.b,X		; 55 C1 ; Exclusive OR accumulator with memory $C1.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor $C1.b,X		; 55 C1 ; Exclusive OR accumulator with memory $C1.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor $C1.b,X		; 55 C1 ; Exclusive OR accumulator with memory $C1.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc $CC.b		; 65 CC ; Add $CC.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$CB.b		; E0 CB ; Compare #$CB.b with X register [Reads: X Index] [Flags: NCZ]
	sbc $D1BFCD.l,X		; FF CD BF D1 ; Subtract with carry (long,X) $D1BFCD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($CD.b,X)		; E1 CD ; Subtract with carry ($CD.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy $0AD1.w		; AC D1 0A ; Load $0AD1.w into Y register [Writes: Y Index] [Flags: NZ]
	ldx $BCA2.w,Y		; BE A2 BC ; Load X register $BCA2.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	lda ($B8.b,S),Y		; B3 B8 ; Load accumulator (stack relative indirect indexed) ($B8.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $BA.b		; 85 BA ; Store accumulator to $BA.b [Reads: Accumulator]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	ldx $03.b,Y		; B6 03 ; Load X register $03.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	lda [$5B.b],Y		; B7 5B ; Load accumulator (long indexed) [$5B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $A036.w,Y		; 99 36 A0 ; Store accumulator to $A036.w,Y [Reads: Y Index, Accumulator]
	ldx #$A3.b		; A2 A3 ; Load #$A3.b into X register [Writes: X Index] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	stx $4A.b,Y		; 96 4A ; Store X register $4A.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	sta $956D.w,X		; 9D 6D 95 ; Store accumulator to $956D.w,X [Reads: Accumulator, X Index]
	lda $94.b,X		; B5 94 ; Load $94.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	asl $6894.w		; 0E 94 68 ; Arithmetic shift left $6894.w [Flags: NCZ]
	sty $3F.b,X		; 94 3F ; Store Y register $3F.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	sta ($3F.b,S),Y		; 93 3F ; Store accumulator (stack relative indirect indexed) ($3F.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	sta ($DE.b,S),Y		; 93 DE ; Store accumulator (stack relative indirect indexed) ($DE.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	sta $8DDE.w		; 8D DE 8D ; Store accumulator to $8DDE.w [Reads: Accumulator]
	dec $DE8D.w,X		; DE 8D DE ; Decrement memory $DE8D.w,X [Reads: X Index] [Flags: NZ]
	sta $8F54.w		; 8D 54 8F ; Store accumulator to $8F54.w [Reads: Accumulator]
	cmp $88.b		; C5 88 ; Compare $88.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	and ($85.b),Y		; 31 85 ; AND accumulator with memory ($85.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $FF87.w		; 4D 87 FF ; Exclusive OR $FF87.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($90.b,X)		; 81 90 ; Store accumulator ($90.b,X) [Reads: Direct Page, Accumulator, X Index]
	.db $80, $90		; 80 90 ; Branch always to $80, $90 [Flow: branch]
	.db $80, $90		; 80 90 ; Branch always to $80, $90 [Flow: branch]
	.db $80, $90		; 80 90 ; Branch always to $80, $90 [Flow: branch]
	.db $80, $1B		; 80 1B ; Branch always to $80, $1B [Flow: branch]
	.db $B0, $E4		; B0 E4 ; Branch if carry set to $B0, $E4 [Flow: branch]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	adc $AF.b,X		; 75 AF ; Add $AF.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $B0, $A8		; B0 A8 ; Branch if carry set to $B0, $A8 [Flow: branch]
	adc ($A9.b,S),Y		; 73 A9 ; Add with carry (stack relative indirect indexed) ($A9.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	adc $80BD80.l,X		; 7F 80 BD 80 ; Add long $80BD80.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $06D0.w		; 0D D0 06 ; Logical OR $06D0.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06DBF0.l		; 22 F0 DB 06 ; Jump to subroutine long $06DBF0.l [Writes: Stack Pointer] [Flow: call]
	.db $80, $03		; 80 03 ; Branch always to $80, $03 [Flow: branch]
	jsr $B6A4.w		; 20 A4 B6 ; Jump to subroutine at $B6A4.w [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	jsr $F9ED.w		; 20 ED F9 ; Jump to subroutine at $F9ED.w [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $07		; F0 07 ; Branch if equal to $F0, $07 [Flow: branch]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $AB93.w		; 20 93 AB ; Jump to subroutine at $AB93.w [Writes: Stack Pointer] [Flow: call]
	lda $0E10.w,X		; BD 10 0E ; Load $0E10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0A		; D0 0A ; Branch if not equal to $D0, $0A [Flow: branch]
	jsr $B88D.w		; 20 8D B8 ; Jump to subroutine at $B88D.w [Writes: Stack Pointer] [Flow: call]
	.db $F0, $05		; F0 05 ; Branch if equal to $F0, $05 [Flow: branch]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $F80008.l,X		; FF 08 00 F8 ; Subtract with carry (long,X) $F80008.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F80008.l,X		; FF 08 00 F8 ; Subtract with carry (long,X) $F80008.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $08FFF8.l,X		; FF F8 FF 08 ; Subtract with carry (long,X) $08FFF8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $84.b		; 00 84 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	stx $88.b		; 86 88 ; Store X register to $88.b [Reads: X Index]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$80.b		; C0 80 ; Compare #$80.b with Y register [Reads: Y Index] [Flags: NCZ]
	jsr $FA50.w		; 20 50 FA ; Jump to subroutine at $FA50.w [Writes: Stack Pointer] [Flow: call]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx #$03.b		; A2 03 ; Load #$03.b into X register [Writes: X Index] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $B688.w,X		; 7D 88 B6 ; Add $B688.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	and #$0100.w		; 29 00 01 ; Logical AND #$0100.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E.b		; 85 0E ; Store accumulator to $0E.b [Reads: Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $B690.w,X		; 7D 90 B6 ; Add $B690.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0010.w		; 69 10 00 ; Add #$0010.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0100.w		; C9 00 01 ; Compare #$0100.w with accumulator [Reads: Accumulator] [Flags: NCZ]
.ACCU 8
	sep #$20		; E2 20
	.db $90, $04		; 90 04 ; Branch if carry clear to $90, $04 [Flow: branch]
	lda #$F0.b		; A9 F0 ; Load #$F0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $06.b		; 65 06 ; Add $06.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $B698.w,X		; BD 98 B6 ; Load $B698.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda $B6A0.w,X		; BD A0 B6 ; Load $B6A0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $0F.b		; A5 0F ; Load $0F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$02.b		; 09 02 ; Logical OR #$02.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($92.b),Y		; 91 92 ; Store accumulator ($92.b),Y [Reads: Direct Page, Y Index, Accumulator]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $B0		; 10 B0 ; Branch if plus to $10, $B0 [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $B7EF.w		; 20 EF B7 ; Jump to subroutine at $B7EF.w [Writes: Stack Pointer] [Flow: call]
	lda $0EA0.w,X		; BD A0 0E ; Load $0EA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	jsr $C4F9.w		; 20 F9 C4 ; Jump to subroutine at $C4F9.w [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	jsr $FA2E.w		; 20 2E FA ; Jump to subroutine at $FA2E.w [Writes: Stack Pointer] [Flow: call]
	lda $0F80.w,X		; BD 80 0F ; Load $0F80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$02.b		; E9 02 ; Subtract #$02.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0F80.w,X		; [PATTERN: Memory clearing operation] 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $09		; 10 09 ; Branch if plus to $10, $09 [Flow: branch]
	stz $0F70.w,X		; 9E 70 0F ; Store zero to $0F70.w,X [Reads: X Index]
	stz $0F80.w,X		; 9E 80 0F ; Store zero to $0F80.w,X [Reads: X Index]
	jsr $C4F9.w		; 20 F9 C4 ; Jump to subroutine at $C4F9.w [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	jmp $B7BA.w		; 4C BA B7 ; Jump to $B7BA.w [Flow: jump]
	lda $0E60.w,X		; BD 60 0E ; Load $0E60.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$40.b		; 09 40 ; Logical OR #$40.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E60.w,X		; 9D 60 0E ; Store accumulator to $0E60.w,X [Reads: Accumulator, X Index]
	ldy $0DF0.w,X		; BC F0 0D ; Load Y register $0DF0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	cpy #$01.b		; C0 01 ; Compare #$01.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $D0, $1C		; D0 1C ; Branch if not equal to $D0, $1C [Flow: branch]
	and #$BF.b		; 29 BF ; Logical AND #$BF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E60.w,X		; 9D 60 0E ; Store accumulator to $0E60.w,X [Reads: Accumulator, X Index]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	asl $0E40.w,X		; 1E 40 0E ; Arithmetic shift left $0E40.w,X [Reads: X Index] [Flags: NCZ]
	lsr $0E40.w,X		; 5E 40 0E ; Logical shift right $0E40.w,X [Reads: X Index] [Flags: NCZ]
	lda $0E60.w,X		; BD 60 0E ; Load $0E60.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$BF.b		; 29 BF ; Logical AND #$BF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E60.w,X		; 9D 60 0E ; Store accumulator to $0E60.w,X [Reads: Accumulator, X Index]
	lda #$0B.b		; A9 0B ; Load #$0B.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $36		; D0 36 ; Branch if not equal to $D0, $36 [Flow: branch]
.ACCU 16
	rep #$20		; C2 20
	lda $22.b		; A5 22 ; Load $22.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $0FD8.w		; ED D8 0F ; Subtract $0FD8.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$001F.w		; 69 1F 00 ; Add #$001F.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$003E.w		; C9 3E 00 ; Compare #$003E.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $25		; B0 25 ; Branch if carry set to $B0, $25 [Flow: branch]
	lda $20.b		; A5 20 ; Load $20.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0008.w		; 69 08 00 ; Add #$0008.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $0FDA.w		; ED DA 0F ; Subtract $0FDA.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0030.w		; 69 30 00 ; Add #$0030.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0058.w		; C9 58 00 ; Compare #$0058.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $12		; B0 12 ; Branch if carry set to $B0, $12 [Flow: branch]
.ACCU 8
	sep #$20		; E2 20
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0B		; D0 0B ; Branch if not equal to $D0, $0B [Flow: branch]
	lda #$30.b		; A9 30 ; Load #$30.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda #$22.b		; A9 22 ; Load #$22.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB7C.l		; 22 7C BB 0D ; Jump to subroutine long $0DBB7C.l [Writes: Stack Pointer] [Flow: call]
.ACCU 8
	sep #$20		; E2 20
	jsl $06F129.l		; 22 29 F1 06 ; Jump to subroutine long $06F129.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $08		; 90 08 ; Branch if carry clear to $90, $08 [Flow: branch]
	jsl $0FF540.l		; 22 40 F5 0F ; Jump to subroutine long $0FF540.l [Writes: Stack Pointer] [Flow: call]
	jsl $079291.l		; 22 91 92 07 ; Jump to subroutine long $079291.l [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $09		; F0 09 ; Branch if equal to $F0, $09 [Flow: branch]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$0E.b		; 29 0E ; Logical AND #$0E.b with accumulator [Writes: Accumulator] [Flags: NZ]
	eor $0F50.w,X		; 5D 50 0F ; Exclusive OR accumulator with memory $0F50.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $AB93.w		; 20 93 AB ; Jump to subroutine at $AB93.w [Writes: Stack Pointer] [Flow: call]
	jsr $F971.w		; 20 71 F9 ; Jump to subroutine at $F971.w [Writes: Stack Pointer] [Flow: call]
	jsr $F9ED.w		; 20 ED F9 ; Jump to subroutine at $F9ED.w [Writes: Stack Pointer] [Flow: call]
	jsr $B88D.w		; 20 8D B8 ; Jump to subroutine at $B88D.w [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $0F70.w,X		; 1D 70 0F ; OR accumulator with memory $0F70.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $10		; D0 10 ; Branch if not equal to $D0, $10 [Flow: branch]
	lda #$08.b		; A9 08 ; Load #$08.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	lda #$0C.b		; A9 0C ; Load #$0C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06EA12.l		; 22 12 EA 06 ; Jump to subroutine long $06EA12.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $FF		; F0 FF ; Branch if equal to $F0, $FF [Flow: branch]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: NCZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: NCZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	jsr $FA50.w		; 20 50 FA ; Jump to subroutine at $FA50.w [Writes: Stack Pointer] [Flow: call]
.ACCU 16
	rep #$20		; C2 20
	lda #$B7DF.w		; A9 DF B7 ; Load #$B7DF.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $8AB1.w		; 20 B1 8A ; Jump to subroutine at $8AB1.w [Writes: Stack Pointer] [Flow: call]
	jsl $06DC54.l		; 22 54 DC 06 ; Jump to subroutine long $06DC54.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $B89A.w		; 20 9A B8 ; Jump to subroutine at $B89A.w [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	jsr $F971.w		; 20 71 F9 ; Jump to subroutine at $F971.w [Writes: Stack Pointer] [Flow: call]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D90.w,X		; 9D 90 0D ; Store accumulator to $0D90.w,X [Reads: Accumulator, X Index]
	jsr $AB93.w		; 20 93 AB ; Jump to subroutine at $AB93.w [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $40		; F0 40 ; Branch if equal to $F0, $40 [Flow: branch]
	cmp #$01.b		; C9 01 ; Compare #$01.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $0E		; F0 0E ; Branch if equal to $F0, $0E [Flow: branch]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$69.b		; A9 69 ; Load #$69.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $25		; D0 25 ; Branch if not equal to $D0, $25 [Flow: branch]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$3F.b		; 29 3F ; Logical AND #$3F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$80.b		; 69 80 ; Add #$80.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$0F.b		; 29 0F ; Logical AND #$0F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $AAE4.w,Y		; B9 E4 AA ; Load $AAE4.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $AAF4.w,Y		; B9 F4 AA ; Load $AAF4.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $09		; D0 09 ; Branch if not equal to $D0, $09 [Flow: branch]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	lda #$50.b		; A9 50 ; Load #$50.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $0DA0.w,X		; 3D A0 0D ; AND accumulator with memory $0DA0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	jsr $F9ED.w		; 20 ED F9 ; Jump to subroutine at $F9ED.w [Writes: Stack Pointer] [Flow: call]
	lda $0E70.w,X		; BD 70 0E ; Load $0E70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $E7		; D0 E7 ; Branch if not equal to $D0, $E7 [Flow: branch]
	jsl $06E496.l		; 22 96 E4 06 ; Jump to subroutine long $06E496.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	ldy $0D90.w,X		; BC 90 0D ; Load Y register $0D90.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $B892.w,Y		; B9 92 B8 ; Load $B892.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$BF.b		; 29 BF ; Logical AND #$BF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $B896.w,Y		; 19 96 B8 ; OR accumulator with memory $B896.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	jsl $06DBF0.l		; 22 F0 DB 06 ; Jump to subroutine long $06DBF0.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $06		; B0 06 ; Branch if carry set to $B0, $06 [Flow: branch]
	jsl $06E416.l		; 22 16 E4 06 ; Jump to subroutine long $06E416.l [Writes: Stack Pointer] [Flow: call]
	.db $80, $03		; 80 03 ; Branch always to $80, $03 [Flow: branch]
	jsr $BA24.w		; 20 24 BA ; Jump to subroutine at $BA24.w [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	jsr $F971.w		; 20 71 F9 ; Jump to subroutine at $F971.w [Writes: Stack Pointer] [Flow: call]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0BA0.w,X		; 9D A0 0B ; Store accumulator to $0BA0.w,X [Reads: Accumulator, X Index]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
.ACCU 16
.INDEX 16
	rep #$30		; C2 30
	and #$00FF.w		; 29 FF 00 ; Logical AND #$00FF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $B8E0.w,Y		; B9 E0 B8 ; Load $B8E0.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	nop		; EA ; No operation
	clv		; B8 ; Clear overflow flag [Flags: V]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	lda $B93F.w,Y		; B9 3F B9 ; Load $B93F.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	jmp ($8FB9.w)		; 6C B9 8F ; Jump indirect to ($8FB9.w) [Flow: jump]
	lda $F0BD.w,Y		; B9 BD F0 ; Load $F0BD.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $1BD0.w		; 0D D0 1B ; Logical OR $1BD0.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D10.w,X		; 9D 10 0D ; Store accumulator to $0D10.w,X [Reads: Accumulator, X Index]
	lda $0DA0.w,X		; BD A0 0D ; Load $0DA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D30.w,X		; 9D 30 0D ; Store accumulator to $0D30.w,X [Reads: Accumulator, X Index]
	lda $0DB0.w,X		; BD B0 0D ; Load $0DB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D00.w,X		; 9D 00 0D ; Store accumulator to $0D00.w,X [Reads: Accumulator, X Index]
	lda $0EB0.w,X		; BD B0 0E ; Load $0EB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D20.w,X		; 9D 20 0D ; Store accumulator to $0D20.w,X [Reads: Accumulator, X Index]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $2A		; D0 2A ; Branch if not equal to $D0, $2A [Flow: branch]
.ACCU 16
	rep #$20		; C2 20
	lda $22.b		; A5 22 ; Load $22.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $0FD8.w		; ED D8 0F ; Subtract $0FD8.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0030.w		; 69 30 00 ; Add #$0030.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0060.w		; C9 60 00 ; Compare #$0060.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $19		; B0 19 ; Branch if carry set to $B0, $19 [Flow: branch]
	lda $20.b		; A5 20 ; Load $20.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $0FDA.w		; ED DA 0F ; Subtract $0FDA.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0030.w		; 69 30 00 ; Add #$0030.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0060.w		; C9 60 00 ; Compare #$0060.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $0A		; B0 0A ; Branch if carry set to $B0, $0A [Flow: branch]
.ACCU 8
	sep #$20		; E2 20
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$1F.b		; A9 1F ; Load #$1F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
.ACCU 8
	sep #$20		; E2 20
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0F		; D0 0F ; Branch if not equal to $D0, $0F [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$60.b		; A9 60 ; Load #$60.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06EA12.l		; 22 12 EA 06 ; Jump to subroutine long $06EA12.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $B95D.w,Y		; B9 5D B9 ; Load $B95D.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $9E.b,S		; 03 9E ; OR accumulator with stack relative $9E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldy #$0B.b		; A0 0B ; Load #$0B.b into Y register [Writes: Y Index] [Flags: NZ]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $09		; D0 09 ; Branch if not equal to $D0, $09 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$08.b		; A9 08 ; Load #$08.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $B965.w,Y		; B9 65 B9 ; Load $B965.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	jsr $AB93.w		; 20 93 AB ; Jump to subroutine at $AB93.w [Writes: Stack Pointer] [Flow: call]
	jsr $F9ED.w		; 20 ED F9 ; Jump to subroutine at $F9ED.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $09		; D0 09 ; Branch if not equal to $D0, $09 [Flow: branch]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $B967.w,Y		; B9 67 B9 ; Load $B967.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $080008.l,X		; FF 08 00 08 ; Subtract with carry (long,X) $080008.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $080008.l,X		; FF 08 00 08 ; Subtract with carry (long,X) $080008.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $100000.l,X		; FF 00 00 10 ; Subtract with carry (long,X) $100000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $100000.l,X		; FF 00 00 10 ; Subtract with carry (long,X) $100000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B8.b		; 00 B8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clv		; B8 ; Clear overflow flag [Flags: V]
	clv		; B8 ; Clear overflow flag [Flags: V]
	clv		; B8 ; Clear overflow flag [Flags: V]
	clv		; B8 ; Clear overflow flag [Flags: V]
	clv		; B8 ; Clear overflow flag [Flags: V]
	ldx $A6.b		; A6 A6 ; Load $A6.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	ldx $A6.b		; A6 A6 ; Load $A6.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	ldx $A6.b		; A6 A6 ; Load $A6.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	ldy $A2.b		; A4 A2 ; Load $A2.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	ldy #$A0.b		; A0 A0 ; Load #$A0.b into Y register [Writes: Y Index] [Flags: NZ]
	ldx #$A4.b		; A2 A4 ; Load #$A4.b into X register [Writes: X Index] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $20.b		; 02 20 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $50, $FA		; 50 FA ; Branch if overflow clear to $50, $FA [Flow: branch]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc $0DC0.w,X		; 7D C0 0D ; Add $0DC0.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx #$02.b		; A2 02 ; Load #$02.b into X register [Writes: X Index] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $06.b		; 65 06 ; Add $06.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $B9A6.w,X		; 7D A6 B9 ; Add $B9A6.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	and #$0100.w		; 29 00 01 ; Logical AND #$0100.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E.b		; 85 0E ; Store accumulator to $0E.b [Reads: Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $B9CA.w,X		; 7D CA B9 ; Add $B9CA.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0010.w		; 69 10 00 ; Add #$0010.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0100.w		; C9 00 01 ; Compare #$0100.w with accumulator [Reads: Accumulator] [Flags: NCZ]
.ACCU 8
	sep #$20		; E2 20
	.db $90, $04		; 90 04 ; Branch if carry clear to $90, $04 [Flow: branch]
	lda #$F0.b		; A9 F0 ; Load #$F0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda $B9EE.w,X		; BD EE B9 ; Load $B9EE.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $BA00.w,X		; BD 00 BA ; Load $BA00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $BA12.w,X		; BD 12 BA ; Load $BA12.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $0F.b		; 05 0F ; Logical OR $0F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($92.b),Y		; 91 92 ; Store accumulator ($92.b),Y [Reads: Direct Page, Y Index, Accumulator]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $B0		; 10 B0 ; Branch if plus to $10, $B0 [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0B		; F0 0B ; Branch if equal to $F0, $0B [Flow: branch]
	lda $0B89.w,X		; BD 89 0B ; Load $0B89.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$30.b		; 09 30 ; Logical OR #$30.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0B89.w,X		; 9D 89 0B ; Store accumulator to $0B89.w,X [Reads: Accumulator, X Index]
	jsr $BBFF.w		; 20 FF BB ; Jump to subroutine at $BBFF.w [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
.ACCU 16
.INDEX 16
	rep #$30		; C2 30
	and #$00FF.w		; 29 FF 00 ; Logical AND #$00FF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $BAAA.w,Y		; B9 AA BA ; Load $BAAA.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	dec $BA.b		; C6 BA ; Decrement $BA.b [Reads: Direct Page] [Flags: NZ]
	ora ($BB.b,X)		; 01 BB ; Logical OR ($BB.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	.db $30, $BB		; 30 BB ; Branch if minus to $30, $BB [Flow: branch]
	eor ($BB.b,S),Y		; 53 BB ; XOR accumulator (stack relative indirect indexed) ($BB.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $E0BB.w		; 6D BB E0 ; Add $E0BB.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	jsr $0000.w		; 20 00 00 ; Jump to subroutine at $0000.w [Writes: Stack Pointer] [Flow: call]
	sbc $000000.l,X		; FF 00 00 00 ; Subtract with carry (long,X) $000000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$20.b		; E0 20 ; Compare #$20.b with X register [Reads: X Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $F0BD00.l,X		; FF 00 BD F0 ; Subtract with carry (long,X) $F0BD00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $35D0.w		; 0D D0 35 ; Logical OR $35D0.w with accumulator [Writes: Accumulator] [Flags: NZ]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$08.b		; A9 08 ; Load #$08.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $BAB6.w,Y		; 79 B6 BA ; Add $BAB6.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,X		; 9D 10 0D ; Store accumulator to $0D10.w,X [Reads: Accumulator, X Index]
	lda $0DA0.w,X		; BD A0 0D ; Load $0DA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $BABA.w,Y		; 79 BA BA ; Add $BABA.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D30.w,X		; 9D 30 0D ; Store accumulator to $0D30.w,X [Reads: Accumulator, X Index]
	lda $0DB0.w,X		; BD B0 0D ; Load $0DB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $BABE.w,Y		; 79 BE BA ; Add $BABE.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,X		; 9D 00 0D ; Store accumulator to $0D00.w,X [Reads: Accumulator, X Index]
	lda $0EB0.w,X		; BD B0 0E ; Load $0EB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $BAC2.w,Y		; 79 C2 BA ; Add $BAC2.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D20.w,X		; 9D 20 0D ; Store accumulator to $0D20.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $09		; D0 09 ; Branch if not equal to $D0, $09 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	jsr $BB72.w		; 20 72 BB ; Jump to subroutine at $BB72.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$40.b		; A9 40 ; Load #$40.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	jsr $BB72.w		; 20 72 BB ; Jump to subroutine at $BB72.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $AB93.w		; 20 93 AB ; Jump to subroutine at $AB93.w [Writes: Stack Pointer] [Flow: call]
	jsr $FA2E.w		; 20 2E FA ; Jump to subroutine at $FA2E.w [Writes: Stack Pointer] [Flow: call]
	lda $0F80.w,X		; BD 80 0F ; Load $0F80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$02.b		; E9 02 ; Subtract #$02.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $0E		; 10 0E ; Branch if plus to $10, $0E [Flow: branch]
	stz $0F70.w,X		; 9E 70 0F ; Store zero to $0F70.w,X [Reads: X Index]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	jsr $BB72.w		; 20 72 BB ; Jump to subroutine at $BB72.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0A		; D0 0A ; Branch if not equal to $D0, $0A [Flow: branch]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	.db $80, $07		; 80 07 ; Branch always to $80, $07 [Flow: branch]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	jsr $BB72.w		; 20 72 BB ; Jump to subroutine at $BB72.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $1DF3D4.l		; 22 D4 F3 1D ; Jump to subroutine long $1DF3D4.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $0D20.w,X		; BD 20 0D ; Load $0D20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $01.b		; 85 01 ; Store accumulator to $01.b [Reads: Accumulator]
	lda $0D10.w,X		; BD 10 0D ; Load $0D10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	lda $0D30.w,X		; BD 30 0D ; Load $0D30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $03.b		; 85 03 ; Store accumulator to $03.b [Reads: Accumulator]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06E87B.l		; 22 7B E8 06 ; Jump to subroutine long $06E87B.l [Writes: Stack Pointer] [Flow: call]
	cmp #$40.b		; C9 40 ; Compare #$40.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $05		; F0 05 ; Branch if equal to $F0, $05 [Flow: branch]
	lda #$05.b		; A9 05 ; Load #$05.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D80.w,X		; 9D 80 0D ; Store accumulator to $0D80.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C8.b		; 00 C8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cpy #$C8.b		; C0 C8 ; Compare #$C8.b with Y register [Reads: Y Index] [Flags: NCZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	rep #$C2		; C2 C2 ; Reset processor status bits #$C2 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	rep #$C2		; C2 C2 ; Reset processor status bits #$C2 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	rep #$C2		; C2 C2 ; Reset processor status bits #$C2 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $20.b		; 02 20 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $50, $FA		; 50 FA ; Branch if overflow clear to $50, $FA [Flow: branch]
	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $E8.b		; E5 E8 ; Subtract $E8.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	lda $0D20.w,X		; BD 20 0D ; Load $0D20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $E9.b		; E5 E9 ; Subtract $E9.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $07.b		; 85 07 ; Store accumulator to $07.b [Reads: Accumulator]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc $0DC0.w,X		; 7D C0 0D ; Add $0DC0.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx #$02.b		; A2 02 ; Load #$02.b into X register [Writes: X Index] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $08.b		; 65 08 ; Add $08.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $BBF0.w,X		; BD F0 BB ; Load $BBF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0C.b		; 85 0C ; Store accumulator to $0C.b [Reads: Accumulator]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $BB96.w,X		; 7D 96 BB ; Add $BB96.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	and #$0100.w		; 29 00 01 ; Logical AND #$0100.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E.b		; 85 0E ; Store accumulator to $0E.b [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx $0C.b		; A6 0C ; Load $0C.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	cpx #$01.b		; E0 01 ; Compare #$01.b with X register [Reads: X Index] [Flags: NCZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $02		; B0 02 ; Branch if carry set to $B0, $02 [Flow: branch]
	lda $06.b		; A5 06 ; Load $06.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $BBB4.w,X		; 7D B4 BB ; Add $BBB4.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0010.w		; 69 10 00 ; Add #$0010.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0100.w		; C9 00 01 ; Compare #$0100.w with accumulator [Reads: Accumulator] [Flags: NCZ]
.ACCU 8
	sep #$20		; E2 20
	.db $90, $04		; 90 04 ; Branch if carry clear to $90, $04 [Flow: branch]
	lda #$F0.b		; A9 F0 ; Load #$F0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda $BBD2.w,X		; BD D2 BB ; Load $BBD2.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $0C.b		; A5 0C ; Load $0C.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$01.b		; C9 01 ; Compare #$01.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	lda $BBE1.w,X		; BD E1 BB ; Load $BBE1.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $04		; B0 04 ; Branch if carry set to $B0, $04 [Flow: branch]
	and #$F0.b		; 29 F0 ; Logical AND #$F0.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$02.b		; 09 02 ; Logical OR #$02.b with accumulator [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $0C.b		; A5 0C ; Load $0C.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0F.b		; 05 0F ; Logical OR $0F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($92.b),Y		; 91 92 ; Store accumulator ($92.b),Y [Reads: Direct Page, Y Index, Accumulator]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $96		; 10 96 ; Branch if plus to $10, $96 [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tsb $00F4.w		; 0C F4 00 ; Test and set bits $00F4.w [Reads: Accumulator] [Flags: Z]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $0000.w		; EE 00 00 ; Increment $0000.w [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00F4.w		; 0C F4 00 ; Test and set bits $00F4.w [Reads: Accumulator] [Flags: Z]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $0200.w		; EE 00 02 ; Increment $0200.w [Flags: NZ]
	tsb $06.b		; 04 06 ; Test and set bits $06.b [Reads: Accumulator] [Flags: Z]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$08.b		; 29 08 ; Logical AND #$08.b with accumulator [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc $0DE0.w,X		; 7D E0 0D ; Add $0DE0.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $BC9A.w,Y		; B9 9A BC ; Load $BC9A.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	jsr $BD7E.w		; 20 7E BD ; Jump to subroutine at $BD7E.w [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	jsr $F971.w		; 20 71 F9 ; Jump to subroutine at $F971.w [Writes: Stack Pointer] [Flow: call]
	jsr $AB93.w		; 20 93 AB ; Jump to subroutine at $AB93.w [Writes: Stack Pointer] [Flow: call]
	jsr $F9ED.w		; 20 ED F9 ; Jump to subroutine at $F9ED.w [Writes: Stack Pointer] [Flow: call]
	jsr $B88D.w		; 20 8D B8 ; Jump to subroutine at $B88D.w [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $55		; D0 55 ; Branch if not equal to $D0, $55 [Flow: branch]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $47		; D0 47 ; Branch if not equal to $D0, $47 [Flow: branch]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$3F.b		; 29 3F ; Logical AND #$3F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$30.b		; 69 30 ; Add #$30.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda $0EB0.w,X		; BD B0 0E ; Load $0EB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	jsr $F93F.w		; 20 3F F9 ; Jump to subroutine at $F93F.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	cmp $0DE0.w,X		; DD E0 0D ; Compare accumulator $0DE0.w,X [Reads: X Index] [Flags: NCZ]
	.db $D0, $1B		; D0 1B ; Branch if not equal to $D0, $1B [Flow: branch]
	lda $0E.b		; A5 0E ; Load $0E.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$10.b		; 69 10 ; Add #$10.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$20.b		; C9 20 ; Compare #$20.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $09		; 90 09 ; Branch if carry clear to $90, $09 [Flow: branch]
	lda $0F.b		; A5 0F ; Load $0F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$10.b		; 69 10 ; Add #$10.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$20.b		; C9 20 ; Compare #$20.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $09		; B0 09 ; Branch if carry set to $B0, $09 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	lda #$80.b		; A9 80 ; Load #$80.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda $BC8A.w,Y		; B9 8A BC ; Load $BC8A.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $BC92.w,Y		; B9 92 BC ; Load $BC92.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy $0E70.w,X		; BC 70 0E ; Load Y register $0E70.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	.db $D0, $07		; D0 07 ; Branch if not equal to $D0, $07 [Flow: branch]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $20		; D0 20 ; Branch if not equal to $D0, $20 [Flow: branch]
	lda #$30.b		; A9 30 ; Load #$30.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	jsr $C4F9.w		; 20 F9 C4 ; Jump to subroutine at $C4F9.w [Writes: Stack Pointer] [Flow: call]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $BD16.w,Y		; B9 16 BD ; Load $BD16.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	lda $0E00.w,X		; BD 00 0E ; Load $0E00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $82, $82, $80		; 82 82 80 ; Branch always long to $82, $82, $80 [Flow: branch]
	sty $40.b		; 84 40 ; Store Y register to $40.b [Reads: Y Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $00FFFE.l,X		; FF FE FF 00 ; Subtract with carry (long,X) $00FFFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8A.b		; 00 8A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $8C8A.w		; 8C 8A 8C ; Store Y register to $8C8A.w [Reads: Y Index]
	stx $88.b		; 86 88 ; Store X register to $88.b [Reads: X Index]
	stx $40A0.w		; 8E A0 40 ; Store X register to $40A0.w [Reads: X Index]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $FA50.w		; 20 50 FA ; Jump to subroutine at $FA50.w [Writes: Stack Pointer] [Flow: call]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	lda $0EB0.w,X		; BD B0 0E ; Load $0EB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	and #$0100.w		; 29 00 01 ; Logical AND #$0100.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E.b		; 85 0E ; Store accumulator to $0E.b [Reads: Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$000B.w		; E9 0B 00 ; Subtract #$000B.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0010.w		; 69 10 00 ; Add #$0010.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0100.w		; C9 00 01 ; Compare #$0100.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $05		; 90 05 ; Branch if carry clear to $90, $05 [Flow: branch]
	lda #$00F0.w		; A9 F0 00 ; Load #$00F0.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
.ACCU 8
	sep #$20		; E2 20
	lda $C6A2.w,X		; BD A2 C6 ; Load $C6A2.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $C6A6.w,X		; BD A6 C6 ; Load $C6A6.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0F.b		; 05 0F ; Logical OR $0F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($92.b)		; 92 92 ; Store accumulator (indirect) ($92.b) [Reads: Direct Page, Accumulator]
	lda $06.b		; A5 06 ; Load $06.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $BD5E.w,X		; 7D 5E BD ; Add $BD5E.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	and #$0100.w		; 29 00 01 ; Logical AND #$0100.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E.b		; 85 0E ; Store accumulator to $0E.b [Reads: Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0010.w		; 69 10 00 ; Add #$0010.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0100.w		; C9 00 01 ; Compare #$0100.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $05		; 90 05 ; Branch if carry clear to $90, $05 [Flow: branch]
	lda #$00F0.w		; A9 F0 00 ; Load #$00F0.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
.ACCU 8
	sep #$20		; E2 20
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda $BD6E.w,X		; BD 6E BD ; Load $BD6E.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $BD76.w,X		; BD 76 BD ; Load $BD76.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0F.b		; 05 0F ; Logical OR $0F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($92.b),Y		; 91 92 ; Store accumulator ($92.b),Y [Reads: Direct Page, Y Index, Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	jsl $06DC54.l		; 22 54 DC 06 ; Jump to subroutine long $06DC54.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DB0.w,X		; BD B0 0D ; Load $0DB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	jmp $BF51.w		; 4C 51 BF ; Jump to $BF51.w [Flow: jump]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $03		; B0 03 ; Branch if carry set to $B0, $03 [Flow: branch]
	jmp $BED3.w		; 4C D3 BE ; Jump to $BED3.w [Flow: jump]
	.db $D0, $22		; D0 22 ; Branch if not equal to $D0, $22 [Flow: branch]
	ldy #$0F.b		; A0 0F ; Load #$0F.b into Y register [Writes: Y Index] [Flags: NZ]
	cpy $0FA0.w		; CC A0 0F ; Compare $0FA0.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $F0, $14		; F0 14 ; Branch if equal to $F0, $14 [Flow: branch]
	lda $0DD0.w,Y		; B9 D0 0D ; Load $0DD0.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$09.b		; C9 09 ; Compare #$09.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $0D		; 90 0D ; Branch if carry clear to $90, $0D [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0EF0.w,Y		; 19 F0 0E ; OR accumulator with memory $0EF0.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	jsr $BE49.w		; 20 49 BE ; Jump to subroutine at $BE49.w [Writes: Stack Pointer] [Flow: call]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $10, $E4		; 10 E4 ; Branch if plus to $10, $E4 [Flow: branch]
	jsl $06F121.l		; 22 21 F1 06 ; Jump to subroutine long $06F121.l [Writes: Stack Pointer] [Flow: call]
	jsr $C113.w		; 20 13 C1 ; Jump to subroutine at $C113.w [Writes: Stack Pointer] [Flow: call]
	lda $0E00.w,X		; BD 00 0E ; Load $0E00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0D10.w,X		; BD 10 0D ; Load $0D10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$10.b		; E9 10 ; Subtract #$10.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $0D30.w,X		; BD 30 0D ; Load $0D30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc #$00.b		; E9 00 ; Subtract #$00.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
	lda #$30.b		; A9 30 ; Load #$30.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	sta $03.b		; 85 03 ; Store accumulator to $03.b [Reads: Accumulator]
	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$10.b		; E9 10 ; Subtract #$10.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $01.b		; 85 01 ; Store accumulator to $01.b [Reads: Accumulator]
	lda $0D20.w,X		; BD 20 0D ; Load $0D20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc #$00.b		; E9 00 ; Subtract #$00.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $09.b		; 85 09 ; Store accumulator to $09.b [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	jsl $0683EA.l		; 22 EA 83 06 ; Jump to subroutine long $0683EA.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	jsl $0683E6.l		; 22 E6 83 06 ; Jump to subroutine long $0683E6.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $58		; 90 58 ; Branch if carry clear to $90, $58 [Flow: branch]
	lda $0E20.w,Y		; B9 20 0E ; Load $0E20.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$11.b		; C9 11 ; Compare #$11.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $51		; F0 51 ; Branch if equal to $F0, $51 [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	lda #$08.b		; A9 08 ; Load #$08.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06ECE0.l		; 22 E0 EC 06 ; Jump to subroutine long $06ECE0.l [Writes: Stack Pointer] [Flow: call]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda $0D10.w,X		; BD 10 0D ; Load $0D10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $0D30.w,X		; BD 30 0D ; Load $0D30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $01.b		; 85 01 ; Store accumulator to $01.b [Reads: Accumulator]
	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $0F70.w,X		; FD 70 0F ; Subtract with carry $0F70.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	lda $0D20.w,X		; BD 20 0D ; Load $0D20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc #$00.b		; E9 00 ; Subtract #$00.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $03.b		; 85 03 ; Store accumulator to $03.b [Reads: Accumulator]
	lda $0D10.w,Y		; B9 10 0D ; Load $0D10.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	lda $0D30.w,Y		; B9 30 0D ; Load $0D30.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $05.b		; 85 05 ; Store accumulator to $05.b [Reads: Accumulator]
	lda $0D00.w,Y		; B9 00 0D ; Load $0D00.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $0F70.w,Y		; F9 70 0F ; Subtract with carry $0F70.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	lda $0D20.w,Y		; B9 20 0D ; Load $0D20.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc #$00.b		; E9 00 ; Subtract #$00.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $07.b		; 85 07 ; Store accumulator to $07.b [Reads: Accumulator]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06EA22.l		; 22 22 EA 06 ; Jump to subroutine long $06EA22.l [Writes: Stack Pointer] [Flow: call]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0F30.w,Y		; 99 30 0F ; Store accumulator to $0F30.w,Y [Reads: Y Index, Accumulator]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0F40.w,Y		; 99 40 0F ; Store accumulator to $0F40.w,Y [Reads: Y Index, Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0E90.w,X		; BD 90 0E ; Load $0E90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $08		; F0 08 ; Branch if equal to $F0, $08 [Flow: branch]
	lda $0B89.w,X		; BD 89 0B ; Load $0B89.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$30.b		; 09 30 ; Logical OR #$30.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0B89.w,X		; 9D 89 0B ; Store accumulator to $0B89.w,X [Reads: Accumulator, X Index]
	jsl $06DBF0.l		; 22 F0 DB 06 ; Jump to subroutine long $06DBF0.l [Writes: Stack Pointer] [Flow: call]
	lda $0EF0.w,X		; BD F0 0E ; Load $0EF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0B		; D0 0B ; Branch if not equal to $D0, $0B [Flow: branch]
	lda $0E00.w,X		; BD 00 0E ; Load $0E00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$40.b		; C9 40 ; Compare #$40.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $46		; B0 46 ; Branch if carry set to $B0, $46 [Flow: branch]
	cmp #$01.b		; C9 01 ; Compare #$01.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $33		; D0 33 ; Branch if not equal to $D0, $33 [Flow: branch]
	stz $0EF0.w,X		; [PATTERN: Memory clearing operation] 9E F0 0E ; Store zero to $0EF0.w,X [Reads: X Index]
	lda $0DD0.w,X		; BD D0 0D ; Load $0DD0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$0A.b		; C9 0A ; Compare #$0A.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $06		; D0 06 ; Branch if not equal to $D0, $06 [Flow: branch]
	stz $0309.w		; 9C 09 03 ; Store zero to $0309.w
	stz $0308.w		; 9C 08 03 ; Store zero to $0308.w
	lda #$0C.b		; A9 0C ; Load #$0C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB7C.l		; 22 7C BB 0D ; Jump to subroutine long $0DBB7C.l [Writes: Stack Pointer] [Flow: call]
	inc $0DB0.w,X		; FE B0 0D ; Increment memory $0DB0.w,X [Reads: X Index] [Flags: NZ]
	lda #$09.b		; A9 09 ; Load #$09.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F60.w,X		; 9D 60 0F ; Store accumulator to $0F60.w,X [Reads: Accumulator, X Index]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	lda #$1F.b		; A9 1F ; Load #$1F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E00.w,X		; 9D 00 0E ; Store accumulator to $0E00.w,X [Reads: Accumulator, X Index]
	lda #$06.b		; A9 06 ; Load #$06.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DD0.w,X		; 9D D0 0D ; Store accumulator to $0DD0.w,X [Reads: Accumulator, X Index]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E40.w,X		; 9D 40 0E ; Store accumulator to $0E40.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$0E.b		; 29 0E ; Logical AND #$0E.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$F1.b		; 29 F1 ; Logical AND #$F1.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	lda $0EE0.w,X		; BD E0 0E ; Load $0EE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $04		; D0 04 ; Branch if not equal to $D0, $04 [Flow: branch]
	jsl $06F2AA.l		; 22 AA F2 06 ; Jump to subroutine long $06F2AA.l [Writes: Stack Pointer] [Flow: call]
	jsr $F9ED.w		; 20 ED F9 ; Jump to subroutine at $F9ED.w [Writes: Stack Pointer] [Flow: call]
	lda $1B.b		; A5 1B ; Load $1B.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	jsr $B88D.w		; 20 8D B8 ; Jump to subroutine at $B88D.w [Writes: Stack Pointer] [Flow: call]
	jsl $06DFF2.l		; 22 F2 DF 06 ; Jump to subroutine long $06DFF2.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $C04B.w		; 20 4B C0 ; Jump to subroutine at $C04B.w [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	jsr $AB93.w		; 20 93 AB ; Jump to subroutine at $AB93.w [Writes: Stack Pointer] [Flow: call]
	jsr $F93F.w		; 20 3F F9 ; Jump to subroutine at $F93F.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0E		; D0 0E ; Branch if not equal to $D0, $0E [Flow: branch]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$70.b		; A9 70 ; Load #$70.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $09		; D0 09 ; Branch if not equal to $D0, $09 [Flow: branch]
	stz $0D80.w,X		; [PATTERN: Memory clearing operation] 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $0E80.w,X		; 9E 80 0E ; Store zero to $0E80.w,X [Reads: X Index]
	cmp #$50.b		; C9 50 ; Compare #$50.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $03		; 90 03 ; Branch if carry clear to $90, $03 [Flow: branch]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	cmp #$20.b		; C9 20 ; Compare #$20.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $05		; D0 05 ; Branch if not equal to $D0, $05 [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	jsr $BFC1.w		; 20 C1 BF ; Jump to subroutine at $BFC1.w [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$20.b		; 69 20 ; Add #$20.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $D001.w,Y		; B9 01 D0 ; Load $D001.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$F8.b		; 09 F8 ; Logical OR #$F8.b with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pea $F1F4.w		; F4 F4 F1 ; Push absolute address $F1F4.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sbc ($FF.b,S),Y		; F3 FF ; Subtract with carry (stack relative indirect indexed) ($FF.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc $A9FFFF.l,X		; FF FF FF A9 ; Subtract with carry (long,X) $A9FFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $71		; 30 71 ; Branch if minus to $30, $71 [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $BFB1.w,X		; 7D B1 BF ; Add $BFB1.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,Y		; 99 10 0D ; Store accumulator to $0D10.w,Y [Reads: Y Index, Accumulator]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $BFB5.w,X		; 7D B5 BF ; Add $BFB5.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D30.w,Y		; 99 30 0D ; Store accumulator to $0D30.w,Y [Reads: Y Index, Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $BFB9.w,X		; 7D B9 BF ; Add $BFB9.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,Y		; 99 00 0D ; Store accumulator to $0D00.w,Y [Reads: Y Index, Accumulator]
	lda $03.b		; A5 03 ; Load $03.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $BFBD.w,X		; 7D BD BF ; Add $BFBD.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D20.w,Y		; 99 20 0D ; Store accumulator to $0D20.w,Y [Reads: Y Index, Accumulator]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06EA12.l		; 22 12 EA 06 ; Jump to subroutine long $06EA12.l [Writes: Stack Pointer] [Flow: call]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DB0.w,X		; 9D B0 0D ; Store accumulator to $0DB0.w,X [Reads: Accumulator, X Index]
	jsr $F93F.w		; 20 3F F9 ; Jump to subroutine at $F93F.w [Writes: Stack Pointer] [Flow: call]
	lda $0F.b		; A5 0F ; Load $0F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $03		; 10 03 ; Branch if plus to $10, $03 [Flow: branch]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0F.b		; 85 0F ; Store accumulator to $0F.b [Reads: Accumulator]
	lda $0E.b		; A5 0E ; Load $0E.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $03		; 10 03 ; Branch if plus to $10, $03 [Flow: branch]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora $0F.b		; 05 0F ; Logical OR $0F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $C03B.w,Y		; B9 3B C0 ; Load $C03B.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	lda $0E60.w,X		; BD 60 0E ; Load $0E60.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$EE.b		; 29 EE ; Logical AND #$EE.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$18.b		; 09 18 ; Logical OR #$18.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E60.w,X		; 9D 60 0E ; Store accumulator to $0E60.w,X [Reads: Accumulator, X Index]
	lda #$08.b		; A9 08 ; Load #$08.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	lda #$FF.b		; A9 FF ; Load #$FF.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E00.w,X		; 9D 00 0E ; Store accumulator to $0E00.w,X [Reads: Accumulator, X Index]
	stz $0E50.w,X		; 9E 50 0E ; Store zero to $0E50.w,X [Reads: X Index]
	lda #$13.b		; A9 13 ; Load #$13.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB8A.l		; 22 8A BB 0D ; Jump to subroutine long $0DBB8A.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $3028.w		; 20 28 30 ; Jump to subroutine at $3028.w [Writes: Stack Pointer] [Flow: call]
	sec		; 38 ; Set carry flag [Flags: C]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	jsr $FA50.w		; 20 50 FA ; Jump to subroutine at $FA50.w [Writes: Stack Pointer] [Flow: call]
	ldy #$08.b		; A0 08 ; Load #$08.b into Y register [Writes: Y Index] [Flags: NZ]
	jsr $B160.w		; 20 60 B1 ; Jump to subroutine at $B160.w [Writes: Stack Pointer] [Flow: call]
	ldy #$04.b		; A0 04 ; Load #$04.b into Y register [Writes: Y Index] [Flags: NZ]
	jsr $B3CD.w		; 20 CD B3 ; Jump to subroutine at $B3CD.w [Writes: Stack Pointer] [Flow: call]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$14.b		; C9 14 ; Compare #$14.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $03		; B0 03 ; Branch if carry set to $B0, $03 [Flow: branch]
	jsr $C089.w		; 20 89 C0 ; Jump to subroutine at $C089.w [Writes: Stack Pointer] [Flow: call]
	lda #$0A.b		; A9 0A ; Load #$0A.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06DC5C.l		; 22 5C DC 06 ; Jump to subroutine long $06DC5C.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $0001FF.l,X		; FF FF 01 00 ; Subtract with carry (long,X) $0001FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$00.b		; 09 00 ; Logical OR #$00.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$00.b		; 09 00 ; Logical OR #$00.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $F4FFF8.l,X		; FF F8 FF F4 ; Subtract with carry (long,X) $F4FFF8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F4FFF4.l,X		; FF F4 FF F4 ; Subtract with carry (long,X) $F4FFF4.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F0FFF4.l,X		; FF F4 FF F0 ; Subtract with carry (long,X) $F0FFF4.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F4FFF2.l,X		; FF F2 FF F4 ; Subtract with carry (long,X) $F4FFF2.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $DAFFF2.l,X		; FF F2 FF DA ; Subtract with carry (long,X) $DAFFF2.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $0E80.w,X		; 1D 80 0E ; OR accumulator with memory $0E80.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $C069.w,X		; 7D 69 C0 ; Add $C069.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	and #$0100.w		; 29 00 01 ; Logical AND #$0100.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E.b		; 85 0E ; Store accumulator to $0E.b [Reads: Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $C079.w,X		; 7D 79 C0 ; Add $C079.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0010.w		; 69 10 00 ; Add #$0010.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0100.w		; C9 00 01 ; Compare #$0100.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $05		; 90 05 ; Branch if carry clear to $90, $05 [Flow: branch]
	lda #$00F0.w		; A9 F0 00 ; Load #$00F0.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
.ACCU 8
	sep #$20		; E2 20
	lda #$6E.b		; A9 6E ; Load #$6E.b into accumulator [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	lda $05.b		; A5 05 ; Load $05.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$30.b		; 29 30 ; Logical AND #$30.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$08.b		; 09 08 ; Logical OR #$08.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0F.b		; 05 0F ; Logical OR $0F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($92.b)		; 92 92 ; Store accumulator (indirect) ($92.b) [Reads: Direct Page, Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	pea $F40C.w		; F4 0C F4 ; Push absolute address $F40C.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	tsb $08F8.w		; 0C F8 08 ; Test and set bits $08F8.w [Reads: Accumulator] [Flags: Z]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pea $0CF4.w		; F4 F4 0C ; Push absolute address $0CF4.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	tsb $F8F8.w		; 0C F8 F8 ; Test and set bits $F8F8.w [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sty $84.b		; 84 84 ; Store Y register to $84.b [Reads: Y Index]
	sty $84.b		; 84 84 ; Store Y register to $84.b [Reads: Y Index]
	stx $86.b		; 86 86 ; Store X register to $86.b [Reads: X Index]
	stx $86.b		; 86 86 ; Store X register to $86.b [Reads: X Index]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $FA50.w		; 20 50 FA ; Jump to subroutine at $FA50.w [Writes: Stack Pointer] [Flow: call]
	lda $0E00.w,X		; BD 00 0E ; Load $0E00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$0C.b		; 29 0C ; Logical AND #$0C.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx #$03.b		; A2 03 ; Load #$03.b into X register [Writes: X Index] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $06.b		; 65 06 ; Add $06.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $C0D3.w,X		; 7D D3 C0 ; Add $C0D3.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $C0E3.w,X		; 7D E3 C0 ; Add $C0E3.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $C0F3.w,X		; BD F3 C0 ; Load $C0F3.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $C103.w,X		; BD 03 C1 ; Load $C103.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $D6		; 10 D6 ; Branch if plus to $10, $D6 [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	ldy #$02.b		; A0 02 ; Load #$02.b into Y register [Writes: Y Index] [Flags: NZ]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06FEB4.l		; 22 B4 FE 06 ; Jump to subroutine long $06FEB4.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DB0.w,X		; BD B0 0D ; Load $0DB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	jmp $C227.w		; 4C 27 C2 ; Jump to $C227.w [Flow: jump]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	lda $0D50.w,X		; BD 50 0D ; Load $0D50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $01		; 10 01 ; Branch if plus to $10, $01 [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0D10.w,X		; 7D 10 0D ; Add $0D10.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,X		; 9D 10 0D ; Store accumulator to $0D10.w,X [Reads: Accumulator, X Index]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $0D30.w,X		; 7D 30 0D ; Add $0D30.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D30.w,X		; 9D 30 0D ; Store accumulator to $0D30.w,X [Reads: Accumulator, X Index]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	lda $0D40.w,X		; BD 40 0D ; Load $0D40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $01		; 10 01 ; Branch if plus to $10, $01 [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0D00.w,X		; 7D 00 0D ; Add $0D00.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,X		; 9D 00 0D ; Store accumulator to $0D00.w,X [Reads: Accumulator, X Index]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $0D20.w,X		; 7D 20 0D ; Add $0D20.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D20.w,X		; 9D 20 0D ; Store accumulator to $0D20.w,X [Reads: Accumulator, X Index]
	ldy $0DB0.w,X		; BC B0 0D ; Load Y register $0DB0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $0E1F.w,Y		; B9 1F 0E ; Load $0E1F.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$CE.b		; C9 CE ; Compare #$CE.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $2C		; D0 2C ; Branch if not equal to $D0, $2C [Flow: branch]
.ACCU 16
	rep #$20		; C2 20
	lda $0FD8.w		; AD D8 0F ; Load $0FD8.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $22.b		; E5 22 ; Subtract $22.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0010.w		; 69 10 00 ; Add #$0010.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0020.w		; C9 20 00 ; Compare #$0020.w with accumulator [Reads: Accumulator] [Flags: NCZ]
.ACCU 8
	sep #$20		; E2 20
	.db $B0, $16		; B0 16 ; Branch if carry set to $B0, $16 [Flow: branch]
.ACCU 16
	rep #$20		; C2 20
	lda $20.b		; A5 20 ; Load $20.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $0FDA.w		; ED DA 0F ; Subtract $0FDA.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0018.w		; 69 18 00 ; Add #$0018.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0020.w		; C9 20 00 ; Compare #$0020.w with accumulator [Reads: Accumulator] [Flags: NCZ]
.ACCU 8
	sep #$20		; E2 20
	.db $B0, $03		; B0 03 ; Branch if carry set to $B0, $03 [Flow: branch]
	jmp $C1F6.w		; 4C F6 C1 ; Jump to $C1F6.w [Flow: jump]
	jmp $C21A.w		; 4C 1A C2 ; Jump to $C21A.w [Flow: jump]
	jsl $0DC26E.l		; 22 6E C2 0D ; Jump to subroutine long $0DC26E.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $07		; 90 07 ; Branch if carry clear to $90, $07 [Flow: branch]
	lda $0FA5.w		; AD A5 0F ; Load $0FA5.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$09.b		; C9 09 ; Compare #$09.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $57		; D0 57 ; Branch if not equal to $D0, $57 [Flow: branch]
	lda $0055.w		; AD 55 00 ; Load $0055.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $52		; D0 52 ; Branch if not equal to $D0, $52 [Flow: branch]
.ACCU 16
	rep #$20		; C2 20
	lda $0FD8.w		; AD D8 0F ; Load $0FD8.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $22.b		; E5 22 ; Subtract $22.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0010.w		; C9 10 00 ; Compare #$0010.w with accumulator [Reads: Accumulator] [Flags: NCZ]
.ACCU 8
	sep #$20		; E2 20
	.db $B0, $3A		; B0 3A ; Branch if carry set to $B0, $3A [Flow: branch]
.ACCU 16
	rep #$20		; C2 20
	lda $0FDA.w		; AD DA 0F ; Load $0FDA.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $20.b		; E5 20 ; Subtract $20.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0010.w		; C9 10 00 ; Compare #$0010.w with accumulator [Reads: Accumulator] [Flags: NCZ]
.ACCU 8
	sep #$20		; E2 20
	.db $B0, $2B		; B0 2B ; Branch if carry set to $B0, $2B [Flow: branch]
	lda $0F20.w,X		; BD 20 0F ; Load $0F20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $EE.b		; C5 EE ; Compare $EE.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	.db $D0, $24		; D0 24 ; Branch if not equal to $D0, $24 [Flow: branch]
	lda $0DB0.w,X		; BD B0 0D ; Load $0DB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $14		; F0 14 ; Branch if equal to $F0, $14 [Flow: branch]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D80.w,X		; 9D 80 0D ; Store accumulator to $0D80.w,X [Reads: Accumulator, X Index]
	lda $0E20.w,X		; BD 20 0E ; Load $0E20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$CE.b		; C9 CE ; Compare #$CE.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $08		; F0 08 ; Branch if equal to $F0, $08 [Flow: branch]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	stz $0E80.w,X		; 9E 80 0E ; Store zero to $0E80.w,X [Reads: X Index]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	.db $80, $09		; 80 09 ; Branch always to $80, $09 [Flow: branch]
	jsr $FA50.w		; 20 50 FA ; Jump to subroutine at $FA50.w [Writes: Stack Pointer] [Flow: call]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	lda $0E00.w,X		; BD 00 0E ; Load $0E00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0C		; F0 0C ; Branch if equal to $F0, $0C [Flow: branch]
	lda $B5CB.w,Y		; B9 CB B5 ; Load $B5CB.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	lda $B5CF.w,Y		; B9 CF B5 ; Load $B5CF.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	jsr $C680.w		; 20 80 C6 ; Jump to subroutine at $C680.w [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	lda $0DD0.w,X		; BD D0 0D ; Load $0DD0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$05.b		; C9 05 ; Compare #$05.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $0A		; D0 0A ; Branch if not equal to $D0, $0A [Flow: branch]
	lda $11.b		; A5 11 ; Load $11.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $D0		; D0 D0 ; Branch if not equal to $D0, $D0 [Flow: branch]
	jsr $C535.w		; 20 35 C5 ; Jump to subroutine at $C535.w [Writes: Stack Pointer] [Flow: call]
	jmp $C535.w		; 4C 35 C5 ; Jump to $C535.w [Flow: jump]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	jsl $06EB5E.l		; 22 5E EB 06 ; Jump to subroutine long $06EB5E.l [Writes: Stack Pointer] [Flow: call]
	jsl $06F121.l		; 22 21 F1 06 ; Jump to subroutine long $06F121.l [Writes: Stack Pointer] [Flow: call]
	.db $B0, $05		; B0 05 ; Branch if carry set to $B0, $05 [Flow: branch]
	lda $0FDC.w		; AD DC 0F ; Load $0FDC.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $10		; F0 10 ; Branch if equal to $F0, $10 [Flow: branch]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $09		; B0 09 ; Branch if carry set to $B0, $09 [Flow: branch]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D80.w,X		; 9D 80 0D ; Store accumulator to $0D80.w,X [Reads: Accumulator, X Index]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $80, $10		; 80 10 ; Branch always to $80, $10 [Flow: branch]
	lda $0EA0.w,X		; BD A0 0E ; Load $0EA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0E		; F0 0E ; Branch if equal to $F0, $0E [Flow: branch]
	cmp #$04.b		; C9 04 ; Compare #$04.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $0A		; 90 0A ; Branch if carry clear to $90, $0A [Flow: branch]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D80.w,X		; 9D 80 0D ; Store accumulator to $0D80.w,X [Reads: Accumulator, X Index]
	lda #$80.b		; A9 80 ; Load #$80.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $C4D7.w		; 20 D7 C4 ; Jump to subroutine at $C4D7.w [Writes: Stack Pointer] [Flow: call]
	jsr $F971.w		; 20 71 F9 ; Jump to subroutine at $F971.w [Writes: Stack Pointer] [Flow: call]
	lda $0E30.w,X		; BD 30 0E ; Load $0E30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$05.b		; C9 05 ; Compare #$05.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $0D		; B0 0D ; Branch if carry set to $B0, $0D [Flow: branch]
	lda $0E70.w,X		; BD 70 0E ; Load $0E70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	jsr $F9ED.w		; 20 ED F9 ; Jump to subroutine at $F9ED.w [Writes: Stack Pointer] [Flow: call]
	jsr $B88D.w		; 20 8D B8 ; Jump to subroutine at $B88D.w [Writes: Stack Pointer] [Flow: call]
	.db $80, $03		; 80 03 ; Branch always to $80, $03 [Flow: branch]
	jsr $F9ED.w		; 20 ED F9 ; Jump to subroutine at $F9ED.w [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$04.b		; C9 04 ; Compare #$04.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	stz $0ED0.w,X		; 9E D0 0E ; Store zero to $0ED0.w,X [Reads: X Index]
.ACCU 16
.INDEX 16
	rep #$30		; C2 30
	and #$00FF.w		; 29 FF 00 ; Logical AND #$00FF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $C2C6.w,Y		; B9 C6 C2 ; Load $C2C6.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	pei ($C2.b)		; D4 C2 ; Push effective indirect address ($C2.b) [Reads: Direct Page] [Writes: Stack Pointer]
	ora $C4.b,S		; 03 C4 ; OR accumulator with stack relative $C4.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $90, $C4		; 90 C4 ; Branch if carry clear to $90, $C4 [Flow: branch]
	cmp ($C4.b,X)		; C1 C4 ; Compare accumulator ($C4.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cpy $60.b		; C4 60 ; Compare $60.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	cpy #$FF.b		; C0 FF ; Compare #$FF.b with Y register [Reads: Y Index] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	jsr $C4F9.w		; 20 F9 C4 ; Jump to subroutine at $C4F9.w [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $54		; D0 54 ; Branch if not equal to $D0, $54 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda $0E30.w,X		; BD 30 0E ; Load $0E30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $22		; F0 22 ; Branch if equal to $F0, $22 [Flow: branch]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$05.b		; C9 05 ; Compare #$05.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $1C		; B0 1C ; Branch if carry set to $B0, $1C [Flow: branch]
	lda $0E30.w,X		; BD 30 0E ; Load $0E30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $C2D0.w,Y		; B9 D0 C2 ; Load $C2D0.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$01.b		; 49 01 ; Exclusive OR #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	stz $0E80.w,X		; 9E 80 0E ; Store zero to $0E80.w,X [Reads: X Index]
	.db $80, $25		; 80 25 ; Branch always to $80, $25 [Flow: branch]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$3F.b		; 29 3F ; Logical AND #$3F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$28.b		; 69 28 ; Add #$28.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	cmp $0DE0.w,X		; DD E0 0D ; Compare accumulator $0DE0.w,X [Reads: X Index] [Flags: NCZ]
	.db $F0, $0C		; F0 0C ; Branch if equal to $F0, $0C [Flow: branch]
	eor $0DE0.w,X		; 5D E0 0D ; Exclusive OR accumulator with memory $0DE0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$02.b		; 29 02 ; Logical AND #$02.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $05		; D0 05 ; Branch if not equal to $D0, $05 [Flow: branch]
	lda #$0C.b		; A9 0C ; Load #$0C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E00.w,X		; 9D 00 0E ; Store accumulator to $0E00.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tsb $0C0D.w		; 0C 0D 0C ; Test and set bits $0C0D.w [Reads: Accumulator] [Flags: Z]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	asl $05.b		; 06 05 ; Arithmetic shift left $05.b [Reads: Direct Page] [Flags: NCZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$0A.b		; 09 0A ; Logical OR #$0A.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($12.b),Y		; 11 12 ; OR accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($12.b),Y		; 11 12 ; OR accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0D0E.w		; 0D 0E 0D ; Logical OR $0D0E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $0101.w		; 0E 01 01 ; Arithmetic shift left $0101.w [Flags: NCZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $FF0101.l,X		; FF 01 01 FF ; Subtract with carry (long,X) $FF0101.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FF0101.l,X		; FF 01 01 FF ; Subtract with carry (long,X) $FF0101.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	asl $BC.b		; 06 BC ; Arithmetic shift left $BC.b [Reads: Direct Page] [Flags: NCZ]
	ldy #$0D.b		; A0 0D ; Load #$0D.b into Y register [Writes: Y Index] [Flags: NZ]
	lda $C359.w,Y		; B9 59 C3 ; Load $C359.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $C361.w,Y		; B9 61 C3 ; Load $C361.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	jsr $B88D.w		; 20 8D B8 ; Jump to subroutine at $B88D.w [Writes: Stack Pointer] [Flow: call]
	lda $0E10.w,X		; BD 10 0E ; Load $0E10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0F		; F0 0F ; Branch if equal to $F0, $0F [Flow: branch]
	cmp #$2C.b		; C9 2C ; Compare #$2C.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $1B		; D0 1B ; Branch if not equal to $D0, $1B [Flow: branch]
	ldy $0DA0.w,X		; BC A0 0D ; Load Y register $0DA0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $C399.w,Y		; B9 99 C3 ; Load $C399.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DA0.w,X		; 9D A0 0D ; Store accumulator to $0DA0.w,X [Reads: Accumulator, X Index]
	.db $80, $10		; 80 10 ; Branch always to $80, $10 [Flow: branch]
	ldy $0DA0.w,X		; BC A0 0D ; Load Y register $0DA0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $0E70.w,X		; BD 70 0E ; Load $0E70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $C389.w,Y		; 39 89 C3 ; AND accumulator with memory $C389.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $05		; D0 05 ; Branch if not equal to $D0, $05 [Flow: branch]
	lda #$58.b		; A9 58 ; Load #$58.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E10.w,X		; 9D 10 0E ; Store accumulator to $0E10.w,X [Reads: Accumulator, X Index]
	ldy $0DA0.w,X		; BC A0 0D ; Load Y register $0DA0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $0E70.w,X		; BD 70 0E ; Load $0E70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $C381.w,Y		; 39 81 C3 ; AND accumulator with memory $C381.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $06		; F0 06 ; Branch if equal to $F0, $06 [Flow: branch]
	lda $C391.w,Y		; B9 91 C3 ; Load $C391.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DA0.w,X		; 9D A0 0D ; Store accumulator to $0DA0.w,X [Reads: Accumulator, X Index]
	ldy $0DA0.w,X		; BC A0 0D ; Load Y register $0DA0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $C369.w,Y		; B9 69 C3 ; Load $C369.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $C371.w,Y		; B9 71 C3 ; Load $C371.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	lda $C379.w,Y		; B9 79 C3 ; Load $C379.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	jmp $C454.w		; 4C 54 C4 ; Jump to $C454.w [Flow: jump]
	jsr $C5F2.w		; 20 F2 C5 ; Jump to subroutine at $C5F2.w [Writes: Stack Pointer] [Flow: call]
	lda $0E30.w,X		; BD 30 0E ; Load $0E30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$05.b		; C9 05 ; Compare #$05.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $03		; 90 03 ; Branch if carry clear to $90, $03 [Flow: branch]
	jmp $C3A1.w		; 4C A1 C3 ; Jump to $C3A1.w [Flow: jump]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0E		; D0 0E ; Branch if not equal to $D0, $0E [Flow: branch]
	jsr $C4F9.w		; 20 F9 C4 ; Jump to subroutine at $C4F9.w [Writes: Stack Pointer] [Flow: call]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D80.w,X		; 9D 80 0D ; Store accumulator to $0D80.w,X [Reads: Accumulator, X Index]
	lda #$A0.b		; A9 A0 ; Load #$A0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	inc $0DF0.w,X		; FE F0 0D ; Increment memory $0DF0.w,X [Reads: X Index] [Flags: NZ]
	lda $0E70.w,X		; BD 70 0E ; Load $0E70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$0F.b		; 29 0F ; Logical AND #$0F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0B		; F0 0B ; Branch if equal to $F0, $0B [Flow: branch]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$01.b		; 49 01 ; Exclusive OR #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	jsr $C32B.w		; 20 2B C3 ; Jump to subroutine at $C32B.w [Writes: Stack Pointer] [Flow: call]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $C331.w,Y		; B9 31 C3 ; Load $C331.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $C335.w,Y		; B9 35 C3 ; Load $C335.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc $00.b		; 65 00 ; Add $00.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $C339.w,Y		; B9 39 C3 ; Load $C339.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $C4F9.w		; 20 F9 C4 ; Jump to subroutine at $C4F9.w [Writes: Stack Pointer] [Flow: call]
	jsr $C5F2.w		; 20 F2 C5 ; Jump to subroutine at $C5F2.w [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0B		; D0 0B ; Branch if not equal to $D0, $0B [Flow: branch]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D80.w,X		; 9D 80 0D ; Store accumulator to $0D80.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cmp #$80.b		; C9 80 ; Compare #$80.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $16		; B0 16 ; Branch if carry set to $B0, $16 [Flow: branch]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $C470.w,Y		; B9 70 C4 ; Load $C470.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $C4F9.w		; 20 F9 C4 ; Jump to subroutine at $C4F9.w [Writes: Stack Pointer] [Flow: call]
	jsr $F93F.w		; 20 3F F9 ; Jump to subroutine at $F93F.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $17		; D0 17 ; Branch if not equal to $D0, $17 [Flow: branch]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D80.w,X		; 9D 80 0D ; Store accumulator to $0D80.w,X [Reads: Accumulator, X Index]
	lda #$FF.b		; A9 FF ; Load #$FF.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	stz $0E30.w,X		; 9E 30 0E ; Store zero to $0E30.w,X [Reads: X Index]
	lda $0B6B.w,X		; BD 6B 0B ; Load $0B6B.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$0F.b		; 29 0F ; Logical AND #$0F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$60.b		; 09 60 ; Logical OR #$60.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0B6B.w,X		; 9D 6B 0B ; Store accumulator to $0B6B.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $13		; D0 13 ; Branch if not equal to $D0, $13 [Flow: branch]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $D041.w,Y		; [PATTERN: Memory clearing operation] B9 41 D0 ; Load $D041.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0EC0.w,X		; 9D C0 0E ; Store accumulator to $0EC0.w,X [Reads: Accumulator, X Index]
	.db $82, $1E, $FF		; 82 1E FF ; Branch always long to $82, $1E, $FF [Flow: branch]
	stz $0D50.w,X		; 9E 50 0D ; Store zero to $0D50.w,X [Reads: X Index]
	stz $0D40.w,X		; 9E 40 0D ; Store zero to $0D40.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$1F.b		; 29 1F ; Logical AND #$1F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $2A		; D0 2A ; Branch if not equal to $D0, $2A [Flow: branch]
	lda $0ED0.w,X		; BD D0 0E ; Load $0ED0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $09		; D0 09 ; Branch if not equal to $D0, $09 [Flow: branch]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB8A.l		; 22 8A BB 0D ; Jump to subroutine long $0DBB8A.l [Writes: Stack Pointer] [Flow: call]
	inc $0ED0.w,X		; FE D0 0E ; Increment memory $0ED0.w,X [Reads: X Index] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $0E20.w,X		; BD 20 0E ; Load $0E20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$42.b		; C9 42 ; Compare #$42.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	lda $C566.w,Y		; B9 66 C5 ; Load $C566.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $06EA12.l		; 22 12 EA 06 ; Jump to subroutine long $06EA12.l [Writes: Stack Pointer] [Flow: call]
	jsr $F93F.w		; 20 3F F9 ; Jump to subroutine at $F93F.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	jsl $05C542.l		; 22 42 C5 05 ; Jump to subroutine long $05C542.l [Writes: Stack Pointer] [Flow: call]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	jsr $C454.w		; 20 54 C4 ; Jump to subroutine at $C454.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	asl $00F2.w		; 0E F2 00 ; Arithmetic shift left $00F2.w [Flags: NCZ]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($8B.b)		; F2 8B ; Subtract with carry (indirect) ($8B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	lda $0E70.w,X		; BD 70 0E ; Load $0E70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $1A		; F0 1A ; Branch if equal to $F0, $1A [Flow: branch]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $07		; F0 07 ; Branch if equal to $F0, $07 [Flow: branch]
	jsr $F949.w		; 20 49 F9 ; Jump to subroutine at $F949.w [Writes: Stack Pointer] [Flow: call]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $80, $03		; 80 03 ; Branch always to $80, $03 [Flow: branch]
	jsr $F944.w		; 20 44 F9 ; Jump to subroutine at $F944.w [Writes: Stack Pointer] [Flow: call]
	lda $C53C.w,Y		; B9 3C C5 ; Load $C53C.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $C53E.w,Y		; B9 3E C5 ; Load $C53E.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	ora ($12.b)		; 12 12 ; OR accumulator with memory (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($12.b)		; 12 12 ; OR accumulator with memory (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	.db $F0, $F2		; F0 F2 ; Branch if equal to $F0, $F2 [Flow: branch]
	pea $F8F6.w		; F4 F6 F8 ; Push absolute address $F8F6.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	jsr ($00FE.w,X)		; FC FE 00 ; Jump to subroutine indirect indexed ($00FE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $08.b		; 06 08 ; Arithmetic shift left $08.b [Reads: Direct Page] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tsb $100E.w		; 0C 0E 10 ; Test and set bits $100E.w [Reads: Accumulator] [Flags: Z]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	.db $10, $0E		; 10 0E ; Branch if plus to $10, $0E [Flow: branch]
	tsb $080A.w		; 0C 0A 08 ; Test and set bits $080A.w [Reads: Accumulator] [Flags: Z]
	asl $04.b		; 06 04 ; Arithmetic shift left $04.b [Reads: Direct Page] [Flags: NCZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $FAFC.w,X		; FE FC FA ; Increment memory $FAFC.w,X [Reads: X Index] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	inc $F4.b,X		; F6 F4 ; Increment memory $F4.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	sbc ($F0.b)		; F2 F0 ; Subtract with carry (indirect) ($F0.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $06.b		; 04 06 ; Test and set bits $06.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tsb $100E.w		; 0C 0E 10 ; Test and set bits $100E.w [Reads: Accumulator] [Flags: Z]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	.db $10, $0E		; 10 0E ; Branch if plus to $10, $0E [Flow: branch]
	tsb $080A.w		; 0C 0A 08 ; Test and set bits $080A.w [Reads: Accumulator] [Flags: Z]
	asl $04.b		; 06 04 ; Arithmetic shift left $04.b [Reads: Direct Page] [Flags: NCZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $FAFC.w,X		; FE FC FA ; Increment memory $FAFC.w,X [Reads: X Index] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	inc $F4.b,X		; F6 F4 ; Increment memory $F4.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	sbc ($F0.b)		; F2 F0 ; Subtract with carry (indirect) ($F0.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	sbc ($F4.b)		; F2 F4 ; Subtract with carry (indirect) ($F4.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inc $F8.b,X		; F6 F8 ; Increment memory $F8.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	jsr ($00FE.w,X)		; FC FE 00 ; Jump to subroutine indirect indexed ($00FE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $10, $30		; 10 30 ; Branch if plus to $10, $30 [Flow: branch]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $1A.b		; 65 1A ; Add $1A.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $0F.b		; 85 0F ; Store accumulator to $0F.b [Reads: Accumulator]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0F00.w,X		; 1D 00 0F ; OR accumulator with memory $0F00.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $6E		; D0 6E ; Branch if not equal to $D0, $6E [Flow: branch]
	lda $0EC0.w,X		; BD C0 0E ; Load $0EC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $0EC0.w,X		; FE C0 0E ; Increment memory $0EC0.w,X [Reads: X Index] [Flags: NZ]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	and #$1F.b		; 29 1F ; Logical AND #$1F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	adc $C5EE.w,Y		; 79 EE C5 ; Add $C5EE.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and #$3F.b		; 29 3F ; Logical AND #$3F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F.b		; 85 0F ; Store accumulator to $0F.b [Reads: Accumulator]
	lda #$41.b		; A9 41 ; Load #$41.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$0A.b		; A0 0A ; Load #$0A.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $1DF65F.l		; 22 5F F6 1D ; Jump to subroutine long $1DF65F.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $51		; 30 51 ; Branch if minus to $30, $51 [Flow: branch]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$08.b		; 69 08 ; Add #$08.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,Y		; 99 10 0D ; Store accumulator to $0D10.w,Y [Reads: Y Index, Accumulator]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D30.w,Y		; 99 30 0D ; Store accumulator to $0D30.w,Y [Reads: Y Index, Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$04.b		; 69 04 ; Add #$04.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,Y		; 99 00 0D ; Store accumulator to $0D00.w,Y [Reads: Y Index, Accumulator]
	lda $03.b		; A5 03 ; Load $03.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D20.w,Y		; 99 20 0D ; Store accumulator to $0D20.w,Y [Reads: Y Index, Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx $0F.b		; A6 0F ; Load $0F.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,Y		; 99 E0 0D ; Store accumulator to $0DE0.w,Y [Reads: Y Index, Accumulator]
	lda $C56E.w,X		; BD 6E C5 ; Load $C56E.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,Y		; 99 50 0D ; Store accumulator to $0D50.w,Y [Reads: Y Index, Accumulator]
	lda $C5AE.w,X		; BD AE C5 ; Load $C5AE.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,Y		; 99 40 0D ; Store accumulator to $0D40.w,Y [Reads: Y Index, Accumulator]
	lda $0E40.w,Y		; B9 40 0E ; Load $0E40.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and #$F0.b		; 29 F0 ; Logical AND #$F0.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$A0.b		; 09 A0 ; Logical OR #$A0.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E40.w,Y		; 99 40 0E ; Store accumulator to $0E40.w,Y [Reads: Y Index, Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0DB0.w,Y		; 99 B0 0D ; Store accumulator to $0DB0.w,Y [Reads: Y Index, Accumulator]
	sta $0BA0.w,Y		; 99 A0 0B ; Store accumulator to $0BA0.w,Y [Reads: Y Index, Accumulator]
	lda #$40.b		; A9 40 ; Load #$40.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F60.w,Y		; 99 60 0F ; Store accumulator to $0F60.w,Y [Reads: Y Index, Accumulator]
	sta $0E60.w,Y		; 99 60 0E ; Store accumulator to $0E60.w,Y [Reads: Y Index, Accumulator]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0CAA.w,Y		; 99 AA 0C ; Store accumulator to $0CAA.w,Y [Reads: Y Index, Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $C612.w		; 20 12 C6 ; Jump to subroutine at $C612.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	jsr $C680.w		; 20 80 C6 ; Jump to subroutine at $C680.w [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $FA50.w		; 20 50 FA ; Jump to subroutine at $FA50.w [Writes: Stack Pointer] [Flow: call]
	jsr $C6DE.w		; 20 DE C6 ; Jump to subroutine at $C6DE.w [Writes: Stack Pointer] [Flow: call]
	jsr $CA09.w		; 20 09 CA ; Jump to subroutine at $CA09.w [Writes: Stack Pointer] [Flow: call]
	jsr $CB64.w		; 20 64 CB ; Jump to subroutine at $CB64.w [Writes: Stack Pointer] [Flow: call]
	lda $0E60.w,X		; BD 60 0E ; Load $0E60.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$10.b		; 29 10 ; Logical AND #$10.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0A		; F0 0A ; Branch if equal to $F0, $0A [Flow: branch]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $C69E.w,Y		; B9 9E C6 ; Load $C69E.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $06DC5C.l		; 22 5C DC 06 ; Jump to subroutine long $06DC5C.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tsb $0A0C.w		; 0C 0C 0A ; Test and set bits $0A0C.w [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $42, $42		; 42 42 ; Reserved instruction
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	mvp $00,$40		; 44 40 00 ; Move block positive $00,$40 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DA.b		; 00 DA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $0D.b		; 85 0D ; Store accumulator to $0D.b [Reads: Accumulator]
	lda $0EB0.w,X		; BD B0 0E ; Load $0EB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	and #$0100.w		; 29 00 01 ; Logical AND #$0100.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E.b		; 85 0E ; Store accumulator to $0E.b [Reads: Accumulator]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	ldy $0D.b		; A4 0D ; Load $0D.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	sbc $C6AA.w,Y		; F9 AA C6 ; Subtract with carry $C6AA.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0010.w		; 69 10 00 ; Add #$0010.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0100.w		; C9 00 01 ; Compare #$0100.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $05		; 90 05 ; Branch if carry clear to $90, $05 [Flow: branch]
	lda #$00F0.w		; A9 F0 00 ; Load #$00F0.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
.ACCU 8
	sep #$20		; E2 20
	lda $C6A2.w,X		; BD A2 C6 ; Load $C6A2.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $C6A6.w,X		; BD A6 C6 ; Load $C6A6.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0F.b		; 05 0F ; Logical OR $0F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($92.b),Y		; 91 92 ; Store accumulator ($92.b),Y [Reads: Direct Page, Y Index, Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr ($04FF.w,X)		; FC FF 04 ; Jump to subroutine indirect indexed ($04FF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0A0004.l,X		; FF 04 00 0A ; Subtract with carry (long,X) $0A0004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0A0004.l,X		; FF 04 00 0A ; Subtract with carry (long,X) $0A0004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0A0004.l,X		; FF 04 00 0A ; Subtract with carry (long,X) $0A0004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $00FFFC.l,X		; FF FC FF 00 ; Subtract with carry (long,X) $00FFFC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $00FFFC.l,X		; FF FC FF 00 ; Subtract with carry (long,X) $00FFFC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $00FFFD.l,X		; FF FD FF 00 ; Subtract with carry (long,X) $00FFFD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FCFFFD.l,X		; FF FD FF FC ; Subtract with carry (long,X) $FCFFFD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FD0004.l,X		; FF 04 00 FD ; Subtract with carry (long,X) $FD0004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FCFFFD.l,X		; FF FD FF FC ; Subtract with carry (long,X) $FCFFFD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FD0004.l,X		; FF 04 00 FD ; Subtract with carry (long,X) $FD0004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FCFFFD.l,X		; FF FD FF FC ; Subtract with carry (long,X) $FCFFFD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FD0004.l,X		; FF 04 00 FD ; Subtract with carry (long,X) $FD0004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FCFFFD.l,X		; FF FD FF FC ; Subtract with carry (long,X) $FCFFFD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $0C0004.l,X		; FF 04 00 0C ; Subtract with carry (long,X) $0C0004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000004.l,X		; FF 04 00 00 ; Subtract with carry (long,X) $000004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000004.l,X		; FF 04 00 00 ; Subtract with carry (long,X) $000004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000004.l,X		; FF 04 00 00 ; Subtract with carry (long,X) $000004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000004.l,X		; FF 04 00 00 ; Subtract with carry (long,X) $000004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000004.l,X		; FF 04 00 00 ; Subtract with carry (long,X) $000004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000004.l,X		; FF 04 00 00 ; Subtract with carry (long,X) $000004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $010006.l,X		; FF 06 00 01 ; Subtract with carry (long,X) $010006.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $020006.l,X		; FF 06 00 02 ; Subtract with carry (long,X) $020006.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $010006.l,X		; FF 06 00 01 ; Subtract with carry (long,X) $010006.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000003.l,X		; FF 03 00 00 ; Subtract with carry (long,X) $000003.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000004.l,X		; FF 04 00 00 ; Subtract with carry (long,X) $000004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000004.l,X		; FF 04 00 00 ; Subtract with carry (long,X) $000004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000003.l,X		; FF 03 00 00 ; Subtract with carry (long,X) $000003.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $010006.l,X		; FF 06 00 01 ; Subtract with carry (long,X) $010006.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $020006.l,X		; FF 06 00 02 ; Subtract with carry (long,X) $020006.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $010006.l,X		; FF 06 00 01 ; Subtract with carry (long,X) $010006.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $48.b		; 00 48 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor #$6D.b		; 49 6D ; Exclusive OR #$6D.b with accumulator [Writes: Accumulator] [Flags: NZ]
	adc $4849.w,X		; 7D 49 48 ; Add $4849.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $467D.w		; 6D 7D 46 ; Add $467D.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	lsr $6D.b		; 46 6D ; Logical shift right $6D.b [Reads: Direct Page] [Flags: NCZ]
	adc $464B.w,X		; 7D 4B 46 ; Add $464B.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $4D7D.w		; 6D 7D 4D ; Add $4D7D.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	eor $4E4E.w,X		; 5D 4E 4E ; Exclusive OR accumulator with memory $4E4E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $605D.w		; 4D 5D 60 ; Exclusive OR $605D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	eor $625D.w		; 4D 5D 62 ; Exclusive OR $625D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $62, $6D, $7D		; 62 6D 7D ; Push effective relative address $62, $6D, $7D [Writes: Stack Pointer]
	stz $64.b		; 64 64 ; Store zero to $64.b
	adc $667D.w		; 6D 7D 66 ; Add $667D.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	adc [$6D.b]		; 67 6D ; Add with carry (long) [$6D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc $6667.w,X		; 7D 67 66 ; Add $6667.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $647D.w		; 6D 7D 64 ; Add $647D.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	adc #$4D.b		; 69 4D ; Add #$4D.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	eor $4E4E.w,X		; 5D 4E 4E ; Exclusive OR accumulator with memory $4E4E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $605D.w		; 4D 5D 60 ; Exclusive OR $605D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	eor $625D.w		; 4D 5D 62 ; Exclusive OR $625D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $62, $02, $03		; 62 02 03 ; Push effective relative address $62, $02, $03 [Writes: Stack Pointer]
	jsr $0220.w		; 20 20 02 ; Jump to subroutine at $0220.w [Writes: Stack Pointer] [Flow: call]
	tsb $2020.w		; 0C 20 20 ; Test and set bits $2020.w [Reads: Accumulator] [Flags: Z]
	cop $0C.b		; 02 0C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $0820.w		; 20 20 08 ; Jump to subroutine at $0820.w [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsr $0E20.w		; 20 20 0E ; Jump to subroutine at $0E20.w [Writes: Stack Pointer] [Flow: call]
	asl $2020.w		; 0E 20 20 ; Arithmetic shift left $2020.w [Flags: NCZ]
	asl $200E.w		; 0E 0E 20 ; Arithmetic shift left $200E.w [Flags: NCZ]
	jsr $0605.w		; 20 05 06 ; Jump to subroutine at $0605.w [Writes: Stack Pointer] [Flow: call]
	jsr $2220.w		; 20 20 22 ; Jump to subroutine at $2220.w [Writes: Stack Pointer] [Flow: call]
	asl $20.b		; 06 20 ; Arithmetic shift left $20.b [Reads: Direct Page] [Flags: NCZ]
	jsr $0622.w		; 20 22 06 ; Jump to subroutine at $0622.w [Writes: Stack Pointer] [Flow: call]
	jsr $0820.w		; 20 20 08 ; Jump to subroutine at $0820.w [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsr $0E20.w		; 20 20 0E ; Jump to subroutine at $0E20.w [Writes: Stack Pointer] [Flow: call]
	asl $2020.w		; 0E 20 20 ; Arithmetic shift left $2020.w [Flags: NCZ]
	asl $200E.w		; 0E 0E 20 ; Arithmetic shift left $200E.w [Flags: NCZ]
	jsr $0000.w		; 20 00 00 ; Jump to subroutine at $0000.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0C0C.w		; 0C 0C 0C ; Test and set bits $0C0C.w [Reads: Accumulator] [Flags: Z]
	tsb $BC.b		; 04 BC ; Test and set bits $BC.b [Reads: Accumulator] [Flags: Z]
	cpx #$0D.b		; E0 0D ; Compare #$0D.b with X register [Reads: X Index] [Flags: NCZ]
	lda $CA05.w,Y		; B9 05 CA ; Load $CA05.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $07.b		; 85 07 ; Store accumulator to $07.b [Reads: Accumulator]
	lda $0E20.w,X		; BD 20 0E ; Load $0E20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx #$03.b		; A2 03 ; Load #$03.b into X register [Writes: X Index] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $07.b		; 65 07 ; Add $07.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	stx $06.b		; 86 06 ; Store X register to $06.b [Reads: X Index]
	lda $08.b		; A5 08 ; Load $08.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$46.b		; C9 46 ; Compare #$46.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $12		; 90 12 ; Branch if carry clear to $90, $12 [Flow: branch]
	lda $C99D.w,X		; BD 9D C9 ; Load $C99D.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $7D		; F0 7D ; Branch if equal to $F0, $7D [Flow: branch]
	lda $C8CD.w,X		; BD CD C8 ; Load $C8CD.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	cpx #$03.b		; E0 03 ; Compare #$03.b with X register [Reads: X Index] [Flags: NCZ]
	.db $D0, $04		; D0 04 ; Branch if not equal to $D0, $04 [Flow: branch]
	cmp #$20.b		; C9 20 ; Compare #$20.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $70		; F0 70 ; Branch if equal to $F0, $70 [Flow: branch]
	lda $06.b		; A5 06 ; Load $06.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $C72D.w,X		; 7D 2D C7 ; Add $C72D.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	and #$0100.w		; 29 00 01 ; Logical AND #$0100.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E.b		; 85 0E ; Store accumulator to $0E.b [Reads: Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $C7FD.w,X		; 7D FD C7 ; Add $C7FD.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0010.w		; 69 10 00 ; Add #$0010.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0100.w		; C9 00 01 ; Compare #$0100.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $05		; 90 05 ; Branch if carry clear to $90, $05 [Flow: branch]
	lda #$00F0.w		; A9 F0 00 ; Load #$00F0.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
.ACCU 8
	sep #$20		; E2 20
	lda #$08.b		; A9 08 ; Load #$08.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D.b		; 85 0D ; Store accumulator to $0D.b [Reads: Accumulator]
	ldx $06.b		; A6 06 ; Load $06.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	lda $C8CD.w,X		; BD CD C8 ; Load $C8CD.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	cmp #$20.b		; C9 20 ; Compare #$20.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $13		; D0 13 ; Branch if not equal to $D0, $13 [Flow: branch]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D.b		; 85 0D ; Store accumulator to $0D.b [Reads: Accumulator]
	lda $08.b		; A5 08 ; Load $08.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$46.b		; C9 46 ; Compare #$46.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $D0, $0D		; D0 0D ; Branch if not equal to $D0, $0D [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	lda #$F0.b		; A9 F0 ; Load #$F0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $80, $05		; 80 05 ; Branch always to $80, $05 [Flow: branch]
	lda $C99D.w,X		; BD 9D C9 ; Load $C99D.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$01.b		; C9 01 ; Compare #$01.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	lda $C935.w,X		; BD 35 C9 ; Load $C935.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $04		; B0 04 ; Branch if carry set to $B0, $04 [Flow: branch]
	and #$F1.b		; 29 F1 ; Logical AND #$F1.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0D.b		; 05 0D ; Logical OR $0D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $C99D.w,X		; BD 9D C9 ; Load $C99D.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $0F.b		; 05 0F ; Logical OR $0F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($92.b),Y		; 91 92 ; Store accumulator ($92.b),Y [Reads: Direct Page, Y Index, Accumulator]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $30, $03		; 30 03 ; Branch if minus to $30, $03 [Flow: branch]
	jmp $CA1F.w		; 4C 1F CA ; Jump to $CA1F.w [Flow: jump]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $FDFF.w,X		; FD FF FD ; Subtract with carry $FDFF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FCFFFC.l,X		; FF FC FF FC ; Subtract with carry (long,X) $FCFFFC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FCFFFC.l,X		; FF FC FF FC ; Subtract with carry (long,X) $FCFFFC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FCFFFC.l,X		; FF FC FF FC ; Subtract with carry (long,X) $FCFFFC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FDFFF5.l,X		; FF F5 FF FD ; Subtract with carry (long,X) $FDFFF5.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FDFFF5.l,X		; FF F5 FF FD ; Subtract with carry (long,X) $FDFFF5.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F8FFF0.l,X		; FF F0 FF F8 ; Subtract with carry (long,X) $F8FFF0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $0C000C.l,X		; FF 0C 00 0C ; Subtract with carry (long,X) $0C000C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $15.b		; 00 15 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $15.b		; 00 15 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $16.b		; 00 16 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F6.b		; 00 F6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $F7FFFE.l,X		; FF FE FF F7 ; Subtract with carry (long,X) $F7FFFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F7FFFF.l,X		; FF FF FF F7 ; Subtract with carry (long,X) $F7FFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F0FFFF.l,X		; FF FF FF F0 ; Subtract with carry (long,X) $F0FFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $08FFF8.l,X		; FF F8 FF 08 ; Subtract with carry (long,X) $08FFF8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7B.b		; 00 7B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jmp ($6C7C.w)		; 6C 7C 6C ; Jump indirect to ($6C7C.w) [Flow: jump]
	jmp ($7C6C.w,X)		; 7C 6C 7C ; Jump indirect indexed to ($7C6C.w,X) [Reads: X Index] [Flow: jump]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jmp ($6C7C.w)		; 6C 7C 6C ; Jump indirect to ($6C7C.w) [Flow: jump]
	jmp ($7C6C.w,X)		; 7C 6C 7C ; Jump indirect indexed to ($7C6C.w,X) [Reads: X Index] [Flow: jump]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	tsb $14.b		; 04 14 ; Test and set bits $14.b [Reads: Accumulator] [Flags: Z]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	lda $0E20.w,X		; BD 20 0E ; Load $0E20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$41.b		; E9 41 ; Subtract #$41.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $CB60.w,Y		; B9 60 CB ; Load $CB60.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx #$01.b		; A2 01 ; Load #$01.b into X register [Writes: X Index] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $06.b		; 65 06 ; Add $06.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	lda $CAB8.w,X		; BD B8 CA ; Load $CAB8.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $00.b		; 65 00 ; Add $00.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	and #$0100.w		; 29 00 01 ; Logical AND #$0100.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E.b		; 85 0E ; Store accumulator to $0E.b [Reads: Accumulator]
	lda $CAF0.w,X		; BD F0 CA ; Load $CAF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $02.b		; 65 02 ; Add $02.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0010.w		; 69 10 00 ; Add #$0010.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0100.w		; C9 00 01 ; Compare #$0100.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $05		; 90 05 ; Branch if carry clear to $90, $05 [Flow: branch]
	lda #$00F0.w		; A9 F0 00 ; Load #$00F0.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
.ACCU 8
	sep #$20		; E2 20
	lda $CAB8.w,X		; BD B8 CA ; Load $CAB8.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0FAB.w		; 8D AB 0F ; Store accumulator to $0FAB.w [Reads: Accumulator]
	lda $CAF0.w,X		; BD F0 CA ; Load $CAF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0FAA.w		; 8D AA 0F ; Store accumulator to $0FAA.w [Reads: Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda $08.b		; A5 08 ; Load $08.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	lda $CB28.w,X		; BD 28 CB ; Load $CB28.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $02		; B0 02 ; Branch if carry set to $B0, $02 [Flow: branch]
	adc #$03.b		; 69 03 ; Add #$03.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $CB44.w,X		; BD 44 CB ; Load $CB44.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $0F.b		; A5 0F ; Load $0F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($92.b),Y		; 91 92 ; Store accumulator ($92.b),Y [Reads: Direct Page, Y Index, Accumulator]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $9E		; 10 9E ; Branch if plus to $10, $9E [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $C680.w		; 20 80 C6 ; Jump to subroutine at $C680.w [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	jsr $CC3C.w		; 20 3C CC ; Jump to subroutine at $CC3C.w [Writes: Stack Pointer] [Flow: call]
	jsl $06EB5E.l		; 22 5E EB 06 ; Jump to subroutine long $06EB5E.l [Writes: Stack Pointer] [Flow: call]
	jsr $F971.w		; 20 71 F9 ; Jump to subroutine at $F971.w [Writes: Stack Pointer] [Flow: call]
	jsr $CDD4.w		; 20 D4 CD ; Jump to subroutine at $CDD4.w [Writes: Stack Pointer] [Flow: call]
	jsr $B88D.w		; 20 8D B8 ; Jump to subroutine at $B88D.w [Writes: Stack Pointer] [Flow: call]
	jsl $06F121.l		; 22 21 F1 06 ; Jump to subroutine long $06F121.l [Writes: Stack Pointer] [Flow: call]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$0F.b		; 29 0F ; Logical AND #$0F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $34		; D0 34 ; Branch if not equal to $D0, $34 [Flow: branch]
	jsr $F93F.w		; 20 3F F9 ; Jump to subroutine at $F93F.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $C56A.w,Y		; B9 6A C5 ; Load $C56A.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $06EA12.l		; 22 12 EA 06 ; Jump to subroutine long $06EA12.l [Writes: Stack Pointer] [Flow: call]
	lda $0E70.w,X		; BD 70 0E ; Load $0E70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $1A		; F0 1A ; Branch if equal to $F0, $1A [Flow: branch]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $07		; F0 07 ; Branch if equal to $F0, $07 [Flow: branch]
	jsr $F949.w		; 20 49 F9 ; Jump to subroutine at $F949.w [Writes: Stack Pointer] [Flow: call]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $80, $03		; 80 03 ; Branch always to $80, $03 [Flow: branch]
	jsr $F944.w		; 20 44 F9 ; Jump to subroutine at $F944.w [Writes: Stack Pointer] [Flow: call]
	lda $C53C.w,Y		; B9 3C C5 ; Load $C53C.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $C53E.w,Y		; B9 3E C5 ; Load $C53E.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	jsr $C454.w		; 20 54 C4 ; Jump to subroutine at $C454.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0ED0.w,X		; BD D0 0E ; Load $0ED0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$10.b		; C9 10 ; Compare #$10.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $21		; F0 21 ; Branch if equal to $F0, $21 [Flow: branch]
	inc $0ED0.w,X		; FE D0 0E ; Increment memory $0ED0.w,X [Reads: X Index] [Flags: NZ]
	cmp #$0F.b		; C9 0F ; Compare #$0F.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $1A		; D0 1A ; Branch if not equal to $D0, $1A [Flow: branch]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB8A.l		; 22 8A BB 0D ; Jump to subroutine long $0DBB8A.l [Writes: Stack Pointer] [Flow: call]
	lda $7EF3C5.l		; AF C5 F3 7E ; Load long $7EF3C5.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $0C		; D0 0C ; Branch if not equal to $D0, $0C [Flow: branch]
	lda $040A.w		; AD 0A 04 ; Load $040A.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$18.b		; C9 18 ; Compare #$18.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $05		; D0 05 ; Branch if not equal to $D0, $05 [Flow: branch]
	lda #$0C.b		; A9 0C ; Load #$0C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012C.w		; 8D 2C 01 ; Store accumulator to $012C.w [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $CCD5.w		; 20 D5 CC ; Jump to subroutine at $CCD5.w [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	jsr $CC3C.w		; 20 3C CC ; Jump to subroutine at $CC3C.w [Writes: Stack Pointer] [Flow: call]
	jsl $06EB5E.l		; 22 5E EB 06 ; Jump to subroutine long $06EB5E.l [Writes: Stack Pointer] [Flow: call]
	jsr $F971.w		; 20 71 F9 ; Jump to subroutine at $F971.w [Writes: Stack Pointer] [Flow: call]
	jsr $CDD4.w		; 20 D4 CD ; Jump to subroutine at $CDD4.w [Writes: Stack Pointer] [Flow: call]
	jsr $B88D.w		; 20 8D B8 ; Jump to subroutine at $B88D.w [Writes: Stack Pointer] [Flow: call]
	jsl $06F121.l		; 22 21 F1 06 ; Jump to subroutine long $06F121.l [Writes: Stack Pointer] [Flow: call]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$0F.b		; 29 0F ; Logical AND #$0F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $34		; D0 34 ; Branch if not equal to $D0, $34 [Flow: branch]
	jsr $F93F.w		; 20 3F F9 ; Jump to subroutine at $F93F.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $C56A.w,Y		; B9 6A C5 ; Load $C56A.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $06EA12.l		; 22 12 EA 06 ; Jump to subroutine long $06EA12.l [Writes: Stack Pointer] [Flow: call]
	lda $0E70.w,X		; BD 70 0E ; Load $0E70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $1A		; F0 1A ; Branch if equal to $F0, $1A [Flow: branch]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $07		; F0 07 ; Branch if equal to $F0, $07 [Flow: branch]
	jsr $F949.w		; 20 49 F9 ; Jump to subroutine at $F949.w [Writes: Stack Pointer] [Flow: call]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $80, $03		; 80 03 ; Branch always to $80, $03 [Flow: branch]
	jsr $F944.w		; 20 44 F9 ; Jump to subroutine at $F944.w [Writes: Stack Pointer] [Flow: call]
	lda $C53C.w,Y		; B9 3C C5 ; Load $C53C.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $C53E.w,Y		; B9 3E C5 ; Load $C53E.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $B0C7.w,Y		; B9 C7 B0 ; Load $B0C7.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $FA50.w		; 20 50 FA ; Jump to subroutine at $FA50.w [Writes: Stack Pointer] [Flow: call]
	ldy #$0C.b		; A0 0C ; Load #$0C.b into Y register [Writes: Y Index] [Flags: NZ]
	jsr $B160.w		; 20 60 B1 ; Jump to subroutine at $B160.w [Writes: Stack Pointer] [Flow: call]
	ldy #$08.b		; A0 08 ; Load #$08.b into Y register [Writes: Y Index] [Flags: NZ]
	jsr $B3CD.w		; 20 CD B3 ; Jump to subroutine at $B3CD.w [Writes: Stack Pointer] [Flow: call]
	jsr $CD4F.w		; 20 4F CD ; Jump to subroutine at $CD4F.w [Writes: Stack Pointer] [Flow: call]
	jmp $C68C.w		; 4C 8C C6 ; Jump to $C68C.w [Flow: jump]
	ora $000700.l		; 0F 00 07 00 ; OR accumulator with memory (long) $000700.l [Writes: Accumulator] [Flags: NZ]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora #$00.b		; 09 00 ; Logical OR #$00.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $F60000.l,X		; FF 00 00 F6 ; Subtract with carry (long,X) $F60000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $0DFFFE.l,X		; FF FE FF 0D ; Subtract with carry (long,X) $0DFFFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FCFFFC.l,X		; FF FC FF FC ; Subtract with carry (long,X) $FCFFFC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FEFFFC.l,X		; FF FC FF FE ; Subtract with carry (long,X) $FEFFFC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FEFFFE.l,X		; FF FE FF FE ; Subtract with carry (long,X) $FEFFFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FEFFFE.l,X		; FF FE FF FE ; Subtract with carry (long,X) $FEFFFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FEFFFE.l,X		; FF FE FF FE ; Subtract with carry (long,X) $FEFFFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $08FFFE.l,X		; FF FE FF 08 ; Subtract with carry (long,X) $08FFFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F2.b		; 00 F2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $F0FFFA.l,X		; FF FA FF F0 ; Subtract with carry (long,X) $F0FFFA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $6FFFF8.l,X		; FF F8 FF 6F ; Subtract with carry (long,X) $6FFFF8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $6F7F6F.l,X		; 7F 6F 7F 6F ; Add long $6F7F6F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $6E7F6F.l,X		; 7F 6F 7F 6E ; Add long $6E7F6F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $7E6E.w,X		; 7E 6E 7E ; Rotate right $7E6E.w,X [Reads: X Index] [Flags: NCZ]
	ror $6E7E.w		; 6E 7E 6E ; Rotate right $6E7E.w [Flags: NCZ]
	ror $4040.w,X		; 7E 40 40 ; Rotate right $4040.w,X [Reads: X Index] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $80, $05		; 80 05 ; Branch always to $80, $05 [Flow: branch]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	eor #$01.b		; 49 01 ; Exclusive OR #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$02.b		; 29 02 ; Logical AND #$02.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	lda $0E20.w,X		; BD 20 0E ; Load $0E20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx #$01.b		; A2 01 ; Load #$01.b into X register [Writes: X Index] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $06.b		; 65 06 ; Add $06.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	lda $CCE8.w,X		; BD E8 CC ; Load $CCE8.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $00.b		; 65 00 ; Add $00.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	and #$0100.w		; 29 00 01 ; Logical AND #$0100.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E.b		; 85 0E ; Store accumulator to $0E.b [Reads: Accumulator]
	lda $CD08.w,X		; BD 08 CD ; Load $CD08.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $02.b		; 65 02 ; Add $02.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0010.w		; 69 10 00 ; Add #$0010.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0100.w		; C9 00 01 ; Compare #$0100.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $05		; 90 05 ; Branch if carry clear to $90, $05 [Flow: branch]
	lda #$00F0.w		; A9 F0 00 ; Load #$00F0.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
.ACCU 8
	sep #$20		; E2 20
	lda $CCE8.w,X		; BD E8 CC ; Load $CCE8.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0FAB.w		; 8D AB 0F ; Store accumulator to $0FAB.w [Reads: Accumulator]
	lda $CD08.w,X		; BD 08 CD ; Load $CD08.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0FAA.w		; 8D AA 0F ; Store accumulator to $0FAA.w [Reads: Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda $08.b		; A5 08 ; Load $08.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$48.b		; C9 48 ; Compare #$48.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	lda $CD28.w,X		; BD 28 CD ; Load $CD28.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $90, $02		; 90 02 ; Branch if carry clear to $90, $02 [Flow: branch]
	sbc #$03.b		; E9 03 ; Subtract #$03.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $CD38.w,X		; BD 38 CD ; Load $CD38.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$F1.b		; 29 F1 ; Logical AND #$F1.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$08.b		; 09 08 ; Logical OR #$08.b with accumulator [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $0F.b		; A5 0F ; Load $0F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($92.b),Y		; 91 92 ; Store accumulator ($92.b),Y [Reads: Direct Page, Y Index, Accumulator]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $9A		; 10 9A ; Branch if plus to $10, $9A [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0E70.w,X		; BD 70 0E ; Load $0E70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	jmp $F9ED.w		; 4C ED F9 ; Jump to $F9ED.w [Flow: jump]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tsb $1200.w		; 0C 00 12 ; Test and set bits $1200.w [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	lda $0E00.w,X		; BD 00 0E ; Load $0E00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0C		; F0 0C ; Branch if equal to $F0, $0C [Flow: branch]
	lda $B5CB.w,Y		; B9 CB B5 ; Load $B5CB.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	lda $CDDD.w,Y		; B9 DD CD ; Load $CDDD.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	jsr $D192.w		; 20 92 D1 ; Jump to subroutine at $D192.w [Writes: Stack Pointer] [Flow: call]
	.db $80, $1C		; 80 1C ; Branch always to $80, $1C [Flow: branch]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	lda $0E00.w,X		; BD 00 0E ; Load $0E00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0C		; F0 0C ; Branch if equal to $F0, $0C [Flow: branch]
	lda $B5CB.w,Y		; B9 CB B5 ; Load $B5CB.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	lda $B5CF.w,Y		; B9 CF B5 ; Load $B5CF.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	jsr $D38C.w		; 20 8C D3 ; Jump to subroutine at $D38C.w [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	jsr $AB93.w		; 20 93 AB ; Jump to subroutine at $AB93.w [Writes: Stack Pointer] [Flow: call]
	.db $B0, $05		; B0 05 ; Branch if carry set to $B0, $05 [Flow: branch]
	lda $0FDC.w		; AD DC 0F ; Load $0FDC.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $11		; F0 11 ; Branch if equal to $F0, $11 [Flow: branch]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $0A		; B0 0A ; Branch if carry set to $B0, $0A [Flow: branch]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D80.w,X		; 9D 80 0D ; Store accumulator to $0D80.w,X [Reads: Accumulator, X Index]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda $0EA0.w,X		; BD A0 0E ; Load $0EA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $07		; F0 07 ; Branch if equal to $F0, $07 [Flow: branch]
	cmp #$04.b		; C9 04 ; Compare #$04.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $03		; 90 03 ; Branch if carry clear to $90, $03 [Flow: branch]
	jsr $CF53.w		; 20 53 CF ; Jump to subroutine at $CF53.w [Writes: Stack Pointer] [Flow: call]
	jsr $F971.w		; 20 71 F9 ; Jump to subroutine at $F971.w [Writes: Stack Pointer] [Flow: call]
	jsr $CDD4.w		; 20 D4 CD ; Jump to subroutine at $CDD4.w [Writes: Stack Pointer] [Flow: call]
	jsr $B88D.w		; 20 8D B8 ; Jump to subroutine at $B88D.w [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
.ACCU 16
.INDEX 16
	rep #$30		; C2 30
	and #$00FF.w		; 29 FF 00 ; Logical AND #$00FF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $CE68.w,Y		; B9 68 CE ; Load $CE68.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $CE.b,X		; 74 CE ; Store zero to $CE.b,X [Reads: X Index]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	dec $CF13.w		; CE 13 CF ; Decrement $CF13.w [Flags: NZ]
	mvp $85,$CF		; 44 CF 85 ; Move block positive $85,$CF [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cmp $20D045.l		; CF 45 D0 20 ; Compare accumulator (long) $20D045.l [Reads: Accumulator] [Flags: NCZ]
	sbc $BDC4.w,Y		; F9 C4 BD ; Subtract with carry $BDC4.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $0D		; F0 0D ; Branch if equal to $F0, $0D [Flow: branch]
	.db $D0, $2D		; D0 2D ; Branch if not equal to $D0, $2D [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$7F.b		; 29 7F ; Logical AND #$7F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$50.b		; 69 50 ; Add #$50.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	cmp $0DE0.w,X		; DD E0 0D ; Compare accumulator $0DE0.w,X [Reads: X Index] [Flags: NCZ]
	.db $F0, $0C		; F0 0C ; Branch if equal to $F0, $0C [Flow: branch]
	eor $0DE0.w,X		; 5D E0 0D ; Exclusive OR accumulator with memory $0DE0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$02.b		; 29 02 ; Logical AND #$02.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $05		; D0 05 ; Branch if not equal to $D0, $05 [Flow: branch]
	lda #$0C.b		; A9 0C ; Load #$0C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E00.w,X		; 9D 00 0E ; Store accumulator to $0E00.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0B		; D0 0B ; Branch if not equal to $D0, $0B [Flow: branch]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D80.w,X		; 9D 80 0D ; Store accumulator to $0D80.w,X [Reads: Accumulator, X Index]
	lda #$A0.b		; A9 A0 ; Load #$A0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $C5F2.w		; 20 F2 C5 ; Jump to subroutine at $C5F2.w [Writes: Stack Pointer] [Flow: call]
	lda $0E70.w,X		; BD 70 0E ; Load $0E70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$0F.b		; 29 0F ; Logical AND #$0F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0B		; F0 0B ; Branch if equal to $F0, $0B [Flow: branch]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$01.b		; 49 01 ; Exclusive OR #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	jsr $C32B.w		; 20 2B C3 ; Jump to subroutine at $C32B.w [Writes: Stack Pointer] [Flow: call]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $C331.w,Y		; B9 31 C3 ; Load $C331.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $C335.w,Y		; B9 35 C3 ; Load $C335.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$0F.b		; 29 0F ; Logical AND #$0F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0D		; D0 0D ; Branch if not equal to $D0, $0D [Flow: branch]
	inc $0D90.w,X		; FE 90 0D ; Increment memory $0D90.w,X [Reads: X Index] [Flags: NZ]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	stz $0D90.w,X		; 9E 90 0D ; Store zero to $0D90.w,X [Reads: X Index]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc $0D90.w,X		; 7D 90 0D ; Add $0D90.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy $0E20.w,X		; BC 20 0E ; Load Y register $0E20.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	cpy #$48.b		; C0 48 ; Compare #$48.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$10.b		; 69 10 ; Add #$10.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $C339.w,Y		; B9 39 C3 ; Load $C339.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $C4F9.w		; 20 F9 C4 ; Jump to subroutine at $C4F9.w [Writes: Stack Pointer] [Flow: call]
	jsr $C5F2.w		; 20 F2 C5 ; Jump to subroutine at $C5F2.w [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0B		; D0 0B ; Branch if not equal to $D0, $0B [Flow: branch]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D80.w,X		; 9D 80 0D ; Store accumulator to $0D80.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cmp #$80.b		; C9 80 ; Compare #$80.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $16		; B0 16 ; Branch if carry set to $B0, $16 [Flow: branch]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $C470.w,Y		; B9 70 C4 ; Load $C470.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $C4F9.w		; 20 F9 C4 ; Jump to subroutine at $C4F9.w [Writes: Stack Pointer] [Flow: call]
	jsr $F93F.w		; 20 3F F9 ; Jump to subroutine at $F93F.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0D		; D0 0D ; Branch if not equal to $D0, $0D [Flow: branch]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D80.w,X		; 9D 80 0D ; Store accumulator to $0D80.w,X [Reads: Accumulator, X Index]
	lda #$3C.b		; A9 3C ; Load #$3C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	stz $0E80.w,X		; 9E 80 0E ; Store zero to $0E80.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $B0, $50		; B0 50 ; Branch if carry set to $B0, $50 [Flow: branch]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $B0, $50		; B0 50 ; Branch if carry set to $B0, $50 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc $FF0000.l,X		; FF 00 00 FF ; Subtract with carry (long,X) $FF0000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $00FF00.l,X		; FF 00 FF 00 ; Subtract with carry (long,X) $00FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $B0, $50		; B0 50 ; Branch if carry set to $B0, $50 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $B0, $50		; B0 50 ; Branch if carry set to $B0, $50 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000000.l,X		; FF 00 00 00 ; Subtract with carry (long,X) $000000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $030300.l,X		; FF 00 03 03 ; Subtract with carry (long,X) $030300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $BC0C.w		; 0C 0C BC ; Test and set bits $BC0C.w [Reads: Accumulator] [Flags: Z]
	cpx #$0D.b		; E0 0D ; Compare #$0D.b with X register [Reads: X Index] [Flags: NCZ]
	lda $0E70.w,X		; BD 70 0E ; Load $0E70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $CF81.w,Y		; 39 81 CF ; AND accumulator with memory $CF81.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $05		; D0 05 ; Branch if not equal to $D0, $05 [Flow: branch]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $09		; D0 09 ; Branch if not equal to $D0, $09 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $55		; D0 55 ; Branch if not equal to $D0, $55 [Flow: branch]
	jsr $F93F.w		; 20 3F F9 ; Jump to subroutine at $F93F.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	lda $0E20.w,X		; BD 20 0E ; Load $0E20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$48.b		; C9 48 ; Compare #$48.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $04		; D0 04 ; Branch if not equal to $D0, $04 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	lda $22.b		; A5 22 ; Load $22.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $CF61.w,Y		; 79 61 CF ; Add $CF61.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	lda $23.b		; A5 23 ; Load $23.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $CF69.w,Y		; 79 69 CF ; Add $CF69.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $05.b		; 85 05 ; Store accumulator to $05.b [Reads: Accumulator]
	lda $20.b		; A5 20 ; Load $20.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $CF71.w,Y		; 79 71 CF ; Add $CF71.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	lda $21.b		; A5 21 ; Load $21.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $CF79.w,Y		; 79 79 CF ; Add $CF79.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $07.b		; 85 07 ; Store accumulator to $07.b [Reads: Accumulator]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06EA22.l		; 22 22 EA 06 ; Jump to subroutine long $06EA22.l [Writes: Stack Pointer] [Flow: call]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $0E.b		; A5 0E ; Load $0E.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$06.b		; 69 06 ; Add #$06.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0C.b		; C9 0C ; Compare #$0C.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $09		; B0 09 ; Branch if carry set to $B0, $09 [Flow: branch]
	lda $0F.b		; A5 0F ; Load $0F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$06.b		; 69 06 ; Add #$06.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0C.b		; C9 0C ; Compare #$0C.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $9B		; 90 9B ; Branch if carry clear to $90, $9B [Flow: branch]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	jsr $CEE2.w		; 20 E2 CE ; Jump to subroutine at $CEE2.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $1819.w,Y		; 19 19 18 ; OR accumulator with memory $1819.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$17.b],Y		; 17 17 ; OR accumulator with memory (long indexed) [$17.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora [$17.b],Y		; 17 17 ; OR accumulator with memory (long indexed) [$17.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($13.b,S),Y		; 13 13 ; OR accumulator (stack relative indirect indexed) ($13.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($12.b)		; 12 12 ; OR accumulator with memory (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	ora $0E0E0F.l		; 0F 0F 0E 0E ; OR accumulator with memory (long) $0E0E0F.l [Writes: Accumulator] [Flags: NZ]
	asl $160E.w		; 0E 0E 16 ; Arithmetic shift left $160E.w [Flags: NCZ]
	asl $15.b,X		; 16 15 ; Arithmetic shift left $15.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $14.b,X		; 15 14 ; OR accumulator with memory $14.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	trb $14.b		; 14 14 ; Test and reset bits $14.b [Reads: Accumulator] [Flags: Z]
	trb $14.b		; 14 14 ; Test and reset bits $14.b [Reads: Accumulator] [Flags: Z]
	trb $12.b		; 14 12 ; Test and reset bits $12.b [Reads: Accumulator] [Flags: Z]
	ora ($12.b)		; 12 12 ; OR accumulator with memory (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	.db $10, $15		; 10 15 ; Branch if plus to $10, $15 [Flow: branch]
	ora $08.b,X		; 15 08 ; OR accumulator with memory $08.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	asl $16.b		; 06 16 ; Arithmetic shift left $16.b [Reads: Direct Page] [Flags: NCZ]
	asl $04.b,X		; 16 04 ; Arithmetic shift left $04.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $17.b,S		; 03 17 ; OR accumulator with stack relative $17.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$0F.b],Y		; 17 0F ; OR accumulator with memory (long indexed) [$0F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $0B0B0F.l		; 0F 0F 0B 0B ; OR accumulator with memory (long) $0B0B0F.l [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $0C0D.w		; 0D 0D 0C ; Logical OR $0C0D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $E0BC.w		; 0C BC E0 ; Test and set bits $E0BC.w [Reads: Accumulator] [Flags: Z]
	ora $41B9.w		; 0D B9 41 ; Logical OR $41B9.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $9D		; D0 9D ; Branch if not equal to $D0, $9D [Flow: branch]
	cpy #$0E.b		; C0 0E ; Compare #$0E.b with Y register [Reads: Y Index] [Flags: NCZ]
	jsr $C4F9.w		; 20 F9 C4 ; Jump to subroutine at $C4F9.w [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	jmp $C417.w		; 4C 17 C4 ; Jump to $C417.w [Flow: jump]
	stz $0E80.w,X		; 9E 80 0E ; Store zero to $0E80.w,X [Reads: X Index]
	cmp #$28.b		; C9 28 ; Compare #$28.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $03		; 90 03 ; Branch if carry clear to $90, $03 [Flow: branch]
	dec $0E80.w,X		; DE 80 0E ; Decrement memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	cmp #$0C.b		; C9 0C ; Compare #$0C.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $05		; D0 05 ; Branch if not equal to $D0, $05 [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	jsr $D0C5.w		; 20 C5 D0 ; Jump to subroutine at $D0C5.w [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy $0E20.w,X		; BC 20 0E ; Load Y register $0E20.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	cpy #$48.b		; C0 48 ; Compare #$48.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$20.b		; 69 20 ; Add #$20.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $D001.w,Y		; B9 01 D0 ; Load $D001.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $10, $F8		; 10 F8 ; Branch if plus to $10, $F8 [Flow: branch]
	ora $0B.b,S		; 03 0B ; OR accumulator with stack relative $0B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $0CFC.w		; 0C FC 0C ; Test and set bits $0CFC.w [Reads: Accumulator] [Flags: Z]
	jsr ($FF00.w,X)		; FC 00 FF ; Jump to subroutine indirect indexed ($FF00.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $F8		; 10 F8 ; Branch if plus to $10, $F8 [Flow: branch]
	inc $02FE.w,X		; FE FE 02 ; Increment memory $02FE.w,X [Reads: X Index] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FF00FF.l,X		; FF FF 00 FF ; Subtract with carry (long,X) $FF00FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $D0		; 30 D0 ; Branch if minus to $30, $D0 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $00E0.w		; 20 E0 00 ; Jump to subroutine at $00E0.w [Writes: Stack Pointer] [Flow: call]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $D0, $00		; D0 00 ; Branch if not equal to $D0, $00 [Flow: branch]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$03.b		; E0 03 ; Compare #$03.b with X register [Reads: X Index] [Flags: NCZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $A9.b		; 06 A9 ; Arithmetic shift left $A9.b [Reads: Direct Page] [Flags: NCZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $73		; 30 73 ; Branch if minus to $30, $73 [Flow: branch]
	lda #$05.b		; A9 05 ; Load #$05.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB8A.l		; 22 8A BB 0D ; Jump to subroutine long $0DBB8A.l [Writes: Stack Pointer] [Flow: call]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	lda $0E20.w,X		; BD 20 0E ; Load $0E20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$48.b		; C9 48 ; Compare #$48.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $90, $03		; 90 03 ; Branch if carry clear to $90, $03 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$04.b		; 69 04 ; Add #$04.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $D08B.w,X		; 7D 8B D0 ; Add $D08B.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,Y		; 99 10 0D ; Store accumulator to $0D10.w,Y [Reads: Y Index, Accumulator]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $D093.w,X		; 7D 93 D0 ; Add $D093.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D30.w,Y		; 99 30 0D ; Store accumulator to $0D30.w,Y [Reads: Y Index, Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $D09B.w,X		; 7D 9B D0 ; Add $D09B.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,Y		; 99 00 0D ; Store accumulator to $0D00.w,Y [Reads: Y Index, Accumulator]
	lda $03.b		; A5 03 ; Load $03.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $D0A3.w,X		; 7D A3 D0 ; Add $D0A3.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D20.w,Y		; 99 20 0D ; Store accumulator to $0D20.w,Y [Reads: Y Index, Accumulator]
	lda $D0AB.w,X		; BD AB D0 ; Load $D0AB.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,Y		; 99 50 0D ; Store accumulator to $0D50.w,Y [Reads: Y Index, Accumulator]
	lda $D0B1.w,X		; BD B1 D0 ; Load $D0B1.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,Y		; 99 40 0D ; Store accumulator to $0D40.w,Y [Reads: Y Index, Accumulator]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,Y		; 99 E0 0D ; Store accumulator to $0DE0.w,Y [Reads: Y Index, Accumulator]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $D0C1.w,X		; BD C1 D0 ; Load $D0C1.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0F60.w,Y		; 99 60 0F ; Store accumulator to $0F60.w,Y [Reads: Y Index, Accumulator]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F70.w,Y		; 99 70 0F ; Store accumulator to $0F70.w,Y [Reads: Y Index, Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda $0E20.w,X		; BD 20 0E ; Load $0E20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$48.b		; C9 48 ; Compare #$48.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $90, $01		; 90 01 ; Branch if carry clear to $90, $01 [Flow: branch]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0D90.w,Y		; 99 90 0D ; Store accumulator to $0D90.w,Y [Reads: Y Index, Accumulator]
	.db $F0, $0E		; F0 0E ; Branch if equal to $F0, $0E [Flow: branch]
	lda $7EF35A.l		; AF 5A F3 7E ; Load long $7EF35A.l into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	lda $0BE0.w,Y		; B9 E0 0B ; Load $0BE0.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and #$DF.b		; 29 DF ; Logical AND #$DF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0BE0.w,Y		; 99 E0 0B ; Store accumulator to $0BE0.w,Y [Reads: Y Index, Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	stz $0DC0.w,X		; 9E C0 0D ; Store zero to $0DC0.w,X [Reads: X Index]
	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	and #$F1.b		; 29 F1 ; Logical AND #$F1.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$02.b		; 09 02 ; Logical OR #$02.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
.ACCU 16
	rep #$20		; C2 20
	lda $0FDA.w		; AD DA 0F ; Load $0FDA.w into accumulator [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0008.w		; 69 08 00 ; Add #$0008.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0FDA.w		; 8D DA 0F ; Store accumulator to $0FDA.w [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	jsl $06DBF0.l		; 22 F0 DB 06 ; Jump to subroutine long $06DBF0.l [Writes: Stack Pointer] [Flow: call]
.ACCU 16
	rep #$20		; C2 20
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $0FDA.w		; 8D DA 0F ; Store accumulator to $0FDA.w [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	jsr $FA50.w		; 20 50 FA ; Jump to subroutine at $FA50.w [Writes: Stack Pointer] [Flow: call]
	ldy #$10.b		; A0 10 ; Load #$10.b into Y register [Writes: Y Index] [Flags: NZ]
	jsr $C6E0.w		; 20 E0 C6 ; Jump to subroutine at $C6E0.w [Writes: Stack Pointer] [Flow: call]
	ldy #$0C.b		; A0 0C ; Load #$0C.b into Y register [Writes: Y Index] [Flags: NZ]
	jsr $B3CD.w		; 20 CD B3 ; Jump to subroutine at $B3CD.w [Writes: Stack Pointer] [Flow: call]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$14.b		; C9 14 ; Compare #$14.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $05		; B0 05 ; Branch if carry set to $B0, $05 [Flow: branch]
	ldy #$04.b		; A0 04 ; Load #$04.b into Y register [Writes: Y Index] [Flags: NZ]
	jsr $CD4A.w		; 20 4A CD ; Jump to subroutine at $CD4A.w [Writes: Stack Pointer] [Flow: call]
	jmp $C68C.w		; 4C 8C C6 ; Jump to $C68C.w [Flow: jump]
	jsr $FA50.w		; 20 50 FA ; Jump to subroutine at $FA50.w [Writes: Stack Pointer] [Flow: call]
	ldy #$0C.b		; A0 0C ; Load #$0C.b into Y register [Writes: Y Index] [Flags: NZ]
	jsr $B160.w		; 20 60 B1 ; Jump to subroutine at $B160.w [Writes: Stack Pointer] [Flow: call]
	ldy #$08.b		; A0 08 ; Load #$08.b into Y register [Writes: Y Index] [Flags: NZ]
	jsr $B3CD.w		; 20 CD B3 ; Jump to subroutine at $B3CD.w [Writes: Stack Pointer] [Flow: call]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$14.b		; C9 14 ; Compare #$14.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $03		; B0 03 ; Branch if carry set to $B0, $03 [Flow: branch]
	jsr $CD48.w		; 20 48 CD ; Jump to subroutine at $CD48.w [Writes: Stack Pointer] [Flow: call]
	jmp $C68C.w		; 4C 8C C6 ; Jump to $C68C.w [Flow: jump]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0C		; F0 0C ; Branch if equal to $F0, $0C [Flow: branch]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $05		; D0 05 ; Branch if not equal to $D0, $05 [Flow: branch]
	jsr $D141.w		; 20 41 D1 ; Jump to subroutine at $D141.w [Writes: Stack Pointer] [Flow: call]
	.db $80, $03		; 80 03 ; Branch always to $80, $03 [Flow: branch]
	jsr $D321.w		; 20 21 D3 ; Jump to subroutine at $D321.w [Writes: Stack Pointer] [Flow: call]
	.db $80, $14		; 80 14 ; Branch always to $80, $14 [Flow: branch]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0F		; F0 0F ; Branch if equal to $F0, $0F [Flow: branch]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$0E.b		; C9 0E ; Compare #$0E.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $05		; 90 05 ; Branch if carry clear to $90, $05 [Flow: branch]
	jsr $D38C.w		; 20 8C D3 ; Jump to subroutine at $D38C.w [Writes: Stack Pointer] [Flow: call]
	.db $80, $03		; 80 03 ; Branch always to $80, $03 [Flow: branch]
	jsr $D321.w		; 20 21 D3 ; Jump to subroutine at $D321.w [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0BA0.w,X		; 9D A0 0B ; Store accumulator to $0BA0.w,X [Reads: Accumulator, X Index]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
.ACCU 16
.INDEX 16
	rep #$30		; C2 30
	and #$00FF.w		; 29 FF 00 ; Logical AND #$00FF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $D1ED.w,Y		; B9 ED D1 ; Load $D1ED.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $D1.b,X		; F5 D1 ; Subtract $D1.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $D2.b,S		; 23 D2 ; AND accumulator with stack relative $D2.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc [$D2.b],Y		; 77 D2 ; Add with carry (long indexed) [$D2.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $BDD2.w		; CE D2 BD ; Decrement $BDD2.w [Flags: NZ]
	.db $F0, $0D		; F0 0D ; Branch if equal to $F0, $0D [Flow: branch]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$40.b		; A9 40 ; Load #$40.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $06F2AA.l		; 22 AA F2 06 ; Jump to subroutine long $06F2AA.l [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $13		; D0 13 ; Branch if not equal to $D0, $13 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$30.b		; A9 30 ; Load #$30.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	jsr $F93F.w		; 20 3F F9 ; Jump to subroutine at $F93F.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cmp #$20.b		; C9 20 ; Compare #$20.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $05		; D0 05 ; Branch if not equal to $D0, $05 [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	jsr $D252.w		; 20 52 D2 ; Jump to subroutine at $D252.w [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $D203.w,Y		; B9 03 D2 ; Load $D203.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$EC.b		; A9 EC ; Load #$EC.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $1C		; 30 1C ; Branch if minus to $30, $1C [Flow: branch]
	jsl $09AE64.l		; 22 64 AE 09 ; Jump to subroutine long $09AE64.l [Writes: Stack Pointer] [Flow: call]
	lda #$06.b		; A9 06 ; Load #$06.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DD0.w,Y		; 99 D0 0D ; Store accumulator to $0DD0.w,Y [Reads: Y Index, Accumulator]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,Y		; 99 F0 0D ; Store accumulator to $0DF0.w,Y [Reads: Y Index, Accumulator]
	lda $0E40.w,Y		; B9 40 0E ; Load $0E40.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$03.b		; 69 03 ; Add #$03.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0E40.w,Y		; 99 40 0E ; Store accumulator to $0E40.w,Y [Reads: Y Index, Accumulator]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DB0.w,Y		; 99 B0 0D ; Store accumulator to $0DB0.w,Y [Reads: Y Index, Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $0BA0.w,X		; 9E A0 0B ; Store zero to $0BA0.w,X [Reads: X Index]
	jsr $AB93.w		; 20 93 AB ; Jump to subroutine at $AB93.w [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0A		; D0 0A ; Branch if not equal to $D0, $0A [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$30.b		; A9 30 ; Load #$30.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	.db $80, $42		; 80 42 ; Branch always to $80, $42 [Flow: branch]
	stz $0D90.w,X		; 9E 90 0D ; Store zero to $0D90.w,X [Reads: X Index]
	cmp #$28.b		; C9 28 ; Compare #$28.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $03		; B0 03 ; Branch if carry set to $B0, $03 [Flow: branch]
	dec $0D90.w,X		; DE 90 0D ; Decrement memory $0D90.w,X [Reads: X Index] [Flags: NZ]
	cmp #$10.b		; C9 10 ; Compare #$10.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $05		; D0 05 ; Branch if not equal to $D0, $05 [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	jsr $D0C5.w		; 20 C5 D0 ; Jump to subroutine at $D0C5.w [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy $0E20.w,X		; BC 20 0E ; Load Y register $0E20.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	cpy #$49.b		; C0 49 ; Compare #$49.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$20.b		; 69 20 ; Add #$20.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $D001.w,Y		; B9 01 D0 ; Load $D001.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	jsr $AB93.w		; 20 93 AB ; Jump to subroutine at $AB93.w [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $09		; D0 09 ; Branch if not equal to $D0, $09 [Flow: branch]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	lda #$40.b		; A9 40 ; Load #$40.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $D2BE.w,Y		; B9 BE D2 ; Load $D2BE.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FD0008.l,X		; FF 08 00 FD ; Subtract with carry (long,X) $FD0008.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FD0008.l,X		; FF 08 00 FD ; Subtract with carry (long,X) $FD0008.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $200008.l,X		; FF 08 00 20 ; Subtract with carry (long,X) $200008.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr $2020.w		; 20 20 20 ; Jump to subroutine at $2020.w [Writes: Stack Pointer] [Flow: call]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	jsr $2040.w		; 20 40 20 ; Jump to subroutine at $2040.w [Writes: Stack Pointer] [Flow: call]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	jsr $2042.w		; 20 42 20 ; Jump to subroutine at $2042.w [Writes: Stack Pointer] [Flow: call]
	.db $42, $20		; 42 20 ; Reserved instruction
	ora #$03.b		; 09 03 ; Logical OR #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	eor #$43.b		; 49 43 ; Exclusive OR #$43.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$03.b		; 09 03 ; Logical OR #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	eor #$43.b		; 49 43 ; Exclusive OR #$43.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$03.b		; 09 03 ; Logical OR #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	eor #$43.b		; 49 43 ; Exclusive OR #$43.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$03.b		; 09 03 ; Logical OR #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $FA50.w		; 20 50 FA ; Jump to subroutine at $FA50.w [Writes: Stack Pointer] [Flow: call]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx #$01.b		; A2 01 ; Load #$01.b into X register [Writes: X Index] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $06.b		; 65 06 ; Add $06.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	and #$0100.w		; 29 00 01 ; Logical AND #$0100.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E.b		; 85 0E ; Store accumulator to $0E.b [Reads: Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $D2E9.w,X		; 7D E9 D2 ; Add $D2E9.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0010.w		; 69 10 00 ; Add #$0010.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0100.w		; C9 00 01 ; Compare #$0100.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $05		; 90 05 ; Branch if carry clear to $90, $05 [Flow: branch]
	lda #$00F0.w		; A9 F0 00 ; Load #$00F0.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
.ACCU 8
	sep #$20		; E2 20
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda $D305.w,X		; BD 05 D3 ; Load $D305.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $D313.w,X		; BD 13 D3 ; Load $D313.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$20.b		; 09 20 ; Logical OR #$20.b with accumulator [Writes: Accumulator] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	.db $D0, $04		; D0 04 ; Branch if not equal to $D0, $04 [Flow: branch]
	and #$F1.b		; 29 F1 ; Logical AND #$F1.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0F.b		; 05 0F ; Logical OR $0F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($92.b),Y		; 91 92 ; Store accumulator ($92.b),Y [Reads: Direct Page, Y Index, Accumulator]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $AE		; 10 AE ; Branch if plus to $10, $AE [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $14.b		; 14 14 ; Test and reset bits $14.b [Reads: Accumulator] [Flags: Z]
	tsb $20.b		; 04 20 ; Test and set bits $20.b [Reads: Accumulator] [Flags: Z]
	.db $50, $FA		; 50 FA ; Branch if overflow clear to $50, $FA [Flow: branch]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $D384.w,Y		; B9 84 D3 ; Load $D384.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	jsr $C6E0.w		; 20 E0 C6 ; Jump to subroutine at $C6E0.w [Writes: Stack Pointer] [Flow: call]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $D388.w,Y		; B9 88 D3 ; Load $D388.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	jsr $CA10.w		; 20 10 CA ; Jump to subroutine at $CA10.w [Writes: Stack Pointer] [Flow: call]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $D381.w,Y		; B9 81 D3 ; Load $D381.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	jsr $D4D4.w		; 20 D4 D4 ; Jump to subroutine at $D4D4.w [Writes: Stack Pointer] [Flow: call]
	jmp $C68C.w		; 4C 8C C6 ; Jump to $C68C.w [Flow: jump]
	sbc $0007FF.l,X		; FF FF 07 00 ; Subtract with carry (long,X) $0007FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $0007FF.l,X		; FF FF 07 00 ; Subtract with carry (long,X) $0007FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $0007FF.l,X		; FF FF 07 00 ; Subtract with carry (long,X) $0007FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc $F6FFFB.l,X		; FF FB FF F6 ; Subtract with carry (long,X) $F6FFFB.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FCFFFE.l,X		; FF FE FF FC ; Subtract with carry (long,X) $FCFFFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FAFFFC.l,X		; FF FC FF FA ; Subtract with carry (long,X) $FAFFFC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FB0002.l,X		; FF 02 00 FB ; Subtract with carry (long,X) $FB0002.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FBFFFB.l,X		; FF FB FF FB ; Subtract with carry (long,X) $FBFFFB.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $06FFFB.l,X		; FF FB FF 06 ; Subtract with carry (long,X) $06FFFB.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $020006.l,X		; FF 06 00 02 ; Subtract with carry (long,X) $020006.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $020006.l,X		; FF 06 00 02 ; Subtract with carry (long,X) $020006.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $060006.l,X		; FF 06 00 06 ; Subtract with carry (long,X) $060006.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $F4FFFA.l,X		; FF FA FF F4 ; Subtract with carry (long,X) $F4FFFA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FAFFFC.l,X		; FF FC FF FA ; Subtract with carry (long,X) $FAFFFC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F7FFFA.l,X		; FF FA FF F7 ; Subtract with carry (long,X) $F7FFFA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FAFFFF.l,X		; FF FF FF FA ; Subtract with carry (long,X) $FAFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FAFFFA.l,X		; FF FA FF FA ; Subtract with carry (long,X) $FAFFFA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FEFFFA.l,X		; FF FA FF FE ; Subtract with carry (long,X) $FEFFFA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $020006.l,X		; FF 06 00 02 ; Subtract with carry (long,X) $020006.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $020006.l,X		; FF 06 00 02 ; Subtract with carry (long,X) $020006.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $060006.l,X		; FF 06 00 06 ; Subtract with carry (long,X) $060006.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	and $1B3A.w,X		; 3D 3A 1B ; AND accumulator with memory $1B3A.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	and $0B3A.w,X		; 3D 3A 0B ; AND accumulator with memory $0B3A.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	and $1B3A.w,X		; 3D 3A 1B ; AND accumulator with memory $1B3A.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	and $0B3A.w,X		; 3D 3A 0B ; AND accumulator with memory $0B3A.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $084D.w		; 0D 4D 08 ; Logical OR $084D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $084D.w		; 0D 4D 08 ; Logical OR $084D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $4D4D.w		; 0D 4D 4D ; Logical OR $4D4D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	eor $8D0D.w		; 4D 0D 8D ; Exclusive OR $8D0D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	ora $488D.w		; 0D 8D 48 ; Logical OR $488D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	ora $8D8D.w		; 0D 8D 8D ; Logical OR $8D8D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $CD8D.w		; 8D 8D CD ; Store accumulator to $CD8D.w [Reads: Accumulator]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta $88CD.w		; 8D CD 88 ; Store accumulator to $88CD.w [Reads: Accumulator]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta $CDCD.w		; 8D CD CD ; Store accumulator to $CDCD.w [Reads: Accumulator]
	cmp $CD4D.w		; CD 4D CD ; Compare $CD4D.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	eor $08CD.w		; 4D CD 08 ; Exclusive OR $08CD.w with accumulator [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	eor $CDCD.w		; 4D CD CD ; Exclusive OR $CDCD.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp $0309.w		; CD 09 03 ; Compare $0309.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$0E.b		; E9 0E ; Subtract #$0E.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	.db $B0, $08		; B0 08 ; Branch if carry set to $B0, $08 [Flow: branch]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $D4D0.w,Y		; B9 D0 D4 ; Load $D4D0.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx #$03.b		; A2 03 ; Load #$03.b into X register [Writes: X Index] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $06.b		; 65 06 ; Add $06.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $D3B0.w,X		; 7D B0 D3 ; Add $D3B0.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	and #$0100.w		; 29 00 01 ; Logical AND #$0100.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E.b		; 85 0E ; Store accumulator to $0E.b [Reads: Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $D410.w,X		; 7D 10 D4 ; Add $D410.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0010.w		; 69 10 00 ; Add #$0010.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0100.w		; C9 00 01 ; Compare #$0100.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $05		; 90 05 ; Branch if carry clear to $90, $05 [Flow: branch]
	lda #$00F0.w		; A9 F0 00 ; Load #$00F0.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
.ACCU 8
	sep #$20		; E2 20
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda $D470.w,X		; BD 70 D4 ; Load $D470.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $D4A0.w,X		; BD A0 D4 ; Load $D4A0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$20.b		; 09 20 ; Logical OR #$20.b with accumulator [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $0F.b		; A5 0F ; Load $0F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($92.b),Y		; 91 92 ; Store accumulator ($92.b),Y [Reads: Direct Page, Y Index, Accumulator]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $B2		; 10 B2 ; Branch if plus to $10, $B2 [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $D54C.w		; 20 4C D5 ; Jump to subroutine at $D54C.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $1DF063.l		; 22 63 F0 1D ; Jump to subroutine long $1DF063.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $0E20.w,X		; BD 20 0E ; Load $0E20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$40.b		; C9 40 ; Compare #$40.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	lda $0E00.w,X		; BD 00 0E ; Load $0E00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $06		; F0 06 ; Branch if equal to $F0, $06 [Flow: branch]
	lda $B5CB.w,Y		; B9 CB B5 ; Load $B5CB.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $D548.w,Y		; B9 48 D5 ; Load $D548.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	jsr $D64B.w		; 20 4B D6 ; Jump to subroutine at $D64B.w [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	jsl $06F2AA.l		; 22 AA F2 06 ; Jump to subroutine long $06F2AA.l [Writes: Stack Pointer] [Flow: call]
	lda $040A.w		; AD 0A 04 ; Load $040A.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$1B.b		; C9 1B ; Compare #$1B.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $17		; D0 17 ; Branch if not equal to $D0, $17 [Flow: branch]
	lda #$B2.b		; A9 B2 ; Load #$B2.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy $0D00.w,X		; BC 00 0D ; Load Y register $0D00.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	cpy #$50.b		; C0 50 ; Compare #$50.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $F0, $06		; F0 06 ; Branch if equal to $F0, $06 [Flow: branch]
	lda #$B3.b		; A9 B3 ; Load #$B3.b into accumulator [Writes: Accumulator] [Flags: NZ]
	cpy #$90.b		; C0 90 ; Compare #$90.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05FA59.l		; 22 59 FA 05 ; Jump to subroutine long $05FA59.l [Writes: Stack Pointer] [Flow: call]
	.db $80, $1A		; 80 1A ; Branch always to $80, $1A [Flow: branch]
	lda $0B69.w		; AD 69 0B ; Load $0B69.w into accumulator [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0F.b		; 69 0F ; Add #$0F.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05FA59.l		; 22 59 FA 05 ; Jump to subroutine long $05FA59.l [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	.db $90, $07		; 90 07 ; Branch if carry clear to $90, $07 [Flow: branch]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cmp #$07.b		; C9 07 ; Compare #$07.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $02		; D0 02 ; Branch if not equal to $D0, $02 [Flow: branch]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0B69.w		; 8D 69 0B ; Store accumulator to $0B69.w [Reads: Accumulator]
	jsr $AB93.w		; 20 93 AB ; Jump to subroutine at $AB93.w [Writes: Stack Pointer] [Flow: call]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$1F.b		; 29 1F ; Logical AND #$1F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	jsr $AC34.w		; 20 34 AC ; Jump to subroutine at $AC34.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	sbc $02FFFA.l,X		; FF FA FF 02 ; Subtract with carry (long,X) $02FFFA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F9.b		; 00 F9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $F9FFF9.l,X		; FF F9 FF F9 ; Subtract with carry (long,X) $F9FFF9.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $000000.l,X		; FF 00 00 00 ; Subtract with carry (long,X) $000000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000004.l,X		; FF 04 00 00 ; Subtract with carry (long,X) $000004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F6.b		; 00 F6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0CFFFC.l,X		; FF FC FF 0C ; Subtract with carry (long,X) $0CFFFC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FDFFF5.l,X		; FF F5 FF FD ; Subtract with carry (long,X) $FDFFF5.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $000005.l,X		; FF 05 00 00 ; Subtract with carry (long,X) $000005.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FDFFF5.l,X		; FF F5 FF FD ; Subtract with carry (long,X) $FDFFF5.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F50005.l,X		; FF 05 00 F5 ; Subtract with carry (long,X) $F50005.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $000005.l,X		; FF 05 00 00 ; Subtract with carry (long,X) $000005.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $004046.l,X		; FF 46 40 00 ; Subtract with carry (long,X) $004046.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	and #$4E.b		; 29 4E ; Logical AND #$4E.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $42, $39		; 42 39 ; Reserved instruction
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lsr $3942.w		; 4E 42 39 ; Logical shift right $3942.w [Flags: NCZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	rol $38.b		; 26 38 ; Rotate left $38.b [Reads: Direct Page] [Flags: NCZ]
	stz $64.b		; 64 64 ; Store zero to $64.b
	mvp $00,$40		; 44 40 00 ; Move block positive $00,$40 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $20.b		; 02 20 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $50, $FA		; 50 FA ; Branch if overflow clear to $50, $FA [Flow: branch]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc $0DC0.w,X		; 7D C0 0D ; Add $0DC0.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx #$04.b		; A2 04 ; Load #$04.b into X register [Writes: X Index] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $06.b		; 65 06 ; Add $06.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	lda $D5BF.w,X		; BD BF D5 ; Load $D5BF.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $00.b		; 65 00 ; Add $00.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	and #$0100.w		; 29 00 01 ; Logical AND #$0100.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E.b		; 85 0E ; Store accumulator to $0E.b [Reads: Accumulator]
	lda $D5E7.w,X		; BD E7 D5 ; Load $D5E7.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $02.b		; 65 02 ; Add $02.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0010.w		; 69 10 00 ; Add #$0010.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0100.w		; C9 00 01 ; Compare #$0100.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $05		; 90 05 ; Branch if carry clear to $90, $05 [Flow: branch]
	lda #$00F0.w		; A9 F0 00 ; Load #$00F0.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
.ACCU 8
	sep #$20		; E2 20
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda $D60F.w,X		; BD 0F D6 ; Load $D60F.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	cmp #$40.b		; C9 40 ; Compare #$40.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	lda $D623.w,X		; BD 23 D6 ; Load $D623.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $04		; B0 04 ; Branch if carry set to $B0, $04 [Flow: branch]
	and #$F1.b		; 29 F1 ; Logical AND #$F1.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$08.b		; 09 08 ; Logical OR #$08.b with accumulator [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $D637.w,X		; BD 37 D6 ; Load $D637.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $0F.b		; 05 0F ; Logical OR $0F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($92.b),Y		; 91 92 ; Store accumulator ($92.b),Y [Reads: Direct Page, Y Index, Accumulator]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $A7		; 10 A7 ; Branch if plus to $10, $A7 [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda #$0C.b		; A9 0C ; Load #$0C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06DC5C.l		; 22 5C DC 06 ; Jump to subroutine long $06DC5C.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	lda $0E20.w,X		; BD 20 0E ; Load $0E20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$07.b		; C9 07 ; Compare #$07.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	cmp #$05.b		; C9 05 ; Compare #$05.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $05		; D0 05 ; Branch if not equal to $D0, $05 [Flow: branch]
	jsr $D6D4.w		; 20 D4 D6 ; Jump to subroutine at $D6D4.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $D8B5.w		; 20 B5 D8 ; Jump to subroutine at $D8B5.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $D743.w		; 20 43 D7 ; Jump to subroutine at $D743.w [Writes: Stack Pointer] [Flow: call]
	ldy $0DC0.w,X		; BC C0 0D ; Load Y register $0DC0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	.db $F0, $44		; F0 44 ; Branch if equal to $F0, $44 [Flow: branch]
	cpy #$0B.b		; C0 0B ; Compare #$0B.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $F0, $40		; F0 40 ; Branch if equal to $F0, $40 [Flow: branch]
	lda $D738.w,Y		; B9 38 D7 ; Load $D738.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0377.w		; 8D 77 03 ; Store accumulator to $0377.w [Reads: Accumulator]
	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$13.b		; E9 13 ; Subtract #$13.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $20.b		; 85 20 ; Store accumulator to $20.b [Reads: Accumulator]
	lda $0D20.w,X		; BD 20 0D ; Load $0D20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc #$00.b		; E9 00 ; Subtract #$00.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $21.b		; 85 21 ; Store accumulator to $21.b [Reads: Accumulator]
	lda $0D10.w,X		; BD 10 0D ; Load $0D10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $22.b		; 85 22 ; Store accumulator to $22.b [Reads: Accumulator]
	lda $0D30.w,X		; BD 30 0D ; Load $0D30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $23.b		; 85 23 ; Store accumulator to $23.b [Reads: Accumulator]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $1C		; D0 1C ; Branch if not equal to $D0, $1C [Flow: branch]
	inc $0DC0.w,X		; FE C0 0D ; Increment memory $0DC0.w,X [Reads: X Index] [Flags: NZ]
	ldy $0DC0.w,X		; BC C0 0D ; Load Y register $0DC0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	cpy #$0B.b		; C0 0B ; Compare #$0B.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $D0, $0A		; D0 0A ; Branch if not equal to $D0, $0A [Flow: branch]
	lda #$1B.b		; A9 1B ; Load #$1B.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012F.w		; 8D 2F 01 ; Store accumulator to $012F.w [Reads: Accumulator]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0642.w		; 8D 42 06 ; Store accumulator to $0642.w [Reads: Accumulator]
	lda $D72D.w,Y		; B9 2D D7 ; Load $D72D.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	lda $0E20.w,X		; BD 20 0E ; Load $0E20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$07.b		; C9 07 ; Compare #$07.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	jsr $D7F9.w		; 20 F9 D7 ; Jump to subroutine at $D7F9.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $D858.w		; 20 58 D8 ; Jump to subroutine at $D858.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	cop $0A.b		; 02 0A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora #$09.b		; 09 09 ; Logical OR #$09.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$22.b		; 09 22 ; Logical OR #$22.b with accumulator [Writes: Accumulator] [Flags: NZ]
	and #$F1.b		; [PATTERN: Memory clearing operation] 29 F1 ; Logical AND #$F1.b with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $90.b		; 06 90 ; Arithmetic shift left $90.b [Reads: Direct Page] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	stz $27.b		; 64 27 ; Store zero to $27.b
	stz $28.b		; 64 28 ; Store zero to $28.b
	jsl $079291.l		; 22 91 92 07 ; Jump to subroutine long $079291.l [Writes: Stack Pointer] [Flow: call]
	stz $48.b		; 64 48 ; Store zero to $48.b
	lda $0020.w		; AD 20 00 ; Load $0020.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $0D00.w,X		; FD 00 0D ; Subtract with carry $0D00.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $10, $5C		; 10 5C ; Branch if plus to $10, $5C [Flow: branch]
	cmp #$F4.b		; C9 F4 ; Compare #$F4.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $30, $28		; 30 28 ; Branch if minus to $30, $28 [Flow: branch]
	lda $0022.w		; AD 22 00 ; Load $0022.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp $0D10.w,X		; DD 10 0D ; Compare accumulator $0D10.w,X [Reads: X Index] [Flags: NCZ]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	lda $0D10.w,X		; BD 10 0D ; Load $0D10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$10.b		; E9 10 ; Subtract #$10.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $22.b		; 85 22 ; Store accumulator to $22.b [Reads: Accumulator]
	lda $0D30.w,X		; BD 30 0D ; Load $0D30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc #$00.b		; E9 00 ; Subtract #$00.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $23.b		; 85 23 ; Store accumulator to $23.b [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0D10.w,X		; BD 10 0D ; Load $0D10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0E.b		; 69 0E ; Add #$0E.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $22.b		; 85 22 ; Store accumulator to $22.b [Reads: Accumulator]
	lda $0D30.w,X		; BD 30 0D ; Load $0D30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $23.b		; 85 23 ; Store accumulator to $23.b [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	inc $0379.w		; EE 79 03 ; Increment $0379.w [Flags: NZ]
	lda $F2.b		; A5 F2 ; Load $F2.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $19		; 10 19 ; Branch if plus to $10, $19 [Flow: branch]
	lda $F0.b		; A5 F0 ; Load $F0.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $13		; D0 13 ; Branch if not equal to $D0, $13 [Flow: branch]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0E		; D0 0E ; Branch if not equal to $D0, $0E [Flow: branch]
	inc $0DC0.w,X		; FE C0 0D ; Increment memory $0DC0.w,X [Reads: X Index] [Flags: NZ]
	lda #$08.b		; A9 08 ; Load #$08.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda #$22.b		; A9 22 ; Load #$22.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB7C.l		; 22 7C BB 0D ; Jump to subroutine long $0DBB7C.l [Writes: Stack Pointer] [Flow: call]
	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$15.b		; E9 15 ; Subtract #$15.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $20.b		; 85 20 ; Store accumulator to $20.b [Reads: Accumulator]
	lda $0D20.w,X		; BD 20 0D ; Load $0D20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc #$00.b		; E9 00 ; Subtract #$00.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $21.b		; 85 21 ; Store accumulator to $21.b [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$09.b		; 69 09 ; Add #$09.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $20.b		; 85 20 ; Store accumulator to $20.b [Reads: Accumulator]
	lda $0D20.w,X		; BD 20 0D ; Load $0D20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $21.b		; 85 21 ; Store accumulator to $21.b [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr ($000C.w,X)		; FC 0C 00 ; Jump to subroutine indirect indexed ($000C.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr ($0404.w,X)		; FC 04 04 ; Jump to subroutine indirect indexed ($0404.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $00FD.w,X		; FD FD 00 ; Subtract with carry $00FD.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $D2.b		; 05 D2 ; Logical OR $D2.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp ($C4.b)		; D2 C4 ; Compare accumulator (indirect) ($C4.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cpx $E4.b		; E4 E4 ; Compare $E4.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	cpx $40.b		; E4 40 ; Compare $40.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $20.b		; 05 20 ; Logical OR $20.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $50, $FA		; 50 FA ; Branch if overflow clear to $50, $FA [Flow: branch]
	jsl $06F864.l		; 22 64 F8 06 ; Jump to subroutine long $06F864.l [Writes: Stack Pointer] [Flow: call]
	ldy $0DC0.w,X		; BC C0 0D ; Load Y register $0DC0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $D7ED.w,Y		; B9 ED D7 ; Load $D7ED.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $D7E6.w,Y		; B9 E6 D7 ; Load $D7E6.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx #$04.b		; A2 04 ; Load #$04.b into X register [Writes: X Index] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $D7CA.w,X		; 7D CA D7 ; Add $D7CA.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $D7D0.w,X		; 7D D0 D7 ; Add $D7D0.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $D7D6.w,X		; BD D6 D7 ; Load $D7D6.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $D7DC.w,X		; BD DC D7 ; Load $D7DC.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$21.b		; 09 21 ; Logical OR #$21.b with accumulator [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	cpx #$02.b		; E0 02 ; Compare #$02.b with X register [Reads: X Index] [Flags: NCZ]
	.db $D0, $09		; D0 09 ; Branch if not equal to $D0, $09 [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	lda ($90.b),Y		; B1 90 ; Load accumulator ($90.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $06.b		; E5 06 ; Subtract $06.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $D7E0.w,X		; BD E0 D7 ; Load $D7E0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta ($92.b),Y		; 91 92 ; Store accumulator ($92.b),Y [Reads: Direct Page, Y Index, Accumulator]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $C5		; 10 C5 ; Branch if plus to $10, $C5 [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	ldy #$FF.b		; A0 FF ; Load #$FF.b into Y register [Writes: Y Index] [Flags: NZ]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06FEB4.l		; 22 B4 FE 06 ; Jump to subroutine long $06FEB4.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ldx #$A4.b		; A2 A4 ; Load #$A4.b into X register [Writes: X Index] [Flags: NZ]
	jsr $FA50.w		; 20 50 FA ; Jump to subroutine at $FA50.w [Writes: Stack Pointer] [Flow: call]
	jsl $06F864.l		; 22 64 F8 06 ; Jump to subroutine long $06F864.l [Writes: Stack Pointer] [Flow: call]
	ldy $0DC0.w,X		; BC C0 0D ; Load Y register $0DC0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $D7ED.w,Y		; B9 ED D7 ; Load $D7ED.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $D7E6.w,Y		; B9 E6 D7 ; Load $D7E6.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	stz $07.b		; 64 07 ; Store zero to $07.b
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx #$01.b		; A2 01 ; Load #$01.b into X register [Writes: X Index] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	and #$0100.w		; 29 00 01 ; Logical AND #$0100.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E.b		; 85 0E ; Store accumulator to $0E.b [Reads: Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: NCZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $06.b		; E5 06 ; Subtract $06.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0010.w		; 69 10 00 ; Add #$0010.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0100.w		; C9 00 01 ; Compare #$0100.w with accumulator [Reads: Accumulator] [Flags: NCZ]
.ACCU 8
	sep #$20		; E2 20
	.db $90, $04		; 90 04 ; Branch if carry clear to $90, $04 [Flow: branch]
	lda #$F0.b		; A9 F0 ; Load #$F0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $D856.w,X		; BD 56 D8 ; Load $D856.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $05.b		; A5 05 ; Load $05.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0F.b		; 05 0F ; Logical OR $0F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($92.b),Y		; 91 92 ; Store accumulator ($92.b),Y [Reads: Direct Page, Y Index, Accumulator]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $BF		; 10 BF ; Branch if plus to $10, $BF [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $D999.w		; 20 99 D9 ; Jump to subroutine at $D999.w [Writes: Stack Pointer] [Flow: call]
	ldy $0DC0.w,X		; BC C0 0D ; Load Y register $0DC0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	.db $F0, $58		; F0 58 ; Branch if equal to $F0, $58 [Flow: branch]
	cpy #$0D.b		; C0 0D ; Compare #$0D.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $F0, $54		; F0 54 ; Branch if equal to $F0, $54 [Flow: branch]
	lda $D92C.w,Y		; B9 2C D9 ; Load $D92C.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0377.w		; 8D 77 03 ; Store accumulator to $0377.w [Reads: Accumulator]
	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $D938.w,Y		; 79 38 D9 ; Add $D938.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $20.b		; 85 20 ; Store accumulator to $20.b [Reads: Accumulator]
	lda $0D20.w,X		; BD 20 0D ; Load $0D20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $21.b		; 85 21 ; Store accumulator to $21.b [Reads: Accumulator]
	lda $0D10.w,X		; BD 10 0D ; Load $0D10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $22.b		; 85 22 ; Store accumulator to $22.b [Reads: Accumulator]
	lda $0D30.w,X		; BD 30 0D ; Load $0D30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $23.b		; 85 23 ; Store accumulator to $23.b [Reads: Accumulator]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $2F		; D0 2F ; Branch if not equal to $D0, $2F [Flow: branch]
	inc $0DC0.w,X		; FE C0 0D ; Increment memory $0DC0.w,X [Reads: X Index] [Flags: NZ]
	ldy $0DC0.w,X		; BC C0 0D ; Load Y register $0DC0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	cpy #$0D.b		; C0 0D ; Compare #$0D.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $D0, $1D		; D0 1D ; Branch if not equal to $D0, $1D [Flow: branch]
	lda $0E20.w,X		; BD 20 0E ; Load $0E20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$06.b		; C9 06 ; Compare #$06.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $0C		; D0 0C ; Branch if not equal to $D0, $0C [Flow: branch]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0CF4.w		; 8D F4 0C ; Store accumulator to $0CF4.w [Reads: Accumulator]
	lda #$3C.b		; A9 3C ; Load #$3C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012E.w		; 8D 2E 01 ; Store accumulator to $012E.w [Reads: Accumulator]
	.db $80, $0A		; 80 0A ; Branch always to $80, $0A [Flow: branch]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0642.w		; 8D 42 06 ; Store accumulator to $0642.w [Reads: Accumulator]
	lda #$1B.b		; A9 1B ; Load #$1B.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012F.w		; 8D 2F 01 ; Store accumulator to $012F.w [Reads: Accumulator]
	lda $D91F.w,Y		; B9 1F D9 ; Load $D91F.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	jsr $D953.w		; 20 53 D9 ; Jump to subroutine at $D953.w [Writes: Stack Pointer] [Flow: call]
	lda $0F00.w,X		; BD 00 0F ; Load $0F00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	stz $0DC0.w,X		; 9E C0 0D ; Store zero to $0DC0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$09.b		; 09 09 ; Logical OR #$09.b with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tsb $0D0C.w		; 0C 0C 0D ; Test and set bits $0D0C.w [Reads: Accumulator] [Flags: Z]
	ora $0E0E.w		; 0D 0E 0E ; Logical OR $0E0E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $FA50.w		; 20 50 FA ; Jump to subroutine at $FA50.w [Writes: Stack Pointer] [Flow: call]
	jsl $06F864.l		; 22 64 F8 06 ; Jump to subroutine long $06F864.l [Writes: Stack Pointer] [Flow: call]
	ldy $0DC0.w,X		; BC C0 0D ; Load Y register $0DC0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $D945.w,Y		; B9 45 D9 ; Load $D945.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	ldy #$04.b		; A0 04 ; Load #$04.b into Y register [Writes: Y Index] [Flags: NZ]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $06.b		; 65 06 ; Add $06.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ldy #$05.b		; A0 05 ; Load #$05.b into Y register [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda #$CE.b		; A9 CE ; Load #$CE.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$06.b		; A0 06 ; Load #$06.b into Y register [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda #$EE.b		; A9 EE ; Load #$EE.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$02.b		; A0 02 ; Load #$02.b into Y register [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $05.b		; A5 05 ; Load $05.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy #$03.b		; A0 03 ; Load #$03.b into Y register [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	ldy #$07.b		; A0 07 ; Load #$07.b into Y register [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	ldy #$02.b		; A0 02 ; Load #$02.b into Y register [Writes: Y Index] [Flags: NZ]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06FEB4.l		; 22 B4 FE 06 ; Jump to subroutine long $06FEB4.l [Writes: Stack Pointer] [Flow: call]
	rts		; [PATTERN: Memory clearing operation] 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $06F129.l		; 22 29 F1 06 ; Jump to subroutine long $06F129.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $30		; 90 30 ; Branch if carry clear to $90, $30 [Flow: branch]
	stz $27.b		; 64 27 ; Store zero to $27.b
	stz $28.b		; 64 28 ; Store zero to $28.b
	jsl $079291.l		; 22 91 92 07 ; Jump to subroutine long $079291.l [Writes: Stack Pointer] [Flow: call]
	stz $48.b		; 64 48 ; Store zero to $48.b
	lda $0020.w		; AD 20 00 ; Load $0020.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $0D00.w,X		; FD 00 0D ; Subtract with carry $0D00.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $10, $3C		; 10 3C ; Branch if plus to $10, $3C [Flow: branch]
	cmp #$F4.b		; C9 F4 ; Compare #$F4.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $30, $28		; 30 28 ; Branch if minus to $30, $28 [Flow: branch]
	lda $0022.w		; AD 22 00 ; Load $0022.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp $0D10.w,X		; DD 10 0D ; Compare accumulator $0D10.w,X [Reads: X Index] [Flags: NCZ]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	lda $0D10.w,X		; BD 10 0D ; Load $0D10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$10.b		; E9 10 ; Subtract #$10.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $22.b		; 85 22 ; Store accumulator to $22.b [Reads: Accumulator]
	lda $0D30.w,X		; BD 30 0D ; Load $0D30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc #$00.b		; E9 00 ; Subtract #$00.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $23.b		; 85 23 ; Store accumulator to $23.b [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0D10.w,X		; BD 10 0D ; Load $0D10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0E.b		; 69 0E ; Add #$0E.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $22.b		; 85 22 ; Store accumulator to $22.b [Reads: Accumulator]
	lda $0D30.w,X		; BD 30 0D ; Load $0D30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $23.b		; 85 23 ; Store accumulator to $23.b [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$15.b		; E9 15 ; Subtract #$15.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $20.b		; 85 20 ; Store accumulator to $20.b [Reads: Accumulator]
	lda $0D20.w,X		; BD 20 0D ; Load $0D20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc #$00.b		; E9 00 ; Subtract #$00.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $21.b		; 85 21 ; Store accumulator to $21.b [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	inc $0379.w		; EE 79 03 ; Increment $0379.w [Flags: NZ]
	lda $F2.b		; A5 F2 ; Load $F2.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $22		; 10 22 ; Branch if plus to $10, $22 [Flow: branch]
	lda $F0.b		; A5 F0 ; Load $F0.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $1C		; D0 1C ; Branch if not equal to $D0, $1C [Flow: branch]
	inc $0377.w		; EE 77 03 ; Increment $0377.w [Flags: NZ]
	lda $F0.b		; A5 F0 ; Load $F0.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$04.b		; 29 04 ; Logical AND #$04.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $13		; F0 13 ; Branch if equal to $F0, $13 [Flow: branch]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0E		; D0 0E ; Branch if not equal to $D0, $0E [Flow: branch]
	inc $0DC0.w,X		; FE C0 0D ; Increment memory $0DC0.w,X [Reads: X Index] [Flags: NZ]
	lda #$0C.b		; A9 0C ; Load #$0C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda #$22.b		; A9 22 ; Load #$22.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB7C.l		; 22 7C BB 0D ; Jump to subroutine long $0DBB7C.l [Writes: Stack Pointer] [Flow: call]
	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$09.b		; 69 09 ; Add #$09.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $20.b		; 85 20 ; Store accumulator to $20.b [Reads: Accumulator]
	lda $0D20.w,X		; BD 20 0D ; Load $0D20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $21.b		; 85 21 ; Store accumulator to $21.b [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $DA3D.w		; 20 3D DA ; Jump to subroutine at $DA3D.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	sbc $FAFFFA.l,X		; FF FA FF FA ; Subtract with carry (long,X) $FAFFFA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F70000.l,X		; FF 00 00 F7 ; Subtract with carry (long,X) $F70000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $A50000.l,X		; FF 00 00 A5 ; Subtract with carry (long,X) $A50000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy #$C9.b		; A0 C9 ; Load #$C9.b into Y register [Writes: Y Index] [Flags: NZ]
	ora ($F0.b)		; 12 F0 ; OR accumulator with memory (indirect) ($F0.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $4C.b,S		; 03 4C ; OR accumulator with stack relative $4C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc [$DA.b],Y		; F7 DA ; Subtract with carry (long indexed) [$DA.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr $DB27.w		; 20 27 DB ; Jump to subroutine at $DB27.w [Writes: Stack Pointer] [Flow: call]
	lda $7EF3C5.l		; AF C5 F3 7E ; Load long $7EF3C5.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $0A		; 90 0A ; Branch if carry clear to $90, $0A [Flow: branch]
	lda $7EF3C6.l		; AF C6 F3 7E ; Load long $7EF3C6.l into accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$02.b		; 09 02 ; Logical OR #$02.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF3C6.l		; 8F C6 F3 7E ; Store accumulator (long) $7EF3C6.l [Reads: Accumulator]
	lda $7EF3C6.l		; AF C6 F3 7E ; Load long $7EF3C6.l into accumulator [Writes: Accumulator] [Flags: NZ]
	and #$02.b		; 29 02 ; Logical AND #$02.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E90.w,X		; 9D 90 0E ; Store accumulator to $0E90.w,X [Reads: Accumulator, X Index]
	lda $0E40.w,X		; BD 40 0E ; Load $0E40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$F0.b		; 29 F0 ; Logical AND #$F0.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$02.b		; 09 02 ; Logical OR #$02.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E40.w,X		; 9D 40 0E ; Store accumulator to $0E40.w,X [Reads: Accumulator, X Index]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F60.w,X		; 9D 60 0F ; Store accumulator to $0F60.w,X [Reads: Accumulator, X Index]
	lda $7EF359.l		; AF 59 F3 7E ; Load long $7EF359.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $0C		; 90 0C ; Branch if carry clear to $90, $0C [Flow: branch]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	stz $0DC0.w,X		; 9E C0 0D ; Store zero to $0DC0.w,X [Reads: X Index]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $80, $33		; 80 33 ; Branch always to $80, $33 [Flow: branch]
	jsr $F93F.w		; 20 3F F9 ; Jump to subroutine at $F93F.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor #$03.b		; 49 03 ; Exclusive OR #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	lda $7EF3CC.l		; AF CC F3 7E ; Load long $7EF3CC.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$01.b		; C9 01 ; Compare #$01.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $1D		; D0 1D ; Branch if not equal to $D0, $1D [Flow: branch]
	lda $7EF3C6.l		; AF C6 F3 7E ; Load long $7EF3C6.l into accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$04.b		; 09 04 ; Logical OR #$04.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF3C6.l		; 8F C6 F3 7E ; Store accumulator (long) $7EF3C6.l [Reads: Accumulator]
	lda $7EF29B.l		; AF 9B F2 7E ; Load long $7EF29B.l into accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$20.b		; 09 20 ; Logical OR #$20.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF29B.l		; 8F 9B F2 7E ; Store accumulator (long) $7EF29B.l [Reads: Accumulator]
	lda #$AA.b		; A9 AA ; Load #$AA.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $80, $02		; 80 02 ; Branch always to $80, $02 [Flow: branch]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E80.w,X		; 9D 80 0E ; Store accumulator to $0E80.w,X [Reads: Accumulator, X Index]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $DA31.w,Y		; B9 31 DA ; Load $DA31.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0D10.w,X		; 7D 10 0D ; Add $0D10.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,X		; 9D 10 0D ; Store accumulator to $0D10.w,X [Reads: Accumulator, X Index]
	lda $DA32.w,Y		; B9 32 DA ; Load $DA32.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $0D30.w,X		; 7D 30 0D ; Add $0D30.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D30.w,X		; 9D 30 0D ; Store accumulator to $0D30.w,X [Reads: Accumulator, X Index]
	lda $DA37.w,Y		; B9 37 DA ; Load $DA37.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0D00.w,X		; 7D 00 0D ; Add $0D00.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,X		; 9D 00 0D ; Store accumulator to $0D00.w,X [Reads: Accumulator, X Index]
	lda $DA38.w,Y		; B9 38 DA ; Load $DA38.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $0D20.w,X		; 7D 20 0D ; Add $0D20.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D20.w,X		; 9D 20 0D ; Store accumulator to $0D20.w,X [Reads: Accumulator, X Index]
	inc $0BA0.w,X		; FE A0 0B ; Increment memory $0BA0.w,X [Reads: X Index] [Flags: NZ]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7FFE01.l		; 8F 01 FE 7F ; Store accumulator (long) $7FFE01.l [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cmp #$04.b		; C9 04 ; Compare #$04.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $12		; D0 12 ; Branch if not equal to $D0, $12 [Flow: branch]
	lda $7EF3C6.l		; AF C6 F3 7E ; Load long $7EF3C6.l into accumulator [Writes: Accumulator] [Flags: NZ]
	and #$10.b		; 29 10 ; Logical AND #$10.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $1C		; D0 1C ; Branch if not equal to $D0, $1C [Flow: branch]
	lda $0D10.w,X		; BD 10 0D ; Load $0D10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$08.b		; 69 08 ; Add #$08.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,X		; 9D 10 0D ; Store accumulator to $0D10.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $7EF3C6.l		; AF C6 F3 7E ; Load long $7EF3C6.l into accumulator [Writes: Accumulator] [Flags: NZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0A		; D0 0A ; Branch if not equal to $D0, $0A [Flow: branch]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $0E80.w,X		; 9D 80 0E ; Store accumulator to $0E80.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	and [$02.b],Y		; 37 02 ; AND accumulator with memory (long indexed) [$02.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	inc $0DDF.w		; EE DF 0D ; Increment $0DDF.w [Flags: NZ]
	lda #$73.b		; A9 73 ; Load #$73.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	stz $0DDF.w		; 9C DF 0D ; Store zero to $0DDF.w
	lda $0E40.w,Y		; B9 40 0E ; Load $0E40.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and #$F0.b		; 29 F0 ; Logical AND #$F0.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$03.b		; 09 03 ; Logical OR #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E40.w,Y		; 99 40 0E ; Store accumulator to $0E40.w,Y [Reads: Y Index, Accumulator]
	lda $DB23.w		; AD 23 DB ; Load $DB23.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D10.w,Y		; 99 10 0D ; Store accumulator to $0D10.w,Y [Reads: Y Index, Accumulator]
	lda $DB24.w		; AD 24 DB ; Load $DB24.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D30.w,Y		; 99 30 0D ; Store accumulator to $0D30.w,Y [Reads: Y Index, Accumulator]
	lda $DB25.w		; AD 25 DB ; Load $DB25.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D00.w,Y		; 99 00 0D ; Store accumulator to $0D00.w,Y [Reads: Y Index, Accumulator]
	lda $DB26.w		; AD 26 DB ; Load $DB26.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D20.w,Y		; 99 20 0D ; Store accumulator to $0D20.w,Y [Reads: Y Index, Accumulator]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E90.w,Y		; 99 90 0E ; Store accumulator to $0E90.w,Y [Reads: Y Index, Accumulator]
	lda #$0B.b		; A9 0B ; Load #$0B.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F60.w,Y		; 99 60 0F ; Store accumulator to $0F60.w,Y [Reads: Y Index, Accumulator]
	lda $0CAA.w,Y		; B9 AA 0C ; Load $0CAA.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora #$20.b		; 09 20 ; Logical OR #$20.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0CAA.w,Y		; 99 AA 0C ; Store accumulator to $0CAA.w,Y [Reads: Y Index, Accumulator]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E80.w,Y		; 99 80 0E ; Store accumulator to $0E80.w,Y [Reads: Y Index, Accumulator]
	lda $0D00.w,Y		; B9 00 0D ; Load $0D00.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $0D20.w,Y		; B9 20 0D ; Load $0D20.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $01.b		; 85 01 ; Store accumulator to $01.b [Reads: Accumulator]
.ACCU 16
.INDEX 16
	rep #$30		; C2 30
	lda $20.b		; A5 20 ; Load $20.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $00.b		; C5 00 ; Compare $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	.db $B0, $05		; B0 05 ; Branch if carry set to $B0, $05 [Flow: branch]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DB0.w,Y		; 99 B0 0D ; Store accumulator to $0DB0.w,Y [Reads: Y Index, Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $DB8E.w		; 20 8E DB ; Jump to subroutine at $DB8E.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0E90.w,X		; BD 90 0E ; Load $0E90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	bit $E6DE.w		; 2C DE E6 ; Test bits $E6DE.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	jmp.w [$DB9B]		; DC 9B DB ; Jump long indirect [$DB9B] [Flow: jump]
	jsr $DC8A.w		; 20 8A DC ; Jump to subroutine at $DC8A.w [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	lda $0DB0.w,X		; BD B0 0D ; Load $0DB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $3D		; D0 3D ; Branch if not equal to $D0, $3D [Flow: branch]
	jsl $06F129.l		; 22 29 F1 06 ; Jump to subroutine long $06F129.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $27		; 90 27 ; Branch if carry clear to $90, $27 [Flow: branch]
	jsl $0FF540.l		; 22 40 F5 0F ; Jump to subroutine long $0FF540.l [Writes: Stack Pointer] [Flow: call]
	stz $5E.b		; [PATTERN: Memory clearing operation] 64 5E ; Store zero to $5E.b
	jsl $079291.l		; 22 91 92 07 ; Jump to subroutine long $079291.l [Writes: Stack Pointer] [Flow: call]
	lda #$07.b		; A9 07 ; Load #$07.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E00.w,X		; 9D 00 0E ; Store accumulator to $0E00.w,X [Reads: Accumulator, X Index]
	stz $0E80.w,X		; 9E 80 0E ; Store zero to $0E80.w,X [Reads: X Index]
	lda #$81.b		; A9 81 ; Load #$81.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $48.b		; 85 48 ; Store accumulator to $48.b [Reads: Accumulator]
	lda #$08.b		; A9 08 ; Load #$08.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $5E.b		; 85 5E ; Store accumulator to $5E.b [Reads: Accumulator]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	brk $DC.b		; 00 DC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $52DC.w,Y		; 39 DC 52 ; AND accumulator with memory $52DC.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$00BD]		; DC BD 00 ; Jump long indirect [$00BD] [Flow: jump]
	asl $E3D0.w		; 0E D0 E3 ; Arithmetic shift left $E3D0.w [Flags: NCZ]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	sbc $DB.b,X		; F5 DB ; Subtract $DB.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $40A9DB.l,X		; FF DB A9 40 ; Subtract with carry (long,X) $40A9DB.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D90.w,X		; 9D 90 0D ; Store accumulator to $0D90.w,X [Reads: Accumulator, X Index]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	brk $DC.b		; 00 DC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $52DC.w,Y		; 39 DC 52 ; AND accumulator with memory $52DC.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$909E]		; DC 9E 90 ; Jump long indirect [$909E] [Flow: jump]
	ora $4864.w		; 0D 64 48 ; Logical OR $4864.w with accumulator [Writes: Accumulator] [Flags: NZ]
	stz $5E.b		; 64 5E ; Store zero to $5E.b
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0D10.w,X		; BD 10 0D ; Load $0D10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$13.b		; 69 13 ; Add #$13.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,X		; 9D 10 0D ; Store accumulator to $0D10.w,X [Reads: Accumulator, X Index]
	lda $0D30.w,X		; BD 30 0D ; Load $0D30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D30.w,X		; 9D 30 0D ; Store accumulator to $0D30.w,X [Reads: Accumulator, X Index]
	jsr $F93F.w		; 20 3F F9 ; Jump to subroutine at $F93F.w [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $0D30.w,X		; 9D 30 0D ; Store accumulator to $0D30.w,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $0D10.w,X		; 9D 10 0D ; Store accumulator to $0D10.w,X [Reads: Accumulator, X Index]
	cpy #$03.b		; C0 03 ; Compare #$03.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	cpy #$01.b		; C0 01 ; Compare #$01.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $D0, $12		; D0 12 ; Branch if not equal to $D0, $12 [Flow: branch]
	inc $0D90.w,X		; FE 90 0D ; Increment memory $0D90.w,X [Reads: X Index] [Flags: NZ]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$40.b		; C9 40 ; Compare #$40.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $08		; 90 08 ; Branch if carry clear to $90, $08 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $02E4.w		; 8D E4 02 ; Store accumulator to $02E4.w [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB8A.l		; 22 8A BB 0D ; Jump to subroutine long $0DBB8A.l [Writes: Stack Pointer] [Flow: call]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$A8.b		; A9 A8 ; Load #$A8.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E00.w,X		; 9D 00 0E ; Store accumulator to $0E00.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $F9ED.w		; [PATTERN: Memory clearing operation] 20 ED F9 ; Jump to subroutine at $F9ED.w [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0A		; D0 0A ; Branch if not equal to $D0, $0A [Flow: branch]
	stz $02E4.w		; 9C E4 02 ; Store zero to $02E4.w
	stz $0D50.w,X		; 9E 50 0D ; Store zero to $0D50.w,X [Reads: X Index]
	stz $0DB0.w,X		; 9E B0 0D ; Store zero to $0DB0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E00.w,X		; 9D 00 0E ; Store accumulator to $0E00.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $0016.w		; 2C 16 00 ; Test bits $0016.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	cop $10.b		; 02 10 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2C.b		; 00 2C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $00.b,X		; 56 00 ; Logical shift right $00.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2E.b		; 00 2E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	cop $10.b		; 02 10 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2E.b		; 00 2E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $00.b		; 46 00 ; Logical shift right $00.b [Reads: Direct Page] [Flags: NCZ]
	cop $A9.b		; 02 A9 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
	lda #$DC.b		; A9 DC ; Load #$DC.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $09.b		; 85 09 ; Store accumulator to $09.b [Reads: Accumulator]
	lda $0DB0.w,X		; BD B0 0D ; Load $0DB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $06		; D0 06 ; Branch if not equal to $D0, $06 [Flow: branch]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBA84.l		; 22 84 BA 0D ; Jump to subroutine long $0DBA84.l [Writes: Stack Pointer] [Flow: call]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jmp $8AB1.w		; 4C B1 8A ; Jump to $8AB1.w [Flow: jump]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $0EB0.w,X		; DD B0 0E ; Compare accumulator $0EB0.w,X [Reads: X Index] [Flags: NCZ]
	.db $F0, $2C		; F0 2C ; Branch if equal to $F0, $2C [Flow: branch]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$1F.b		; 29 1F ; Logical AND #$1F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $24		; D0 24 ; Branch if not equal to $D0, $24 [Flow: branch]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $0EB0.w,X		; 5D B0 0E ; Exclusive OR accumulator with memory $0EB0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$02.b		; 29 02 ; Logical AND #$02.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $1C		; D0 1C ; Branch if not equal to $D0, $1C [Flow: branch]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora #$02.b		; 09 02 ; Logical OR #$02.b with accumulator [Writes: Accumulator] [Flags: NZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	lda $0EB0.w,X		; BD B0 0E ; Load $0EB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$02.b		; 29 02 ; Logical AND #$02.b with accumulator [Writes: Accumulator] [Flags: NZ]
	eor $0DE0.w,X		; 5D E0 0D ; Exclusive OR accumulator with memory $0DE0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	clc		; 18 ; Clear carry flag [Flags: C]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0EB0.w,X		; BD B0 0E ; Load $0EB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	sec		; 38 ; Set carry flag [Flags: C]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$09.b],Y		; F7 09 ; Subtract with carry (long indexed) [$09.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$09.b],Y		; F7 09 ; Subtract with carry (long indexed) [$09.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $04		; D0 04 ; Branch if not equal to $D0, $04 [Flow: branch]
	jsl $0DCF31.l		; 22 31 CF 0D ; Jump to subroutine long $0DCF31.l [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	jsl $1EF4F3.l		; 22 F3 F4 1E ; Jump to subroutine long $1EF4F3.l [Writes: Stack Pointer] [Flow: call]
	jsl $05DCA2.l		; 22 A2 DC 05 ; Jump to subroutine long $05DCA2.l [Writes: Stack Pointer] [Flow: call]
	jsr $F9ED.w		; 20 ED F9 ; Jump to subroutine at $F9ED.w [Writes: Stack Pointer] [Flow: call]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cmp $DD63.w,X		; DD 63 DD ; Compare accumulator $DD63.w,X [Reads: X Index] [Flags: NCZ]
	sbc $DD.b		; E5 DD ; Subtract $DD.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	ora $DD3FDD.l,X		; 1F DD 3F DD ; Logical OR long $DD3FDD.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1BA9DD.l,X		; 5F DD A9 1B ; Exclusive OR accumulator with memory (long,X) $1BA9DD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E1A7.l		; 22 A7 E1 05 ; Jump to subroutine long $05E1A7.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $15		; 90 15 ; Branch if carry clear to $90, $15 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	inc $0DC0.w,X		; FE C0 0D ; Increment memory $0DC0.w,X [Reads: X Index] [Flags: NZ]
	lda $7EF3C6.l		; AF C6 F3 7E ; Load long $7EF3C6.l into accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$02.b		; 09 02 ; Logical OR #$02.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF3C6.l		; 8F C6 F3 7E ; Store accumulator (long) $7EF3C6.l [Reads: Accumulator]
	lda #$80.b		; A9 80 ; Load #$80.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E10.w,X		; 9D 10 0E ; Store accumulator to $0E10.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $0DC0.w,X		; 9E C0 0D ; Store zero to $0DC0.w,X [Reads: X Index]
	lda $0E10.w,X		; BD 10 0E ; Load $0E10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$02.b		; 29 02 ; Logical AND #$02.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D90.w,X		; 9D 90 0D ; Store accumulator to $0D90.w,X [Reads: Accumulator, X Index]
	lda $0E10.w,X		; BD 10 0E ; Load $0E10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $06		; D0 06 ; Branch if not equal to $D0, $06 [Flow: branch]
	lda #$33.b		; A9 33 ; Load #$33.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB7C.l		; 22 7C BB 0D ; Jump to subroutine long $0DBB7C.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	adc ($DD.b)		; 72 DD ; Add with carry (indirect) ($DD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $DDB3DD.l,X		; 9F DD B3 DD ; Store accumulator (long,X) $DDB3DD.l,X [Reads: Accumulator, X Index]
	cmp $DD.b		; C5 DD ; Compare $DD.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $1F		; D0 1F ; Branch if not equal to $D0, $1F [Flow: branch]
	lda #$17.b		; A9 17 ; Load #$17.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7FFE01.l		; 8F 01 FE 7F ; Store accumulator (long) $7FFE01.l [Reads: Accumulator]
	jsr $EC4C.w		; 20 4C EC ; Jump to subroutine at $EC4C.w [Writes: Stack Pointer] [Flow: call]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $02E4.w		; 8D E4 02 ; Store accumulator to $02E4.w [Reads: Accumulator]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF3C7.l		; 8F C7 F3 7E ; Store accumulator (long) $7EF3C7.l [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $7FFE01.l		; AF 01 FE 7F ; Load long $7FFE01.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $0B		; D0 0B ; Branch if not equal to $D0, $0B [Flow: branch]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $1CE8.w		; AD E8 1C ; Load $1CE8.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $07		; D0 07 ; Branch if not equal to $D0, $07 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	stz $02E4.w		; 9C E4 02 ; Store zero to $02E4.w
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D80.w,X		; 9D 80 0D ; Store accumulator to $0D80.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $F93F.w		; 20 3F F9 ; Jump to subroutine at $F93F.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor #$03.b		; 49 03 ; Exclusive OR #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	lda #$16.b		; A9 16 ; Load #$16.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E1A7.l		; 22 A7 E1 05 ; Jump to subroutine long $05E1A7.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $06		; 90 06 ; Branch if carry clear to $90, $06 [Flow: branch]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	asl $19.b,X		; 16 19 ; Arithmetic shift left $19.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $4998F9.l,X		; 3F F9 98 49 ; AND accumulator with memory (long,X) $4998F9.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $9D.b,S		; 03 9D ; OR accumulator with stack relative $9D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $0E		; B0 0E ; Branch if carry set to $B0, $0E [Flow: branch]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	lda $7EF374.l		; AF 74 F3 7E ; Load long $7EF374.l into accumulator [Writes: Accumulator] [Flags: NZ]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$07.b		; C9 07 ; Compare #$07.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $04		; D0 04 ; Branch if not equal to $D0, $04 [Flow: branch]
	ldy #$02.b		; A0 02 ; Load #$02.b into Y register [Writes: Y Index] [Flags: NZ]
	.db $80, $0A		; 80 0A ; Branch always to $80, $0A [Flow: branch]
	lda $7EF3C7.l		; AF C7 F3 7E ; Load long $7EF3C7.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $02		; 90 02 ; Branch if carry clear to $90, $02 [Flow: branch]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	lda $DDDF.w,Y		; B9 DF DD ; Load $DDDF.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lda $DDE2.w,Y		; B9 E2 DD ; Load $DDE2.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	jsl $05E1A7.l		; 22 A7 E1 05 ; Jump to subroutine long $05E1A7.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $0C		; 90 0C ; Branch if carry clear to $90, $0C [Flow: branch]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	lda #$A0.b		; A9 A0 ; Load #$A0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF372.l		; 8F 72 F3 7E ; Store accumulator (long) $7EF372.l [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pea $F40C.w		; F4 0C F4 ; Push absolute address $F40C.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	tsb $0000.w		; 0C 00 00 ; Test and set bits $0000.w [Reads: Accumulator] [Flags: Z]
	jsl $0DD391.l		; 22 91 D3 0D ; Jump to subroutine long $0DD391.l [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	rol $19DE.w,X		; 3E DE 19 ; Rotate left $19DE.w,X [Reads: X Index] [Flags: NCZ]
	cmp $F9ED20.l,X		; DF 20 ED F9 ; Compare accumulator (long,X) $F9ED20.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	eor ($DE.b)		; 52 DE ; Exclusive OR accumulator with memory (indirect) ($DE.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc ($DE.b)		; 72 DE ; Add with carry (indirect) ($DE.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	dec $DEB4.w,X		; DE B4 DE ; Decrement memory $DEB4.w,X [Reads: X Index] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	dec $40A9.w,X		; DE A9 40 ; Decrement memory $40A9.w,X [Reads: X Index] [Flags: NZ]
	sta $0FC2.w		; 8D C2 0F ; Store accumulator to $0FC2.w [Reads: Accumulator]
	lda #$09.b		; A9 09 ; Load #$09.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0FC3.w		; 8D C3 0F ; Store accumulator to $0FC3.w [Reads: Accumulator]
	lda #$5A.b		; A9 5A ; Load #$5A.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0FC4.w		; 8D C4 0F ; Store accumulator to $0FC4.w [Reads: Accumulator]
	lda #$21.b		; A9 21 ; Load #$21.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0FC5.w		; 8D C5 0F ; Store accumulator to $0FC5.w [Reads: Accumulator]
	lda #$1F.b		; A9 1F ; Load #$1F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0A		; D0 0A ; Branch if not equal to $D0, $0A [Flow: branch]
	lda $9C.b		; A5 9C ; Load $9C.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$20.b		; C9 20 ; Compare #$20.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $05		; F0 05 ; Branch if equal to $F0, $05 [Flow: branch]
	dec $9C.b		; C6 9C ; Decrement $9C.b [Reads: Direct Page] [Flags: NZ]
	dec $9D.b		; C6 9D ; Decrement $9D.b [Reads: Direct Page] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	inc $037D.w		; EE 7D 03 ; Increment $037D.w [Flags: NZ]
	inc $037C.w		; EE 7C 03 ; Increment $037C.w [Flags: NZ]
	lda #$57.b		; A9 57 ; Load #$57.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $20.b		; 85 20 ; Store accumulator to $20.b [Reads: Accumulator]
	lda #$21.b		; A9 21 ; Load #$21.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $21.b		; 85 21 ; Store accumulator to $21.b [Reads: Accumulator]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $02E4.w		; 8D E4 02 ; Store accumulator to $02E4.w [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$0D.b		; A9 0D ; Load #$0D.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012C.w		; 8D 2C 01 ; Store accumulator to $012C.w [Reads: Accumulator]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cpx #$02.b		; E0 02 ; Compare #$02.b with X register [Reads: X Index] [Flags: NCZ]
	ora ($BD.b,X)		; 01 BD ; Logical OR ($BD.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $F0, $0D		; F0 0D ; Branch if equal to $F0, $0D [Flow: branch]
	.db $D0, $34		; D0 34 ; Branch if not equal to $D0, $34 [Flow: branch]
	ldy $0D90.w,X		; BC 90 0D ; Load Y register $0D90.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	.db $D0, $09		; D0 09 ; Branch if not equal to $D0, $09 [Flow: branch]
	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$02.b		; E9 02 ; Subtract #$02.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,X		; 9D 00 0D ; Store accumulator to $0D00.w,X [Reads: Accumulator, X Index]
	lda $DEB0.w,Y		; B9 B0 DE ; Load $DEB0.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda $DEB2.w,Y		; B9 B2 DE ; Load $DEB2.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $DE24.w,Y		; B9 24 DE ; Load $DE24.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $DE28.w,Y		; B9 28 DE ; Load $DE28.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	inc $0D90.w,X		; FE 90 0D ; Increment memory $0D90.w,X [Reads: X Index] [Flags: NZ]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$05.b		; A9 05 ; Load #$05.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF3CC.l		; 8F CC F3 7E ; Store accumulator (long) $7EF3CC.l [Reads: Accumulator]
	lda #$F3.b		; A9 F3 ; Load #$F3.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $02CD.w		; 8D CD 02 ; Store accumulator to $02CD.w [Reads: Accumulator]
	lda #$0D.b		; A9 0D ; Load #$0D.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $02CE.w		; 8D CE 02 ; Store accumulator to $02CE.w [Reads: Accumulator]
	lda $7EF3C6.l		; [PATTERN: Memory clearing operation] AF C6 F3 7E ; Load long $7EF3C6.l into accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$10.b		; 09 10 ; Logical OR #$10.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF3C6.l		; 8F C6 F3 7E ; Store accumulator (long) $7EF3C6.l [Reads: Accumulator]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	stz $02E4.w		; 9C E4 02 ; Store zero to $02E4.w
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	rol $DF.b		; 26 DF ; Rotate left $DF.b [Reads: Direct Page] [Flags: NCZ]
	mvp $43,$DF		; 44 DF 43 ; Move block positive $43,$DF [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cmp $F12922.l,X		; DF 22 29 F1 ; Compare accumulator (long,X) $F12922.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	asl $90.b		; 06 90 ; Arithmetic shift left $90.b [Reads: Direct Page] [Flags: NCZ]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	lda $0791.w,Y		; B9 91 07 ; Load $0791.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lda #$0E.b		; A9 0E ; Load #$0E.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E1F0.l		; 22 F0 E1 05 ; Jump to subroutine long $05E1F0.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $09		; 90 09 ; Branch if carry clear to $90, $09 [Flow: branch]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF3CC.l		; 8F CC F3 7E ; Store accumulator (long) $7EF3CC.l [Reads: Accumulator]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	stz $02E9.w		; 9C E9 02 ; Store zero to $02E9.w
	jsl $0799AD.l		; 22 AD 99 07 ; Jump to subroutine long $0799AD.l [Writes: Stack Pointer] [Flow: call]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF3C8.l		; 8F C8 F3 7E ; Store accumulator (long) $7EF3C8.l [Reads: Accumulator]
	lda $7EF3C6.l		; AF C6 F3 7E ; Load long $7EF3C6.l into accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$01.b		; 09 01 ; Logical OR #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF3C6.l		; 8F C6 F3 7E ; Store accumulator (long) $7EF3C6.l [Reads: Accumulator]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF3C5.l		; 8F C5 F3 7E ; Store accumulator (long) $7EF3C5.l [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	stz $07.b		; 64 07 ; Store zero to $07.b
	jsr $DFE9.w		; 20 E9 DF ; Jump to subroutine at $DFE9.w [Writes: Stack Pointer] [Flow: call]
	.db $80, $03		; 80 03 ; Branch always to $80, $03 [Flow: branch]
	jsr $DFE5.w		; 20 E5 DF ; Jump to subroutine at $DFE5.w [Writes: Stack Pointer] [Flow: call]
	.db $B0, $6A		; B0 6A ; Branch if carry set to $B0, $6A [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
.ACCU 16
.INDEX 16
	rep #$30		; C2 30
	ldy #$0000.w		; A0 00 00 ; Load #$0000.w into Y register [Writes: Y Index] [Flags: NZ]
	ldx $0090.w		; AE 90 00 ; Load $0090.w into X register [Writes: X Index] [Flags: NZ]
	lda ($08.b),Y		; B1 08 ; Load accumulator ($08.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $00.b		; 65 00 ; Add $00.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $0000.w,X		; 9D 00 00 ; Store accumulator to $0000.w,X [Reads: Accumulator, X Index]
	and #$0100.w		; 29 00 01 ; Logical AND #$0100.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0C.b		; 85 0C ; Store accumulator to $0C.b [Reads: Accumulator]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	lda ($08.b),Y		; B1 08 ; Load accumulator ($08.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $02.b		; 65 02 ; Add $02.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $0001.w,X		; 9D 01 00 ; Store accumulator to $0001.w,X [Reads: Accumulator, X Index]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0010.w		; 69 10 00 ; Add #$0010.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0100.w		; C9 00 01 ; Compare #$0100.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $06		; 90 06 ; Branch if carry clear to $90, $06 [Flow: branch]
	lda #$00F0.w		; A9 F0 00 ; Load #$00F0.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0001.w,X		; 9D 01 00 ; Store accumulator to $0001.w,X [Reads: Accumulator, X Index]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	lda $0CFE.w		; AD FE 0C ; Load $0CFE.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$0001.w		; C9 01 00 ; Compare #$0001.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	lda ($08.b),Y		; B1 08 ; Load accumulator ($08.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $04.b		; 45 04 ; Exclusive OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $90, $06		; 90 06 ; Branch if carry clear to $90, $06 [Flow: branch]
	and #$F1FF.w		; 29 FF F1 ; Logical AND #$F1FF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$0400.w		; 09 00 04 ; Logical OR #$0400.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0002.w,X		; 9D 02 00 ; Store accumulator to $0002.w,X [Reads: Accumulator, X Index]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$0800.w		; E9 00 08 ; Subtract #$0800.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
.ACCU 8
	sep #$20		; E2 20
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	lda ($08.b),Y		; B1 08 ; Load accumulator ($08.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $0D.b		; 05 0D ; Logical OR $0D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0A20.w,X		; 9D 20 0A ; Store accumulator to $0A20.w,X [Reads: Accumulator, X Index]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	dec $06.b		; C6 06 ; Decrement $06.b [Reads: Direct Page] [Flags: NZ]
	.db $D0, $A2		; D0 A2 ; Branch if not equal to $D0, $A2 [Flow: branch]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $06F864.l		; [PATTERN: Memory clearing operation] 22 64 F8 06 ; Jump to subroutine long $06F864.l [Writes: Stack Pointer] [Flow: call]
	jsr $FA50.w		; 20 50 FA ; Jump to subroutine at $FA50.w [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	stz $0CFE.w		; 9C FE 0C ; Store zero to $0CFE.w
	stz $0CFF.w		; 9C FF 0C ; Store zero to $0CFF.w
	lda $0DD0.w,X		; BD D0 0D ; Load $0DD0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$0A.b		; C9 0A ; Compare #$0A.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $04		; D0 04 ; Branch if not equal to $D0, $04 [Flow: branch]
	lda $7FFA2C.l,X		; BF 2C FA 7F ; Load long $7FFA2C.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$0B.b		; C9 0B ; Compare #$0B.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $07		; D0 07 ; Branch if not equal to $D0, $07 [Flow: branch]
	lda $7FFA3C.l,X		; BF 3C FA 7F ; Load long $7FFA3C.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0CFE.w		; 8D FE 0C ; Store accumulator to $0CFE.w [Reads: Accumulator]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $E013.w		; 20 13 E0 ; Jump to subroutine at $E013.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $E17F.w		; 20 7F E1 ; Jump to subroutine at $E17F.w [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	jsl $05DCA2.l		; 22 A2 DC 05 ; Jump to subroutine long $05DCA2.l [Writes: Stack Pointer] [Flow: call]
	jsr $F93F.w		; 20 3F F9 ; Jump to subroutine at $F93F.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor #$03.b		; 49 03 ; Exclusive OR #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	lda $A0.b		; A5 A0 ; Load $A0.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0A		; D0 0A ; Branch if not equal to $D0, $0A [Flow: branch]
	lda #$31.b		; A9 31 ; Load #$31.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E1A7.l		; 22 A7 E1 05 ; Jump to subroutine long $05E1A7.l [Writes: Stack Pointer] [Flow: call]
	.db $80, $17		; 80 17 ; Branch always to $80, $17 [Flow: branch]
	lda $0401.w		; AD 01 04 ; Load $0401.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0A		; D0 0A ; Branch if not equal to $D0, $0A [Flow: branch]
	lda #$2F.b		; A9 2F ; Load #$2F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E1A7.l		; 22 A7 E1 05 ; Jump to subroutine long $05E1A7.l [Writes: Stack Pointer] [Flow: call]
	.db $80, $08		; 80 08 ; Branch always to $80, $08 [Flow: branch]
	lda #$30.b		; A9 30 ; Load #$30.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E1A7.l		; 22 A7 E1 05 ; Jump to subroutine long $05E1A7.l [Writes: Stack Pointer] [Flow: call]
	jsl $1EF4F3.l		; 22 F3 F4 1E ; Jump to subroutine long $1EF4F3.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $F9ED.w		; 20 ED F9 ; Jump to subroutine at $F9ED.w [Writes: Stack Pointer] [Flow: call]
	jsr $B88D.w		; 20 8D B8 ; Jump to subroutine at $B88D.w [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpx #$B6.b		; E0 B6 ; Compare #$B6.b with X register [Reads: X Index] [Flags: NCZ]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: NCZ]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	pea $000B.w		; F4 0B 00 ; Push absolute address $000B.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $BD.b		; 00 BD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $0D		; F0 0D ; Branch if equal to $F0, $0D [Flow: branch]
	.db $D0, $18		; D0 18 ; Branch if not equal to $D0, $18 [Flow: branch]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$1F.b		; 29 1F ; Logical AND #$1F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$40.b		; 69 40 ; Add #$40.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$02.b		; 09 02 ; Logical OR #$02.b with accumulator [Writes: Accumulator] [Flags: NZ]
	eor $0DE0.w,X		; 5D E0 0D ; Exclusive OR accumulator with memory $0DE0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	lda $0E70.w,X		; BD 70 0E ; Load $0E70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$0F.b		; 29 0F ; Logical AND #$0F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $08		; F0 08 ; Branch if equal to $F0, $08 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$60.b		; A9 60 ; Load #$60.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $E063.w,Y		; B9 63 E0 ; Load $E063.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $E067.w,Y		; B9 67 E0 ; Load $E067.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D90.w,X		; 9D 90 0D ; Store accumulator to $0D90.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $1B		; D0 1B ; Branch if not equal to $D0, $1B [Flow: branch]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$1F.b		; 29 1F ; Logical AND #$1F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$60.b		; 69 60 ; Add #$60.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$02.b		; [PATTERN: Memory clearing operation] 09 02 ; Logical OR #$02.b with accumulator [Writes: Accumulator] [Flags: NZ]
	eor $0DE0.w,X		; 5D E0 0D ; Exclusive OR accumulator with memory $0DE0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	stz $0D50.w,X		; 9E 50 0D ; Store zero to $0D50.w,X [Reads: X Index]
	stz $0D40.w,X		; 9E 40 0D ; Store zero to $0D40.w,X [Reads: X Index]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0C		; D0 0C ; Branch if not equal to $D0, $0C [Flow: branch]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora #$02.b		; 09 02 ; Logical OR #$02.b with accumulator [Writes: Accumulator] [Flags: NZ]
	eor $0DE0.w,X		; 5D E0 0D ; Exclusive OR accumulator with memory $0DE0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D90.w,X		; 9D 90 0D ; Store accumulator to $0D90.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D90.w,X		; 9D 90 0D ; Store accumulator to $0D90.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pea $04FF.w		; F4 FF 04 ; Push absolute address $04FF.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F5.b		; 00 F5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000004.l,X		; FF 04 00 00 ; Subtract with carry (long,X) $000004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pea $04FF.w		; F4 FF 04 ; Push absolute address $04FF.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F5.b		; 00 F5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000004.l,X		; FF 04 00 00 ; Subtract with carry (long,X) $000004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pea $08FF.w		; F4 FF 08 ; Push absolute address $08FF.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F5.b		; 00 F5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000008.l,X		; FF 08 00 00 ; Subtract with carry (long,X) $000008.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pea $08FF.w		; F4 FF 08 ; Push absolute address $08FF.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F5.b		; 00 F5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $004008.l,X		; FF 08 40 00 ; Subtract with carry (long,X) $004008.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	stz $07.b		; 64 07 ; Store zero to $07.b
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc $0DC0.w,X		; 7D C0 0D ; Add $0DC0.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc #$FF.b		; 69 FF ; Add #$FF.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
	lda #$E0.b		; A9 E0 ; Load #$E0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $09.b		; 85 09 ; Store accumulator to $09.b [Reads: Accumulator]
	jsl $05DF75.l		; 22 75 DF 05 ; Jump to subroutine long $05DF75.l [Writes: Stack Pointer] [Flow: call]
	jsl $06DC54.l		; 22 54 DC 06 ; Jump to subroutine long $06DC54.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tsb $06.b		; 04 06 ; Test and set bits $06.b [Reads: Accumulator] [Flags: Z]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $1CF0.w		; 8D F0 1C ; Store accumulator to $1CF0.w [Reads: Accumulator]
	sty $1CF1.w		; 8C F1 1C ; Store Y register to $1CF1.w [Reads: Y Index]
	jsl $06F129.l		; 22 29 F1 06 ; Jump to subroutine long $06F129.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $38		; 90 38 ; Branch if carry clear to $90, $38 [Flow: branch]
	jsl $07F4D0.l		; 22 D0 F4 07 ; Jump to subroutine long $07F4D0.l [Writes: Stack Pointer] [Flow: call]
	.db $B0, $32		; B0 32 ; Branch if carry set to $B0, $32 [Flow: branch]
	lda $F6.b		; A5 F6 ; Load $F6.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $2E		; 10 2E ; Branch if plus to $10, $2E [Flow: branch]
	lda $0F10.w,X		; BD 10 0F ; Load $0F10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $29		; D0 29 ; Branch if not equal to $D0, $29 [Flow: branch]
	lda $4D.b		; A5 4D ; Load $4D.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $23		; F0 23 ; Branch if equal to $F0, $23 [Flow: branch]
	jsr $F93F.w		; 20 3F F9 ; Jump to subroutine at $F93F.w [Writes: Stack Pointer] [Flow: call]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	lda $05E1A3.l,X		; BF A3 E1 05 ; Load long $05E1A3.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	cmp $2F.b		; C5 2F ; Compare $2F.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	.db $D0, $15		; D0 15 ; Branch if not equal to $D0, $15 [Flow: branch]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	lda $1CF0.w		; AD F0 1C ; Load $1CF0.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy $1CF1.w		; AC F1 1C ; Load $1CF1.w into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	lda #$40.b		; A9 40 ; Load #$40.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F10.w,X		; 9D 10 0F ; Store accumulator to $0F10.w,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	eor #$03.b		; 49 03 ; Exclusive OR #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sta $1CF0.w		; 8D F0 1C ; Store accumulator to $1CF0.w [Reads: Accumulator]
	sty $1CF1.w		; 8C F1 1C ; Store Y register to $1CF1.w [Reads: Y Index]
	jsl $06F129.l		; 22 29 F1 06 ; Jump to subroutine long $06F129.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $18		; 90 18 ; Branch if carry clear to $90, $18 [Flow: branch]
	lda $4D.b		; A5 4D ; Load $4D.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $12		; F0 12 ; Branch if equal to $F0, $12 [Flow: branch]
	lda $1CF0.w		; AD F0 1C ; Load $1CF0.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy $1CF1.w		; AC F1 1C ; Load $1CF1.w into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	jsr $F93F.w		; 20 3F F9 ; Jump to subroutine at $F93F.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor #$03.b		; 49 03 ; Exclusive OR #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	rtl		; [PATTERN: Memory clearing operation] 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sta $1CF0.w		; 8D F0 1C ; Store accumulator to $1CF0.w [Reads: Accumulator]
	sty $1CF1.w		; 8C F1 1C ; Store Y register to $1CF1.w [Reads: Y Index]
	stz $0223.w		; 9C 23 02 ; Store zero to $0223.w
	stz $1CD8.w		; 9C D8 1C ; Store zero to $1CD8.w
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $11.b		; 85 11 ; Store accumulator to $11.b [Reads: Accumulator]
	lda $10.b		; A5 10 ; Load $10.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $010C.w		; 8D 0C 01 ; Store accumulator to $010C.w [Reads: Accumulator]
	lda #$0E.b		; A9 0E ; Load #$0E.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $10.b		; 85 10 ; Store accumulator to $10.b [Reads: Accumulator]
	phx		; [PATTERN: Memory clearing operation] DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	jsl $0FF540.l		; 22 40 F5 0F ; Jump to subroutine long $0FF540.l [Writes: Stack Pointer] [Flow: call]
	stz $5E.b		; 64 5E ; Store zero to $5E.b
	jsl $0791B9.l		; 22 B9 91 07 ; Jump to subroutine long $0791B9.l [Writes: Stack Pointer] [Flow: call]
	stz $4D.b		; 64 4D ; Store zero to $4D.b
	stz $46.b		; 64 46 ; Store zero to $46.b
	lda $5D.b		; A5 5D ; Load $5D.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $04		; D0 04 ; Branch if not equal to $D0, $04 [Flow: branch]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $5D.b		; 85 5D ; Store accumulator to $5D.b [Reads: Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $E255.w		; 20 55 E2 ; Jump to subroutine at $E255.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $06E416.l		; 22 16 E4 06 ; Jump to subroutine long $06E416.l [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	jsl $07F4D0.l		; 22 D0 F4 07 ; Jump to subroutine long $07F4D0.l [Writes: Stack Pointer] [Flow: call]
	.db $B0, $29		; B0 29 ; Branch if carry set to $B0, $29 [Flow: branch]
	jsl $06F129.l		; 22 29 F1 06 ; Jump to subroutine long $06F129.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $09		; 90 09 ; Branch if carry clear to $90, $09 [Flow: branch]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $03F8.w		; 8D F8 03 ; Store accumulator to $03F8.w [Reads: Accumulator]
	sta $0D90.w,X		; 9D 90 0D ; Store accumulator to $0D90.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $15		; F0 15 ; Branch if equal to $F0, $15 [Flow: branch]
	stz $03F8.w		; [PATTERN: Memory clearing operation] 9C F8 03 ; Store zero to $03F8.w
	lda $0308.w		; AD 08 03 ; Load $0308.w into accumulator [Writes: Accumulator] [Flags: NZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0B		; F0 0B ; Branch if equal to $F0, $0B [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	jsl $1DFBD7.l		; 22 D7 FB 1D ; Jump to subroutine long $1DFBD7.l [Writes: Stack Pointer] [Flow: call]
	jsl $05AB9C.l		; 22 9C AB 05 ; Jump to subroutine long $05AB9C.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $E294.w		; 20 94 E2 ; Jump to subroutine at $E294.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $06E416.l		; 22 16 E4 06 ; Jump to subroutine long $06E416.l [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	jsl $07F4D0.l		; 22 D0 F4 07 ; Jump to subroutine long $07F4D0.l [Writes: Stack Pointer] [Flow: call]
	.db $B0, $48		; B0 48 ; Branch if carry set to $B0, $48 [Flow: branch]
	jsl $06F129.l		; 22 29 F1 06 ; Jump to subroutine long $06F129.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $09		; 90 09 ; Branch if carry clear to $90, $09 [Flow: branch]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $03F8.w		; 8D F8 03 ; Store accumulator to $03F8.w [Reads: Accumulator]
	sta $0D90.w,X		; 9D 90 0D ; Store accumulator to $0D90.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $34		; F0 34 ; Branch if equal to $F0, $34 [Flow: branch]
	stz $03F8.w		; 9C F8 03 ; Store zero to $03F8.w
	lda $0308.w		; AD 08 03 ; Load $0308.w into accumulator [Writes: Accumulator] [Flags: NZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $2A		; F0 2A ; Branch if equal to $F0, $2A [Flow: branch]
	lda #$1F.b		; A9 1F ; Load #$1F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB7C.l		; 22 7C BB 0D ; Jump to subroutine long $0DBB7C.l [Writes: Stack Pointer] [Flow: call]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	jsl $1BC264.l		; 22 64 C2 1B ; Jump to subroutine long $1BC264.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	jsr $F2D6.w		; 20 D6 F2 ; Jump to subroutine at $F2D6.w [Writes: Stack Pointer] [Flow: call]
	lda $0D10.w,X		; BD 10 0D ; Load $0D10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D10.w,Y		; 99 10 0D ; Store accumulator to $0D10.w,Y [Reads: Y Index, Accumulator]
	lda $0D30.w,X		; BD 30 0D ; Load $0D30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D30.w,Y		; 99 30 0D ; Store accumulator to $0D30.w,Y [Reads: Y Index, Accumulator]
	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D00.w,Y		; 99 00 0D ; Store accumulator to $0D00.w,Y [Reads: Y Index, Accumulator]
	lda $0D20.w,X		; BD 20 0D ; Load $0D20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D20.w,Y		; 99 20 0D ; Store accumulator to $0D20.w,Y [Reads: Y Index, Accumulator]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $E2F2.w		; 20 F2 E2 ; Jump to subroutine at $E2F2.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $03		; B0 03 ; Branch if carry set to $B0, $03 [Flow: branch]
	jsr $E37F.w		; 20 7F E3 ; Jump to subroutine at $E37F.w [Writes: Stack Pointer] [Flow: call]
	jmp $E6BF.w		; 4C BF E6 ; Jump to $E6BF.w [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $000026.l,X		; FF 26 00 00 ; Subtract with carry (long,X) $000026.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F9.b		; 00 F9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000026.l,X		; FF 26 00 00 ; Subtract with carry (long,X) $000026.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $000024.l,X		; FF 24 00 00 ; Subtract with carry (long,X) $000024.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C2.b		; 00 C2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F9.b		; 00 F9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000024.l,X		; FF 24 00 00 ; Subtract with carry (long,X) $000024.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C2.b		; 00 C2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $000028.l,X		; FF 28 00 00 ; Subtract with carry (long,X) $000028.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E4.b		; 00 E4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F9.b		; 00 F9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000028.l,X		; FF 28 00 00 ; Subtract with carry (long,X) $000028.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E6.b		; 00 E6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $004028.l,X		; FF 28 40 00 ; Subtract with carry (long,X) $004028.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E4.b		; 00 E4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $28FF.w,Y		; F9 FF 28 ; Subtract with carry $28FF.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	inc $40.b		; E6 40 ; Increment $40.b [Reads: Direct Page] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	stz $07.b		; 64 07 ; Store zero to $07.b
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc $0DC0.w,X		; 7D C0 0D ; Add $0DC0.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc #$FF.b		; 69 FF ; Add #$FF.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
	lda #$E2.b		; A9 E2 ; Load #$E2.b into accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $09.b		; 85 09 ; Store accumulator to $09.b [Reads: Accumulator]
	jsl $05DF75.l		; 22 75 DF 05 ; Jump to subroutine long $05DF75.l [Writes: Stack Pointer] [Flow: call]
	jsl $06DC54.l		; 22 54 DC 06 ; Jump to subroutine long $06DC54.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $82, $83, $01		; 82 83 01 ; Branch always long to $82, $83, $01 [Flow: branch]
	ora ($8B.b,X)		; 01 8B ; Logical OR ($8B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $E3AF.w		; 20 AF E3 ; Jump to subroutine at $E3AF.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $E3DC.w		; 20 DC E3 ; Jump to subroutine at $E3DC.w [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	jsl $1EF4F3.l		; 22 F3 F4 1E ; Jump to subroutine long $1EF4F3.l [Writes: Stack Pointer] [Flow: call]
	lda $7EF356.l		; AF 56 F3 7E ; Load long $7EF356.l into accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $E3A3.w,Y		; B9 A3 E3 ; Load $E3A3.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lda $E3A5.w,Y		; B9 A5 E3 ; Load $E3A5.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	jsl $05E1A7.l		; 22 A7 E1 05 ; Jump to subroutine long $05E1A7.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $0000C4.l,X		; FF C4 00 00 ; Subtract with carry (long,X) $0000C4.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CA.b		; 00 CA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $A9.b		; 02 A9 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $85.b		; 02 85 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $64.b		; 06 64 ; Arithmetic shift left $64.b [Reads: Direct Page] [Flags: NCZ]
	ora [$A9.b]		; 07 A9 ; OR accumulator with memory (long) [$A9.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpy $0885.w		; CC 85 08 ; Compare $0885.w with Y register [Reads: Y Index] [Flags: NCZ]
	lda #$E3.b		; A9 E3 ; Load #$E3.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $09.b		; 85 09 ; Store accumulator to $09.b [Reads: Accumulator]
	jsl $05DF75.l		; 22 75 DF 05 ; Jump to subroutine long $05DF75.l [Writes: Stack Pointer] [Flow: call]
	jsl $06DC54.l		; 22 54 DC 06 ; Jump to subroutine long $06DC54.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $E3FB.w		; 20 FB E3 ; Jump to subroutine at $E3FB.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $E55D.w		; 20 5D E5 ; Jump to subroutine at $E55D.w [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	lda $0F60.w,X		; BD 60 0F ; Load $0F60.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F60.w,X		; 9D 60 0F ; Store accumulator to $0F60.w,X [Reads: Accumulator, X Index]
	jsl $06F129.l		; 22 29 F1 06 ; Jump to subroutine long $06F129.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $0C		; 90 0C ; Branch if carry clear to $90, $0C [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	jsl $0FF540.l		; 22 40 F5 0F ; Jump to subroutine long $0FF540.l [Writes: Stack Pointer] [Flow: call]
	stz $5E.b		; 64 5E ; Store zero to $5E.b
	jsl $0791B9.l		; 22 B9 91 07 ; Jump to subroutine long $0791B9.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $0F60.w,X		; 9D 60 0F ; Store accumulator to $0F60.w,X [Reads: Accumulator, X Index]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0C		; D0 0C ; Branch if not equal to $D0, $0C [Flow: branch]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$02.b		; 69 02 ; Add #$02.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D90.w,X		; 9D 90 0D ; Store accumulator to $0D90.w,X [Reads: Accumulator, X Index]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	dec $00.b		; C6 00 ; Decrement $00.b [Reads: Direct Page] [Flags: NZ]
	.db $10, $FB		; 10 FB ; Branch if plus to $10, $FB [Flow: branch]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	jsl $07F4D0.l		; 22 D0 F4 07 ; Jump to subroutine long $07F4D0.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $01		; 90 01 ; Branch if carry clear to $90, $01 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpx $53.b		; E4 53 ; Compare $53.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	cpx $9E.b		; E4 9E ; Compare $9E.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $80, $0D		; 80 0D ; Branch always to $80, $0D [Flow: branch]
	ldy #$18.b		; [PATTERN: Memory clearing operation] A0 18 ; Load #$18.b into Y register [Writes: Y Index] [Flags: NZ]
	stz $02E9.w		; 9C E9 02 ; Store zero to $02E9.w
	jsl $0799AD.l		; 22 AD 99 07 ; Jump to subroutine long $0799AD.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $00.b		; 64 00 ; Store zero to $00.b
	lda $7EF344.l		; AF 44 F3 7E ; Load long $7EF344.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$01.b		; C9 01 ; Compare #$01.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $02		; D0 02 ; Branch if not equal to $D0, $02 [Flow: branch]
	inc $00.b		; E6 00 ; Increment $00.b [Reads: Direct Page] [Flags: NZ]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	jmp ($A7E4.w,X)		; 7C E4 A7 ; Jump indirect indexed to ($A7E4.w,X) [Reads: X Index] [Flow: jump]
	cpx $A7.b		; E4 A7 ; Compare $A7.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	cpx $A7.b		; E4 A7 ; Compare $A7.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	cpx $A7.b		; E4 A7 ; Compare $A7.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	cpx $AF.b		; E4 AF ; Compare $AF.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	mvp $7E,$F3		; 44 F3 7E ; Move block positive $7E,$F3 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $09		; D0 09 ; Branch if not equal to $D0, $09 [Flow: branch]
	lda #$4A.b		; A9 4A ; Load #$4A.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E1A7.l		; 22 A7 E1 05 ; Jump to subroutine long $05E1A7.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
.INDEX 16
	rep #$10		; C2 10
	ldx #$0212.w		; A2 12 02 ; Load #$0212.w into X register [Writes: X Index] [Flags: NZ]
	lda $7EF000.l,X		; BF 00 F0 7E ; Load long $7EF000.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	cmp #$00.b		; C9 00 ; Compare #$00.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $10, $E6		; 10 E6 ; Branch if plus to $10, $E6 [Flow: branch]
	lda #$4B.b		; A9 4B ; Load #$4B.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E1A7.l		; 22 A7 E1 05 ; Jump to subroutine long $05E1A7.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $F0.b		; A5 F0 ; Load $F0.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$40.b		; 29 40 ; Logical AND #$40.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $19		; F0 19 ; Branch if equal to $F0, $19 [Flow: branch]
	jsl $06F129.l		; 22 29 F1 06 ; Jump to subroutine long $06F129.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $12		; 90 12 ; Branch if carry clear to $90, $12 [Flow: branch]
	lda $0202.w		; AD 02 02 ; Load $0202.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$05.b		; C9 05 ; Compare #$05.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $0B		; D0 0B ; Branch if not equal to $D0, $0B [Flow: branch]
	lda $7EF344.l		; AF 44 F3 7E ; Load long $7EF344.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$01.b		; C9 01 ; Compare #$01.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	jsr $E4CF.w		; 20 CF E4 ; Jump to subroutine at $E4CF.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$4C.b		; A9 4C ; Load #$4C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E1A7.l		; 22 A7 E1 05 ; Jump to subroutine long $05E1A7.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $7EF344.l		; AF 44 F3 7E ; Load long $7EF344.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$01.b		; C9 01 ; Compare #$01.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $2E		; D0 2E ; Branch if not equal to $D0, $2E [Flow: branch]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF344.l		; 8F 44 F3 7E ; Store accumulator (long) $7EF344.l [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
.INDEX 16
	rep #$10		; C2 10
	ldx #$0212.w		; A2 12 02 ; Load #$0212.w into X register [Writes: X Index] [Flags: NZ]
	lda $7EF000.l,X		; BF 00 F0 7E ; Load long $7EF000.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$80.b		; 09 80 ; Logical OR #$80.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF000.l,X		; 9F 00 F0 7E ; Store accumulator (long,X) $7EF000.l,X [Reads: Accumulator, X Index]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	stz $012E.w		; 9C 2E 01 ; Store zero to $012E.w
	jsl $0DDB7F.l		; 22 7F DB 0D ; Jump to subroutine long $0DDB7F.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda #$4B.b		; A9 4B ; Load #$4B.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	lda #$0D.b		; A9 0D ; Load #$0D.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB6E.l		; 22 6E BB 0D ; Jump to subroutine long $0DBB6E.l [Writes: Stack Pointer] [Flow: call]
	stz $0ABF.w		; 9C BF 0A ; Store zero to $0ABF.w
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $AE08.w,X		; FD 08 AE ; Subtract with carry $AE08.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $BE		; 10 BE ; Branch if plus to $10, $BE [Flow: branch]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ldx $FE00.w		; AE 00 FE ; Load $FE00.w into X register [Writes: X Index] [Flags: NZ]
	.db $10, $BE		; 10 BE ; Branch if plus to $10, $BE [Flow: branch]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	lda $10FF00.l		; AF 00 FF 10 ; Load long $10FF00.l into accumulator [Writes: Accumulator] [Flags: NZ]
	lda $090000.l,X		; BF 00 00 09 ; Load long $090000.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda $110000.l		; AF 00 00 11 ; Load long $110000.l into accumulator [Writes: Accumulator] [Flags: NZ]
	lda $0A0100.l,X		; BF 00 01 0A ; Load long $0A0100.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda $120100.l		; AF 00 01 12 ; Load long $120100.l into accumulator [Writes: Accumulator] [Flags: NZ]
	lda $0B0000.l,X		; BF 00 00 0B ; Load long $0B0000.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda $120000.l		; AF 00 00 12 ; Load long $120000.l into accumulator [Writes: Accumulator] [Flags: NZ]
	lda $0AFF00.l,X		; BF 00 FF 0A ; Load long $0AFF00.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldx $FF00.w		; AE 00 FF ; Load $FF00.w into X register [Writes: X Index] [Flags: NZ]
	ora ($BE.b)		; 12 BE ; OR accumulator with memory (indirect) ($BE.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$AE.b		; 09 AE ; Logical OR #$AE.b with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($BE.b),Y		; 11 BE ; OR accumulator with memory ($BE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($0080.w,X)		; FC 80 00 ; Jump to subroutine indirect indexed ($0080.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $0F.b,X		; F5 0F ; Subtract $0F.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	stx $04.b		; 86 04 ; Store X register to $04.b [Reads: X Index]
	sbc $860F.w,X		; FD 0F 86 ; Subtract with carry $860F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	mvp $04,$00		; 44 00 04 ; Move block positive $04,$00 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $82, $00, $20		; 82 00 20 ; Branch always long to $82, $00, $20 [Flow: branch]
	.db $50, $FA		; 50 FA ; Branch if overflow clear to $50, $FA [Flow: branch]
	jsl $06F864.l		; 22 64 F8 06 ; Jump to subroutine long $06F864.l [Writes: Stack Pointer] [Flow: call]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	stz $01.b		; 64 01 ; Store zero to $01.b
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
.ACCU 16
.INDEX 16
	rep #$30		; C2 30
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$00FF.w		; 29 FF 00 ; Logical AND #$00FF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ldy $90.b		; A4 90 ; Load $90.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	lda $E509.w,X		; BD 09 E5 ; Load $E509.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0FA8.w		; 6D A8 0F ; Add $0FA8.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0000.w,Y		; 99 00 00 ; Store accumulator to $0000.w,Y [Reads: Y Index, Accumulator]
	lda $E50A.w,X		; BD 0A E5 ; Load $E50A.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0FA9.w		; 6D A9 0F ; Add $0FA9.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0001.w,Y		; 99 01 00 ; Store accumulator to $0001.w,Y [Reads: Y Index, Accumulator]
	lda $E50B.w,X		; BD 0B E5 ; Load $E50B.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0002.w,Y		; 99 02 00 ; Store accumulator to $0002.w,Y [Reads: Y Index, Accumulator]
	lda $E50D.w,X		; BD 0D E5 ; Load $E50D.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0FA8.w		; 6D A8 0F ; Add $0FA8.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0004.w,Y		; 99 04 00 ; Store accumulator to $0004.w,Y [Reads: Y Index, Accumulator]
	lda $E50E.w,X		; BD 0E E5 ; Load $E50E.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0FA9.w		; 6D A9 0F ; Add $0FA9.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0005.w,Y		; 99 05 00 ; Store accumulator to $0005.w,Y [Reads: Y Index, Accumulator]
	lda $E50F.w,X		; BD 0F E5 ; Load $E50F.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0006.w,Y		; 99 06 00 ; Store accumulator to $0006.w,Y [Reads: Y Index, Accumulator]
	ldx #$0000.w		; A2 00 00 ; Load #$0000.w into X register [Writes: X Index] [Flags: NZ]
	lda #$0002.w		; A9 02 00 ; Load #$0002.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E.b		; 85 0E ; Store accumulator to $0E.b [Reads: Accumulator]
	lda $E549.w,X		; BD 49 E5 ; Load $E549.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0FA8.w		; 6D A8 0F ; Add $0FA8.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0008.w,Y		; 99 08 00 ; Store accumulator to $0008.w,Y [Reads: Y Index, Accumulator]
	lda $E54A.w,X		; BD 4A E5 ; Load $E54A.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0FA9.w		; 6D A9 0F ; Add $0FA9.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0009.w,Y		; 99 09 00 ; Store accumulator to $0009.w,Y [Reads: Y Index, Accumulator]
	lda $E54B.w,X		; BD 4B E5 ; Load $E54B.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $04.b		; 45 04 ; Exclusive OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $000A.w,Y		; 99 0A 00 ; Store accumulator to $000A.w,Y [Reads: Y Index, Accumulator]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dec $0E.b		; C6 0E ; Decrement $0E.b [Reads: Direct Page] [Flags: NZ]
	.db $10, $D8		; 10 D8 ; Branch if plus to $10, $D8 [Flow: branch]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$0003.w		; E9 03 00 ; Subtract #$0003.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0003.w		; C9 03 00 ; Compare #$0003.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $05		; 90 05 ; Branch if carry clear to $90, $05 [Flow: branch]
	ldx #$0000.w		; A2 00 00 ; Load #$0000.w into X register [Writes: X Index] [Flags: NZ]
	.db $80, $03		; 80 03 ; Branch always to $80, $03 [Flow: branch]
	ldx #$0004.w		; A2 04 00 ; Load #$0004.w into X register [Writes: X Index] [Flags: NZ]
	lda $E555.w,X		; BD 55 E5 ; Load $E555.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0FA8.w		; 6D A8 0F ; Add $0FA8.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0008.w,Y		; 99 08 00 ; Store accumulator to $0008.w,Y [Reads: Y Index, Accumulator]
	lda $E556.w,X		; BD 56 E5 ; Load $E556.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0FA9.w		; 6D A9 0F ; Add $0FA9.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0009.w,Y		; 99 09 00 ; Store accumulator to $0009.w,Y [Reads: Y Index, Accumulator]
	lda $E557.w,X		; BD 57 E5 ; Load $E557.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $000A.w,Y		; 99 0A 00 ; Store accumulator to $000A.w,Y [Reads: Y Index, Accumulator]
	ldy $92.b		; A4 92 ; Load $92.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	lda #$0000.w		; A9 00 00 ; Load #$0000.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0000.w,Y		; 99 00 00 ; Store accumulator to $0000.w,Y [Reads: Y Index, Accumulator]
	lda #$0202.w		; A9 02 02 ; Load #$0202.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0002.w,Y		; 99 02 00 ; Store accumulator to $0002.w,Y [Reads: Y Index, Accumulator]
	sta $0004.w,Y		; 99 04 00 ; Store accumulator to $0004.w,Y [Reads: Y Index, Accumulator]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda #$05.b		; A9 05 ; Load #$05.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$FF.b		; A0 FF ; Load #$FF.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $06FEB4.l		; 22 B4 FE 06 ; Jump to subroutine long $06FEB4.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $E633.w		; 20 33 E6 ; Jump to subroutine at $E633.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DA0.w,X		; BD A0 0D ; Load $0DA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $1D		; D0 1D ; Branch if not equal to $D0, $1D [Flow: branch]
	jsl $06E416.l		; 22 16 E4 06 ; Jump to subroutine long $06E416.l [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	jsr $F93F.w		; 20 3F F9 ; Jump to subroutine at $F93F.w [Writes: Stack Pointer] [Flow: call]
	cpy #$02.b		; C0 02 ; Compare #$02.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $D0, $0F		; D0 0F ; Branch if not equal to $D0, $0F [Flow: branch]
	lda $0BB0.w,X		; BD B0 0B ; Load $0BB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$09.b		; C9 09 ; Compare #$09.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	inc $0642.w		; EE 42 06 ; Increment $0642.w [Flags: NZ]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DA0.w,X		; 9D A0 0D ; Store accumulator to $0DA0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0D50.w,X		; BD 50 0D ; Load $0D50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $06		; F0 06 ; Branch if equal to $F0, $06 [Flow: branch]
	.db $10, $03		; 10 03 ; Branch if plus to $10, $03 [Flow: branch]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $80, $01		; 80 01 ; Branch always to $80, $01 [Flow: branch]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0D40.w,X		; BD 40 0D ; Load $0D40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $06		; F0 06 ; Branch if equal to $F0, $06 [Flow: branch]
	.db $10, $03		; 10 03 ; Branch if plus to $10, $03 [Flow: branch]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $80, $01		; 80 01 ; Branch always to $80, $01 [Flow: branch]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $E67D.w		; 20 7D E6 ; Jump to subroutine at $E67D.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	inc $0BA0.w,X		; FE A0 0B ; Increment memory $0BA0.w,X [Reads: X Index] [Flags: NZ]
	lda $0D10.w,X		; BD 10 0D ; Load $0D10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D90.w,X		; 9D 90 0D ; Store accumulator to $0D90.w,X [Reads: Accumulator, X Index]
	lda $0D30.w,X		; BD 30 0D ; Load $0D30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DA0.w,X		; 9D A0 0D ; Store accumulator to $0DA0.w,X [Reads: Accumulator, X Index]
	lda #$F7.b		; A9 F7 ; Load #$F7.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $E6AA.w		; 20 AA E6 ; Jump to subroutine at $E6AA.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$09.b],Y		; F7 09 ; Subtract with carry (long indexed) [$09.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$09.b],Y		; F7 09 ; Subtract with carry (long indexed) [$09.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $0E30.w,X		; BD 30 0E ; Load $0E30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $05		; F0 05 ; Branch if equal to $F0, $05 [Flow: branch]
	jsl $1AFECF.l		; 22 CF FE 1A ; Jump to subroutine long $1AFECF.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $04		; B0 04 ; Branch if carry set to $B0, $04 [Flow: branch]
	jsl $1AF92C.l		; 22 2C F9 1A ; Jump to subroutine long $1AF92C.l [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $2E		; B0 2E ; Branch if carry set to $B0, $2E [Flow: branch]
	lda $1B.b		; A5 1B ; Load $1B.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $16		; F0 16 ; Branch if equal to $F0, $16 [Flow: branch]
	jsl $05DCA2.l		; 22 A2 DC 05 ; Jump to subroutine long $05DCA2.l [Writes: Stack Pointer] [Flow: call]
	jsr $F93F.w		; 20 3F F9 ; Jump to subroutine at $F93F.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor #$03.b		; 49 03 ; Exclusive OR #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	lda #$AD.b		; A9 AD ; Load #$AD.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E1A7.l		; 22 A7 E1 05 ; Jump to subroutine long $05E1A7.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $06		; D0 06 ; Branch if not equal to $D0, $06 [Flow: branch]
	jsl $06F129.l		; 22 29 F1 06 ; Jump to subroutine long $06F129.l [Writes: Stack Pointer] [Flow: call]
	.db $B0, $18		; B0 18 ; Branch if carry set to $B0, $18 [Flow: branch]
	jsl $05DCA2.l		; 22 A2 DC 05 ; Jump to subroutine long $05DCA2.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $1B		; 90 1B ; Branch if carry clear to $90, $1B [Flow: branch]
	jsr $F9ED.w		; 20 ED F9 ; Jump to subroutine at $F9ED.w [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sbc [$8D.b]		; E7 8D ; Subtract with carry (long) [$8D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$31.b]		; E7 31 ; Subtract with carry (long) [$31.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sta [$E8.b]		; 87 E8 ; Store accumulator (long) [$E8.b] [Reads: Direct Page, Accumulator]
	jsr $F93F.w		; 20 3F F9 ; Jump to subroutine at $F93F.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor #$03.b		; 49 03 ; Exclusive OR #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	.db $80, $E1		; 80 E1 ; Branch always to $80, $E1 [Flow: branch]
	cpx #$20.b		; E0 20 ; Compare #$20.b with X register [Reads: X Index] [Flags: NCZ]
	sbc $F0BD00.l,X		; FF 00 BD F0 ; Subtract with carry (long,X) $F0BD00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $3ED0.w		; 0D D0 3E ; Logical OR $3ED0.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ldy $0DB0.w,X		; BC B0 0D ; Load Y register $0DB0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $E716.w,Y		; 79 16 E7 ; Add $E716.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $0D10.w,X		; DD 10 0D ; Compare accumulator $0D10.w,X [Reads: X Index] [Flags: NCZ]
	.db $D0, $2F		; D0 2F ; Branch if not equal to $D0, $2F [Flow: branch]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $E716.w,Y		; 79 16 E7 ; Add $E716.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $0DA0.w,X		; BD A0 0D ; Load $0DA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $E718.w,Y		; 79 18 E7 ; Add $E718.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $0D30.w,X		; DD 30 0D ; Compare accumulator $0D30.w,X [Reads: X Index] [Flags: NCZ]
	.db $D0, $1D		; D0 1D ; Branch if not equal to $D0, $1D [Flow: branch]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$01.b		; 49 01 ; Exclusive OR #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $E6A2.w,Y		; B9 A2 E6 ; Load $E6A2.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $E6A6.w,Y		; B9 A6 E6 ; Load $E6A6.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	lda $0DB0.w,X		; BD B0 0D ; Load $0DB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$01.b		; 49 01 ; Exclusive OR #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DB0.w,X		; 9D B0 0D ; Store accumulator to $0DB0.w,X [Reads: Accumulator, X Index]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	lda $0F60.w,X		; BD 60 0F ; Load $0F60.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F60.w,X		; 9D 60 0F ; Store accumulator to $0F60.w,X [Reads: Accumulator, X Index]
	lda #$2F.b		; A9 2F ; Load #$2F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E1F0.l		; 22 F0 E1 05 ; Jump to subroutine long $05E1F0.l [Writes: Stack Pointer] [Flow: call]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $0F60.w,X		; 9D 60 0F ; Store accumulator to $0F60.w,X [Reads: Accumulator, X Index]
	.db $90, $0B		; 90 0B ; Branch if carry clear to $90, $0B [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	jsl $09C02F.l		; 22 2F C0 09 ; Jump to subroutine long $09C02F.l [Writes: Stack Pointer] [Flow: call]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $0EB0.w,X		; 9E B0 0E ; Store zero to $0EB0.w,X [Reads: X Index]
	ldy $0FDE.w		; AC DE 0F ; Load $0FDE.w into Y register [Writes: Y Index] [Flags: NZ]
	lda $0B18.w,Y		; B9 18 0B ; Load $0B18.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $0B20.w,Y		; B9 20 0B ; Load $0B20.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $01.b		; 85 01 ; Store accumulator to $01.b [Reads: Accumulator]
	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	lda $0D20.w,X		; BD 20 0D ; Load $0D20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $03.b		; 85 03 ; Store accumulator to $03.b [Reads: Accumulator]
.ACCU 16
	rep #$20		; C2 20
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $02.b		; [PATTERN: Memory clearing operation] C5 02 ; Compare $02.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	.db $90, $45		; 90 45 ; Branch if carry clear to $90, $45 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	stz $0D50.w,X		; 9E 50 0D ; Store zero to $0D50.w,X [Reads: X Index]
	stz $0D40.w,X		; 9E 40 0D ; Store zero to $0D40.w,X [Reads: X Index]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F60.w,X		; 9D 60 0F ; Store accumulator to $0F60.w,X [Reads: Accumulator, X Index]
	lda $0B08.w,Y		; B9 08 0B ; Load $0B08.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	lda $0B10.w,Y		; B9 10 0B ; Load $0B10.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $03.b		; 85 03 ; Store accumulator to $03.b [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
.ACCU 16
.INDEX 16
	rep #$30		; C2 30
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $0708.w		; ED 08 07 ; Subtract $0708.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	and $070A.w		; 2D 0A 07 ; Logical AND $070A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $070C.w		; ED 0C 07 ; Subtract $070C.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	and $070E.w		; 2D 0E 07 ; Logical AND $070E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $04.b		; 65 04 ; Add $04.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsl $1BC952.l		; 22 52 C9 1B ; Jump to subroutine long $1BC952.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda #$9D10.w		; A9 10 9D ; Load #$9D10.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0D		; F0 0D ; Branch if equal to $F0, $0D [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$8D01.w		; A9 01 8D ; Load #$8D01.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cpx $02.b		; E4 02 ; Compare $02.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	lda $0B08.w,Y		; B9 08 0B ; Load $0B08.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	lda $0B10.w,Y		; B9 10 0B ; Load $0B10.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $05.b		; 85 05 ; Store accumulator to $05.b [Reads: Accumulator]
	lda $0B18.w,Y		; B9 18 0B ; Load $0B18.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	lda $0B20.w,Y		; B9 20 0B ; Load $0B20.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $07.b		; 85 07 ; Store accumulator to $07.b [Reads: Accumulator]
	lda #$2240.w		; A9 40 22 ; Load #$2240.w into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $A506EA.l		; 22 EA 06 A5 ; Jump to subroutine long $A506EA.l [Writes: Stack Pointer] [Flow: call]
	brk $9D.b		; 00 9D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; [PATTERN: Memory clearing operation] 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	ora $01A5.w		; 0D A5 01 ; Logical OR $01A5.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	stz $0DE0.w,X		; 9E E0 0D ; Store zero to $0DE0.w,X [Reads: X Index]
	stz $0EB0.w,X		; 9E B0 0E ; Store zero to $0EB0.w,X [Reads: X Index]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$9D01.w		; 29 01 9D ; Logical AND #$9D01.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cpy #$600D.w		; C0 0D 60 ; Compare #$600D.w with Y register [Reads: Y Index] [Flags: NCZ]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $4D		; D0 4D ; Branch if not equal to $D0, $4D [Flow: branch]
	ldy $0FDE.w		; AC DE 0F ; Load $0FDE.w into Y register [Writes: Y Index] [Flags: NZ]
	lda $0B18.w,Y		; B9 18 0B ; Load $0B18.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D00.w,X		; 9D 00 0D ; Store accumulator to $0D00.w,X [Reads: Accumulator, X Index]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $0B20.w,Y		; B9 20 0B ; Load $0B20.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D20.w,X		; 9D 20 0D ; Store accumulator to $0D20.w,X [Reads: Accumulator, X Index]
	sta $01.b		; 85 01 ; Store accumulator to $01.b [Reads: Accumulator]
	lda $0B08.w,Y		; B9 08 0B ; Load $0B08.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D10.w,X		; 9D 10 0D ; Store accumulator to $0D10.w,X [Reads: Accumulator, X Index]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	lda $0B10.w,Y		; B9 10 0B ; Load $0B10.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D30.w,X		; 9D 30 0D ; Store accumulator to $0D30.w,X [Reads: Accumulator, X Index]
	sta $03.b		; 85 03 ; Store accumulator to $03.b [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
.ACCU 16
.INDEX 16
	rep #$30		; C2 30
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $0708.w		; ED 08 07 ; Subtract $0708.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	and $070A.w		; 2D 0A 07 ; Logical AND $070A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $070C.w		; ED 0C 07 ; Subtract $070C.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	and $070E.w		; 2D 0E 07 ; Logical AND $070E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $04.b		; 65 04 ; Add $04.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	jsl $1BC952.l		; 22 52 C9 1B ; Jump to subroutine long $1BC952.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	inc $0D80.w,X		; [PATTERN: Memory clearing operation] FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	jsr $F9ED.w		; 20 ED F9 ; Jump to subroutine at $F9ED.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	stz $02E4.w		; 9C E4 02 ; Store zero to $02E4.w
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $E896.w		; 20 96 E8 ; Jump to subroutine at $E896.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$9D02.w		; A9 02 9D ; Load #$9D02.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $B0, $0E		; B0 0E ; Branch if carry set to $B0, $0E [Flow: branch]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	inc $0BA0.w,X		; FE A0 0B ; Increment memory $0BA0.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $E8B2.w		; 20 B2 E8 ; Jump to subroutine at $E8B2.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	rol $CA.b,X		; 36 CA ; Rotate left $CA.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	rol $00.b,X		; 36 00 ; Rotate left $00.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $20EA.w		; 4D EA 20 ; Exclusive OR $20EA.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lsr $22F9.w		; 4E F9 22 ; Logical shift right $22F9.w [Flags: NCZ]
	ldx #$05DC.w		; A2 DC 05 ; Load #$05DC.w into X register [Writes: X Index] [Flags: NZ]
	jsl $1EF4F3.l		; 22 F3 F4 1E ; Jump to subroutine long $1EF4F3.l [Writes: Stack Pointer] [Flow: call]
	lda #$9DFF.w		; A9 FF 9D ; Load #$9DFF.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $30, $0E		; 30 0E ; Branch if minus to $30, $0E [Flow: branch]
	jsr $B88D.w		; 20 8D B8 ; Jump to subroutine at $B88D.w [Writes: Stack Pointer] [Flow: call]
	lda $0F60.w,X		; BD 60 0F ; Load $0F60.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda #$9D07.w		; A9 07 9D ; Load #$9D07.w into accumulator [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $F12922.l		; 0F 22 29 F1 ; OR accumulator with memory (long) $F12922.l [Writes: Accumulator] [Flags: NZ]
	asl $90.b		; 06 90 ; Arithmetic shift left $90.b [Reads: Direct Page] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DB0.w,X		; 9D B0 0D ; Store accumulator to $0DB0.w,X [Reads: Accumulator, X Index]
	lda #$9D03.w		; A9 03 9D ; Load #$9D03.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $80, $0D		; 80 0D ; Branch always to $80, $0D [Flow: branch]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $0F60.w,X		; 9D 60 0F ; Store accumulator to $0F60.w,X [Reads: Accumulator, X Index]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	sbc [$E8.b],Y		; F7 E8 ; Subtract with carry (long indexed) [$E8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr $E9.b		; 46 E9 ; Logical shift right $E9.b [Reads: Direct Page] [Flags: NCZ]
	adc ($E9.b,S),Y		; 73 E9 ; Add with carry (stack relative indirect indexed) ($E9.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc #$18E8.w		; E9 E8 18 ; Subtract #$18E8.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	jsl $05DCA2.l		; 22 A2 DC 05 ; Jump to subroutine long $05DCA2.l [Writes: Stack Pointer] [Flow: call]
	jsr $F93F.w		; 20 3F F9 ; Jump to subroutine at $F93F.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor #$9D03.w		; 49 03 9D ; Exclusive OR #$9D03.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $B0, $0E		; B0 0E ; Branch if carry set to $B0, $0E [Flow: branch]
	jsl $06F129.l		; 22 29 F1 06 ; Jump to subroutine long $06F129.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $27		; 90 27 ; Branch if carry clear to $90, $27 [Flow: branch]
	jsl $0791B9.l		; 22 B9 91 07 ; Jump to subroutine long $0791B9.l [Writes: Stack Pointer] [Flow: call]
	jsr $F93F.w		; 20 3F F9 ; Jump to subroutine at $F93F.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor #$9D03.w		; 49 03 9D ; Exclusive OR #$9D03.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cpx #$490D.w		; E0 0D 49 ; Compare #$490D.w with X register [Reads: X Index] [Flags: NCZ]
	ora ($09.b,X)		; 01 09 ; Logical OR ($09.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $9D.b		; 02 9D ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $B0, $0E		; B0 0E ; Branch if carry set to $B0, $0E [Flow: branch]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	and #$1A01.w		; 29 01 1A ; Logical AND #$1A01.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D80.w,X		; 9D 80 0D ; Store accumulator to $0D80.w,X [Reads: Accumulator, X Index]
	lda $E8F3.w,Y		; B9 F3 E8 ; Load $E8F3.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda #$9D20.w		; [PATTERN: Memory clearing operation] A9 20 9D ; Load #$9D20.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0D		; F0 0D ; Branch if equal to $F0, $0D [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $0D50.w,X		; 9E 50 0D ; Store zero to $0D50.w,X [Reads: X Index]
	stz $0D40.w,X		; 9E 40 0D ; Store zero to $0D40.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$9D01.w		; 29 01 9D ; Logical AND #$9D01.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cpy #$200D.w		; C0 0D 20 ; Compare #$200D.w with Y register [Reads: Y Index] [Flags: NCZ]
	sbc $60F9.w		; ED F9 60 ; Subtract $60F9.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $ED		; D0 ED ; Branch if not equal to $D0, $ED [Flow: branch]
	jsr $E9AC.w		; 20 AC E9 ; Jump to subroutine at $E9AC.w [Writes: Stack Pointer] [Flow: call]
	jsr $E9BA.w		; 20 BA E9 ; Jump to subroutine at $E9BA.w [Writes: Stack Pointer] [Flow: call]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0B		; D0 0B ; Branch if not equal to $D0, $0B [Flow: branch]
	lda #$9DFF.w		; A9 FF 9D ; Load #$9DFF.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $90, $0D		; 90 0D ; Branch if carry clear to $90, $0D [Flow: branch]
	lda #$9D02.w		; A9 02 9D ; Load #$9D02.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $B0, $0E		; B0 0E ; Branch if carry set to $B0, $0E [Flow: branch]
	rts		; [PATTERN: Memory clearing operation] 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	dec $0D90.w,X		; DE 90 0D ; Decrement memory $0D90.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	stz $0E80.w,X		; 9E 80 0E ; Store zero to $0E80.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sei		; 78 ; Set interrupt disable flag [Flags: I]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $80, $03		; 80 03 ; Branch always to $80, $03 [Flow: branch]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $0DF0BD.l,X		; FF BD F0 0D ; Subtract with carry (long,X) $0DF0BD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $D0, $C0		; D0 C0 ; Branch if not equal to $D0, $C0 [Flow: branch]
	jsr $E9AC.w		; 20 AC E9 ; Jump to subroutine at $E9AC.w [Writes: Stack Pointer] [Flow: call]
	jsr $E9BA.w		; 20 BA E9 ; Jump to subroutine at $E9BA.w [Writes: Stack Pointer] [Flow: call]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $DE		; D0 DE ; Branch if not equal to $D0, $DE [Flow: branch]
	ldy $0DA0.w,X		; BC A0 0D ; Load Y register $0DA0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	inc $0DA0.w,X		; FE A0 0D ; Increment memory $0DA0.w,X [Reads: X Index] [Flags: NZ]
	lda $E96C.w,Y		; B9 6C E9 ; Load $E96C.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D90.w,X		; 9D 90 0D ; Store accumulator to $0D90.w,X [Reads: Accumulator, X Index]
	lda $E96F.w,Y		; B9 6F E9 ; Load $E96F.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $D1		; 30 D1 ; Branch if minus to $30, $D1 [Flow: branch]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$A0A6.w		; A9 A6 A0 ; Load #$A0A6.w into accumulator [Writes: Accumulator] [Flags: NZ]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $05E2.w,Y		; 19 E2 05 ; OR accumulator with memory $05E2.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $90, $03		; 90 03 ; Branch if carry clear to $90, $03 [Flow: branch]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	lda $0DB0.w,X		; BD B0 0D ; Load $0DB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D80.w,X		; 9D 80 0D ; Store accumulator to $0D80.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $1AFB2C.l		; 22 2C FB 1A ; Jump to subroutine long $1AFB2C.l [Writes: Stack Pointer] [Flow: call]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$9D01.w		; 29 01 9D ; Logical AND #$9D01.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cpy #$600D.w		; C0 0D 60 ; Compare #$600D.w with Y register [Reads: Y Index] [Flags: NCZ]
	ldy $0EB0.w,X		; BC B0 0E ; Load Y register $0EB0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $E8AA.w,Y		; B9 AA E8 ; Load $E8AA.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $E8AE.w,Y		; B9 AE E8 ; Load $E8AE.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	jsr $F9ED.w		; 20 ED F9 ; Jump to subroutine at $F9ED.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $00002C.l,X		; FF 2C 00 00 ; Subtract with carry (long,X) $00002C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EE.b		; 00 EE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $2CFF.w,Y		; F9 FF 2C ; Subtract with carry $2CFF.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EE.b		; 00 EE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $00002A.l,X		; FF 2A 00 00 ; Subtract with carry (long,X) $00002A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CA.b		; 00 CA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $2AFF.w,Y		; F9 FF 2A ; Subtract with carry $2AFF.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CA.b		; 00 CA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $00002E.l,X		; FF 2E 00 00 ; Subtract with carry (long,X) $00002E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CC.b		; 00 CC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $2EFF.w,Y		; F9 FF 2E ; Subtract with carry $2EFF.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CE.b		; 00 CE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $00402E.l,X		; FF 2E 40 00 ; Subtract with carry (long,X) $00402E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CC.b		; 00 CC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $2EFF.w,Y		; F9 FF 2E ; Subtract with carry $2EFF.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	dec $0048.w		; CE 48 00 ; Decrement $0048.w [Flags: NZ]
	cop $A9.b		; 02 A9 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $85.b		; 02 85 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $64.b		; 06 64 ; Arithmetic shift left $64.b [Reads: Direct Page] [Flags: NCZ]
	ora [$BD.b]		; 07 BD ; OR accumulator with memory (long) [$BD.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx #$0A0D.w		; E0 0D 0A ; Compare #$0A0D.w with X register [Reads: X Index] [Flags: NCZ]
	adc $0DC0.w,X		; 7D C0 0D ; Add $0DC0.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc #$85CD.w		; 69 CD 85 ; Add #$85CD.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	lda #$69E9.w		; A9 E9 69 ; Load #$69E9.w into accumulator [Writes: Accumulator] [Flags: NZ]
	brk $85.b		; 00 85 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$7522.w		; 09 22 75 ; Logical OR #$7522.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp $542205.l,X		; DF 05 22 54 ; Compare accumulator (long,X) $542205.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	jmp.w [$6006]		; DC 06 60 ; Jump long indirect [$6006] [Flow: jump]
	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $EA79.w		; 20 79 EA ; Jump to subroutine at $EA79.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $EBA7.w		; 20 A7 EB ; Jump to subroutine at $EBA7.w [Writes: Stack Pointer] [Flow: call]
	lda $03.b		; A5 03 ; Load $03.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D90.w,X		; 9D 90 0D ; Store accumulator to $0D90.w,X [Reads: Accumulator, X Index]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	jsl $068000.l		; 22 00 80 06 ; Jump to subroutine long $068000.l [Writes: Stack Pointer] [Flow: call]
	jsl $1EF4F3.l		; 22 F3 F4 1E ; Jump to subroutine long $1EF4F3.l [Writes: Stack Pointer] [Flow: call]
	jsl $07F4D0.l		; 22 D0 F4 07 ; Jump to subroutine long $07F4D0.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $01		; 90 01 ; Branch if carry clear to $90, $01 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	.db $D0, $0A		; D0 0A ; Branch if not equal to $D0, $0A [Flow: branch]
	lda #$9D01.w		; A9 01 9D ; Load #$9D01.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cpy #$A90D.w		; C0 0D A9 ; Compare #$A90D.w with Y register [Reads: Y Index] [Flags: NCZ]
	trb $9D.b		; 14 9D ; Test and reset bits $9D.b [Reads: Accumulator] [Flags: Z]
	.db $F0, $0D		; F0 0D ; Branch if equal to $F0, $0D [Flow: branch]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	stz $0DC0.w,X		; 9E C0 0D ; Store zero to $0DC0.w,X [Reads: X Index]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	cmp [$EA.b]		; C7 EA ; Compare accumulator (long) [$EA.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sbc $17EA.w		; ED EA 17 ; Subtract $17EA.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	eor $A9EB.w,X		; 5D EB A9 ; Exclusive OR accumulator with memory $A9EB.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pei ($A0.b)		; D4 A0 ; Push effective indirect address ($A0.b) [Reads: Direct Page] [Writes: Stack Pointer]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda [$E1.b]		; A7 E1 ; Load accumulator (long) [$E1.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $60.b		; 05 60 ; Logical OR $60.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0B		; D0 0B ; Branch if not equal to $D0, $0B [Flow: branch]
	lda $0E90.w,X		; BD 90 0E ; Load $0E90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $06		; F0 06 ; Branch if equal to $F0, $06 [Flow: branch]
	lda #$9D03.w		; A9 03 9D ; Load #$9D03.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $80, $0D		; 80 0D ; Branch always to $80, $0D [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $7EF3C9.l		; AF C9 F3 7E ; Load long $7EF3C9.l into accumulator [Writes: Accumulator] [Flags: NZ]
	and #$D002.w		; 29 02 D0 ; Logical AND #$D002.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp $A0D1A9.l,X		; DF A9 D1 A0 ; Compare accumulator (long,X) $A0D1A9.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda [$E1.b]		; A7 E1 ; Load accumulator (long) [$E1.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $90.b		; 05 90 ; Logical OR $90.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $FE.b,S		; 03 FE ; OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $80, $0D		; 80 0D ; Branch always to $80, $0D [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $1CE8.w		; AD E8 1C ; Load $1CE8.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $19		; D0 19 ; Branch if not equal to $D0, $19 [Flow: branch]
.ACCU 16
	rep #$20		; C2 20
	lda $7EF360.l		; AF 60 F3 7E ; Load long $7EF360.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$0064.w		; C9 64 00 ; Compare #$0064.w with accumulator [Reads: Accumulator] [Flags: NCZ]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	.db $90, $0C		; 90 0C ; Branch if carry clear to $90, $0C [Flow: branch]
	lda #$D2.b		; A9 D2 ; Load #$D2.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$D3.b		; A9 D3 ; Load #$D3.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; [PATTERN: Memory clearing operation] 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ldy #$16.b		; A0 16 ; Load #$16.b into Y register [Writes: Y Index] [Flags: NZ]
	stz $02E9.w		; 9C E9 02 ; Store zero to $02E9.w
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	jsl $0799AD.l		; 22 AD 99 07 ; Jump to subroutine long $0799AD.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda $7EF3C9.l		; AF C9 F3 7E ; Load long $7EF3C9.l into accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$02.b		; 09 02 ; Logical OR #$02.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF3C9.l		; 8F C9 F3 7E ; Store accumulator (long) $7EF3C9.l [Reads: Accumulator]
.ACCU 16
	rep #$20		; C2 20
	lda $7EF360.l		; AF 60 F3 7E ; Load long $7EF360.l into accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$0064.w		; E9 64 00 ; Subtract #$0064.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $7EF360.l		; 8F 60 F3 7E ; Store accumulator (long) $7EF360.l [Reads: Accumulator]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0E90.w,X		; BD 90 0E ; Load $0E90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $0C		; 30 0C ; Branch if minus to $30, $0C [Flow: branch]
	lda #$D5.b		; A9 D5 ; Load #$D5.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$D6.b		; A9 D6 ; Load #$D6.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ldy $0E90.w,X		; BC 90 0E ; Load Y register $0E90.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	.db $30, $11		; 30 11 ; Branch if minus to $30, $11 [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	lda #$00.b		; [PATTERN: Memory clearing operation] A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DD0.w,Y		; 99 D0 0D ; Store accumulator to $0DD0.w,Y [Reads: Y Index, Accumulator]
	jsl $1AFE88.l		; 22 88 FE 1A ; Jump to subroutine long $1AFE88.l [Writes: Stack Pointer] [Flow: call]
	stz $0E90.w,X		; 9E 90 0E ; Store zero to $0E90.w,X [Reads: X Index]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and #$0F.b		; 29 0F ; Logical AND #$0F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda #$00.b		; [PATTERN: Memory clearing operation] A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DD0.w,Y		; 99 D0 0D ; Store accumulator to $0DD0.w,Y [Reads: Y Index, Accumulator]
	jsl $068054.l		; 22 54 80 06 ; Jump to subroutine long $068054.l [Writes: Stack Pointer] [Flow: call]
	stz $0E90.w,X		; 9E 90 0E ; Store zero to $0E90.w,X [Reads: X Index]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $ACFF.w,Y		; F9 FF AC ; Subtract with carry $ACFF.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $88.b		; 00 88 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0000AC.l,X		; FF AC 00 00 ; Subtract with carry (long,X) $0000AC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A2.b		; 00 A2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $A9.b		; 02 A9 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $85.b		; 02 85 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $64.b		; 06 64 ; Arithmetic shift left $64.b [Reads: Direct Page] [Flags: NCZ]
	ora [$BD.b]		; 07 BD ; OR accumulator with memory (long) [$BD.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpy #$0D.b		; C0 0D ; Compare #$0D.b with Y register [Reads: Y Index] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc #$87.b		; 69 87 ; Add #$87.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
	lda #$EB.b		; A9 EB ; Load #$EB.b into accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $09.b		; 85 09 ; Store accumulator to $09.b [Reads: Accumulator]
	jsl $05DF75.l		; 22 75 DF 05 ; Jump to subroutine long $05DF75.l [Writes: Stack Pointer] [Flow: call]
	jsl $06DC54.l		; 22 54 DC 06 ; Jump to subroutine long $06DC54.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $EBCF.w		; 20 CF EB ; Jump to subroutine at $EBCF.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $7EF359.l		; AF 59 F3 7E ; Load long $7EF359.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $38		; B0 38 ; Branch if carry set to $B0, $38 [Flow: branch]
	inc $0BA0.w,X		; FE A0 0B ; Increment memory $0BA0.w,X [Reads: X Index] [Flags: NZ]
	jsr $F93F.w		; 20 3F F9 ; Jump to subroutine at $F93F.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor #$03.b		; 49 03 ; Exclusive OR #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	lda $7EF3CC.l		; AF CC F3 7E ; Load long $7EF3CC.l into accumulator [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF3CC.l		; 8F CC F3 7E ; Store accumulator (long) $7EF3CC.l [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	jsl $00D423.l		; 22 23 D4 00 ; Jump to subroutine long $00D423.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $7EF3CC.l		; 8F CC F3 7E ; Store accumulator (long) $7EF3CC.l [Reads: Accumulator]
	lda $A0.b		; A5 A0 ; Load $A0.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$12.b		; C9 12 ; Compare #$12.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $31		; D0 31 ; Branch if not equal to $D0, $31 [Flow: branch]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E80.w,X		; 9D 80 0E ; Store accumulator to $0E80.w,X [Reads: Accumulator, X Index]
	lda $7EF3C6.l		; AF C6 F3 7E ; Load long $7EF3C6.l into accumulator [Writes: Accumulator] [Flags: NZ]
	and #$04.b		; 29 04 ; Logical AND #$04.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $04		; D0 04 ; Branch if not equal to $D0, $04 [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0F.b		; 69 0F ; Add #$0F.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,X		; 9D 00 0D ; Store accumulator to $0D00.w,X [Reads: Accumulator, X Index]
	lda $0D20.w,X		; BD 20 0D ; Load $0D20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D20.w,X		; 9D 20 0D ; Store accumulator to $0D20.w,X [Reads: Accumulator, X Index]
	lda $0D10.w,X		; BD 10 0D ; Load $0D10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$06.b		; 69 06 ; Add #$06.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,X		; 9D 10 0D ; Store accumulator to $0D10.w,X [Reads: Accumulator, X Index]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F60.w,X		; 9D 60 0F ; Store accumulator to $0F60.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E80.w,X		; 9D 80 0E ; Store accumulator to $0E80.w,X [Reads: Accumulator, X Index]
	lda $7EF3CC.l		; AF CC F3 7E ; Load long $7EF3CC.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$01.b		; C9 01 ; Compare #$01.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $08		; F0 08 ; Branch if equal to $F0, $08 [Flow: branch]
	lda $7EF3C6.l		; AF C6 F3 7E ; Load long $7EF3C6.l into accumulator [Writes: Accumulator] [Flags: NZ]
	and #$04.b		; 29 04 ; Logical AND #$04.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$76.b		; A9 76 ; Load #$76.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx $02CF.w		; AE CF 02 ; Load $02CF.w into X register [Writes: X Index] [Flags: NZ]
	lda $1A64.w,X		; BD 64 1A ; Load $1A64.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,Y		; 99 B0 0E ; Store accumulator to $0EB0.w,Y [Reads: Y Index, Accumulator]
	sta $0DE0.w,Y		; 99 E0 0D ; Store accumulator to $0DE0.w,Y [Reads: Y Index, Accumulator]
	lda $20.b		; A5 20 ; Load $20.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D00.w,Y		; 99 00 0D ; Store accumulator to $0D00.w,Y [Reads: Y Index, Accumulator]
	lda $21.b		; A5 21 ; Load $21.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D20.w,Y		; 99 20 0D ; Store accumulator to $0D20.w,Y [Reads: Y Index, Accumulator]
	lda $22.b		; A5 22 ; Load $22.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D10.w,Y		; 99 10 0D ; Store accumulator to $0D10.w,Y [Reads: Y Index, Accumulator]
	lda $23.b		; A5 23 ; Load $23.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D30.w,Y		; 99 30 0D ; Store accumulator to $0D30.w,Y [Reads: Y Index, Accumulator]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E80.w,Y		; 99 80 0E ; Store accumulator to $0E80.w,Y [Reads: Y Index, Accumulator]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF3CC.l		; 8F CC F3 7E ; Store accumulator (long) $7EF3CC.l [Reads: Accumulator]
	lda $0BA0.w,Y		; B9 A0 0B ; Load $0BA0.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0BA0.w,Y		; 99 A0 0B ; Store accumulator to $0BA0.w,Y [Reads: Y Index, Accumulator]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F60.w,Y		; 99 60 0F ; Store accumulator to $0F60.w,Y [Reads: Y Index, Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$09.b],Y		; F7 09 ; Subtract with carry (long indexed) [$09.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$09.b],Y		; F7 09 ; Subtract with carry (long indexed) [$09.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $EC9E.w		; 20 9E EC ; Jump to subroutine at $EC9E.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $0DCE5F.l		; 22 5F CE 0D ; Jump to subroutine long $0DCE5F.l [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	jsl $1EF4F3.l		; 22 F3 F4 1E ; Jump to subroutine long $1EF4F3.l [Writes: Stack Pointer] [Flow: call]
	jsl $05DCA2.l		; 22 A2 DC 05 ; Jump to subroutine long $05DCA2.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $03		; 90 03 ; Branch if carry clear to $90, $03 [Flow: branch]
	jsr $F9ED.w		; 20 ED F9 ; Jump to subroutine at $F9ED.w [Writes: Stack Pointer] [Flow: call]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	lda $ED69EC.l,X		; BF EC 69 ED ; Load long $ED69EC.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $20EE.w		; 0C EE 20 ; Test and set bits $20EE.w [Reads: Accumulator] [Flags: Z]
	and $4998F9.l,X		; 3F F9 98 49 ; AND accumulator with memory (long,X) $4998F9.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $9D.b,S		; 03 9D ; OR accumulator with stack relative $9D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $0E		; B0 0E ; Branch if carry set to $B0, $0E [Flow: branch]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	cmp $FAEC.w,Y		; D9 EC FA ; Compare accumulator $FAEC.w,Y [Reads: Y Index] [Flags: NCZ]
	cpx $ED20.w		; EC 20 ED ; Compare $ED20.w with X register [Reads: X Index] [Flags: NCZ]
	bit $43ED.w		; 2C ED 43 ; Test bits $43ED.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	sbc $2922.w		; ED 22 29 ; Subtract $2922.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sbc ($06.b),Y		; F1 06 ; Subtract with carry ($06.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $90, $1A		; 90 1A ; Branch if carry clear to $90, $1A [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	inc $02E4.w		; EE E4 02 ; Increment $02E4.w [Flags: NZ]
	ldy $0EB0.w,X		; BC B0 0E ; Load Y register $0EB0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $EC8E.w,Y		; B9 8E EC ; Load $EC8E.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $EC92.w,Y		; B9 92 EC ; Load $EC92.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $16		; D0 16 ; Branch if not equal to $D0, $16 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$1C.b		; [PATTERN: Memory clearing operation] A9 1C ; Load #$1C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	stz $0D50.w,X		; 9E 50 0D ; Store zero to $0D50.w,X [Reads: X Index]
	stz $0D40.w,X		; 9E 40 0D ; Store zero to $0D40.w,X [Reads: X Index]
	lda #$19.b		; A9 19 ; Load #$19.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012C.w		; 8D 2C 01 ; Store accumulator to $012C.w [Reads: Accumulator]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$25.b		; A9 25 ; Load #$25.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $1CE8.w		; AD E8 1C ; Load $1CE8.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0C		; D0 0C ; Branch if not equal to $D0, $0C [Flow: branch]
	lda #$24.b		; A9 24 ; Load #$24.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D80.w,X		; 9D 80 0D ; Store accumulator to $0D80.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $02E4.w		; 9C E4 02 ; Store zero to $02E4.w
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF3C8.l		; 8F C8 F3 7E ; Store accumulator (long) $7EF3C8.l [Reads: Accumulator]
	jsl $00F9DD.l		; 22 DD F9 00 ; Jump to subroutine long $00F9DD.l [Writes: Stack Pointer] [Flow: call]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF3CC.l		; 8F CC F3 7E ; Store accumulator (long) $7EF3CC.l [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	jsl $02B929.l		; 22 29 B9 02 ; Jump to subroutine long $02B929.l [Writes: Stack Pointer] [Flow: call]
	jsl $099F39.l		; 22 39 9F 09 ; Jump to subroutine long $099F39.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012C.w		; 8D 2C 01 ; Store accumulator to $012C.w [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	ror $C4ED.w,X		; 7E ED C4 ; Rotate right $C4ED.w,X [Reads: X Index] [Flags: NCZ]
	sbc $EDEC.w		; ED EC ED ; Subtract $EDEC.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	rol $1A.b		; 26 1A ; Rotate left $1A.b [Reads: Direct Page] [Flags: NCZ]
	bit $0101.w		; 2C 01 01 ; Test bits $0101.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $BD.b		; 02 BD ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $0D		; F0 0D ; Branch if equal to $F0, $0D [Flow: branch]
	.db $D0, $36		; D0 36 ; Branch if not equal to $D0, $36 [Flow: branch]
	ldy $0D90.w,X		; BC 90 0D ; Load Y register $0D90.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	cpy #$04.b		; [PATTERN: Memory clearing operation] C0 04 ; Compare #$04.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $90, $10		; 90 10 ; Branch if carry clear to $90, $10 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	stz $0DE0.w,X		; 9E E0 0D ; Store zero to $0DE0.w,X [Reads: X Index]
	stz $0EB0.w,X		; 9E B0 0E ; Store zero to $0EB0.w,X [Reads: X Index]
	stz $0D50.w,X		; [PATTERN: Memory clearing operation] 9E 50 0D ; Store zero to $0D50.w,X [Reads: X Index]
	stz $0D40.w,X		; 9E 40 0D ; Store zero to $0D40.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $ED76.w,Y		; B9 76 ED ; Load $ED76.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda $ED7A.w,Y		; B9 7A ED ; Load $ED7A.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	inc $0D90.w,X		; FE 90 0D ; Increment memory $0D90.w,X [Reads: X Index] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $EC8E.w,Y		; B9 8E EC ; Load $EC8E.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $EC92.w,Y		; B9 92 EC ; Load $EC92.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$1D.b		; A9 1D ; Load #$1D.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7FFE01.l		; 8F 01 FE 7F ; Store accumulator (long) $7FFE01.l [Reads: Accumulator]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF3C8.l		; 8F C8 F3 7E ; Store accumulator (long) $7EF3C8.l [Reads: Accumulator]
	jsl $00F9DD.l		; 22 DD F9 00 ; Jump to subroutine long $00F9DD.l [Writes: Stack Pointer] [Flow: call]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF3C5.l		; 8F C5 F3 7E ; Store accumulator (long) $7EF3C5.l [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	jsl $00FC62.l		; 22 62 FC 00 ; Jump to subroutine long $00FC62.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $F93F.w		; 20 3F F9 ; Jump to subroutine at $F93F.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor #$03.b		; 49 03 ; Exclusive OR #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	lda #$1E.b		; A9 1E ; Load #$1E.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E1A7.l		; 22 A7 E1 05 ; Jump to subroutine long $05E1A7.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $06		; 90 06 ; Branch if carry clear to $90, $06 [Flow: branch]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	asl $2726.w,X		; 1E 26 27 ; Arithmetic shift left $2726.w,X [Reads: X Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $4998F9.l,X		; 3F F9 98 49 ; AND accumulator with memory (long,X) $4998F9.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $9D.b,S		; 03 9D ; OR accumulator with stack relative $9D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $0E		; B0 0E ; Branch if carry set to $B0, $0E [Flow: branch]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	lda $7EF374.l		; AF 74 F3 7E ; Load long $7EF374.l into accumulator [Writes: Accumulator] [Flags: NZ]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$07.b		; C9 07 ; Compare #$07.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $04		; D0 04 ; Branch if not equal to $D0, $04 [Flow: branch]
	ldy #$02.b		; A0 02 ; Load #$02.b into Y register [Writes: Y Index] [Flags: NZ]
	.db $80, $0A		; 80 0A ; Branch always to $80, $0A [Flow: branch]
	lda $7EF3C7.l		; AF C7 F3 7E ; Load long $7EF3C7.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $02		; 90 02 ; Branch if carry clear to $90, $02 [Flow: branch]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	lda $EE06.w,Y		; B9 06 EE ; Load $EE06.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lda $EE09.w,Y		; B9 09 EE ; Load $EE09.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	jsl $05E1A7.l		; 22 A7 E1 05 ; Jump to subroutine long $05E1A7.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $0C		; 90 0C ; Branch if carry clear to $90, $0C [Flow: branch]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	lda #$A0.b		; A9 A0 ; Load #$A0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF372.l		; 8F 72 F3 7E ; Store accumulator (long) $7EF372.l [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $EE53.w		; 20 53 EE ; Jump to subroutine at $EE53.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $7EF344.l		; AF 44 F3 7E ; Load long $7EF344.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $04		; 90 04 ; Branch if carry clear to $90, $04 [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	lda #$08.b		; A9 08 ; Load #$08.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0F50.w,X		; 1D 50 0F ; OR accumulator with memory $0F50.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	inc $0BA0.w,X		; FE A0 0B ; Increment memory $0BA0.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $EE78.w		; 20 78 EE ; Jump to subroutine at $EE78.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $06DBF0.l		; 22 F0 DB 06 ; Jump to subroutine long $06DBF0.l [Writes: Stack Pointer] [Flow: call]
	jsl $07F4D0.l		; 22 D0 F4 07 ; Jump to subroutine long $07F4D0.l [Writes: Stack Pointer] [Flow: call]
	.db $B0, $23		; B0 23 ; Branch if carry set to $B0, $23 [Flow: branch]
	jsl $06F129.l		; 22 29 F1 06 ; Jump to subroutine long $06F129.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $0F		; [PATTERN: Memory clearing operation] 90 0F ; Branch if carry clear to $90, $0F [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldy #$29.b		; A0 29 ; Load #$29.b into Y register [Writes: Y Index] [Flags: NZ]
	stz $02E9.w		; 9C E9 02 ; Store zero to $02E9.w
	jsl $0799AD.l		; 22 AD 99 07 ; Jump to subroutine long $0799AD.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$1F.b		; 29 1F ; Logical AND #$1F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$40.b		; 49 40 ; Exclusive OR #$40.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $EEAF.w		; 20 AF EE ; Jump to subroutine at $EEAF.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $EEE6.w		; 20 E6 EE ; Jump to subroutine at $EEE6.w [Writes: Stack Pointer] [Flow: call]
	jsr $F955.w		; 20 55 F9 ; Jump to subroutine at $F955.w [Writes: Stack Pointer] [Flow: call]
	lda $7FFA1C.l,X		; BF 1C FA 7F ; Load long $7FFA1C.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $11		; D0 11 ; Branch if not equal to $D0, $11 [Flow: branch]
	lda $0DB0.w,X		; BD B0 0D ; Load $0DB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0B		; D0 0B ; Branch if not equal to $D0, $0B [Flow: branch]
	inc $0DB0.w,X		; FE B0 0D ; Increment memory $0DB0.w,X [Reads: X Index] [Flags: NZ]
	lda #$6F.b		; A9 6F ; Load #$6F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $F9ED.w		; 20 ED F9 ; Jump to subroutine at $F9ED.w [Writes: Stack Pointer] [Flow: call]
	jsl $06DFF2.l		; 22 F2 DF 06 ; Jump to subroutine long $06DFF2.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pea $0000.w		; F4 00 00 ; Push absolute address $0000.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F5.b		; 00 F5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A9.b		; 00 A9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $85.b		; 02 85 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $64.b		; 06 64 ; Arithmetic shift left $64.b [Reads: Direct Page] [Flags: NCZ]
	ora [$A9.b]		; 07 A9 ; OR accumulator with memory (long) [$A9.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dec $85.b,X		; D6 85 ; Decrement memory $85.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	lda #$EE.b		; A9 EE ; Load #$EE.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $09.b		; 85 09 ; Store accumulator to $09.b [Reads: Accumulator]
	jsl $05DF75.l		; 22 75 DF 05 ; Jump to subroutine long $05DF75.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	eor $56.b,X		; 55 56 ; Exclusive OR accumulator with memory $56.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor [$01.b],Y		; 57 01 ; Exclusive OR accumulator with memory (long indexed) [$01.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($8B.b,X)		; 01 8B ; Logical OR ($8B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $EF09.w		; 20 09 EF ; Jump to subroutine at $EF09.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $1B.b		; A5 1B ; Load $1B.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $20		; D0 20 ; Branch if not equal to $D0, $20 [Flow: branch]
	lda $8A.b		; A5 8A ; Load $8A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$3B.b		; C9 3B ; Compare #$3B.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	lda $7EF2BB.l		; AF BB F2 7E ; Load long $7EF2BB.l into accumulator [Writes: Accumulator] [Flags: NZ]
	and #$20.b		; 29 20 ; Logical AND #$20.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0C		; F0 0C ; Branch if equal to $F0, $0C [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx $8A.b		; A6 8A ; Load $8A.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	lda $7EF280.l,X		; BF 80 F2 7E ; Load long $7EF280.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$40.b		; 29 40 ; Logical AND #$40.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $05		; F0 05 ; Branch if equal to $F0, $05 [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0D30.w,X		; BD 30 0D ; Load $0D30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $0403.w		; AD 03 04 ; Load $0403.w into accumulator [Writes: Accumulator] [Flags: NZ]
	and $F006.w,Y		; 39 06 F0 ; AND accumulator with memory $F006.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $EF47.w		; 20 47 EF ; Jump to subroutine at $EF47.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $040C.w		; AD 0C 04 ; Load $040C.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$1A.b		; C9 1A ; Compare #$1A.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $04		; D0 04 ; Branch if not equal to $D0, $04 [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0ED0.w,X		; BD D0 0E ; Load $0ED0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0BA0.w,X		; 9D A0 0B ; Store accumulator to $0BA0.w,X [Reads: Accumulator, X Index]
	.db $D0, $0F		; D0 0F ; Branch if not equal to $D0, $0F [Flow: branch]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	jsl $00D4ED.l		; 22 ED D4 00 ; Jump to subroutine long $00D4ED.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	jsl $0684BD.l		; 22 BD 84 06 ; Jump to subroutine long $0684BD.l [Writes: Stack Pointer] [Flow: call]
	inc $0ED0.w,X		; FE D0 0E ; Increment memory $0ED0.w,X [Reads: X Index] [Flags: NZ]
	lda $048E.w		; AD 8E 04 ; Load $048E.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$06.b		; C9 06 ; Compare #$06.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $09		; D0 09 ; Branch if not equal to $D0, $09 [Flow: branch]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $04		; D0 04 ; Branch if not equal to $D0, $04 [Flow: branch]
	jsl $05A029.l		; 22 29 A0 05 ; Jump to subroutine long $05A029.l [Writes: Stack Pointer] [Flow: call]
	jsl $06DBF0.l		; 22 F0 DB 06 ; Jump to subroutine long $06DBF0.l [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	dec $0F80.w,X		; DE 80 0F ; Decrement memory $0F80.w,X [Reads: X Index] [Flags: NZ]
	dec $0F80.w,X		; DE 80 0F ; Decrement memory $0F80.w,X [Reads: X Index] [Flags: NZ]
	jsr $FA2E.w		; 20 2E FA ; Jump to subroutine at $FA2E.w [Writes: Stack Pointer] [Flow: call]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $2A		; 10 2A ; Branch if plus to $10, $2A [Flow: branch]
	stz $0F70.w,X		; 9E 70 0F ; Store zero to $0F70.w,X [Reads: X Index]
	lda $0F80.w,X		; BD 80 0F ; Load $0F80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	lda $048E.w		; AD 8E 04 ; Load $048E.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$06.b		; C9 06 ; Compare #$06.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $15		; D0 15 ; Branch if not equal to $D0, $15 [Flow: branch]
	lda $0E30.w,X		; BD 30 0E ; Load $0E30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $10		; D0 10 ; Branch if not equal to $D0, $10 [Flow: branch]
	lda $0E40.w,X		; BD 40 0E ; Load $0E40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$02.b		; 69 02 ; Add #$02.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0E40.w,X		; 9D 40 0E ; Store accumulator to $0E40.w,X [Reads: Accumulator, X Index]
	inc $0E30.w,X		; FE 30 0E ; Increment memory $0E30.w,X [Reads: X Index] [Flags: NZ]
	jsl $1DE214.l		; 22 14 E2 1D ; Jump to subroutine long $1DE214.l [Writes: Stack Pointer] [Flow: call]
	jsl $07F4D0.l		; 22 D0 F4 07 ; Jump to subroutine long $07F4D0.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $01		; 90 01 ; Branch if carry clear to $90, $01 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $06F129.l		; 22 29 F1 06 ; Jump to subroutine long $06F129.l [Writes: Stack Pointer] [Flow: call]
	.db $B0, $17		; B0 17 ; Branch if carry set to $B0, $17 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $02E9.w		; 8D E9 02 ; Store accumulator to $02E9.w [Reads: Accumulator]
	ldy #$3E.b		; A0 3E ; Load #$3E.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $0799AD.l		; 22 AD 99 07 ; Jump to subroutine long $0799AD.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda $0403.w		; AD 03 04 ; Load $0403.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$80.b		; 09 80 ; Logical OR #$80.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0403.w		; 8D 03 04 ; Store accumulator to $0403.w [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $E2		; D0 E2 ; Branch if not equal to $D0, $E2 [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	jsl $0791B9.l		; 22 B9 91 07 ; Jump to subroutine long $0791B9.l [Writes: Stack Pointer] [Flow: call]
	ldy #$26.b		; A0 26 ; Load #$26.b into Y register [Writes: Y Index] [Flags: NZ]
	stz $02E9.w		; 9C E9 02 ; Store zero to $02E9.w
	jsl $0799AD.l		; 22 AD 99 07 ; Jump to subroutine long $0799AD.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda $1B.b		; A5 1B ; Load $1B.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $11		; D0 11 ; Branch if not equal to $D0, $11 [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx $8A.b		; A6 8A ; Load $8A.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	lda $7EF280.l,X		; BF 80 F2 7E ; Load long $7EF280.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$40.b		; 09 40 ; Logical OR #$40.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF280.l,X		; 9F 80 F2 7E ; Store accumulator (long,X) $7EF280.l,X [Reads: Accumulator, X Index]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	jsr $30BD.w		; 20 BD 30 ; Jump to subroutine at $30BD.w [Writes: Stack Pointer] [Flow: call]
	ora $0129.w		; 0D 29 01 ; Logical OR $0129.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $0403.w		; AD 03 04 ; Load $0403.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $F006.w,Y		; 19 06 F0 ; OR accumulator with memory $F006.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0403.w		; 8D 03 04 ; Store accumulator to $0403.w [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $F020.w		; 20 20 F0 ; Jump to subroutine at $F020.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0B		; D0 0B ; Branch if not equal to $D0, $0B [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	jsr $EF09.w		; 20 09 EF ; Jump to subroutine at $EF09.w [Writes: Stack Pointer] [Flow: call]
	lda $0DD0.w,X		; BD D0 0D ; Load $0DD0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $59		; F0 59 ; Branch if equal to $F0, $59 [Flow: branch]
	jsl $06DBF0.l		; 22 F0 DB 06 ; Jump to subroutine long $06DBF0.l [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	jsl $07F4D0.l		; 22 D0 F4 07 ; Jump to subroutine long $07F4D0.l [Writes: Stack Pointer] [Flow: call]
	.db $B0, $4C		; B0 4C ; Branch if carry set to $B0, $4C [Flow: branch]
	jsr $B88D.w		; 20 8D B8 ; Jump to subroutine at $B88D.w [Writes: Stack Pointer] [Flow: call]
	lda $0E70.w,X		; BD 70 0E ; Load $0E70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $09		; F0 09 ; Branch if equal to $F0, $09 [Flow: branch]
	lda $0D50.w,X		; BD 50 0D ; Load $0D50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	dec $0F80.w,X		; DE 80 0F ; Decrement memory $0F80.w,X [Reads: X Index] [Flags: NZ]
	jsr $FA2E.w		; 20 2E FA ; Jump to subroutine at $FA2E.w [Writes: Stack Pointer] [Flow: call]
	jsr $F9ED.w		; 20 ED F9 ; Jump to subroutine at $F9ED.w [Writes: Stack Pointer] [Flow: call]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	stz $0F70.w,X		; 9E 70 0F ; Store zero to $0F70.w,X [Reads: X Index]
	lda $0F80.w,X		; BD 80 0F ; Load $0F80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	and #$F8.b		; 29 F8 ; Logical AND #$F8.b with accumulator [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	lda $0D50.w,X		; BD 50 0D ; Load $0D50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0D		; F0 0D ; Branch if equal to $F0, $0D [Flow: branch]
	cmp #$7F.b		; C9 7F ; Compare #$7F.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	cmp #$FF.b		; C9 FF ; Compare #$FF.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	inc $0D50.w,X		; FE 50 0D ; Increment memory $0D50.w,X [Reads: X Index] [Flags: NZ]
	lda $0F10.w,X		; BD 10 0F ; Load $0F10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $06		; D0 06 ; Branch if not equal to $D0, $06 [Flow: branch]
	jsl $06F129.l		; 22 29 F1 06 ; Jump to subroutine long $06F129.l [Writes: Stack Pointer] [Flow: call]
	.db $B0, $01		; B0 01 ; Branch if carry set to $B0, $01 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $7EF36B.l		; AF 6B F3 7E ; Load long $7EF36B.l into accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF36B.l		; 8F 6B F3 7E ; Store accumulator (long) $7EF36B.l [Reads: Accumulator]
	.db $D0, $11		; D0 11 ; Branch if not equal to $D0, $11 [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	jsl $0791B9.l		; 22 B9 91 07 ; Jump to subroutine long $0791B9.l [Writes: Stack Pointer] [Flow: call]
	ldy #$26.b		; A0 26 ; Load #$26.b into Y register [Writes: Y Index] [Flags: NZ]
	stz $02E9.w		; 9C E9 02 ; Store zero to $02E9.w
	jsl $0799AD.l		; 22 AD 99 07 ; Jump to subroutine long $0799AD.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	.db $80, $18		; 80 18 ; Branch always to $80, $18 [Flow: branch]
	lda #$2D.b		; A9 2D ; Load #$2D.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB8A.l		; 22 8A BB 0D ; Jump to subroutine long $0DBB8A.l [Writes: Stack Pointer] [Flow: call]
	lda $7EF36B.l		; AF 6B F3 7E ; Load long $7EF36B.l into accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $EEF9.w,Y		; B9 F9 EE ; Load $EEF9.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lda $EEFD.w,Y		; B9 FD EE ; Load $EEFD.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	lda $1B.b		; A5 1B ; Load $1B.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	jmp $F008.w		; 4C 08 F0 ; Jump to $F008.w [Flow: jump]
	jmp $EFF7.w		; 4C F7 EF ; Jump to $EFF7.w [Flow: jump]
	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $F0D5.w		; 20 D5 F0 ; Jump to subroutine at $F0D5.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $F23A.w		; 20 3A F2 ; Jump to subroutine at $F23A.w [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	jsl $1EF4F3.l		; 22 F3 F4 1E ; Jump to subroutine long $1EF4F3.l [Writes: Stack Pointer] [Flow: call]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	eor $EAF1.w		; 4D F1 EA ; Exclusive OR $EAF1.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $AF		; F0 AF ; Branch if equal to $F0, $AF [Flow: branch]
	dec $F3.b		; C6 F3 ; Decrement $F3.b [Reads: Direct Page] [Flags: NZ]
	ror $2029.w,X		; 7E 29 20 ; Rotate right $2029.w,X [Reads: X Index] [Flags: NCZ]
	.db $F0, $46		; F0 46 ; Branch if equal to $F0, $46 [Flow: branch]
	lda $7EF359.l		; AF 59 F3 7E ; Load long $7EF359.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $0A		; 90 0A ; Branch if carry clear to $90, $0A [Flow: branch]
	lda #$28.b		; A9 28 ; Load #$28.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E1A7.l		; 22 A7 E1 05 ; Jump to subroutine long $05E1A7.l [Writes: Stack Pointer] [Flow: call]
	.db $80, $46		; 80 46 ; Branch always to $80, $46 [Flow: branch]
	lda $7EF374.l		; AF 74 F3 7E ; Load long $7EF374.l into accumulator [Writes: Accumulator] [Flags: NZ]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$07.b		; C9 07 ; Compare #$07.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $0A		; D0 0A ; Branch if not equal to $D0, $0A [Flow: branch]
	lda #$26.b		; A9 26 ; Load #$26.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E1A7.l		; 22 A7 E1 05 ; Jump to subroutine long $05E1A7.l [Writes: Stack Pointer] [Flow: call]
	.db $80, $32		; 80 32 ; Branch always to $80, $32 [Flow: branch]
	and #$02.b		; 29 02 ; Logical AND #$02.b with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $0A		; D0 0A ; Branch if not equal to $D0, $0A [Flow: branch]
	lda #$29.b		; A9 29 ; Load #$29.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E1A7.l		; 22 A7 E1 05 ; Jump to subroutine long $05E1A7.l [Writes: Stack Pointer] [Flow: call]
	.db $80, $22		; 80 22 ; Branch always to $80, $22 [Flow: branch]
	lda $7EF34E.l		; AF 4E F3 7E ; Load long $7EF34E.l into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0A		; F0 0A ; Branch if equal to $F0, $0A [Flow: branch]
	lda #$27.b		; A9 27 ; Load #$27.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E1A7.l		; 22 A7 E1 05 ; Jump to subroutine long $05E1A7.l [Writes: Stack Pointer] [Flow: call]
	.db $80, $12		; 80 12 ; Branch always to $80, $12 [Flow: branch]
	lda #$25.b		; A9 25 ; Load #$25.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E1A7.l		; 22 A7 E1 05 ; Jump to subroutine long $05E1A7.l [Writes: Stack Pointer] [Flow: call]
	lda $7EF3C6.l		; AF C6 F3 7E ; Load long $7EF3C6.l into accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$20.b		; 09 20 ; Logical OR #$20.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF3C6.l		; 8F C6 F3 7E ; Store accumulator (long) $7EF3C6.l [Reads: Accumulator]
	jmp $F1DC.w		; 4C DC F1 ; Jump to $F1DC.w [Flow: jump]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc ($E9.b),Y		; F1 E9 ; Subtract with carry ($E9.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($FB.b),Y		; F1 FB ; Subtract with carry ($FB.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($0E.b),Y		; F1 0E ; Subtract with carry ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($39.b)		; F2 39 ; Subtract with carry (indirect) ($39.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $7EF374.l		; AF 74 F3 7E ; Load long $7EF374.l into accumulator [Writes: Accumulator] [Flags: NZ]
	and #$04.b		; 29 04 ; Logical AND #$04.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0F		; D0 0F ; Branch if not equal to $D0, $0F [Flow: branch]
	lda #$32.b		; A9 32 ; Load #$32.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E1A7.l		; 22 A7 E1 05 ; Jump to subroutine long $05E1A7.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $03		; 90 03 ; Branch if carry clear to $90, $03 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	.db $80, $65		; 80 65 ; Branch always to $80, $65 [Flow: branch]
	lda $7EF355.l		; AF 55 F3 7E ; Load long $7EF355.l into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $21		; D0 21 ; Branch if not equal to $D0, $21 [Flow: branch]
	lda $7EF3C7.l		; AF C7 F3 7E ; Load long $7EF3C7.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $F15C.w,Y		; B9 5C F1 ; Load $F15C.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lda $F15E.w,Y		; B9 5E F1 ; Load $F15E.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	jsl $05E1A7.l		; 22 A7 E1 05 ; Jump to subroutine long $05E1A7.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $06		; 90 06 ; Branch if carry clear to $90, $06 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	.db $80, $3E		; 80 3E ; Branch always to $80, $3E [Flow: branch]
	lda $7EF346.l		; AF 46 F3 7E ; Load long $7EF346.l into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0A		; D0 0A ; Branch if not equal to $D0, $0A [Flow: branch]
	lda #$37.b		; A9 37 ; Load #$37.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E1A7.l		; 22 A7 E1 05 ; Jump to subroutine long $05E1A7.l [Writes: Stack Pointer] [Flow: call]
	.db $80, $2E		; 80 2E ; Branch always to $80, $2E [Flow: branch]
	lda $7EF374.l		; AF 74 F3 7E ; Load long $7EF374.l into accumulator [Writes: Accumulator] [Flags: NZ]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$07.b		; C9 07 ; Compare #$07.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $0A		; F0 0A ; Branch if equal to $F0, $0A [Flow: branch]
	lda #$34.b		; A9 34 ; Load #$34.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E1A7.l		; 22 A7 E1 05 ; Jump to subroutine long $05E1A7.l [Writes: Stack Pointer] [Flow: call]
	.db $80, $1A		; 80 1A ; Branch always to $80, $1A [Flow: branch]
	lda $7EF359.l		; AF 59 F3 7E ; Load long $7EF359.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $0A		; B0 0A ; Branch if carry set to $B0, $0A [Flow: branch]
	lda #$30.b		; A9 30 ; Load #$30.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E1A7.l		; 22 A7 E1 05 ; Jump to subroutine long $05E1A7.l [Writes: Stack Pointer] [Flow: call]
	.db $80, $08		; 80 08 ; Branch always to $80, $08 [Flow: branch]
	lda #$31.b		; A9 31 ; Load #$31.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E1A7.l		; 22 A7 E1 05 ; Jump to subroutine long $05E1A7.l [Writes: Stack Pointer] [Flow: call]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$33.b		; A9 33 ; Load #$33.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF3C7.l		; 8F C7 F3 7E ; Store accumulator (long) $7EF3C7.l [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ldy #$4B.b		; A0 4B ; Load #$4B.b into Y register [Writes: Y Index] [Flags: NZ]
	stz $02E9.w		; 9C E9 02 ; Store zero to $02E9.w
	jsl $0799AD.l		; 22 AD 99 07 ; Jump to subroutine long $0799AD.l [Writes: Stack Pointer] [Flow: call]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF3C7.l		; 8F C7 F3 7E ; Store accumulator (long) $7EF3C7.l [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$37.b		; A9 37 ; Load #$37.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$FF.b],Y		; F7 FF ; Subtract with carry (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx #$00.b		; A2 00 ; Load #$00.b into X register [Writes: X Index] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $0000A0.l,X		; FF A0 00 00 ; Subtract with carry (long,X) $0000A0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A4.b		; 00 A4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	stz $07.b		; 64 07 ; Store zero to $07.b
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc #$1A.b		; 69 1A ; Add #$1A.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
	lda #$F2.b		; A9 F2 ; Load #$F2.b into accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $09.b		; 85 09 ; Store accumulator to $09.b [Reads: Accumulator]
	jsl $05DF75.l		; 22 75 DF 05 ; Jump to subroutine long $05DF75.l [Writes: Stack Pointer] [Flow: call]
	jsl $06DC54.l		; 22 54 DC 06 ; Jump to subroutine long $06DC54.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $F262.w		; 20 62 F2 ; Jump to subroutine at $F262.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	inc $0BA0.w,X		; FE A0 0B ; Increment memory $0BA0.w,X [Reads: X Index] [Flags: NZ]
	lda $8A.b		; A5 8A ; Load $8A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $1A		; F0 1A ; Branch if equal to $F0, $1A [Flow: branch]
	lda $0D10.w,X		; BD 10 0D ; Load $0D10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$08.b		; 69 08 ; Add #$08.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,X		; 9D 10 0D ; Store accumulator to $0D10.w,X [Reads: Accumulator, X Index]
	lda $7EF347.l		; AF 47 F3 7E ; Load long $7EF347.l into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $1B		; F0 1B ; Branch if equal to $F0, $1B [Flow: branch]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D80.w,X		; 9D 80 0D ; Store accumulator to $0D80.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $7EF348.l		; AF 48 F3 7E ; Load long $7EF348.l into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0A		; F0 0A ; Branch if equal to $F0, $0A [Flow: branch]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D80.w,X		; 9D 80 0D ; Store accumulator to $0D80.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $F29E.w		; 20 9E F2 ; Jump to subroutine at $F29E.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	tsb $B2F3.w		; 0C F3 B2 ; Test and set bits $B2F3.w [Reads: Accumulator] [Flags: Z]
	sbc ($00.b)		; F2 00 ; Subtract with carry (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $0DD120.l		; 22 20 D1 0D ; Jump to subroutine long $0DD120.l [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $17		; D0 17 ; Branch if not equal to $D0, $17 [Flow: branch]
	lda #$05.b		; A9 05 ; Load #$05.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	ldy $0D90.w,X		; BC 90 0D ; Load Y register $0D90.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $F2A9.w,Y		; B9 A9 F2 ; Load $F2A9.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $04		; 10 04 ; Branch if plus to $10, $04 [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	inc $0D90.w,X		; FE 90 0D ; Increment memory $0D90.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$F2.b		; A9 F2 ; Load #$F2.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $2D		; 30 2D ; Branch if minus to $30, $2D [Flow: branch]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	sta $0F.b		; 85 0F ; Store accumulator to $0F.b [Reads: Accumulator]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
.ACCU 16
	rep #$20		; C2 20
	and #$000F.w		; 29 0F 00 ; Logical AND #$000F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$0008.w		; E9 08 00 ; Subtract #$0008.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $00.b		; 65 00 ; Add $00.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $0F.b		; A5 0F ; Load $0F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$000F.w		; 29 0F 00 ; Logical AND #$000F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $02.b		; 65 02 ; Add $02.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	jsl $09AE64.l		; 22 64 AE 09 ; Jump to subroutine long $09AE64.l [Writes: Stack Pointer] [Flow: call]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E80.w,Y		; 99 80 0E ; Store accumulator to $0E80.w,Y [Reads: Y Index, Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $0DD1E2.l		; 22 E2 D1 0D ; Jump to subroutine long $0DD1E2.l [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	lda $037A.w		; AD 7A 03 ; Load $037A.w into accumulator [Writes: Accumulator] [Flags: NZ]
	and #$DF.b		; 29 DF ; Logical AND #$DF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $037A.w		; 8D 7A 03 ; Store accumulator to $037A.w [Reads: Accumulator]
	stz $0D90.w,X		; [PATTERN: Memory clearing operation] 9E 90 0D ; Store zero to $0D90.w,X [Reads: X Index]
	jsl $06F129.l		; 22 29 F1 06 ; Jump to subroutine long $06F129.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $0D		; 90 0D ; Branch if carry clear to $90, $0D [Flow: branch]
	jsl $0FF540.l		; 22 40 F5 0F ; Jump to subroutine long $0FF540.l [Writes: Stack Pointer] [Flow: call]
	stz $5E.b		; 64 5E ; Store zero to $5E.b
	jsl $079291.l		; 22 91 92 07 ; Jump to subroutine long $079291.l [Writes: Stack Pointer] [Flow: call]
	inc $0D90.w,X		; FE 90 0D ; Increment memory $0D90.w,X [Reads: X Index] [Flags: NZ]
	jsl $07F4D0.l		; 22 D0 F4 07 ; Jump to subroutine long $07F4D0.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $01		; 90 01 ; Branch if carry clear to $90, $01 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	eor $F42EF3.l		; 4F F3 2E F4 ; Exclusive OR accumulator with memory (long) $F42EF3.l [Writes: Accumulator] [Flags: NZ]
	bit $63F4.w,X		; 3C F4 63 ; Test bits $63F4.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	pea $0E0D.w		; F4 0D 0E ; Push absolute address $0E0D.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $010F.w		; 0D 0F 01 ; Logical OR $010F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($A5.b,X)		; 01 A5 ; Logical OR ($A5.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $6F		; F0 6F ; Branch if equal to $F0, $6F [Flow: branch]
	lda $2F.b		; A5 2F ; Load $2F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $6A		; D0 6A ; Branch if not equal to $D0, $6A [Flow: branch]
	jsr $F93F.w		; 20 3F F9 ; Jump to subroutine at $F93F.w [Writes: Stack Pointer] [Flow: call]
	cpy #$02.b		; C0 02 ; Compare #$02.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $D0, $63		; D0 63 ; Branch if not equal to $D0, $63 [Flow: branch]
.ACCU 16
	rep #$20		; C2 20
	lda $0FDA.w		; AD DA 0F ; Load $0FDA.w into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0010.w		; 69 10 00 ; Add #$0010.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp $20.b		; C5 20 ; Compare $20.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	.db $90, $54		; 90 54 ; Branch if carry clear to $90, $54 [Flow: branch]
	lda $F4.b		; A5 F4 ; Load $F4.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $09		; 10 09 ; Branch if plus to $10, $09 [Flow: branch]
	lda $7EF359.l		; AF 59 F3 7E ; Load long $7EF359.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $01		; D0 01 ; Branch if not equal to $D0, $01 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0202.w		; AD 02 02 ; Load $0202.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$0F.b		; C9 0F ; Compare #$0F.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	lda $F4.b		; A5 F4 ; Load $F4.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$40.b		; 29 40 ; Logical AND #$40.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $06		; D0 06 ; Branch if not equal to $D0, $06 [Flow: branch]
	lda $F6.b		; A5 F6 ; Load $F6.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $34		; 10 34 ; Branch if plus to $10, $34 [Flow: branch]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $F0, $21		; [PATTERN: Memory clearing operation] F0 21 ; Branch if equal to $F0, $21 [Flow: branch]
	stz $0300.w		; 9C 00 03 ; Store zero to $0300.w
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $037A.w		; 8D 7A 03 ; Store accumulator to $037A.w [Reads: Accumulator]
	stz $012E.w		; 9C 2E 01 ; Store zero to $012E.w
	lda $7EF359.l		; AF 59 F3 7E ; Load long $7EF359.l into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $30, $10		; 30 10 ; Branch if minus to $30, $10 [Flow: branch]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $0C		; 90 0C ; Branch if carry clear to $90, $0C [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	jsl $0785E5.l		; 22 E5 85 07 ; Jump to subroutine long $0785E5.l [Writes: Stack Pointer] [Flow: call]
	lda #$40.b		; A9 40 ; Load #$40.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda $F34B.w,Y		; B9 4B F3 ; Load $F34B.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lda $F34D.w,Y		; B9 4D F3 ; Load $F34D.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $2F.b		; A5 2F ; Load $2F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $65		; D0 65 ; Branch if not equal to $D0, $65 [Flow: branch]
	jsr $F93F.w		; 20 3F F9 ; Jump to subroutine at $F93F.w [Writes: Stack Pointer] [Flow: call]
	cpy #$02.b		; C0 02 ; Compare #$02.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $D0, $5E		; D0 5E ; Branch if not equal to $D0, $5E [Flow: branch]
	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$10.b		; 69 10 ; Add #$10.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp $20.b		; C5 20 ; Compare $20.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	.db $90, $54		; 90 54 ; Branch if carry clear to $90, $54 [Flow: branch]
	lda $F4.b		; A5 F4 ; Load $F4.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $09		; 10 09 ; Branch if plus to $10, $09 [Flow: branch]
	lda $7EF359.l		; AF 59 F3 7E ; Load long $7EF359.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $01		; D0 01 ; Branch if not equal to $D0, $01 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0202.w		; AD 02 02 ; Load $0202.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$0F.b		; C9 0F ; Compare #$0F.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	lda $F4.b		; A5 F4 ; Load $F4.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$40.b		; 29 40 ; Logical AND #$40.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $06		; D0 06 ; Branch if not equal to $D0, $06 [Flow: branch]
	lda $F6.b		; A5 F6 ; Load $F6.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $34		; 10 34 ; Branch if plus to $10, $34 [Flow: branch]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $F0, $21		; [PATTERN: Memory clearing operation] F0 21 ; Branch if equal to $F0, $21 [Flow: branch]
	stz $0300.w		; 9C 00 03 ; Store zero to $0300.w
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $037A.w		; 8D 7A 03 ; Store accumulator to $037A.w [Reads: Accumulator]
	stz $012E.w		; 9C 2E 01 ; Store zero to $012E.w
	lda $7EF359.l		; AF 59 F3 7E ; Load long $7EF359.l into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $30, $10		; 30 10 ; Branch if minus to $30, $10 [Flow: branch]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $0C		; 90 0C ; Branch if carry clear to $90, $0C [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	jsl $07855A.l		; 22 5A 85 07 ; Jump to subroutine long $07855A.l [Writes: Stack Pointer] [Flow: call]
	lda #$40.b		; A9 40 ; Load #$40.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda $F347.w,Y		; B9 47 F3 ; Load $F347.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lda $F349.w,Y		; B9 49 F3 ; Load $F349.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$80.b		; A9 80 ; Load #$80.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $09		; D0 09 ; Branch if not equal to $D0, $09 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$F0.b		; A9 F0 ; Load #$F0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cmp #$60.b		; C9 60 ; Compare #$60.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $08		; F0 08 ; Branch if equal to $F0, $08 [Flow: branch]
	cmp #$40.b		; C9 40 ; Compare #$40.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	cmp #$20.b		; C9 20 ; Compare #$20.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	inc $0DC0.w,X		; FE C0 0D ; Increment memory $0DC0.w,X [Reads: X Index] [Flags: NZ]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	jsr $F2D6.w		; 20 D6 F2 ; Jump to subroutine at $F2D6.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $F471.w		; 20 71 F4 ; Jump to subroutine at $F471.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $F505.w		; 20 05 F5 ; Jump to subroutine at $F505.w [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	jsl $1EF4F3.l		; 22 F3 F4 1E ; Jump to subroutine long $1EF4F3.l [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pea $F4B5.w		; F4 B5 F4 ; Push absolute address $F4B5.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	cmp ($F4.b,X)		; C1 F4 ; Compare accumulator ($F4.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	pea $59AF.w		; F4 AF 59 ; Push absolute address $59AF.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sbc ($7E.b,S),Y		; F3 7E ; Subtract with carry (stack relative indirect indexed) ($7E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $19		; B0 19 ; Branch if carry set to $B0, $19 [Flow: branch]
	lda #$2B.b		; A9 2B ; Load #$2B.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E1A7.l		; 22 A7 E1 05 ; Jump to subroutine long $05E1A7.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $03		; 90 03 ; Branch if carry clear to $90, $03 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$2E.b		; A9 2E ; Load #$2E.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E1A7.l		; 22 A7 E1 05 ; Jump to subroutine long $05E1A7.l [Writes: Stack Pointer] [Flow: call]
	.db $80, $EA		; 80 EA ; Branch always to $80, $EA [Flow: branch]
	lda #$2C.b		; A9 2C ; Load #$2C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $1CE8.w		; AD E8 1C ; Load $1CE8.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0C		; D0 0C ; Branch if not equal to $D0, $0C [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$2D.b		; A9 2D ; Load #$2D.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$2C.b		; A9 2C ; Load #$2C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$2D.b		; A9 2D ; Load #$2D.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E1A7.l		; 22 A7 E1 05 ; Jump to subroutine long $05E1A7.l [Writes: Stack Pointer] [Flow: call]
	.db $80, $BA		; 80 BA ; Branch always to $80, $BA [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc $00008E.l,X		; FF 8E 00 00 ; Subtract with carry (long,X) $00008E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $00008E.l,X		; FF 8E 00 00 ; Subtract with carry (long,X) $00008E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	stz $07.b		; 64 07 ; Store zero to $07.b
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc #$E5.b		; 69 E5 ; Add #$E5.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
	lda #$F4.b		; A9 F4 ; Load #$F4.b into accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $09.b		; 85 09 ; Store accumulator to $09.b [Reads: Accumulator]
	jsl $05DF75.l		; 22 75 DF 05 ; Jump to subroutine long $05DF75.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $F529.w		; 20 29 F5 ; Jump to subroutine at $F529.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $F539.w		; 20 39 F5 ; Jump to subroutine at $F539.w [Writes: Stack Pointer] [Flow: call]
	jsr $F58E.w		; 20 8E F5 ; Jump to subroutine at $F58E.w [Writes: Stack Pointer] [Flow: call]
	jsr $F5BF.w		; 20 BF F5 ; Jump to subroutine at $F5BF.w [Writes: Stack Pointer] [Flow: call]
	jsr $F5F0.w		; 20 F0 F5 ; Jump to subroutine at $F5F0.w [Writes: Stack Pointer] [Flow: call]
	inc $0BA0.w,X		; FE A0 0B ; Increment memory $0BA0.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0ABF.w		; AD BF 0A ; Load $0ABF.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $4F		; F0 4F ; Branch if equal to $F0, $4F [Flow: branch]
	lda $7EF344.l		; AF 44 F3 7E ; Load long $7EF344.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $47		; F0 47 ; Branch if equal to $F0, $47 [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	stz $00.b		; 64 00 ; Store zero to $00.b
.INDEX 16
	rep #$10		; C2 10
	ldx #$0212.w		; A2 12 02 ; Load #$0212.w into X register [Writes: X Index] [Flags: NZ]
	lda $7EF000.l,X		; BF 00 F0 7E ; Load long $7EF000.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$80.b		; 29 80 ; Logical AND #$80.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $30		; F0 30 ; Branch if equal to $F0, $30 [Flow: branch]
	lda #$E9.b		; A9 E9 ; Load #$E9.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E80.w,Y		; 99 80 0E ; Store accumulator to $0E80.w,Y [Reads: Y Index, Accumulator]
	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$00.b		; E9 00 ; Subtract #$00.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,Y		; 99 00 0D ; Store accumulator to $0D00.w,Y [Reads: Y Index, Accumulator]
	lda $0D20.w,X		; BD 20 0D ; Load $0D20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc #$00.b		; E9 00 ; Subtract #$00.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0D20.w,Y		; 99 20 0D ; Store accumulator to $0D20.w,Y [Reads: Y Index, Accumulator]
	lda $0D10.w,X		; BD 10 0D ; Load $0D10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$10.b		; E9 10 ; Subtract #$10.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,Y		; 99 10 0D ; Store accumulator to $0D10.w,Y [Reads: Y Index, Accumulator]
	lda $0D30.w,X		; BD 30 0D ; Load $0D30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc #$00.b		; E9 00 ; Subtract #$00.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0D30.w,Y		; 99 30 0D ; Store accumulator to $0D30.w,Y [Reads: Y Index, Accumulator]
	jmp $F61D.w		; 4C 1D F6 ; Jump to $F61D.w [Flow: jump]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$E9.b		; A9 E9 ; Load #$E9.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E80.w,Y		; 99 80 0E ; Store accumulator to $0E80.w,Y [Reads: Y Index, Accumulator]
	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$48.b		; E9 48 ; Subtract #$48.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,Y		; 99 00 0D ; Store accumulator to $0D00.w,Y [Reads: Y Index, Accumulator]
	lda $0D20.w,X		; BD 20 0D ; Load $0D20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc #$00.b		; E9 00 ; Subtract #$00.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0D20.w,Y		; 99 20 0D ; Store accumulator to $0D20.w,Y [Reads: Y Index, Accumulator]
	lda $0D10.w,X		; BD 10 0D ; Load $0D10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$28.b		; E9 28 ; Subtract #$28.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,Y		; 99 10 0D ; Store accumulator to $0D10.w,Y [Reads: Y Index, Accumulator]
	lda $0D30.w,X		; BD 30 0D ; Load $0D30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc #$00.b		; E9 00 ; Subtract #$00.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0D30.w,Y		; 99 30 0D ; Store accumulator to $0D30.w,Y [Reads: Y Index, Accumulator]
	jmp $F61D.w		; 4C 1D F6 ; Jump to $F61D.w [Flow: jump]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$E9.b		; A9 E9 ; Load #$E9.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E80.w,Y		; 99 80 0E ; Store accumulator to $0E80.w,Y [Reads: Y Index, Accumulator]
	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$48.b		; E9 48 ; Subtract #$48.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,Y		; 99 00 0D ; Store accumulator to $0D00.w,Y [Reads: Y Index, Accumulator]
	lda $0D20.w,X		; BD 20 0D ; Load $0D20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc #$00.b		; E9 00 ; Subtract #$00.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0D20.w,Y		; 99 20 0D ; Store accumulator to $0D20.w,Y [Reads: Y Index, Accumulator]
	lda $0D10.w,X		; BD 10 0D ; Load $0D10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$08.b		; 69 08 ; Add #$08.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,Y		; 99 10 0D ; Store accumulator to $0D10.w,Y [Reads: Y Index, Accumulator]
	lda $0D30.w,X		; BD 30 0D ; Load $0D30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D30.w,Y		; 99 30 0D ; Store accumulator to $0D30.w,Y [Reads: Y Index, Accumulator]
	jmp $F61D.w		; 4C 1D F6 ; Jump to $F61D.w [Flow: jump]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$E9.b		; A9 E9 ; Load #$E9.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E80.w,Y		; 99 80 0E ; Store accumulator to $0E80.w,Y [Reads: Y Index, Accumulator]
	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$48.b		; E9 48 ; Subtract #$48.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,Y		; 99 00 0D ; Store accumulator to $0D00.w,Y [Reads: Y Index, Accumulator]
	lda $0D20.w,X		; BD 20 0D ; Load $0D20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc #$00.b		; E9 00 ; Subtract #$00.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0D20.w,Y		; 99 20 0D ; Store accumulator to $0D20.w,Y [Reads: Y Index, Accumulator]
	lda $0D10.w,X		; BD 10 0D ; Load $0D10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$58.b		; E9 58 ; Subtract #$58.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,Y		; 99 10 0D ; Store accumulator to $0D10.w,Y [Reads: Y Index, Accumulator]
	lda $0D30.w,X		; BD 30 0D ; Load $0D30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc #$00.b		; E9 00 ; Subtract #$00.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0D30.w,Y		; 99 30 0D ; Store accumulator to $0D30.w,Y [Reads: Y Index, Accumulator]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F60.w,Y		; 99 60 0F ; Store accumulator to $0F60.w,Y [Reads: Y Index, Accumulator]
	lda $0CAA.w,Y		; B9 AA 0C ; Load $0CAA.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora #$20.b		; 09 20 ; Logical OR #$20.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0CAA.w,Y		; 99 AA 0C ; Store accumulator to $0CAA.w,Y [Reads: Y Index, Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $F633.w		; 20 33 F6 ; Jump to subroutine at $F633.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	sta ($F8.b,S),Y		; 93 F8 ; Store accumulator (stack relative indirect indexed) ($F8.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	mvp $8E,$F6		; 44 F6 8E ; Move block positive $8E,$F6 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	inc $2B.b,X		; F6 2B ; Increment memory $2B.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	sbc [$D0.b],Y		; F7 D0 ; Subtract with carry (long indexed) [$D0.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$20.b],Y		; F7 20 ; Subtract with carry (long indexed) [$20.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $20.b,X		; F6 20 ; Increment memory $20.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	lsr $22F9.w		; 4E F9 22 ; Logical shift right $22F9.w [Flags: NCZ]
	sbc ($F4.b,S),Y		; F3 F4 ; Subtract with carry (stack relative indirect indexed) ($F4.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	asl $2922.w,X		; 1E 22 29 ; Arithmetic shift left $2922.w,X [Reads: X Index] [Flags: NCZ]
	sbc ($06.b),Y		; F1 06 ; Subtract with carry ($06.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $90, $16		; 90 16 ; Branch if carry clear to $90, $16 [Flow: branch]
	lda $F6.b		; A5 F6 ; Load $F6.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $12		; 10 12 ; Branch if plus to $10, $12 [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	jsl $0791B9.l		; 22 B9 91 07 ; Jump to subroutine long $0791B9.l [Writes: Stack Pointer] [Flow: call]
	ldy #$0D.b		; [PATTERN: Memory clearing operation] A0 0D ; Load #$0D.b into Y register [Writes: Y Index] [Flags: NZ]
	stz $02E9.w		; 9C E9 02 ; Store zero to $02E9.w
	jsl $0799AD.l		; 22 AD 99 07 ; Jump to subroutine long $0799AD.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $04.b		; E6 04 ; Increment $04.b [Reads: Direct Page] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $04.b		; E6 04 ; Increment $04.b [Reads: Direct Page] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	stz $07.b		; 64 07 ; Store zero to $07.b
	lda #$6B.b		; A9 6B ; Load #$6B.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
	lda #$F6.b		; A9 F6 ; Load #$F6.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $09.b		; 85 09 ; Store accumulator to $09.b [Reads: Accumulator]
	jsl $05DF75.l		; 22 75 DF 05 ; Jump to subroutine long $05DF75.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $F718.w		; 20 18 F7 ; Jump to subroutine at $F718.w [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	jsl $1EF4F3.l		; 22 F3 F4 1E ; Jump to subroutine long $1EF4F3.l [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $12		; D0 12 ; Branch if not equal to $D0, $12 [Flow: branch]
	jsr $F880.w		; 20 80 F8 ; Jump to subroutine at $F880.w [Writes: Stack Pointer] [Flow: call]
	.db $B0, $0E		; B0 0E ; Branch if carry set to $B0, $0E [Flow: branch]
	lda #$4F.b		; A9 4F ; Load #$4F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E1F0.l		; 22 F0 E1 05 ; Jump to subroutine long $05E1F0.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $03		; 90 03 ; Branch if carry clear to $90, $03 [Flow: branch]
	jsr $F846.w		; 20 46 F8 ; Jump to subroutine at $F846.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $06F129.l		; 22 29 F1 06 ; Jump to subroutine long $06F129.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $3B		; 90 3B ; Branch if carry clear to $90, $3B [Flow: branch]
	lda $F6.b		; A5 F6 ; Load $F6.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $37		; 10 37 ; Branch if plus to $10, $37 [Flow: branch]
.ACCU 16
	rep #$20		; C2 20
	lda $7EF360.l		; AF 60 F3 7E ; Load long $7EF360.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$003C.w		; C9 3C 00 ; Compare #$003C.w with accumulator [Reads: Accumulator] [Flags: NCZ]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	.db $90, $36		; 90 36 ; Branch if carry clear to $90, $36 [Flow: branch]
	jsl $1EDE2E.l		; 22 2E DE 1E ; Jump to subroutine long $1EDE2E.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $25		; 30 25 ; Branch if minus to $30, $25 [Flow: branch]
	lda #$1D.b		; A9 1D ; Load #$1D.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB8A.l		; 22 8A BB 0D ; Jump to subroutine long $0DBB8A.l [Writes: Stack Pointer] [Flow: call]
	lda #$40.b		; A9 40 ; Load #$40.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
.ACCU 16
	rep #$20		; C2 20
	lda $7EF360.l		; AF 60 F3 7E ; Load long $7EF360.l into accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$003C.w		; E9 3C 00 ; Subtract #$003C.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $7EF360.l		; 8F 60 F3 7E ; Store accumulator (long) $7EF360.l [Reads: Accumulator]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	ldy #$2F.b		; A0 2F ; Load #$2F.b into Y register [Writes: Y Index] [Flags: NZ]
	stz $02E9.w		; 9C E9 02 ; Store zero to $02E9.w
	jsl $0799AD.l		; 22 AD 99 07 ; Jump to subroutine long $0799AD.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$50.b		; A9 50 ; Load #$50.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	jmp $F846.w		; 4C 46 F8 ; Jump to $F846.w [Flow: jump]
	jmp $F83E.w		; 4C 3E F8 ; Jump to $F83E.w [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$08.b		; C0 08 ; Compare #$08.b with Y register [Reads: Y Index] [Flags: NCZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0012FF.l,X		; FF FF 12 00 ; Subtract with carry (long,X) $0012FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $00000A.l		; 22 0A 00 00 ; Jump to subroutine long $00000A.l [Writes: Stack Pointer] [Flow: call]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	stz $07.b		; 64 07 ; Store zero to $07.b
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
	lda #$F7.b		; A9 F7 ; Load #$F7.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $09.b		; 85 09 ; Store accumulator to $09.b [Reads: Accumulator]
	jsl $05DF75.l		; 22 75 DF 05 ; Jump to subroutine long $05DF75.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $F7BD.w		; 20 BD F7 ; Jump to subroutine at $F7BD.w [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	jsl $1EF4F3.l		; 22 F3 F4 1E ; Jump to subroutine long $1EF4F3.l [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $12		; D0 12 ; Branch if not equal to $D0, $12 [Flow: branch]
	jsr $F880.w		; 20 80 F8 ; Jump to subroutine at $F880.w [Writes: Stack Pointer] [Flow: call]
	.db $B0, $0E		; B0 0E ; Branch if carry set to $B0, $0E [Flow: branch]
	lda #$4F.b		; A9 4F ; Load #$4F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E1F0.l		; 22 F0 E1 05 ; Jump to subroutine long $05E1F0.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $03		; 90 03 ; Branch if carry clear to $90, $03 [Flow: branch]
	jsr $F846.w		; 20 46 F8 ; Jump to subroutine at $F846.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $06F129.l		; 22 29 F1 06 ; Jump to subroutine long $06F129.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $3B		; 90 3B ; Branch if carry clear to $90, $3B [Flow: branch]
	lda $F6.b		; A5 F6 ; Load $F6.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $37		; 10 37 ; Branch if plus to $10, $37 [Flow: branch]
.ACCU 16
	rep #$20		; C2 20
	lda $7EF360.l		; AF 60 F3 7E ; Load long $7EF360.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$00A0.w		; C9 A0 00 ; Compare #$00A0.w with accumulator [Reads: Accumulator] [Flags: NCZ]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	.db $90, $36		; 90 36 ; Branch if carry clear to $90, $36 [Flow: branch]
	jsl $1EDE2E.l		; 22 2E DE 1E ; Jump to subroutine long $1EDE2E.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $25		; 30 25 ; Branch if minus to $30, $25 [Flow: branch]
	lda #$1D.b		; A9 1D ; Load #$1D.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB8A.l		; 22 8A BB 0D ; Jump to subroutine long $0DBB8A.l [Writes: Stack Pointer] [Flow: call]
	lda #$40.b		; A9 40 ; Load #$40.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
.ACCU 16
	rep #$20		; C2 20
	lda $7EF360.l		; AF 60 F3 7E ; Load long $7EF360.l into accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$00A0.w		; E9 A0 00 ; Subtract #$00A0.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $7EF360.l		; 8F 60 F3 7E ; Store accumulator (long) $7EF360.l [Reads: Accumulator]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	ldy #$30.b		; A0 30 ; Load #$30.b into Y register [Writes: Y Index] [Flags: NZ]
	stz $02E9.w		; 9C E9 02 ; Store zero to $02E9.w
	jsl $0799AD.l		; 22 AD 99 07 ; Jump to subroutine long $0799AD.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$50.b		; A9 50 ; Load #$50.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	jmp $F846.w		; 4C 46 F8 ; Jump to $F846.w [Flow: jump]
	jmp $F83E.w		; 4C 3E F8 ; Jump to $F83E.w [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$04.b		; C0 04 ; Compare #$04.b with Y register [Reads: Y Index] [Flags: NCZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1200.w		; 0D 00 12 ; Logical OR $1200.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b)		; 12 00 ; OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $00000A.l		; 22 0A 00 00 ; Jump to subroutine long $00000A.l [Writes: Stack Pointer] [Flow: call]
	sbc $12FF.w,X		; FD FF 12 ; Subtract with carry $12FF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $31.b		; 00 31 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	stz $07.b		; 64 07 ; Store zero to $07.b
	lda #$9D.b		; A9 9D ; Load #$9D.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
	lda #$F7.b		; A9 F7 ; Load #$F7.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $09.b		; 85 09 ; Store accumulator to $09.b [Reads: Accumulator]
	jsl $05DF75.l		; 22 75 DF 05 ; Jump to subroutine long $05DF75.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $F86D.w		; 20 6D F8 ; Jump to subroutine at $F86D.w [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	jsl $1EF4F3.l		; 22 F3 F4 1E ; Jump to subroutine long $1EF4F3.l [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $12		; D0 12 ; Branch if not equal to $D0, $12 [Flow: branch]
	jsr $F880.w		; 20 80 F8 ; Jump to subroutine at $F880.w [Writes: Stack Pointer] [Flow: call]
	.db $B0, $0E		; B0 0E ; Branch if carry set to $B0, $0E [Flow: branch]
	lda #$4F.b		; A9 4F ; Load #$4F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E1F0.l		; 22 F0 E1 05 ; Jump to subroutine long $05E1F0.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $03		; 90 03 ; Branch if carry clear to $90, $03 [Flow: branch]
	jsr $F846.w		; 20 46 F8 ; Jump to subroutine at $F846.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $06F129.l		; 22 29 F1 06 ; Jump to subroutine long $06F129.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $3B		; 90 3B ; Branch if carry clear to $90, $3B [Flow: branch]
	lda $F6.b		; A5 F6 ; Load $F6.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $37		; 10 37 ; Branch if plus to $10, $37 [Flow: branch]
.ACCU 16
	rep #$20		; C2 20
	lda $7EF360.l		; AF 60 F3 7E ; Load long $7EF360.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$0078.w		; C9 78 00 ; Compare #$0078.w with accumulator [Reads: Accumulator] [Flags: NCZ]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	.db $90, $35		; 90 35 ; Branch if carry clear to $90, $35 [Flow: branch]
	jsl $1EDE2E.l		; 22 2E DE 1E ; Jump to subroutine long $1EDE2E.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $25		; 30 25 ; Branch if minus to $30, $25 [Flow: branch]
	lda #$1D.b		; A9 1D ; Load #$1D.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB8A.l		; 22 8A BB 0D ; Jump to subroutine long $0DBB8A.l [Writes: Stack Pointer] [Flow: call]
	lda #$40.b		; A9 40 ; Load #$40.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
.ACCU 16
	rep #$20		; C2 20
	lda $7EF360.l		; AF 60 F3 7E ; Load long $7EF360.l into accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$0078.w		; E9 78 00 ; Subtract #$0078.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $7EF360.l		; 8F 60 F3 7E ; Store accumulator (long) $7EF360.l [Reads: Accumulator]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	ldy #$2E.b		; A0 2E ; Load #$2E.b into Y register [Writes: Y Index] [Flags: NZ]
	stz $02E9.w		; 9C E9 02 ; Store zero to $02E9.w
	jsl $0799AD.l		; 22 AD 99 07 ; Jump to subroutine long $0799AD.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$50.b		; A9 50 ; Load #$50.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	.db $80, $08		; 80 08 ; Branch always to $80, $08 [Flow: branch]
	lda #$7C.b		; A9 7C ; Load #$7C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	lda #$3C.b		; A9 3C ; Load #$3C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB7C.l		; 22 7C BB 0D ; Jump to subroutine long $0DBB7C.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$02.b		; C0 02 ; Compare #$02.b with Y register [Reads: Y Index] [Flags: NCZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1200.w		; 0D 00 12 ; Logical OR $1200.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b)		; 12 00 ; OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $0A.b		; 02 0A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $12FF.w,X		; FD FF 12 ; Subtract with carry $12FF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $31.b		; 00 31 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	stz $07.b		; 64 07 ; Store zero to $07.b
	lda #$4D.b		; A9 4D ; Load #$4D.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
	lda #$F8.b		; A9 F8 ; Load #$F8.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $09.b		; 85 09 ; Store accumulator to $09.b [Reads: Accumulator]
	jsl $05DF75.l		; 22 75 DF 05 ; Jump to subroutine long $05DF75.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $7EF35C.l		; AF 5C F3 7E ; Load long $7EF35C.l into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $7EF35D.l		; 0F 5D F3 7E ; OR accumulator with memory (long) $7EF35D.l [Writes: Accumulator] [Flags: NZ]
	ora $7EF35E.l		; 0F 5E F3 7E ; OR accumulator with memory (long) $7EF35E.l [Writes: Accumulator] [Flags: NZ]
	ora $7EF35F.l		; 0F 5F F3 7E ; OR accumulator with memory (long) $7EF35F.l [Writes: Accumulator] [Flags: NZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $05F91B.l		; 22 1B F9 05 ; Jump to subroutine long $05F91B.l [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	jsl $1EF4F3.l		; 22 F3 F4 1E ; Jump to subroutine long $1EF4F3.l [Writes: Stack Pointer] [Flow: call]
	jsl $07F4D0.l		; 22 D0 F4 07 ; Jump to subroutine long $07F4D0.l [Writes: Stack Pointer] [Flow: call]
	.db $B0, $4C		; B0 4C ; Branch if carry set to $B0, $4C [Flow: branch]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $09		; F0 09 ; Branch if equal to $F0, $09 [Flow: branch]
	lda #$A0.b		; A9 A0 ; Load #$A0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF372.l		; 8F 72 F3 7E ; Store accumulator (long) $7EF372.l [Reads: Accumulator]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	lda $7EF35C.l		; AF 5C F3 7E ; Load long $7EF35C.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $2B		; B0 2B ; Branch if carry set to $B0, $2B [Flow: branch]
	lda $7EF35D.l		; AF 5D F3 7E ; Load long $7EF35D.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $23		; B0 23 ; Branch if carry set to $B0, $23 [Flow: branch]
	lda $7EF35E.l		; AF 5E F3 7E ; Load long $7EF35E.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $1B		; B0 1B ; Branch if carry set to $B0, $1B [Flow: branch]
	lda $7EF35F.l		; AF 5F F3 7E ; Load long $7EF35F.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $13		; B0 13 ; Branch if carry set to $B0, $13 [Flow: branch]
	lda $0ABF.w		; AD BF 0A ; Load $0ABF.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0E		; F0 0E ; Branch if equal to $F0, $0E [Flow: branch]
	lda #$4D.b		; A9 4D ; Load #$4D.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E1A7.l		; 22 A7 E1 05 ; Jump to subroutine long $05E1A7.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $03		; 90 03 ; Branch if carry clear to $90, $03 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$4E.b		; A9 4E ; Load #$4E.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E1A7.l		; 22 A7 E1 05 ; Jump to subroutine long $05E1A7.l [Writes: Stack Pointer] [Flow: call]
	.db $80, $F0		; 80 F0 ; Branch always to $80, $F0 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $000C00.l,X		; FF 00 0C 00 ; Subtract with carry (long,X) $000C00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0200.w		; 0C 00 02 ; Test and set bits $0200.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $000C00.l,X		; FF 00 0C 00 ; Subtract with carry (long,X) $000C00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp $0200.w		; 4C 00 02 ; Jump to $0200.w [Flow: jump]
	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	stz $07.b		; 64 07 ; Store zero to $07.b
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc #$FB.b		; 69 FB ; Add #$FB.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
	lda #$F8.b		; A9 F8 ; Load #$F8.b into accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $09.b		; 85 09 ; Store accumulator to $09.b [Reads: Accumulator]
	jsl $05DF75.l		; 22 75 DF 05 ; Jump to subroutine long $05DF75.l [Writes: Stack Pointer] [Flow: call]
	jsl $06DC54.l		; 22 54 DC 06 ; Jump to subroutine long $06DC54.l [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $06EAA0.l		; 22 A0 EA 06 ; Jump to subroutine long $06EAA0.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $06EACD.l		; 22 CD EA 06 ; Jump to subroutine long $06EACD.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $06EAE4.l		; 22 E4 EA 06 ; Jump to subroutine long $06EAE4.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DD0.w,X		; BD D0 0D ; Load $0DD0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$09.b		; C9 09 ; Compare #$09.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $13		; D0 13 ; Branch if not equal to $D0, $13 [Flow: branch]
	lda $0FC1.w		; AD C1 0F ; Load $0FC1.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0E		; D0 0E ; Branch if not equal to $D0, $0E [Flow: branch]
	lda $11.b		; A5 11 ; Load $11.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0A		; D0 0A ; Branch if not equal to $D0, $0A [Flow: branch]
	lda $0CAA.w,X		; BD AA 0C ; Load $0CAA.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $07		; 30 07 ; Branch if minus to $30, $07 [Flow: branch]
	lda $0F00.w,X		; BD 00 0F ; Load $0F00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $02		; F0 02 ; Branch if equal to $F0, $02 [Flow: branch]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $BD03.w		; 0C 03 BD ; Test and set bits $BD03.w [Reads: Accumulator] [Flags: Z]
	ldy #$0E.b		; A0 0E ; Load #$0E.b into Y register [Writes: Y Index] [Flags: NZ]
	.db $F0, $72		; F0 72 ; Branch if equal to $F0, $72 [Flow: branch]
	and #$7F.b		; 29 7F ; Logical AND #$7F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $6F		; F0 6F ; Branch if equal to $F0, $6F [Flow: branch]
	lda $0D40.w,X		; BD 40 0D ; Load $0D40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda $0D50.w,X		; BD 50 0D ; Load $0D50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	dec $0EA0.w,X		; DE A0 0E ; Decrement memory $0EA0.w,X [Reads: X Index] [Flags: NZ]
	.db $D0, $19		; D0 19 ; Branch if not equal to $D0, $19 [Flow: branch]
	lda $0F40.w,X		; BD 40 0F ; Load $0F40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$20.b		; 69 20 ; Add #$20.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$40.b		; C9 40 ; Compare #$40.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $0A		; B0 0A ; Branch if carry set to $B0, $0A [Flow: branch]
	lda $0F30.w,X		; BD 30 0F ; Load $0F30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$20.b		; 69 20 ; Add #$20.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$40.b		; C9 40 ; Compare #$40.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $05		; 90 05 ; Branch if carry clear to $90, $05 [Flow: branch]
	lda #$90.b		; A9 90 ; Load #$90.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0EA0.w,X		; 9D A0 0E ; Store accumulator to $0EA0.w,X [Reads: Accumulator, X Index]
	lda $0EA0.w,X		; BD A0 0E ; Load $0EA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $39		; 30 39 ; Branch if minus to $30, $39 [Flow: branch]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $F96B.w,Y		; 39 6B F9 ; AND accumulator with memory $F96B.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $2F		; D0 2F ; Branch if not equal to $D0, $2F [Flow: branch]
	lda $0F30.w,X		; BD 30 0F ; Load $0F30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	lda $0F40.w,X		; BD 40 0F ; Load $0F40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $0CD2.w,X		; BD D2 0C ; Load $0CD2.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $1B		; 30 1B ; Branch if minus to $30, $1B [Flow: branch]
	jsr $B88D.w		; 20 8D B8 ; Jump to subroutine at $B88D.w [Writes: Stack Pointer] [Flow: call]
	and #$0F.b		; 29 0F ; Logical AND #$0F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $14		; [PATTERN: Memory clearing operation] F0 14 ; Branch if equal to $F0, $14 [Flow: branch]
	cmp #$04.b		; C9 04 ; Compare #$04.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $08		; B0 08 ; Branch if carry set to $B0, $08 [Flow: branch]
	stz $0F40.w,X		; 9E 40 0F ; Store zero to $0F40.w,X [Reads: X Index]
	stz $0D50.w,X		; 9E 50 0D ; Store zero to $0D50.w,X [Reads: X Index]
	.db $80, $06		; [PATTERN: Memory clearing operation] 80 06 ; Branch always to $80, $06 [Flow: branch]
	stz $0F30.w,X		; 9E 30 0F ; Store zero to $0F30.w,X [Reads: X Index]
	stz $0D40.w,X		; 9E 40 0D ; Store zero to $0D40.w,X [Reads: X Index]
	.db $80, $03		; 80 03 ; Branch always to $80, $03 [Flow: branch]
	jsr $F9ED.w		; 20 ED F9 ; Jump to subroutine at $F9ED.w [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $0EA0.w,X		; 9E A0 0E ; Store zero to $0EA0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $F9F4.w		; 20 F4 F9 ; Jump to subroutine at $F9F4.w [Writes: Stack Pointer] [Flow: call]
	jsr $FA00.w		; 20 00 FA ; Jump to subroutine at $FA00.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$10.b		; 69 10 ; Add #$10.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	jsr $FA00.w		; 20 00 FA ; Jump to subroutine at $FA00.w [Writes: Stack Pointer] [Flow: call]
	ldx $0FA0.w		; AE A0 0F ; Load $0FA0.w into X register [Writes: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0D40.w,X		; BD 40 0D ; Load $0D40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $28		; F0 28 ; Branch if equal to $F0, $28 [Flow: branch]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0D60.w,X		; 7D 60 0D ; Add $0D60.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D60.w,X		; 9D 60 0D ; Store accumulator to $0D60.w,X [Reads: Accumulator, X Index]
	lda $0D40.w,X		; BD 40 0D ; Load $0D40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	.db $10, $03		; 10 03 ; Branch if plus to $10, $03 [Flow: branch]
	ora #$F0.b		; 09 F0 ; Logical OR #$F0.b with accumulator [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	adc $0D00.w,X		; 7D 00 0D ; Add $0D00.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,X		; 9D 00 0D ; Store accumulator to $0D00.w,X [Reads: Accumulator, X Index]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $0D20.w,X		; 7D 20 0D ; Add $0D20.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D20.w,X		; 9D 20 0D ; Store accumulator to $0D20.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0F80.w,X		; BD 80 0F ; Load $0F80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0F90.w,X		; 7D 90 0F ; Add $0F90.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0F90.w,X		; 9D 90 0F ; Store accumulator to $0F90.w,X [Reads: Accumulator, X Index]
	lda $0F80.w,X		; BD 80 0F ; Load $0F80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	.db $10, $02		; 10 02 ; Branch if plus to $10, $02 [Flow: branch]
	ora #$F0.b		; 09 F0 ; Logical OR #$F0.b with accumulator [Writes: Accumulator] [Flags: NZ]
	adc $0F70.w,X		; 7D 70 0F ; Add $0F70.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0F70.w,X		; 9D 70 0F ; Store accumulator to $0F70.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $06E416.l		; 22 16 E4 06 ; Jump to subroutine long $06E416.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $02		; 90 02 ; Branch if carry clear to $90, $02 [Flow: branch]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sta $1CF0.w		; 8D F0 1C ; Store accumulator to $1CF0.w [Reads: Accumulator]
	sty $1CF1.w		; 8C F1 1C ; Store Y register to $1CF1.w [Reads: Y Index]
	lda $0E40.w,X		; BD 40 0E ; Load $0E40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda #$80.b		; A9 80 ; Load #$80.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E40.w,X		; 9D 40 0E ; Store accumulator to $0E40.w,X [Reads: Accumulator, X Index]
	lda $0F60.w,X		; BD 60 0F ; Load $0F60.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda #$07.b		; A9 07 ; Load #$07.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F60.w,X		; 9D 60 0F ; Store accumulator to $0F60.w,X [Reads: Accumulator, X Index]
	jsl $06F129.l		; 22 29 F1 06 ; Jump to subroutine long $06F129.l [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $0F60.w,X		; 9D 60 0F ; Store accumulator to $0F60.w,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $0E40.w,X		; 9D 40 0E ; Store accumulator to $0E40.w,X [Reads: Accumulator, X Index]
	.db $90, $22		; 90 22 ; Branch if carry clear to $90, $22 [Flow: branch]
	php		; [PATTERN: Memory clearing operation] 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsl $0FF540.l		; 22 40 F5 0F ; Jump to subroutine long $0FF540.l [Writes: Stack Pointer] [Flow: call]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	stz $0372.w		; 9C 72 03 ; Store zero to $0372.w
	stz $5E.b		; 64 5E ; Store zero to $5E.b
	lda $4D.b		; [PATTERN: Memory clearing operation] A5 4D ; Load $4D.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $13		; D0 13 ; Branch if not equal to $D0, $13 [Flow: branch]
	stz $0223.w		; 9C 23 02 ; Store zero to $0223.w
	stz $1CD8.w		; 9C D8 1C ; Store zero to $1CD8.w
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $11.b		; 85 11 ; Store accumulator to $11.b [Reads: Accumulator]
	lda $10.b		; A5 10 ; Load $10.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $010C.w		; 8D 0C 01 ; Store accumulator to $010C.w [Reads: Accumulator]
	lda #$0E.b		; A9 0E ; Load #$0E.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $10.b		; 85 10 ; Store accumulator to $10.b [Reads: Accumulator]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

.ACCU 16
.INDEX 16
	rep #$30		; C2 30
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $0708.w		; ED 08 07 ; Subtract $0708.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	and $070A.w		; 2D 0A 07 ; Logical AND $070A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $070C.w		; ED 0C 07 ; Subtract $070C.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	and $070E.w		; 2D 0E 07 ; Logical AND $070E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $7E2000.l,X		; BF 00 20 7E ; Load long $7E2000.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $1BF110.l,X		; BF 10 F1 1B ; Load long $1BF110.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $FAD2.w		; 20 D2 FA ; Jump to subroutine at $FAD2.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0EB0.w,X		; BD B0 0E ; Load $0EB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $05		; F0 05 ; Branch if equal to $F0, $05 [Flow: branch]
	jsl $1E8A8E.l		; 22 8E 8A 1E ; Jump to subroutine long $1E8A8E.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	jsl $06DBF0.l		; 22 F0 DB 06 ; Jump to subroutine long $06DBF0.l [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	jsr $F9ED.w		; 20 ED F9 ; Jump to subroutine at $F9ED.w [Writes: Stack Pointer] [Flow: call]
	jsr $FA2E.w		; 20 2E FA ; Jump to subroutine at $FA2E.w [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	sbc $FB3CFA.l,X		; FF FA 3C FB ; Subtract with carry (long,X) $FB3CFA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	stx $B9FB.w		; 8E FB B9 ; Store X register to $B9FB.w [Reads: X Index]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	cpx $FB.b		; E4 FB ; Compare $FB.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	lda $7EF37B.l		; AF 7B F3 7E ; Load long $7EF37B.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$01.b		; C9 01 ; Compare #$01.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $32		; B0 32 ; Branch if carry set to $B0, $32 [Flow: branch]
	jsl $06F129.l		; 22 29 F1 06 ; Jump to subroutine long $06F129.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $2C		; 90 2C ; Branch if carry clear to $90, $2C [Flow: branch]
	ldy #$04.b		; A0 04 ; Load #$04.b into Y register [Writes: Y Index] [Flags: NZ]
	lda $0C4A.w,Y		; B9 4A 0C ; Load $0C4A.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$1A.b		; C9 1A ; Compare #$1A.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $10, $F6		; 10 F6 ; Branch if plus to $10, $F6 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $09AE40.l		; 22 40 AE 09 ; Jump to subroutine long $09AE40.l [Writes: Stack Pointer] [Flow: call]
	lda #$0D.b		; A9 0D ; Load #$0D.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB6E.l		; 22 6E BB 0D ; Jump to subroutine long $0DBB6E.l [Writes: Stack Pointer] [Flow: call]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$14.b		; A9 14 ; Load #$14.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D90.w,X		; 9D 90 0D ; Store accumulator to $0D90.w,X [Reads: Accumulator, X Index]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $02E4.w		; 8D E4 02 ; Store accumulator to $02E4.w [Reads: Accumulator]
	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$20.b		; 09 20 ; Logical OR #$20.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sed		; F8 ; Set decimal flag [Flags: D]
	ora [$BD.b]		; 07 BD ; OR accumulator with memory (long) [$BD.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0D		; F0 0D ; Branch if equal to $F0, $0D [Flow: branch]
	.db $D0, $2A		; D0 2A ; Branch if not equal to $D0, $2A [Flow: branch]
	dec $0D90.w,X		; DE 90 0D ; Decrement memory $0D90.w,X [Reads: X Index] [Flags: NZ]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	cmp #$01.b		; C9 01 ; Compare #$01.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $1E		; F0 1E ; Branch if equal to $F0, $1E [Flow: branch]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $FB3A.w,Y		; B9 3A FB ; Load $FB3A.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0D50.w,X		; 7D 50 0D ; Add $0D50.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$01.b		; 49 01 ; Exclusive OR #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; [PATTERN: Memory clearing operation] A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	stz $0DC0.w,X		; 9E C0 0D ; Store zero to $0DC0.w,X [Reads: X Index]
	stz $0F80.w,X		; 9E 80 0F ; Store zero to $0F80.w,X [Reads: X Index]
	stz $0D50.w,X		; 9E 50 0D ; Store zero to $0D50.w,X [Reads: X Index]
	lda #$FF.b		; A9 FF ; Load #$FF.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0B		; D0 0B ; Branch if not equal to $D0, $0B [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$40.b		; A9 40 ; Load #$40.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E00.w,X		; 9D 00 0E ; Store accumulator to $0E00.w,X [Reads: Accumulator, X Index]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$F1.b		; 29 F1 ; Logical AND #$F1.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $FB86.w,Y		; 19 86 FB ; OR accumulator with memory $FB86.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$F0.b		; C9 F0 ; Compare #$F0.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $04		; D0 04 ; Branch if not equal to $D0, $04 [Flow: branch]
	jsl $09AEA8.l		; 22 A8 AE 09 ; Jump to subroutine long $09AEA8.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0E00.w,X		; BD 00 0E ; Load $0E00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $1E		; D0 1E ; Branch if not equal to $D0, $1E [Flow: branch]
	lda #$11.b		; A9 11 ; Load #$11.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	jsl $0ED8FB.l		; 22 FB D8 0E ; Jump to subroutine long $0ED8FB.l [Writes: Stack Pointer] [Flow: call]
	inc $15.b		; E6 15 ; Increment $15.b [Reads: Direct Page] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF37B.l		; 8F 7B F3 7E ; Store accumulator (long) $7EF37B.l [Reads: Accumulator]
	jsl $0DDB7F.l		; 22 7F DB 0D ; Jump to subroutine long $0DDB7F.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cmp #$10.b		; C9 10 ; Compare #$10.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	sta $0FF9.w		; [PATTERN: Memory clearing operation] 8D F9 0F ; Store accumulator to $0FF9.w [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $09AE7E.l		; 22 7E AE 09 ; Jump to subroutine long $09AE7E.l [Writes: Stack Pointer] [Flow: call]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	stz $02E4.w		; 9C E4 02 ; Store zero to $02E4.w
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $FBF7.w		; 20 F7 FB ; Jump to subroutine at $FBF7.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	stz $04FC.w,X		; 9E FC 04 ; Store zero to $04FC.w,X [Reads: X Index]
	jsr ($FD4D.w,X)		; FC 4D FD ; Jump to subroutine indirect indexed ($FD4D.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsl $06DD38.l		; 22 38 DD 06 ; Jump to subroutine long $06DD38.l [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	jsl $06F129.l		; 22 29 F1 06 ; Jump to subroutine long $06F129.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $05		; 90 05 ; Branch if carry clear to $90, $05 [Flow: branch]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D80.w,X		; 9D 80 0D ; Store accumulator to $0D80.w,X [Reads: Accumulator, X Index]
	jsr $F9ED.w		; 20 ED F9 ; Jump to subroutine at $F9ED.w [Writes: Stack Pointer] [Flow: call]
	dec $0F80.w,X		; DE 80 0F ; Decrement memory $0F80.w,X [Reads: X Index] [Flags: NZ]
	jsr $FA2E.w		; [PATTERN: Memory clearing operation] 20 2E FA ; Jump to subroutine at $FA2E.w [Writes: Stack Pointer] [Flow: call]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $1B		; 10 1B ; Branch if plus to $10, $1B [Flow: branch]
	stz $0D40.w,X		; 9E 40 0D ; Store zero to $0D40.w,X [Reads: X Index]
	stz $0F70.w,X		; 9E 70 0F ; Store zero to $0F70.w,X [Reads: X Index]
	lda $0F80.w,X		; BD 80 0F ; Load $0F80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	and #$FE.b		; 29 FE ; Logical AND #$FE.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $06		; F0 06 ; Branch if equal to $F0, $06 [Flow: branch]
	lda #$14.b		; A9 14 ; Load #$14.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB8A.l		; 22 8A BB 0D ; Jump to subroutine long $0DBB8A.l [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	lsr $1BFC.w		; 4E FC 1B ; Logical shift right $1BFC.w [Flags: NCZ]
	sbc $FD2E.w,X		; FD 2E FD ; Subtract with carry $FD2E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $C2FC.w,X		; 7E FC C2 ; Rotate right $C2FC.w,X [Reads: X Index] [Flags: NCZ]
	jsr $D8AD.w		; 20 AD D8 ; Jump to subroutine at $D8AD.w [Writes: Stack Pointer] [Flow: call]
	ora $22E538.l		; 0F 38 E5 22 ; OR accumulator with memory (long) $22E538.l [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$10.b		; 69 10 ; Add #$10.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	brk $C9.b		; 00 C9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($00.b,X)		; 21 00 ; Logical AND ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $B0, $1A		; B0 1A ; Branch if carry set to $B0, $1A [Flow: branch]
	lda $0FDA.w		; AD DA 0F ; Load $0FDA.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $20.b		; E5 20 ; Subtract $20.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$18.b		; 69 18 ; Add #$18.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	brk $C9.b		; 00 C9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and #$00.b		; 29 00 ; Logical AND #$00.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $B0, $0B		; B0 0B ; Branch if carry set to $B0, $0B [Flow: branch]
	lda $011A.w		; AD 1A 01 ; Load $011A.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $011C.w		; 0D 1C 01 ; Logical OR $011C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	jsr $6FAF.w		; 20 AF 6F ; Jump to subroutine at $6FAF.w [Writes: Stack Pointer] [Flow: call]
	sbc ($7E.b,S),Y		; F3 7E ; Subtract with carry (stack relative indirect indexed) ($7E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $7EF36F.l		; 8F 6F F3 7E ; Store accumulator (long) $7EF36F.l [Reads: Accumulator]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	lda $0CBA.w,X		; BD BA 0C ; Load $0CBA.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $0403.w		; AD 03 04 ; Load $0403.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $FC7C.w,Y		; 19 7C FC ; OR accumulator with memory $FC7C.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0403.w		; 8D 03 04 ; Store accumulator to $0403.w [Reads: Accumulator]
	lda #$2F.b		; A9 2F ; Load #$2F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB8A.l		; 22 8A BB 0D ; Jump to subroutine long $0DBB8A.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $06DBF0.l		; 22 F0 DB 06 ; Jump to subroutine long $06DBF0.l [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	jsl $06F129.l		; 22 29 F1 06 ; Jump to subroutine long $06F129.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $05		; 90 05 ; Branch if carry clear to $90, $05 [Flow: branch]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D80.w,X		; 9D 80 0D ; Store accumulator to $0D80.w,X [Reads: Accumulator, X Index]
	jsr $F9ED.w		; 20 ED F9 ; Jump to subroutine at $F9ED.w [Writes: Stack Pointer] [Flow: call]
	dec $0F80.w,X		; DE 80 0F ; Decrement memory $0F80.w,X [Reads: X Index] [Flags: NZ]
	jsr $FA2E.w		; [PATTERN: Memory clearing operation] 20 2E FA ; Jump to subroutine at $FA2E.w [Writes: Stack Pointer] [Flow: call]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $1B		; 10 1B ; Branch if plus to $10, $1B [Flow: branch]
	stz $0D40.w,X		; 9E 40 0D ; Store zero to $0D40.w,X [Reads: X Index]
	stz $0F70.w,X		; 9E 70 0F ; Store zero to $0F70.w,X [Reads: X Index]
	lda $0F80.w,X		; BD 80 0F ; Load $0F80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	and #$FE.b		; 29 FE ; Logical AND #$FE.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $06		; F0 06 ; Branch if equal to $F0, $06 [Flow: branch]
	lda #$21.b		; A9 21 ; Load #$21.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB7C.l		; 22 7C BB 0D ; Jump to subroutine long $0DBB7C.l [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	jsr ($FD1B.w,X)		; FC 1B FD ; Jump to subroutine indirect indexed ($FD1B.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	rol $3AFD.w		; 2E FD 3A ; Rotate left $3AFD.w [Flags: NCZ]
	sbc $2FAD.w,X		; FD AD 2F ; Subtract with carry $2FAD.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
.ACCU 16
	rep #$20		; C2 20
	lda $0FD8.w		; AD D8 0F ; Load $0FD8.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $22.b		; E5 22 ; Subtract $22.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0027.w		; 69 27 00 ; Add #$0027.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$002F.w		; C9 2F 00 ; Compare #$002F.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $1A		; B0 1A ; Branch if carry set to $B0, $1A [Flow: branch]
	lda $0FDA.w		; AD DA 0F ; Load $0FDA.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $20.b		; E5 20 ; Subtract $20.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0028.w		; 69 28 00 ; Add #$0028.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$002E.w		; C9 2E 00 ; Compare #$002E.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $0B		; B0 0B ; Branch if carry set to $B0, $0B [Flow: branch]
	lda $011A.w		; AD 1A 01 ; Load $011A.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $011C.w		; 0D 1C 01 ; Logical OR $011C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	lda #$FB.b		; A9 FB ; Load #$FB.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$1B.b		; A9 1B ; Load #$1B.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012F.w		; 8D 2F 01 ; Store accumulator to $012F.w [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $06		; D0 06 ; Branch if not equal to $D0, $06 [Flow: branch]
	lda $00EE.w		; AD EE 00 ; Load $00EE.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F20.w,X		; 9D 20 0F ; Store accumulator to $0F20.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	jsl $0791B9.l		; 22 B9 91 07 ; Jump to subroutine long $0791B9.l [Writes: Stack Pointer] [Flow: call]
	ldy #$1D.b		; [PATTERN: Memory clearing operation] A0 1D ; Load #$1D.b into Y register [Writes: Y Index] [Flags: NZ]
	stz $02E9.w		; 9C E9 02 ; Store zero to $02E9.w
	jsl $0799AD.l		; 22 AD 99 07 ; Jump to subroutine long $0799AD.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$8F.b		; A9 8F ; Load #$8F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E40.w,X		; 9D 40 0E ; Store accumulator to $0E40.w,X [Reads: Accumulator, X Index]
	lda #$47.b		; A9 47 ; Load #$47.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F60.w,X		; 9D 60 0F ; Store accumulator to $0F60.w,X [Reads: Accumulator, X Index]
	jsr $FE6F.w		; 20 6F FE ; Jump to subroutine at $FE6F.w [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	jsl $06F129.l		; 22 29 F1 06 ; Jump to subroutine long $06F129.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $0C		; 90 0C ; Branch if carry clear to $90, $0C [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	jsl $0FF540.l		; 22 40 F5 0F ; Jump to subroutine long $0FF540.l [Writes: Stack Pointer] [Flow: call]
	stz $5E.b		; 64 5E ; Store zero to $5E.b
	jsl $079291.l		; 22 91 92 07 ; Jump to subroutine long $079291.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	jsr $F9ED.w		; 20 ED F9 ; Jump to subroutine at $F9ED.w [Writes: Stack Pointer] [Flow: call]
	dec $0F80.w,X		; DE 80 0F ; Decrement memory $0F80.w,X [Reads: X Index] [Flags: NZ]
	jsr $FA2E.w		; 20 2E FA ; Jump to subroutine at $FA2E.w [Writes: Stack Pointer] [Flow: call]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $0E		; 10 0E ; Branch if plus to $10, $0E [Flow: branch]
	stz $0F70.w,X		; 9E 70 0F ; Store zero to $0F70.w,X [Reads: X Index]
	lda $0F80.w,X		; BD 80 0F ; Load $0F80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $FDD0.w,X		; FD D0 FD ; Subtract with carry $FDD0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	inc $809E.w,X		; FE 9E 80 ; Increment memory $809E.w,X [Reads: X Index] [Flags: NZ]
	asl $20C2.w		; 0E C2 20 ; Arithmetic shift left $20C2.w [Flags: NCZ]
	lda $0FD8.w		; AD D8 0F ; Load $0FD8.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $22.b		; E5 22 ; Subtract $22.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$18.b		; 69 18 ; Add #$18.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	brk $C9.b		; 00 C9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($00.b,X)		; 41 00 ; Exclusive OR accumulator with memory ($00.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $21		; B0 21 ; Branch if carry set to $B0, $21 [Flow: branch]
	lda $0FDA.w		; AD DA 0F ; Load $0FDA.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $20.b		; E5 20 ; Subtract $20.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$20.b		; 69 20 ; Add #$20.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	brk $C9.b		; 00 C9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($00.b),Y		; 51 00 ; Exclusive OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $12		; B0 12 ; Branch if carry set to $B0, $12 [Flow: branch]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	lda $011A.w		; AD 1A 01 ; Load $011A.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $011C.w		; 0D 1C 01 ; Logical OR $011C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $08		; F0 08 ; Branch if equal to $F0, $08 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$14.b		; A9 14 ; Load #$14.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $35		; D0 35 ; Branch if not equal to $D0, $35 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$1B.b		; A9 1B ; Load #$1B.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012F.w		; 8D 2F 01 ; Store accumulator to $012F.w [Reads: Accumulator]
	lda #$FC.b		; A9 FC ; Load #$FC.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	jsr $FF39.w		; 20 39 FF ; Jump to subroutine at $FF39.w [Writes: Stack Pointer] [Flow: call]
	lda #$05.b		; A9 05 ; Load #$05.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,Y		; 99 50 0D ; Store accumulator to $0D50.w,Y [Reads: Y Index, Accumulator]
	sta $0D40.w,Y		; 99 40 0D ; Store accumulator to $0D40.w,Y [Reads: Y Index, Accumulator]
	jsr $FF39.w		; 20 39 FF ; Jump to subroutine at $FF39.w [Writes: Stack Pointer] [Flow: call]
	lda #$05.b		; A9 05 ; Load #$05.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,Y		; 99 50 0D ; Store accumulator to $0D50.w,Y [Reads: Y Index, Accumulator]
	lda #$FC.b		; A9 FC ; Load #$FC.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,Y		; 99 40 0D ; Store accumulator to $0D40.w,Y [Reads: Y Index, Accumulator]
	jsr $FF39.w		; 20 39 FF ; Jump to subroutine at $FF39.w [Writes: Stack Pointer] [Flow: call]
	lda #$FC.b		; A9 FC ; Load #$FC.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,Y		; 99 50 0D ; Store accumulator to $0D50.w,Y [Reads: Y Index, Accumulator]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,Y		; 99 40 0D ; Store accumulator to $0D40.w,Y [Reads: Y Index, Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $12		; D0 12 ; Branch if not equal to $D0, $12 [Flow: branch]
	lda #$08.b		; A9 08 ; Load #$08.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$06.b		; C9 06 ; Compare #$06.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $31.b		; 00 31 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $31.b		; 02 31 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $71.b		; 02 71 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $71.b		; 00 71 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $2231.w		; 20 31 22 ; Jump to subroutine at $2231.w [Writes: Stack Pointer] [Flow: call]
	and ($22.b),Y		; 31 22 ; AND accumulator with memory ($22.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc ($20.b),Y		; 71 20 ; Add with carry ($20.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($04.b),Y		; 71 04 ; Add with carry ($04.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($06.b),Y		; 31 06 ; AND accumulator with memory ($06.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($06.b),Y		; 31 06 ; AND accumulator with memory ($06.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc ($04.b),Y		; 71 04 ; Add with carry ($04.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($24.b),Y		; 71 24 ; Add with carry ($24.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($26.b),Y		; 31 26 ; AND accumulator with memory ($26.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($26.b),Y		; 31 26 ; AND accumulator with memory ($26.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc ($24.b),Y		; 71 24 ; Add with carry ($24.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($0A.b),Y		; 71 0A ; Add with carry ($0A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $1E.b,X		; 16 1E ; Arithmetic shift left $1E.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $0D.b		; 05 0D ; Logical OR $0D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $1100.w,X		; 1D 00 11 ; OR accumulator with memory $1100.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	bit $210F.w		; 2C 0F 21 ; Test bits $210F.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	ora ($1A.b)		; 12 1A ; OR accumulator with memory (indirect) ($1A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $10, $18		; 10 18 ; Branch if plus to $10, $18 [Flow: branch]
	ora [$22.b],Y		; 17 22 ; OR accumulator with memory (long indexed) [$22.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $1E.b,S		; 23 1E ; AND accumulator with stack relative $1E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0A2A2E.l,X		; 1F 2E 2A 0A ; Logical OR long $0A2A2E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and ($71.b),Y		; 31 71 ; AND accumulator with memory ($71.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($71.b),Y		; 31 71 ; AND accumulator with memory ($71.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($71.b),Y		; 31 71 ; AND accumulator with memory ($71.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsr $FA50.w		; 20 50 FA ; Jump to subroutine at $FA50.w [Writes: Stack Pointer] [Flow: call]
	lda $0FA8.w		; AD A8 0F ; Load $0FA8.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$20.b		; E9 20 ; Subtract #$20.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0FA8.w		; 8D A8 0F ; Store accumulator to $0FA8.w [Reads: Accumulator]
	lda $0FA9.w		; AD A9 0F ; Load $0FA9.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$20.b		; E9 20 ; Subtract #$20.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0FA9.w		; 8D A9 0F ; Store accumulator to $0FA9.w [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $6D		; D0 6D ; Branch if not equal to $D0, $6D [Flow: branch]
.INDEX 16
	rep #$10		; C2 10
	ldx $90.b		; A6 90 ; Load $90.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $0FA8.w		; AD A8 0F ; Load $0FA8.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $00.b,X		; 95 00 ; Store accumulator to $00.b,X [Reads: Accumulator, X Index]
	sta $10.b,X		; 95 10 ; Store accumulator to $10.b,X [Reads: Accumulator, X Index]
	sta $20.b,X		; 95 20 ; Store accumulator to $20.b,X [Reads: Accumulator, X Index]
	sta $30.b,X		; 95 30 ; Store accumulator to $30.b,X [Reads: Accumulator, X Index]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$10.b		; 69 10 ; Add #$10.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	dec $00.b		; C6 00 ; Decrement $00.b [Reads: Direct Page] [Flags: NZ]
	.db $10, $ED		; 10 ED ; Branch if plus to $10, $ED [Flow: branch]
	ldx $90.b		; A6 90 ; Load $90.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	lda $0FA9.w		; AD A9 0F ; Load $0FA9.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $01.b,X		; 95 01 ; Store accumulator to $01.b,X [Reads: Accumulator, X Index]
	sta $05.b,X		; 95 05 ; Store accumulator to $05.b,X [Reads: Accumulator, X Index]
	sta $09.b,X		; 95 09 ; Store accumulator to $09.b,X [Reads: Accumulator, X Index]
	sta $0D.b,X		; 95 0D ; Store accumulator to $0D.b,X [Reads: Accumulator, X Index]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$10.b		; 69 10 ; Add #$10.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $11.b,X		; 95 11 ; Store accumulator to $11.b,X [Reads: Accumulator, X Index]
	sta $15.b,X		; 95 15 ; Store accumulator to $15.b,X [Reads: Accumulator, X Index]
	sta $19.b,X		; 95 19 ; Store accumulator to $19.b,X [Reads: Accumulator, X Index]
	sta $1D.b,X		; 95 1D ; Store accumulator to $1D.b,X [Reads: Accumulator, X Index]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$10.b		; 69 10 ; Add #$10.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $21.b,X		; 95 21 ; Store accumulator to $21.b,X [Reads: Accumulator, X Index]
	sta $25.b,X		; 95 25 ; Store accumulator to $25.b,X [Reads: Accumulator, X Index]
	sta $29.b,X		; 95 29 ; Store accumulator to $29.b,X [Reads: Accumulator, X Index]
	sta $2D.b,X		; 95 2D ; Store accumulator to $2D.b,X [Reads: Accumulator, X Index]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$10.b		; 69 10 ; Add #$10.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $31.b,X		; 95 31 ; Store accumulator to $31.b,X [Reads: Accumulator, X Index]
	sta $35.b,X		; 95 35 ; Store accumulator to $35.b,X [Reads: Accumulator, X Index]
	sta $39.b,X		; 95 39 ; Store accumulator to $39.b,X [Reads: Accumulator, X Index]
	sta $3D.b,X		; 95 3D ; Store accumulator to $3D.b,X [Reads: Accumulator, X Index]
.ACCU 16
.INDEX 16
	rep #$30		; C2 30
	ldy #$0000.w		; A0 00 00 ; Load #$0000.w into Y register [Writes: Y Index] [Flags: NZ]
	lda $FE23.w,Y		; B9 23 FE ; Load $FE23.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $02.b,X		; 95 02 ; Store accumulator to $02.b,X [Reads: Accumulator, X Index]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cpy #$0020.w		; C0 20 00 ; Compare #$0020.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $90, $F0		; 90 F0 ; Branch if carry clear to $90, $F0 [Flow: branch]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda #$0F.b		; A9 0F ; Load #$0F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$02.b		; A0 02 ; Load #$02.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $06FEB4.l		; 22 B4 FE 06 ; Jump to subroutine long $06FEB4.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	stz $01.b		; 64 01 ; Store zero to $01.b
.INDEX 16
	rep #$10		; C2 10
	ldx $90.b		; A6 90 ; Load $90.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	ldy #$000F.w		; A0 0F 00 ; Load #$000F.w into Y register [Writes: Y Index] [Flags: NZ]
	lda $0FA8.w		; AD A8 0F ; Load $0FA8.w into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $FE43.w,Y		; 79 43 FE ; Add $FE43.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $00.b,X		; 95 00 ; Store accumulator to $00.b,X [Reads: Accumulator, X Index]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	lda $0FA9.w		; AD A9 0F ; Load $0FA9.w into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $FE53.w,Y		; 79 53 FE ; Add $FE53.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $00.b,X		; 95 00 ; Store accumulator to $00.b,X [Reads: Accumulator, X Index]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	ldy $00.b		; A4 00 ; Load $00.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	lda $FE63.w,Y		; B9 63 FE ; Load $FE63.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,X		; 95 00 ; Store accumulator to $00.b,X [Reads: Accumulator, X Index]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	lda $FE69.w,Y		; B9 69 FE ; Load $FE69.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,X		; 95 00 ; Store accumulator to $00.b,X [Reads: Accumulator, X Index]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $10, $D9		; 10 D9 ; Branch if plus to $10, $D9 [Flow: branch]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda #$0F.b		; A9 0F ; Load #$0F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$02.b		; A0 02 ; Load #$02.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $06FEB4.l		; 22 B4 FE 06 ; Jump to subroutine long $06FEB4.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$3B.b		; A9 3B ; Load #$3B.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,Y		; 99 C0 0D ; Store accumulator to $0DC0.w,Y [Reads: Y Index, Accumulator]
	lda $0F80.w,X		; BD 80 0F ; Load $0F80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0F80.w,Y		; 99 80 0F ; Store accumulator to $0F80.w,Y [Reads: Y Index, Accumulator]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E80.w,Y		; 99 80 0E ; Store accumulator to $0E80.w,Y [Reads: Y Index, Accumulator]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D80.w,Y		; 99 80 0D ; Store accumulator to $0D80.w,Y [Reads: Y Index, Accumulator]
	lda #$08.b		; A9 08 ; Load #$08.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,Y		; 99 F0 0D ; Store accumulator to $0DF0.w,Y [Reads: Y Index, Accumulator]
	jsl $09AE64.l		; 22 64 AE 09 ; Jump to subroutine long $09AE64.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $FF66.w		; 20 66 FF ; Jump to subroutine at $FF66.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $FFDF.w		; 20 DF FF ; Jump to subroutine at $FFDF.w [Writes: Stack Pointer] [Flow: call]
	jsr $F94E.w		; 20 4E F9 ; Jump to subroutine at $F94E.w [Writes: Stack Pointer] [Flow: call]
	jsl $1EF4F3.l		; 22 F3 F4 1E ; Jump to subroutine long $1EF4F3.l [Writes: Stack Pointer] [Flow: call]
	jsl $05DCA2.l		; 22 A2 DC 05 ; Jump to subroutine long $05DCA2.l [Writes: Stack Pointer] [Flow: call]
	jsr $F93F.w		; 20 3F F9 ; Jump to subroutine at $F93F.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor #$03.b		; 49 03 ; Exclusive OR #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	lda $7EF3C7.l		; AF C7 F3 7E ; Load long $7EF3C7.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $11		; B0 11 ; Branch if carry set to $B0, $11 [Flow: branch]
	lda #$47.b		; A9 47 ; Load #$47.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E1A7.l		; 22 A7 E1 05 ; Jump to subroutine long $05E1A7.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $06		; 90 06 ; Branch if carry clear to $90, $06 [Flow: branch]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF3C7.l		; 8F C7 F3 7E ; Store accumulator (long) $7EF3C7.l [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$48.b		; A9 48 ; Load #$48.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E1A7.l		; 22 A7 E1 05 ; Jump to subroutine long $05E1A7.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $000882.l,X		; FF 82 08 00 ; Subtract with carry (long,X) $000882.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $AA.b		; 00 AA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $000882.l,X		; FF 82 08 00 ; Subtract with carry (long,X) $000882.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $AA.b		; 00 AA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $004880.l,X		; FF 80 48 00 ; Subtract with carry (long,X) $004880.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $AA.b		; 00 AA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $000880.l,X		; FF 80 08 00 ; Subtract with carry (long,X) $000880.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $AA.b		; 00 AA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	stz $07.b		; 64 07 ; Store zero to $07.b
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc #$9F.b		; 69 9F ; Add #$9F.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
	lda #$FF.b		; A9 FF ; Load #$FF.b into accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $09.b		; 85 09 ; Store accumulator to $09.b [Reads: Accumulator]
	jsl $05DF75.l		; 22 75 DF 05 ; Jump to subroutine long $05DF75.l [Writes: Stack Pointer] [Flow: call]
	jsl $06DC54.l		; 22 54 DC 06 ; Jump to subroutine long $06DC54.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $FF		; Opcode FF overrunning bank boundry at 02FFFF. Skipping. ; Subtract with carry (long,X) $FF [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
.ENDS
