.BANK 25 SLOT 0
.ORG $0000

.SECTION "Bank25" FORCE

	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($40.b)		; 12 40 ; OR accumulator with memory (indirect) ($40.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	adc $40.b,S		; 63 40 ; Add with carry (stack relative) $40.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($47.b)		; F2 47 ; Subtract with carry (indirect) ($47.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $53.b,X		; 95 53 ; Store accumulator to $53.b,X [Reads: Accumulator, X Index]
	sta $53.b,X		; 95 53 ; Store accumulator to $53.b,X [Reads: Accumulator, X Index]
	.db $B0, $53		; B0 53 ; Branch if carry set to $B0, $53 [Flow: branch]
	pei ($53.b)		; D4 53 ; Push effective indirect address ($53.b) [Reads: Direct Page] [Writes: Stack Pointer]
	sbc $541353.l		; EF 53 13 54 ; Subtract with carry (long) $541353.l [Writes: Accumulator] [Flags: NCVZ]
	rol $7654.w		; 2E 54 76 ; Rotate left $7654.w [Flags: NCZ]
	mvn $54,$A3		; 54 A3 54 ; Move block negative $54,$A3 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $552155.l		; 0F 55 21 55 ; OR accumulator with memory (long) $552155.l [Writes: Accumulator] [Flags: NZ]
	lda ($55.b),Y		; B1 55 ; Load accumulator ($55.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $2D5B.w		; 2D 5B 2D ; Logical AND $2D5B.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	and $BB5B.w		; 2D 5B BB ; Logical AND $BB5B.w with accumulator [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $9D68.w		; AD 68 9D ; Load $9D68.w into accumulator [Writes: Accumulator] [Flags: NZ]
	jmp ($6CD3.w)		; 6C D3 6C ; Jump indirect to ($6CD3.w) [Flow: jump]
	adc $7A.b		; 65 7A ; Add $7A.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc $7A.b		; 65 7A ; Add $7A.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $7C.b,S		; 03 7C ; OR accumulator with stack relative $7C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jmp ($7CDB.w,X)		; 7C DB 7C ; Jump indirect indexed to ($7CDB.w,X) [Reads: X Index] [Flow: jump]
	ldx $7E.b		; A6 7E ; Load $7E.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	cmp ($7E.b,X)		; C1 7E ; Compare accumulator ($7E.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	adc $7D86.w,X		; 7D 86 7D ; Add $7D86.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	stx $6A.b		; 86 6A ; Store X register to $6A.b [Reads: X Index]
	sta $8D85.w		; 8D 85 8D ; Store accumulator to $8D85.w [Reads: Accumulator]
	lsr $8D94.w		; 4E 94 8D ; Logical shift right $8D94.w [Flags: NCZ]
	sty $BC.b,X		; 94 BC ; Store Y register $BC.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	lda ($8D.b,X)		; A1 8D ; Load accumulator ($8D.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sty $BC.b,X		; 94 BC ; Store Y register $BC.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	lda ($BC.b,X)		; A1 BC ; Load accumulator ($BC.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lda ($E7.b,X)		; A1 E7 ; Load accumulator ($E7.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ldx $B5.b		; A6 B5 ; Load $B5.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	ldx $B0D1.w		; AE D1 B0 ; Load $B0D1.w into X register [Writes: X Index] [Flags: NZ]
	cpx $2CB0.w		; EC B0 2C ; Compare $2CB0.w with X register [Reads: X Index] [Flags: NCZ]
	lda ($2C.b,S),Y		; B3 2C ; Load accumulator (stack relative indirect indexed) ($2C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda ($61.b,S),Y		; B3 61 ; Load accumulator (stack relative indirect indexed) ($61.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy #$7A.b		; A0 7A ; Load #$7A.b into Y register [Writes: Y Index] [Flags: NZ]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $6A.b		; 00 6A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $AACCCE.l		; 0F CE CC AA ; OR accumulator with memory (long) $AACCCE.l [Writes: Accumulator] [Flags: NZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	ldy $7ACB.w,X		; BC CB 7A ; Load Y register $7ACB.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	sbc $EEEEEF.l		; EF EF EE EE ; Subtract with carry (long) $EEEEEF.l [Writes: Accumulator] [Flags: NCVZ]
	dec $CCDC.w,X		; DE DC CC ; Decrement memory $CCDC.w,X [Reads: X Index] [Flags: NZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ldy $EDCC.w,X		; BC CC ED ; Load Y register $EDCC.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	sbc $32116A.l,X		; FF 6A 11 32 ; Subtract with carry (long,X) $32116A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $65.b		; 45 65 ; Exclusive OR $65.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr $65.b,X		; 56 65 ; Logical shift right $65.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	eor $44.b,X		; 55 44 ; Exclusive OR accumulator with memory $44.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	jsl $222211.l		; 22 11 22 22 ; Jump to subroutine long $222211.l [Writes: Stack Pointer] [Flow: call]
	and ($34.b)		; 32 34 ; AND accumulator with memory (indirect) ($34.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $55.b		; 45 55 ; Exclusive OR $55.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	lsr $66.b,X		; 56 66 ; Logical shift right $66.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ror $55.b,X		; 76 55 ; Rotate right $55.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	adc $42.b		; 65 42 ; Add $42.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and ($10.b,S),Y		; 33 10 ; AND accumulator (stack relative indirect indexed) ($10.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $10, $DD		; 10 DD ; Branch if plus to $10, $DD [Flow: branch]
	ldy $ABBA.w,X		; BC BA AB ; Load Y register $ABBA.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	ldy $02CC.w		; AC CC 02 ; Load $02CC.w into Y register [Writes: Y Index] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda ($E4.b)		; B2 E4 ; Load accumulator (indirect) ($E4.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc ($20.b,X)		; E1 20 ; Subtract with carry ($20.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	pei ($B1.b)		; D4 B1 ; Push effective indirect address ($B1.b) [Reads: Direct Page] [Writes: Stack Pointer]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	rol $F2B2.w		; 2E B2 F2 ; Rotate left $F2B2.w [Flags: NCZ]
	brk $31.b		; 00 31 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $E0.b,S		; C3 E0 ; Compare accumulator (stack relative) $E0.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	jmp $413F.w		; 4C 3F 41 ; Jump to $413F.w [Flow: jump]
	lda ($1F.b)		; B2 1F ; Load accumulator (indirect) ($1F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pea $4C0D.w		; F4 0D 4C ; Push absolute address $4C0D.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	ora $1D011D.l,X		; 1F 1D 01 1D ; Logical OR long $1D011D.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda ($0E.b)		; B2 0E ; Load accumulator (indirect) ($0E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $4C6CFF.l		; 4F FF 6C 4C ; Exclusive OR accumulator with memory (long) $4C6CFF.l [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	ora ($F0.b)		; 12 F0 ; OR accumulator with memory (indirect) ($F0.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda ($00.b)		; B2 00 ; Load accumulator (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $E32F.w,X		; 1D 2F E3 ; OR accumulator with memory $E32F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rep #$00		; C2 00 ; Reset processor status bits #$00 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	cmp $D2.b,S		; C3 D2 ; Compare accumulator (stack relative) $D2.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	lda ($D5.b)		; B2 D5 ; Load accumulator (indirect) ($D5.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	eor ($F1.b,X)		; 41 F1 ; Exclusive OR accumulator with memory ($F1.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($21.b),Y		; D1 21 ; Compare accumulator ($21.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cpx $DF.b		; E4 DF ; Compare $DF.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	lda ($10.b)		; B2 10 ; Load accumulator (indirect) ($10.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc ($0B.b,S),Y		; F3 0B ; Subtract with carry (stack relative indirect indexed) ($0B.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $CF		; 10 CF ; Branch if plus to $10, $CF [Flow: branch]
	bit $1D1E.w		; 2C 1E 1D ; Test bits $1D1E.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	ldx #$1F.b		; A2 1F ; Load #$1F.b into X register [Writes: X Index] [Flags: NZ]
	sta ($C4.b,S),Y		; 93 C4 ; Store accumulator (stack relative indirect indexed) ($C4.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	eor #$21.b		; 49 21 ; Exclusive OR #$21.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc ($4C.b)		; F2 4C ; Subtract with carry (indirect) ($4C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $5D3AB2.l		; 0F B2 3A 5D ; OR accumulator with memory (long) $5D3AB2.l [Writes: Accumulator] [Flags: NZ]
	.db $10, $C1		; 10 C1 ; Branch if plus to $10, $C1 [Flow: branch]
	eor $20EB.w		; 4D EB 20 ; Exclusive OR $20EB.w with accumulator [Writes: Accumulator] [Flags: NZ]
	eor $B3B2.w		; 4D B2 B3 ; Exclusive OR $B3B2.w with accumulator [Writes: Accumulator] [Flags: NZ]
	rol $050F.w,X		; 3E 0F 05 ; Rotate left $050F.w,X [Reads: X Index] [Flags: NCZ]
	and $3020.w,X		; 3D 20 30 ; AND accumulator with memory $3020.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $B2.b		; 00 B2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EB.b		; 00 EB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($B2.b)		; 32 B2 ; AND accumulator with memory (indirect) ($B2.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp ($F1.b)		; D2 F1 ; Compare accumulator (indirect) ($F1.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sbc ($EF.b,S),Y		; F3 EF ; Subtract with carry (stack relative indirect indexed) ($EF.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	lda ($3F.b)		; B2 3F ; Load accumulator (indirect) ($3F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($0E.b)		; 12 0E ; OR accumulator with memory (indirect) ($0E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx $0B.b		; E4 0B ; Compare $0B.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	lsr $C402.w		; 4E 02 C4 ; Logical shift right $C402.w [Flags: NCZ]
	ldx #$4D.b		; A2 4D ; Load #$4D.b into X register [Writes: X Index] [Flags: NZ]
	.db $B0, $20		; B0 20 ; Branch if carry set to $B0, $20 [Flow: branch]
	ora $0E32.w,X		; 1D 32 0E ; OR accumulator with memory $0E32.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda ($03.b,S),Y		; B3 03 ; Load accumulator (stack relative indirect indexed) ($03.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
.ACCU 16
	rep #$E0		; C2 E0
	and $1EF1C3.l		; 2F C3 F1 1E ; AND accumulator with memory (long) $1EF1C3.l [Writes: Accumulator] [Flags: NZ]
	eor $B2F01E.l,X		; 5F 1E F0 B2 ; Exclusive OR accumulator with memory (long,X) $B2F01E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($E1.b,X)		; C1 E1 ; Compare accumulator ($E1.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	ora ($F3.b),Y		; 11 F3 ; OR accumulator with memory ($F3.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $105C0B.l		; 22 0B 5C 10 ; Jump to subroutine long $105C0B.l [Writes: Stack Pointer] [Flow: call]
	lda ($F1.b)		; B2 F1 ; Load accumulator (indirect) ($F1.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda ($20.b)		; B2 20 ; Load accumulator (indirect) ($20.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $2FE030.l,X		; 1F 30 E0 2F ; Logical OR long $2FE030.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $3C4CB2.l,X		; 1F B2 4C 3C ; Logical OR long $3C4CB2.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($01.b)		; D2 01 ; Compare accumulator (indirect) ($01.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora ($F2.b,X)		; 01 F2 ; Logical OR ($F2.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc ($03.b),Y		; F1 03 ; Subtract with carry ($03.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lda ($CE.b)		; B2 CE ; Load accumulator (indirect) ($CE.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $0120.w,X		; 3E 20 01 ; Rotate left $0120.w,X [Reads: X Index] [Flags: NCZ]
	dec $1E30.w,X		; DE 30 1E ; Decrement memory $1E30.w,X [Reads: X Index] [Flags: NZ]
	.db $50, $B2		; 50 B2 ; Branch if overflow clear to $50, $B2 [Flow: branch]
	lda ($5A.b)		; B2 5A ; Load accumulator (indirect) ($5A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($4A.b,X)		; 21 4A ; Logical AND ($4A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor $CF20.w,X		; 5D 20 CF ; Exclusive OR accumulator with memory $CF20.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($B2.b),Y		; 31 B2 ; AND accumulator with memory ($B2.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $4C.b		; 00 4C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $0DB3.w,X		; 3E B3 0D ; Rotate left $0DB3.w,X [Reads: X Index] [Flags: NCZ]
	ora ($F2.b,S),Y		; 13 F2 ; OR accumulator (stack relative indirect indexed) ($F2.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $4DB2.w		; 2E B2 4D ; Rotate left $4DB2.w [Flags: NCZ]
	and $C122F2.l		; 2F F2 22 C1 ; AND accumulator with memory (long) $C122F2.l [Writes: Accumulator] [Flags: NZ]
	cop $0D.b		; 02 0D ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $B2.b,X		; 16 B2 ; Arithmetic shift left $B2.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	inc $4D2D.w		; EE 2D 4D ; Increment $4D2D.w [Flags: NZ]
	ora $2F1E1F.l,X		; 1F 1F 1E 2F ; Logical OR long $2F1E1F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cop $B2.b		; 02 B2 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $D0, $3B		; D0 3B ; Branch if not equal to $D0, $3B [Flow: branch]
	ora ($2F.b),Y		; 11 2F ; OR accumulator with memory ($2F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
.ACCU 8
	sep #$20		; E2 20
	.db $10, $DD		; 10 DD ; Branch if plus to $10, $DD [Flow: branch]
	lda ($3D.b)		; B2 3D ; Load accumulator (indirect) ($3D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($CF.b,X)		; 21 CF ; Logical AND ($CF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor ($C0.b,X)		; 41 C0 ; Exclusive OR accumulator with memory ($C0.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	cop $FE.b		; 02 FE ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rep #$0F		; C2 0F ; Reset processor status bits #$0F [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
.INDEX 16
	rep #$11		; C2 11
	ora $C2E000.l,X		; 1F 00 E0 C2 ; Logical OR long $C2E000.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $01E0E1.l		; 4F E1 E0 01 ; Exclusive OR accumulator with memory (long) $01E0E1.l [Writes: Accumulator] [Flags: NZ]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda ($D1.b)		; B2 D1 ; Load accumulator (indirect) ($D1.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $002E.w,X		; 3D 2E 00 ; AND accumulator with memory $002E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $ED.b,S		; E3 ED ; Subtract stack-relative $ED.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	sbc ($C4.b,X)		; E1 C4 ; Subtract with carry ($C4.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda ($FD.b)		; B2 FD ; Load accumulator (indirect) ($FD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $2F3E.w,X		; 1E 3E 2F ; Arithmetic shift left $2F3E.w,X [Reads: X Index] [Flags: NCZ]
	cpx $1D.b		; E4 1D ; Compare $1D.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	and $B200.w,X		; 3D 00 B2 ; AND accumulator with memory $B200.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $2B12.w		; 0D 12 2B ; Logical OR $2B12.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $F000.w		; 20 00 F0 ; Jump to subroutine at $F000.w [Writes: Stack Pointer] [Flow: call]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($B2.b),Y		; 31 B2 ; AND accumulator with memory ($B2.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda $1B.b,X		; B5 1B ; Load $1B.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($D1.b),Y		; 11 D1 ; OR accumulator with memory ($D1.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
.ACCU 8
.INDEX 8
	sep #$F3		; E2 F3
	brk $4E.b		; 00 4E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda ($E1.b)		; B2 E1 ; Load accumulator (indirect) ($E1.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp ($0E.b,X)		; C1 0E ; Compare accumulator ($0E.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	sbc $02D632.l		; EF 32 D6 02 ; Subtract with carry (long) $02D632.l [Writes: Accumulator] [Flags: NCVZ]
	inc $02C2.w		; EE C2 02 ; Increment $02C2.w [Flags: NZ]
	sbc ($EE.b),Y		; F1 EE ; Subtract with carry ($EE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $2F1F.w,X		; 3E 1F 2F ; Rotate left $2F1F.w,X [Reads: X Index] [Flags: NCZ]
	rol $C2F1.w		; 2E F1 C2 ; Rotate left $C2F1.w [Flags: NCZ]
	jsr $E001.w		; 20 01 E0 ; Jump to subroutine at $E001.w [Writes: Stack Pointer] [Flow: call]
	ora $1E0000.l		; 0F 00 00 1E ; OR accumulator with memory (long) $1E0000.l [Writes: Accumulator] [Flags: NZ]
	pei ($B2.b)		; D4 B2 ; Push effective indirect address ($B2.b) [Reads: Direct Page] [Writes: Stack Pointer]
	inc $D243.w		; EE 43 D2 ; Increment $D243.w [Flags: NZ]
	and $01A213.l		; 2F 13 A2 01 ; AND accumulator with memory (long) $01A213.l [Writes: Accumulator] [Flags: NZ]
	jsr ($30B2.w,X)		; FC B2 30 ; Jump to subroutine indirect indexed ($30B2.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $F0, $3C		; F0 3C ; Branch if equal to $F0, $3C [Flow: branch]
	lsr $E0F2.w		; 4E F2 E0 ; Logical shift right $E0F2.w [Flags: NCZ]
	eor $B220.w		; 4D 20 B2 ; Exclusive OR $B220.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $010F03.l		; EF 03 0F 01 ; Subtract with carry (long) $010F03.l [Writes: Accumulator] [Flags: NCVZ]
	sbc ($FA.b)		; F2 FA ; Subtract with carry (indirect) ($FA.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
.ACCU 16
	rep #$2E		; C2 2E
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	rol $F11F.w		; 2E 1F F1 ; Rotate left $F11F.w [Flags: NCZ]
	ora $C2F4.w,X		; 1D F4 C2 ; OR accumulator with memory $C2F4.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($F0.b)		; D2 F0 ; Compare accumulator (indirect) ($F0.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cpx #$EF.b		; E0 EF ; Compare #$EF.b with X register [Reads: X Index] [Flags: NCZ]
	and $E0FEC2.l		; 2F C2 FE E0 ; AND accumulator with memory (long) $E0FEC2.l [Writes: Accumulator] [Flags: NZ]
	rep #$0E		; C2 0E ; Reset processor status bits #$0E [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	.db $10, $4C		; 10 4C ; Branch if plus to $10, $4C [Flow: branch]
	sbc ($FF.b),Y		; F1 FF ; Subtract with carry ($FF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $0F00.w,X		; 1E 00 0F ; Arithmetic shift left $0F00.w,X [Reads: X Index] [Flags: NCZ]
	lda ($B5.b)		; B2 B5 ; Load accumulator (indirect) ($B5.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $0F10.w		; 0E 10 0F ; Arithmetic shift left $0F10.w [Flags: NCZ]
	pei ($D1.b)		; D4 D1 ; Push effective indirect address ($D1.b) [Reads: Direct Page] [Writes: Stack Pointer]
	trb $0A.b		; 14 0A ; Test and reset bits $0A.b [Reads: Accumulator] [Flags: Z]
.INDEX 16
	rep #$11		; C2 11
	cmp ($0D.b)		; D2 0D ; Compare accumulator (indirect) ($0D.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora $E4201E.l,X		; 1F 1E 20 E4 ; Logical OR long $E4201E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$10D2.w		; E0 D2 10 ; Compare #$10D2.w with X register [Reads: X Index] [Flags: NCZ]
	ora ($01.b),Y		; 11 01 ; OR accumulator with memory ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpx $D1.b		; E4 D1 ; Compare $D1.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	.db $F0, $C2		; F0 C2 ; Branch if equal to $F0, $C2 [Flow: branch]
	cpx #$2FF2.w		; E0 F2 2F ; Compare #$2FF2.w with X register [Reads: X Index] [Flags: NCZ]
	ora ($F0.b),Y		; 11 F0 ; OR accumulator with memory ($F0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	asl $F2C2.w		; 0E C2 F2 ; Arithmetic shift left $F2C2.w [Flags: NCZ]
	lda ($01.b),Y		; B1 01 ; Load accumulator ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $F0F3F1.l		; EF F1 F3 F0 ; Subtract with carry (long) $F0F3F1.l [Writes: Accumulator] [Flags: NCVZ]
	brk $C2.b		; 00 C2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $FE.b,S		; 23 FE ; AND accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $2E2E1C.l,X		; FF 1C 2E 2E ; Subtract with carry (long,X) $2E2E1C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($E0.b,S),Y		; F3 E0 ; Subtract with carry (stack relative indirect indexed) ($E0.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
.INDEX 16
	rep #$10		; C2 10
	asl $E13F.w		; 0E 3F E1 ; Arithmetic shift left $E13F.w [Flags: NCZ]
	and $21EEF2.l		; 2F F2 EE 21 ; AND accumulator with memory (long) $21EEF2.l [Writes: Accumulator] [Flags: NZ]
	lda ($DE.b)		; B2 DE ; Load accumulator (indirect) ($DE.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $1F20.w,X		; 5D 20 1F ; Exclusive OR accumulator with memory $1F20.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($E2.b),Y		; 11 E2 ; OR accumulator with memory ($E2.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($D1.b),Y		; F1 D1 ; Subtract with carry ($D1.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lda ($FF.b)		; B2 FF ; Load accumulator (indirect) ($FF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $E2210C.l		; 4F 0C 21 E2 ; Exclusive OR accumulator with memory (long) $E2210C.l [Writes: Accumulator] [Flags: NZ]
	eor $B20FF2.l		; 4F F2 0F B2 ; Exclusive OR accumulator with memory (long) $B20FF2.l [Writes: Accumulator] [Flags: NZ]
	rol $2F0F.w,X		; 3E 0F 2F ; Rotate left $2F0F.w,X [Reads: X Index] [Flags: NCZ]
.ACCU 8
	sep #$E2		; E2 E2
	sbc $B20A03.l		; EF 03 0A B2 ; Subtract with carry (long) $B20A03.l [Writes: Accumulator] [Flags: NCVZ]
	ora ($4E.b,X)		; 01 4E ; Logical OR ($4E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($2E.b,X)		; 01 2E ; Logical OR ($2E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $232A11.l,X		; 1F 11 2A 23 ; Logical OR long $232A11.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda ($EF.b)		; B2 EF ; Load accumulator (indirect) ($EF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $F0		; 10 F0 ; Branch if plus to $10, $F0 [Flow: branch]
	eor $201F.w		; 4D 1F 20 ; Exclusive OR $201F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $EEB2D5.l		; 0F D5 B2 EE ; OR accumulator with memory (long) $EEB2D5.l [Writes: Accumulator] [Flags: NZ]
	asl $2F2E.w,X		; 1E 2E 2F ; Arithmetic shift left $2F2E.w,X [Reads: X Index] [Flags: NCZ]
	and $6CFF3E.l		; 2F 3E FF 6C ; AND accumulator with memory (long) $6CFF3E.l [Writes: Accumulator] [Flags: NZ]
	ldx #$3CE1.w		; A2 E1 3C ; Load #$3CE1.w into X register [Writes: X Index] [Flags: NZ]
	ora $B1.b		; 05 B1 ; Logical OR $B1.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $FE1DE3.l,X		; 1F E3 1D FE ; Logical OR long $FE1DE3.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda ($1F.b)		; B2 1F ; Load accumulator (indirect) ($1F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $E2		; 10 E2 ; Branch if plus to $10, $E2 [Flow: branch]
	inc $2F4E.w,X		; FE 4E 2F ; Increment memory $2F4E.w,X [Reads: X Index] [Flags: NZ]
	.db $10, $1F		; 10 1F ; Branch if plus to $10, $1F [Flow: branch]
.INDEX 16
	rep #$1E		; C2 1E
	.db $F0, $4E		; F0 4E ; Branch if equal to $F0, $4E [Flow: branch]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($F1.b,X)		; E1 F1 ; Subtract with carry ($F1.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $C2.b		; 00 C2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $F2.b		; 02 F2 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $1F		; F0 1F ; Branch if equal to $F0, $1F [Flow: branch]
	cop $F0.b		; 02 F0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $B2D5.w		; 2E D5 B2 ; Rotate left $B2D5.w [Flags: NCZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	adc $5C2D.w,X		; 7D 2D 5C ; Add $5C2D.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $B1.b,X		; F5 B1 ; Subtract $B1.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $B2.b		; 00 B2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $EF.b		; 04 EF ; Test and set bits $EF.b [Reads: Accumulator] [Flags: Z]
	ora $0DE1.w,X		; 1D E1 0D ; OR accumulator with memory $0DE1.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
.ACCU 8
	sep #$E1		; E2 E1
	cpx #$EEB2.w		; E0 B2 EE ; Compare #$EEB2.w with X register [Reads: X Index] [Flags: NCZ]
	and $223E.w		; 2D 3E 22 ; Logical AND $223E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $114E.w,X		; 1D 4E 11 ; OR accumulator with memory $114E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($B2.b,S),Y		; F3 B2 ; Subtract with carry (stack relative indirect indexed) ($B2.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	inc $A4.b		; E6 A4 ; Increment $A4.b [Reads: Direct Page] [Flags: NZ]
	trb $E031.w		; 1C 31 E0 ; Test and reset bits $E031.w [Reads: Accumulator] [Flags: Z]
	and $01.b,S		; 23 01 ; AND accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $B2.b,S		; E3 B2 ; Subtract stack-relative $B2.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	sbc $2DDFEE.l		; EF EE DF 2D ; Subtract with carry (long) $2DDFEE.l [Writes: Accumulator] [Flags: NCVZ]
	jsr ($104D.w,X)		; FC 4D 10 ; Jump to subroutine indirect indexed ($104D.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $B0, $C2		; B0 C2 ; Branch if carry set to $B0, $C2 [Flow: branch]
	and $1F10.w		; 2D 10 1F ; Logical AND $1F10.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc ($01.b),Y		; F1 01 ; Subtract with carry ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $306C.w,X		; FE 6C 30 ; Increment memory $306C.w,X [Reads: X Index] [Flags: NZ]
.INDEX 16
	rep #$11		; C2 11
	cmp $0F000D.l,X		; DF 0D 00 0F ; Compare accumulator (long,X) $0F000D.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	bit $0F04.w,X		; 3C 04 0F ; Test bits $0F04.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	lda ($5F.b)		; B2 5F ; Load accumulator (indirect) ($5F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $D531.w		; 2E 31 D5 ; Rotate left $D531.w [Flags: NCZ]
	pei ($2E.b)		; D4 2E ; Push effective indirect address ($2E.b) [Reads: Direct Page] [Writes: Stack Pointer]
	trb $B25F.w		; 1C 5F B2 ; Test and reset bits $B25F.w [Reads: Accumulator] [Flags: Z]
	sep #$0F		; E2 0F ; Set processor status bits #$0F [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	sbc $3E4C.w,X		; FD 4C 3E ; Subtract with carry $3E4C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $CDA22F.l,X		; 3F 2F A2 CD ; AND accumulator with memory (long,X) $CDA22F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $C1.b,S		; 23 C1 ; AND accumulator with stack relative $C1.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0542.w,X		; 1D 42 05 ; OR accumulator with memory $0542.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda [$0F.b],Y		; B7 0F ; Load accumulator (long indexed) [$0F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	brk $2E.b		; 00 2E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $EE.b		; 02 EE ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($2C.b),Y		; F1 2C ; Subtract with carry ($2C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $6CB2.w,X		; 3E B2 6C ; Rotate left $6CB2.w,X [Reads: X Index] [Flags: NCZ]
	ora ($01.b),Y		; 11 01 ; OR accumulator with memory ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$033C.w		; E0 3C 03 ; Compare #$033C.w with X register [Reads: X Index] [Flags: NCZ]
	inc $B202.w,X		; FE 02 B2 ; Increment memory $B202.w,X [Reads: X Index] [Flags: NZ]
	lda $FE.b,X		; B5 FE ; Load $FE.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ror $1DE1.w		; 6E E1 1D ; Rotate right $1DE1.w [Flags: NCZ]
	ora $B4.b,S		; 03 B4 ; OR accumulator with stack relative $B4.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda ($1C.b)		; B2 1C ; Load accumulator (indirect) ($1C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $FD01.w,X		; 3E 01 FD ; Rotate left $FD01.w,X [Reads: X Index] [Flags: NCZ]
	lsr $3FFC.w		; 4E FC 3F ; Logical shift right $3FFC.w [Flags: NCZ]
	inc $B2.b		; E6 B2 ; Increment $B2.b [Reads: Direct Page] [Flags: NZ]
	inc $0000.w		; EE 00 00 ; Increment $0000.w [Flags: NZ]
.INDEX 16
	rep #$11		; C2 11
	sbc $B22D31.l,X		; FF 31 2D B2 ; Subtract with carry (long,X) $B22D31.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $E0.b,S		; 23 E0 ; AND accumulator with stack relative $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol M7C.w		; 2E 1D 21 ; Rotate left M7C.w [Flags: NCZ]
	jsr $3A0E.w		; 20 0E 3A ; Jump to subroutine at $3A0E.w [Writes: Stack Pointer] [Flow: call]
	lda ($13.b)		; B2 13 ; Load accumulator (indirect) ($13.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	wai		; CB ; Wait for interrupt
	.db $30, $D2		; 30 D2 ; Branch if minus to $30, $D2 [Flow: branch]
	sbc $2EF102.l,X		; FF 02 F1 2E ; Subtract with carry (long,X) $2EF102.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda ($1B.b)		; B2 1B ; Load accumulator (indirect) ($1B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $06F0.w,X		; 5D F0 06 ; Exclusive OR accumulator with memory $06F0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $02FF4D.l		; EF 4D FF 02 ; Subtract with carry (long) $02FF4D.l [Writes: Accumulator] [Flags: NCVZ]
	ldx #$5DBA.w		; A2 BA 5D ; Load #$5DBA.w into X register [Writes: X Index] [Flags: NZ]
	sbc $3BA195.l,X		; FF 95 A1 3B ; Subtract with carry (long,X) $3BA195.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr $B2F2.w,X		; 5E F2 B2 ; Logical shift right $B2F2.w,X [Reads: X Index] [Flags: NCZ]
.ACCU 8
.INDEX 8
	sep #$3E		; E2 3E
	ora $14.b,S		; 03 14 ; OR accumulator with stack relative $14.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	eor $FD.b,S		; 43 FD ; Exclusive OR accumulator with stack relative $FD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($C2.b,X)		; 01 C2 ; Logical OR ($C2.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $B1.b,X		; F5 B1 ; Subtract $B1.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $2DFEF0.l		; 4F F0 FE 2D ; Exclusive OR accumulator with memory (long) $2DFEF0.l [Writes: Accumulator] [Flags: NZ]
	.db $F0, $EF		; F0 EF ; Branch if equal to $F0, $EF [Flow: branch]
	ldx #$40.b		; A2 40 ; Load #$40.b into X register [Writes: X Index] [Flags: NZ]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
.ACCU 16
.INDEX 16
	rep #$7D		; C2 7D
	ror $F0E3.w,X		; 7E E3 F0 ; Rotate right $F0E3.w,X [Reads: X Index] [Flags: NCZ]
	lda ($1F.b)		; B2 1F ; Load accumulator (indirect) ($1F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $06.b,X		; F5 06 ; Subtract $06.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy #$C171.w		; A0 71 C1 ; Load #$C171.w into Y register [Writes: Y Index] [Flags: NZ]
	cmp ($E6.b,S),Y		; D3 E6 ; Compare accumulator (stack relative indirect indexed) ($E6.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
.ACCU 16
	rep #$A2		; C2 A2
	eor $0EF1.w		; 4D F1 0E ; Exclusive OR $0EF1.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jmp $E112.w		; 4C 12 E1 ; Jump to $E112.w [Flow: jump]
	ora $4ED3B2.l		; 0F B2 D3 4E ; OR accumulator with memory (long) $4ED3B2.l [Writes: Accumulator] [Flags: NZ]
	lsr $2F31.w,X		; 5E 31 2F ; Logical shift right $2F31.w,X [Reads: X Index] [Flags: NCZ]
	sbc ($2F.b),Y		; F1 2F ; Subtract with carry ($2F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $B2		; 10 B2 ; Branch if plus to $10, $B2 [Flow: branch]
	cop $F0.b		; 02 F0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($1D.b,X)		; 01 1D ; Logical OR ($1D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	pei ($E0.b)		; D4 E0 ; Push effective indirect address ($E0.b) [Reads: Direct Page] [Writes: Stack Pointer]
	and $B25A.w		; 2D 5A B2 ; Logical AND $B25A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $10, $24		; 10 24 ; Branch if plus to $10, $24 [Flow: branch]
	sbc $0242.w		; ED 42 02 ; Subtract $0242.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	bit $9307.w		; 2C 07 93 ; Test bits $9307.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	ldx #$72F9.w		; A2 F9 72 ; Load #$72F9.w into X register [Writes: X Index] [Flags: NZ]
	lda $5C.b,X		; B5 5C ; Load $5C.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	pea $D0B3.w		; F4 B3 D0 ; Push absolute address $D0B3.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sbc [$C2.b],Y		; F7 C2 ; Subtract with carry (long indexed) [$C2.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $FFD0F1.l		; 0F F1 D0 FF ; OR accumulator with memory (long) $FFD0F1.l [Writes: Accumulator] [Flags: NZ]
	ora ($2B.b,X)		; 01 2B ; Logical OR ($2B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	lda ($1F.b)		; B2 1F ; Load accumulator (indirect) ($1F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $1E1E.w		; 20 1E 1E ; Jump to subroutine at $1E1E.w [Writes: Stack Pointer] [Flow: call]
	lsr $2DE2.w,X		; 5E E2 2D ; Logical shift right $2DE2.w,X [Reads: X Index] [Flags: NCZ]
	eor $100FC2.l		; 4F C2 0F 10 ; Exclusive OR accumulator with memory (long) $100FC2.l [Writes: Accumulator] [Flags: NZ]
	.db $F0, $1D		; F0 1D ; Branch if equal to $F0, $1D [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $00C2.w		; EE C2 00 ; Increment $00C2.w [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $1D.b,S		; 03 1D ; OR accumulator with stack relative $1D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($FE.b,S),Y		; 13 FE ; OR accumulator (stack relative indirect indexed) ($FE.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($F0.b)		; 12 F0 ; OR accumulator with memory (indirect) ($F0.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rep #$0F		; C2 0F ; Reset processor status bits #$0F [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	bit $0001.w,X		; 3C 01 00 ; Test bits $0001.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $3E		; F0 3E ; Branch if equal to $F0, $3E [Flow: branch]
	lda ($3C.b)		; B2 3C ; Load accumulator (indirect) ($3C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr $4EDE.w,X		; 5E DE 4E ; Logical shift right $4EDE.w,X [Reads: X Index] [Flags: NCZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $62, $EE, $13		; 62 EE 13 ; Push effective relative address $62, $EE, $13 [Writes: Stack Pointer]
	rep #$C2		; C2 C2 ; Reset processor status bits #$C2 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	and ($E0.b,X)		; 21 E0 ; Logical AND ($E0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $EF132C.l		; 2F 2C 13 EF ; AND accumulator with memory (long) $EF132C.l [Writes: Accumulator] [Flags: NZ]
	brk $B2.b		; 00 B2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $2BFFD4.l		; 2F D4 FF 2B ; AND accumulator with memory (long) $2BFFD4.l [Writes: Accumulator] [Flags: NZ]
	jmp $132D12.l		; 5C 12 2D 13 ; Jump long to $132D12.l [Flow: jump]
.ACCU 16
.INDEX 16
	rep #$F1		; C2 F1
	.db $10, $01		; 10 01 ; Branch if plus to $10, $01 [Flow: branch]
	sbc ($00.b),Y		; F1 00 ; Subtract with carry ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($0D.b,X)		; 01 0D ; Logical OR ($0D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $C2.b		; 04 C2 ; Test and set bits $C2.b [Reads: Accumulator] [Flags: Z]
	cmp ($1E.b,X)		; C1 1E ; Compare accumulator ($1E.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	and $024E.w		; 2D 4E 02 ; Logical AND $024E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $EFE3.w		; 0E E3 EF ; Arithmetic shift left $EFE3.w [Flags: NCZ]
	lda ($40.b)		; B2 40 ; Load accumulator (indirect) ($40.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy $B3.b		; A4 B3 ; Load $B3.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	cmp $10B2E4.l,X		; DF E4 B2 10 ; Compare accumulator (long,X) $10B2E4.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lda ($23.b)		; B2 23 ; Load accumulator (indirect) ($23.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpy #$D213.w		; C0 13 D2 ; Compare #$D213.w with Y register [Reads: Y Index] [Flags: NCZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	cmp $2E.b,S		; C3 2E ; Compare accumulator (stack relative) $2E.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	eor ($B2.b),Y		; 51 B2 ; Exclusive OR accumulator with memory ($B2.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta ($2F.b,S),Y		; 93 2F ; Store accumulator (stack relative indirect indexed) ($2F.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	sbc $E00340.l,X		; FF 40 03 E0 ; Subtract with carry (long,X) $E00340.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	pea $B2F2.w		; F4 F2 B2 ; Push absolute address $B2F2.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	cmp $FF.b,S		; C3 FF ; Compare accumulator (stack relative) $FF.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	and $D5024A.l,X		; 3F 4A 02 D5 ; AND accumulator with memory (long,X) $D5024A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda $5CB2.w		; AD B2 5C ; Load $5CB2.w into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $F5F004.l		; 22 04 F0 F5 ; Jump to subroutine long $F5F004.l [Writes: Stack Pointer] [Flow: call]
	sbc $D233.w		; ED 33 D2 ; Subtract $D233.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
.ACCU 16
.INDEX 16
	rep #$F0		; C2 F0
	ora $DE.b,S		; 03 DE ; OR accumulator with stack relative $DE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($1F.b,X)		; 21 1F ; Logical AND ($1F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $F0.b,X		; F5 F0 ; Subtract $F0.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($B2.b,X)		; 21 B2 ; Logical AND ($B2.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $D0, $13		; D0 13 ; Branch if not equal to $D0, $13 [Flow: branch]
	.db $D0, $11		; D0 11 ; Branch if not equal to $D0, $11 [Flow: branch]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and ($EF.b),Y		; 31 EF ; AND accumulator with memory ($EF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $F4C2.w,X		; 1E C2 F4 ; Arithmetic shift left $F4C2.w,X [Reads: X Index] [Flags: NCZ]
	dec $3011.w,X		; DE 11 30 ; Decrement memory $3011.w,X [Reads: X Index] [Flags: NZ]
	cmp $F0.b		; C5 F0 ; Compare $F0.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
.INDEX 8
	sep #$D1		; E2 D1
	rep #$04		; C2 04 ; Reset processor status bits #$04 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	dec $1F0F.w,X		; DE 0F 1F ; Decrement memory $1F0F.w,X [Reads: X Index] [Flags: NZ]
	bit $3E3D.w,X		; 3C 3D 3E ; Test bits $3E3D.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	jsr $C5B2.w		; 20 B2 C5 ; Jump to subroutine at $C5B2.w [Writes: Stack Pointer] [Flow: call]
	and $5E2CE2.l		; 2F E2 2C 5E ; AND accumulator with memory (long) $5E2CE2.l [Writes: Accumulator] [Flags: NZ]
	sbc $C3.b,S		; E3 C3 ; Subtract stack-relative $C3.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	dec $11C2.w,X		; DE C2 11 ; Decrement memory $11C2.w,X [Reads: X Index] [Flags: NZ]
	sbc $1DD402.l,X		; FF 02 D4 1D ; Subtract with carry (long,X) $1DD402.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $1E		; 10 1E ; Branch if plus to $10, $1E [Flow: branch]
	and $4BE4B2.l		; 2F B2 E4 4B ; AND accumulator with memory (long) $4BE4B2.l [Writes: Accumulator] [Flags: NZ]
	sbc ($0F.b,X)		; E1 0F ; Subtract with carry ($0F.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $C121.w		; 2D 21 C1 ; Logical AND $C121.w with accumulator [Writes: Accumulator] [Flags: NZ]
	inc $1FB2.w		; EE B2 1F ; Increment $1FB2.w [Flags: NZ]
	and $1BA700.l		; 2F 00 A7 1B ; AND accumulator with memory (long) $1BA700.l [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $50, $C2		; 50 C2 ; Branch if overflow clear to $50, $C2 [Flow: branch]
.ACCU 8
	sep #$2C		; E2 2C
	.db $10, $E1		; 10 E1 ; Branch if plus to $10, $E1 [Flow: branch]
	sbc $F14F2D.l,X		; FF 2D 4F F1 ; Subtract with carry (long,X) $F14F2D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rep #$0F		; C2 0F ; Reset processor status bits #$0F [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	asl $F02F.w,X		; 1E 2F F0 ; Arithmetic shift left $F02F.w,X [Reads: X Index] [Flags: NCZ]
	.db $10, $D2		; 10 D2 ; Branch if plus to $10, $D2 [Flow: branch]
	rol $B201.w		; 2E 01 B2 ; Rotate left $B201.w [Flags: NCZ]
	sta ($0D.b,S),Y		; 93 0D ; Store accumulator (stack relative indirect indexed) ($0D.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	jsr $F30F.w		; 20 0F F3 ; Jump to subroutine at $F30F.w [Writes: Stack Pointer] [Flow: call]
	ora $3FB200.l		; 0F 00 B2 3F ; OR accumulator with memory (long) $3FB200.l [Writes: Accumulator] [Flags: NZ]
	sbc $C4.b,S		; E3 C4 ; Subtract stack-relative $C4.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	tsb $E200.w		; 0C 00 E2 ; Test and set bits $E200.w [Reads: Accumulator] [Flags: Z]
	cmp ($ED.b,S),Y		; D3 ED ; Compare accumulator (stack relative indirect indexed) ($ED.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
.INDEX 16
	rep #$12		; C2 12
	bit $E002.w,X		; 3C 02 E0 ; Test bits $E002.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	and $F3F0.w,X		; 3D F0 F3 ; AND accumulator with memory $F3F0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($A2.b),Y		; D1 A2 ; Compare accumulator ($A2.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	lsr $353B.w		; 4E 3B 35 ; Logical shift right $353B.w [Flags: NCZ]
	.db $D0, $F5		; D0 F5 ; Branch if not equal to $D0, $F5 [Flow: branch]
	cpy #$2500.w		; C0 00 25 ; Compare #$2500.w with Y register [Reads: Y Index] [Flags: NCZ]
	lda ($F0.b)		; B2 F0 ; Load accumulator (indirect) ($F0.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $F0.b		; 04 F0 ; Test and set bits $F0.b [Reads: Accumulator] [Flags: Z]
	ora $94.b,X		; 15 94 ; OR accumulator with memory $94.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	ora $D2.b,S		; 03 D2 ; OR accumulator with stack relative $D2.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda ($F3.b)		; B2 F3 ; Load accumulator (indirect) ($F3.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
.ACCU 16
	rep #$E0		; C2 E0
	ora $EF.b,S		; 03 EF ; OR accumulator with stack relative $EF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $B2A1F5.l		; 2F F5 A1 B2 ; AND accumulator with memory (long) $B2A1F5.l [Writes: Accumulator] [Flags: NZ]
	cop $DF.b		; 02 DF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	asl $B0.b,X		; 16 B0 ; Arithmetic shift left $B0.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $FE.b,S		; 03 FE ; OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lsr $FFB2.w		; 4E B2 FF ; Logical shift right $FFB2.w [Flags: NCZ]
	sbc ($D0.b)		; F2 D0 ; Subtract with carry (indirect) ($D0.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $2C.b,X		; F5 2C ; Subtract $2C.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $F4		; 30 F4 ; Branch if minus to $30, $F4 [Flow: branch]
	lda ($C2.b)		; B2 C2 ; Load accumulator (indirect) ($C2.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($F0.b,X)		; 01 F0 ; Logical OR ($F0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $DF12.w,X		; 3D 12 DF ; AND accumulator with memory $DF12.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $C24FFD.l		; 22 FD 4F C2 ; Jump to subroutine long $C24FFD.l [Writes: Stack Pointer] [Flow: call]
	.db $10, $12		; 10 12 ; Branch if plus to $10, $12 [Flow: branch]
	.db $F0, $F2		; F0 F2 ; Branch if equal to $F0, $F2 [Flow: branch]
	tsb $E120.w		; 0C 20 E1 ; Test and set bits $E120.w [Reads: Accumulator] [Flags: Z]
	sbc ($B2.b),Y		; F1 B2 ; Subtract with carry ($B2.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $1DB132.l,X		; FF 32 B1 1D ; Subtract with carry (long,X) $1DB132.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($C4.b),Y		; 51 C4 ; Exclusive OR accumulator with memory ($C4.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($FD.b),Y		; 11 FD ; OR accumulator with memory ($FD.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda ($43.b)		; B2 43 ; Load accumulator (indirect) ($43.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	jmp ($1EDE.w,X)		; 7C DE 1E ; Jump indirect indexed to ($1EDE.w,X) [Reads: X Index] [Flow: jump]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	jsr $B21D.w		; 20 1D B2 ; Jump to subroutine at $B21D.w [Writes: Stack Pointer] [Flow: call]
	and $132E.w,X		; 3D 2E 13 ; AND accumulator with memory $132E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $F15E.w,X		; DD 5E F1 ; Compare accumulator $F15E.w,X [Reads: X Index] [Flags: NCZ]
	sbc $01.b,S		; E3 01 ; Subtract stack-relative $01.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	lda ($D1.b)		; B2 D1 ; Load accumulator (indirect) ($D1.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($D1.b),Y		; 11 D1 ; OR accumulator with memory ($D1.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jmp $1DC2.w		; 4C C2 1D ; Jump to $1DC2.w [Flow: jump]
	.db $F0, $5F		; F0 5F ; Branch if equal to $F0, $5F [Flow: branch]
.ACCU 16
.INDEX 16
	rep #$F0		; C2 F0
	and $0E110D.l		; 2F 0D 11 0E ; AND accumulator with memory (long) $0E110D.l [Writes: Accumulator] [Flags: NZ]
	eor $B2FFF4.l		; 4F F4 FF B2 ; Exclusive OR accumulator with memory (long) $B2FFF4.l [Writes: Accumulator] [Flags: NZ]
	rol $00C4.w,X		; 3E C4 00 ; Rotate left $00C4.w,X [Reads: X Index] [Flags: NCZ]
	sta ($4B.b)		; 92 4B ; Store accumulator (indirect) ($4B.b) [Reads: Direct Page, Accumulator]
	ora $5B.b,S		; 03 5B ; OR accumulator with stack relative $5B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $2FD1B2.l		; EF B2 D1 2F ; Subtract with carry (long) $2FD1B2.l [Writes: Accumulator] [Flags: NCVZ]
	cop $F0.b		; 02 F0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $BE63FB.l		; 2F FB 63 BE ; AND accumulator with memory (long) $BE63FB.l [Writes: Accumulator] [Flags: NZ]
	lda ($5E.b)		; B2 5E ; Load accumulator (indirect) ($5E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $E44C.w		; 2E 4C E4 ; Rotate left $E44C.w [Flags: NCZ]
	ora $2F1FE3.l,X		; 1F E3 1F 2F ; Logical OR long $2F1FE3.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda ($F1.b)		; B2 F1 ; Load accumulator (indirect) ($F1.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $E310E1.l,X		; 3F E1 10 E3 ; AND accumulator with memory (long,X) $E310E1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $02		; F0 02 ; Branch if equal to $F0, $02 [Flow: branch]
	cpy $B2.b		; C4 B2 ; Compare $B2.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	asl $E001.w		; 0E 01 E0 ; Arithmetic shift left $E001.w [Flags: NCZ]
	cpx #$2E6D.w		; E0 6D 2E ; Compare #$2E6D.w with X register [Reads: X Index] [Flags: NCZ]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda ($41.b)		; B2 41 ; Load accumulator (indirect) ($41.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp ($0D.b,S),Y		; D3 0D ; Compare accumulator (stack relative indirect indexed) ($0D.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sbc ($4D.b),Y		; F1 4D ; Subtract with carry ($4D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $2E		; 10 2E ; Branch if plus to $10, $2E [Flow: branch]
	lda ($13.b)		; B2 13 ; Load accumulator (indirect) ($13.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $92.b		; 00 92 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($1EE1.w)		; 6C E1 1E ; Jump indirect to ($1EE1.w) [Flow: jump]
	lda ($1E.b)		; B2 1E ; Load accumulator (indirect) ($1E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $EB04.w		; 0E 04 EB ; Arithmetic shift left $EB04.w [Flags: NCZ]
	.db $42, $0F		; 42 0F ; Reserved instruction
	pei ($E1.b)		; D4 E1 ; Push effective indirect address ($E1.b) [Reads: Direct Page] [Writes: Stack Pointer]
	lda ($1E.b)		; B2 1E ; Load accumulator (indirect) ($1E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $E2310F.l		; 22 0F 31 E2 ; Jump to subroutine long $E2310F.l [Writes: Stack Pointer] [Flow: call]
	pea $2BD0.w		; F4 D0 2B ; Push absolute address $2BD0.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
.ACCU 16
	rep #$21		; C2 21
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $0F10.w		; 4D 10 0F ; Exclusive OR $0F10.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $20		; F0 20 ; Branch if equal to $F0, $20 [Flow: branch]
	lda ($C6.b)		; B2 C6 ; Load accumulator (indirect) ($C6.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $222F.w		; 1C 2F 22 ; Test and reset bits $222F.w [Reads: Accumulator] [Flags: Z]
	lda ($F0.b,S),Y		; B3 F0 ; Load accumulator (stack relative indirect indexed) ($F0.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($30.b,X)		; 01 30 ; Logical OR ($30.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
.INDEX 16
	rep #$10		; C2 10
	ora ($E3.b,X)		; 01 E3 ; Logical OR ($E3.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsr $003E.w		; 20 3E 00 ; Jump to subroutine at $003E.w [Writes: Stack Pointer] [Flow: call]
	eor $C210.w		; 4D 10 C2 ; Exclusive OR $C210.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $F10FC1.l		; 22 C1 0F F1 ; Jump to subroutine long $F10FC1.l [Writes: Stack Pointer] [Flow: call]
	ora $DF2E0F.l		; 0F 0F 2E DF ; OR accumulator with memory (long) $DF2E0F.l [Writes: Accumulator] [Flags: NZ]
.ACCU 16
	rep #$2B		; C2 2B
	cmp ($FD.b),Y		; D1 FD ; Compare accumulator ($FD.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	jsl $E1100F.l		; 22 0F 10 E1 ; Jump to subroutine long $E1100F.l [Writes: Stack Pointer] [Flow: call]
	asl $23B2.w,X		; 1E B2 23 ; Arithmetic shift left $23B2.w,X [Reads: X Index] [Flags: NCZ]
	cpy #$D14F.w		; C0 4F D1 ; Compare #$D14F.w with Y register [Reads: Y Index] [Flags: NCZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	pei ($EE.b)		; D4 EE ; Push effective indirect address ($EE.b) [Reads: Direct Page] [Writes: Stack Pointer]
	rol $EFB2.w,X		; 3E B2 EF ; Rotate left $EFB2.w,X [Reads: X Index] [Flags: NCZ]
	cop $C1.b		; 02 C1 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $CF52.w		; 0D 52 CF ; Logical OR $CF52.w with accumulator [Writes: Accumulator] [Flags: NZ]
	rol $B2FF.w,X		; 3E FF B2 ; Rotate left $B2FF.w,X [Reads: X Index] [Flags: NCZ]
	bit $C112.w,X		; 3C 12 C1 ; Test bits $C112.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	asl $D6E2.w		; 0E E2 D6 ; Arithmetic shift left $D6E2.w [Flags: NCZ]
	lda ($FF.b)		; B2 FF ; Load accumulator (indirect) ($FF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rep #$03		; C2 03 ; Reset processor status bits #$03 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	sbc ($0E.b,X)		; E1 0E ; Subtract with carry ($0E.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $C0.b		; 24 C0 ; Test bits $C0.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	jsr $F41F.w		; 20 1F F4 ; Jump to subroutine at $F41F.w [Writes: Stack Pointer] [Flow: call]
	lda ($9F.b)		; B2 9F ; Load accumulator (indirect) ($9F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $F1EE01.l,X		; 1F 01 EE F1 ; Logical OR long $F1EE01.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $1E2F.w		; EE 2F 1E ; Increment $1E2F.w [Flags: NZ]
	rep #$01		; C2 01 ; Reset processor status bits #$01 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	ora $DF0100.l		; 0F 00 01 DF ; OR accumulator with memory (long) $DF0100.l [Writes: Accumulator] [Flags: NZ]
	ora $B2323B.l,X		; 1F 3B 32 B2 ; Logical OR long $B2323B.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $EF.b,X		; F6 EF ; Increment memory $EF.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	adc #$3F0F.w		; 69 0F 3F ; Add #$3F0F.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	inc $2BE1.w,X		; FE E1 2B ; Increment memory $2BE1.w,X [Reads: X Index] [Flags: NZ]
	lda ($22.b)		; B2 22 ; Load accumulator (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx #$4D10.w		; E0 10 4D ; Compare #$4D10.w with X register [Reads: X Index] [Flags: NCZ]
	ora $F1.b,S		; 03 F1 ; OR accumulator with stack relative $F1.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($0E.b)		; 12 0E ; OR accumulator with memory (indirect) ($0E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
.INDEX 16
	rep #$12		; C2 12
	ora $D212.w		; 0D 12 D2 ; Logical OR $D212.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $C36C.w,X		; 1E 6C C3 ; Arithmetic shift left $C36C.w,X [Reads: X Index] [Flags: NCZ]
	ora $7BB2.w,X		; 1D B2 7B ; OR accumulator with memory $7BB2.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $503A1D.l,X		; FF 1D 3A 50 ; Subtract with carry (long,X) $503A1D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy $F1.b,X		; B4 F1 ; Load Y register $F1.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	cmp ($B2.b,X)		; C1 B2 ; Compare accumulator ($B2.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	and ($E1.b),Y		; 31 E1 ; AND accumulator with memory ($E1.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($EF.b)		; F2 EF ; Subtract with carry (indirect) ($EF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $B4		; 10 B4 ; Branch if plus to $10, $B4 [Flow: branch]
.INDEX 16
	rep #$1E		; C2 1E
	and $00125C.l,X		; 3F 5C 12 00 ; AND accumulator with memory (long,X) $00125C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsr $1E10.w		; 20 10 1E ; Jump to subroutine at $1E10.w [Writes: Stack Pointer] [Flow: call]
	lda ($5A.b)		; B2 5A ; Load accumulator (indirect) ($5A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $EF.b		; 05 EF ; Logical OR $EF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($2D.b),Y		; 31 2D ; AND accumulator with memory ($2D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($F3.b)		; 32 F3 ; AND accumulator with memory (indirect) ($F3.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda ($B2.b),Y		; B1 B2 ; Load accumulator ($B2.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($F3.b)		; 32 F3 ; AND accumulator with memory (indirect) ($F3.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp ($C5.b,S),Y		; D3 C5 ; Compare accumulator (stack relative indirect indexed) ($C5.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	cpx #$131D.w		; E0 1D 13 ; Compare #$131D.w with X register [Reads: X Index] [Flags: NCZ]
	cpx $C2.b		; E4 C2 ; Compare $C2.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc ($02.b,X)		; E1 02 ; Subtract with carry ($02.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $304D.w		; 0E 4D 30 ; Arithmetic shift left $304D.w [Flags: NCZ]
	asl $0E0F.w		; 0E 0F 0E ; Arithmetic shift left $0E0F.w [Flags: NCZ]
.INDEX 16
	rep #$10		; C2 10
	.db $F0, $01		; F0 01 ; Branch if equal to $F0, $01 [Flow: branch]
	sbc ($E0.b,X)		; E1 E0 ; Subtract with carry ($E0.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cop $FF.b		; 02 FF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
.INDEX 16
	rep #$10		; C2 10
	and $C2F1.w		; 2D F1 C2 ; Logical AND $C2F1.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($1D.b),Y		; 11 1D ; OR accumulator with memory ($1D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($EF.b,X)		; 21 EF ; Logical AND ($EF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ldx #$C359.w		; A2 59 C3 ; Load #$C359.w into X register [Writes: X Index] [Flags: NZ]
	ldx $B23F.w,Y		; BE 3F B2 ; Load X register $B23F.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ldx $DA.b,Y		; B6 DA ; Load X register $DA.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	and $2FC2.w		; 2D C2 2F ; Logical AND $2FC2.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cop $B0.b		; 02 B0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $0E0F.w		; 4E 0F 0E ; Logical shift right $0E0F.w [Flags: NCZ]
	ora $0FC201.l,X		; 1F 01 C2 0F ; Logical OR long $0FC201.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $EF		; F0 EF ; Branch if equal to $F0, $EF [Flow: branch]
	.db $10, $1E		; 10 1E ; Branch if plus to $10, $1E [Flow: branch]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($C2.b),Y		; 11 C2 ; OR accumulator with memory ($C2.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $2FF15D.l,X		; FF 5D F1 2F ; Subtract with carry (long,X) $2FF15D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$E1F1.w		; E0 F1 E1 ; Compare #$E1F1.w with X register [Reads: X Index] [Flags: NCZ]
	ora $D314B2.l,X		; 1F B2 14 D3 ; Logical OR long $D314B2.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cop $F1.b		; 02 F1 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1F2F00.l,X		; 1F 00 2F 1F ; Logical OR long $1F2F00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda ($F1.b)		; B2 F1 ; Load accumulator (indirect) ($F1.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($FE.b,X)		; 01 FE ; Logical OR ($FE.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc ($C3.b,S),Y		; F3 C3 ; Subtract with carry (stack relative indirect indexed) ($C3.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $A2C0D7.l,X		; 1F D7 C0 A2 ; Logical OR long $A2C0D7.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $42, $DD		; 42 DD ; Reserved instruction
	and ($1B.b),Y		; 31 1B ; AND accumulator with memory ($1B.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr $3A3F.w		; 4E 3F 3A ; Logical shift right $3A3F.w [Flags: NCZ]
	eor ($B2.b,X)		; 41 B2 ; Exclusive OR accumulator with memory ($B2.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $F1		; 10 F1 ; Branch if plus to $10, $F1 [Flow: branch]
	sbc ($E2.b),Y		; F1 E2 ; Subtract with carry ($E2.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
.ACCU 16
.INDEX 16
	rep #$3E		; C2 3E
	sbc ($5B.b,X)		; E1 5B ; Subtract with carry ($5B.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda ($E2.b)		; B2 E2 ; Load accumulator (indirect) ($E2.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $326D2F.l		; 2F 2F 6D 32 ; AND accumulator with memory (long) $326D2F.l [Writes: Accumulator] [Flags: NZ]
	inc $F25B.w,X		; FE 5B F2 ; Increment memory $F25B.w,X [Reads: X Index] [Flags: NZ]
	lda ($FC.b)		; B2 FC ; Load accumulator (indirect) ($FC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($D1.b),Y		; 31 D1 ; AND accumulator with memory ($D1.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr $312B.w		; 4E 2B 31 ; Logical shift right $312B.w [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cop $B2.b		; 02 B2 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($F0.b,S),Y		; F3 F0 ; Subtract with carry (stack relative indirect indexed) ($F0.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc $12200F.l,X		; FF 0F 20 12 ; Subtract with carry (long,X) $12200F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $1C.b		; 05 1C ; Logical OR $1C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
.ACCU 16
.INDEX 16
	rep #$3E		; C2 3E
	.db $F0, $0E		; F0 0E ; Branch if equal to $F0, $0E [Flow: branch]
	sbc ($01.b),Y		; F1 01 ; Subtract with carry ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $C20FF1.l,X		; FF F1 0F C2 ; Subtract with carry (long,X) $C20FF1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr $F200.w		; 20 00 F2 ; Jump to subroutine at $F200.w [Writes: Stack Pointer] [Flow: call]
	inc $B26F.w		; EE 6F B2 ; Increment $B26F.w [Flags: NZ]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	lda ($0F.b)		; B2 0F ; Load accumulator (indirect) ($0F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	trb $ED.b		; 14 ED ; Test and reset bits $ED.b [Reads: Accumulator] [Flags: Z]
	and ($0C.b)		; 32 0C ; AND accumulator with memory (indirect) ($0C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $A611.w,X		; 3D 11 A6 ; AND accumulator with memory $A611.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldx $D1.b		; A6 D1 ; Load $D1.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	sbc ($E9.b,S),Y		; F3 E9 ; Subtract with carry (stack relative indirect indexed) ($E9.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	eor [$AE.b],Y		; 57 AE ; Exclusive OR accumulator with memory (long indexed) [$AE.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $C2.b		; 14 C2 ; Test and reset bits $C2.b [Reads: Accumulator] [Flags: Z]
	lda ($2E.b)		; B2 2E ; Load accumulator (indirect) ($2E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and [$AB.b]		; 27 AB ; AND accumulator with memory (long) [$AB.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpx #$F32F.w		; E0 2F F3 ; Compare #$F32F.w with X register [Reads: X Index] [Flags: NCZ]
	cpy #$3DB2.w		; C0 B2 3D ; Compare #$3DB2.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpy $4C.b		; C4 4C ; Compare $4C.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	lda ($EF.b,S),Y		; B3 EF ; Load accumulator (stack relative indirect indexed) ($EF.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $F000.w,X		; 3E 00 F0 ; Rotate left $F000.w,X [Reads: X Index] [Flags: NCZ]
.ACCU 16
	rep #$2F		; C2 2F
	sbc $2F.b,S		; E3 2F ; Subtract stack-relative $2F.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	ora $E04E.w		; 0D 4E E0 ; Logical OR $E04E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($D0.b,X)		; 01 D0 ; Logical OR ($D0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda ($FC.b)		; B2 FC ; Load accumulator (indirect) ($FC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $1C102C.l		; 2F 2C 10 1C ; AND accumulator with memory (long) $1C102C.l [Writes: Accumulator] [Flags: NZ]
	sbc ($D1.b)		; F2 D1 ; Subtract with carry (indirect) ($D1.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $EC59A2.l,X		; FF A2 59 EC ; Subtract with carry (long,X) $EC59A2.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $34CD.w,X		; 7D CD 34 ; Add $34CD.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy $E602.w		; CC 02 E6 ; Compare $E602.w with Y register [Reads: Y Index] [Flags: NCZ]
.ACCU 16
.INDEX 16
	rep #$F0		; C2 F0
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	sbc ($E0.b,S),Y		; F3 E0 ; Subtract with carry (stack relative indirect indexed) ($E0.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	rol $1C10.w		; 2E 10 1C ; Rotate left $1C10.w [Flags: NCZ]
	lda ($F4.b)		; B2 F4 ; Load accumulator (indirect) ($F4.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpy #$203C.w		; C0 3C 20 ; Compare #$203C.w with Y register [Reads: Y Index] [Flags: NCZ]
	and $B003.w		; 2D 03 B0 ; Logical AND $B003.w with accumulator [Writes: Accumulator] [Flags: NZ]
	rol $01C2.w		; 2E C2 01 ; Rotate left $01C2.w [Flags: NCZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $C5		; 10 C5 ; Branch if plus to $10, $C5 [Flow: branch]
	ldx $215D.w,Y		; BE 5D 21 ; Load X register $215D.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	lda ($F4.b)		; B2 F4 ; Load accumulator (indirect) ($F4.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy $03.b,X		; B4 03 ; Load Y register $03.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	ora ($0F.b),Y		; 11 0F ; OR accumulator with memory ($0F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	rol $A314.w,X		; 3E 14 A3 ; Rotate left $A314.w,X [Reads: X Index] [Flags: NCZ]
.INDEX 16
	rep #$10		; C2 10
	and ($E5.b),Y		; 31 E5 ; AND accumulator with memory ($E5.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $1E003F.l,X		; 1F 3F 00 1E ; Logical OR long $1E003F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rol $3BC2.w		; 2E C2 3B ; Rotate left $3BC2.w [Flags: NCZ]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	ora $200001.l		; 0F 01 00 20 ; OR accumulator with memory (long) $200001.l [Writes: Accumulator] [Flags: NZ]
	ora ($B2.b,S),Y		; 13 B2 ; OR accumulator (stack relative indirect indexed) ($B2.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $E0323D.l,X		; 1F 3D 32 E0 ; Logical OR long $E0323D.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $DE5129.l,X		; 3F 29 51 DE ; AND accumulator with memory (long,X) $DE5129.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda ($3F.b)		; B2 3F ; Load accumulator (indirect) ($3F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $D0.b		; 04 D0 ; Test and set bits $D0.b [Reads: Accumulator] [Flags: Z]
	and $C31010.l		; 2F 10 10 C3 ; AND accumulator with memory (long) $C31010.l [Writes: Accumulator] [Flags: NZ]
	.db $30, $B2		; 30 B2 ; Branch if minus to $30, $B2 [Flow: branch]
	sbc $F0F2FE.l,X		; FF FE F2 F0 ; Subtract with carry (long,X) $F0F2FE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $C2.b,S		; 03 C2 ; OR accumulator with stack relative $C2.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $4EB22D.l,X		; 1F 2D B2 4E ; Logical OR long $4EB22D.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsr $21E1.w		; 20 E1 21 ; Jump to subroutine at $21E1.w [Writes: Stack Pointer] [Flow: call]
	cmp ($2B.b,X)		; C1 2B ; Compare accumulator ($2B.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	rol $B211.w		; 2E 11 B2 ; Rotate left $B211.w [Flags: NCZ]
	sbc $F2301C.l,X		; FF 1C 30 F2 ; Subtract with carry (long,X) $F2301C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $002C.w,X		; FE 2C 00 ; Increment memory $002C.w,X [Reads: X Index] [Flags: NZ]
	cpx $B2.b		; E4 B2 ; Compare $B2.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc ($FD.b),Y		; F1 FD ; Subtract with carry ($FD.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($3E.b,S),Y		; F3 3E ; Subtract with carry (stack relative indirect indexed) ($3E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cmp ($1D.b,S),Y		; D3 1D ; Compare accumulator (stack relative indirect indexed) ($1D.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	cop $B3.b		; 02 B3 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda ($3E.b)		; B2 3E ; Load accumulator (indirect) ($3E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $FFF03C.l,X		; FF 3C F0 FF ; Subtract with carry (long,X) $FFF03C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$F43C.w		; E0 3C F4 ; Compare #$F43C.w with X register [Reads: X Index] [Flags: NCZ]
.ACCU 16
	rep #$EE		; C2 EE
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	jsr $E0F1.w		; 20 F1 E0 ; Jump to subroutine at $E0F1.w [Writes: Stack Pointer] [Flow: call]
	.db $10, $FE		; 10 FE ; Branch if plus to $10, $FE [Flow: branch]
	and $E4DDB2.l		; 2F B2 DD E4 ; AND accumulator with memory (long) $E4DDB2.l [Writes: Accumulator] [Flags: NZ]
	ora $3C0E21.l,X		; 1F 21 0E 3C ; Logical OR long $3C0E21.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsr $B6FF.w		; 20 FF B6 ; Jump to subroutine at $B6FF.w [Writes: Stack Pointer] [Flow: call]
	jmp $D1F2F2.l		; 5C F2 F2 D1 ; Jump long to $D1F2F2.l [Flow: jump]
	and $D510.w		; 2D 10 D5 ; Logical AND $D510.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp $B2.b		; C5 B2 ; Compare $B2.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp $D1E020.l,X		; DF 20 E0 D1 ; Compare accumulator (long,X) $D1E020.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($2F.b),Y		; 31 2F ; AND accumulator with memory ($2F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda ($F2.b)		; B2 F2 ; Load accumulator (indirect) ($F2.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $2E6C.w		; 1C 6C 2E ; Test and reset bits $2E6C.w [Reads: Accumulator] [Flags: Z]
	trb $A242.w		; 1C 42 A2 ; Test and reset bits $A242.w [Reads: Accumulator] [Flags: Z]
	cmp $70FD21.l,X		; DF 21 FD 70 ; Compare accumulator (long,X) $70FD21.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	ora $A5F321.l		; 0F 21 F3 A5 ; OR accumulator with memory (long) $A5F321.l [Writes: Accumulator] [Flags: NZ]
	lda ($F1.b)		; B2 F1 ; Load accumulator (indirect) ($F1.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
.ACCU 8
.INDEX 8
	sep #$F1		; E2 F1
	sbc $F2301E.l,X		; FF 1E 30 F2 ; Subtract with carry (long,X) $F2301E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	lda ($31.b)		; B2 31 ; Load accumulator (indirect) ($31.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $1012.w		; 0E 12 10 ; Arithmetic shift left $1012.w [Flags: NCZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	.db $F0, $D4		; F0 D4 ; Branch if equal to $F0, $D4 [Flow: branch]
	sbc $5E4EB2.l		; EF B2 4E 5E ; Subtract with carry (long) $5E4EB2.l [Writes: Accumulator] [Flags: NCVZ]
	cpx #$F0.b		; E0 F0 ; Compare #$F0.b with X register [Reads: X Index] [Flags: NCZ]
	cmp ($3F.b,S),Y		; D3 3F ; Compare accumulator (stack relative indirect indexed) ($3F.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	and $B22F.w		; 2D 2F B2 ; Logical AND $B22F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $C513.w		; 20 13 C5 ; Jump to subroutine at $C513.w [Writes: Stack Pointer] [Flow: call]
	sbc $103F.w,X		; FD 3F 10 ; Subtract with carry $103F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $01		; F0 01 ; Branch if equal to $F0, $01 [Flow: branch]
	ldx #$F2.b		; A2 F2 ; Load #$F2.b into X register [Writes: X Index] [Flags: NZ]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $BE.b		; 14 BE ; Test and reset bits $BE.b [Reads: Accumulator] [Flags: Z]
	trb $A1.b		; 14 A1 ; Test and reset bits $A1.b [Reads: Accumulator] [Flags: Z]
	bit $E2B2.w		; 2C B2 E2 ; Test bits $E2B2.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	ora $1EB3F3.l,X		; 1F F3 B3 1E ; Logical OR long $1EB3F3.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $D241.w,X		; 3D 41 D2 ; AND accumulator with memory $D241.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda ($E4.b)		; B2 E4 ; Load accumulator (indirect) ($E4.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $F4		; F0 F4 ; Branch if equal to $F0, $F4 [Flow: branch]
	cpx #$1F.b		; E0 1F ; Compare #$1F.b with X register [Reads: X Index] [Flags: NCZ]
	cmp $A25C2A.l,X		; DF 2A 5C A2 ; Compare accumulator (long,X) $A25C2A.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	cop $23.b		; 02 23 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $D0, $E5		; D0 E5 ; Branch if not equal to $D0, $E5 [Flow: branch]
	sbc ($DE.b),Y		; F1 DE ; Subtract with carry ($DE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($0E.b),Y		; 51 0E ; Exclusive OR accumulator with memory ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda ($10.b)		; B2 10 ; Load accumulator (indirect) ($10.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor ($F0.b,X)		; 41 F0 ; Exclusive OR accumulator with memory ($F0.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	jsr $E11F.w		; 20 1F E1 ; Jump to subroutine at $E11F.w [Writes: Stack Pointer] [Flow: call]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rol $F3B2.w,X		; 3E B2 F3 ; Rotate left $F3B2.w,X [Reads: X Index] [Flags: NCZ]
	lda $B0E110.l,X		; BF 10 E1 B0 ; Load long $B0E110.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $B2020F.l,X		; 3F 0F 02 B2 ; AND accumulator with memory (long,X) $B2020F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $120FFF.l,X		; 1F FF 0F 12 ; Logical OR long $120FFF.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($10.b,X)		; C1 10 ; Compare accumulator ($10.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	ora $FDA2F3.l,X		; 1F F3 A2 FD ; Logical OR long $FDA2F3.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $4F		; F0 4F ; Branch if equal to $F0, $4F [Flow: branch]
	jmp ($0104.w)		; 6C 04 01 ; Jump indirect to ($0104.w) [Flow: jump]
	cpx #$4B.b		; E0 4B ; Compare #$4B.b with X register [Reads: X Index] [Flags: NCZ]
	lda ($2F.b)		; B2 2F ; Load accumulator (indirect) ($2F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $0D12.w		; 0E 12 0D ; Arithmetic shift left $0D12.w [Flags: NCZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	and $B2D42E.l,X		; 3F 2E D4 B2 ; AND accumulator with memory (long,X) $B2D42E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $01112D.l		; CF 2D 11 01 ; Compare accumulator (long) $01112D.l [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $C2		; F0 C2 ; Branch if equal to $F0, $C2 [Flow: branch]
	sbc ($0E.b),Y		; F1 0E ; Subtract with carry ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lda ($33.b)		; B2 33 ; Load accumulator (indirect) ($33.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc ($0E.b,X)		; E1 0E ; Subtract with carry ($0E.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $4F		; 10 4F ; Branch if plus to $10, $4F [Flow: branch]
	ora $B2FEE3.l,X		; 1F E3 FE B2 ; Logical OR long $B2FEE3.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jmp $F40FE4.l		; 5C E4 0F F4 ; Jump long to $F40FE4.l [Flow: jump]
	rep #$0B		; C2 0B ; Reset processor status bits #$0B [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	rol $C2E5.w,X		; 3E E5 C2 ; Rotate left $C2E5.w,X [Reads: X Index] [Flags: NCZ]
	sbc ($D0.b),Y		; F1 D0 ; Subtract with carry ($D0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $F0FF01.l,X		; 1F 01 FF F0 ; Logical OR long $F0FF01.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $2BB24E.l		; 0F 4E B2 2B ; OR accumulator with memory (long) $2BB24E.l [Writes: Accumulator] [Flags: NZ]
	lsr $F2D1.w,X		; 5E D1 F2 ; Logical shift right $F2D1.w,X [Reads: X Index] [Flags: NCZ]
	pea $0DD4.w		; F4 D4 0D ; Push absolute address $0DD4.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	ora $A313A2.l		; 0F A2 13 A3 ; OR accumulator with memory (long) $A313A2.l [Writes: Accumulator] [Flags: NZ]
	sbc $D2.b,X		; F5 D2 ; Subtract $D2.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $D1.b,S		; 03 D1 ; OR accumulator with stack relative $D1.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc ($2A.b)		; F2 2A ; Subtract with carry (indirect) ($2A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda ($E3.b)		; B2 E3 ; Load accumulator (indirect) ($E3.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $305A.w,X		; FE 5A 30 ; Increment memory $305A.w,X [Reads: X Index] [Flags: NZ]
	and $F0A0D6.l,X		; 3F D6 A0 F0 ; AND accumulator with memory (long,X) $F0A0D6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda ($1B.b)		; B2 1B ; Load accumulator (indirect) ($1B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $42, $00		; 42 00 ; Reserved instruction
	rol $1F1E.w		; 2E 1E 1F ; Rotate left $1F1E.w [Flags: NCZ]
	jsr $B2F4.w		; 20 F4 B2 ; Jump to subroutine at $B2F4.w [Writes: Stack Pointer] [Flow: call]
	cpx $E1.b		; E4 E1 ; Compare $E1.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	jsr $B1D4.w		; 20 D4 B1 ; Jump to subroutine at $B1D4.w [Writes: Stack Pointer] [Flow: call]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	rol $F2B3.w		; 2E B3 F2 ; Rotate left $F2B3.w [Flags: NCZ]
	brk $31.b		; 00 31 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $E0.b,S		; C3 E0 ; Compare accumulator (stack relative) $E0.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	jmp $413F.w		; 4C 3F 41 ; Jump to $413F.w [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C8.b		; 00 C8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($F1.b,X)		; 01 F1 ; Logical OR ($F1.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $2FD34C.l,X		; FF 4C D3 2F ; Subtract with carry (long,X) $2FD34C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $00.b,X		; B4 00 ; Load Y register $00.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $F46F.w		; 1C 6F F4 ; Test and reset bits $F46F.w [Reads: Accumulator] [Flags: Z]
	.db $50, $20		; 50 20 ; Branch if overflow clear to $50, $20 [Flow: branch]
	sty $5B.b		; 84 5B ; Store Y register to $5B.b [Reads: Y Index]
	.db $D0, $11		; D0 11 ; Branch if not equal to $D0, $11 [Flow: branch]
	ora $FEFFFF.l		; 0F FF FF FE ; OR accumulator with memory (long) $FEFFFF.l [Writes: Accumulator] [Flags: NZ]
	dec $0FB4.w		; CE B4 0F ; Decrement $0FB4.w [Flags: NZ]
	cmp $3D.b,S		; C3 3D ; Compare accumulator (stack relative) $3D.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $B4DFED.l,X		; FF ED DF B4 ; Subtract with carry (long,X) $B4DFED.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $0F14.w		; 20 14 0F ; Jump to subroutine at $0F14.w [Writes: Stack Pointer] [Flow: call]
	cmp $0022.w		; CD 22 00 ; Compare $0022.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($2D.b,X)		; 01 2D ; Logical OR ($2D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $10, $C1		; 10 C1 ; Branch if plus to $10, $C1 [Flow: branch]
	and $F2B42E.l,X		; 3F 2E B4 F2 ; AND accumulator with memory (long,X) $F2B42E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($13.b,X)		; 01 13 ; Logical OR ($13.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $304411.l		; EF 11 44 30 ; Subtract with carry (long) $304411.l [Writes: Accumulator] [Flags: NCVZ]
	brk $94.b		; 00 94 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $FFF0EF.l		; CF EF F0 FF ; Compare accumulator (long) $FFF0EF.l [Reads: Accumulator] [Flags: NCZ]
.ACCU 16
	rep #$2D		; C2 2D
	inc $B8EE.w		; EE EE B8 ; Increment $B8EE.w [Flags: NZ]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($4C.b,S),Y		; F3 4C ; Subtract with carry (stack relative indirect indexed) ($4C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $C24CD1.l		; 0F D1 4C C2 ; OR accumulator with memory (long) $C24CD1.l [Writes: Accumulator] [Flags: NZ]
	ldy $05.b		; A4 05 ; Load $05.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	cop $FF.b		; 02 FF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $B4.b		; 24 B4 ; Test bits $B4.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $64		; F0 64 ; Branch if equal to $F0, $64 [Flow: branch]
	inc $30CF.w		; EE CF 30 ; Increment $30CF.w [Flags: NZ]
	and $B4.b,S		; 23 B4 ; AND accumulator with stack relative $B4.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $EE.b,S		; 43 EE ; Exclusive OR accumulator with stack relative $EE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $10, $FF		; 10 FF ; Branch if plus to $10, $FF [Flow: branch]
	cmp $13ED.w,X		; DD ED 13 ; Compare accumulator $13ED.w,X [Reads: X Index] [Flags: NCZ]
	and ($B4.b,X)		; 21 B4 ; Logical AND ($B4.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $F4.b		; 02 F4 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00F0.w		; 2D F0 00 ; Logical AND $00F0.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A8.b		; 00 A8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $F5FC01.l,X		; FF 01 FC F5 ; Subtract with carry (long,X) $F5FC01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($5A.b),Y		; F1 5A ; Subtract with carry ($5A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $4F.b,S		; A3 4F ; Load accumulator (stack relative) $4F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldy $0C.b		; A4 0C ; Load $0C.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	dec $C302.w,X		; DE 02 C3 ; Decrement memory $C302.w,X [Reads: X Index] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b),Y		; 11 01 ; OR accumulator with memory ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	cop $ED.b		; 02 ED ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($13.b),Y		; 31 13 ; AND accumulator with memory ($13.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $2E		; D0 2E ; Branch if not equal to $D0, $2E [Flow: branch]
	cmp ($11.b)		; D2 11 ; Compare accumulator (indirect) ($11.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	ldx #$36.b		; A2 36 ; Load #$36.b into X register [Writes: X Index] [Flags: NZ]
	eor $50DA.w		; 4D DA 50 ; Exclusive OR $50DA.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	brk $A8.b		; 00 A8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $F0		; 10 F0 ; Branch if plus to $10, $F0 [Flow: branch]
	.db $10, $F0		; 10 F0 ; Branch if plus to $10, $F0 [Flow: branch]
	.db $B0, $44		; B0 44 ; Branch if carry set to $B0, $44 [Flow: branch]
	sbc $B811.w		; ED 11 B8 ; Subtract $B811.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sbc ($31.b,X)		; E1 31 ; Subtract with carry ($31.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	eor ($F1.b),Y		; 51 F1 ; Exclusive OR accumulator with memory ($F1.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $A42EE2.l		; 0F E2 2E A4 ; OR accumulator with memory (long) $A42EE2.l [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	and ($36.b),Y		; 31 36 ; AND accumulator with memory ($36.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

.INDEX 8
	sep #$DB		; E2 DB
	lsr $24.b,X		; 56 24 ; Logical shift right $24.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ldy $0C.b,X		; B4 0C ; Load Y register $0C.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	cmp ($12.b,X)		; C1 12 ; Compare accumulator ($12.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	mvn $1D,$10		; 54 10 1D ; Move block negative $1D,$10 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cmp $60.b,S		; C3 60 ; Compare accumulator (stack relative) $60.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	ldy $F3.b		; A4 F3 ; Load $F3.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	.db $D0, $F0		; D0 F0 ; Branch if not equal to $D0, $F0 [Flow: branch]
	.db $F0, $0F		; F0 0F ; Branch if equal to $F0, $0F [Flow: branch]
	sbc $B8F0FF.l,X		; FF FF F0 B8 ; Subtract with carry (long,X) $B8F0FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1FC022.l		; 0F 22 C0 1F ; OR accumulator with memory (long) $1FC022.l [Writes: Accumulator] [Flags: NZ]
	cpy #$4F.b		; C0 4F ; Compare #$4F.b with Y register [Reads: Y Index] [Flags: NCZ]
	ldy $F1.b,X		; B4 F1 ; Load Y register $F1.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	sbc ($01.b,X)		; E1 01 ; Subtract with carry ($01.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $43		; F0 43 ; Branch if equal to $F0, $43 [Flow: branch]
	asl $11C1.w		; 0E C1 11 ; Arithmetic shift left $11C1.w [Flags: NCZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	ora ($FE.b),Y		; 11 FE ; OR accumulator with memory ($FE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($11.b),Y		; D1 11 ; Compare accumulator ($11.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	ora ($0E.b,X)		; 01 0E ; Logical OR ($0E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $20.b		; 04 20 ; Test and set bits $20.b [Reads: Accumulator] [Flags: Z]
	ldy $70.b		; A4 70 ; Load $70.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	.db $B0, $DB		; B0 DB ; Branch if carry set to $B0, $DB [Flow: branch]
	cmp $132B25.l		; CF 25 2B 13 ; Compare accumulator (long) $132B25.l [Reads: Accumulator] [Flags: NCZ]
	eor ($A8.b),Y		; 51 A8 ; Exclusive OR accumulator with memory ($A8.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $F2		; F0 F2 ; Branch if equal to $F0, $F2 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0EEFC7.l,X		; FF C7 EF 0E ; Subtract with carry (long,X) $0EEFC7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	ora ($1C.b)		; 12 1C ; OR accumulator with memory (indirect) ($1C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	ora $E1C2.w,X		; 1D C2 E1 ; OR accumulator with memory $E1C2.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $A454.w		; 0D 54 A4 ; Logical OR $A454.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $CF.b		; 00 CF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($ED.b)		; 32 ED ; AND accumulator with memory (indirect) ($ED.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $230DE1.l,X		; FF E1 0D 23 ; Subtract with carry (long,X) $230DE1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy $F0.b,X		; B4 F0 ; Load Y register $F0.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	ora $02DD21.l		; 0F 21 DD 02 ; OR accumulator with memory (long) $02DD21.l [Writes: Accumulator] [Flags: NZ]
	jsr $2022.w		; 20 22 20 ; Jump to subroutine at $2022.w [Writes: Stack Pointer] [Flow: call]
	clv		; B8 ; Clear overflow flag [Flags: V]
	sbc $3D.b,S		; E3 3D ; Subtract stack-relative $3D.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	sbc ($33.b,X)		; E1 33 ; Subtract with carry ($33.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $2011.w		; CD 11 20 ; Compare $2011.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	asl $EDA4.w,X		; 1E A4 ED ; Arithmetic shift left $EDA4.w,X [Reads: X Index] [Flags: NCZ]
	sta ($65.b)		; 92 65 ; Store accumulator (indirect) ($65.b) [Reads: Direct Page, Accumulator]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $03CDFB.l,X		; FF FB CD 03 ; Subtract with carry (long,X) $03CDFB.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	jmp.w [$2E01]		; DC 01 2E ; Jump long indirect [$2E01] [Flow: jump]
	rep #$01		; C2 01 ; Reset processor status bits #$01 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	adc $B8EEBD.l		; 6F BD EE B8 ; Add with carry (long) $B8EEBD.l [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	and $F130CE.l,X		; 3F CE 30 F1 ; AND accumulator with memory (long,X) $F130CE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($F0.b,X)		; 01 F0 ; Logical OR ($F0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc ($A4.b),Y		; F1 A4 ; Subtract with carry ($A4.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $1102.w		; EE 02 11 ; Increment $1102.w [Flags: NZ]
	cop $5F.b		; 02 5F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($22.b,X)		; C1 22 ; Compare accumulator ($22.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	brk $A4.b		; 00 A4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $F5B0.w,X		; 3C B0 F5 ; Test bits $F5B0.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	eor ($DE.b),Y		; 51 DE ; Exclusive OR accumulator with memory ($DE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $63.b		; E5 63 ; Subtract $63.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $32A8.w		; 0D A8 32 ; Logical OR $32A8.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $00F21D.l		; EF 1D F2 00 ; Subtract with carry (long) $00F21D.l [Writes: Accumulator] [Flags: NCVZ]
	and ($EF.b)		; 32 EF ; AND accumulator with memory (indirect) ($EF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $DFA4.w		; 0D A4 DF ; Logical OR $DFA4.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	wai		; CB ; Wait for interrupt
	.db $D0, $10		; D0 10 ; Branch if not equal to $D0, $10 [Flow: branch]
	and $F09800.l		; 2F 00 98 F0 ; AND accumulator with memory (long) $F09800.l [Writes: Accumulator] [Flags: NZ]
	bit $CE.b,X		; 34 CE ; Test bits $CE.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sbc $E622.w,X		; FD 22 E6 ; Subtract with carry $E622.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $A8D1.w,Y		; F9 D1 A8 ; Subtract with carry $A8D1.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($ED.b),Y		; 51 ED ; Exclusive OR accumulator with memory ($ED.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $52.b,S		; E3 52 ; Subtract stack-relative $52.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sep #$01		; E2 01 ; Set processor status bits #$01 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	sbc ($A4.b,S),Y		; F3 A4 ; Subtract with carry (stack relative indirect indexed) ($A4.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $3523.w		; 0D 23 35 ; Logical OR $3523.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $EECD.w		; 0E CD EE ; Arithmetic shift left $EECD.w [Flags: NCZ]
	and ($0D.b),Y		; 31 0D ; AND accumulator with memory ($0D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	cpx #$53.b		; E0 53 ; Compare #$53.b with X register [Reads: X Index] [Flags: NCZ]
	pea $E3AB.w		; F4 AB E3 ; Push absolute address $E3AB.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	ora $2E.b,X		; 15 2E ; OR accumulator with memory $2E.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cpy $CFA4.w		; CC A4 CF ; Compare $CFA4.w with Y register [Reads: Y Index] [Flags: NCZ]
	sbc $3414.w,X		; FD 14 34 ; Subtract with carry $3414.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $F0, $42		; F0 42 ; Branch if equal to $F0, $42 [Flow: branch]
	tsb $43A8.w		; 0C A8 43 ; Test and set bits $43A8.w [Reads: Accumulator] [Flags: Z]
	rol $03AF.w,X		; 3E AF 03 ; Rotate left $03AF.w,X [Reads: X Index] [Flags: NCZ]
	ora $D13C2F.l,X		; 1F 2F 3C D1 ; Logical OR long $D13C2F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldy $EE.b		; A4 EE ; Load $EE.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	ora ($40.b,X)		; 01 40 ; Logical OR ($40.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc ($FD.b,S),Y		; F3 FD ; Subtract with carry (stack relative indirect indexed) ($FD.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $D0, $34		; D0 34 ; Branch if not equal to $D0, $34 [Flow: branch]
	asl $23A4.w		; 0E A4 23 ; Arithmetic shift left $23A4.w [Flags: NCZ]
	inc $43E4.w,X		; FE E4 43 ; Increment memory $43E4.w,X [Reads: X Index] [Flags: NZ]
	ora ($E1.b)		; 12 E1 ; OR accumulator with memory (indirect) ($E1.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $A421.w		; 0E 21 A4 ; Arithmetic shift left $A421.w [Flags: NCZ]
	sbc ($30.b),Y		; F1 30 ; Subtract with carry ($30.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	dec $2E12.w,X		; DE 12 2E ; Decrement memory $2E12.w,X [Reads: X Index] [Flags: NZ]
	cmp $A8B2.w,X		; DD B2 A8 ; Compare accumulator $A8B2.w,X [Reads: X Index] [Flags: NCZ]
	rol $000D.w,X		; 3E 0D 00 ; Rotate left $000D.w,X [Reads: X Index] [Flags: NCZ]
	cmp ($F2.b),Y		; D1 F2 ; Compare accumulator ($F2.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	pea $EC01.w		; F4 01 EC ; Push absolute address $EC01.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	sbc $00.b,X		; F5 00 ; Subtract $00.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $D111.w		; 2C 11 D1 ; Test bits $D111.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	and $FD.b,S		; 23 FD ; AND accumulator with stack relative $FD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $1D43A8.l		; CF A8 43 1D ; Compare accumulator (long) $1D43A8.l [Reads: Accumulator] [Flags: NCZ]
	sbc ($42.b,X)		; E1 42 ; Subtract with carry ($42.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $C1E0.w,X		; FD E0 C1 ; Subtract with carry $C1E0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($94.b)		; 52 94 ; Exclusive OR accumulator with memory (indirect) ($94.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $5C		; 10 5C ; Branch if plus to $10, $5C [Flow: branch]
	tsb $52.b		; 04 52 ; Test and set bits $52.b [Reads: Accumulator] [Flags: Z]
	sbc ($0F.b,X)		; E1 0F ; Subtract with carry ($0F.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $ED.b,S		; 43 ED ; Exclusive OR accumulator with stack relative $ED.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldy $0D.b		; A4 0D ; Load $0D.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	sbc $1E.b,S		; E3 1E ; Subtract stack-relative $1E.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	dec $13B1.w,X		; DE B1 13 ; Decrement memory $13B1.w,X [Reads: X Index] [Flags: NZ]
	and ($2F.b,S),Y		; 33 2F ; AND accumulator (stack relative indirect indexed) ($2F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	sbc ($F3.b)		; F2 F3 ; Subtract with carry (indirect) ($F3.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and $42D3.w		; 2D D3 42 ; Logical AND $42D3.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ldx $3EF1.w,Y		; BE F1 3E ; Load X register $3EF1.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	cop $FF.b		; 02 FF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($F0.b,X)		; 01 F0 ; Logical OR ($F0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $42, $EE		; 42 EE ; Reserved instruction
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	tsb $A8.b		; 04 A8 ; Test and set bits $A8.b [Reads: Accumulator] [Flags: Z]
	ora ($3F.b)		; 12 3F ; OR accumulator with memory (indirect) ($3F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $ED01FF.l		; EF FF 01 ED ; Subtract with carry (long) $ED01FF.l [Writes: Accumulator] [Flags: NCVZ]
	mvp $A4,$F2		; 44 F2 A4 ; Move block positive $A4,$F2 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	ora $2113FF.l,X		; 1F FF 13 21 ; Logical OR long $2113FF.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $13DE.w		; 0E DE 13 ; Arithmetic shift left $13DE.w [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	eor $F0D021.l		; 4F 21 D0 F0 ; Exclusive OR accumulator with memory (long) $F0D021.l [Writes: Accumulator] [Flags: NZ]
	ora ($23.b),Y		; 11 23 ; OR accumulator with memory ($23.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $1CA4.w,X		; FD A4 1C ; Subtract with carry $1CA4.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: NCZ]
	inc $110F.w,X		; FE 0F 11 ; Increment memory $110F.w,X [Reads: X Index] [Flags: NZ]
	jsr $A8ED.w		; 20 ED A8 ; Jump to subroutine at $A8ED.w [Writes: Stack Pointer] [Flow: call]
	and ($1E.b,S),Y		; 33 1E ; AND accumulator (stack relative indirect indexed) ($1E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
.ACCU 16
.INDEX 16
	rep #$FE		; C2 FE
	tsb $ED.b		; 04 ED ; Test and set bits $ED.b [Reads: Accumulator] [Flags: Z]
	cop $12.b		; 02 12 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ldy $E06E.w,X		; BC 6E E0 ; Load Y register $E06E.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	sbc [$3A.b]		; E7 3A ; Subtract with carry (long) [$3A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp $9847DC.l,X		; DF DC 47 98 ; Compare accumulator (long,X) $9847DC.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	asl $2EE2.w		; 0E E2 2E ; Arithmetic shift left $2EE2.w [Flags: NCZ]
	tsb $FB.b		; 04 FB ; Test and set bits $FB.b [Reads: Accumulator] [Flags: Z]
	cop $35.b		; 02 35 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	sbc $F30D23.l,X		; FF 23 0D F3 ; Subtract with carry (long,X) $F30D23.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $52E4.w		; ED E4 52 ; Subtract $52E4.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cmp $00A4.w,X		; DD A4 00 ; Compare accumulator $00A4.w,X [Reads: X Index] [Flags: NCZ]
	ora ($11.b)		; 12 11 ; OR accumulator with memory (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0F		; F0 0F ; Branch if equal to $F0, $0F [Flow: branch]
	sbc $4E15.w,X		; FD 15 4E ; Subtract with carry $4E15.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	cmp $D2.b,X		; D5 D2 ; Compare accumulator $D2.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	and $43C0.w		; 2D C0 43 ; Logical AND $43C0.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $0ED0.w		; 2D D0 0E ; Logical AND $0ED0.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($2C.b)		; F2 2C ; Subtract with carry (indirect) ($2C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp $1B3F36.l		; CF 36 3F 1B ; Compare accumulator (long) $1B3F36.l [Reads: Accumulator] [Flags: NCZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	brk $98.b		; 00 98 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $20BE44.l,X		; 1F 44 BE 20 ; Logical OR long $20BE44.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $EFF4.w,X		; FE F4 EF ; Increment memory $EFF4.w,X [Reads: X Index] [Flags: NZ]
	and ($A8.b),Y		; 31 A8 ; AND accumulator with memory ($A8.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $3C.b		; 24 3C ; Test bits $3C.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cmp $1FE3.w,X		; DD E3 1F ; Compare accumulator $1FE3.w,X [Reads: X Index] [Flags: NCZ]
	ora ($02.b)		; 12 02 ; OR accumulator with memory (indirect) ($02.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $3120A8.l		; CF A8 20 31 ; Compare accumulator (long) $3120A8.l [Reads: Accumulator] [Flags: NCZ]
	asl $F3DC.w,X		; 1E DC F3 ; Arithmetic shift left $F3DC.w,X [Reads: X Index] [Flags: NCZ]
	and ($CF.b,S),Y		; 33 CF ; AND accumulator (stack relative indirect indexed) ($CF.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $CFE294.l		; 2F 94 E2 CF ; AND accumulator with memory (long) $CFE294.l [Writes: Accumulator] [Flags: NZ]
	sbc $1FED.w		; ED ED 1F ; Subtract $1FED.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ora ($1D.b,S),Y		; 13 1D ; OR accumulator (stack relative indirect indexed) ($1D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $F1A4.w		; CE A4 F1 ; Decrement $F1A4.w [Flags: NZ]
	rol $22CF.w		; 2E CF 22 ; Rotate left $22CF.w [Flags: NCZ]
	and ($EC.b)		; 32 EC ; AND accumulator with memory (indirect) ($EC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $3FA803.l		; EF 03 A8 3F ; Subtract with carry (long) $3FA803.l [Writes: Accumulator] [Flags: NCVZ]
	sbc $2400.w		; ED 00 24 ; Subtract $2400.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ora $1C0FF0.l		; 0F F0 0F 1C ; OR accumulator with memory (long) $1C0FF0.l [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	ora ($00.b,S),Y		; 13 00 ; OR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	mvp $F1,$DC		; 44 DC F1 ; Move block positive $F1,$DC [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $98E102.l		; 0F 02 E1 98 ; OR accumulator with memory (long) $98E102.l [Writes: Accumulator] [Flags: NZ]
	ora $0D.b		; 05 0D ; Logical OR $0D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $BD2403.l		; CF 03 24 BD ; Compare accumulator (long) $BD2403.l [Reads: Accumulator] [Flags: NCZ]
	lda $439462.l,X		; BF 62 94 43 ; Load long $439462.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $F3CE.w		; 0E CE F3 ; Arithmetic shift left $F3CE.w [Flags: NCZ]
	ora $E0.b,S		; 03 E0 ; OR accumulator with stack relative $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr $9801.w		; 20 01 98 ; Jump to subroutine at $9801.w [Writes: Stack Pointer] [Flow: call]
	cpx #$2DF1.w		; E0 F1 2D ; Compare #$2DF1.w with X register [Reads: X Index] [Flags: NCZ]
	sbc $010224.l		; EF 24 02 01 ; Subtract with carry (long) $010224.l [Writes: Accumulator] [Flags: NCVZ]
	dec $1298.w,X		; DE 98 12 ; Decrement memory $1298.w,X [Reads: X Index] [Flags: NZ]
	sbc ($F0.b,X)		; E1 F0 ; Subtract with carry ($F0.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	stz $CF.b		; 64 CF ; Store zero to $CF.b
	.db $D0, $3C		; D0 3C ; Branch if not equal to $D0, $3C [Flow: branch]
	and $98.b,X		; 35 98 ; Logical AND $98.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sbc ($15.b),Y		; F1 15 ; Subtract with carry ($15.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $FA.b,S		; 43 FA ; Exclusive OR accumulator with stack relative $FA.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $F2FF.w,X		; 1E FF F2 ; Arithmetic shift left $F2FF.w,X [Reads: X Index] [Flags: NCZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($32.b),Y		; 11 32 ; OR accumulator with memory ($32.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	dec $EFEE.w,X		; DE EE EF ; Decrement memory $EFEE.w,X [Reads: X Index] [Flags: NZ]
	bit $01.b,X		; 34 01 ; Test bits $01.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	tsb $0F98.w		; 0C 98 0F ; Test and set bits $0F98.w [Reads: Accumulator] [Flags: Z]
	sbc ($2D.b,X)		; E1 2D ; Subtract with carry ($2D.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$212D.w		; C0 2D 21 ; Compare #$212D.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sty $32.b,X		; 94 32 ; Store Y register $32.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	eor $31.b,S		; 43 31 ; Exclusive OR accumulator with stack relative $31.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $513446.l,X		; DF 46 34 51 ; Compare accumulator (long,X) $513446.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	stz $7098.w		; 9C 98 70 ; Store zero to $7098.w
	sbc ($42.b,X)		; E1 42 ; Subtract with carry ($42.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $26DBF0.l		; 2F F0 DB 26 ; AND accumulator with memory (long) $26DBF0.l [Writes: Accumulator] [Flags: NZ]
	.db $30, $88		; 30 88 ; Branch if minus to $30, $88 [Flow: branch]
	sbc $C1B7.w,X		; FD B7 C1 ; Subtract with carry $C1B7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $F0E53B.l		; 0F 3B E5 F0 ; OR accumulator with memory (long) $F0E53B.l [Writes: Accumulator] [Flags: NZ]
	sty $98.b,X		; 94 98 ; Store Y register $98.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	adc $DFB2FF.l		; 6F FF B2 DF ; Add with carry (long) $DFB2FF.l [Writes: Accumulator] [Flags: NCVZ]
	pea $DA4F.w		; F4 4F DA ; Push absolute address $DA4F.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sbc $98.b,S		; E3 98 ; Subtract stack-relative $98.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	eor ($CE.b),Y		; 51 CE ; Exclusive OR accumulator with memory ($CE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda ($20.b)		; B2 20 ; Load accumulator (indirect) ($20.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($1E.b),Y		; 31 1E ; AND accumulator with memory ($1E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	inc $980B.w,X		; FE 0B 98 ; Increment memory $980B.w,X [Reads: X Index] [Flags: NZ]
	cmp ($22.b,S),Y		; D3 22 ; Compare accumulator (stack relative indirect indexed) ($22.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	.db $30, $DF		; 30 DF ; Branch if minus to $30, $DF [Flow: branch]
	eor ($FE.b)		; 52 FE ; Exclusive OR accumulator with memory (indirect) ($FE.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($0D.b)		; 12 0D ; OR accumulator with memory (indirect) ($0D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lda ($42.b),Y		; B1 42 ; Load accumulator ($42.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $2FE10F.l,X		; 1F 0F E1 2F ; Logical OR long $2FE10F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $23.b,X		; 35 23 ; Logical AND $23.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cpx $73BF.w		; EC BF 73 ; Compare $73BF.w with X register [Reads: X Index] [Flags: NCZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	cmp ($42.b,X)		; C1 42 ; Compare accumulator ($42.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($32.b),Y		; D1 32 ; Compare accumulator ($32.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	asl $BEEF.w		; 0E EF BE ; Arithmetic shift left $BEEF.w [Flags: NCZ]
	eor $1E.b,S		; 43 1E ; Exclusive OR accumulator with stack relative $1E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $98		; D0 98 ; Branch if not equal to $D0, $98 [Flow: branch]
	sbc $14DD01.l,X		; FF 01 DD 14 ; Subtract with carry (long,X) $14DD01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $F01E.w		; 2E 1E F0 ; Rotate left $F01E.w [Flags: NCZ]
	sbc ($98.b)		; F2 98 ; Subtract with carry (indirect) ($98.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($1F.b,X)		; E1 1F ; Subtract with carry ($1F.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($41.b,X)		; 01 41 ; Logical OR ($41.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $032DE0.l		; 0F E0 2D 03 ; OR accumulator with memory (long) $032DE0.l [Writes: Accumulator] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and $10.b,S		; 23 10 ; AND accumulator with stack relative $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $51DF.w,X		; DE DF 51 ; Decrement memory $51DF.w,X [Reads: X Index] [Flags: NZ]
	ora ($98.b),Y		; 11 98 ; OR accumulator with memory ($98.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $1220C1.l,X		; FF C1 20 12 ; Subtract with carry (long,X) $1220C1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $1FF2DE.l		; 0F DE F2 1F ; OR accumulator with memory (long) $1FF2DE.l [Writes: Accumulator] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	dec $5E24.w,X		; DE 24 5E ; Decrement memory $5E24.w,X [Reads: X Index] [Flags: NZ]
	ldy $1302.w		; AC 02 13 ; Load $1302.w into Y register [Writes: Y Index] [Flags: NZ]
	and $DC982E.l,X		; 3F 2E 98 DC ; AND accumulator with memory (long,X) $DC982E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($DF.b)		; F2 DF ; Subtract with carry (indirect) ($DF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($1F.b,X)		; 01 1F ; Logical OR ($1F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $10.b,S		; 23 10 ; AND accumulator with stack relative $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $1288.w,X		; DE 88 12 ; Decrement memory $1288.w,X [Reads: X Index] [Flags: NZ]
	cmp ($01.b),Y		; D1 01 ; Compare accumulator ($01.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	eor $0A.b		; 45 0A ; Exclusive OR $0A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $55.b,S		; A3 55 ; Load accumulator (stack relative) $55.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $E488.w,X		; DD 88 E4 ; Compare accumulator $E488.w,X [Reads: X Index] [Flags: NCZ]
	.db $70, $12		; 70 12 ; Branch if overflow set to $70, $12 [Flow: branch]
	cop $1F.b		; 02 1F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	cop $41.b		; 02 41 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b)		; 12 01 ; OR accumulator with memory (indirect) ($01.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0E		; F0 0E ; Branch if equal to $F0, $0E [Flow: branch]
	cmp $DC5203.l,X		; DF 03 52 DC ; Compare accumulator (long,X) $DC5203.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $CC0D24.l,X		; DF 24 0D CC ; Compare accumulator (long,X) $CC0D24.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	.db $F0, $13		; F0 13 ; Branch if equal to $F0, $13 [Flow: branch]
	.db $30, $FD		; 30 FD ; Branch if minus to $30, $FD [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $CC		; F0 CC ; Branch if equal to $F0, $CC [Flow: branch]
.INDEX 8
	sep #$54		; E2 54
	ora $F098F0.l,X		; 1F F0 98 F0 ; Logical OR long $F098F0.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc ($51.b),Y		; F1 51 ; Subtract with carry ($51.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($D0.b,X)		; 01 D0 ; Logical OR ($D0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $10F098.l		; 2F 98 F0 10 ; AND accumulator with memory (long) $10F098.l [Writes: Accumulator] [Flags: NZ]
	and $10.b		; 25 10 ; Logical AND $10.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $FF		; D0 FF ; Branch if not equal to $D0, $FF [Flow: branch]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $FD0222.l,X		; FF 22 02 FD ; Subtract with carry (long,X) $FD0222.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx $1101.w		; EC 01 11 ; Compare $1101.w with X register [Reads: X Index] [Flags: NCZ]
	brk $98.b		; 00 98 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($FC.b)		; 12 FC ; OR accumulator with memory (indirect) ($FC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $00		; D0 00 ; Branch if not equal to $D0, $00 [Flow: branch]
	ora ($13.b,X)		; 01 13 ; Logical OR ($13.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $10, $EF		; 10 EF ; Branch if plus to $10, $EF [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $12		; 10 12 ; Branch if plus to $10, $12 [Flow: branch]
	inc $E1DF.w		; EE DF E1 ; Increment $E1DF.w [Flags: NZ]
	mvp $DF,$0F		; 44 0F DF ; Move block positive $DF,$0F [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ora ($F5.b),Y		; 11 F5 ; OR accumulator with memory ($F5.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($FC.b),Y		; 31 FC ; AND accumulator with memory ($FC.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	pea $FA73.w		; F4 73 FA ; Push absolute address $FA73.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	lda $401398.l,X		; BF 98 13 40 ; Load long $401398.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$4104]		; DC 04 41 ; Jump long indirect [$4104] [Flow: jump]
	sbc $2000.w,X		; FD 00 20 ; Subtract with carry $2000.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ldx $1031.w,Y		; BE 31 10 ; Load X register $1031.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	inc $D1DC.w,X		; FE DC D1 ; Increment memory $D1DC.w,X [Reads: X Index] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $D0, $88		; D0 88 ; Branch if not equal to $D0, $88 [Flow: branch]
	and ($00.b,X)		; 21 00 ; Logical AND ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $01CFDB.l		; 0F DB CF 01 ; OR accumulator with memory (long) $01CFDB.l [Writes: Accumulator] [Flags: NZ]
	eor $88CE.w		; 4D CE 88 ; Exclusive OR $88CE.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($45.b),Y		; 11 45 ; OR accumulator with memory ($45.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sep #$0F		; E2 0F ; Set processor status bits #$0F [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	and ($ED.b)		; 32 ED ; AND accumulator with memory (indirect) ($ED.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $98.b,S		; 03 98 ; OR accumulator with stack relative $98.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $F4DD1F.l		; 22 1F DD F4 ; Jump to subroutine long $F4DD1F.l [Writes: Stack Pointer] [Flow: call]
	and ($22.b,S),Y		; 33 22 ; AND accumulator (stack relative indirect indexed) ($22.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $88E1.w		; ED E1 88 ; Subtract $88E1.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	mvp $2E,$11		; 44 11 2E ; Move block positive $2E,$11 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	inc $FBF1.w		; EE F1 FB ; Increment $FBF1.w [Flags: NZ]
	sbc $C08412.l,X		; FF 12 84 C0 ; Subtract with carry (long,X) $C08412.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($ED.b)		; 32 ED ; AND accumulator with memory (indirect) ($ED.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx #$EF.b		; E0 EF ; Compare #$EF.b with X register [Reads: X Index] [Flags: NCZ]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $010088.l,X		; FF 88 00 01 ; Subtract with carry (long,X) $010088.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $2410.w,X		; FD 10 24 ; Subtract with carry $2410.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $F1DD.w		; 0C DD F1 ; Test and set bits $F1DD.w [Reads: Accumulator] [Flags: Z]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($22.b)		; 12 22 ; OR accumulator with memory (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $3213CD.l		; 0F CD 13 32 ; OR accumulator with memory (long) $3213CD.l [Writes: Accumulator] [Flags: NZ]
	sbc $88E0.w,X		; FD E0 88 ; Subtract with carry $88E0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $1F.b		; 45 1F ; Exclusive OR $1F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $2102.w,X		; DD 02 21 ; Compare accumulator $2102.w,X [Reads: X Index] [Flags: NCZ]
	.db $10, $F0		; 10 F0 ; Branch if plus to $10, $F0 [Flow: branch]
	and ($88.b,S),Y		; 33 88 ; AND accumulator (stack relative indirect indexed) ($88.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($E9.b,S),Y		; 33 E9 ; AND accumulator (stack relative indirect indexed) ($E9.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda ($65.b)		; B2 65 ; Load accumulator (indirect) ($65.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $02CE.w,X		; 1E CE 02 ; Arithmetic shift left $02CE.w,X [Reads: X Index] [Flags: NCZ]
	sbc $0288.w		; ED 88 02 ; Subtract $0288.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $CF		; 30 CF ; Branch if minus to $30, $CF [Flow: branch]
	ora ($1D.b),Y		; 11 1D ; OR accumulator with memory ($1D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda $88ED11.l,X		; BF 11 ED 88 ; Load long $88ED11.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $22		; F0 22 ; Branch if equal to $F0, $22 [Flow: branch]
	asl $02AD.w,X		; 1E AD 02 ; Arithmetic shift left $02AD.w,X [Reads: X Index] [Flags: NCZ]
	.db $10, $03		; 10 03 ; Branch if plus to $10, $03 [Flow: branch]
	ora $F2EC88.l,X		; 1F 88 EC F2 ; Logical OR long $F2EC88.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($11.b)		; 32 11 ; AND accumulator with memory (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $FD.b		; 24 FD ; Test bits $FD.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cpx #$03.b		; E0 03 ; Compare #$03.b with X register [Reads: X Index] [Flags: NCZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	eor ($FE.b),Y		; 51 FE ; Exclusive OR accumulator with memory ($FE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $34		; F0 34 ; Branch if equal to $F0, $34 [Flow: branch]
	and ($FD.b)		; 32 FD ; AND accumulator with memory (indirect) ($FD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $338812.l,X		; BF 12 88 33 ; Load long $338812.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $24D0.w		; 0E D0 24 ; Arithmetic shift left $24D0.w [Flags: NCZ]
	ora $02CE.w,X		; 1D CE 02 ; OR accumulator with memory $02CE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($88.b,X)		; 41 88 ; Exclusive OR accumulator with memory ($88.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	dec $3502.w		; CE 02 35 ; Decrement $3502.w [Flags: NZ]
	asl $CEDC.w		; 0E DC CE ; Arithmetic shift left $CEDC.w [Flags: NCZ]
	sbc ($88.b),Y		; F1 88 ; Subtract with carry ($88.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $20.b,X		; 34 20 ; Test bits $20.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	dec $10F2.w,X		; DE F2 10 ; Decrement memory $10F2.w,X [Reads: X Index] [Flags: NZ]
	cpx #$11.b		; E0 11 ; Compare #$11.b with X register [Reads: X Index] [Flags: NCZ]
	cmp $412388.l,X		; DF 88 23 41 ; Compare accumulator (long,X) $412388.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	inc $20E2.w,X		; FE E2 20 ; Increment memory $20E2.w,X [Reads: X Index] [Flags: NZ]
	cpx #$F0.b		; E0 F0 ; Compare #$F0.b with X register [Reads: X Index] [Flags: NCZ]
	ora ($78.b)		; 12 78 ; OR accumulator with memory (indirect) ($78.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $42.b,S		; 43 42 ; Exclusive OR accumulator with stack relative $42.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $11FE.w		; 0D FE 11 ; Logical OR $11FE.w with accumulator [Writes: Accumulator] [Flags: NZ]
	eor $3F.b,X		; 55 3F ; Exclusive OR accumulator with memory $3F.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $EE88.w,X		; FD 88 EE ; Subtract with carry $EE88.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $44		; F0 44 ; Branch if equal to $F0, $44 [Flow: branch]
	jsr $D0DC.w		; 20 DC D0 ; Jump to subroutine at $D0DC.w [Writes: Stack Pointer] [Flow: call]
	bit $30.b		; 24 30 ; Test bits $30.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cpx $01CE.w		; EC CE 01 ; Compare $01CE.w with X register [Reads: X Index] [Flags: NCZ]
	and ($0F.b,X)		; 21 0F ; Logical AND ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpx #$13.b		; E0 13 ; Compare #$13.b with X register [Reads: X Index] [Flags: NCZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $2200.w		; CD 00 22 ; Compare $2200.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	and ($0E.b),Y		; 31 0E ; AND accumulator with memory ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	inc $12FF.w		; EE FF 12 ; Increment $12FF.w [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	stz $FD.b,X		; 74 FD ; Store zero to $FD.b,X [Reads: X Index]
	.db $F0, $23		; F0 23 ; Branch if equal to $F0, $23 [Flow: branch]
	adc $FE.b		; 65 FE ; Add $FE.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inc $88E2.w		; EE E2 88 ; Increment $88E2.w [Flags: NZ]
	eor $31.b		; 45 31 ; Exclusive OR $31.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $0F01.w		; EE 01 0F ; Increment $0F01.w [Flags: NZ]
	sbc ($21.b),Y		; F1 21 ; Subtract with carry ($21.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($88.b)		; 12 88 ; OR accumulator with memory (indirect) ($88.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $21F1CC.l		; 2F CC F1 21 ; AND accumulator with memory (long) $21F1CC.l [Writes: Accumulator] [Flags: NZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$FE.b		; E0 FE ; Compare #$FE.b with X register [Reads: X Index] [Flags: NCZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ldx $4F22.w		; AE 22 4F ; Load $4F22.w into X register [Writes: X Index] [Flags: NZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	cpx #$01.b		; E0 01 ; Compare #$01.b with X register [Reads: X Index] [Flags: NCZ]
	ora ($0E.b,S),Y		; 13 0E ; OR accumulator (stack relative indirect indexed) ($0E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sbc $35E0.w		; ED E0 35 ; Subtract $35E0.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	eor ($FC.b),Y		; 51 FC ; Exclusive OR accumulator with memory ($FC.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ldy $4402.w,X		; BC 02 44 ; Load Y register $4402.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	eor $20.b,S		; 43 20 ; Exclusive OR accumulator with stack relative $20.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $03DEDD.l,X		; FF DD DE 03 ; Subtract with carry (long,X) $03DEDD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	mvp $98,$32		; 44 32 98 ; Move block positive $98,$32 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	asl $E0ED.w,X		; 1E ED E0 ; Arithmetic shift left $E0ED.w,X [Reads: X Index] [Flags: NCZ]
	bit $31.b,X		; 34 31 ; Test bits $31.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	inc $11E0.w		; EE E0 11 ; Increment $11E0.w [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sbc $12DF.w,X		; FD DF 12 ; Subtract with carry $12DF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $4E.b		; 45 4E ; Exclusive OR $4E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpy $FFDF.w		; CC DF FF ; Compare $FFDF.w with Y register [Reads: Y Index] [Flags: NCZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sbc ($00.b),Y		; F1 00 ; Subtract with carry ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($20.b)		; 12 20 ; OR accumulator with memory (indirect) ($20.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx $00DF.w		; EC DF 00 ; Compare $00DF.w with X register [Reads: X Index] [Flags: NCZ]
	sbc $74F278.l,X		; FF 78 F2 74 ; Subtract with carry (long,X) $74F278.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	cpy $43E0.w		; CC E0 43 ; Compare $43E0.w with Y register [Reads: Y Index] [Flags: NCZ]
	adc $3D.b		; 65 3D ; Add $3D.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	stz $6D.b,X		; 74 6D ; Store zero to $6D.b,X [Reads: X Index]
	ldy RDDIVL.w		; AC 14 42 ; Load RDDIVL.w into Y register [Writes: Y Index] [Flags: NZ]
	ora $425534.l		; 0F 34 55 42 ; OR accumulator with memory (long) $425534.l [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	bit $31.b		; 24 31 ; Test bits $31.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	ora $FF88EE.l		; 0F EE 88 FF ; OR accumulator with memory (long) $FF88EE.l [Writes: Accumulator] [Flags: NZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $10E0CC.l,X		; FF CC E0 10 ; Subtract with carry (long,X) $10E0CC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $E188.w,X		; FE 88 E1 ; Increment memory $E188.w,X [Reads: X Index] [Flags: NZ]
	and $2F.b,S		; 23 2F ; AND accumulator with stack relative $2F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	dec $12F1.w,X		; DE F1 12 ; Decrement memory $12F1.w,X [Reads: X Index] [Flags: NZ]
	.db $10, $78		; 10 78 ; Branch if plus to $10, $78 [Flow: branch]
	cmp $34E1.w,X		; DD E1 34 ; Compare accumulator $34E1.w,X [Reads: X Index] [Flags: NCZ]
	eor ($FF.b)		; 52 FF ; Exclusive OR accumulator with memory (indirect) ($FF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $11		; 10 11 ; Branch if plus to $10, $11 [Flow: branch]
	jsl $FC3278.l		; 22 78 32 FC ; Jump to subroutine long $FC3278.l [Writes: Stack Pointer] [Flow: call]
	cpx #$45.b		; E0 45 ; Compare #$45.b with X register [Reads: X Index] [Flags: NCZ]
	stz $3F.b		; 64 3F ; Store zero to $3F.b
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	ldy $F378.w,X		; BC 78 F3 ; Load Y register $F378.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	eor $4F.b,X		; 55 4F ; Exclusive OR accumulator with memory $4F.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cpy $1C12.w		; CC 12 1C ; Compare $1C12.w with Y register [Reads: Y Index] [Flags: NCZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	pea $5478.w		; F4 78 54 ; Push absolute address $5478.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	jsr ($44C1.w,X)		; FC C1 44 ; Jump to subroutine indirect indexed ($44C1.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora $20E0DB.l,X		; 1F DB E0 20 ; Logical OR long $20E0DB.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	and ($0F.b,X)		; 21 0F ; Logical AND ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpy $E0CB.w		; CC CB E0 ; Compare $E0CB.w with Y register [Reads: Y Index] [Flags: NCZ]
	bit $2F.b,X		; 34 2F ; Test bits $2F.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora ($78.b,S),Y		; 13 78 ; OR accumulator (stack relative indirect indexed) ($78.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $F0BCCD.l		; 2F CD BC F0 ; AND accumulator with memory (long) $F0BCCD.l [Writes: Accumulator] [Flags: NZ]
	ora ($46.b),Y		; 11 46 ; OR accumulator with memory ($46.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	mvn $88,$FA		; 54 FA 88 ; Move block negative $88,$FA [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cmp $222212.l		; CF 12 22 22 ; Compare accumulator (long) $222212.l [Reads: Accumulator] [Flags: NCZ]
	jsr $11EF.w		; 20 EF 11 ; Jump to subroutine at $11EF.w [Writes: Stack Pointer] [Flow: call]
	ora ($68.b),Y		; 11 68 ; OR accumulator with memory ($68.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc ($DE.b,X)		; 61 DE ; Add with carry ($DE.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	stz $20.b,X		; 74 20 ; Store zero to $20.b,X [Reads: X Index]
	ora $00DCCB.l,X		; 1F CB DC 00 ; Logical OR long $00DCCB.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora ($F2.b),Y		; 11 F2 ; OR accumulator with memory ($F2.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($10.b),Y		; 11 10 ; OR accumulator with memory ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	nop		; EA ; No operation
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	cmp $7813.w		; CD 13 78 ; Compare $7813.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	eor ($1D.b)		; 52 1D ; Exclusive OR accumulator with memory (indirect) ($1D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda #$01AC.w		; A9 AC 01 ; Load #$01AC.w into accumulator [Writes: Accumulator] [Flags: NZ]
	mvp $FA,$43		; 44 43 FA ; Move block positive $FA,$43 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dec $2001.w,X		; DE 01 20 ; Decrement memory $2001.w,X [Reads: X Index] [Flags: NZ]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $22.b,S		; 43 22 ; Exclusive OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $DC88.w,X		; FE 88 DC ; Increment memory $DC88.w,X [Reads: X Index] [Flags: NZ]
	cmp ($33.b)		; D2 33 ; Compare accumulator (indirect) ($33.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	jsl $F0FF10.l		; 22 10 FF F0 ; Jump to subroutine long $F0FF10.l [Writes: Stack Pointer] [Flow: call]
	ora ($78.b),Y		; 11 78 ; OR accumulator with memory ($78.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($10.b,S),Y		; 33 10 ; AND accumulator (stack relative indirect indexed) ($10.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $BDDC.w		; ED DC BD ; Subtract $BDDC.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($78.b,X)		; E1 78 ; Subtract with carry ($78.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($F0.b,X)		; 01 F0 ; Logical OR ($F0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $F0, $02		; F0 02 ; Branch if equal to $F0, $02 [Flow: branch]
	asl $D0DE.w		; 0E DE D0 ; Arithmetic shift left $D0DE.w [Flags: NCZ]
	bit $78.b		; 24 78 ; Test bits $78.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	and ($EC.b,S),Y		; 33 EC ; AND accumulator (stack relative indirect indexed) ($EC.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $3104.w,X		; BD 04 31 ; Load $3104.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $22		; F0 22 ; Branch if equal to $F0, $22 [Flow: branch]
	ora $ADCA78.l,X		; 1F 78 CA AD ; Logical OR long $ADCA78.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	trb $62.b		; 14 62 ; Test and reset bits $62.b [Reads: Accumulator] [Flags: Z]
	asl $11FE.w		; 0E FE 11 ; Arithmetic shift left $11FE.w [Flags: NCZ]
	ora ($68.b)		; 12 68 ; OR accumulator with memory (indirect) ($68.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $53.b,S		; 23 53 ; AND accumulator with stack relative $53.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $6402E1.l		; EF E1 02 64 ; Subtract with carry (long) $6402E1.l [Writes: Accumulator] [Flags: NCVZ]
	eor $32.b,S		; 43 32 ; Exclusive OR accumulator with stack relative $32.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora ($12.b)		; 12 12 ; OR accumulator with memory (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$35B0]		; DC B0 35 ; Jump long indirect [$35B0] [Flow: jump]
	.db $42, $1F		; 42 1F ; Reserved instruction
	jsr ($DE78.w,X)		; FC 78 DE ; Jump to subroutine indirect indexed ($DE78.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $BCDD.w,X		; FD DD BC ; Subtract with carry $BCDD.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($46.b,X)		; E1 46 ; Subtract with carry ($46.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $42, $EC		; 42 EC ; Reserved instruction
	sty $30.b		; 84 30 ; Store Y register to $30.b [Reads: Y Index]
	sbc $23E0.w		; ED E0 23 ; Subtract $23E0.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	and ($FE.b),Y		; 31 FE ; AND accumulator with memory ($FE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $227802.l		; EF 02 78 22 ; Subtract with carry (long) $227802.l [Writes: Accumulator] [Flags: NCVZ]
	inc $33E0.w		; EE E0 33 ; Increment $33E0.w [Flags: NZ]
	and ($0D.b),Y		; 31 0D ; AND accumulator with memory ($0D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $238814.l,X		; DF 14 88 23 ; Compare accumulator (long,X) $238814.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	bit $31.b,X		; 34 31 ; Test bits $31.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sbc $F0DC.w,X		; FD DC F0 ; Subtract with carry $F0DC.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($22.b)		; 32 22 ; AND accumulator with memory (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	rol $CCDC.w		; 2E DC CC ; Rotate left $CCDC.w [Flags: NCZ]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	inc $F1BC.w,X		; FE BC F1 ; Increment memory $F1BC.w,X [Reads: X Index] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	stz $0A.b		; 64 0A ; Store zero to $0A.b
	jmp.w [$1E00]		; DC 00 1E ; Jump long indirect [$1E00] [Flow: jump]
	ldy $76D2.w,X		; BC D2 76 ; Load Y register $76D2.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $30, $CC		; 30 CC ; Branch if minus to $30, $CC [Flow: branch]
	cpx #$24.b		; E0 24 ; Compare #$24.b with X register [Reads: X Index] [Flags: NCZ]
	and ($0E.b)		; 32 0E ; AND accumulator with memory (indirect) ($0E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpy $78CF.w		; CC CF 78 ; Compare $78CF.w with Y register [Reads: Y Index] [Flags: NCZ]
	and $44.b,X		; 35 44 ; Logical AND $44.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $11EEDE.l,X		; 1F DE EE 11 ; Logical OR long $11EEDE.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	cpx #$0F.b		; E0 0F ; Compare #$0F.b with X register [Reads: X Index] [Flags: NCZ]
	sbc ($26.b,X)		; E1 26 ; Subtract with carry ($26.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	mvp $E3,$FD		; 44 FD E3 ; Move block positive $E3,$FD [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	and ($58.b,S),Y		; 33 58 ; AND accumulator (stack relative indirect indexed) ($58.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $4E2F.w,X		; 3D 2F 4E ; AND accumulator with memory $4E2F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $4DFE0C.l		; 4F 0C FE 4D ; Exclusive OR accumulator with memory (long) $4DFE0C.l [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora $0F0FFF.l		; 0F FF 0F 0F ; OR accumulator with memory (long) $0F0FFF.l [Writes: Accumulator] [Flags: NZ]
	sbc $FFCC.w,X		; FD CC FF ; Subtract with carry $FFCC.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($68.b,X)		; 01 68 ; Logical OR ($68.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $10, $EF		; 10 EF ; Branch if plus to $10, $EF [Flow: branch]
	sbc $13CEDC.l,X		; FF DC CE 13 ; Subtract with carry (long,X) $13CEDC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $23.b		; 24 23 ; Test bits $23.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	ora $634301.l,X		; 1F 01 43 63 ; Logical OR long $634301.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $02		; F0 02 ; Branch if equal to $F0, $02 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	and ($54.b,S),Y		; 33 54 ; AND accumulator (stack relative indirect indexed) ($54.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr $03EF.w		; 20 EF 03 ; Jump to subroutine at $03EF.w [Writes: Stack Pointer] [Flow: call]
	bit $1F.b,X		; 34 1F ; Test bits $1F.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	jmp.w [$C078]		; DC 78 C0 ; Jump long indirect [$C078] [Flow: jump]
	ora ($0F.b)		; 12 0F ; OR accumulator with memory (indirect) ($0F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dec $12E0.w,X		; DE E0 12 ; Decrement memory $12E0.w,X [Reads: X Index] [Flags: NZ]
	inc $78BA.w,X		; FE BA 78 ; Increment memory $78BA.w,X [Reads: X Index] [Flags: NZ]
	ldx $2402.w,Y		; BE 02 24 ; Load X register $2402.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	and ($FE.b,X)		; 21 FE ; Logical AND ($FE.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $EEEC.w		; ED EC EE ; Subtract $EEEC.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora ($45.b),Y		; 11 45 ; OR accumulator with memory ($45.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor ($10.b)		; 52 10 ; Exclusive OR accumulator with memory (indirect) ($10.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $33E0.w,X		; FD E0 33 ; Subtract with carry $33E0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr $0168.w		; 20 68 01 ; Jump to subroutine at $0168.w [Writes: Stack Pointer] [Flow: call]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $3531FF.l		; EF FF 31 35 ; Subtract with carry (long) $3531FF.l [Writes: Accumulator] [Flags: NCVZ]
	eor ($78.b),Y		; 51 78 ; Exclusive OR accumulator with memory ($78.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $F1DE.w		; 0E DE F1 ; Arithmetic shift left $F1DE.w [Flags: NCZ]
	lsr $51.b		; 46 51 ; Logical shift right $51.b [Reads: Direct Page] [Flags: NCZ]
	ora $C0DB.w,X		; 1D DB C0 ; OR accumulator with memory $C0DB.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	mvp $EE,$10		; 44 10 EE ; Move block positive $EE,$10 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sbc ($12.b),Y		; F1 12 ; Subtract with carry ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $0E		; 10 0E ; Branch if plus to $10, $0E [Flow: branch]
	cmp $EF0268.l,X		; DF 68 02 EF ; Compare accumulator (long,X) $EF0268.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	cpx $C0BD.w		; EC BD C0 ; Compare $C0BD.w with X register [Reads: X Index] [Flags: NCZ]
	.db $62, $1C, $BA		; 62 1C BA ; Push effective relative address $62, $1C, $BA [Writes: Stack Pointer]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $F0, $11		; F0 11 ; Branch if equal to $F0, $11 [Flow: branch]
	inc $12C0.w,X		; FE C0 12 ; Increment memory $12C0.w,X [Reads: X Index] [Flags: NZ]
	ora ($13.b,S),Y		; 13 13 ; OR accumulator (stack relative indirect indexed) ($13.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $78		; F0 78 ; Branch if equal to $F0, $78 [Flow: branch]
	inc $01F0.w		; EE F0 01 ; Increment $01F0.w [Flags: NZ]
	bit $44.b		; 24 44 ; Test bits $44.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora ($10.b)		; 12 10 ; OR accumulator with memory (indirect) ($10.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $523368.l,X		; FF 68 33 52 ; Subtract with carry (long,X) $523368.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $23.b		; 24 23 ; Test bits $23.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cop $D0.b		; 02 D0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($FE.b,X)		; 01 FE ; Logical OR ($FE.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $D0, $02		; D0 02 ; Branch if not equal to $D0, $02 [Flow: branch]
	and $FE.b,S		; 23 FE ; AND accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $EDCE.w		; CD CE ED ; Compare $EDCE.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cpx #$68.b		; E0 68 ; Compare #$68.b with X register [Reads: X Index] [Flags: NCZ]
	ora $DEAEDC.l,X		; 1F DC AE DE ; Logical OR long $DEAEDC.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($02.b),Y		; F1 02 ; Subtract with carry ($02.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($1E.b),Y		; 11 1E ; OR accumulator with memory ($1E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	asl $12FF.w		; 0E FF 12 ; Arithmetic shift left $12FF.w [Flags: NCZ]
	and ($00.b),Y		; 31 00 ; AND accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $781F43.l		; 22 43 1F 78 ; Jump to subroutine long $781F43.l [Writes: Stack Pointer] [Flow: call]
	inc $12E0.w		; EE E0 12 ; Increment $12E0.w [Flags: NZ]
	jsl $1E1221.l		; 22 21 12 1E ; Jump to subroutine long $1E1221.l [Writes: Stack Pointer] [Flow: call]
	cpy $DF78.w		; CC 78 DF ; Compare $DF78.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora $55.b,S		; 03 55 ; OR accumulator with stack relative $55.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	ora $F0ED.w		; 0D ED F0 ; Logical OR $F0ED.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and ($78.b,X)		; 21 78 ; Logical AND ($78.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $02DF.w,X		; FD DF 02 ; Subtract with carry $02DF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $20.b,X		; 34 20 ; Test bits $20.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	inc $EEFE.w		; EE FE EE ; Increment $EEFE.w [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sbc ($0F.b),Y		; F1 0F ; Subtract with carry ($0F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $02BE.w,X		; DE BE 02 ; Decrement memory $02BE.w,X [Reads: X Index] [Flags: NZ]
	eor $2F.b,S		; 43 2F ; Exclusive OR accumulator with stack relative $2F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $BB68.w		; ED 68 BB ; Subtract $BB68.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	dec $4F33.w,X		; DE 33 4F ; Decrement memory $4F33.w,X [Reads: X Index] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $35		; D0 35 ; Branch if not equal to $D0, $35 [Flow: branch]
	adc $68.b		; 65 68 ; Add $68.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $62, $40, $2C		; 62 40 2C ; Push effective relative address $62, $40, $2C [Writes: Stack Pointer]
	jmp.w [$65F4]		; DC F4 65 ; Jump long indirect [$65F4] [Flow: jump]
	and ($12.b,X)		; 21 12 ; Logical AND ($12.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	and $12.b,S		; 23 12 ; AND accumulator with stack relative $12.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $30.b,X		; 35 30 ; Logical AND $30.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $FEDE.w,X		; FD DE FE ; Subtract with carry $FEDE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $78.b,S		; 03 78 ; OR accumulator with stack relative $78.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $DEDB1F.l		; 22 1F DB DE ; Jump to subroutine long $DEDB1F.l [Writes: Stack Pointer] [Flow: call]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	inc $68DD.w,X		; FE DD 68 ; Increment memory $68DD.w,X [Reads: X Index] [Flags: NZ]
	.db $B0, $00		; B0 00 ; Branch if carry set to $B0, $00 [Flow: branch]
	inc $BDBB.w		; EE BB BD ; Increment $BDBB.w [Flags: NZ]
	.db $F0, $21		; F0 21 ; Branch if equal to $F0, $21 [Flow: branch]
	eor $68.b,S		; 43 68 ; Exclusive OR accumulator with stack relative $68.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $121001.l		; 2F 01 10 12 ; AND accumulator with memory (long) $121001.l [Writes: Accumulator] [Flags: NZ]
	jsl $523311.l		; 22 11 33 52 ; Jump to subroutine long $523311.l [Writes: Stack Pointer] [Flow: call]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora ($13.b)		; 12 13 ; OR accumulator with memory (indirect) ($13.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $11.b		; 24 11 ; Test bits $11.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	inc $F1CD.w,X		; FE CD F1 ; Increment memory $F1CD.w,X [Reads: X Index] [Flags: NZ]
	and $78.b,S		; 23 78 ; AND accumulator with stack relative $78.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $0E.b,S		; 43 0E ; Exclusive OR accumulator with stack relative $0E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $0FDE.w		; EE DE 0F ; Increment $0FDE.w [Flags: NZ]
	ora ($10.b),Y		; 11 10 ; OR accumulator with memory ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($58.b),Y		; 11 58 ; OR accumulator with memory ($58.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc #$FDEB.w		; E9 EB FD ; Subtract #$FDEB.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $2F		; 10 2F ; Branch if plus to $10, $2F [Flow: branch]
	sbc $1EFD.w,X		; FD FD 1E ; Subtract with carry $1EFD.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	inc $02DE.w,X		; FE DE 02 ; Increment memory $02DE.w,X [Reads: X Index] [Flags: NZ]
	mvp $BB,$1F		; 44 1F BB ; Move block positive $BB,$1F [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	lda $68D0.w,X		; BD D0 68 ; Load $68D0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $44.b		; 25 44 ; Logical AND $44.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $10, $01		; 10 01 ; Branch if plus to $10, $01 [Flow: branch]
	ora $682211.l		; 0F 11 22 68 ; OR accumulator with memory (long) $682211.l [Writes: Accumulator] [Flags: NZ]
	eor ($42.b)		; 52 42 ; Exclusive OR accumulator with memory (indirect) ($42.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $0402.w		; 20 02 04 ; Jump to subroutine at $0402.w [Writes: Stack Pointer] [Flow: call]
	and [$55.b],Y		; 37 55 ; AND accumulator with memory (long indexed) [$55.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor ($58.b,X)		; 41 58 ; Exclusive OR accumulator with memory ($58.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cpx $E2F0.w		; EC F0 E2 ; Compare $E2F0.w with X register [Reads: X Index] [Flags: NCZ]
	sbc ($13.b,X)		; E1 13 ; Subtract with carry ($13.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($FE.b,X)		; 01 FE ; Logical OR ($FE.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	inc $01EF.w		; EE EF 01 ; Increment $01EF.w [Flags: NZ]
	and ($31.b,X)		; 21 31 ; Logical AND ($31.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $CDDC.w,X		; FD DC CD ; Subtract with carry $CDDC.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	dec $11F0.w		; CE F0 11 ; Decrement $11F0.w [Flags: NZ]
	asl $DFDD.w,X		; 1E DD DF ; Arithmetic shift left $DFDD.w,X [Reads: X Index] [Flags: NCZ]
	ora ($41.b),Y		; 11 41 ; OR accumulator with memory ($41.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	and $102211.l		; 2F 11 22 10 ; AND accumulator with memory (long) $102211.l [Writes: Accumulator] [Flags: NZ]
	ora $646521.l		; 0F 21 65 64 ; OR accumulator with memory (long) $646521.l [Writes: Accumulator] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	mvp $04,$EE		; 44 EE 04 ; Move block positive $04,$EE [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ror $66.b		; 66 66 ; Rotate right $66.b [Reads: Direct Page] [Flags: NCZ]
	mvn $1D,$44		; 54 44 1D ; Move block negative $1D,$44 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	ldx $4515.w		; AE 15 45 ; Load $4515.w into X register [Writes: X Index] [Flags: NZ]
	.db $30, $BA		; 30 BA ; Branch if minus to $30, $BA [Flow: branch]
	ldy $58DE.w,X		; BC DE 58 ; Load Y register $58DE.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	inc $E2C2.w		; EE C2 E2 ; Increment $E2C2.w [Flags: NZ]
	eor ($1D.b,X)		; 41 1D ; Exclusive OR accumulator with memory ($1D.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$1BEA.w		; C9 EA 1B ; Compare #$1BEA.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	cmp $6013.w,X		; DD 13 60 ; Compare accumulator $6013.w,X [Reads: X Index] [Flags: NCZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	stz $EFDF.w		; 9C DF EF ; Store zero to $EFDF.w
	inc $0F58.w		; EE 58 0F ; Increment $0F58.w [Flags: NZ]
	and ($21.b,X)		; 21 21 ; Logical AND ($21.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jmp $00FC4C.l		; 5C 4C FC 00 ; Jump long to $00FC4C.l [Flow: jump]
	mvn $13,$78		; 54 78 13 ; Move block negative $13,$78 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	jsr $11F0.w		; 20 F0 11 ; Jump to subroutine at $11F0.w [Writes: Stack Pointer] [Flow: call]
	ora ($34.b)		; 12 34 ; OR accumulator with memory (indirect) ($34.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($0F.b),Y		; 31 0F ; AND accumulator with memory ($0F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	cmp $2101.w,X		; DD 01 21 ; Compare accumulator $2101.w,X [Reads: X Index] [Flags: NCZ]
	jsl $FDFF20.l		; 22 20 FF FD ; Jump to subroutine long $FDFF20.l [Writes: Stack Pointer] [Flow: call]
	cpx $FE78.w		; EC 78 FE ; Compare $FE78.w with X register [Reads: X Index] [Flags: NCZ]
	inc $10F0.w		; EE F0 10 ; Increment $10F0.w [Flags: NZ]
	asl $FEDC.w,X		; 1E DC FE ; Arithmetic shift left $FEDC.w,X [Reads: X Index] [Flags: NCZ]
	.db $F0, $68		; F0 68 ; Branch if equal to $F0, $68 [Flow: branch]
	and ($FF.b,S),Y		; 33 FF ; AND accumulator (stack relative indirect indexed) ($FF.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpy $CDAC.w		; CC AC CD ; Compare $CDAC.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora ($33.b),Y		; 11 33 ; OR accumulator with memory ($33.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor ($68.b)		; 52 68 ; Exclusive OR accumulator with memory (indirect) ($68.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	sbc $4613F0.l		; EF F0 13 46 ; Subtract with carry (long) $4613F0.l [Writes: Accumulator] [Flags: NCVZ]
	adc $54.b		; 65 54 ; Add $54.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	and ($00.b)		; 32 00 ; AND accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $56F1.w		; EE F1 56 ; Increment $56F1.w [Flags: NZ]
	and ($0F.b)		; 32 0F ; AND accumulator with memory (indirect) ($0F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$EF78]		; DC 78 EF ; Jump long indirect [$EF78] [Flow: jump]
	.db $F0, $12		; F0 12 ; Branch if equal to $F0, $12 [Flow: branch]
	ora ($0E.b)		; 12 0E ; OR accumulator with memory (indirect) ($0E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$FFDE]		; DC DE FF ; Jump long indirect [$FFDE] [Flow: jump]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	and ($22.b,X)		; 21 22 ; Logical AND ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $EFECED.l,X		; 1F ED EC EF ; Logical OR long $EFECED.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($21.b,X)		; 21 21 ; Logical AND ($21.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	asl $EEFE.w,X		; 1E FE EE ; Arithmetic shift left $EEFE.w,X [Reads: X Index] [Flags: NCZ]
	cmp $34F1EE.l,X		; DF EE F1 34 ; Compare accumulator (long,X) $34F1EE.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	eor $68.b,S		; 43 68 ; Exclusive OR accumulator with stack relative $68.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	dec $7624.w,X		; DE 24 76 ; Decrement memory $7624.w,X [Reads: X Index] [Flags: NZ]
	.db $42, $2E		; 42 2E ; Reserved instruction
	.db $F0, $68		; F0 68 ; Branch if equal to $F0, $68 [Flow: branch]
	.db $F0, $13		; F0 13 ; Branch if equal to $F0, $13 [Flow: branch]
	jsr $0312.w		; 20 12 03 ; Jump to subroutine at $0312.w [Writes: Stack Pointer] [Flow: call]
	ora $44.b,X		; 15 44 ; OR accumulator with memory $44.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $1F4168.l		; 22 68 41 1F ; Jump to subroutine long $1F4168.l [Writes: Stack Pointer] [Flow: call]
	.db $F0, $DF		; F0 DF ; Branch if equal to $F0, $DF [Flow: branch]
	.db $F0, $10		; F0 10 ; Branch if equal to $F0, $10 [Flow: branch]
	ora ($0F.b),Y		; 11 0F ; OR accumulator with memory ($0F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	cpx $EFCD.w		; EC CD EF ; Compare $EFCD.w with X register [Reads: X Index] [Flags: NCZ]
	sbc $EFED.w		; ED ED EF ; Subtract $EFED.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sbc $AA58EE.l,X		; FF EE 58 AA ; Subtract with carry (long,X) $AA58EE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $EEE0.w,X		; BD E0 EE ; Load $EEE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dec $3322.w,X		; DE 22 33 ; Decrement memory $3322.w,X [Reads: X Index] [Flags: NZ]
	ora $330168.l		; 0F 68 01 33 ; OR accumulator with memory (long) $330168.l [Writes: Accumulator] [Flags: NZ]
	and ($0E.b)		; 32 0E ; AND accumulator with memory (indirect) ($0E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $645703.l,X		; FF 03 57 64 ; Subtract with carry (long,X) $645703.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	jsl $213425.l		; 22 25 34 21 ; Jump to subroutine long $213425.l [Writes: Stack Pointer] [Flow: call]
	asl $20FE.w		; 0E FE 20 ; Arithmetic shift left $20FE.w [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	sbc $DDBCDD.l,X		; FF DD BC DD ; Subtract with carry (long,X) $DDBCDD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sbc $DDDD.w		; ED DD DD ; Subtract $DDDD.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cmp $0101F1.l,X		; DF F1 01 01 ; Compare accumulator (long,X) $0101F1.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	.db $F0, $58		; F0 58 ; Branch if equal to $F0, $58 [Flow: branch]
	sbc $33.b,S		; E3 33 ; Subtract stack-relative $33.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	ora $32DFEE.l		; 0F EE DF 32 ; OR accumulator with memory (long) $32DFEE.l [Writes: Accumulator] [Flags: NZ]
	.db $42, $3D		; 42 3D ; Reserved instruction
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sbc $01E0.w		; ED E0 01 ; Subtract $01E0.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	and ($13.b,S),Y		; 33 13 ; AND accumulator (stack relative indirect indexed) ($13.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b)		; 12 00 ; OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $0F68.w		; 0C 68 0F ; Test and set bits $0F68.w [Reads: Accumulator] [Flags: Z]
	ora ($43.b)		; 12 43 ; OR accumulator with memory (indirect) ($43.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $30, $32		; 30 32 ; Branch if minus to $30, $32 [Flow: branch]
	and ($21.b,X)		; 21 21 ; Logical AND ($21.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($68.b,X)		; 01 68 ; Logical OR ($68.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($34.b)		; 12 34 ; OR accumulator with memory (indirect) ($34.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($EE.b),Y		; 11 EE ; OR accumulator with memory ($EE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda $32E1.w,X		; BD E1 32 ; Load $32E1.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $68		; 10 68 ; Branch if plus to $10, $68 [Flow: branch]
	jsr ($EECB.w,X)		; FC CB EE ; Jump to subroutine indirect indexed ($EECB.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora $EFEEFF.l		; 0F FF EE EF ; OR accumulator with memory (long) $EFEEFF.l [Writes: Accumulator] [Flags: NZ]
	jmp.w [$BC68]		; DC 68 BC ; Jump long indirect [$BC68] [Flow: jump]
	dec $12F1.w		; CE F1 12 ; Decrement $12F1.w [Flags: NZ]
	and ($0F.b,X)		; 21 0F ; Logical AND ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $0168E0.l		; EF E0 68 01 ; Subtract with carry (long) $0168E0.l [Writes: Accumulator] [Flags: NCVZ]
	bit $43.b		; 24 43 ; Test bits $43.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	jsl $123121.l		; 22 21 31 12 ; Jump to subroutine long $123121.l [Writes: Stack Pointer] [Flow: call]
	ora ($68.b),Y		; 11 68 ; OR accumulator with memory ($68.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $030222.l		; 22 22 02 03 ; Jump to subroutine long $030222.l [Writes: Stack Pointer] [Flow: call]
	bit $23.b		; 24 23 ; Test bits $23.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora ($F1.b)		; 12 F1 ; OR accumulator with memory (indirect) ($F1.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	sbc ($BF.b)		; F2 BF ; Subtract with carry (indirect) ($BF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp $9D9B.w		; CD 9B 9D ; Compare $9D9B.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $0F		; B0 0F ; Branch if carry set to $B0, $0F [Flow: branch]
	asl $DC68.w,X		; 1E 68 DC ; Arithmetic shift left $DC68.w,X [Reads: X Index] [Flags: NCZ]
	cmp $E0DC.w		; CD DC E0 ; Compare $E0DC.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora $DEEE0F.l,X		; 1F 0F EE DE ; Logical OR long $DEEE0F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	asl $02EE.w		; 0E EE 02 ; Arithmetic shift left $02EE.w [Flags: NCZ]
	mvn $30,$42		; 54 42 30 ; Move block negative $30,$42 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $580D.w		; 0D 0D 58 ; Logical OR $580D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	pea $6346.w		; F4 46 63 ; Push absolute address $6346.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	adc $16F20F.l		; 6F 0F F2 16 ; Add with carry (long) $16F20F.l [Writes: Accumulator] [Flags: NCVZ]
	eor ($58.b)		; 52 58 ; Exclusive OR accumulator with memory (indirect) ($58.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	cmp $7524.w,X		; DD 24 75 ; Compare accumulator $7524.w,X [Reads: X Index] [Flags: NCZ]
	adc $25.b		; 65 25 ; Add $25.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	trb $68.b		; 14 68 ; Test and reset bits $68.b [Reads: Accumulator] [Flags: Z]
	.db $F0, $D0		; F0 D0 ; Branch if equal to $F0, $D0 [Flow: branch]
	cmp ($02.b,X)		; C1 02 ; Compare accumulator ($02.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	and ($20.b)		; 32 20 ; AND accumulator with memory (indirect) ($20.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $0F68F0.l,X		; FF F0 68 0F ; Subtract with carry (long,X) $0F68F0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($EF.b),Y		; F1 EF ; Subtract with carry ($EF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $CFCC.w		; CD CC CF ; Compare $CFCC.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	sbc $DB58FF.l		; EF FF 58 DB ; Subtract with carry (long) $DB58FF.l [Writes: Accumulator] [Flags: NCVZ]
	sbc $BCAFC3.l		; EF C3 AF BC ; Subtract with carry (long) $BCAFC3.l [Writes: Accumulator] [Flags: NCVZ]
	sbc $686334.l		; EF 34 63 68 ; Subtract with carry (long) $686334.l [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $F0		; 10 F0 ; Branch if plus to $10, $F0 [Flow: branch]
	cop $12.b		; 02 12 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $224423.l		; 22 23 44 22 ; Jump to subroutine long $224423.l [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($32.b)		; 32 32 ; AND accumulator with memory (indirect) ($32.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $12F0.w		; 20 F0 12 ; Jump to subroutine at $12F0.w [Writes: Stack Pointer] [Flow: call]
	ora ($68.b),Y		; 11 68 ; OR accumulator with memory ($68.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $1F11FF.l,X		; FF FF 11 1F ; Subtract with carry (long,X) $1F11FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $ECBAEB.l		; 0F EB BA EC ; OR accumulator with memory (long) $ECBAEB.l [Writes: Accumulator] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	inc $0B3E.w,X		; FE 3E 0B ; Increment memory $0B3E.w,X [Reads: X Index] [Flags: NZ]
	cpx $CDDB.w		; EC DB CD ; Compare $CDDB.w with X register [Reads: X Index] [Flags: NCZ]
	lda $0168E3.l,X		; BF E3 68 01 ; Load long $0168E3.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $F20010.l,X		; FF 10 00 F2 ; Subtract with carry (long,X) $F20010.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($58.b,S),Y		; 13 58 ; OR accumulator (stack relative indirect indexed) ($58.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $31.b,X		; 34 31 ; Test bits $31.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and ($01.b)		; 32 01 ; AND accumulator with memory (indirect) ($01.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $26.b,S		; 03 26 ; OR accumulator with stack relative $26.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $DD.b,S		; 43 DD ; Exclusive OR accumulator with stack relative $DD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	lda ($F5.b),Y		; B1 F5 ; Load accumulator ($F5.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $41.b		; 14 41 ; Test and reset bits $41.b [Reads: Accumulator] [Flags: Z]
	.db $50, $20		; 50 20 ; Branch if overflow clear to $50, $20 [Flow: branch]
	ora $DD58FC.l,X		; 1F FC 58 DD ; Logical OR long $DD58FC.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cop $23.b		; 02 23 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $ED0B.w		; 2E 0B ED ; Rotate left $ED0B.w [Flags: NCZ]
	ora $125830.l		; 0F 30 58 12 ; OR accumulator with memory (long) $125830.l [Writes: Accumulator] [Flags: NZ]
	sbc $D0BCCD.l		; EF CD BC D0 ; Subtract with carry (long) $D0BCCD.l [Writes: Accumulator] [Flags: NCVZ]
	ora $58DEED.l		; 0F ED DE 58 ; OR accumulator with memory (long) $58DEED.l [Writes: Accumulator] [Flags: NZ]
	sbc $DACC0F.l,X		; FF 0F CC DA ; Subtract with carry (long,X) $DACC0F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	lda $6866F6.l		; AF F6 66 68 ; Load long $6866F6.l into accumulator [Writes: Accumulator] [Flags: NZ]
	and ($01.b)		; 32 01 ; AND accumulator with memory (indirect) ($01.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	bit $22.b		; 24 22 ; Test bits $22.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	and $44.b,S		; 23 44 ; AND accumulator with stack relative $44.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $10, $FF		; 10 FF ; Branch if plus to $10, $FF [Flow: branch]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($11.b)		; 32 11 ; AND accumulator with memory (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	inc $9CCC.w		; EE CC 9C ; Increment $9CCC.w [Flags: NZ]
	lda $68FDEE.l,X		; BF EE FD 68 ; Load long $68FDEE.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $CDDFFF.l		; 0F FF DF CD ; OR accumulator with memory (long) $CDDFFF.l [Writes: Accumulator] [Flags: NZ]
	dec $C0CE.w,X		; DE CE C0 ; Decrement memory $C0CE.w,X [Reads: X Index] [Flags: NZ]
	sbc $13C058.l,X		; FF 58 C0 13 ; Subtract with carry (long,X) $13C058.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $12.b		; 04 12 ; Test and set bits $12.b [Reads: Accumulator] [Flags: Z]
	ora ($20.b)		; 12 20 ; OR accumulator with memory (indirect) ($20.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $216823.l		; 22 23 68 21 ; Jump to subroutine long $216823.l [Writes: Stack Pointer] [Flow: call]
	cop $12.b		; 02 12 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $33.b,X		; 34 33 ; Test bits $33.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora ($F0.b),Y		; 11 F0 ; OR accumulator with memory ($F0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	inc $0158.w,X		; FE 58 01 ; Increment memory $0158.w,X [Reads: X Index] [Flags: NZ]
	and ($51.b)		; 32 51 ; AND accumulator with memory (indirect) ($51.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($0D.b)		; 32 0D ; AND accumulator with memory (indirect) ($0D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	nop		; EA ; No operation
	cmp $48FF.w		; CD FF 48 ; Compare $48FF.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	and $63.b,S		; 23 63 ; AND accumulator with stack relative $63.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	inc $1FE1.w		; EE E1 1F ; Increment $1FE1.w [Flags: NZ]
	sbc $58BC.w,X		; FD BC 58 ; Subtract with carry $58BC.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $EFEF.w		; ED EF EF ; Subtract $EFEF.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	asl $EC1F.w		; 0E 1F EC ; Arithmetic shift left $EC1F.w [Flags: NCZ]
	jmp.w [$58DD]		; DC DD 58 ; Jump long indirect [$58DD] [Flow: jump]
	sbc $DDFD.w,X		; FD FD DD ; Subtract with carry $DDFD.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $E20606.l,X		; FF 06 06 E2 ; Subtract with carry (long,X) $E20606.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	cmp $332402.l,X		; DF 02 24 33 ; Compare accumulator (long,X) $332402.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	and ($01.b,X)		; 21 01 ; Logical AND ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and ($11.b,X)		; 21 11 ; Logical AND ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	eor ($32.b),Y		; 51 32 ; Exclusive OR accumulator with memory ($32.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $203343.l		; 22 43 33 20 ; Jump to subroutine long $203343.l [Writes: Stack Pointer] [Flow: call]
	ora ($14.b,X)		; 01 14 ; Logical OR ($14.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	ora ($0E.b,X)		; 01 0E ; Logical OR ($0E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	cmp $3EFE.w,X		; DD FE 3E ; Compare accumulator $3EFE.w,X [Reads: X Index] [Flags: NCZ]
	eor $0D68.w		; 4D 68 0D ; Exclusive OR $0D68.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cpx $FFEC.w		; EC EC FF ; Compare $FFEC.w with X register [Reads: X Index] [Flags: NCZ]
	ora $FD0E0D.l,X		; 1F 0D 0E FD ; Logical OR long $FD0E0D.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	nop		; EA ; No operation
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	inc $2401.w		; EE 01 24 ; Increment $2401.w [Flags: NZ]
	adc $53.b,S		; 63 53 ; Add with carry (stack relative) $53.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	asl $FF68.w,X		; 1E 68 FF ; Arithmetic shift left $FF68.w,X [Reads: X Index] [Flags: NCZ]
	ora ($34.b,X)		; 01 34 ; Logical OR ($34.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor ($32.b,S),Y		; 53 32 ; XOR accumulator (stack relative indirect indexed) ($32.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $58EF01.l		; 22 01 EF 58 ; Jump to subroutine long $58EF01.l [Writes: Stack Pointer] [Flow: call]
	pei ($67.b)		; D4 67 ; Push effective indirect address ($67.b) [Reads: Direct Page] [Writes: Stack Pointer]
	stz $3F.b		; 64 3F ; Store zero to $3F.b
	cpy $F1BE.w		; CC BE F1 ; Compare $F1BE.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora ($68.b)		; 12 68 ; OR accumulator with memory (indirect) ($68.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $0E		; 10 0E ; Branch if plus to $10, $0E [Flow: branch]
	cmp $EFCE.w,X		; DD CE EF ; Compare accumulator $EFCE.w,X [Reads: X Index] [Flags: NCZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $58		; 10 58 ; Branch if plus to $10, $58 [Flow: branch]
	cmp $00FF.w		; CD FF 00 ; Compare $00FF.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	sbc ($1E.b),Y		; F1 1E ; Subtract with carry ($1E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $FE1E.w,X		; FE 1E FE ; Increment memory $FE1E.w,X [Reads: X Index] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	cmp $F0BF.w,X		; DD BF F0 ; Compare accumulator $F0BF.w,X [Reads: X Index] [Flags: NCZ]
	jsr $3D60.w		; 20 60 3D ; Jump to subroutine at $3D60.w [Writes: Stack Pointer] [Flow: call]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cmp ($58.b)		; D2 58 ; Compare accumulator (indirect) ($58.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora ($32.b)		; 12 32 ; OR accumulator with memory (indirect) ($32.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $30, $1F		; 30 1F ; Branch if minus to $30, $1F [Flow: branch]
	and ($45.b)		; 32 45 ; AND accumulator with memory (indirect) ($45.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $31.b,S		; 43 31 ; Exclusive OR accumulator with stack relative $31.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	eor ($65.b,X)		; 41 65 ; Exclusive OR accumulator with memory ($65.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor $24.b,X		; 55 24 ; Exclusive OR accumulator with memory $24.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $0D.b,S		; 23 0D ; AND accumulator with stack relative $0D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	sbc $232158.l,X		; FF 58 21 23 ; Subtract with carry (long,X) $232158.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($CE.b),Y		; 11 CE ; OR accumulator with memory ($CE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ldx $ECCF.w,Y		; BE CF EC ; Load X register $ECCF.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	cmp $EE68.w,X		; DD 68 EE ; Compare accumulator $EE68.w,X [Reads: X Index] [Flags: NCZ]
	cmp $101FF0.l,X		; DF F0 1F 10 ; Compare accumulator (long,X) $101FF0.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	ora $D0DD.w		; 0D DD D0 ; Logical OR $D0DD.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	cmp ($24.b)		; D2 24 ; Compare accumulator (indirect) ($24.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora $321EEE.l,X		; 1F EE 1E 32 ; Logical OR long $321EEE.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $F168.w		; 20 68 F1 ; Jump to subroutine at $F168.w [Writes: Stack Pointer] [Flow: call]
	ora ($13.b)		; 12 13 ; OR accumulator with memory (indirect) ($13.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $11.b		; 24 11 ; Test bits $11.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cop $11.b		; 02 11 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($58.b),Y		; 11 58 ; OR accumulator with memory ($58.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $061201.l		; 22 01 12 06 ; Jump to subroutine long $061201.l [Writes: Stack Pointer] [Flow: call]
	jsl $DEEB1F.l		; 22 1F EB DE ; Jump to subroutine long $DEEB1F.l [Writes: Stack Pointer] [Flow: call]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	inc $DDDD.w,X		; FE DD DD ; Increment memory $DDDD.w,X [Reads: X Index] [Flags: NZ]
	ldy $F1BC.w,X		; BC BC F1 ; Load Y register $F1BC.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	and ($2E.b,X)		; 21 2E ; Logical AND ($2E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp $DEBB.w,Y		; D9 BB DE ; Compare accumulator $DEBB.w,Y [Reads: Y Index] [Flags: NCZ]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $58.b,S		; 23 58 ; AND accumulator with stack relative $58.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr $FC0F.w		; 20 0F FC ; Jump to subroutine at $FC0F.w [Writes: Stack Pointer] [Flow: call]
	sbc $F0D0EE.l,X		; FF EE D0 F0 ; Subtract with carry (long,X) $F0D0EE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($58.b),Y		; 31 58 ; AND accumulator with memory ($58.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $42, $51		; 42 51 ; Reserved instruction
	bit $01.b,X		; 34 01 ; Test bits $01.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora ($01.b),Y		; 11 01 ; OR accumulator with memory ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($F5.b)		; F2 F5 ; Subtract with carry (indirect) ($F5.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	asl $56.b		; 06 56 ; Arithmetic shift left $56.b [Reads: Direct Page] [Flags: NCZ]
	and ($20.b,S),Y		; 33 20 ; AND accumulator (stack relative indirect indexed) ($20.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($20.b)		; 32 20 ; AND accumulator with memory (indirect) ($20.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	sbc $E1FCEC.l,X		; FF EC FC E1 ; Subtract with carry (long,X) $E1FCEC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $AFADAD.l		; EF AD AD AF ; Subtract with carry (long) $AFADAD.l [Writes: Accumulator] [Flags: NCVZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: NCZ]
	asl $EA0C.w		; 0E 0C EA ; Arithmetic shift left $EA0C.w [Flags: NCZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	cpy #$13.b		; C0 13 ; Compare #$13.b with Y register [Reads: Y Index] [Flags: NCZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	and ($0F.b)		; 32 0F ; AND accumulator with memory (indirect) ($0F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldx $00F0.w,Y		; BE F0 00 ; Load X register $00F0.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	and ($12.b,S),Y		; 33 12 ; AND accumulator (stack relative indirect indexed) ($12.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($58.b),Y		; 31 58 ; AND accumulator with memory ($58.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $454320.l,X		; 1F 20 43 45 ; Logical OR long $454320.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $23.b,X		; 35 23 ; Logical AND $23.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($1F.b)		; 12 1F ; OR accumulator with memory (indirect) ($1F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	and ($61.b)		; 32 61 ; AND accumulator with memory (indirect) ($61.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $50.b		; 45 50 ; Exclusive OR $50.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $1141.w		; 20 41 11 ; Jump to subroutine at $1141.w [Writes: Stack Pointer] [Flow: call]
	cmp $EB58.w		; CD 58 EB ; Compare $EB58.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jmp.w [$FFED]		; DC ED FF ; Jump long indirect [$FFED] [Flow: jump]
	ora $EF0D.w		; 0D 0D EF ; Logical OR $EF0D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp $FEEE58.l,X		; DF 58 EE FE ; Compare accumulator (long,X) $FEEE58.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	ora $CFFEFE.l,X		; 1F FE FE CF ; Logical OR long $CFFEFE.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $12		; F0 12 ; Branch if equal to $F0, $12 [Flow: branch]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	ora ($E0.b)		; 12 E0 ; OR accumulator with memory (indirect) ($E0.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $C0		; D0 C0 ; Branch if not equal to $D0, $C0 [Flow: branch]
	cmp ($F4.b),Y		; D1 F4 ; Compare accumulator ($F4.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	rol $44.b		; 26 44 ; Rotate left $44.b [Reads: Direct Page] [Flags: NCZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	ora $02E1BF.l		; 0F BF E1 02 ; OR accumulator with memory (long) $02E1BF.l [Writes: Accumulator] [Flags: NZ]
	and $33.b,S		; 23 33 ; AND accumulator with stack relative $33.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $114842.l		; 22 42 48 11 ; Jump to subroutine long $114842.l [Writes: Stack Pointer] [Flow: call]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	and ($42.b),Y		; 31 42 ; AND accumulator with memory ($42.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor ($55.b,X)		; 41 55 ; Exclusive OR accumulator with memory ($55.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	stz $75.b		; 64 75 ; Store zero to $75.b
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	asl $FC0B.w,X		; 1E 0B FC ; Arithmetic shift left $FC0B.w,X [Reads: X Index] [Flags: NCZ]
	inc $FF0F.w,X		; FE 0F FF ; Increment memory $FF0F.w,X [Reads: X Index] [Flags: NZ]
	sbc $FB58DC.l,X		; FF DC 58 FB ; Subtract with carry (long,X) $FB58DC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	cpx $1FFD.w		; EC FD 1F ; Compare $1FFD.w with X register [Reads: X Index] [Flags: NCZ]
	ora $48FFFD.l,X		; 1F FD FF 48 ; Logical OR long $48FFFD.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$D2.b		; E0 D2 ; Compare #$D2.b with X register [Reads: X Index] [Flags: NCZ]
	ora ($13.b,S),Y		; 13 13 ; OR accumulator (stack relative indirect indexed) ($13.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($55.b,S),Y		; 33 55 ; AND accumulator (stack relative indirect indexed) ($55.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $42, $20		; 42 20 ; Reserved instruction
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	and ($34.b)		; 32 34 ; AND accumulator with memory (indirect) ($34.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc [$23.b]		; 67 23 ; Add with carry (long) [$23.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tsb $F5.b		; 04 F5 ; Test and set bits $F5.b [Reads: Accumulator] [Flags: Z]
	eor $55.b,X		; 55 55 ; Exclusive OR accumulator with memory $55.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	ora ($12.b,S),Y		; 13 12 ; OR accumulator (stack relative indirect indexed) ($12.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
.ACCU 8
	sep #$E1		; E2 E1
	and ($3F.b,X)		; 21 3F ; Logical AND ($3F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and ($D4.b,X)		; 21 D4 ; Logical AND ($D4.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	cmp ($E0.b),Y		; D1 E0 ; Compare accumulator ($E0.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cpy $BB9A.w		; CC 9A BB ; Compare $BB9A.w with Y register [Reads: Y Index] [Flags: NCZ]
	cmp $DFDE.w,X		; DD DE DF ; Compare accumulator $DFDE.w,X [Reads: X Index] [Flags: NCZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	cpx #$0F.b		; E0 0F ; Compare #$0F.b with X register [Reads: X Index] [Flags: NCZ]
	.db $10, $FD		; 10 FD ; Branch if plus to $10, $FD [Flow: branch]
	sbc $F1FF.w,X		; FD FF F1 ; Subtract with carry $F1FF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $48.b		; 02 48 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $0F		; 30 0F ; Branch if minus to $30, $0F [Flow: branch]
	ora $432110.l		; 0F 10 21 43 ; OR accumulator with memory (long) $432110.l [Writes: Accumulator] [Flags: NZ]
	and ($11.b,S),Y		; 33 11 ; AND accumulator (stack relative indirect indexed) ($11.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	sbc ($C2.b,X)		; E1 C2 ; Subtract with carry ($C2.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $26.b		; 05 26 ; Logical OR $26.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($0F.b,S),Y		; 13 0F ; OR accumulator (stack relative indirect indexed) ($0F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $E2		; D0 E2 ; Branch if not equal to $D0, $E2 [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	asl $45.b		; 06 45 ; Arithmetic shift left $45.b [Reads: Direct Page] [Flags: NCZ]
	eor $01.b,S		; 43 01 ; Exclusive OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($E2.b,X)		; 01 E2 ; Logical OR ($E2.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc ($E3.b),Y		; F1 E3 ; Subtract with carry ($E3.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	cop $F4.b		; 02 F4 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $E2.b,S		; E3 E2 ; Subtract stack-relative $E2.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	.db $D0, $EE		; D0 EE ; Branch if not equal to $D0, $EE [Flow: branch]
	sbc $48FC.w,X		; FD FC 48 ; Subtract with carry $48FC.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy $BEBD.w,X		; BC BD BE ; Load Y register $BEBD.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	dec $FEFD.w,X		; DE FD FE ; Decrement memory $FEFD.w,X [Reads: X Index] [Flags: NZ]
	sbc $48FE.w,X		; FD FE 48 ; Subtract with carry $48FE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx $00DF.w		; EC DF 00 ; Compare $00DF.w with X register [Reads: X Index] [Flags: NCZ]
	and ($53.b)		; 32 53 ; AND accumulator with memory (indirect) ($53.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $30		; 10 30 ; Branch if plus to $10, $30 [Flow: branch]
	ora ($48.b)		; 12 48 ; OR accumulator with memory (indirect) ($48.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($32.b,S),Y		; 33 32 ; AND accumulator (stack relative indirect indexed) ($32.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor ($42.b,X)		; 41 42 ; Exclusive OR accumulator with memory ($42.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	jsr $2120.w		; 20 20 21 ; Jump to subroutine at $2120.w [Writes: Stack Pointer] [Flow: call]
	sec		; 38 ; Set carry flag [Flags: C]
	eor $43.b,S		; 43 43 ; Exclusive OR accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr $0B2C.w		; 20 2C 0B ; Jump to subroutine at $0B2C.w [Writes: Stack Pointer] [Flow: call]
	sbc $482100.l,X		; FF 00 21 48 ; Subtract with carry (long,X) $482100.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp.w [$EECD]		; DC CD EE ; Jump long indirect [$EECD] [Flow: jump]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	sbc $DCEE38.l,X		; FF 38 EE DC ; Subtract with carry (long,X) $DCEE38.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	dec $01F0.w,X		; DE F0 01 ; Decrement memory $01F0.w,X [Reads: X Index] [Flags: NZ]
	ora ($CD.b,X)		; 01 CD ; Logical OR ($CD.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sec		; 38 ; Set carry flag [Flags: C]
	inc $13D3.w,X		; FE D3 13 ; Increment memory $13D3.w,X [Reads: X Index] [Flags: NZ]
	mvp $22,$34		; 44 34 22 ; Move block positive $22,$34 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	.db $F0, $EF		; F0 EF ; Branch if equal to $F0, $EF [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	ora ($43.b,X)		; 01 43 ; Logical OR ($43.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor $42.b,X		; 55 42 ; Exclusive OR accumulator with memory $42.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $FF		; F0 FF ; Branch if equal to $F0, $FF [Flow: branch]
	.db $D0, $10		; D0 10 ; Branch if not equal to $D0, $10 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	rol $4552.w,X		; 3E 52 45 ; Rotate left $4552.w,X [Reads: X Index] [Flags: NCZ]
	and $10.b		; 25 10 ; Logical AND $10.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $28F00E.l		; 2F 0E F0 28 ; AND accumulator with memory (long) $28F00E.l [Writes: Accumulator] [Flags: NZ]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	ora $2E1D.w		; 0D 1D 2E ; Logical OR $2E1D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $DA0E.w,X		; 1E 0E DA ; Arithmetic shift left $DA0E.w,X [Reads: X Index] [Flags: NCZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	dec $EC9D.w,X		; DE 9D EC ; Decrement memory $EC9D.w,X [Reads: X Index] [Flags: NZ]
	tsb $0E0D.w		; 0C 0D 0E ; Test and set bits $0E0D.w [Reads: Accumulator] [Flags: Z]
	sbc $28CC.w		; ED CC 28 ; Subtract $28CC.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sbc $CEDE.w		; ED DE CE ; Subtract $CEDE.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cmp $502302.l		; CF 02 23 50 ; Compare accumulator (long) $502302.l [Reads: Accumulator] [Flags: NCZ]
	eor ($28.b)		; 52 28 ; Exclusive OR accumulator with memory (indirect) ($28.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($43.b)		; 32 43 ; AND accumulator with memory (indirect) ($43.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $222342.l		; 22 42 23 22 ; Jump to subroutine long $222342.l [Writes: Stack Pointer] [Flow: call]
	ora ($21.b),Y		; 11 21 ; OR accumulator with memory ($21.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	jsl $203143.l		; 22 43 31 20 ; Jump to subroutine long $203143.l [Writes: Stack Pointer] [Flow: call]
	ora $FFE00E.l		; 0F 0E E0 FF ; OR accumulator with memory (long) $FFE00E.l [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc $FCEF0F.l,X		; FF 0F EF FC ; Subtract with carry (long,X) $FCEF0F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp.w [$90CE]		; DC CE 90 ; Jump long indirect [$90CE] [Flow: jump]
	cmp $FFFE18.l		; CF 18 FE FF ; Compare accumulator (long) $FFFE18.l [Reads: Accumulator] [Flags: NCZ]
	dec $0DEE.w,X		; DE EE 0D ; Decrement memory $0DEE.w,X [Reads: X Index] [Flags: NZ]
	brk $E1.b		; 00 E1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pei ($18.b)		; D4 18 ; Push effective indirect address ($18.b) [Reads: Direct Page] [Writes: Stack Pointer]
	sbc $C3.b,S		; E3 C3 ; Subtract stack-relative $C3.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	ora ($E1.b,X)		; 01 E1 ; Logical OR ($E1.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $10, $54		; 10 54 ; Branch if plus to $10, $54 [Flow: branch]
	ora ($40.b,X)		; 01 40 ; Logical OR ($40.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($20.b)		; 12 20 ; OR accumulator with memory (indirect) ($20.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $0811.w		; 20 11 08 ; Jump to subroutine at $0811.w [Writes: Stack Pointer] [Flow: call]
	.db $10, $40		; 10 40 ; Branch if plus to $10, $40 [Flow: branch]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $010100.l		; 0F 00 01 01 ; OR accumulator with memory (long) $010100.l [Writes: Accumulator] [Flags: NZ]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	and $10.b,S		; 23 10 ; AND accumulator with stack relative $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0000FF.l,X		; 1F FF 00 00 ; Logical OR long $0000FF.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $FE0D0F.l		; 0F 0F 0D FE ; OR accumulator with memory (long) $FE0D0F.l [Writes: Accumulator] [Flags: NZ]
	cmp $0002F0.l,X		; DF F0 02 00 ; Compare accumulator (long,X) $0002F0.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D2.b		; 00 D2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $DEDD.w,X		; DD DD DE ; Compare accumulator $DEDD.w,X [Reads: X Index] [Flags: NCZ]
	cmp $3423.w,X		; DD 23 34 ; Compare accumulator $3423.w,X [Reads: X Index] [Flags: NCZ]
	mvp $86,$44		; 44 44 86 ; Move block positive $86,$44 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	jmp $66C7.w		; 4C C7 66 ; Jump to $66C7.w [Flow: jump]
	ror $67.b		; 66 67 ; Rotate right $67.b [Reads: Direct Page] [Flags: NCZ]
	ror $66.b,X		; 76 66 ; Rotate right $66.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ror $D2.b		; 66 D2 ; Rotate right $D2.b [Reads: Direct Page] [Flags: NCZ]
	and ($33.b,S),Y		; 33 33 ; AND accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($33.b,S),Y		; 33 33 ; AND accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($33.b)		; 32 33 ; AND accumulator with memory (indirect) ($33.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $96DC.w		; ED DC 96 ; Subtract $96DC.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	and ($EF.b,X)		; 21 EF ; Logical AND ($EF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp $DDCC.w,X		; DD CC DD ; Compare accumulator $DDCC.w,X [Reads: X Index] [Flags: NCZ]
	cmp $DDDD.w,X		; DD DD DD ; Compare accumulator $DDDD.w,X [Reads: X Index] [Flags: NCZ]
	cmp ($DD.b)		; D2 DD ; Compare accumulator (indirect) ($DD.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp $DDDE.w,X		; DD DE DD ; Compare accumulator $DDDE.w,X [Reads: X Index] [Flags: NCZ]
	and $34.b,S		; 23 34 ; AND accumulator with stack relative $34.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	mvp $87,$44		; 44 44 87 ; Move block positive $87,$44 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	jmp $66C6.w		; 4C C6 66 ; Jump to $66C6.w [Flow: jump]
	adc [$66.b],Y		; 77 66 ; Add with carry (long indexed) [$66.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $67.b		; 66 67 ; Rotate right $67.b [Reads: Direct Page] [Flags: NCZ]
	ror $02.b,X		; 76 02 ; Rotate right $02.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($DC.b)		; D2 DC ; Compare accumulator (indirect) ($DC.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp $DDDD.w,X		; DD DD DD ; Compare accumulator $DDDD.w,X [Reads: X Index] [Flags: NCZ]
	cmp $EEDD.w,X		; DD DD EE ; Compare accumulator $EEDD.w,X [Reads: X Index] [Flags: NCZ]
	inc $4E96.w		; EE 96 4E ; Increment $4E96.w [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($6A.b),Y		; 11 6A ; OR accumulator with memory ($6A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	mvp $22,$00		; 44 00 22 ; Move block positive $22,$00 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	bit $44.b,X		; 34 44 ; Test bits $44.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	eor $66.b		; 45 66 ; Exclusive OR $66.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc [$B6.b]		; 67 B6 ; Add with carry (long) [$B6.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $DCD25E.l,X		; 3F 5E D2 DC ; AND accumulator with memory (long,X) $DCD25E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $DDDD.w,X		; DD DD DD ; Compare accumulator $DDDD.w,X [Reads: X Index] [Flags: NCZ]
	cmp $EEDD.w,X		; DD DD EE ; Compare accumulator $EEDD.w,X [Reads: X Index] [Flags: NCZ]
	inc $4E97.w		; EE 97 4E ; Increment $4E97.w [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b),Y		; 11 02 ; OR accumulator with memory ($02.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	cmp $1137.w,X		; DD 37 11 ; Compare accumulator $1137.w,X [Reads: X Index] [Flags: NCZ]
	ora ($12.b)		; 12 12 ; OR accumulator with memory (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b)		; 12 01 ; OR accumulator with memory (indirect) ($01.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($7A.b)		; 12 7A ; OR accumulator with memory (indirect) ($7A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $22.b,S		; 43 22 ; Exclusive OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $22.b,S		; 23 22 ; AND accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $33.b,S		; 23 33 ; AND accumulator with stack relative $33.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($44.b,S),Y		; 33 44 ; AND accumulator (stack relative indirect indexed) ($44.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	eor $55.b		; 45 55 ; Exclusive OR $55.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror $55.b		; 66 55 ; Rotate right $55.b [Reads: Direct Page] [Flags: NCZ]
	ror $65.b		; 66 65 ; Rotate right $65.b [Reads: Direct Page] [Flags: NCZ]
	mvp $7A,$54		; 44 54 7A ; Move block positive $7A,$54 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	eor $32.b,S		; 43 32 ; Exclusive OR accumulator with stack relative $32.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $32.b,S		; 23 32 ; AND accumulator with stack relative $32.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $443333.l		; 22 33 33 44 ; Jump to subroutine long $443333.l [Writes: Stack Pointer] [Flow: call]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	eor $54.b,X		; 55 54 ; Exclusive OR accumulator with memory $54.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ror $65.b		; 66 65 ; Rotate right $65.b [Reads: Direct Page] [Flags: NCZ]
	adc $65.b		; 65 65 ; Add $65.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	mvn $7A,$44		; 54 44 7A ; Move block negative $7A,$44 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	mvp $33,$22		; 44 22 33 ; Move block positive $33,$22 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	jsl $233323.l		; 22 23 33 23 ; Jump to subroutine long $233323.l [Writes: Stack Pointer] [Flow: call]
	eor $7A.b		; 45 7A ; Exclusive OR $7A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $55.b		; 45 55 ; Exclusive OR $55.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr $66.b,X		; 56 66 ; Logical shift right $66.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	lsr $55.b,X		; 56 55 ; Logical shift right $55.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	eor $43.b,X		; 55 43 ; Exclusive OR accumulator with memory $43.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	eor $33.b,S		; 43 33 ; Exclusive OR accumulator with stack relative $33.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($22.b)		; 32 22 ; AND accumulator with memory (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $33.b,S		; 23 33 ; AND accumulator with stack relative $33.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($34.b,S),Y		; 33 34 ; AND accumulator (stack relative indirect indexed) ($34.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	eor $55.b,X		; 55 55 ; Exclusive OR accumulator with memory $55.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ror $55.b		; 66 55 ; Rotate right $55.b [Reads: Direct Page] [Flags: NCZ]
	ror $55.b		; 66 55 ; Rotate right $55.b [Reads: Direct Page] [Flags: NCZ]
	eor $44.b,X		; 55 44 ; Exclusive OR accumulator with memory $44.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($33.b,S),Y		; 33 33 ; AND accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($22.b)		; 32 22 ; AND accumulator with memory (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($33.b)		; 32 33 ; AND accumulator with memory (indirect) ($33.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($44.b,S),Y		; 33 44 ; AND accumulator (stack relative indirect indexed) ($44.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7A.b		; 00 7A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($62.b)		; F2 62 ; Subtract with carry (indirect) ($62.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jsl $212223.l		; 22 23 22 21 ; Jump to subroutine long $212223.l [Writes: Stack Pointer] [Flow: call]
	ora ($10.b)		; 12 10 ; OR accumulator with memory (indirect) ($10.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cmp $ABAAC0.l,X		; DF C0 AA AB ; Compare accumulator (long,X) $ABAAC0.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	cmp $A633E2.l		; CF E2 33 A6 ; Compare accumulator (long) $A633E2.l [Reads: Accumulator] [Flags: NCZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $212322.l		; 22 22 23 21 ; Jump to subroutine long $212322.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $5D		; 30 5D ; Branch if minus to $30, $5D [Flow: branch]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	ldy $2F.b,X		; B4 2F ; Load Y register $2F.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	ora $00F001.l		; 0F 01 F0 00 ; OR accumulator with memory (long) $00F001.l [Writes: Accumulator] [Flags: NZ]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $ED.b		; 25 ED ; Logical AND $ED.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	.db $10, $21		; 10 21 ; Branch if plus to $10, $21 [Flow: branch]
	and ($22.b,X)		; 21 22 ; Logical AND ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and ($33.b)		; 32 33 ; AND accumulator with memory (indirect) ($33.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	mvp $A6,$55		; 44 55 A6 ; Move block positive $A6,$55 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora ($22.b)		; 12 22 ; OR accumulator with memory (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $43.b,X		; 34 43 ; Test bits $43.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $32.b,X		; 34 32 ; Test bits $32.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	lsr $B4CA.w,X		; 5E CA B4 ; Logical shift right $B4CA.w,X [Reads: X Index] [Flags: NCZ]
	and $F0001F.l		; 2F 1F 00 F0 ; AND accumulator with memory (long) $F0001F.l [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8A.b		; 00 8A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$D1.b		; 09 D1 ; Logical OR #$D1.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $6AFF.w		; EE FF 6A ; Increment $6AFF.w [Flags: NZ]
	sta $AAAA.w,Y		; 99 AA AA ; Store accumulator to $AAAA.w,Y [Reads: Y Index, Accumulator]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	cmp $F0EF.w		; CD EF F0 ; Compare $F0EF.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	and $AA.b,S		; 23 AA ; AND accumulator with stack relative $AA.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($F0.b),Y		; 11 F0 ; OR accumulator with memory ($F0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $B26A.w,X		; 3D 6A B2 ; AND accumulator with memory $B26A.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($32.b),Y		; 31 32 ; AND accumulator with memory ($32.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($0F.b,X)		; 21 0F ; Logical AND ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	inc $CCED.w		; EE ED CC ; Increment $CCED.w [Flags: NZ]
	cpy $258A.w		; CC 8A 25 ; Compare $258A.w with Y register [Reads: Y Index] [Flags: NCZ]
	sbc ($11.b,X)		; E1 11 ; Subtract with carry ($11.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($10.b)		; 12 10 ; OR accumulator with memory (indirect) ($10.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $4A.b		; 00 4A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $D0, $A1		; D0 A1 ; Branch if not equal to $D0, $A1 [Flow: branch]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	cmp $A633E1.l,X		; DF E1 33 A6 ; Compare accumulator (long,X) $A633E1.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $212322.l		; 22 22 23 21 ; Jump to subroutine long $212322.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $5D		; 30 5D ; Branch if minus to $30, $5D [Flow: branch]
	wai		; CB ; Wait for interrupt
	ldy $2F.b,X		; B4 2F ; Load Y register $2F.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	ora $00F001.l		; 0F 01 F0 00 ; OR accumulator with memory (long) $00F001.l [Writes: Accumulator] [Flags: NZ]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A6.b		; 00 A6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: NCZ]
	ror $CA.b		; 66 CA ; Rotate right $CA.b [Reads: Direct Page] [Flags: NCZ]
	lda ($11.b,X)		; A1 11 ; Load accumulator ($11.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($34.b)		; 12 34 ; OR accumulator with memory (indirect) ($34.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	mvp $67,$45		; 44 45 67 ; Move block positive $67,$45 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	lda ($00.b)		; B2 00 ; Load accumulator (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($22.b)		; 12 22 ; OR accumulator with memory (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpy $AAAA.w		; CC AA AA ; Compare $AAAA.w with Y register [Reads: Y Index] [Flags: NCZ]
	ror $76.b		; 66 76 ; Rotate right $76.b [Reads: Direct Page] [Flags: NCZ]
	sbc $1201F0.l,X		; FF F0 01 12 ; Subtract with carry (long,X) $1201F0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $34.b,S		; 23 34 ; AND accumulator with stack relative $34.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $92.b		; 45 92 ; Exclusive OR $92.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $01EF.w		; CD EF 01 ; Compare $01EF.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	and $45.b,S		; 23 45 ; AND accumulator with stack relative $45.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc [$FF.b]		; 67 FF ; Add with carry (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($6A.b,X)		; 01 6A ; Logical OR ($6A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($4F.b),Y		; 11 4F ; OR accumulator with memory ($4F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $333422.l		; 22 22 34 33 ; Jump to subroutine long $333422.l [Writes: Stack Pointer] [Flow: call]
	eor $44.b		; 45 44 ; Exclusive OR $44.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldx $11.b,Y		; B6 11 ; Load X register $11.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	.db $F0, $A0		; F0 A0 ; Branch if equal to $F0, $A0 [Flow: branch]
	cpx #$0F.b		; E0 0F ; Compare #$0F.b with X register [Reads: X Index] [Flags: NCZ]
	stx $C1.b		; 86 C1 ; Store X register to $C1.b [Reads: X Index]
	and $FFFFFF.l		; 2F FF FF FF ; AND accumulator with memory (long) $FFFFFF.l [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($A6.b),Y		; 11 A6 ; OR accumulator with memory ($A6.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($10.b),Y		; 11 10 ; OR accumulator with memory ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$10.b		; C0 10 ; Compare #$10.b with Y register [Reads: Y Index] [Flags: NCZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	sbc ($5D.b),Y		; F1 5D ; Subtract with carry ($5D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($21.b),Y		; 11 21 ; OR accumulator with memory ($21.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda ($33.b)		; B2 33 ; Load accumulator (indirect) ($33.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($33.b,S),Y		; 33 33 ; AND accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $55.b		; 45 55 ; Exclusive OR $55.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $8ADDDD.l,X		; FF DD DD 8A ; Subtract with carry (long,X) $8ADDDD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $000FEF.l,X		; 5F EF 0F 00 ; Exclusive OR accumulator with memory (long,X) $000FEF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	.db $10, $01		; 10 01 ; Branch if plus to $10, $01 [Flow: branch]
	stx $22.b,Y		; 96 22 ; Store X register $22.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	ora ($22.b),Y		; 11 22 ; OR accumulator with memory ($22.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $912222.l		; 22 22 22 91 ; Jump to subroutine long $912222.l [Writes: Stack Pointer] [Flow: call]
	jsl $31227A.l		; 22 7A 22 31 ; Jump to subroutine long $31227A.l [Writes: Stack Pointer] [Flow: call]
	and ($23.b,S),Y		; 33 23 ; AND accumulator (stack relative indirect indexed) ($23.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($34.b,S),Y		; 33 34 ; AND accumulator (stack relative indirect indexed) ($34.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	mvp $BA,$34		; 44 34 BA ; Move block positive $BA,$34 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1B.b		; 00 1B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $A6.b		; E6 A6 ; Increment $A6.b [Reads: Direct Page] [Flags: NZ]
	cmp ($F0.b)		; D2 F0 ; Compare accumulator (indirect) ($F0.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
.ACCU 8
.INDEX 8
	sep #$BE		; E2 BE
	dec $EEEE.w,X		; DE EE EE ; Decrement memory $EEEE.w,X [Reads: X Index] [Flags: NZ]
	inc $FEEE.w,X		; FE EE FE ; Increment memory $FEEE.w,X [Reads: X Index] [Flags: NZ]
	lda [$00.b]		; A7 00 ; Load accumulator (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $B0, $3F		; B0 3F ; Branch if carry set to $B0, $3F [Flow: branch]
	ora $E022.w,X		; 1D 22 E0 ; OR accumulator with memory $E022.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($F0.b,S),Y		; F3 F0 ; Subtract with carry (stack relative indirect indexed) ($F0.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cmp ($2F.b,X)		; C1 2F ; Compare accumulator ($2F.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	.db $B0, $1E		; B0 1E ; Branch if carry set to $B0, $1E [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $E111E4.l,X		; FF E4 11 E1 ; Subtract with carry (long,X) $E111E4.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $B0, $3D		; B0 3D ; Branch if carry set to $B0, $3D [Flow: branch]
	inc $FC2F.w,X		; FE 2F FC ; Increment memory $FC2F.w,X [Reads: X Index] [Flags: NZ]
	ora ($F0.b)		; 12 F0 ; OR accumulator with memory (indirect) ($F0.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx $0F.b		; E4 0F ; Compare $0F.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	ldy #$F2.b		; A0 F2 ; Load #$F2.b into Y register [Writes: Y Index] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	ldy $1B70.w,X		; BC 70 1B ; Load Y register $1B70.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	eor $BF.b,X		; 55 BF ; Exclusive OR accumulator with memory $BF.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $B0.b,X		; D5 B0 ; Compare accumulator $B0.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	asl $20D3.w		; 0E D3 20 ; Arithmetic shift left $20D3.w [Flags: NCZ]
	cpx #$4E.b		; E0 4E ; Compare #$4E.b with X register [Reads: X Index] [Flags: NCZ]
	sbc $B0EC32.l,X		; FF 32 EC B0 ; Subtract with carry (long,X) $B0EC32.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $0EF5FD.l		; 22 FD F5 0E ; Jump to subroutine long $0EF5FD.l [Writes: Stack Pointer] [Flow: call]
.ACCU 8
	sep #$2E		; E2 2E
	lda ($40.b)		; B2 40 ; Load accumulator (indirect) ($40.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $FF		; B0 FF ; Branch if carry set to $B0, $FF [Flow: branch]
	.db $50, $DE		; 50 DE ; Branch if overflow clear to $50, $DE [Flow: branch]
	and $FA.b,S		; 23 FA ; AND accumulator with stack relative $FA.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	trb $FE.b		; 14 FE ; Test and reset bits $FE.b [Reads: Accumulator] [Flags: Z]
	cmp $B0.b,X		; D5 B0 ; Compare accumulator $B0.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $40E1.w,X		; 1D E1 40 ; OR accumulator with memory $40E1.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda $53FD50.l		; AF 50 FD 53 ; Load long $53FD50.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp $1A04B0.l,X		; DF B0 04 1A ; Compare accumulator (long,X) $1A04B0.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	cpx $1F.b		; E4 1F ; Compare $1F.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	cpy $3D.b		; C4 3D ; Compare $3D.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	sbc $CFC041.l		; EF 41 C0 CF ; Subtract with carry (long) $CFC041.l [Writes: Accumulator] [Flags: NCVZ]
	and ($0E.b,X)		; 21 0E ; Logical AND ($0E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and ($FF.b)		; 32 FF ; AND accumulator with memory (indirect) ($FF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $0C.b		; 02 0C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $C0.b,S		; 03 C0 ; OR accumulator with stack relative $C0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $E01ED2.l,X		; 1F D2 1E E0 ; Logical OR long $E01ED2.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $BF		; 30 BF ; Branch if minus to $30, $BF [Flow: branch]
	and ($FE.b,X)		; 21 FE ; Logical AND ($FE.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpy #$31.b		; C0 31 ; Compare #$31.b with Y register [Reads: Y Index] [Flags: NCZ]
	inc $FC13.w		; EE 13 FC ; Increment $FC13.w [Flags: NZ]
	ora ($1D.b,S),Y		; 13 1D ; OR accumulator (stack relative indirect indexed) ($1D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $1E.b,S		; E3 1E ; Subtract stack-relative $1E.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	cpy #$D1.b		; C0 D1 ; Compare #$D1.b with Y register [Reads: Y Index] [Flags: NCZ]
	rol $21C0.w,X		; 3E C0 21 ; Rotate left $21C0.w,X [Reads: X Index] [Flags: NCZ]
	.db $D0, $30		; D0 30 ; Branch if not equal to $D0, $30 [Flow: branch]
	sbc $C023.w		; ED 23 C0 ; Subtract $C023.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cmp $1C13.w		; CD 13 1C ; Compare $1C13.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora ($0E.b,S),Y		; 13 0E ; OR accumulator (stack relative indirect indexed) ($0E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx $2C.b		; E4 2C ; Compare $2C.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc ($C0.b)		; F2 C0 ; Subtract with carry (indirect) ($C0.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	eor $CF30D3.l		; 4F D3 30 CF ; Exclusive OR accumulator with memory (long) $CF30D3.l [Writes: Accumulator] [Flags: NZ]
	lsr $22CF.w		; 4E CF 22 ; Logical shift right $22CF.w [Flags: NCZ]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: NCZ]
	and ($FC.b)		; 32 FC ; AND accumulator with memory (indirect) ($FC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($D0.b)		; 12 D0 ; OR accumulator with memory (indirect) ($D0.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $0C.b		; 14 0C ; Test and reset bits $0C.b [Reads: Accumulator] [Flags: Z]
	ora ($0D.b),Y		; 11 0D ; OR accumulator with memory ($0D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$E3.b		; C0 E3 ; Compare #$E3.b with Y register [Reads: Y Index] [Flags: NCZ]
	sbc $3DF1.w		; ED F1 3D ; Subtract $3DF1.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sbc ($20.b)		; F2 20 ; Subtract with carry (indirect) ($20.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp ($2D.b,X)		; C1 2D ; Compare accumulator ($2D.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	.db $B0, $EF		; B0 EF ; Branch if carry set to $B0, $EF [Flow: branch]
	adc ($B3.b,X)		; 61 B3 ; Add with carry ($B3.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $FF5BCE.l		; 22 CE 5B FF ; Jump to subroutine long $FF5BCE.l [Writes: Stack Pointer] [Flow: call]
	and $B0.b,X		; 35 B0 ; Logical AND $B0.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
.ACCU 16
	rep #$22		; C2 22
	jsr ($E15C.w,X)		; FC 5C E1 ; Jump to subroutine indirect indexed ($E15C.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	asl $D1.b,X		; 16 D1 ; Arithmetic shift left $D1.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	jsr $0CB0.w		; 20 B0 0C ; Jump to subroutine at $0CB0.w [Writes: Stack Pointer] [Flow: call]
	eor $16C1.w		; 4D C1 16 ; Exclusive OR $16C1.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cpx #$31.b		; E0 31 ; Compare #$31.b with X register [Reads: X Index] [Flags: NCZ]
	tsb $B04E.w		; 0C 4E B0 ; Test and set bits $B04E.w [Reads: Accumulator] [Flags: Z]
	cmp ($05.b,X)		; C1 05 ; Compare accumulator ($05.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	cpx #$31.b		; E0 31 ; Compare #$31.b with X register [Reads: X Index] [Flags: NCZ]
	tsb $B13E.w		; 0C 3E B1 ; Test and set bits $B13E.w [Reads: Accumulator] [Flags: Z]
	ora $B0.b,X		; 15 B0 ; OR accumulator with memory $B0.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $30		; F0 30 ; Branch if equal to $F0, $30 [Flow: branch]
	jsr ($C13E.w,X)		; FC 3E C1 ; Jump to subroutine indirect indexed ($C13E.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora $E0.b,X		; 15 E0 ; OR accumulator with memory $E0.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	jsr $FCB0.w		; 20 B0 FC ; Jump to subroutine at $FCB0.w [Writes: Stack Pointer] [Flow: call]
	bit $15D1.w,X		; 3C D1 15 ; Test bits $15D1.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	sep #$41		; E2 41 ; Set processor status bits #$41 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	sbc $B04B.w,X		; FD 4B B0 ; Subtract with carry $B04B.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp ($35.b),Y		; D1 35 ; Compare accumulator ($35.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cmp ($31.b),Y		; D1 31 ; Compare accumulator ($31.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	sbc $E03B.w		; ED 3B E0 ; Subtract $E03B.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	bit $B0.b,X		; 34 B0 ; Test bits $B0.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cmp ($32.b)		; D2 32 ; Compare accumulator (indirect) ($32.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	inc $002B.w		; EE 2B 00 ; Increment $002B.w [Flags: NZ]
	and ($D3.b)		; 32 D3 ; AND accumulator with memory (indirect) ($D3.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($B0.b),Y		; 31 B0 ; AND accumulator with memory ($B0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $52001B.l,X		; DF 1B 00 52 ; Compare accumulator (long,X) $52001B.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	sbc ($10.b,S),Y		; F3 10 ; Subtract with carry (stack relative indirect indexed) ($10.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cmp ($ED.b,X)		; C1 ED ; Compare accumulator ($ED.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	.db $B0, $22		; B0 22 ; Branch if carry set to $B0, $22 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora ($0F.b)		; 12 0F ; OR accumulator with memory (indirect) ($0F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp ($BE.b,S),Y		; D3 BE ; Compare accumulator (stack relative indirect indexed) ($BE.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	ora ($4D.b)		; 12 4D ; OR accumulator with memory (indirect) ($4D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $12		; B0 12 ; Branch if carry set to $B0, $12 [Flow: branch]
	asl $AFD2.w,X		; 1E D2 AF ; Arithmetic shift left $AFD2.w,X [Reads: X Index] [Flags: NCZ]
	ora $3D.b,S		; 03 3D ; OR accumulator with stack relative $3D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($0D.b,X)		; 21 0D ; Logical AND ($0D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $B0, $00		; B0 00 ; Branch if carry set to $B0, $00 [Flow: branch]
	.db $B0, $05		; B0 05 ; Branch if carry set to $B0, $05 [Flow: branch]
	ora $2B0C32.l		; 0F 32 0C 2B ; OR accumulator with memory (long) $2B0C32.l [Writes: Accumulator] [Flags: NZ]
	cmp ($B0.b),Y		; D1 B0 ; Compare accumulator ($B0.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	and $E1.b		; 25 E1 ; Logical AND $E1.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $ED		; 10 ED ; Branch if plus to $10, $ED [Flow: branch]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	and ($42.b,X)		; 21 42 ; Logical AND ($42.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc ($B0.b,S),Y		; F3 B0 ; Subtract with carry (stack relative indirect indexed) ($B0.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $C2		; 10 C2 ; Branch if plus to $10, $C2 [Flow: branch]
	ldy $4C11.w		; AC 11 4C ; Load $4C11.w into Y register [Writes: Y Index] [Flags: NZ]
	ora ($0D.b),Y		; 11 0D ; OR accumulator with memory ($0D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($B0.b),Y		; D1 B0 ; Compare accumulator ($B0.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	sta $311E05.l,X		; 9F 05 1E 31 ; Store accumulator (long,X) $311E05.l,X [Reads: Accumulator, X Index]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc ($24.b)		; F2 24 ; Subtract with carry (indirect) ($24.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $B0, $D2		; B0 D2 ; Branch if carry set to $B0, $D2 [Flow: branch]
	ora $11ECC0.l		; 0F C0 EC 11 ; OR accumulator with memory (long) $11ECC0.l [Writes: Accumulator] [Flags: NZ]
	ror $0E23.w		; 6E 23 0E ; Rotate right $0E23.w [Flags: NCZ]
	.db $B0, $C1		; B0 C1 ; Branch if carry set to $B0, $C1 [Flow: branch]
	sta ($15.b),Y		; 91 15 ; Store accumulator ($15.b),Y [Reads: Direct Page, Y Index, Accumulator]
	asl $FA30.w,X		; 1E 30 FA ; Arithmetic shift left $FA30.w,X [Reads: X Index] [Flags: NCZ]
	ora $B0F1.w,Y		; 19 F1 B0 ; OR accumulator with memory $B0F1.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and $D3.b		; 25 D3 ; Logical AND $D3.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($D0.b),Y		; 11 D0 ; OR accumulator with memory ($D0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda $7E32.w,X		; BD 32 7E ; Load $7E32.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($B0.b),Y		; 31 B0 ; AND accumulator with memory ($B0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	inc $A2EF.w,X		; FE EF A2 ; Increment memory $A2EF.w,X [Reads: X Index] [Flags: NZ]
	asl $F1.b,X		; 16 F1 ; Arithmetic shift left $F1.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	and $B03AFC.l		; 2F FC 3A B0 ; AND accumulator with memory (long) $B03AFC.l [Writes: Accumulator] [Flags: NZ]
	ora ($42.b),Y		; 11 42 ; OR accumulator with memory ($42.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($F0.b,S),Y		; D3 F0 ; Compare accumulator (stack relative indirect indexed) ($F0.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	lda ($9E.b)		; B2 9E ; Load accumulator (indirect) ($9E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $31B05C.l		; 22 5C B0 31 ; Jump to subroutine long $31B05C.l [Writes: Stack Pointer] [Flow: call]
	tsb $C2FD.w		; 0C FD C2 ; Test and set bits $C2FD.w [Reads: Accumulator] [Flags: Z]
	ora $C1.b		; 05 C1 ; Logical OR $C1.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $B0FD.w		; 20 FD B0 ; Jump to subroutine at $B0FD.w [Writes: Stack Pointer] [Flow: call]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	and ($50.b,X)		; 21 50 ; Logical AND ($50.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc ($00.b,S),Y		; F3 00 ; Subtract with carry (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cmp $B1.b,S		; C3 B1 ; Compare accumulator (stack relative) $B1.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	and ($B0.b,S),Y		; 33 B0 ; AND accumulator (stack relative indirect indexed) ($B0.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $1D31.w,X		; 3C 31 1D ; Test bits $1D31.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	and $16E3.w		; 2D E3 16 ; Logical AND $16E3.w with accumulator [Writes: Accumulator] [Flags: NZ]
.INDEX 16
	rep #$10		; C2 10
	.db $B0, $FE		; B0 FE ; Branch if carry set to $B0, $FE [Flow: branch]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $10, $5F		; 10 5F ; Branch if plus to $10, $5F [Flow: branch]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $B2.b,S		; C3 B2 ; Compare accumulator (stack relative) $B2.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	.db $B0, $14		; B0 14 ; Branch if carry set to $B0, $14 [Flow: branch]
	asl $0C3F.w,X		; 1E 3F 0C ; Arithmetic shift left $0C3F.w,X [Reads: X Index] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
.ACCU 8
	sep #$25		; E2 25
	sbc ($B0.b)		; F2 B0 ; Subtract with carry (indirect) ($B0.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($D1.b),Y		; 11 D1 ; OR accumulator with memory ($D1.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora #$21.b		; 09 21 ; Logical OR #$21.b with accumulator [Writes: Accumulator] [Flags: NZ]
	adc $0F01.w		; 6D 01 0F ; Add $0F01.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sbc ($B0.b,X)		; E1 B0 ; Subtract with carry ($B0.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx #$EF05.w		; A2 05 EF ; Load #$EF05.w into X register [Writes: X Index] [Flags: NZ]
	.db $30, $1C		; 30 1C ; Branch if minus to $30, $1C [Flow: branch]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora ($32.b),Y		; 11 32 ; OR accumulator with memory ($32.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $C3		; B0 C3 ; Branch if carry set to $B0, $C3 [Flow: branch]
	ora ($C3.b,X)		; 01 C3 ; Logical OR ($C3.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp $215B31.l		; CF 31 5B 21 ; Compare accumulator (long) $215B31.l [Reads: Accumulator] [Flags: NCZ]
	asl $10B0.w,X		; 1E B0 10 ; Arithmetic shift left $10B0.w,X [Reads: X Index] [Flags: NCZ]
	cmp $16.b,S		; C3 16 ; Compare accumulator (stack relative) $16.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	cmp ($2F.b),Y		; D1 2F ; Compare accumulator ($2F.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	sbc $204B.w,X		; FD 4B 20 ; Subtract with carry $204B.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $B0, $40		; B0 40 ; Branch if carry set to $B0, $40 [Flow: branch]
	sbc $F0.b,S		; E3 F0 ; Subtract stack-relative $F0.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	cpy $A0.b		; C4 A0 ; Compare $A0.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	jsl $B0203B.l		; 22 3B 20 B0 ; Jump to subroutine long $B0203B.l [Writes: Stack Pointer] [Flow: call]
	tsb $C11C.w		; 0C 1C C1 ; Test and set bits $C11C.w [Reads: Accumulator] [Flags: Z]
	ora $C2.b		; 05 C2 ; Logical OR $C2.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $EF		; 10 EF ; Branch if plus to $10, $EF [Flow: branch]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	.db $B0, $21		; B0 21 ; Branch if carry set to $B0, $21 [Flow: branch]
	eor $0F13.w,X		; 5D 13 0F ; Exclusive OR accumulator with memory $0F13.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($B2.b,S),Y		; D3 B2 ; Compare accumulator (stack relative indirect indexed) ($B2.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	tsb $FF.b		; 04 FF ; Test and set bits $FF.b [Reads: Accumulator] [Flags: Z]
	.db $B0, $3F		; B0 3F ; Branch if carry set to $B0, $3F [Flow: branch]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $10, $21		; 10 21 ; Branch if plus to $10, $21 [Flow: branch]
	cmp $00.b,S		; C3 00 ; Compare accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	lda ($B0.b)		; B2 B0 ; Load accumulator (indirect) ($B0.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda ($11.b,X)		; A1 11 ; Load accumulator ($11.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	bit $0C30.w		; 2C 30 0C ; Test bits $0C30.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	and #$02.b		; 29 02 ; Logical AND #$02.b with accumulator [Writes: Accumulator] [Flags: NZ]
	and $B0.b,S		; 23 B0 ; AND accumulator with stack relative $B0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda ($00.b,S),Y		; B3 00 ; Load accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
.ACCU 16
	rep #$A1		; C2 A1
	and ($4B.b)		; 32 4B ; AND accumulator with memory (indirect) ($4B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $3AB00D.l,X		; 3F 0D B0 3A ; AND accumulator with memory (long,X) $3AB00D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $25.b,S		; 03 25 ; OR accumulator with stack relative $25.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda ($00.b,S),Y		; B3 00 ; Load accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp ($9F.b,X)		; C1 9F ; Compare accumulator ($9F.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	and ($B0.b,X)		; 21 B0 ; Logical AND ($B0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	eor ($1D.b,X)		; 41 1D ; Exclusive OR accumulator with memory ($1D.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc ($14.b)		; F2 14 ; Subtract with carry (indirect) ($14.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda $00.b,S		; A3 00 ; Load accumulator (stack relative) $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $D2		; B0 D2 ; Branch if carry set to $B0, $D2 [Flow: branch]
	lda $404B21.l		; AF 21 4B 40 ; Load long $404B21.l into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $022A.w		; 0D 2A 02 ; Logical OR $022A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $B0, $13		; B0 13 ; Branch if carry set to $B0, $13 [Flow: branch]
	ldy $11.b,X		; B4 11 ; Load Y register $11.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	cmp ($A1.b),Y		; D1 A1 ; Compare accumulator ($A1.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	jsl $B0403C.l		; 22 3C 40 B0 ; Jump to subroutine long $B0403C.l [Writes: Stack Pointer] [Flow: call]
	ora $223B.w		; 0D 3B 22 ; Logical OR $223B.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and ($C3.b,X)		; 21 C3 ; Logical AND ($C3.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $B0C3D3.l,X		; FF D3 C3 B0 ; Subtract with carry (long,X) $B0C3D3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($0E.b)		; 12 0E ; OR accumulator with memory (indirect) ($0E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $313C0F.l,X		; 3F 0F 3C 31 ; AND accumulator with memory (long,X) $313C0F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rol $B0F2.w,X		; 3E F2 B0 ; Rotate left $B0F2.w,X [Reads: X Index] [Flags: NCZ]
	sbc $25C3F1.l,X		; FF F1 C3 25 ; Subtract with carry (long,X) $25C3F1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($1F.b,X)		; E1 1F ; Subtract with carry ($1F.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $EC		; F0 EC ; Branch if equal to $F0, $EC [Flow: branch]
	.db $B0, $21		; B0 21 ; Branch if carry set to $B0, $21 [Flow: branch]
	jmp $0020.w		; 4C 20 00 ; Jump to $0020.w [Flow: jump]
	trb $24E3.w		; 1C E3 24 ; Test and reset bits $24E3.w [Reads: Accumulator] [Flags: Z]
	lda ($B0.b)		; B2 B0 ; Load accumulator (indirect) ($B0.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $F2		; F0 F2 ; Branch if equal to $F0, $F2 [Flow: branch]
	cmp ($32.b,X)		; C1 32 ; Compare accumulator ($32.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	and $B01B0F.l,X		; 3F 0F 1B B0 ; AND accumulator with memory (long,X) $B01B0F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($20.b),Y		; 11 20 ; OR accumulator with memory ($20.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
.ACCU 16
	rep #$EF		; C2 EF
	sbc ($C2.b),Y		; F1 C2 ; Subtract with carry ($C2.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	trb $F0.b		; 14 F0 ; Test and reset bits $F0.b [Reads: Accumulator] [Flags: Z]
	.db $B0, $3F		; B0 3F ; Branch if carry set to $B0, $3F [Flow: branch]
	.db $F0, $FE		; F0 FE ; Branch if equal to $F0, $FE [Flow: branch]
	and ($4D.b)		; 32 4D ; AND accumulator with memory (indirect) ($4D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $EE		; 10 EE ; Branch if plus to $10, $EE [Flow: branch]
	tsb $F2B0.w		; 0C B0 F2 ; Test and set bits $F2B0.w [Reads: Accumulator] [Flags: Z]
	and $C2.b,S		; 23 C2 ; AND accumulator with stack relative $C2.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $23C2F1.l,X		; FF F1 C2 23 ; Subtract with carry (long,X) $23C2F1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $4CA0.w		; 0D A0 4C ; Logical OR $4CA0.w with accumulator [Writes: Accumulator] [Flags: NZ]
	dec $63FA.w,X		; DE FA 63 ; Decrement memory $63FA.w,X [Reads: X Index] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora ($DD.b,S),Y		; 13 DD ; OR accumulator (stack relative indirect indexed) ($DD.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora #$E3B0.w		; 09 B0 E3 ; Logical OR #$E3B0.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $F000B1.l		; 22 B1 00 F0 ; Jump to subroutine long $F000B1.l [Writes: Stack Pointer] [Flow: call]
	lda ($33.b),Y		; B1 33 ; Load accumulator ($33.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $3FB0.w		; 1C B0 3F ; Test and reset bits $3FB0.w [Reads: Accumulator] [Flags: Z]
	sbc $3F212D.l,X		; FF 2D 21 3F ; Subtract with carry (long,X) $3F212D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($FF.b,S),Y		; F3 FF ; Subtract with carry (stack relative indirect indexed) ($FF.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	brk $B0.b		; 00 B0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($13.b)		; D2 13 ; Compare accumulator (indirect) ($13.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp ($2F.b),Y		; D1 2F ; Compare accumulator ($2F.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	.db $F0, $DF		; F0 DF ; Branch if equal to $F0, $DF [Flow: branch]
	and ($3D.b)		; 32 3D ; AND accumulator with memory (indirect) ($3D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $30		; B0 30 ; Branch if carry set to $B0, $30 [Flow: branch]
	inc $120B.w,X		; FE 0B 12 ; Increment memory $120B.w,X [Reads: X Index] [Flags: NZ]
	and ($D2.b),Y		; 31 D2 ; AND accumulator with memory ($D2.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	inc $B0E0.w		; EE E0 B0 ; Increment $B0E0.w [Flags: NZ]
.INDEX 16
	rep #$13		; C2 13
	sbc $EDEF1E.l		; EF 1E EF ED ; Subtract with carry (long) $EDEF1E.l [Writes: Accumulator] [Flags: NCVZ]
	and ($4D.b)		; 32 4D ; AND accumulator with memory (indirect) ($4D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $21		; B0 21 ; Branch if carry set to $B0, $21 [Flow: branch]
	ora $22031C.l		; 0F 1C 03 22 ; OR accumulator with memory (long) $22031C.l [Writes: Accumulator] [Flags: NZ]
	lda ($F0.b),Y		; B1 F0 ; Load accumulator ($F0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($B0.b)		; F2 B0 ; Subtract with carry (indirect) ($B0.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp ($13.b,X)		; C1 13 ; Compare accumulator ($13.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	asl $FF2F.w,X		; 1E 2F FF ; Arithmetic shift left $FF2F.w,X [Reads: X Index] [Flags: NCZ]
	and $3F20.w		; 2D 20 3F ; Logical AND $3F20.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$ED24.w		; A0 24 ED ; Load #$ED24.w into Y register [Writes: Y Index] [Flags: NZ]
	ora $A427A5.l		; 0F A5 27 A4 ; OR accumulator with memory (long) $A427A5.l [Writes: Accumulator] [Flags: NZ]
	and $EFB0D2.l		; 2F D2 B0 EF ; AND accumulator with memory (long) $EFB0D2.l [Writes: Accumulator] [Flags: NZ]
	and ($3C.b)		; 32 3C ; AND accumulator with memory (indirect) ($3C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $1C0E.w		; 20 0E 1C ; Jump to subroutine at $1C0E.w [Writes: Stack Pointer] [Flow: call]
	cop $23.b		; 02 23 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $B0, $C2		; B0 C2 ; Branch if carry set to $B0, $C2 [Flow: branch]
	ora ($E2.b,X)		; 01 E2 ; Logical OR ($E2.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
.ACCU 16
	rep #$23		; C2 23
	and $0E2F.w		; 2D 2F 0E ; Logical AND $0E2F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $B0, $2B		; B0 2B ; Branch if carry set to $B0, $2B [Flow: branch]
	and ($20.b,X)		; 21 20 ; Logical AND ($20.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $01.b,S		; E3 01 ; Subtract stack-relative $01.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	sbc ($C2.b,S),Y		; F3 C2 ; Subtract with carry (stack relative indirect indexed) ($C2.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $A0.b,S		; 03 A0 ; OR accumulator with stack relative $A0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $49FE4E.l,X		; FF 4E FE 49 ; Subtract with carry (long,X) $49FE4E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($6B.b),Y		; 51 6B ; Exclusive OR accumulator with memory ($6B.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cop $EE.b		; 02 EE ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy #$94F2.w		; A0 F2 94 ; Load #$94F2.w into Y register [Writes: Y Index] [Flags: NZ]
	ora [$A1.b],Y		; 17 A1 ; OR accumulator with memory (long indexed) [$A1.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $410BE0.l,X		; 1F E0 0B 41 ; Logical OR long $410BE0.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldy #$207A.w		; A0 7A 20 ; Load #$207A.w into Y register [Writes: Y Index] [Flags: NZ]
	sbc $B31F.w,X		; FD 1F B3 ; Subtract with carry $B31F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$92.b],Y		; 17 92 ; OR accumulator with memory (long indexed) [$92.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($DC.b)		; D2 DC ; Compare accumulator (indirect) ($DC.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	and ($7A.b)		; 32 7A ; AND accumulator with memory (indirect) ($7A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $30, $1D		; 30 1D ; Branch if minus to $30, $1D [Flow: branch]
	bit $B0D3.w,X		; 3C D3 B0 ; Test bits $B0D3.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	ora ($C1.b,S),Y		; 13 C1 ; OR accumulator (stack relative indirect indexed) ($C1.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $11DED1.l,X		; FF D1 DE 11 ; Subtract with carry (long,X) $11DED1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $B010.w,X		; 3C 10 B0 ; Test bits $B010.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	asl $E11D.w,X		; 1E 1D E1 ; Arithmetic shift left $E11D.w,X [Reads: X Index] [Flags: NCZ]
	ora ($C1.b,S),Y		; 13 C1 ; OR accumulator (stack relative indirect indexed) ($C1.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($F2.b,X)		; 01 F2 ; Logical OR ($F2.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	inc $11B0.w		; EE B0 11 ; Increment $11B0.w [Flags: NZ]
	bit $1F10.w,X		; 3C 10 1F ; Test bits $1F10.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	and $D203E1.l		; 2F E1 03 D2 ; AND accumulator with memory (long) $D203E1.l [Writes: Accumulator] [Flags: NZ]
	ldy #$C111.w		; A0 11 C1 ; Load #$C111.w into Y register [Writes: Y Index] [Flags: NZ]
	jsr ($6A20.w,X)		; FC 20 6A ; Jump to subroutine indirect indexed ($6A20.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr $100C.w		; 20 0C 10 ; Jump to subroutine at $100C.w [Writes: Stack Pointer] [Flow: call]
	ldy #$06B2.w		; A0 B2 06 ; Load #$06B2.w into Y register [Writes: Y Index] [Flags: NZ]
	ldx #$E011.w		; A2 11 E0 ; Load #$E011.w into X register [Writes: X Index] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	and $10A06B.l,X		; 3F 6B A0 10 ; AND accumulator with memory (long,X) $10A06B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $93D2.w,X		; FD D2 93 ; Subtract with carry $93D2.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $D1.b,X		; F6 D1 ; Increment memory $D1.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	jsr $B0FC.w		; 20 FC B0 ; Jump to subroutine at $B0FC.w [Writes: Stack Pointer] [Flow: call]
	bit $3E20.w		; 2C 20 3E ; Test bits $3E20.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	sbc ($01.b),Y		; F1 01 ; Subtract with carry ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $C2.b,S		; E3 C2 ; Subtract stack-relative $C2.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	sbc ($B0.b)		; F2 B0 ; Subtract with carry (indirect) ($B0.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $4C1E1F.l		; 0F 1F 1E 4C ; OR accumulator with memory (long) $4C1E1F.l [Writes: Accumulator] [Flags: NZ]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	cmp ($02.b)		; D2 02 ; Compare accumulator (indirect) ($02.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ldy #$90B6.w		; A0 B6 90 ; Load #$90B6.w into Y register [Writes: Y Index] [Flags: NZ]
	ora ($49.b,S),Y		; 13 49 ; OR accumulator (stack relative indirect indexed) ($49.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $5C3B.w,X		; 3E 3B 5C ; Rotate left $5C3B.w,X [Reads: X Index] [Flags: NCZ]
	sbc ($B0.b,X)		; E1 B0 ; Subtract with carry ($B0.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($C1.b,S),Y		; 13 C1 ; OR accumulator (stack relative indirect indexed) ($C1.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc ($E2.b)		; F2 E2 ; Subtract with carry (indirect) ($E2.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $2F4D10.l		; 0F 10 4D 2F ; OR accumulator with memory (long) $2F4D10.l [Writes: Accumulator] [Flags: NZ]
	ldy #$014C.w		; A0 4C 01 ; Load #$014C.w into Y register [Writes: Y Index] [Flags: NZ]
	cpy $E7.b		; C4 E7 ; Compare $E7.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	lda $E3.b,S		; A3 E3 ; Load accumulator (stack relative) $E3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $2EB04A.l		; EF 4A B0 2E ; Subtract with carry (long) $2EB04A.l [Writes: Accumulator] [Flags: NCVZ]
	rol $1020.w,X		; 3E 20 10 ; Rotate left $1020.w,X [Reads: X Index] [Flags: NCZ]
	sbc ($C2.b,S),Y		; F3 C2 ; Subtract with carry (stack relative indirect indexed) ($C2.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	pea $A0FF.w		; F4 FF A0 ; Push absolute address $A0FF.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sbc ($2C.b),Y		; F1 2C ; Subtract with carry ($2C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc #$512D.w		; 69 2D 51 ; Add #$512D.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp ($F2.b),Y		; D1 F2 ; Compare accumulator ($F2.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	ldy $A0.b		; A4 A0 ; Load $A0.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	cpy #$4CE2.w		; C0 E2 4C ; Compare #$4CE2.w with Y register [Reads: Y Index] [Flags: NCZ]
	rol $1F3B.w		; 2E 3B 1F ; Rotate left $1F3B.w [Flags: NCZ]
	sbc ($05.b,X)		; E1 05 ; Subtract with carry ($05.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy #$E3C2.w		; A0 C2 E3 ; Load #$E3C2.w into Y register [Writes: Y Index] [Flags: NZ]
	cpx #$2F2B.w		; E0 2B 2F ; Compare #$2F2B.w with X register [Reads: X Index] [Flags: NCZ]
	ror $2F1F.w		; 6E 1F 2F ; Rotate right $2F1F.w [Flags: NCZ]
	ldy #$B1E4.w		; A0 E4 B1 ; Load #$B1E4.w into Y register [Writes: Y Index] [Flags: NZ]
	sbc $0E.b		; E5 0E ; Subtract $0E.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $1D		; F0 1D ; Branch if equal to $F0, $1D [Flow: branch]
	eor $A00E.w		; 4D 0E A0 ; Exclusive OR $A00E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and ($D1.b)		; 32 D1 ; AND accumulator with memory (indirect) ($D1.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $D1.b,S		; 03 D1 ; OR accumulator with stack relative $D1.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $4D11.w,X		; FE 11 4D ; Increment memory $4D11.w,X [Reads: X Index] [Flags: NZ]
	ora $F23EA0.l,X		; 1F A0 3E F2 ; Logical OR long $F23EA0.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($F4.b,X)		; C1 F4 ; Compare accumulator ($F4.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	.db $F0, $02		; F0 02 ; Branch if equal to $F0, $02 [Flow: branch]
	asl $903D.w		; 0E 3D 90 ; Arithmetic shift left $903D.w [Flags: NCZ]
	ora $B061.w		; 0D 61 B0 ; Logical OR $B061.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($B3.b)		; 12 B3 ; OR accumulator with memory (indirect) ($B3.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $4A02.w,X		; FD 02 4A ; Subtract with carry $4A02.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy #$2E10.w		; A0 10 2E ; Load #$2E10.w into Y register [Writes: Y Index] [Flags: NZ]
	sbc ($C0.b),Y		; F1 C0 ; Subtract with carry ($C0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($F0.b,S),Y		; F3 F0 ; Subtract with carry (stack relative indirect indexed) ($F0.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora ($FE.b,X)		; 01 FE ; Logical OR ($FE.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $90, $5B		; 90 5B ; Branch if carry clear to $90, $5B [Flow: branch]
	asl $B041.w		; 0E 41 B0 ; Arithmetic shift left $B041.w [Flags: NCZ]
	sbc ($C2.b),Y		; F1 C2 ; Subtract with carry ($C2.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($9002.w,X)		; FC 02 90 ; Jump to subroutine indirect indexed ($9002.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jmp $E43D20.l		; 5C 20 3D E4 ; Jump long to $E43D20.l [Flow: jump]
	lda ($E6.b),Y		; B1 E6 ; Load accumulator ($E6.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $0C90E1.l,X		; 1F E1 90 0C ; Logical OR long $0C90E1.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $430F.w,X		; 3D 0F 43 ; AND accumulator with memory $430F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($02.b),Y		; D1 02 ; Compare accumulator ($02.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	.db $D0, $1B		; D0 1B ; Branch if not equal to $D0, $1B [Flow: branch]
	.db $90, $00		; 90 00 ; Branch if carry clear to $90, $00 [Flow: branch]
	adc $D43F0F.l		; 6F 0F 3F D4 ; Add with carry (long) $D43F0F.l [Writes: Accumulator] [Flags: NCVZ]
	sbc ($F5.b,X)		; E1 F5 ; Subtract with carry ($F5.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $0090.w		; 2E 90 00 ; Rotate left $0090.w [Flags: NCZ]
	ora $CE10.w,X		; 1D 10 CE ; OR accumulator with memory $CE10.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $E0.b,X		; 15 E0 ; OR accumulator with memory $E0.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($ED.b,S),Y		; F3 ED ; Subtract with carry (stack relative indirect indexed) ($ED.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $90, $2C		; 90 2C ; Branch if carry clear to $90, $2C [Flow: branch]
	ora $11DF40.l		; 0F 40 DF 11 ; OR accumulator with memory (long) $11DF40.l [Writes: Accumulator] [Flags: NZ]
	cmp ($0D.b),Y		; D1 0D ; Compare accumulator ($0D.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	sbc ($90.b,S),Y		; F3 90 ; Subtract with carry (stack relative indirect indexed) ($90.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	lsr $3F00.w,X		; 5E 00 3F ; Logical shift right $3F00.w,X [Reads: X Index] [Flags: NCZ]
.INDEX 8
	sep #$D1		; E2 D1
	pea $F11E.w		; F4 1E F1 ; Push absolute address $F11E.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	.db $90, $2E		; 90 2E ; Branch if carry clear to $90, $2E [Flow: branch]
	.db $10, $E0		; 10 E0 ; Branch if plus to $10, $E0 [Flow: branch]
	and $E0.b,X		; 35 E0 ; Logical AND $E0.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cop $EE.b		; 02 EE ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $1F90.w,X		; 3E 90 1F ; Rotate left $1F90.w,X [Reads: X Index] [Flags: NCZ]
	and ($F0.b),Y		; 31 F0 ; AND accumulator with memory ($F0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($F1.b)		; 12 F1 ; OR accumulator with memory (indirect) ($F1.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $50E0.w,X		; 1D E0 50 ; OR accumulator with memory $50E0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	lsr $DEB4.w,X		; 5E B4 DE ; Logical shift right $DEB4.w,X [Reads: X Index] [Flags: NCZ]
	asl $2B.b		; 06 2B ; Arithmetic shift left $2B.b [Reads: Direct Page] [Flags: NCZ]
	brk $2D.b		; 00 2D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $02		; 90 02 ; Branch if carry clear to $90, $02 [Flow: branch]
	sbc ($04.b,X)		; E1 04 ; Subtract with carry ($04.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $100DF2.l		; 0F F2 0D 10 ; OR accumulator with memory (long) $100DF2.l [Writes: Accumulator] [Flags: NZ]
	sbc $EF5780.l		; EF 80 57 EF ; Subtract with carry (long) $EF5780.l [Writes: Accumulator] [Flags: NCVZ]
	bit $DD.b		; 24 DD ; Test bits $DD.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $10, $51		; 10 51 ; Branch if plus to $10, $51 [Flow: branch]
	inc $0280.w		; EE 80 02 ; Increment $0280.w [Flags: NZ]
	cmp ($2D.b),Y		; D1 2D ; Compare accumulator ($2D.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cpx #$70.b		; E0 70 ; Compare #$70.b with X register [Reads: X Index] [Flags: NCZ]
	cmp $80B24F.l,X		; DF 4F B2 80 ; Compare accumulator (long,X) $80B24F.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	inc $3C05.w		; EE 05 3C ; Increment $3C05.w [Flags: NZ]
	ora ($2D.b,X)		; 01 2D ; Logical OR ($2D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc ($C2.b,S),Y		; F3 C2 ; Subtract with carry (stack relative indirect indexed) ($C2.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	tsb $80.b		; 04 80 ; Test and set bits $80.b [Reads: Accumulator] [Flags: Z]
	ora $111DE0.l,X		; 1F E0 1D 11 ; Logical OR long $111DE0.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $0C05.w		; EE 05 0C ; Increment $0C05.w [Flags: NZ]
	sbc ($80.b,X)		; E1 80 ; Subtract with carry ($80.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($DF1E.w,X)		; FC 1E DF ; Jump to subroutine indirect indexed ($DF1E.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	mvp $11,$B1		; 44 B1 11 ; Move block positive $11,$B1 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cmp $01803E.l		; CF 3E 80 01 ; Compare accumulator (long) $01803E.l [Reads: Accumulator] [Flags: NCZ]
	eor ($E1.b),Y		; 51 E1 ; Exclusive OR accumulator with memory ($E1.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($E0.b),Y		; 11 E0 ; OR accumulator with memory ($E0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $4FE1.w,X		; 1D E1 4F ; OR accumulator with memory $4FE1.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $80, $F0		; 80 F0 ; Branch always to $80, $F0 [Flow: branch]
	sbc $F01DE0.l,X		; FF E0 1D F0 ; Subtract with carry (long,X) $F01DE0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr $3FFF.w,X		; 5E FF 3F ; Logical shift right $3FFF.w,X [Reads: X Index] [Flags: NCZ]
	.db $70, $B4		; 70 B4 ; Branch if overflow set to $70, $B4 [Flow: branch]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	cpy #$61.b		; C0 61 ; Compare #$61.b with Y register [Reads: Y Index] [Flags: NCZ]
	cmp $0FA55F.l		; CF 5F A5 0F ; Compare accumulator (long) $0FA55F.l [Reads: Accumulator] [Flags: NCZ]
	.db $70, $C0		; 70 C0 ; Branch if overflow set to $70, $C0 [Flow: branch]
	.db $50, $CF		; 50 CF ; Branch if overflow clear to $50, $CF [Flow: branch]
	lsr $B1E5.w		; 4E E5 B1 ; Logical shift right $B1E5.w [Flags: NCZ]
	ora $2C.b,X		; 15 2C ; OR accumulator with memory $2C.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $80, $10		; 80 10 ; Branch always to $80, $10 [Flow: branch]
	asl $1EF2.w,X		; 1E F2 1E ; Arithmetic shift left $1EF2.w,X [Reads: X Index] [Flags: NCZ]
.ACCU 8
.INDEX 8
	sep #$3D		; E2 3D
	cmp ($2E.b),Y		; D1 2E ; Compare accumulator ($2E.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	.db $70, $B4		; 70 B4 ; Branch if overflow set to $70, $B4 [Flow: branch]
	cmp ($F1.b)		; D2 F1 ; Compare accumulator (indirect) ($F1.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora ($E0.b,X)		; 01 E0 ; Logical OR ($E0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rol $C1F3.w,X		; 3E F3 C1 ; Rotate left $C1F3.w,X [Reads: X Index] [Flags: NCZ]
	.db $70, $14		; 70 14 ; Branch if overflow set to $70, $14 [Flow: branch]
	and $2D10.w		; 2D 10 2D ; Logical AND $2D10.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $1D.b		; 04 1D ; Test and set bits $1D.b [Reads: Accumulator] [Flags: Z]
	inc $6C.b		; E6 6C ; Increment $6C.b [Reads: Direct Page] [Flags: NZ]
	.db $70, $D4		; 70 D4 ; Branch if overflow set to $70, $D4 [Flow: branch]
	eor $EFC4.w		; 4D C4 EF ; Exclusive OR $EFC4.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp ($3F.b)		; D2 3F ; Compare accumulator (indirect) ($3F.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sbc ($3D.b,X)		; E1 3D ; Subtract with carry ($3D.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $E3		; 70 E3 ; Branch if overflow set to $70, $E3 [Flow: branch]
	inc $2C15.w		; EE 15 2C ; Increment $2C15.w [Flags: NZ]
	and ($1D.b,X)		; 21 1D ; Logical AND ($1D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc ($0F.b,S),Y		; F3 0F ; Subtract with carry (stack relative indirect indexed) ($0F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $D4		; 70 D4 ; Branch if overflow set to $70, $D4 [Flow: branch]
	ror $3DE2.w		; 6E E2 3D ; Rotate right $3DE2.w [Flags: NCZ]
	cpx $FE.b		; E4 FE ; Compare $FE.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	pea $703D.w		; F4 3D 70 ; Push absolute address $703D.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	ora ($3E.b)		; 12 3E ; OR accumulator with memory (indirect) ($3E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sep #$0F		; E2 0F ; Set processor status bits #$0F [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	cmp ($4F.b),Y		; D1 4F ; Compare accumulator ($4F.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	sbc ($3F.b),Y		; F1 3F ; Subtract with carry ($3F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	stz $F4.b,X		; 74 F4 ; Store zero to $F4.b,X [Reads: X Index]
	cmp $210A15.l,X		; DF 15 0A 21 ; Compare accumulator (long,X) $210A15.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	trb $FE04.w		; 1C 04 FE ; Test and reset bits $FE04.w [Reads: Accumulator] [Flags: Z]
	.db $70, $D0		; 70 D0 ; Branch if overflow set to $70, $D0 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sbc $1ED22F.l		; EF 2F D2 1E ; Subtract with carry (long) $1ED22F.l [Writes: Accumulator] [Flags: NCVZ]
	cmp ($3D.b),Y		; D1 3D ; Compare accumulator ($3D.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpy #$6F.b		; C0 6F ; Compare #$6F.b with Y register [Reads: Y Index] [Flags: NCZ]
	cmp ($1D.b,S),Y		; D3 1D ; Compare accumulator (stack relative indirect indexed) ($1D.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	cmp $30DD60.l		; CF 60 DD 30 ; Compare accumulator (long) $30DD60.l [Reads: Accumulator] [Flags: NCZ]
	.db $70, $E1		; 70 E1 ; Branch if overflow set to $70, $E1 [Flow: branch]
	ora $4ED1.w		; 0D D1 4E ; Logical OR $4ED1.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp $0FE030.l,X		; DF 30 E0 0F ; Compare accumulator (long,X) $0FE030.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpx #$4F.b		; E0 4F ; Compare #$4F.b with X register [Reads: X Index] [Flags: NCZ]
	inc $C230.w		; EE 30 C2 ; Increment $C230.w [Flags: NZ]
	trb $7FB1.w		; 1C B1 7F ; Test and reset bits $7FB1.w [Reads: Accumulator] [Flags: Z]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $1ED140.l		; EF 40 D1 1E ; Subtract with carry (long) $1ED140.l [Writes: Accumulator] [Flags: NCVZ]
	cpx #$50.b		; E0 50 ; Compare #$50.b with X register [Reads: X Index] [Flags: NCZ]
	inc $6020.w,X		; FE 20 60 ; Increment memory $6020.w,X [Reads: X Index] [Flags: NZ]
	cmp ($2E.b),Y		; D1 2E ; Compare accumulator ($2E.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cpx #$50.b		; E0 50 ; Compare #$50.b with X register [Reads: X Index] [Flags: NCZ]
	inc $F132.w		; EE 32 F1 ; Increment $F132.w [Flags: NZ]
	and $F060.w		; 2D 60 F0 ; Logical AND $F060.w with accumulator [Writes: Accumulator] [Flags: NZ]
	eor ($0F.b,X)		; 41 0F ; Exclusive OR accumulator with memory ($0F.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($F1.b)		; 12 F1 ; OR accumulator with memory (indirect) ($F1.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $30F0.w,X		; 3E F0 30 ; Rotate left $30F0.w,X [Reads: X Index] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $3EF001.l,X		; FF 01 F0 3E ; Subtract with carry (long,X) $3EF001.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($50.b)		; F2 50 ; Subtract with carry (indirect) ($50.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $D0, $00		; D0 00 ; Branch if not equal to $D0, $00 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpx #$2E.b		; E0 2E ; Compare #$2E.b with X register [Reads: X Index] [Flags: NCZ]
	cmp $22D042.l,X		; DF 42 D0 22 ; Compare accumulator (long,X) $22D042.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	sbc $FF6020.l,X		; FF 20 60 FF ; Subtract with carry (long,X) $FF6020.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($DF.b,S),Y		; 33 DF ; AND accumulator (stack relative indirect indexed) ($DF.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($EE.b)		; 12 EE ; OR accumulator with memory (indirect) ($EE.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $EE.b		; 00 EE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $50.b		; 04 50 ; Test and set bits $50.b [Reads: Accumulator] [Flags: Z]
	ora $0C05.w		; 0D 05 0C ; Logical OR $0C05.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($DF.b)		; 12 DF ; OR accumulator with memory (indirect) ($DF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pea $E32F.w		; F4 2F E3 ; Push absolute address $E32F.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	.db $50, $4F		; 50 4F ; Branch if overflow clear to $50, $4F [Flow: branch]
	trb $CF.b		; 14 CF ; Test and reset bits $CF.b [Reads: Accumulator] [Flags: Z]
	bit $0F.b		; 24 0F ; Test bits $0F.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	.db $10, $1E		; 10 1E ; Branch if plus to $10, $1E [Flow: branch]
	sbc ($50.b,S),Y		; F3 50 ; Subtract with carry (stack relative indirect indexed) ($50.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	asl $4DF5.w		; 0E F5 4D ; Arithmetic shift left $4DF5.w [Flags: NCZ]
	cop $2F.b		; 02 2F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($1F.b),Y		; F1 1F ; Subtract with carry ($1F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F04150.l		; EF 50 41 F0 ; Subtract with carry (long) $F04150.l [Writes: Accumulator] [Flags: NCVZ]
	and ($E0.b),Y		; 31 E0 ; AND accumulator with memory ($E0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $2101.w,X		; 1D 01 21 ; OR accumulator with memory $2101.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $FF.b		; 14 FF ; Test and reset bits $FF.b [Reads: Accumulator] [Flags: Z]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cmp $23BF65.l,X		; DF 65 BF 23 ; Compare accumulator (long,X) $23BF65.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	inc $1340.w		; EE 40 13 ; Increment $1340.w [Flags: NZ]
	sbc $E23FF5.l,X		; FF F5 3F E2 ; Subtract with carry (long,X) $E23FF5.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $EF04.w		; 2D 04 EF ; Logical AND $EF04.w with accumulator [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	and $2E.b		; 25 2E ; Logical AND $2E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($2E.b)		; 12 2E ; OR accumulator with memory (indirect) ($2E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc ($1E.b)		; F2 1E ; Subtract with carry (indirect) ($1E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($4F.b,X)		; E1 4F ; Subtract with carry ($4F.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $DE		; 30 DE ; Branch if minus to $30, $DE [Flow: branch]
	and ($E1.b),Y		; 31 E1 ; AND accumulator with memory ($E1.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $51E2.w		; 6D E2 51 ; Add $51E2.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cpy #$23.b		; C0 23 ; Compare #$23.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $30, $DF		; 30 DF ; Branch if minus to $30, $DF [Flow: branch]
	jsl $FE15EF.l		; 22 EF 15 FE ; Jump to subroutine long $FE15EF.l [Writes: Stack Pointer] [Flow: call]
	sbc ($2E.b)		; F2 2E ; Subtract with carry (indirect) ($2E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($30.b,S),Y		; F3 30 ; Subtract with carry (stack relative indirect indexed) ($30.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc $3CF3.w,X		; FD F3 3C ; Subtract with carry $3CF3.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($3E.b,X)		; E1 3E ; Subtract with carry ($3E.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$2D.b		; E0 2D ; Compare #$2D.b with X register [Reads: X Index] [Flags: NCZ]
	sbc ($20.b),Y		; F1 20 ; Subtract with carry ($20.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $D002D0.l,X		; 5F D0 02 D0 ; Exclusive OR accumulator with memory (long,X) $D002D0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($BE.b,X)		; 21 BE ; Logical AND ($BE.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$0E.b],Y		; 17 0E ; OR accumulator with memory (long indexed) [$0E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsr $2C04.w		; 20 04 2C ; Jump to subroutine at $2C04.w [Writes: Stack Pointer] [Flow: call]
	sbc $0D.b,S		; E3 0D ; Subtract stack-relative $0D.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	sbc ($4C.b,S),Y		; F3 4C ; Subtract with carry (stack relative indirect indexed) ($4C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($4F.b)		; F2 4F ; Subtract with carry (indirect) ($4F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $D1		; 10 D1 ; Branch if plus to $10, $D1 [Flow: branch]
	jmp $B072C2.l		; 5C C2 72 B0 ; Jump long to $B072C2.l [Flow: jump]
	cop $E1.b		; 02 E1 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($10.b,S),Y		; 13 10 ; OR accumulator (stack relative indirect indexed) ($10.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpy #$24.b		; C0 24 ; Compare #$24.b with Y register [Reads: Y Index] [Flags: NCZ]
	ora $101F10.l		; 0F 10 1F 10 ; OR accumulator with memory (long) $101F10.l [Writes: Accumulator] [Flags: NZ]
	asl $0011.w,X		; 1E 11 00 ; Arithmetic shift left $0011.w,X [Reads: X Index] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sbc ($01.b),Y		; F1 01 ; Subtract with carry ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: NCZ]
	.db $D0, $01		; D0 01 ; Branch if not equal to $D0, $01 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stx $DF.b,Y		; 96 DF ; Store X register $DF.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	and $33CE12.l		; 2F 12 CE 33 ; AND accumulator with memory (long) $33CE12.l [Writes: Accumulator] [Flags: NZ]
	ora ($24.b),Y		; 11 24 ; OR accumulator with memory ($24.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$92.b		; C0 92 ; Compare #$92.b with Y register [Reads: Y Index] [Flags: NCZ]
	sbc $0021E1.l		; EF E1 21 00 ; Subtract with carry (long) $0021E1.l [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $BC		; F0 BC ; Branch if equal to $F0, $BC [Flow: branch]
	and ($FC.b),Y		; 31 FC ; AND accumulator with memory ($FC.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	ora ($F5.b,S),Y		; 13 F5 ; OR accumulator (stack relative indirect indexed) ($F5.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	mvn $20,$FF		; 54 FF 20 ; Move block negative $20,$FF [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	lda ($C6.b),Y		; B1 C6 ; Load accumulator ($C6.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ldx #$0E.b		; A2 0E ; Load #$0E.b into X register [Writes: X Index] [Flags: NZ]
	and ($10.b,X)		; 21 10 ; Logical AND ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $3D23EE.l,X		; FF EE 23 3D ; Subtract with carry (long,X) $3D23EE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ldx $04.b		; A6 04 ; Load $04.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	and $11D2.w		; 2D D2 11 ; Logical AND $11D2.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and ($0F.b,S),Y		; 33 0F ; AND accumulator (stack relative indirect indexed) ($0F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0C		; D0 0C ; Branch if not equal to $D0, $0C [Flow: branch]
	ldx #$32.b		; A2 32 ; Load #$32.b into X register [Writes: X Index] [Flags: NZ]
	sbc $E5DDEE.l,X		; FF EE DD E5 ; Subtract with carry (long,X) $E5DDEE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr $BFCC.w		; 4E CC BF ; Logical shift right $BFCC.w [Flags: NCZ]
	ldx $40.b		; A6 40 ; Load $40.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	lda ($20.b,X)		; A1 20 ; Load accumulator ($20.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $1C.b,X		; 15 1C ; OR accumulator with memory $1C.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$0C.b		; E0 0C ; Compare #$0C.b with X register [Reads: X Index] [Flags: NCZ]
	eor $B6.b,S		; 43 B6 ; Exclusive OR accumulator with stack relative $B6.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $F400F1.l,X		; FF F1 00 F4 ; Subtract with carry (long,X) $F400F1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $13DE.w,X		; 1D DE 13 ; OR accumulator with memory $13DE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($B6.b)		; 12 B6 ; OR accumulator with memory (indirect) ($B6.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $00		; D0 00 ; Branch if not equal to $D0, $00 [Flow: branch]
	and ($1F.b,X)		; 21 1F ; Logical AND ($1F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc ($FF.b),Y		; F1 FF ; Subtract with carry ($FF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($0E.b,S),Y		; F3 0E ; Subtract with carry (stack relative indirect indexed) ($0E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ldx $E0.b,Y		; B6 E0 ; Load X register $E0.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	and $CC3DF3.l		; 2F F3 3D CC ; AND accumulator with memory (long) $CC3DF3.l [Writes: Accumulator] [Flags: NZ]
	and $14.b,S		; 23 14 ; AND accumulator with stack relative $14.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $10E0A6.l		; EF A6 E0 10 ; Subtract with carry (long) $10E0A6.l [Writes: Accumulator] [Flags: NCVZ]
	bit $FF.b,X		; 34 FF ; Test bits $FF.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
.ACCU 16
.INDEX 16
	rep #$F0		; C2 F0
	eor $B6BE.w		; 4D BE B6 ; Exclusive OR $B6BE.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and ($D2.b,X)		; 21 D2 ; Logical AND ($D2.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor $F1BF.w		; 4D BF F1 ; Exclusive OR $F1BF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $0E.b		; 25 0E ; Logical AND $0E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $A6		; F0 A6 ; Branch if equal to $F0, $A6 [Flow: branch]
	pea $0133.w		; F4 33 01 ; Push absolute address $0133.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	ldx $71EF.w,Y		; BE EF 71 ; Load X register $71EF.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	cmp #$A624.w		; C9 24 A6 ; Compare #$A624.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora $F0CA1F.l,X		; 1F 1F CA F0 ; Logical OR long $F0CA1F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $42, $BE		; 62 42 BE ; Push effective relative address $62, $42, $BE [Writes: Stack Pointer]
	ora ($A6.b,S),Y		; 13 A6 ; OR accumulator (stack relative indirect indexed) ($A6.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($01.b,S),Y		; 33 01 ; AND accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $F957FD.l		; AF FD 57 F9 ; Load long $F957FD.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp ($30.b),Y		; D1 30 ; Compare accumulator ($30.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	ldx $C3.b		; A6 C3 ; Load $C3.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	jmp.w [$6FEE]		; DC EE 6F ; Jump long indirect [$6FEE] [Flow: jump]
	mvn $D6,$CC		; 54 CC D6 ; Move block negative $D6,$CC [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	eor $63A6.w,X		; 5D A6 63 ; Exclusive OR accumulator with memory $63A6.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda $6BE40D.l,X		; BF 0D E4 6B ; Load long $6BE40D.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($4D.b,X)		; C1 4D ; Compare accumulator ($4D.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	cmp ($B2.b,X)		; C1 B2 ; Compare accumulator ($B2.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	cmp $02CA.w		; CD CA 02 ; Compare $02CA.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora $4312F0.l		; 0F F0 12 43 ; OR accumulator with memory (long) $4312F0.l [Writes: Accumulator] [Flags: NZ]
	ldx #$4E54.w		; A2 54 4E ; Load #$4E54.w into X register [Writes: X Index] [Flags: NZ]
	cpy $53.b		; C4 53 ; Compare $53.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	and $BCCA43.l		; 2F 43 CA BC ; AND accumulator with memory (long) $BCCA43.l [Writes: Accumulator] [Flags: NZ]
	lda ($CC.b)		; B2 CC ; Load accumulator (indirect) ($CC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$22D3]		; DC D3 22 ; Jump long indirect [$22D3] [Flow: jump]
	cmp $22F0.w		; CD F0 22 ; Compare $22F0.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	and $B6.b,S		; 23 B6 ; AND accumulator with stack relative $B6.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0E1FD3.l		; 0F D3 1F 0E ; OR accumulator with memory (long) $0E1FD3.l [Writes: Accumulator] [Flags: NZ]
	jsl $FD01CE.l		; 22 CE 01 FD ; Jump to subroutine long $FD01CE.l [Writes: Stack Pointer] [Flow: call]
	ldx $2F.b		; A6 2F ; Load $2F.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	bit $32.b		; 24 32 ; Test bits $32.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	asl $6D.b,X		; 16 6D ; Arithmetic shift left $6D.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	jsl $EFB61E.l		; 22 1E B6 EF ; Jump to subroutine long $EFB61E.l [Writes: Stack Pointer] [Flow: call]
	jsr $012D.w		; 20 2D 01 ; Jump to subroutine at $012D.w [Writes: Stack Pointer] [Flow: call]
	tsb $0ED2.w		; 0C D2 0E ; Test and set bits $0ED2.w [Reads: Accumulator] [Flags: Z]
	ora $3021B6.l,X		; 1F B6 21 30 ; Logical OR long $3021B6.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $10E4.w		; EE E4 10 ; Increment $10E4.w [Flags: NZ]
	and ($0F.b,X)		; 21 0F ; Logical AND ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpx #$15A6.w		; E0 A6 15 ; Compare #$15A6.w with X register [Reads: X Index] [Flags: NCZ]
	asl $FA0F.w		; 0E 0F FA ; Arithmetic shift left $FA0F.w [Flags: NCZ]
	lda ($D0.b)		; B2 D0 ; Load accumulator (indirect) ($D0.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $B24D.w		; 2E 4D B2 ; Rotate left $B24D.w [Flags: NCZ]
	cmp ($FF.b,S),Y		; D3 FF ; Compare accumulator (stack relative indirect indexed) ($FF.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	ldy #$3543.w		; A0 43 35 ; Load #$3543.w into Y register [Writes: Y Index] [Flags: NZ]
	bit $0F.b,X		; 34 0F ; Test bits $0F.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora $B6.b		; 05 B6 ; Logical OR $B6.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0E00.w,X		; 1D 00 0E ; OR accumulator with memory $0E00.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
.ACCU 16
.INDEX 16
	rep #$F0		; C2 F0
	ora $B2F50F.l		; 0F 0F F5 B2 ; OR accumulator with memory (long) $B2F50F.l [Writes: Accumulator] [Flags: NZ]
	cpx #$20BC.w		; E0 BC 20 ; Compare #$20BC.w with X register [Reads: X Index] [Flags: NCZ]
	ora ($43.b,S),Y		; 13 43 ; OR accumulator (stack relative indirect indexed) ($43.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $B26604.l		; 0F 04 66 B2 ; OR accumulator with memory (long) $B26604.l [Writes: Accumulator] [Flags: NZ]
	.db $42, $12		; 42 12 ; Reserved instruction
	cmp $DEDD.w,X		; DD DD DE ; Compare accumulator $DEDD.w,X [Reads: X Index] [Flags: NCZ]
	jmp.w [$EFCF]		; DC CF EF ; Jump long indirect [$EFCF] [Flow: jump]
	ldx $EE.b,Y		; B6 EE ; Load X register $EE.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	jsr $E011.w		; 20 11 E0 ; Jump to subroutine at $E011.w [Writes: Stack Pointer] [Flow: call]
	sbc ($11.b,S),Y		; F3 11 ; Subtract with carry (stack relative indirect indexed) ($11.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $DCCFA6.l,X		; 1F A6 CF DC ; Logical OR long $DCCFA6.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	pea $9D32.w		; F4 32 9D ; Push absolute address $9D32.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	ldx $51.b		; A6 51 ; Load $51.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	eor $E6.b,S		; 43 E6 ; Exclusive OR accumulator with stack relative $E6.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $F7		; B0 F7 ; Branch if carry set to $B0, $F7 [Flow: branch]
	eor $FD.b,X		; 55 FD ; Exclusive OR accumulator with memory $FD.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sta $DE2BA6.l,X		; 9F A6 2B DE ; Store accumulator (long,X) $DE2BA6.l,X [Reads: Accumulator, X Index]
	cmp $EA.b,S		; C3 EA ; Compare accumulator (stack relative) $EA.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	asl $B623.w		; 0E 23 B6 ; Arithmetic shift left $B623.w [Flags: NCZ]
	ora ($D5.b),Y		; 11 D5 ; OR accumulator with memory ($D5.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $3211.w		; 0E 11 32 ; Arithmetic shift left $3211.w [Flags: NCZ]
	jsr $21AD.w		; 20 AD 21 ; Jump to subroutine at $21AD.w [Writes: Stack Pointer] [Flow: call]
	ldx $DD.b,Y		; B6 DD ; Load X register $DD.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	brk $1D.b		; 00 1D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
.INDEX 8
	sep #$11		; E2 11
	ora $B6400F.l		; 0F 0F 40 B6 ; OR accumulator with memory (long) $B6400F.l [Writes: Accumulator] [Flags: NZ]
	ora ($1D.b,X)		; 01 1D ; Logical OR ($1D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsr $3243.w		; 20 43 32 ; Jump to subroutine at $3243.w [Writes: Stack Pointer] [Flow: call]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	eor ($DB.b,X)		; 41 DB ; Exclusive OR accumulator with memory ($DB.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ldx $F0.b		; A6 F0 ; Load $F0.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	sbc $EFD1.w,X		; FD D1 EF ; Subtract with carry $EFD1.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr $63FF.w,X		; 5E FF 63 ; Logical shift right $63FF.w,X [Reads: X Index] [Flags: NCZ]
	sbc $B6.b,S		; E3 B6 ; Subtract stack-relative $B6.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	rol $1400.w,X		; 3E 00 14 ; Rotate left $1400.w,X [Reads: X Index] [Flags: NCZ]
	and $EB.b,S		; 23 EB ; AND accumulator with stack relative $EB.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($0E.b,X)		; 01 0E ; Logical OR ($0E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpx #$B6.b		; E0 B6 ; Compare #$B6.b with X register [Reads: X Index] [Flags: NCZ]
	sbc $0E0F.w,X		; FD 0F 0E ; Subtract with carry $0E0F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $50, $FF		; 50 FF ; Branch if overflow clear to $50, $FF [Flow: branch]
	ora ($F1.b,X)		; 01 F1 ; Logical OR ($F1.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $2211B6.l		; 2F B6 11 22 ; AND accumulator with memory (long) $2211B6.l [Writes: Accumulator] [Flags: NZ]
	jsl $2BF11C.l		; 22 1C F1 2B ; Jump to subroutine long $2BF11C.l [Writes: Stack Pointer] [Flow: call]
	.db $D0, $FC		; D0 FC ; Branch if not equal to $D0, $FC [Flow: branch]
	ldx $0F.b		; A6 0F ; Load $0F.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	eor #$A355.w		; 49 55 A3 ; Exclusive OR #$A355.w with accumulator [Writes: Accumulator] [Flags: NZ]
	pea $4EE0.w		; F4 E0 4E ; Push absolute address $4EE0.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	mvp $2E,$B6		; 44 B6 2E ; Move block positive $2E,$B6 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora ($4E.b,S),Y		; 13 4E ; OR accumulator (stack relative indirect indexed) ($4E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $C220.w		; EE 20 C2 ; Increment $C220.w [Flags: NZ]
	sbc $B6D0.w		; ED D0 B6 ; Subtract $B6D0.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	tsb $F113.w		; 0C 13 F1 ; Test and set bits $F113.w [Reads: Accumulator] [Flags: Z]
	sbc ($20.b,X)		; E1 20 ; Subtract with carry ($20.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	and ($4F.b,S),Y		; 33 4F ; AND accumulator (stack relative indirect indexed) ($4F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldx $D3.b,Y		; B6 D3 ; Load X register $D3.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	and ($FB.b)		; 32 FB ; AND accumulator with memory (indirect) ($FB.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $FE.b		; 02 FE ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $3DDC.w,X		; DE DC 3D ; Decrement memory $3DDC.w,X [Reads: X Index] [Flags: NZ]
	ldx $1F.b,Y		; B6 1F ; Load X register $1F.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	and ($0D.b,S),Y		; 33 0D ; AND accumulator (stack relative indirect indexed) ($0D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr $333C.w		; 20 3C 33 ; Jump to subroutine at $333C.w [Writes: Stack Pointer] [Flow: call]
	.db $50, $A2		; 50 A2 ; Branch if overflow clear to $50, $A2 [Flow: branch]
	ldx $52.b,Y		; B6 52 ; Load X register $52.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	trb $0D10.w		; 1C 10 0D ; Test and reset bits $0D10.w [Reads: Accumulator] [Flags: Z]
	inc $30CA.w		; EE CA 30 ; Increment $30CA.w [Flags: NZ]
	ora $24B6.w,X		; 1D B6 24 ; OR accumulator with memory $24B6.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $2D22.w,X		; FD 22 2D ; Subtract with carry $2D22.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $41.b,X		; 15 41 ; OR accumulator with memory $41.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ldx $CA63.w		; AE 63 CA ; Load $CA63.w into X register [Writes: X Index] [Flags: NZ]
	ora $FF21.w		; 0D 21 FF ; Logical OR $FF21.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($FE.b,X)		; 01 FE ; Logical OR ($FE.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $30, $0E		; 30 0E ; Branch if minus to $30, $0E [Flow: branch]
	bit $B6.b		; 24 B6 ; Test bits $B6.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cpx $4D02.w		; EC 02 4D ; Compare $4D02.w with X register [Reads: X Index] [Flags: NCZ]
	pea $BE51.w		; F4 51 BE ; Push absolute address $BE51.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	mvp $C6,$50		; 44 50 C6 ; Move block positive $C6,$50 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sbc $FCEF11.l		; EF 11 EF FC ; Subtract with carry (long) $FCEF11.l [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $1E		; F0 1E ; Branch if equal to $F0, $1E [Flow: branch]
	tsb $0E.b		; 04 0E ; Test and set bits $0E.b [Reads: Accumulator] [Flags: Z]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $FE.b,X		; 15 FE ; OR accumulator with memory $FE.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($31.b,X)		; C1 31 ; Compare accumulator ($31.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	jmp $B6FE.w		; 4C FE B6 ; Jump to $B6FE.w [Flow: jump]
	ora ($ED.b,X)		; 01 ED ; Logical OR ($ED.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lda $2E062C.l,X		; BF 2C 06 2E ; Load long $2E062C.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $F531B6.l,X		; FF B6 31 F5 ; Subtract with carry (long,X) $F531B6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $50, $DF		; 50 DF ; Branch if overflow clear to $50, $DF [Flow: branch]
	.db $10, $53		; 10 53 ; Branch if plus to $10, $53 [Flow: branch]
	asl $B6FF.w		; 0E FF B6 ; Arithmetic shift left $B6FF.w [Flags: NCZ]
	brk $CC.b		; 00 CC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $5FE52C.l		; AF 2C E5 5F ; Load long $5FE52C.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cpx #$21.b		; E0 21 ; Compare #$21.b with X register [Reads: X Index] [Flags: NCZ]
	ldx $D4.b,Y		; B6 D4 ; Load X register $D4.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	.db $50, $E0		; 50 E0 ; Branch if overflow clear to $50, $E0 [Flow: branch]
	.db $10, $24		; 10 24 ; Branch if plus to $10, $24 [Flow: branch]
	ora ($FE.b)		; 12 FE ; OR accumulator with memory (indirect) ($FE.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $DECCB6.l		; EF B6 CC DE ; Subtract with carry (long) $DECCB6.l [Writes: Accumulator] [Flags: NCVZ]
	ora $50E4.w		; 0D E4 50 ; Logical OR $50E4.w with accumulator [Writes: Accumulator] [Flags: NZ]
	dec $E513.w,X		; DE 13 E5 ; Decrement memory $E513.w,X [Reads: X Index] [Flags: NZ]
	ldx $42.b,Y		; B6 42 ; Load X register $42.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	cpy #$3F.b		; C0 3F ; Compare #$3F.b with Y register [Reads: Y Index] [Flags: NCZ]
	trb $11.b		; 14 11 ; Test and reset bits $11.b [Reads: Accumulator] [Flags: Z]
	asl $DB0E.w,X		; 1E 0E DB ; Arithmetic shift left $DB0E.w,X [Reads: X Index] [Flags: NCZ]
	ldx $DF.b,Y		; B6 DF ; Load X register $DF.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	sbc $E051D2.l		; EF D2 51 E0 ; Subtract with carry (long) $E051D2.l [Writes: Accumulator] [Flags: NCVZ]
	sbc ($E4.b),Y		; F1 E4 ; Subtract with carry ($E4.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $50, $C6		; 50 C6 ; Branch if overflow clear to $50, $C6 [Flow: branch]
	sbc $11F24F.l,X		; FF 4F F2 11 ; Subtract with carry (long,X) $11F24F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $FE		; 10 FE ; Branch if plus to $10, $FE [Flow: branch]
	inc $B6F1.w		; EE F1 B6 ; Increment $B6F1.w [Flags: NZ]
	jmp.w [$72EF]		; DC EF 72 ; Jump long indirect [$72EF] [Flow: jump]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	sbc $40.b		; E5 40 ; Subtract $40.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inc $62B6.w,X		; FE B6 62 ; Increment memory $62B6.w,X [Reads: X Index] [Flags: NZ]
	pei ($F2.b)		; D4 F2 ; Push effective indirect address ($F2.b) [Reads: Direct Page] [Writes: Stack Pointer]
	and ($1C.b,X)		; 21 1C ; Logical AND ($1C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ldy $BDE2.w		; AC E2 BD ; Load $BDE2.w into Y register [Writes: Y Index] [Flags: NZ]
	ldx $0C.b,Y		; B6 0C ; Load X register $0C.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	eor $F1.b		; 45 F1 ; Exclusive OR $F1.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx #$D6.b		; E0 D6 ; Compare #$D6.b with X register [Reads: X Index] [Flags: NCZ]
	eor $C633F0.l,X		; 5F F0 33 C6 ; Exclusive OR accumulator with memory (long,X) $C633F0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($10.b)		; F2 10 ; Subtract with carry (indirect) ($10.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($2F.b,X)		; 01 2F ; Logical OR ($2F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp $CFF2.w		; CD F2 CF ; Compare $CFF2.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	asl $F6B6.w		; 0E B6 F6 ; Arithmetic shift left $F6B6.w [Flags: NCZ]
	and ($E0.b),Y		; 31 E0 ; AND accumulator with memory ($E0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	dec $6E.b		; C6 6E ; Decrement $6E.b [Reads: Direct Page] [Flags: NZ]
	cmp ($52.b)		; D2 52 ; Compare accumulator (indirect) ($52.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cpx $C6.b		; E4 C6 ; Compare $C6.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $10, $E2		; 10 E2 ; Branch if plus to $10, $E2 [Flow: branch]
	and $EEE3CC.l,X		; 3F CC E3 EE ; AND accumulator with memory (long,X) $EEE3CC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	dec $22.b		; C6 22 ; Decrement $22.b [Reads: Direct Page] [Flags: NZ]
	brk $E2.b		; 00 E2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $D241D1.l		; 4F D1 41 D2 ; Exclusive OR accumulator with memory (long) $D241D1.l [Writes: Accumulator] [Flags: NZ]
	jsr $D1C6.w		; 20 C6 D1 ; Jump to subroutine at $D1C6.w [Writes: Stack Pointer] [Flow: call]
	eor $FFD2EC.l		; 4F EC D2 FF ; Exclusive OR accumulator with memory (long) $FFD2EC.l [Writes: Accumulator] [Flags: NZ]
	cpx #$F0.b		; E0 F0 ; Compare #$F0.b with X register [Reads: X Index] [Flags: NCZ]
	bit $C6.b		; 24 C6 ; Test bits $C6.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sbc $DF30E2.l,X		; FF E2 30 DF ; Subtract with carry (long,X) $DF30E2.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $E0.b,S		; 43 E0 ; Exclusive OR accumulator with stack relative $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($DF.b),Y		; 31 DF ; AND accumulator with memory ($DF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	dec $50.b		; C6 50 ; Decrement $50.b [Reads: Direct Page] [Flags: NZ]
	cmp $E0E1.w,X		; DD E1 E0 ; Compare accumulator $E0E1.w,X [Reads: X Index] [Flags: NCZ]
	sbc $1F130F.l		; EF 0F 13 1F ; Subtract with carry (long) $1F130F.l [Writes: Accumulator] [Flags: NCVZ]
	dec $E2.b		; C6 E2 ; Decrement $E2.b [Reads: Direct Page] [Flags: NZ]
	jsr $44EF.w		; 20 EF 44 ; Jump to subroutine at $44EF.w [Writes: Stack Pointer] [Flow: call]
	inc $EF13.w,X		; FE 13 EF ; Increment memory $EF13.w,X [Reads: X Index] [Flags: NZ]
	and ($B6.b),Y		; 31 B6 ; AND accumulator with memory ($B6.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	.db $D0, $C0		; D0 C0 ; Branch if not equal to $D0, $C0 [Flow: branch]
	sbc $140E.w		; ED 0E 14 ; Subtract $140E.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cmp ($C6.b,X)		; C1 C6 ; Compare accumulator ($C6.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	jsr $34EF.w		; 20 EF 34 ; Jump to subroutine at $34EF.w [Writes: Stack Pointer] [Flow: call]
	ora $20EF13.l		; 0F 13 EF 20 ; OR accumulator with memory (long) $20EF13.l [Writes: Accumulator] [Flags: NZ]
	sbc $0FB6.w		; ED B6 0F ; Subtract $0FB6.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	dec $DEFE.w,X		; DE FE DE ; Decrement memory $DEFE.w,X [Reads: X Index] [Flags: NZ]
	trb $50.b		; 14 50 ; Test and reset bits $50.b [Reads: Accumulator] [Flags: Z]
	cmp ($20.b)		; D2 20 ; Compare accumulator (indirect) ($20.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	cmp ($52.b)		; D2 52 ; Compare accumulator (indirect) ($52.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	eor $B1.b,S		; 43 B1 ; Exclusive OR accumulator with stack relative $B1.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $4EEF.w,X		; 3D EF 4E ; AND accumulator with memory $4EEF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldx $EE.b,Y		; B6 EE ; Load X register $EE.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	cpx #$BE.b		; E0 BE ; Compare #$BE.b with X register [Reads: X Index] [Flags: NCZ]
	and ($5E.b)		; 32 5E ; AND accumulator with memory (indirect) ($5E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc ($20.b)		; F2 20 ; Subtract with carry (indirect) ($20.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $7E33B6.l		; EF B6 33 7E ; Subtract with carry (long) $7E33B6.l [Writes: Accumulator] [Flags: NCVZ]
	ora $E3.b,S		; 03 E3 ; OR accumulator with stack relative $E3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $1CCD.w,X		; 1E CD 1C ; Arithmetic shift left $1CCD.w,X [Reads: X Index] [Flags: NCZ]
	asl $D0B6.w		; 0E B6 D0 ; Arithmetic shift left $D0B6.w [Flags: NCZ]
	lda $5D33.w,X		; BD 33 5D ; Load $5D33.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($1E.b)		; 12 1E ; OR accumulator with memory (indirect) ($1E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc ($32.b,X)		; E1 32 ; Subtract with carry ($32.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	eor $E603.w,Y		; 59 03 E6 ; Exclusive OR accumulator with memory $E603.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	wai		; CB ; Wait for interrupt
	sbc ($4A.b,S),Y		; F3 4A ; Subtract with carry (stack relative indirect indexed) ($4A.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	eor $ACB6E2.l,X		; 5F E2 B6 AC ; Exclusive OR accumulator with memory (long,X) $ACB6E2.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $4E.b		; 06 4E ; Arithmetic shift left $4E.b [Reads: Direct Page] [Flags: NCZ]
	ora ($3E.b,X)		; 01 3E ; Logical OR ($3E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	pei ($11.b)		; D4 11 ; Push effective indirect address ($11.b) [Reads: Direct Page] [Writes: Stack Pointer]
	eor ($BA.b)		; 52 BA ; Exclusive OR accumulator with memory (indirect) ($BA.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $E7DA33.l,X		; FF 33 DA E7 ; Subtract with carry (long,X) $E7DA33.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	trb $E130.w		; 1C 30 E1 ; Test and reset bits $E130.w [Reads: Accumulator] [Flags: Z]
	ldy $B6.b		; A4 B6 ; Load $B6.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	inc $4F.b		; E6 4F ; Increment $4F.b [Reads: Direct Page] [Flags: NZ]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $20.b,X		; D5 20 ; Compare accumulator $20.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	and ($2E.b)		; 32 2E ; AND accumulator with memory (indirect) ($2E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dec $23.b		; C6 23 ; Decrement $23.b [Reads: Direct Page] [Flags: NZ]
	asl $FEB0.w,X		; 1E B0 FE ; Arithmetic shift left $FEB0.w,X [Reads: X Index] [Flags: NCZ]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	cmp $40B6F2.l,X		; DF F2 B6 40 ; Compare accumulator (long,X) $40B6F2.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	trb $F51F.w		; 1C 1F F5 ; Test and reset bits $F51F.w [Reads: Accumulator] [Flags: Z]
	and ($13.b),Y		; 31 13 ; AND accumulator with memory ($13.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $CA46.w		; 2D 46 CA ; Logical AND $CA46.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $FFE5.w		; ED E5 FF ; Subtract $FFE5.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	rol $F02F.w		; 2E 2F F0 ; Rotate left $F02F.w [Flags: NCZ]
	sbc ($11.b)		; F2 11 ; Subtract with carry (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ldx $3B.b,Y		; B6 3B ; Load X register $3B.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	.db $F0, $13		; F0 13 ; Branch if equal to $F0, $13 [Flow: branch]
	trb $F3.b		; 14 F3 ; Test and reset bits $F3.b [Reads: Accumulator] [Flags: Z]
	rol $3C54.w		; 2E 54 3C ; Rotate left $3C54.w [Flags: NCZ]
	dec $CF.b		; C6 CF ; Decrement $CF.b [Reads: Direct Page] [Flags: NZ]
	sbc $FF000F.l,X		; FF 0F 00 FF ; Subtract with carry (long,X) $FF000F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$03.b		; E0 03 ; Compare #$03.b with X register [Reads: X Index] [Flags: NCZ]
	rol $D0B6.w		; 2E B6 D0 ; Rotate left $D0B6.w [Flags: NCZ]
	and ($15.b)		; 32 15 ; AND accumulator with memory (indirect) ($15.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc ($10.b,X)		; E1 10 ; Subtract with carry ($10.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($4F.b,S),Y		; 53 4F ; XOR accumulator (stack relative indirect indexed) ($4F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $BFB6.w		; AD B6 BF ; Load $BFB6.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	.db $F0, $EC		; F0 EC ; Branch if equal to $F0, $EC [Flow: branch]
	inc $6D.b,X		; F6 6D ; Increment memory $6D.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	lda $0561B6.l		; AF B6 61 05 ; Load long $0561B6.l into accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $62E2.w		; 20 E2 62 ; Jump to subroutine at $62E2.w [Writes: Stack Pointer] [Flow: call]
	and $C6A0DC.l		; 2F DC A0 C6 ; AND accumulator with memory (long) $C6A0DC.l [Writes: Accumulator] [Flags: NZ]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	ora $30030C.l,X		; 1F 0C 03 30 ; Logical OR long $30030C.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $22B631.l		; CF 31 B6 22 ; Compare accumulator (long) $22B631.l [Reads: Accumulator] [Flags: NCZ]
	.db $30, $C3		; 30 C3 ; Branch if minus to $30, $C3 [Flow: branch]
	adc ($00.b,X)		; 61 00 ; Add with carry ($00.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	ldy #$D1.b		; A0 D1 ; Load #$D1.b into Y register [Writes: Y Index] [Flags: NZ]
	dec $EF.b		; C6 EF ; Decrement $EF.b [Reads: Direct Page] [Flags: NZ]
	jsr $F31B.w		; 20 1B F3 ; Jump to subroutine at $F31B.w [Writes: Stack Pointer] [Flow: call]
	and ($CF.b,X)		; 21 CF ; Logical AND ($CF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $30, $11		; 30 11 ; Branch if minus to $30, $11 [Flow: branch]
	ldx $42.b,Y		; B6 42 ; Load X register $42.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	lda $62.b,S		; A3 62 ; Load accumulator (stack relative) $62.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc ($4B.b),Y		; F1 4B ; Subtract with carry ($4B.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $B6DDC0.l		; AF C0 DD B6 ; Load long $B6DDC0.l into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $12F429.l		; 22 29 F4 12 ; Jump to subroutine long $12F429.l [Writes: Stack Pointer] [Flow: call]
	cmp $41324F.l		; CF 4F 32 41 ; Compare accumulator (long) $41324F.l [Reads: Accumulator] [Flags: NCZ]
	ldx $B2.b,Y		; B6 B2 ; Load X register $B2.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	adc $D1.b,S		; 63 D1 ; Add with carry (stack relative) $D1.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	jmp $EEDFBE.l		; 5C BE DF EE ; Jump long to $EEDFBE.l [Flow: jump]
	sbc ($B6.b,S),Y		; F3 B6 ; Subtract with carry (stack relative indirect indexed) ($B6.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($2E.b,X)		; E1 2E ; Subtract with carry ($2E.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $50.b,S		; 23 50 ; AND accumulator with stack relative $50.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx #$B6.b		; E0 B6 ; Compare #$B6.b with X register [Reads: X Index] [Flags: NCZ]
	and $E1.b		; 25 E1 ; Logical AND $E1.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr $CEDD.w		; 4E DD CE ; Logical shift right $CEDD.w [Flags: NCZ]
	cpx #$D3.b		; E0 D3 ; Compare #$D3.b with X register [Reads: X Index] [Flags: NCZ]
	ora $31B6.w		; 0D B6 31 ; Logical OR $31B6.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $0FF5.w		; ED F5 0F ; Subtract $0FF5.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ora $6F.b,S		; 03 6F ; OR accumulator with stack relative $6F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx $F2.b,Y		; B6 F2 ; Load X register $F2.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	rol $BC0D.w,X		; 3E 0D BC ; Rotate left $BC0D.w,X [Reads: X Index] [Flags: NCZ]
.INDEX 8
	sep #$D2		; E2 D2
	sbc $CA51.w		; ED 51 CA ; Subtract $CA51.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sbc $01D023.l		; EF 23 D0 01 ; Subtract with carry (long) $01D023.l [Writes: Accumulator] [Flags: NCVZ]
	bit $022F.w		; 2C 2F 02 ; Test bits $022F.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	sbc ($C6.b),Y		; F1 C6 ; Subtract with carry ($C6.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $E1ED0F.l,X		; 1F 0F ED E1 ; Logical OR long $E1ED0F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cop $EE.b		; 02 EE ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($FC.b,X)		; 21 FC ; Logical AND ($FC.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	dec $04.b		; C6 04 ; Decrement $04.b [Reads: Direct Page] [Flags: NZ]
	.db $10, $F1		; 10 F1 ; Branch if plus to $10, $F1 [Flow: branch]
	jsr $E11F.w		; 20 1F E1 ; Jump to subroutine at $E11F.w [Writes: Stack Pointer] [Flow: call]
	ora ($1F.b,S),Y		; 13 1F ; OR accumulator (stack relative indirect indexed) ($1F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $10.b		; C6 10 ; Decrement $10.b [Reads: Direct Page] [Flags: NZ]
	sbc $02D0.w,X		; FD D0 02 ; Subtract with carry $02D0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $0D21.w,X		; DE 21 0D ; Decrement memory $0D21.w,X [Reads: X Index] [Flags: NZ]
	sbc ($BA.b,S),Y		; F3 BA ; Subtract with carry (stack relative indirect indexed) ($BA.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cmp ($B5.b,X)		; C1 B5 ; Compare accumulator ($B5.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	sbc $16B63D.l		; EF 3D B6 16 ; Subtract with carry (long) $16B63D.l [Writes: Accumulator] [Flags: NCVZ]
	ldx $B63D.w		; AE 3D B6 ; Load $B63D.w into X register [Writes: X Index] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lda $23CDF5.l,X		; BF F5 CD 23 ; Load long $23CDF5.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	pei ($13.b)		; D4 13 ; Push effective indirect address ($13.b) [Reads: Direct Page] [Writes: Stack Pointer]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	pei ($CF.b)		; D4 CF ; Push effective indirect address ($CF.b) [Reads: Direct Page] [Writes: Stack Pointer]
	eor $65A2.w,X		; 5D A2 65 ; Exclusive OR accumulator with memory $65A2.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda $B60D2C.l,X		; BF 2C 0D B6 ; Load long $B60D2C.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda $EEF5.w,X		; BD F5 EE ; Load $EEF5.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cop $1B.b		; 02 1B ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($23.b)		; D2 23 ; Compare accumulator (indirect) ($23.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora $C6.b		; 05 C6 ; Logical OR $C6.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $14ED10.l,X		; 1F 10 ED 14 ; Logical OR long $14ED10.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($2F.b),Y		; 11 2F ; OR accumulator with memory ($2F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	inc $B6EE.w,X		; FE EE B6 ; Increment memory $B6EE.w,X [Reads: X Index] [Flags: NZ]
	cmp $0F.b		; C5 0F ; Compare $0F.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	.db $F0, $1D		; F0 1D ; Branch if equal to $F0, $1D [Flow: branch]
	cpx #$12.b		; E0 12 ; Compare #$12.b with X register [Reads: X Index] [Flags: NCZ]
	asl $40.b		; 06 40 ; Arithmetic shift left $40.b [Reads: Direct Page] [Flags: NCZ]
	dec $1F.b		; C6 1F ; Decrement $1F.b [Reads: Direct Page] [Flags: NZ]
	jsr ($1104.w,X)		; FC 04 11 ; Jump to subroutine indirect indexed ($1104.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr $F0FE.w		; 20 FE F0 ; Jump to subroutine at $F0FE.w [Writes: Stack Pointer] [Flow: call]
	.db $D0, $AA		; D0 AA ; Branch if not equal to $D0, $AA [Flow: branch]
	sbc ($0D.b),Y		; F1 0D ; Subtract with carry ($0D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $D75F0F.l		; 0F 0F 5F D7 ; OR accumulator with memory (long) $D75F0F.l [Writes: Accumulator] [Flags: NZ]
	and $C6EA.w		; 2D EA C6 ; Logical AND $C6EA.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jsr ($32E3.w,X)		; FC E3 32 ; Jump to subroutine indirect indexed ($32E3.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	and ($0E.b,X)		; 21 0E ; Logical AND ($0E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $BA0FEF.l		; EF EF 0F BA ; Subtract with carry (long) $BA0FEF.l [Writes: Accumulator] [Flags: NCVZ]
	and $1B02.w,X		; 3D 02 1B ; AND accumulator with memory $1B02.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $11		; 30 11 ; Branch if minus to $30, $11 [Flow: branch]
	ora $DD.b,S		; 03 DD ; OR accumulator with stack relative $DD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $16BA.w,X		; DE BA 16 ; Decrement memory $16BA.w,X [Reads: X Index] [Flags: NZ]
	.db $50, $C2		; 50 C2 ; Branch if overflow clear to $50, $C2 [Flow: branch]
	dec $EEF4.w		; CE F4 EE ; Decrement $EEF4.w [Flags: NZ]
	eor $C5BA3D.l		; 4F 3D BA C5 ; Exclusive OR accumulator with memory (long) $C5BA3D.l [Writes: Accumulator] [Flags: NZ]
	trb $1F20.w		; 1C 20 1F ; Test and reset bits $1F20.w [Reads: Accumulator] [Flags: Z]
	ora $ED.b,X		; 15 ED ; OR accumulator with memory $ED.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ldy #$02.b		; A0 02 ; Load #$02.b into Y register [Writes: Y Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $42, $C1		; 42 C1 ; Reserved instruction
	asl $0EF2.w		; 0E F2 0E ; Arithmetic shift left $0EF2.w [Flags: NCZ]
	rol $D221.w		; 2E 21 D2 ; Rotate left $D221.w [Flags: NCZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $1D12.w		; 2E 12 1D ; Rotate left $1D12.w [Flags: NCZ]
	.db $D0, $1F		; D0 1F ; Branch if not equal to $D0, $1F [Flow: branch]
	bit $B6.b,X		; 34 B6 ; Test bits $B6.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	adc ($4F.b,X)		; 61 4F ; Add with carry ($4F.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $0B0D.w		; CE 0D 0B ; Decrement $0B0D.w [Flags: NZ]
	sbc $EF.b,S		; E3 EF ; Subtract stack-relative $EF.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	.db $F0, $C6		; F0 C6 ; Branch if equal to $F0, $C6 [Flow: branch]
	ora $33022F.l,X		; 1F 2F 02 33 ; Logical OR long $33022F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $12EC.w,X		; FD EC 12 ; Subtract with carry $12EC.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($B6.b,X)		; 41 B6 ; Exclusive OR accumulator with memory ($B6.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	lda $D2191E.l,X		; BF 1E 19 D2 ; Load long $D2191E.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $C63CE0.l,X		; 1F E0 3C C6 ; Logical OR long $C63CE0.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsr $2400.w		; 20 00 24 ; Jump to subroutine at $2400.w [Writes: Stack Pointer] [Flow: call]
	ora $21DC.w		; 0D DC 21 ; Logical OR $21DC.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and ($12.b),Y		; 31 12 ; AND accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	dec $FF.b		; C6 FF ; Decrement $FF.b [Reads: Direct Page] [Flags: NZ]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$10.b		; E0 10 ; Compare #$10.b with X register [Reads: X Index] [Flags: NCZ]
	sbc $C6002F.l,X		; FF 2F 00 C6 ; Subtract with carry (long,X) $C6002F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $2200DB.l		; 2F DB 00 22 ; AND accumulator with memory (long) $2200DB.l [Writes: Accumulator] [Flags: NZ]
	ora ($0F.b,S),Y		; 13 0F ; OR accumulator (stack relative indirect indexed) ($0F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldx $FF.b,Y		; B6 FF ; Load X register $FF.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ldx $DD13.w		; AE 13 DD ; Load $DD13.w into X register [Writes: X Index] [Flags: NZ]
	jsl $CA1E0F.l		; 22 0F 1E CA ; Jump to subroutine long $CA1E0F.l [Writes: Stack Pointer] [Flow: call]
	jsl $4FDEFF.l		; 22 FF DE 4F ; Jump to subroutine long $4FDEFF.l [Writes: Stack Pointer] [Flow: call]
	and ($F2.b,X)		; 21 F2 ; Logical AND ($F2.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	inc $B6F1.w,X		; FE F1 B6 ; Increment memory $B6F1.w,X [Reads: X Index] [Flags: NZ]
	bit $F2AE.w,X		; 3C AE F2 ; Test bits $F2AE.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	ora $FFF3.w		; 0D F3 FF ; Logical OR $FFF3.w with accumulator [Writes: Accumulator] [Flags: NZ]
	rol $C614.w		; 2E 14 C6 ; Rotate left $C614.w [Flags: NCZ]
	and ($ED.b)		; 32 ED ; AND accumulator with memory (indirect) ($ED.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $0302.w,X		; FE 02 03 ; Increment memory $0302.w,X [Reads: X Index] [Flags: NZ]
	and ($F0.b,X)		; 21 F0 ; Logical AND ($F0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $F0E3BA.l		; 0F BA E3 F0 ; OR accumulator with memory (long) $F0E3BA.l [Writes: Accumulator] [Flags: NZ]
	jmp $D203.w		; 4C 03 D2 ; Jump to $D203.w [Flow: jump]
	asl $3003.w		; 0E 03 30 ; Arithmetic shift left $3003.w [Flags: NCZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	stz $0511.w,X		; 9E 11 05 ; Store zero to $0511.w,X [Reads: X Index]
	cmp ($4A.b,S),Y		; D3 4A ; Compare accumulator (stack relative indirect indexed) ($4A.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	asl $F43D.w		; 0E 3D F4 ; Arithmetic shift left $F43D.w [Flags: NCZ]
	ldx $DB.b,Y		; B6 DB ; Load X register $DB.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	ora ($0F.b)		; 12 0F ; OR accumulator with memory (indirect) ($0F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp ($1F.b,S),Y		; D3 1F ; Compare accumulator (stack relative indirect indexed) ($1F.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	cmp ($64.b),Y		; D1 64 ; Compare accumulator ($64.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	asl $FEC6.w,X		; 1E C6 FE ; Arithmetic shift left $FEC6.w,X [Reads: X Index] [Flags: NCZ]
	sbc ($11.b,X)		; E1 11 ; Subtract with carry ($11.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $11		; 30 11 ; Branch if minus to $30, $11 [Flow: branch]
	asl $0DD2.w		; 0E D2 0D ; Arithmetic shift left $0DD2.w [Flags: NCZ]
	ldx $E1.b,Y		; B6 E1 ; Load X register $E1.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	rol $4FA3.w,X		; 3E A3 4F ; Rotate left $4FA3.w,X [Reads: X Index] [Flags: NCZ]
	.db $D0, $53		; D0 53 ; Branch if not equal to $D0, $53 [Flow: branch]
	ora ($FC.b)		; 12 FC ; OR accumulator with memory (indirect) ($FC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dec $D0.b		; C6 D0 ; Decrement $D0.b [Reads: Direct Page] [Flags: NZ]
	ora ($21.b),Y		; 11 21 ; OR accumulator with memory ($21.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $1BD3EE.l		; 22 EE D3 1B ; Jump to subroutine long $1BD3EE.l [Writes: Stack Pointer] [Flow: call]
	.db $F0, $C6		; F0 C6 ; Branch if equal to $F0, $C6 [Flow: branch]
	.db $30, $C1		; 30 C1 ; Branch if minus to $30, $C1 [Flow: branch]
	and ($E0.b,X)		; 21 E0 ; Logical AND ($E0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($02.b),Y		; 11 02 ; OR accumulator with memory ($02.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $01C6C0.l		; 0F C0 C6 01 ; OR accumulator with memory (long) $01C6C0.l [Writes: Accumulator] [Flags: NZ]
	.db $10, $24		; 10 24 ; Branch if plus to $10, $24 [Flow: branch]
	ora $3DC3.w		; 0D C3 3D ; Logical OR $3DC3.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp $DCC233.l		; CF 33 C2 DC ; Compare accumulator (long) $DCC233.l [Reads: Accumulator] [Flags: NCZ]
	cpx #$ED.b		; E0 ED ; Compare #$ED.b with X register [Reads: X Index] [Flags: NCZ]
	sbc $FE3402.l		; EF 02 34 FE ; Subtract with carry (long) $FE3402.l [Writes: Accumulator] [Flags: NCVZ]
	cmp $1420C6.l,X		; DF C6 20 14 ; Compare accumulator (long,X) $1420C6.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	ora $BE3FB1.l,X		; 1F B1 3F BE ; Logical OR long $BE3FB1.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $EE.b,S		; 23 EE ; AND accumulator with stack relative $EE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldx $03.b,Y		; B6 03 ; Load X register $03.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	ora $1632F0.l		; 0F F0 32 16 ; OR accumulator with memory (long) $1632F0.l [Writes: Accumulator] [Flags: NZ]
	ldy $4EC4.w		; AC C4 4E ; Load $4EC4.w into Y register [Writes: Y Index] [Flags: NZ]
	dec $F4.b		; C6 F4 ; Decrement $F4.b [Reads: Direct Page] [Flags: NZ]
	and ($AF.b),Y		; 31 AF ; AND accumulator with memory ($AF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor ($BC.b,X)		; 41 BC ; Exclusive OR accumulator with memory ($BC.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	trb $0D.b		; 14 0D ; Test and reset bits $0D.b [Reads: Accumulator] [Flags: Z]
	sbc ($B2.b,X)		; E1 B2 ; Subtract with carry ($B2.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $D0, $CB		; D0 CB ; Branch if not equal to $D0, $CB [Flow: branch]
	sbc ($15.b),Y		; F1 15 ; Subtract with carry ($15.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr $53AF.w		; 4E AF 53 ; Logical shift right $53AF.w [Flags: NCZ]
	cmp ($C6.b,S),Y		; D3 C6 ; Compare accumulator (stack relative indirect indexed) ($C6.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	.db $42, $BD		; 42 BD ; Reserved instruction
	and ($DB.b,S),Y		; 33 DB ; AND accumulator (stack relative indirect indexed) ($DB.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx $2F.b		; E4 2F ; Compare $2F.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc $FEC612.l		; EF 12 C6 FE ; Subtract with carry (long) $FEC612.l [Writes: Accumulator] [Flags: NCVZ]
	ora ($01.b),Y		; 11 01 ; OR accumulator with memory ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	rol $41D1.w		; 2E D1 41 ; Rotate left $41D1.w [Flags: NCZ]
	cmp ($43.b,X)		; C1 43 ; Compare accumulator ($43.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	dec $DD.b		; C6 DD ; Decrement $DD.b [Reads: Direct Page] [Flags: NZ]
	ora ($EB.b)		; 12 EB ; OR accumulator with memory (indirect) ($EB.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
.ACCU 8
	sep #$20		; E2 20
	asl $1EF2.w		; 0E F2 1E ; Arithmetic shift left $1EF2.w [Flags: NCZ]
	dec $02.b		; C6 02 ; Decrement $02.b [Reads: Direct Page] [Flags: NZ]
	cop $1F.b		; 02 1F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($41.b),Y		; D1 41 ; Compare accumulator ($41.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	.db $B0, $44		; B0 44 ; Branch if carry set to $B0, $44 [Flow: branch]
	sbc $40CA.w		; ED CA 40 ; Subtract $40CA.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sbc $1F14.w		; ED 14 1F ; Subtract $1F14.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cpx #$02.b		; E0 02 ; Compare #$02.b with X register [Reads: X Index] [Flags: NCZ]
	asl $C601.w		; 0E 01 C6 ; Arithmetic shift left $C601.w [Flags: NCZ]
	sbc ($2F.b)		; F2 2F ; Subtract with carry (indirect) ($2F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp $23DE53.l,X		; DF 53 DE 23 ; Compare accumulator (long,X) $23DE53.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	inc $B600.w,X		; FE 00 B6 ; Increment memory $B600.w,X [Reads: X Index] [Flags: NZ]
	cpy $22B2.w		; CC B2 22 ; Compare $22B2.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora $F13FF1.l		; 0F F1 3F F1 ; OR accumulator with memory (long) $F13FF1.l [Writes: Accumulator] [Flags: NZ]
	ora ($B6.b,X)		; 01 B6 ; Logical OR ($B6.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $BB65E0.l,X		; 3F E0 65 BB ; AND accumulator with memory (long,X) $BB65E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $0E.b,S		; 23 0E ; AND accumulator with stack relative $0E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $10, $CE		; 10 CE ; Branch if plus to $10, $CE [Flow: branch]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	cmp $1F.b,X		; D5 1F ; Compare accumulator $1F.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	bit $3E01.w		; 2C 01 3E ; Test bits $3E01.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	cmp $10.b,S		; C3 10 ; Compare accumulator (stack relative) $10.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	ora $F1B6.w,X		; 1D B6 F1 ; OR accumulator with memory $F1B6.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $DB.b,X		; 35 DB ; Logical AND $DB.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($2E.b),Y		; 11 2E ; OR accumulator with memory ($2E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($DD.b,X)		; 01 DD ; Logical OR ($DD.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpy #$B6.b		; C0 B6 ; Compare #$B6.b with Y register [Reads: Y Index] [Flags: NCZ]
	ora $23F040.l,X		; 1F 40 F0 23 ; Logical OR long $23F040.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $10		; D0 10 ; Branch if not equal to $D0, $10 [Flow: branch]
	jsr $B600.w		; 20 00 B6 ; Jump to subroutine at $B600.w [Writes: Stack Pointer] [Flow: call]
	ora $FC.b,X		; 15 FC ; OR accumulator with memory $FC.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $2F.b		; 00 2F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($DD.b,X)		; 01 DD ; Logical OR ($DD.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp $20B62F.l		; CF 2F B6 20 ; Compare accumulator (long) $20B62F.l [Reads: Accumulator] [Flags: NCZ]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $102F2F.l		; EF 2F 2F 10 ; Subtract with carry (long) $102F2F.l [Writes: Accumulator] [Flags: NCVZ]
	trb $BA.b		; 14 BA ; Test and reset bits $BA.b [Reads: Accumulator] [Flags: Z]
	cmp $2C22.w		; CD 22 2C ; Compare $2C22.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora ($EE.b)		; 12 EE ; OR accumulator with memory (indirect) ($EE.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pei ($4D.b)		; D4 4D ; Push effective indirect address ($4D.b) [Reads: Direct Page] [Writes: Stack Pointer]
	brk $A6.b		; 00 A6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	ora [$EC.b]		; 07 EC ; OR accumulator with memory (long) [$EC.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	and ($05.b),Y		; 31 05 ; AND accumulator with memory ($05.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $E3BA.w		; 2D BA E3 ; Logical AND $E3BA.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $DE31.w		; 2D 31 DE ; Logical AND $DE31.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp ($5F.b,S),Y		; D3 5F ; Compare accumulator (stack relative indirect indexed) ($5F.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	.db $D0, $4D		; D0 4D ; Branch if not equal to $D0, $4D [Flow: branch]
	ldx $F3.b,Y		; B6 F3 ; Load X register $F3.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	asl $1001.w		; 0E 01 10 ; Arithmetic shift left $1001.w [Flags: NCZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($CF.b),Y		; 11 CF ; OR accumulator with memory ($CF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ldx $0D.b,Y		; B6 0D ; Load X register $0D.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	ora ($0F.b,S),Y		; 13 0F ; OR accumulator (stack relative indirect indexed) ($0F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldy $FD14.w,X		; BC 14 FD ; Load Y register $FD14.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	eor ($01.b,X)		; 41 01 ; Exclusive OR accumulator with memory ($01.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ldx $2E.b		; A6 2E ; Load $2E.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	cmp ($30.b,S),Y		; D3 30 ; Compare accumulator (stack relative indirect indexed) ($30.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	and ($4E.b)		; 32 4E ; AND accumulator with memory (indirect) ($4E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $AA.b,X		; 15 AA ; OR accumulator with memory $AA.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cpx $13B6.w		; EC B6 13 ; Compare $13B6.w with X register [Reads: X Index] [Flags: NCZ]
	brk $EC.b		; 00 EC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0C.b,S		; E3 0C ; Subtract stack-relative $0C.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	and ($10.b),Y		; 31 10 ; AND accumulator with memory ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($B6.b),Y		; 11 B6 ; OR accumulator with memory ($B6.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($20.b,X)		; E1 20 ; Subtract with carry ($20.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($2E.b,X)		; 21 2E ; Logical AND ($2E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($FC.b)		; 12 FC ; OR accumulator with memory (indirect) ($FC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $FEA603.l		; EF 03 A6 FE ; Subtract with carry (long) $FEA603.l [Writes: Accumulator] [Flags: NCVZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	lda $0A.b,S		; A3 0A ; Load accumulator (stack relative) $0A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $41.b		; 24 41 ; Test bits $41.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	pea $BAC1.w		; F4 C1 BA ; Push absolute address $BAC1.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	and $0D11.w		; 2D 11 0D ; Logical AND $0D11.w with accumulator [Writes: Accumulator] [Flags: NZ]
	pea $E0E3.w		; F4 E3 E0 ; Push absolute address $E0E3.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	ldx $5D.b		; A6 5D ; Load $5D.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	cpy #$EA.b		; C0 EA ; Compare #$EA.b with Y register [Reads: Y Index] [Flags: NCZ]
	rol $30.b		; 26 30 ; Rotate left $30.b [Reads: Direct Page] [Flags: NCZ]
	sbc $E0.b,X		; F5 E0 ; Subtract $E0.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	pea $30B6.w		; F4 B6 30 ; Push absolute address $30B6.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	ora $D00F00.l		; 0F 00 0F D0 ; OR accumulator with memory (long) $D00F00.l [Writes: Accumulator] [Flags: NZ]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: NCZ]
	eor $ECFFB6.l		; 4F B6 FF EC ; Exclusive OR accumulator with memory (long) $ECFFB6.l [Writes: Accumulator] [Flags: NZ]
	tsb $1F.b		; 04 1F ; Test and set bits $1F.b [Reads: Accumulator] [Flags: Z]
	ora $10.b,S		; 03 10 ; OR accumulator with stack relative $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc ($3F.b)		; F2 3F ; Subtract with carry (indirect) ($3F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ldx $F1.b,Y		; B6 F1 ; Load X register $F1.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	ora $EE00FF.l,X		; 1F FF 00 EE ; Logical OR long $EE00FF.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($4F.b,X)		; E1 4F ; Subtract with carry ($4F.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $04ECB6.l,X		; 1F B6 EC 04 ; Logical OR long $04ECB6.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $2F04.w,X		; 1E 04 2F ; Arithmetic shift left $2F04.w,X [Reads: X Index] [Flags: NCZ]
	cmp ($40.b)		; D2 40 ; Compare accumulator (indirect) ($40.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp ($B6.b)		; D2 B6 ; Compare accumulator (indirect) ($B6.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	jsr $21DD.w		; 20 DD 21 ; Jump to subroutine at $21DD.w [Writes: Stack Pointer] [Flow: call]
	inc $20E1.w		; EE E1 20 ; Increment $20E1.w [Flags: NZ]
	and $04B6DC.l		; 2F DC B6 04 ; AND accumulator with memory (long) $04B6DC.l [Writes: Accumulator] [Flags: NZ]
	ora $2E05.w,X		; 1D 05 2E ; OR accumulator with memory $2E05.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($6F.b,S),Y		; D3 6F ; Compare accumulator (stack relative indirect indexed) ($6F.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	cmp ($21.b,X)		; C1 21 ; Compare accumulator ($21.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	ldx $CE.b,Y		; B6 CE ; Load X register $CE.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	jsr $E0EE.w		; 20 EE E0 ; Jump to subroutine at $E0EE.w [Writes: Stack Pointer] [Flow: call]
	ora ($40.b),Y		; 11 40 ; OR accumulator with memory ($40.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$B621]		; DC 21 B6 ; Jump long indirect [$B621] [Flow: jump]
	sbc $3E15.w,X		; FD 15 3E ; Subtract with carry $3E15.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp ($6E.b,S),Y		; D3 6E ; Compare accumulator (stack relative indirect indexed) ($6E.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	sbc ($10.b,X)		; E1 10 ; Subtract with carry ($10.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $EE30B6.l,X		; BF B6 30 EE ; Load long $EE30B6.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $F1		; F0 F1 ; Branch if equal to $F0, $F1 [Flow: branch]
	eor ($BD.b,X)		; 41 BD ; Exclusive OR accumulator with memory ($BD.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	dec $23B6.w,X		; DE B6 23 ; Decrement memory $23B6.w,X [Reads: X Index] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cmp ($6F.b)		; D2 6F ; Compare accumulator (indirect) ($6F.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	.db $F0, $1F		; F0 1F ; Branch if equal to $F0, $1F [Flow: branch]
	lda $EEB630.l,X		; BF 30 B6 EE ; Load long $EEB630.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $CE42F1.l		; 0F F1 42 CE ; OR accumulator with memory (long) $CE42F1.l [Writes: Accumulator] [Flags: NZ]
	and $BA33CD.l,X		; 3F CD 33 BA ; AND accumulator with memory (long,X) $BA33CD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $4CC4.w,X		; 1D C4 4C ; OR accumulator with memory $4CC4.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $2FE21F.l		; 0F 1F E2 2F ; OR accumulator with memory (long) $2FE21F.l [Writes: Accumulator] [Flags: NZ]
	cpx #$B6.b		; E0 B6 ; Compare #$B6.b with X register [Reads: X Index] [Flags: NCZ]
	and $DF32F0.l		; 2F F0 32 DF ; AND accumulator with memory (long) $DF32F0.l [Writes: Accumulator] [Flags: NZ]
	and $3233CC.l,X		; 3F CC 33 32 ; AND accumulator with memory (long,X) $3233CC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldx $D0.b		; A6 D0 ; Load $D0.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	.db $62, $40, $EB		; 62 40 EB ; Push effective relative address $62, $40, $EB [Writes: Stack Pointer]
	lda $3DEEFF.l,X		; BF FF EE 3D ; Load long $3DEEFF.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldx $F0.b,Y		; B6 F0 ; Load X register $F0.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	and ($F1.b,X)		; 21 F1 ; Logical AND ($F1.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rol $13DC.w		; 2E DC 13 ; Rotate left $13DC.w [Flags: NCZ]
	and ($00.b)		; 32 00 ; AND accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldx $32.b		; A6 32 ; Load $32.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	adc ($A9.b,S),Y		; 73 A9 ; Add with carry (stack relative indirect indexed) ($A9.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $D0, $ED		; D0 ED ; Branch if not equal to $D0, $ED [Flow: branch]
	ora $AAFF0E.l		; 0F 0E FF AA ; OR accumulator with memory (long) $AAFF0E.l [Writes: Accumulator] [Flags: NZ]
	rol $FB11.w,X		; 3E 11 FB ; Rotate left $FB11.w,X [Reads: X Index] [Flags: NCZ]
	ora $2E36.w,X		; 1D 36 2E ; OR accumulator with memory $2E36.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpx $B640.w		; EC 40 B6 ; Compare $B640.w with X register [Reads: X Index] [Flags: NCZ]
	mvp $F0,$CC		; 44 CC F0 ; Move block positive $F0,$CC [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sbc $FF11.w		; ED 11 FF ; Subtract $FF11.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	inc $E32F.w		; EE 2F E3 ; Increment $E32F.w [Flags: NZ]
	rol $2F1D.w,X		; 3E 1D 2F ; Rotate left $2F1D.w,X [Reads: X Index] [Flags: NCZ]
	and ($B6.b)		; 32 B6 ; AND accumulator with memory (indirect) ($B6.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$FCEF]		; DC EF FC ; Jump long indirect [$FCEF] [Flow: jump]
	cop $FF.b		; 02 FF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $FE.b		; 02 FE ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $B6.b,S		; 23 B6 ; AND accumulator with stack relative $B6.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $EF01.w,X		; FE 01 EF ; Increment memory $EF01.w,X [Reads: X Index] [Flags: NZ]
	and ($20.b)		; 32 20 ; AND accumulator with memory (indirect) ($20.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $24		; 10 24 ; Branch if plus to $10, $24 [Flow: branch]
	cpx $EFB6.w		; EC B6 EF ; Compare $EFB6.w with X register [Reads: X Index] [Flags: NCZ]
	jsr ($0E03.w,X)		; FC 03 0E ; Jump to subroutine indirect indexed ($0E03.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc ($EE.b,S),Y		; F3 EE ; Subtract with carry (stack relative indirect indexed) ($EE.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	bit $FE.b		; 24 FE ; Test bits $FE.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ldx $02.b		; A6 02 ; Load $02.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	cmp $0156.w		; CD 56 01 ; Compare $0156.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $50, $35		; 50 35 ; Branch if overflow clear to $50, $35 [Flow: branch]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	lda $FAA6.w,X		; BD A6 FA ; Load $FAA6.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($2E.b),Y		; F1 2E ; Subtract with carry ($2E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $DD.b		; C5 DD ; Compare $DD.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora [$3C.b]		; 07 3C ; OR accumulator with memory (long) [$3C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc ($B6.b,X)		; E1 B6 ; Subtract with carry ($B6.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $400013.l		; 0F 13 00 40 ; OR accumulator with memory (long) $400013.l [Writes: Accumulator] [Flags: NZ]
	and ($0F.b,X)		; 21 0F ; Logical AND ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	dec $A6FD.w,X		; DE FD A6 ; Decrement memory $A6FD.w,X [Reads: X Index] [Flags: NZ]
	ora $C540.w		; 0D 40 C5 ; Logical OR $C540.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cpx $7ED4.w		; EC D4 7E ; Compare $7ED4.w with X register [Reads: X Index] [Flags: NCZ]
	sbc $BA3F.w		; ED 3F BA ; Subtract $BA3F.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ora ($0F.b),Y		; 11 0F ; OR accumulator with memory ($0F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	jsr $D100.w		; 20 00 D1 ; Jump to subroutine at $D100.w [Writes: Stack Pointer] [Flow: call]
	ora $11B63D.l		; 0F 3D B6 11 ; OR accumulator with memory (long) $11B63D.l [Writes: Accumulator] [Flags: NZ]
	sbc ($0E.b)		; F2 0E ; Subtract with carry (indirect) ($0E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($40.b,X)		; E1 40 ; Subtract with carry ($40.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $1010.w		; 0D 10 10 ; Logical OR $1010.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	.db $10, $4C		; 10 4C ; Branch if plus to $10, $4C [Flow: branch]
	ora $F0E011.l		; 0F 11 E0 F0 ; OR accumulator with memory (long) $F0E011.l [Writes: Accumulator] [Flags: NZ]
	and $B631.w		; 2D 31 B6 ; Logical AND $B631.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $D0, $32		; D0 32 ; Branch if not equal to $D0, $32 [Flow: branch]
	bit $20F1.w		; 2C F1 20 ; Test bits $20F1.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	sbc ($BA.b,S),Y		; F3 BA ; Subtract with carry (stack relative indirect indexed) ($BA.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $1F1E.w,X		; 1D 1E 1F ; OR accumulator with memory $1F1E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($F0.b,X)		; 01 F0 ; Logical OR ($F0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $FE42.w		; 0D 42 FE ; Logical OR $FE42.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ldx $F0.b,Y		; B6 F0 ; Load X register $F0.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	.db $D0, $31		; D0 31 ; Branch if not equal to $D0, $31 [Flow: branch]
	and $30E1.w,X		; 3D E1 30 ; AND accumulator with memory $30E1.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($51.b,S),Y		; D3 51 ; Compare accumulator (stack relative indirect indexed) ($51.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	trb $F230.w		; 1C 30 F2 ; Test and reset bits $F230.w [Reads: Accumulator] [Flags: Z]
	cpx #$FD.b		; E0 FD ; Compare #$FD.b with X register [Reads: X Index] [Flags: NCZ]
	.db $42, $1E		; 42 1E ; Reserved instruction
	sbc ($BA.b),Y		; F1 BA ; Subtract with carry ($BA.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
.ACCU 16
.INDEX 16
	rep #$3F		; C2 3F
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cmp ($4F.b,S),Y		; D3 4F ; Compare accumulator (stack relative indirect indexed) ($4F.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	lda $5C.b		; A5 5C ; Load $5C.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	eor ($D2.b),Y		; 51 D2 ; Exclusive OR accumulator with memory ($D2.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $EA		; 10 EA ; Branch if plus to $10, $EA [Flow: branch]
	adc ($2E.b,X)		; 61 2E ; Add with carry ($2E.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($D1.b),Y		; F1 D1 ; Subtract with carry ($D1.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx $10.b,Y		; B6 10 ; Load X register $10.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	.db $50, $ED		; 50 ED ; Branch if overflow clear to $50, $ED [Flow: branch]
	and $D0.b,S		; 23 D0 ; AND accumulator with stack relative $D0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $3B.b,S		; 63 3B ; Add with carry (stack relative) $3B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($B2.b),Y		; F1 B2 ; Subtract with carry ($B2.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $9B3B45.l		; 22 45 3B 9B ; Jump to subroutine long $9B3B45.l [Writes: Stack Pointer] [Flow: call]
	cmp $CACD.w,X		; DD CD CA ; Compare accumulator $CACD.w,X [Reads: X Index] [Flags: NCZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ldx $62.b,Y		; B6 62 ; Load X register $62.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	tsb $EE03.w		; 0C 03 EE ; Test and set bits $EE03.w [Reads: Accumulator] [Flags: Z]
	mvn $E2,$5B		; 54 5B E2 ; Move block negative $E2,$5B [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	inc $23C2.w,X		; FE C2 23 ; Increment memory $23C2.w,X [Reads: X Index] [Flags: NZ]
	and $DEFEDE.l,X		; 3F DE FE DE ; AND accumulator with memory (long,X) $DEFEDE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $F1DC.w,X		; FE DC F1 ; Increment memory $F1DC.w,X [Reads: X Index] [Flags: NZ]
	ldx $1C.b,Y		; B6 1C ; Load X register $1C.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	sep #$0F		; E2 0F ; Set processor status bits #$0F [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	mvn $D2,$5C		; 54 5C D2 ; Move block negative $D2,$5C [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sbc $B633.w		; ED 33 B6 ; Subtract $B633.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ldy #$F21F.w		; A0 1F F2 ; Load #$F21F.w into Y register [Writes: Y Index] [Flags: NZ]
	ora $2E24FF.l		; 0F FF 24 2E ; OR accumulator with memory (long) $2E24FF.l [Writes: Accumulator] [Flags: NZ]
	ldx $D1.b,Y		; B6 D1 ; Load X register $D1.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	ora $D25E33.l,X		; 1F 33 5E D2 ; Logical OR long $D25E33.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpx $2C33.w		; EC 33 2C ; Compare $2C33.w with X register [Reads: X Index] [Flags: NCZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	cpx $2F.b		; E4 2F ; Compare $2F.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc $EE.b		; E5 EE ; Subtract $EE.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $E00E31.l		; 0F 31 0E E0 ; OR accumulator with memory (long) $E00E31.l [Writes: Accumulator] [Flags: NZ]
	ldx $F0.b,Y		; B6 F0 ; Load X register $F0.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	and ($31.b,S),Y		; 33 31 ; AND accumulator (stack relative indirect indexed) ($31.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp ($EC.b)		; D2 EC ; Compare accumulator (indirect) ($EC.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	and ($1E.b,S),Y		; 33 1E ; AND accumulator (stack relative indirect indexed) ($1E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $DEA6.w,X		; BD A6 DE ; Load $DEA6.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy $4E.b		; C4 4E ; Compare $4E.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	bit $64.b		; 24 64 ; Test bits $64.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cpx $B6B0.w		; EC B0 B6 ; Compare $B6B0.w with X register [Reads: X Index] [Flags: NCZ]
	mvp $D2,$11		; 44 11 D2 ; Move block positive $D2,$11 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	jsr ($1023.w,X)		; FC 23 10 ; Jump to subroutine indirect indexed ($1023.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cmp $BADD.w		; CD DD BA ; Compare $BADD.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora ($2C.b,S),Y		; 13 2C ; OR accumulator (stack relative indirect indexed) ($2C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $EFD232.l,X		; FF 32 D2 EF ; Subtract with carry (long,X) $EFD232.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp ($62.b)		; D2 62 ; Compare accumulator (indirect) ($62.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ldx $00.b,Y		; B6 00 ; Load X register $00.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	sbc $1A.b,S		; E3 1A ; Subtract stack-relative $1A.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	sbc ($21.b,S),Y		; F3 21 ; Subtract with carry (stack relative indirect indexed) ($21.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	dec $F2CC.w		; CE CC F2 ; Decrement $F2CC.w [Flags: NZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	ora $C412C2.l		; 0F C2 12 C4 ; OR accumulator with memory (long) $C412C2.l [Writes: Accumulator] [Flags: NZ]
	inc $66DF.w,X		; FE DF 66 ; Increment memory $66DF.w,X [Reads: X Index] [Flags: NZ]
	lda $C4B6.w		; AD B6 C4 ; Load $C4B6.w into accumulator [Writes: Accumulator] [Flags: NZ]
	bit $12D2.w,X		; 3C D2 12 ; Test bits $12D2.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	cmp $23C1FB.l,X		; DF FB C1 23 ; Compare accumulator (long,X) $23C1FB.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	dec $E0.b		; C6 E0 ; Decrement $E0.b [Reads: Direct Page] [Flags: NZ]
	ora ($F1.b)		; 12 F1 ; OR accumulator with memory (indirect) ($F1.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($FD.b),Y		; 11 FD ; OR accumulator with memory ($FD.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	pea $E12F.w		; F4 2F E1 ; Push absolute address $E12F.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	ldx $5E.b,Y		; B6 5E ; Load X register $5E.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	.db $D0, $13		; D0 13 ; Branch if not equal to $D0, $13 [Flow: branch]
	sbc $B00B.w		; ED 0B B0 ; Subtract $B00B.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	bit $DE.b,X		; 34 DE ; Test bits $DE.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ldx $25.b,Y		; B6 25 ; Load X register $25.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	.db $F0, $11		; F0 11 ; Branch if equal to $F0, $11 [Flow: branch]
	trb $60C6.w		; 1C C6 60 ; Test and reset bits $60C6.w [Reads: Accumulator] [Flags: Z]
	ldx $B662.w,Y		; BE 62 B6 ; Load X register $B662.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	dec $FD03.w,X		; DE 03 FD ; Decrement memory $FD03.w,X [Reads: X Index] [Flags: NZ]
	ora $35AE.w,X		; 1D AE 35 ; OR accumulator with memory $35AE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $B604.w		; EE 04 B6 ; Increment $B604.w [Flags: NZ]
	ora $B33F1F.l,X		; 1F 1F 3F B3 ; Logical OR long $B33F1F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($EB.b)		; 52 EB ; Exclusive OR accumulator with memory (indirect) ($EB.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	mvp $B6,$EE		; 44 EE B6 ; Move block positive $B6,$EE [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sbc $0D.b,S		; E3 0D ; Subtract stack-relative $0D.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	asl $24BC.w,X		; 1E BC 24 ; Arithmetic shift left $24BC.w,X [Reads: X Index] [Flags: NCZ]
	inc $4E13.w,X		; FE 13 4E ; Increment memory $4E13.w,X [Reads: X Index] [Flags: NZ]
	ldx $1D.b,Y		; B6 1D ; Load X register $1D.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	and ($B1.b)		; 32 B1 ; AND accumulator with memory (indirect) ($B1.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $42, $2A		; 42 2A ; Reserved instruction
	trb $0E.b		; 14 0E ; Test and reset bits $0E.b [Reads: Accumulator] [Flags: Z]
	cmp ($B6.b)		; D2 B6 ; Compare accumulator (indirect) ($B6.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	trb $DB1F.w		; 1C 1F DB ; Test and reset bits $DB1F.w [Reads: Accumulator] [Flags: Z]
	ora $1D.b		; 05 1D ; Logical OR $1D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($5F.b),Y		; 11 5F ; OR accumulator with memory ($5F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $02B6.w,X		; 1E B6 02 ; Arithmetic shift left $02B6.w,X [Reads: X Index] [Flags: NCZ]
	cmp $E35C40.l,X		; DF 40 5C E3 ; Compare accumulator (long,X) $E35C40.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	jsr $1DD0.w		; 20 D0 1D ; Jump to subroutine at $1DD0.w [Writes: Stack Pointer] [Flow: call]
	ldx $0F.b,Y		; B6 0F ; Load X register $0F.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	cmp $1DE5.w,X		; DD E5 1D ; Compare accumulator $1DE5.w,X [Reads: X Index] [Flags: NCZ]
	ora ($40.b),Y		; 11 40 ; OR accumulator with memory ($40.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $B6F2.w		; 0E F2 B6 ; Arithmetic shift left $B6F2.w [Flags: NCZ]
	asl $5F4F.w,X		; 1E 4F 5F ; Arithmetic shift left $5F4F.w,X [Reads: X Index] [Flags: NCZ]
	lda ($21.b)		; B2 21 ; Load accumulator (indirect) ($21.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $B6E01D.l		; EF 1D E0 B6 ; Subtract with carry (long) $B6E01D.l [Writes: Accumulator] [Flags: NCVZ]
	sbc $1DE5.w		; ED E5 1D ; Subtract $1DE5.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ora ($43.b,X)		; 01 43 ; Logical OR ($43.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $1EF1.w		; 0D F1 1E ; Logical OR $1EF1.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ldx $40.b,Y		; B6 40 ; Load X register $40.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	.db $42, $B0		; 42 B0 ; Reserved instruction
	ora ($0E.b),Y		; 11 0E ; OR accumulator with memory ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $FDDF.w,X		; 1E DF FD ; Arithmetic shift left $FDDF.w,X [Reads: X Index] [Flags: NCZ]
	ldx $D4.b,Y		; B6 D4 ; Load X register $D4.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	and $2E24F0.l		; 2F F0 24 2E ; AND accumulator with memory (long) $2E24F0.l [Writes: Accumulator] [Flags: NZ]
	cmp ($1E.b),Y		; D1 1E ; Compare accumulator ($1E.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	ora ($B6.b),Y		; 11 B6 ; OR accumulator with memory ($B6.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $CF.b,S		; 43 CF ; Exclusive OR accumulator with stack relative $CF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($1E.b),Y		; 11 1E ; OR accumulator with memory ($1E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $D3FEDF.l		; 0F DF FE D3 ; OR accumulator with memory (long) $D3FEDF.l [Writes: Accumulator] [Flags: NZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	jsr ($2102.w,X)		; FC 02 21 ; Jump to subroutine indirect indexed ($2102.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $2DF2.w		; ED F2 2D ; Subtract $2DF2.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	and ($3E.b,X)		; 21 3E ; Logical AND ($3E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ldx $AF.b		; A6 AF ; Load $AF.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	ora ($2E.b,X)		; 01 2E ; Logical OR ($2E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	inc $EDAE.w,X		; FE AE ED ; Increment memory $EDAE.w,X [Reads: X Index] [Flags: NZ]
	sta ($70.b)		; 92 70 ; Store accumulator (indirect) ($70.b) [Reads: Direct Page, Accumulator]
	ldx $FE.b,Y		; B6 FE ; Load X register $FE.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	bit $3E.b		; 24 3E ; Test bits $3E.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	inc $F12F.w		; EE 2F F1 ; Increment $F12F.w [Flags: NZ]
	mvn $BA,$DF		; 54 DF BA ; Move block negative $BA,$DF [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	.db $10, $2E		; 10 2E ; Branch if plus to $10, $2E [Flow: branch]
	asl $0FF1.w,X		; 1E F1 0F ; Arithmetic shift left $0FF1.w,X [Reads: X Index] [Flags: NCZ]
	cop $3E.b		; 02 3E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $25B6.w		; ED B6 25 ; Subtract $25B6.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	eor $FF10ED.l		; 4F ED 10 FF ; Exclusive OR accumulator with memory (long) $FF10ED.l [Writes: Accumulator] [Flags: NZ]
	eor $E0.b		; 45 E0 ; Exclusive OR $E0.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $B6.b		; 00 B6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $FECF0F.l,X		; 1F 0F CF FE ; Logical OR long $FECF0F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$1C23.w		; E0 23 1C ; Compare #$1C23.w with X register [Reads: X Index] [Flags: NCZ]
	sbc $B6.b,X		; F5 B6 ; Subtract $B6.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($DE.b,X)		; 41 DE ; Exclusive OR accumulator with memory ($DE.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $F1.b,X		; 36 F1 ; Rotate left $F1.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cpx #$B61F.w		; E0 1F B6 ; Compare #$B61F.w with X register [Reads: X Index] [Flags: NCZ]
	ora ($CF.b,X)		; 01 CF ; Logical OR ($CF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $2C13D0.l		; EF D0 13 2C ; Subtract with carry (long) $2C13D0.l [Writes: Accumulator] [Flags: NCVZ]
	cmp $42.b,X		; D5 42 ; Compare accumulator $42.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	lda ($1F.b)		; B2 1F ; Load accumulator (indirect) ($1F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $46F50E.l,X		; FF 0E F5 46 ; Subtract with carry (long,X) $46F50E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $43.b,S		; 43 43 ; Exclusive OR accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $B6.b,X		; 34 B6 ; Test bits $B6.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cmp $12C0E0.l		; CF E0 C0 12 ; Compare accumulator (long) $12C0E0.l [Reads: Accumulator] [Flags: NCZ]
	rol $44B4.w		; 2E B4 44 ; Rotate left $44B4.w [Flags: NCZ]
	dec $11B2.w,X		; DE B2 11 ; Decrement memory $11B2.w,X [Reads: X Index] [Flags: NZ]
	asl $57E5.w		; 0E E5 57 ; Arithmetic shift left $57E5.w [Flags: NCZ]
	mvn $33,$65		; 54 65 33 ; Move block negative $33,$65 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $CFF0B6.l		; 0F B6 F0 CF ; OR accumulator with memory (long) $CFF0B6.l [Writes: Accumulator] [Flags: NZ]
	ora ($10.b),Y		; 11 10 ; OR accumulator with memory ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda ($45.b,S),Y		; B3 45 ; Load accumulator (stack relative indirect indexed) ($45.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $B6F1.w		; ED F1 B6 ; Subtract $B6F1.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ora $0F13E5.l		; 0F E5 13 0F ; OR accumulator with memory (long) $0F13E5.l [Writes: Accumulator] [Flags: NZ]
	.db $10, $F0		; 10 F0 ; Branch if plus to $10, $F0 [Flow: branch]
	sbc $CEB6FF.l		; EF FF B6 CE ; Subtract with carry (long) $CEB6FF.l [Writes: Accumulator] [Flags: NCVZ]
	jsl $45C210.l		; 22 10 C2 45 ; Jump to subroutine long $45C210.l [Writes: Stack Pointer] [Flow: call]
	sbc $0EF2.w		; ED F2 0E ; Subtract $0EF2.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ldx $D6.b		; A6 D6 ; Load $D6.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	and $4D.b		; 25 4D ; Logical AND $4D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $CDF0.w		; 20 F0 CD ; Jump to subroutine at $CDF0.w [Writes: Stack Pointer] [Flow: call]
	cpy #$BAAA.w		; C0 AA BA ; Compare #$BAAA.w with Y register [Reads: Y Index] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sbc $BD41E2.l,X		; FF E2 41 BD ; Subtract with carry (long,X) $BD41E2.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $B6130D.l		; 22 0D 13 B6 ; Jump to subroutine long $B6130D.l [Writes: Stack Pointer] [Flow: call]
	ora $4F.b,S		; 03 4F ; OR accumulator with stack relative $4F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $ECD0.w		; EE D0 EC ; Increment $ECD0.w [Flags: NZ]
	cop $BA.b		; 02 BA ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $DC32E1.l,X		; FF E1 32 DC ; Subtract with carry (long,X) $DC32E1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($2E.b),Y		; 11 2E ; OR accumulator with memory ($2E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cop $E3.b		; 02 E3 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx $30.b,Y		; B6 30 ; Load X register $30.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0CD0.w,X		; FD D0 0C ; Subtract with carry $0CD0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
.ACCU 8
	sep #$20		; E2 20
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	sbc ($32.b,X)		; E1 32 ; Subtract with carry ($32.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx $2F01.w		; EC 01 2F ; Compare $2F01.w with X register [Reads: X Index] [Flags: NCZ]
	sbc ($E4.b),Y		; F1 E4 ; Subtract with carry ($E4.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $B6.b		; 00 B6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $01		; 10 01 ; Branch if plus to $10, $01 [Flow: branch]
	bit $2EBF.w		; 2C BF 2E ; Test bits $2EBF.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	cpy #$FE21.w		; C0 21 FE ; Compare #$FE21.w with Y register [Reads: Y Index] [Flags: NCZ]
	ldx $14.b,Y		; B6 14 ; Load X register $14.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	and $0011EF.l,X		; 3F EF 11 00 ; AND accumulator with memory (long,X) $0011EF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($03.b),Y		; F1 03 ; Subtract with carry ($03.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $B6		; 30 B6 ; Branch if minus to $30, $B6 [Flow: branch]
	.db $D0, $4E		; D0 4E ; Branch if not equal to $D0, $4E [Flow: branch]
	ldx $BE2F.w,Y		; BE 2F BE ; Load X register $BE2F.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	and ($FD.b)		; 32 FD ; AND accumulator with memory (indirect) ($FD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $B6.b		; 14 B6 ; Test and reset bits $B6.b [Reads: Accumulator] [Flags: Z]
	eor $F010EF.l		; 4F EF 10 F0 ; Exclusive OR accumulator with memory (long) $F010EF.l [Writes: Accumulator] [Flags: NZ]
	.db $10, $03		; 10 03 ; Branch if plus to $10, $03 [Flow: branch]
	and ($C0.b),Y		; 31 C0 ; AND accumulator with memory ($C0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ldx $40.b,Y		; B6 40 ; Load X register $40.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	lda $CC30.w		; AD 30 CC ; Load $CC30.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($0E.b,S),Y		; 13 0E ; OR accumulator (stack relative indirect indexed) ($0E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $31.b,S		; 03 31 ; OR accumulator with stack relative $31.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldx $FE.b,Y		; B6 FE ; Load X register $FE.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	ora ($F1.b,X)		; 01 F1 ; Logical OR ($F1.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rol $43E2.w		; 2E E2 43 ; Rotate left $43E2.w [Flags: NCZ]
	cmp $BBB642.l		; CF 42 B6 BB ; Compare accumulator (long) $BBB642.l [Reads: Accumulator] [Flags: NCZ]
	and ($DB.b,X)		; 21 DB ; Logical AND ($DB.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $0E.b		; 04 0E ; Test and set bits $0E.b [Reads: Accumulator] [Flags: Z]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $01B6.w		; 0D B6 01 ; Logical OR $01B6.w with accumulator [Writes: Accumulator] [Flags: NZ]
.ACCU 8
.INDEX 8
	sep #$3F		; E2 3F
	sbc ($43.b,X)		; E1 43 ; Subtract with carry ($43.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $DC43.w		; CE 43 DC ; Decrement $DC43.w [Flags: NZ]
	ldx $00.b,Y		; B6 00 ; Load X register $00.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	jmp.w [$2FE3]		; DC E3 2F ; Jump long indirect [$2FE3] [Flow: jump]
	sbc ($12.b)		; F2 12 ; Subtract with carry (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	asl $B601.w,X		; 1E 01 B6 ; Arithmetic shift left $B601.w,X [Reads: X Index] [Flags: NCZ]
	sbc ($3F.b,X)		; E1 3F ; Subtract with carry ($3F.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$53.b		; E0 53 ; Compare #$53.b with X register [Reads: X Index] [Flags: NCZ]
	cmp $ED32.w,X		; DD 32 ED ; Compare accumulator $ED32.w,X [Reads: X Index] [Flags: NCZ]
	ora ($A6.b,X)		; 01 A6 ; Logical OR ($A6.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	sta ($41.b)		; 92 41 ; Store accumulator (indirect) ($41.b) [Reads: Direct Page, Accumulator]
	ora ($F3.b),Y		; 11 F3 ; OR accumulator with memory ($F3.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ror $F0D1.w		; 6E D1 F0 ; Rotate right $F0D1.w [Flags: NCZ]
	ldx $30.b,Y		; B6 30 ; Load X register $30.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	sbc $22DC45.l		; EF 45 DC 22 ; Subtract with carry (long) $22DC45.l [Writes: Accumulator] [Flags: NCVZ]
	asl $DEF0.w		; 0E F0 DE ; Arithmetic shift left $DEF0.w [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	cmp [$3D.b]		; C7 3D ; Compare accumulator (long) [$3D.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cop $5B.b		; 02 5B ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $2D.b		; A5 2D ; Load $2D.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jmp $25F0B6.l		; 5C B6 F0 25 ; Jump long to $25F0B6.l [Flow: jump]
	cpx $2F10.w		; EC 10 2F ; Compare $2F10.w with X register [Reads: X Index] [Flags: NCZ]
	.db $F0, $DE		; F0 DE ; Branch if equal to $F0, $DE [Flow: branch]
	cmp $4010B6.l		; CF B6 10 40 ; Compare accumulator (long) $4010B6.l [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $23		; F0 23 ; Branch if equal to $F0, $23 [Flow: branch]
	cmp $002010.l,X		; DF 10 20 00 ; Compare accumulator (long,X) $002010.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	ldx $15.b,Y		; B6 15 ; Load X register $15.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	jsr ($2F00.w,X)		; FC 00 2F ; Jump to subroutine indirect indexed ($2F00.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cop $EC.b		; 02 EC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $20B63F.l,X		; BF 3F B6 20 ; Load long $20B63F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $102F2F.l		; EF 2F 2F 10 ; Subtract with carry (long) $102F2F.l [Writes: Accumulator] [Flags: NCVZ]
	trb $BA.b		; 14 BA ; Test and reset bits $BA.b [Reads: Accumulator] [Flags: Z]
	cmp $2C22.w		; CD 22 2C ; Compare $2C22.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora ($EE.b)		; 12 EE ; OR accumulator with memory (indirect) ($EE.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $4D.b,S		; E3 4D ; Subtract stack-relative $4D.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	ora $073FA6.l,X		; 1F A6 3F 07 ; Logical OR long $073FA6.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpx $3030.w		; EC 30 30 ; Compare $3030.w with X register [Reads: X Index] [Flags: NCZ]
	and ($05.b),Y		; 31 05 ; AND accumulator with memory ($05.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $E3BA.w		; 2D BA E3 ; Logical AND $E3BA.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $DE31.w		; 2D 31 DE ; Logical AND $DE31.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp ($5F.b,S),Y		; D3 5F ; Compare accumulator (stack relative indirect indexed) ($5F.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	.db $D0, $4D		; D0 4D ; Branch if not equal to $D0, $4D [Flow: branch]
	ldx $F3.b,Y		; B6 F3 ; Load X register $F3.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	asl $1001.w		; 0E 01 10 ; Arithmetic shift left $1001.w [Flags: NCZ]
	ora ($21.b),Y		; 11 21 ; OR accumulator with memory ($21.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($CE.b),Y		; 11 CE ; OR accumulator with memory ($CE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ldx $0E.b,Y		; B6 0E ; Load X register $0E.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	and $0F.b,S		; 23 0F ; AND accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldy $FE03.w,X		; BC 03 FE ; Load Y register $FE03.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	eor ($01.b,X)		; 41 01 ; Exclusive OR accumulator with memory ($01.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ldx $1E.b		; A6 1E ; Load $1E.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	cmp ($30.b,S),Y		; D3 30 ; Compare accumulator (stack relative indirect indexed) ($30.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	and ($4E.b)		; 32 4E ; AND accumulator with memory (indirect) ($4E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $AA.b		; 25 AA ; Logical AND $AA.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ldx $13.b,Y		; B6 13 ; Load X register $13.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	brk $EC.b		; 00 EC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FC.b,S		; E3 FC ; Subtract stack-relative $FC.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	and ($21.b)		; 32 21 ; AND accumulator with memory (indirect) ($21.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $B6.b		; 00 B6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($20.b,X)		; E1 20 ; Subtract with carry ($20.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($2E.b,X)		; 21 2E ; Logical AND ($2E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $FD.b		; 02 FD ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FFA6F3.l		; EF F3 A6 FF ; Subtract with carry (long) $FFA6F3.l [Writes: Accumulator] [Flags: NCVZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	lda $0A.b,S		; A3 0A ; Load accumulator (stack relative) $0A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $31.b,X		; 34 31 ; Test bits $31.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	pea $BAC1.w		; F4 C1 BA ; Push absolute address $BAC1.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	.db $10, $1E		; 10 1E ; Branch if plus to $10, $1E [Flow: branch]
	ora $FD31.w,X		; 1D 31 FD ; OR accumulator with memory $FD31.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pea $E0E3.w		; F4 E3 E0 ; Push absolute address $E0E3.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	ldx $5C.b		; A6 5C ; Load $5C.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	cpy #$EA.b		; C0 EA ; Compare #$EA.b with Y register [Reads: Y Index] [Flags: NCZ]
	rol $30.b		; 26 30 ; Rotate left $30.b [Reads: Direct Page] [Flags: NCZ]
	sbc $F0.b,X		; F5 F0 ; Subtract $F0.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($B6.b,S),Y		; F3 B6 ; Subtract with carry (stack relative indirect indexed) ($B6.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $10		; 30 10 ; Branch if minus to $30, $10 [Flow: branch]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $F0, $4F		; F0 4F ; Branch if equal to $F0, $4F [Flow: branch]
	ldx $FF.b,Y		; B6 FF ; Load X register $FF.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	sbc $1F14.w		; ED 14 1F ; Subtract $1F14.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sep #$40		; E2 40 ; Set processor status bits #$40 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	ldx $F1.b,Y		; B6 F1 ; Load X register $F1.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	ora $EE00EE.l,X		; 1F EE 00 EE ; Logical OR long $EE00EE.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($40.b,X)		; E1 40 ; Subtract with carry ($40.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $05DCB6.l,X		; 1F B6 DC 05 ; Logical OR long $05DCB6.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $1F04.w,X		; 1E 04 1F ; Arithmetic shift left $1F04.w,X [Reads: X Index] [Flags: NCZ]
	sbc $4F.b,S		; E3 4F ; Subtract stack-relative $4F.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	cmp ($B6.b)		; D2 B6 ; Compare accumulator (indirect) ($B6.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	and $EE20DE.l		; 2F DE 20 EE ; AND accumulator with memory (long) $EE20DE.l [Writes: Accumulator] [Flags: NZ]
	sbc ($30.b,X)		; E1 30 ; Subtract with carry ($30.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $04B6DC.l		; 2F DC B6 04 ; AND accumulator with memory (long) $04B6DC.l [Writes: Accumulator] [Flags: NZ]
	ora $2E05.w,X		; 1D 05 2E ; OR accumulator with memory $2E05.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($6F.b,S),Y		; D3 6F ; Compare accumulator (stack relative indirect indexed) ($6F.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	cmp ($21.b,X)		; C1 21 ; Compare accumulator ($21.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	ldx $CE.b,Y		; B6 CE ; Load X register $CE.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	jsr $E0EE.w		; 20 EE E0 ; Jump to subroutine at $E0EE.w [Writes: Stack Pointer] [Flow: call]
	ora ($40.b),Y		; 11 40 ; OR accumulator with memory ($40.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$B621]		; DC 21 B6 ; Jump long indirect [$B621] [Flow: jump]
	sbc $3E15.w,X		; FD 15 3E ; Subtract with carry $3E15.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp ($6E.b,S),Y		; D3 6E ; Compare accumulator (stack relative indirect indexed) ($6E.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	sbc ($10.b,X)		; E1 10 ; Subtract with carry ($10.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $EE30B6.l,X		; BF B6 30 EE ; Load long $EE30B6.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $F1		; F0 F1 ; Branch if equal to $F0, $F1 [Flow: branch]
	eor ($BD.b,X)		; 41 BD ; Exclusive OR accumulator with memory ($BD.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	dec $23B6.w,X		; DE B6 23 ; Decrement memory $23B6.w,X [Reads: X Index] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cmp ($6F.b)		; D2 6F ; Compare accumulator (indirect) ($6F.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	.db $F0, $1F		; F0 1F ; Branch if equal to $F0, $1F [Flow: branch]
	lda $EEB630.l,X		; BF 30 B6 EE ; Load long $EEB630.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $CE42F1.l		; 0F F1 42 CE ; OR accumulator with memory (long) $CE42F1.l [Writes: Accumulator] [Flags: NZ]
	and $BA33CD.l,X		; 3F CD 33 BA ; AND accumulator with memory (long,X) $BA33CD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $4CC4.w,X		; 1D C4 4C ; OR accumulator with memory $4CC4.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $2FE21F.l		; 0F 1F E2 2F ; OR accumulator with memory (long) $2FE21F.l [Writes: Accumulator] [Flags: NZ]
	cpx #$B6.b		; E0 B6 ; Compare #$B6.b with X register [Reads: X Index] [Flags: NCZ]
	and $DF32F0.l		; 2F F0 32 DF ; AND accumulator with memory (long) $DF32F0.l [Writes: Accumulator] [Flags: NZ]
	and $3233CC.l,X		; 3F CC 33 32 ; AND accumulator with memory (long,X) $3233CC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldx $D0.b		; A6 D0 ; Load $D0.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	.db $62, $40, $EB		; 62 40 EB ; Push effective relative address $62, $40, $EB [Writes: Stack Pointer]
	lda $3DEEFF.l,X		; BF FF EE 3D ; Load long $3DEEFF.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldx $F0.b,Y		; B6 F0 ; Load X register $F0.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	and ($F1.b,X)		; 21 F1 ; Logical AND ($F1.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rol $13DC.w		; 2E DC 13 ; Rotate left $13DC.w [Flags: NCZ]
	and ($00.b)		; 32 00 ; AND accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldx $32.b		; A6 32 ; Load $32.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	adc ($A9.b,S),Y		; 73 A9 ; Add with carry (stack relative indirect indexed) ($A9.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $D0, $ED		; D0 ED ; Branch if not equal to $D0, $ED [Flow: branch]
	ora $AAFF0E.l		; 0F 0E FF AA ; OR accumulator with memory (long) $AAFF0E.l [Writes: Accumulator] [Flags: NZ]
	rol $FB11.w,X		; 3E 11 FB ; Rotate left $FB11.w,X [Reads: X Index] [Flags: NCZ]
	ora $2E36.w,X		; 1D 36 2E ; OR accumulator with memory $2E36.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpx $B640.w		; EC 40 B6 ; Compare $B640.w with X register [Reads: X Index] [Flags: NCZ]
	mvp $F0,$CC		; 44 CC F0 ; Move block positive $F0,$CC [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sbc $FF11.w		; ED 11 FF ; Subtract $FF11.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	inc $E32F.w		; EE 2F E3 ; Increment $E32F.w [Flags: NZ]
	rol $2F1D.w,X		; 3E 1D 2F ; Rotate left $2F1D.w,X [Reads: X Index] [Flags: NCZ]
	and ($B6.b)		; 32 B6 ; AND accumulator with memory (indirect) ($B6.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$FCEF]		; DC EF FC ; Jump long indirect [$FCEF] [Flow: jump]
	cop $FF.b		; 02 FF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $FE.b		; 02 FE ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $B6.b,S		; 23 B6 ; AND accumulator with stack relative $B6.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $EF01.w,X		; FE 01 EF ; Increment memory $EF01.w,X [Reads: X Index] [Flags: NZ]
	and ($20.b)		; 32 20 ; AND accumulator with memory (indirect) ($20.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $24		; 10 24 ; Branch if plus to $10, $24 [Flow: branch]
	cpx $EFB6.w		; EC B6 EF ; Compare $EFB6.w with X register [Reads: X Index] [Flags: NCZ]
	jsr ($0E03.w,X)		; FC 03 0E ; Jump to subroutine indirect indexed ($0E03.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc ($EE.b,S),Y		; F3 EE ; Subtract with carry (stack relative indirect indexed) ($EE.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	bit $FE.b		; 24 FE ; Test bits $FE.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ldx $02.b		; A6 02 ; Load $02.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	cmp $0156.w		; CD 56 01 ; Compare $0156.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $50, $35		; 50 35 ; Branch if overflow clear to $50, $35 [Flow: branch]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	lda $FAA6.w,X		; BD A6 FA ; Load $FAA6.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($2E.b),Y		; F1 2E ; Subtract with carry ($2E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $DD.b		; C5 DD ; Compare $DD.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora [$3C.b]		; 07 3C ; OR accumulator with memory (long) [$3C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc ($B6.b,X)		; E1 B6 ; Subtract with carry ($B6.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $400013.l		; 0F 13 00 40 ; OR accumulator with memory (long) $400013.l [Writes: Accumulator] [Flags: NZ]
	and ($0F.b,X)		; 21 0F ; Logical AND ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	dec $A6FD.w,X		; DE FD A6 ; Decrement memory $A6FD.w,X [Reads: X Index] [Flags: NZ]
	ora $C540.w		; 0D 40 C5 ; Logical OR $C540.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cpx $7ED4.w		; EC D4 7E ; Compare $7ED4.w with X register [Reads: X Index] [Flags: NCZ]
	sbc $BA3F.w		; ED 3F BA ; Subtract $BA3F.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ora ($0F.b),Y		; 11 0F ; OR accumulator with memory ($0F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	jsr $D100.w		; 20 00 D1 ; Jump to subroutine at $D100.w [Writes: Stack Pointer] [Flow: call]
	ora $11B63D.l		; 0F 3D B6 11 ; OR accumulator with memory (long) $11B63D.l [Writes: Accumulator] [Flags: NZ]
	sbc ($0E.b)		; F2 0E ; Subtract with carry (indirect) ($0E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($40.b,X)		; E1 40 ; Subtract with carry ($40.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $1010.w		; 0D 10 10 ; Logical OR $1010.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	.db $10, $4C		; 10 4C ; Branch if plus to $10, $4C [Flow: branch]
	ora $F0E011.l		; 0F 11 E0 F0 ; OR accumulator with memory (long) $F0E011.l [Writes: Accumulator] [Flags: NZ]
	and $B631.w		; 2D 31 B6 ; Logical AND $B631.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $D0, $32		; D0 32 ; Branch if not equal to $D0, $32 [Flow: branch]
	bit $20F1.w		; 2C F1 20 ; Test bits $20F1.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	sbc ($BA.b,S),Y		; F3 BA ; Subtract with carry (stack relative indirect indexed) ($BA.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $1F1E.w,X		; 1D 1E 1F ; OR accumulator with memory $1F1E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($F0.b,X)		; 01 F0 ; Logical OR ($F0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $FE42.w		; 0D 42 FE ; Logical OR $FE42.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ldx $F0.b,Y		; B6 F0 ; Load X register $F0.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	.db $D0, $31		; D0 31 ; Branch if not equal to $D0, $31 [Flow: branch]
	and $30E1.w,X		; 3D E1 30 ; AND accumulator with memory $30E1.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($51.b,S),Y		; D3 51 ; Compare accumulator (stack relative indirect indexed) ($51.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	trb $F230.w		; 1C 30 F2 ; Test and reset bits $F230.w [Reads: Accumulator] [Flags: Z]
	cpx #$FD.b		; E0 FD ; Compare #$FD.b with X register [Reads: X Index] [Flags: NCZ]
	.db $42, $1E		; 42 1E ; Reserved instruction
	sbc ($BA.b),Y		; F1 BA ; Subtract with carry ($BA.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
.ACCU 16
.INDEX 16
	rep #$3F		; C2 3F
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cmp ($4F.b,S),Y		; D3 4F ; Compare accumulator (stack relative indirect indexed) ($4F.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	lda $5C.b		; A5 5C ; Load $5C.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	eor ($D2.b),Y		; 51 D2 ; Exclusive OR accumulator with memory ($D2.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $EA		; 10 EA ; Branch if plus to $10, $EA [Flow: branch]
	adc ($2E.b,X)		; 61 2E ; Add with carry ($2E.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($D1.b),Y		; F1 D1 ; Subtract with carry ($D1.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx $10.b,Y		; B6 10 ; Load X register $10.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	.db $50, $ED		; 50 ED ; Branch if overflow clear to $50, $ED [Flow: branch]
	and $D0.b,S		; 23 D0 ; AND accumulator with stack relative $D0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $3B.b,S		; 63 3B ; Add with carry (stack relative) $3B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($B2.b),Y		; F1 B2 ; Subtract with carry ($B2.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $9B3B45.l		; 22 45 3B 9B ; Jump to subroutine long $9B3B45.l [Writes: Stack Pointer] [Flow: call]
	cmp $CACD.w,X		; DD CD CA ; Compare accumulator $CACD.w,X [Reads: X Index] [Flags: NCZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ldx $62.b,Y		; B6 62 ; Load X register $62.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	tsb $EE03.w		; 0C 03 EE ; Test and set bits $EE03.w [Reads: Accumulator] [Flags: Z]
	mvn $E2,$5B		; 54 5B E2 ; Move block negative $E2,$5B [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	inc $23C2.w,X		; FE C2 23 ; Increment memory $23C2.w,X [Reads: X Index] [Flags: NZ]
	and $DEFEDE.l,X		; 3F DE FE DE ; AND accumulator with memory (long,X) $DEFEDE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $F1DC.w,X		; FE DC F1 ; Increment memory $F1DC.w,X [Reads: X Index] [Flags: NZ]
	ldx $1C.b,Y		; B6 1C ; Load X register $1C.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	sep #$0F		; E2 0F ; Set processor status bits #$0F [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	mvn $D2,$5C		; 54 5C D2 ; Move block negative $D2,$5C [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sbc $B633.w		; ED 33 B6 ; Subtract $B633.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ldy #$F21F.w		; A0 1F F2 ; Load #$F21F.w into Y register [Writes: Y Index] [Flags: NZ]
	ora $2E24FF.l		; 0F FF 24 2E ; OR accumulator with memory (long) $2E24FF.l [Writes: Accumulator] [Flags: NZ]
	ldx $D1.b,Y		; B6 D1 ; Load X register $D1.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	ora $D25E33.l,X		; 1F 33 5E D2 ; Logical OR long $D25E33.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpx $2C33.w		; EC 33 2C ; Compare $2C33.w with X register [Reads: X Index] [Flags: NCZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	cpx $2F.b		; E4 2F ; Compare $2F.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc $EE.b		; E5 EE ; Subtract $EE.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $E00E31.l		; 0F 31 0E E0 ; OR accumulator with memory (long) $E00E31.l [Writes: Accumulator] [Flags: NZ]
	ldx $F0.b,Y		; B6 F0 ; Load X register $F0.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	and ($31.b,S),Y		; 33 31 ; AND accumulator (stack relative indirect indexed) ($31.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp ($EC.b)		; D2 EC ; Compare accumulator (indirect) ($EC.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	and ($1E.b,S),Y		; 33 1E ; AND accumulator (stack relative indirect indexed) ($1E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $DEA6.w,X		; BD A6 DE ; Load $DEA6.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy $4E.b		; C4 4E ; Compare $4E.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	bit $64.b		; 24 64 ; Test bits $64.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cpx $B6B0.w		; EC B0 B6 ; Compare $B6B0.w with X register [Reads: X Index] [Flags: NCZ]
	mvp $D2,$11		; 44 11 D2 ; Move block positive $D2,$11 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	jsr ($1023.w,X)		; FC 23 10 ; Jump to subroutine indirect indexed ($1023.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cmp $BADD.w		; CD DD BA ; Compare $BADD.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora ($2C.b,S),Y		; 13 2C ; OR accumulator (stack relative indirect indexed) ($2C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $EFD232.l,X		; FF 32 D2 EF ; Subtract with carry (long,X) $EFD232.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp ($62.b)		; D2 62 ; Compare accumulator (indirect) ($62.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ldx $00.b,Y		; B6 00 ; Load X register $00.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	sbc $1A.b,S		; E3 1A ; Subtract stack-relative $1A.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	sbc ($21.b,S),Y		; F3 21 ; Subtract with carry (stack relative indirect indexed) ($21.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	dec $F2CC.w		; CE CC F2 ; Decrement $F2CC.w [Flags: NZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	ora $C412C2.l		; 0F C2 12 C4 ; OR accumulator with memory (long) $C412C2.l [Writes: Accumulator] [Flags: NZ]
	inc $66DF.w,X		; FE DF 66 ; Increment memory $66DF.w,X [Reads: X Index] [Flags: NZ]
	lda $C4B6.w		; AD B6 C4 ; Load $C4B6.w into accumulator [Writes: Accumulator] [Flags: NZ]
	bit $12D2.w,X		; 3C D2 12 ; Test bits $12D2.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	cmp $23C1FB.l,X		; DF FB C1 23 ; Compare accumulator (long,X) $23C1FB.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	dec $E0.b		; C6 E0 ; Decrement $E0.b [Reads: Direct Page] [Flags: NZ]
	ora ($F1.b)		; 12 F1 ; OR accumulator with memory (indirect) ($F1.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($FD.b),Y		; 11 FD ; OR accumulator with memory ($FD.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	pea $E12F.w		; F4 2F E1 ; Push absolute address $E12F.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	ldx $5E.b,Y		; B6 5E ; Load X register $5E.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	.db $D0, $13		; D0 13 ; Branch if not equal to $D0, $13 [Flow: branch]
	sbc $B00B.w		; ED 0B B0 ; Subtract $B00B.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	bit $DE.b,X		; 34 DE ; Test bits $DE.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ldx $25.b,Y		; B6 25 ; Load X register $25.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	.db $F0, $11		; F0 11 ; Branch if equal to $F0, $11 [Flow: branch]
	trb $60C6.w		; 1C C6 60 ; Test and reset bits $60C6.w [Reads: Accumulator] [Flags: Z]
	ldx $B662.w,Y		; BE 62 B6 ; Load X register $B662.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	dec $FD03.w,X		; DE 03 FD ; Decrement memory $FD03.w,X [Reads: X Index] [Flags: NZ]
	ora $35AE.w,X		; 1D AE 35 ; OR accumulator with memory $35AE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $B604.w		; EE 04 B6 ; Increment $B604.w [Flags: NZ]
	ora $B33F1F.l,X		; 1F 1F 3F B3 ; Logical OR long $B33F1F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($EB.b)		; 52 EB ; Exclusive OR accumulator with memory (indirect) ($EB.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	mvp $B6,$EE		; 44 EE B6 ; Move block positive $B6,$EE [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sbc $0D.b,S		; E3 0D ; Subtract stack-relative $0D.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	asl $24BC.w,X		; 1E BC 24 ; Arithmetic shift left $24BC.w,X [Reads: X Index] [Flags: NCZ]
	inc $4E13.w,X		; FE 13 4E ; Increment memory $4E13.w,X [Reads: X Index] [Flags: NZ]
	ldx $1D.b,Y		; B6 1D ; Load X register $1D.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	and ($B1.b)		; 32 B1 ; AND accumulator with memory (indirect) ($B1.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $42, $2A		; 42 2A ; Reserved instruction
	trb $0E.b		; 14 0E ; Test and reset bits $0E.b [Reads: Accumulator] [Flags: Z]
	cmp ($B6.b)		; D2 B6 ; Compare accumulator (indirect) ($B6.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	trb $DB1F.w		; 1C 1F DB ; Test and reset bits $DB1F.w [Reads: Accumulator] [Flags: Z]
	ora $1D.b		; 05 1D ; Logical OR $1D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($5F.b),Y		; 11 5F ; OR accumulator with memory ($5F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $02B6.w,X		; 1E B6 02 ; Arithmetic shift left $02B6.w,X [Reads: X Index] [Flags: NCZ]
	cmp $E35C40.l,X		; DF 40 5C E3 ; Compare accumulator (long,X) $E35C40.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	jsr $1DD0.w		; 20 D0 1D ; Jump to subroutine at $1DD0.w [Writes: Stack Pointer] [Flow: call]
	ldx $0F.b,Y		; B6 0F ; Load X register $0F.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	cmp $1DE5.w,X		; DD E5 1D ; Compare accumulator $1DE5.w,X [Reads: X Index] [Flags: NCZ]
	ora ($40.b),Y		; 11 40 ; OR accumulator with memory ($40.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $B6F2.w		; 0E F2 B6 ; Arithmetic shift left $B6F2.w [Flags: NCZ]
	asl $5F4F.w,X		; 1E 4F 5F ; Arithmetic shift left $5F4F.w,X [Reads: X Index] [Flags: NCZ]
	lda ($21.b)		; B2 21 ; Load accumulator (indirect) ($21.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $B6E01D.l		; EF 1D E0 B6 ; Subtract with carry (long) $B6E01D.l [Writes: Accumulator] [Flags: NCVZ]
	sbc $1DE5.w		; ED E5 1D ; Subtract $1DE5.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ora ($43.b,X)		; 01 43 ; Logical OR ($43.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $1EF1.w		; 0D F1 1E ; Logical OR $1EF1.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ldx $40.b,Y		; B6 40 ; Load X register $40.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	.db $42, $B0		; 42 B0 ; Reserved instruction
	ora ($0E.b),Y		; 11 0E ; OR accumulator with memory ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $FDDF.w,X		; 1E DF FD ; Arithmetic shift left $FDDF.w,X [Reads: X Index] [Flags: NCZ]
	ldx $D4.b,Y		; B6 D4 ; Load X register $D4.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	and $2E24F0.l		; 2F F0 24 2E ; AND accumulator with memory (long) $2E24F0.l [Writes: Accumulator] [Flags: NZ]
	cmp ($1E.b),Y		; D1 1E ; Compare accumulator ($1E.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	ora ($B6.b),Y		; 11 B6 ; OR accumulator with memory ($B6.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $CF.b,S		; 43 CF ; Exclusive OR accumulator with stack relative $CF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($1E.b),Y		; 11 1E ; OR accumulator with memory ($1E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $D3FEDF.l		; 0F DF FE D3 ; OR accumulator with memory (long) $D3FEDF.l [Writes: Accumulator] [Flags: NZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	jsr ($2102.w,X)		; FC 02 21 ; Jump to subroutine indirect indexed ($2102.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $2DF2.w		; ED F2 2D ; Subtract $2DF2.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	and ($3E.b,X)		; 21 3E ; Logical AND ($3E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ldx $AF.b		; A6 AF ; Load $AF.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	ora ($2E.b,X)		; 01 2E ; Logical OR ($2E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	inc $EDAE.w,X		; FE AE ED ; Increment memory $EDAE.w,X [Reads: X Index] [Flags: NZ]
	sta ($70.b)		; 92 70 ; Store accumulator (indirect) ($70.b) [Reads: Direct Page, Accumulator]
	ldx $FE.b,Y		; B6 FE ; Load X register $FE.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	bit $3E.b		; 24 3E ; Test bits $3E.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	inc $F12F.w		; EE 2F F1 ; Increment $F12F.w [Flags: NZ]
	mvn $BA,$DF		; 54 DF BA ; Move block negative $BA,$DF [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	.db $10, $2E		; 10 2E ; Branch if plus to $10, $2E [Flow: branch]
	asl $0FF1.w,X		; 1E F1 0F ; Arithmetic shift left $0FF1.w,X [Reads: X Index] [Flags: NCZ]
	cop $3E.b		; 02 3E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $25B6.w		; ED B6 25 ; Subtract $25B6.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	eor $FF10ED.l		; 4F ED 10 FF ; Exclusive OR accumulator with memory (long) $FF10ED.l [Writes: Accumulator] [Flags: NZ]
	eor $E0.b		; 45 E0 ; Exclusive OR $E0.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $B6.b		; 00 B6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $FECF0F.l,X		; 1F 0F CF FE ; Logical OR long $FECF0F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$1C23.w		; E0 23 1C ; Compare #$1C23.w with X register [Reads: X Index] [Flags: NCZ]
	sbc $B6.b,X		; F5 B6 ; Subtract $B6.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($DE.b,X)		; 41 DE ; Exclusive OR accumulator with memory ($DE.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $F1.b,X		; 36 F1 ; Rotate left $F1.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cpx #$B61F.w		; E0 1F B6 ; Compare #$B61F.w with X register [Reads: X Index] [Flags: NCZ]
	ora ($CF.b,X)		; 01 CF ; Logical OR ($CF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $2C13D0.l		; EF D0 13 2C ; Subtract with carry (long) $2C13D0.l [Writes: Accumulator] [Flags: NCVZ]
	cmp $42.b,X		; D5 42 ; Compare accumulator $42.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	lda ($1F.b)		; B2 1F ; Load accumulator (indirect) ($1F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $46F50E.l,X		; FF 0E F5 46 ; Subtract with carry (long,X) $46F50E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $43.b,S		; 43 43 ; Exclusive OR accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $B6.b,X		; 34 B6 ; Test bits $B6.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cmp $12C0E0.l		; CF E0 C0 12 ; Compare accumulator (long) $12C0E0.l [Reads: Accumulator] [Flags: NCZ]
	rol $44B4.w		; 2E B4 44 ; Rotate left $44B4.w [Flags: NCZ]
	dec $11B2.w,X		; DE B2 11 ; Decrement memory $11B2.w,X [Reads: X Index] [Flags: NZ]
	asl $57E5.w		; 0E E5 57 ; Arithmetic shift left $57E5.w [Flags: NCZ]
	mvn $33,$65		; 54 65 33 ; Move block negative $33,$65 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $CFF0B6.l		; 0F B6 F0 CF ; OR accumulator with memory (long) $CFF0B6.l [Writes: Accumulator] [Flags: NZ]
	ora ($10.b),Y		; 11 10 ; OR accumulator with memory ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda ($45.b,S),Y		; B3 45 ; Load accumulator (stack relative indirect indexed) ($45.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $B6F1.w		; ED F1 B6 ; Subtract $B6F1.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ora $0F13E5.l		; 0F E5 13 0F ; OR accumulator with memory (long) $0F13E5.l [Writes: Accumulator] [Flags: NZ]
	.db $10, $F0		; 10 F0 ; Branch if plus to $10, $F0 [Flow: branch]
	sbc $CEB6FF.l		; EF FF B6 CE ; Subtract with carry (long) $CEB6FF.l [Writes: Accumulator] [Flags: NCVZ]
	jsl $45C210.l		; 22 10 C2 45 ; Jump to subroutine long $45C210.l [Writes: Stack Pointer] [Flow: call]
	sbc $0EF2.w		; ED F2 0E ; Subtract $0EF2.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ldx $D6.b		; A6 D6 ; Load $D6.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	and $4D.b		; 25 4D ; Logical AND $4D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $CDF0.w		; 20 F0 CD ; Jump to subroutine at $CDF0.w [Writes: Stack Pointer] [Flow: call]
	cpy #$BAAA.w		; C0 AA BA ; Compare #$BAAA.w with Y register [Reads: Y Index] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sbc $BD41E2.l,X		; FF E2 41 BD ; Subtract with carry (long,X) $BD41E2.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $B6130D.l		; 22 0D 13 B6 ; Jump to subroutine long $B6130D.l [Writes: Stack Pointer] [Flow: call]
	ora $4F.b,S		; 03 4F ; OR accumulator with stack relative $4F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $ECD0.w		; EE D0 EC ; Increment $ECD0.w [Flags: NZ]
	cop $BA.b		; 02 BA ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $DC32E1.l,X		; FF E1 32 DC ; Subtract with carry (long,X) $DC32E1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($2E.b),Y		; 11 2E ; OR accumulator with memory ($2E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cop $E3.b		; 02 E3 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx $30.b,Y		; B6 30 ; Load X register $30.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0CD0.w,X		; FD D0 0C ; Subtract with carry $0CD0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
.ACCU 8
	sep #$20		; E2 20
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	sbc ($32.b,X)		; E1 32 ; Subtract with carry ($32.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx $2F01.w		; EC 01 2F ; Compare $2F01.w with X register [Reads: X Index] [Flags: NCZ]
	sbc ($E4.b),Y		; F1 E4 ; Subtract with carry ($E4.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $B6.b		; 00 B6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $01		; 10 01 ; Branch if plus to $10, $01 [Flow: branch]
	bit $2EBF.w		; 2C BF 2E ; Test bits $2EBF.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	cpy #$FE21.w		; C0 21 FE ; Compare #$FE21.w with Y register [Reads: Y Index] [Flags: NCZ]
	ldx $14.b,Y		; B6 14 ; Load X register $14.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	and $0011EF.l,X		; 3F EF 11 00 ; AND accumulator with memory (long,X) $0011EF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($03.b),Y		; F1 03 ; Subtract with carry ($03.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $B6		; 30 B6 ; Branch if minus to $30, $B6 [Flow: branch]
	.db $D0, $4E		; D0 4E ; Branch if not equal to $D0, $4E [Flow: branch]
	ldx $BE2F.w,Y		; BE 2F BE ; Load X register $BE2F.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	and ($FD.b)		; 32 FD ; AND accumulator with memory (indirect) ($FD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $B6.b		; 14 B6 ; Test and reset bits $B6.b [Reads: Accumulator] [Flags: Z]
	eor $F010EF.l		; 4F EF 10 F0 ; Exclusive OR accumulator with memory (long) $F010EF.l [Writes: Accumulator] [Flags: NZ]
	.db $10, $03		; 10 03 ; Branch if plus to $10, $03 [Flow: branch]
	and ($C0.b),Y		; 31 C0 ; AND accumulator with memory ($C0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ldx $40.b,Y		; B6 40 ; Load X register $40.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	lda $CC30.w		; AD 30 CC ; Load $CC30.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($0E.b,S),Y		; 13 0E ; OR accumulator (stack relative indirect indexed) ($0E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $31.b,S		; 03 31 ; OR accumulator with stack relative $31.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldx $FE.b,Y		; B6 FE ; Load X register $FE.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	ora ($F1.b,X)		; 01 F1 ; Logical OR ($F1.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rol $43E2.w		; 2E E2 43 ; Rotate left $43E2.w [Flags: NCZ]
	cmp $BBB642.l		; CF 42 B6 BB ; Compare accumulator (long) $BBB642.l [Reads: Accumulator] [Flags: NCZ]
	and ($DB.b,X)		; 21 DB ; Logical AND ($DB.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $0E.b		; 04 0E ; Test and set bits $0E.b [Reads: Accumulator] [Flags: Z]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $01B6.w		; 0D B6 01 ; Logical OR $01B6.w with accumulator [Writes: Accumulator] [Flags: NZ]
.ACCU 8
.INDEX 8
	sep #$3F		; E2 3F
	sbc ($43.b,X)		; E1 43 ; Subtract with carry ($43.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $DC43.w		; CE 43 DC ; Decrement $DC43.w [Flags: NZ]
	ldx $00.b,Y		; B6 00 ; Load X register $00.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	jmp.w [$2FE3]		; DC E3 2F ; Jump long indirect [$2FE3] [Flow: jump]
	sbc ($12.b)		; F2 12 ; Subtract with carry (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	asl $B601.w,X		; 1E 01 B6 ; Arithmetic shift left $B601.w,X [Reads: X Index] [Flags: NCZ]
	sbc ($3F.b,X)		; E1 3F ; Subtract with carry ($3F.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$53.b		; E0 53 ; Compare #$53.b with X register [Reads: X Index] [Flags: NCZ]
	cmp $ED32.w,X		; DD 32 ED ; Compare accumulator $ED32.w,X [Reads: X Index] [Flags: NCZ]
	ora ($A6.b,X)		; 01 A6 ; Logical OR ($A6.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	sta ($41.b)		; 92 41 ; Store accumulator (indirect) ($41.b) [Reads: Direct Page, Accumulator]
	ora ($F3.b),Y		; 11 F3 ; OR accumulator with memory ($F3.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ror $F0D1.w		; 6E D1 F0 ; Rotate right $F0D1.w [Flags: NCZ]
	ldx $30.b,Y		; B6 30 ; Load X register $30.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	sbc $22DC45.l		; EF 45 DC 22 ; Subtract with carry (long) $22DC45.l [Writes: Accumulator] [Flags: NCVZ]
	asl $DEF0.w		; 0E F0 DE ; Arithmetic shift left $DEF0.w [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	cmp [$3D.b]		; C7 3D ; Compare accumulator (long) [$3D.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cop $5B.b		; 02 5B ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $2D.b		; A5 2D ; Load $2D.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jmp $25F0B6.l		; 5C B6 F0 25 ; Jump long to $25F0B6.l [Flow: jump]
	cpx $2F10.w		; EC 10 2F ; Compare $2F10.w with X register [Reads: X Index] [Flags: NCZ]
	.db $F0, $DE		; F0 DE ; Branch if equal to $F0, $DE [Flow: branch]
	cmp $4010B6.l		; CF B6 10 40 ; Compare accumulator (long) $4010B6.l [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $23		; F0 23 ; Branch if equal to $F0, $23 [Flow: branch]
	cmp $002010.l,X		; DF 10 20 00 ; Compare accumulator (long,X) $002010.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	ldx $15.b,Y		; B6 15 ; Load X register $15.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	jsr ($2F00.w,X)		; FC 00 2F ; Jump to subroutine indirect indexed ($2F00.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cop $EC.b		; 02 EC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $20B63F.l,X		; BF 3F B6 20 ; Load long $20B63F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $102F2F.l		; EF 2F 2F 10 ; Subtract with carry (long) $102F2F.l [Writes: Accumulator] [Flags: NCVZ]
	trb $BA.b		; 14 BA ; Test and reset bits $BA.b [Reads: Accumulator] [Flags: Z]
	cmp $2C22.w		; CD 22 2C ; Compare $2C22.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora ($EE.b)		; 12 EE ; OR accumulator with memory (indirect) ($EE.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $4D.b,S		; E3 4D ; Subtract stack-relative $4D.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	ora $073FA6.l,X		; 1F A6 3F 07 ; Logical OR long $073FA6.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpx $3030.w		; EC 30 30 ; Compare $3030.w with X register [Reads: X Index] [Flags: NCZ]
	and ($05.b),Y		; 31 05 ; AND accumulator with memory ($05.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $E3BA.w		; 2D BA E3 ; Logical AND $E3BA.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $DE31.w		; 2D 31 DE ; Logical AND $DE31.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp ($5F.b,S),Y		; D3 5F ; Compare accumulator (stack relative indirect indexed) ($5F.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	.db $D0, $4D		; D0 4D ; Branch if not equal to $D0, $4D [Flow: branch]
	lda [$F3.b],Y		; B7 F3 ; Load accumulator (long indexed) [$F3.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $1001.w		; 0E 01 10 ; Arithmetic shift left $1001.w [Flags: NCZ]
	ora ($21.b),Y		; 11 21 ; OR accumulator with memory ($21.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($CE.b),Y		; 11 CE ; OR accumulator with memory ($CE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3A.b		; 00 3A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pea $2334.w		; F4 34 23 ; Push absolute address $2334.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	.db $F0, $13		; F0 13 ; Branch if equal to $F0, $13 [Flow: branch]
	asl $00B0.w,X		; 1E B0 00 ; Arithmetic shift left $00B0.w,X [Reads: X Index] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: NCZ]
	and ($12.b,X)		; 21 12 ; Logical AND ($12.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and ($11.b),Y		; 31 11 ; AND accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($B1.b,X)		; 01 B1 ; Logical OR ($B1.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	eor $0001FE.l		; 4F FE 01 00 ; Exclusive OR accumulator with memory (long) $0001FE.l [Writes: Accumulator] [Flags: NZ]
	ora ($11.b)		; 12 11 ; OR accumulator with memory (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($EF.b,X)		; 21 EF ; Logical AND ($EF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $F0, $12		; F0 12 ; Branch if equal to $F0, $12 [Flow: branch]
	rol $FE.b		; 26 FE ; Rotate left $FE.b [Reads: Direct Page] [Flags: NCZ]
	sbc ($1F.b),Y		; F1 1F ; Subtract with carry ($1F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $D0, $1B		; D0 1B ; Branch if not equal to $D0, $1B [Flow: branch]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	cmp $F0CC.w		; CD CC F0 ; Compare $F0CC.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	trb $54.b		; 14 54 ; Test and reset bits $54.b [Reads: Accumulator] [Flags: Z]
	jsl $5ADDF0.l		; 22 F0 DD 5A ; Jump to subroutine long $5ADDF0.l [Writes: Stack Pointer] [Flow: call]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	cmp $1313.w		; CD 13 13 ; Compare $1313.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	and ($20.b),Y		; 31 20 ; AND accumulator with memory ($20.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($0F.b,X)		; 21 0F ; Logical AND ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($31.b,S),Y		; 13 31 ; OR accumulator (stack relative indirect indexed) ($31.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $3C.b,S		; 23 3C ; AND accumulator with stack relative $3C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc $DFDD.w		; ED DD DF ; Subtract $DFDD.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ora ($34.b)		; 12 34 ; OR accumulator with memory (indirect) ($34.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $21.b		; 65 21 ; Add $21.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($CC6A.w,X)		; FC 6A CC ; Jump to subroutine indirect indexed ($CC6A.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	dec $3203.w		; CE 03 32 ; Decrement $3203.w [Flags: NZ]
	jsl $FFFF20.l		; 22 20 FF FF ; Jump to subroutine long $FFFF20.l [Writes: Stack Pointer] [Flow: call]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	and ($1F.b,S),Y		; 33 1F ; AND accumulator (stack relative indirect indexed) ($1F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$3F13]		; DC 13 3F ; Jump long indirect [$3F13] [Flow: jump]
	sbc $7A0E22.l		; EF 22 0E 7A ; Subtract with carry (long) $7A0E22.l [Writes: Accumulator] [Flags: NCVZ]
	inc $DFDD.w,X		; FE DD DF ; Increment memory $DFDD.w,X [Reads: X Index] [Flags: NZ]
	sbc $0E6425.l,X		; FF 25 64 0E ; Subtract with carry (long,X) $0E6425.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $9A6A.w,X		; FE 6A 9A ; Increment memory $9A6A.w,X [Reads: X Index] [Flags: NZ]
	ldx $4402.w		; AE 02 44 ; Load $4402.w into X register [Writes: X Index] [Flags: NZ]
	and ($21.b,X)		; 21 21 ; Logical AND ($21.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $346AEF.l		; 0F EF 6A 34 ; OR accumulator with memory (long) $346AEF.l [Writes: Accumulator] [Flags: NZ]
	.db $10, $FF		; 10 FF ; Branch if plus to $10, $FF [Flow: branch]
	and $41.b		; 25 41 ; Logical AND $41.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $8AEF0F.l		; 0F 0F EF 8A ; OR accumulator with memory (long) $8AEF0F.l [Writes: Accumulator] [Flags: NZ]
	ora $00EFFE.l		; 0F FE EF 00 ; OR accumulator with memory (long) $00EFFE.l [Writes: Accumulator] [Flags: NZ]
	and $52.b,X		; 35 52 ; Logical AND $52.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $6AEE.w		; ED EE 6A ; Subtract $6AEE.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	lda $5642F1.l		; AF F1 42 56 ; Load long $5642F1.l into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $30, $01		; 30 01 ; Branch if minus to $30, $01 [Flow: branch]
	ora $017AFF.l,X		; 1F FF 7A 01 ; Logical OR long $017AFF.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $F0		; 10 F0 ; Branch if plus to $10, $F0 [Flow: branch]
	ora ($10.b)		; 12 10 ; OR accumulator with memory (indirect) ($10.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $DEED.w,X		; FE ED DE ; Increment memory $DEED.w,X [Reads: X Index] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $E0FE0F.l,X		; FF 0F FE E0 ; Subtract with carry (long,X) $E0FE0F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor [$40.b],Y		; 57 40 ; Exclusive OR accumulator with memory (long indexed) [$40.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpx $6ACD.w		; EC CD 6A ; Compare $6ACD.w with X register [Reads: X Index] [Flags: NCZ]
	ldx $6215.w		; AE 15 62 ; Load $6215.w into X register [Writes: X Index] [Flags: NZ]
	bit $41.b		; 24 41 ; Test bits $41.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: NCZ]
	ora $11016A.l		; 0F 6A 01 11 ; OR accumulator with memory (long) $11016A.l [Writes: Accumulator] [Flags: NZ]
	and ($55.b,S),Y		; 33 55 ; AND accumulator (stack relative indirect indexed) ($55.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($0F.b,X)		; 21 0F ; Logical AND ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $EF0F00.l		; 0F 00 0F EF ; OR accumulator with memory (long) $EF0F00.l [Writes: Accumulator] [Flags: NZ]
	and $41.b		; 25 41 ; Logical AND $41.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $FE		; F0 FE ; Branch if equal to $F0, $FE [Flow: branch]
	ror $3F.b,X		; 76 3F ; Rotate right $3F.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cmp $23F1.w		; CD F1 23 ; Compare $23F1.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	bit $44.b,X		; 34 44 ; Test bits $44.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and ($1F.b)		; 32 1F ; AND accumulator with memory (indirect) ($1F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $DCDD0F.l		; 0F 0F DD DC ; OR accumulator with memory (long) $DCDD0F.l [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $00FFF0.l		; EF F0 FF 00 ; Subtract with carry (long) $00FFF0.l [Writes: Accumulator] [Flags: NCVZ]
	ora $61150F.l		; 0F 0F 15 61 ; OR accumulator with memory (long) $61150F.l [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy $01CD.w		; CC CD 01 ; Compare $01CD.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora ($10.b),Y		; 11 10 ; OR accumulator with memory ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $6A.b		; 00 6A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($0F.b),Y		; 31 0F ; AND accumulator with memory ($0F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $24		; 10 24 ; Branch if plus to $10, $24 [Flow: branch]
	.db $42, $22		; 42 22 ; Reserved instruction
	ora ($21.b)		; 12 21 ; OR accumulator with memory (indirect) ($21.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	ora $0F00FF.l		; 0F FF 00 0F ; OR accumulator with memory (long) $0F00FF.l [Writes: Accumulator] [Flags: NZ]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $72.b,X		; 15 72 ; OR accumulator with memory $72.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	cpx $F1DE.w		; EC DE F1 ; Compare $F1DE.w with X register [Reads: X Index] [Flags: NCZ]
	ora ($01.b),Y		; 11 01 ; OR accumulator with memory ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $5A.b		; 00 5A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $DCCF.w,X		; 9E CF DC ; Store zero to $DCCF.w,X [Reads: X Index]
	sbc $1F0F.w		; ED 0F 1F ; Subtract $1F0F.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sbc $0FAA1D.l		; EF 1D AA 0F ; Subtract with carry (long) $0FAA1D.l [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $10		; F0 10 ; Branch if equal to $F0, $10 [Flow: branch]
	.db $F0, $0F		; F0 0F ; Branch if equal to $F0, $0F [Flow: branch]
	sbc $9A4114.l		; EF 14 41 9A ; Subtract with carry (long) $9A4114.l [Writes: Accumulator] [Flags: NCVZ]
	wai		; CB ; Wait for interrupt
	cmp $21F1.w		; CD F1 21 ; Compare $21F1.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc ($10.b),Y		; F1 10 ; Subtract with carry ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $B0, $10		; B0 10 ; Branch if carry set to $B0, $10 [Flow: branch]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $56.b		; 45 56 ; Exclusive OR $56.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	mvp $AA,$2F		; 44 2F AA ; Move block positive $AA,$2F [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $0000F0.l		; 0F F0 00 00 ; OR accumulator with memory (long) $0000F0.l [Writes: Accumulator] [Flags: NZ]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $42.b		; 04 42 ; Test and set bits $42.b [Reads: Accumulator] [Flags: Z]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	cmp $F1BD.w,X		; DD BD F1 ; Compare accumulator $F1BD.w,X [Reads: X Index] [Flags: NCZ]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $6A.b		; 00 6A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx $EEC0.w		; AE C0 EE ; Load $EEC0.w into X register [Writes: X Index] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	cpx #$11.b		; E0 11 ; Compare #$11.b with X register [Reads: X Index] [Flags: NCZ]
	ora $009A10.l		; 0F 10 9A 00 ; OR accumulator with memory (long) $009A10.l [Writes: Accumulator] [Flags: NZ]
	sbc $0FF000.l,X		; FF 00 F0 0F ; Subtract with carry (long,X) $0FF000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $9A24F1.l		; EF F1 24 9A ; Subtract with carry (long) $9A24F1.l [Writes: Accumulator] [Flags: NCVZ]
	.db $42, $DC		; 42 DC ; Reserved instruction
	cmp $1012F0.l,X		; DF F0 12 10 ; Compare accumulator (long,X) $1012F0.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sbc $020F00.l,X		; FF 00 0F 02 ; Subtract with carry (long,X) $020F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($22.b,S),Y		; 33 22 ; AND accumulator (stack relative indirect indexed) ($22.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $FF008A.l		; 22 8A 00 FF ; Jump to subroutine long $FF008A.l [Writes: Stack Pointer] [Flow: call]
	inc $0EF1.w		; EE F1 0E ; Increment $0EF1.w [Flags: NZ]
	.db $F0, $0D		; F0 0D ; Branch if equal to $F0, $0D [Flow: branch]
	sbc $AA.b		; E5 AA ; Subtract $AA.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	eor $FE.b,S		; 43 FE ; Exclusive OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $0101E0.l,X		; FF E0 01 01 ; Subtract with carry (long,X) $0101E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$F1.b		; C0 F1 ; Compare #$F1.b with Y register [Reads: Y Index] [Flags: NCZ]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $0F		; F0 0F ; Branch if equal to $F0, $0F [Flow: branch]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $FFF0.w,X		; DD F0 FF ; Compare accumulator $FFF0.w,X [Reads: X Index] [Flags: NCZ]
	sbc $AA93EB.l,X		; FF EB 93 AA ; Subtract with carry (long,X) $AA93EB.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	mvn $ED,$0E		; 54 0E ED ; Move block negative $ED,$0E [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	.db $F0, $10		; F0 10 ; Branch if equal to $F0, $10 [Flow: branch]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	brk $7A.b		; 00 7A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($EF.b,X)		; 41 EF ; Exclusive OR accumulator with memory ($EF.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $02		; F0 02 ; Branch if equal to $F0, $02 [Flow: branch]
	and ($55.b,S),Y		; 33 55 ; AND accumulator (stack relative indirect indexed) ($55.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $FF		; 10 FF ; Branch if plus to $10, $FF [Flow: branch]
	cmp $01E0.w,X		; DD E0 01 ; Compare accumulator $01E0.w,X [Reads: X Index] [Flags: NCZ]
	ora $AAA0DB.l,X		; 1F DB A0 AA ; Logical OR long $AAA0DB.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr $2E.b		; 46 2E ; Logical shift right $2E.b [Reads: Direct Page] [Flags: NCZ]
	cmp $11E0.w,X		; DD E0 11 ; Compare accumulator $11E0.w,X [Reads: X Index] [Flags: NCZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($7A.b,X)		; 01 7A ; Logical OR ($7A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $EEFF.w		; 0E FF EE ; Arithmetic shift left $EEFF.w [Flags: NCZ]
	.db $F0, $FE		; F0 FE ; Branch if equal to $F0, $FE [Flow: branch]
	sbc $8A3322.l		; EF 22 33 8A ; Subtract with carry (long) $8A3322.l [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $EE		; 10 EE ; Branch if plus to $10, $EE [Flow: branch]
	wai		; CB ; Wait for interrupt
	.db $D0, $00		; D0 00 ; Branch if not equal to $D0, $00 [Flow: branch]
	jsl $AABDFB.l		; 22 FB BD AA ; Jump to subroutine long $AABDFB.l [Writes: Stack Pointer] [Flow: call]
	ora ($41.b,S),Y		; 13 41 ; OR accumulator (stack relative indirect indexed) ($41.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $00EF.w		; ED EF 00 ; Subtract $00EF.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	brk $86.b		; 00 86 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $42.b,X		; 35 42 ; Logical AND $42.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and ($10.b,X)		; 21 10 ; Logical AND ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $24F0EE.l		; 0F EE F0 24 ; OR accumulator with memory (long) $24F0EE.l [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	and ($1F.b)		; 32 1F ; AND accumulator with memory (indirect) ($1F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$F0BD]		; DC BD F0 ; Jump long indirect [$F0BD] [Flow: jump]
	ora ($ED.b),Y		; 11 ED ; OR accumulator with memory ($ED.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	.db $F0, $34		; F0 34 ; Branch if equal to $F0, $34 [Flow: branch]
	and $11EFEE.l		; 2F EE EF 11 ; AND accumulator with memory (long) $11EFEE.l [Writes: Accumulator] [Flags: NZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr $6B.b,X		; 56 6B ; Logical shift right $6B.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	inc $DDDE.w		; EE DE DD ; Increment $DDDE.w [Flags: NZ]
	cpy $42F1.w		; CC F1 42 ; Compare $42F1.w with Y register [Reads: Y Index] [Flags: NCZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $0E		; 10 0E ; Branch if plus to $10, $0E [Flow: branch]
	cpx $02BC.w		; EC BC 02 ; Compare $02BC.w with X register [Reads: X Index] [Flags: NCZ]
	and ($1F.b)		; 32 1F ; AND accumulator with memory (indirect) ($1F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx $D09A.w		; EC 9A D0 ; Compare $D09A.w with X register [Reads: X Index] [Flags: NCZ]
	eor [$4F.b]		; 47 4F ; Exclusive OR accumulator with memory (long) [$4F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	.db $D0, $10		; D0 10 ; Branch if not equal to $D0, $10 [Flow: branch]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ror $46.b,X		; 76 46 ; Rotate right $46.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	eor $54.b,X		; 55 54 ; Exclusive OR accumulator with memory $54.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and ($0F.b,X)		; 21 0F ; Logical AND ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $14CE.w		; ED CE 14 ; Subtract $14CE.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	bit $20.b,X		; 34 20 ; Test bits $20.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cpx $E0BC.w		; EC BC E0 ; Compare $E0BC.w with X register [Reads: X Index] [Flags: NCZ]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	.db $F0, $34		; F0 34 ; Branch if equal to $F0, $34 [Flow: branch]
	and $01E0EE.l		; 2F EE E0 01 ; AND accumulator with memory (long) $01E0EE.l [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	and $2D.b,X		; 35 2D ; Logical AND $2D.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $EEFFFF.l,X		; FF FF FF EE ; Subtract with carry (long,X) $EEFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $21		; F0 21 ; Branch if equal to $F0, $21 [Flow: branch]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $0D		; 10 0D ; Branch if plus to $10, $0D [Flow: branch]
	wai		; CB ; Wait for interrupt
	cmp $4302.w,X		; DD 02 43 ; Compare accumulator $4302.w,X [Reads: X Index] [Flags: NCZ]
	and $E09ACB.l		; 2F CB 9A E0 ; AND accumulator with memory (long) $E09ACB.l [Writes: Accumulator] [Flags: NZ]
	lsr $3F.b		; 46 3F ; Logical shift right $3F.b [Reads: Direct Page] [Flags: NCZ]
	cpy $01DF.w		; CC DF 01 ; Compare $01DF.w with Y register [Reads: Y Index] [Flags: NCZ]
	and ($11.b,X)		; 21 11 ; Logical AND ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	eor ($24.b),Y		; 51 24 ; Exclusive OR accumulator with memory ($24.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $5624FF.l		; 0F FF 24 56 ; OR accumulator with memory (long) $5624FF.l [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	bit $20.b,X		; 34 20 ; Test bits $20.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cmp $D0CB.w,X		; DD CB D0 ; Compare accumulator $D0CB.w,X [Reads: X Index] [Flags: NCZ]
	.db $10, $FD		; 10 FD ; Branch if plus to $10, $FD [Flow: branch]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	.db $F0, $34		; F0 34 ; Branch if equal to $F0, $34 [Flow: branch]
	and $01FFEE.l		; 2F EE FF 01 ; AND accumulator with memory (long) $01FFEE.l [Writes: Accumulator] [Flags: NZ]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	eor $2D.b,X		; 55 2D ; Exclusive OR accumulator with memory $2D.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $FF		; F0 FF ; Branch if equal to $F0, $FF [Flow: branch]
	sbc $1200EF.l,X		; FF EF 00 12 ; Subtract with carry (long,X) $1200EF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $0E		; 10 0E ; Branch if plus to $10, $0E [Flow: branch]
	wai		; CB ; Wait for interrupt
	cmp $33F1.w		; CD F1 33 ; Compare $33F1.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	and $EF9AEC.l		; 2F EC 9A EF ; AND accumulator with memory (long) $EF9AEC.l [Writes: Accumulator] [Flags: NZ]
	eor [$4E.b]		; 47 4E ; Exclusive OR accumulator with memory (long) [$4E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy $01DF.w,X		; BC DF 01 ; Load Y register $01DF.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ora ($10.b)		; 12 10 ; OR accumulator with memory (indirect) ($10.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror $F4.b,X		; 76 F4 ; Rotate right $F4.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	adc $43.b		; 65 43 ; Add $43.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jsl $EFFE10.l		; 22 10 FE EF ; Jump to subroutine long $EFFE10.l [Writes: Stack Pointer] [Flow: call]
	and $7A.b		; 25 7A ; Logical AND $7A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($21.b,S),Y		; 33 21 ; AND accumulator (stack relative indirect indexed) ($21.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx $E0BC.w		; EC BC E0 ; Compare $E0BC.w with X register [Reads: X Index] [Flags: NCZ]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	.db $F0, $34		; F0 34 ; Branch if equal to $F0, $34 [Flow: branch]
	and $01E0EE.l		; 2F EE E0 01 ; AND accumulator with memory (long) $01E0EE.l [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc ($E5.b,S),Y		; F3 E5 ; Subtract with carry (stack relative indirect indexed) ($E5.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	inc $FEEF.w,X		; FE EF FE ; Increment memory $FEEF.w,X [Reads: X Index] [Flags: NZ]
	cmp $8A3402.l,X		; DF 02 34 8A ; Compare accumulator (long,X) $8A3402.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	cpx $EFCD.w		; EC CD EF ; Compare $EFCD.w with X register [Reads: X Index] [Flags: NCZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $F19A.w,X		; FE 9A F1 ; Increment memory $F19A.w,X [Reads: X Index] [Flags: NZ]
	lsr $3E.b,X		; 56 3E ; Logical shift right $3E.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	wai		; CB ; Wait for interrupt
	dec $1101.w,X		; DE 01 11 ; Decrement memory $1101.w,X [Reads: X Index] [Flags: NZ]
	ora ($6A.b),Y		; 11 6A ; OR accumulator with memory ($6A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr $41.b,X		; 56 41 ; Logical shift right $41.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($F0.b),Y		; 11 F0 ; OR accumulator with memory ($F0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $66.b,X		; 15 66 ; OR accumulator with memory $66.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	bit $30.b,X		; 34 30 ; Test bits $30.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cmp $D0CC.w,X		; DD CC D0 ; Compare accumulator $D0CC.w,X [Reads: X Index] [Flags: NCZ]
	.db $10, $FD		; 10 FD ; Branch if plus to $10, $FD [Flow: branch]
	cmp #$AA.b		; C9 AA ; Compare #$AA.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $34		; F0 34 ; Branch if equal to $F0, $34 [Flow: branch]
	and $11EFEE.l		; 2F EE EF 11 ; AND accumulator with memory (long) $11EFEE.l [Writes: Accumulator] [Flags: NZ]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc $EE0026.l,X		; FF 26 00 EE ; Subtract with carry (long,X) $EE0026.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $13DE.w		; EE DE 13 ; Increment $13DE.w [Flags: NZ]
	mvp $22,$7A		; 44 7A 22 ; Move block positive $22,$7A [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	asl $A9CB.w		; 0E CB A9 ; Arithmetic shift left $A9CB.w [Flags: NCZ]
	lda $BDDB.w,X		; BD DB BD ; Load $BDDB.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $57019A.l,X		; FF 9A 01 57 ; Subtract with carry (long,X) $57019A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr $DEBB.w		; 4E BB DE ; Logical shift right $DEBB.w [Flags: NCZ]
	.db $F0, $21		; F0 21 ; Branch if equal to $F0, $21 [Flow: branch]
	.db $10, $76		; 10 76 ; Branch if plus to $10, $76 [Flow: branch]
	cmp $324434.l		; CF 34 44 32 ; Compare accumulator (long) $324434.l [Reads: Accumulator] [Flags: NCZ]
	.db $10, $FE		; 10 FE ; Branch if plus to $10, $FE [Flow: branch]
	cpx #$36.b		; E0 36 ; Compare #$36.b with X register [Reads: X Index] [Flags: NCZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	and ($30.b,S),Y		; 33 30 ; AND accumulator (stack relative indirect indexed) ($30.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $E0CB.w		; ED CB E0 ; Subtract $E0CB.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $FD		; 10 FD ; Branch if plus to $10, $FD [Flow: branch]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	.db $F0, $33		; F0 33 ; Branch if equal to $F0, $33 [Flow: branch]
	and $01EFFE.l		; 2F FE EF 01 ; AND accumulator with memory (long) $01EFFE.l [Writes: Accumulator] [Flags: NZ]
	.db $10, $01		; 10 01 ; Branch if plus to $10, $01 [Flow: branch]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	adc $FF1FF3.l,X		; 7F F3 1F FF ; Add long $FF1FF3.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $2202FF.l,X		; FF FF 02 22 ; Subtract with carry (long,X) $2202FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($1F.b),Y		; 11 1F ; OR accumulator with memory ($1F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $DEEC.w		; ED EC DE ; Subtract $DEEC.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cpx $F0DE.w		; EC DE F0 ; Compare $F0DE.w with X register [Reads: X Index] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ora ($34.b,X)		; 01 34 ; Logical OR ($34.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $00EFDD.l		; 2F DD EF 00 ; AND accumulator with memory (long) $00EFDD.l [Writes: Accumulator] [Flags: NZ]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	eor ($52.b),Y		; 51 52 ; Exclusive OR accumulator with memory ($52.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $F0		; 10 F0 ; Branch if plus to $10, $F0 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $34.b		; 02 34 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	mvp $EC,$20		; 44 20 EC ; Move block positive $EC,$20 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ldy $00F0.w,X		; BC F0 00 ; Load Y register $00F0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	inc $AACA.w,X		; FE CA AA ; Increment memory $AACA.w,X [Reads: X Index] [Flags: NZ]
	.db $F0, $24		; F0 24 ; Branch if equal to $F0, $24 [Flow: branch]
	jsr $EFEE.w		; 20 EE EF ; Jump to subroutine at $EFEE.w [Writes: Stack Pointer] [Flow: call]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($7A.b,X)		; 01 7A ; Logical OR ($7A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	adc ($F2.b)		; 72 F2 ; Add with carry (indirect) ($F2.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $2202E0.l		; EF E0 02 22 ; Subtract with carry (long) $2202E0.l [Writes: Accumulator] [Flags: NCVZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($1F.b)		; 12 1F ; OR accumulator with memory (indirect) ($1F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $DEDC.w		; EE DC DE ; Increment $DEDC.w [Flags: NZ]
	cmp $E0CD.w,X		; DD CD E0 ; Compare accumulator $E0CD.w,X [Reads: X Index] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ora ($34.b,X)		; 01 34 ; Logical OR ($34.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $0FEFED.l		; 2F ED EF 0F ; AND accumulator with memory (long) $0FEFED.l [Writes: Accumulator] [Flags: NZ]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $10, $F0		; 10 F0 ; Branch if plus to $10, $F0 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $34.b		; 02 34 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	mvp $EC,$21		; 44 21 EC ; Move block positive $EC,$21 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ldy $00E0.w,X		; BC E0 00 ; Load Y register $00E0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	inc $AACA.w,X		; FE CA AA ; Increment memory $AACA.w,X [Reads: X Index] [Flags: NZ]
	.db $F0, $34		; F0 34 ; Branch if equal to $F0, $34 [Flow: branch]
	ora $01EFEF.l,X		; 1F EF EF 01 ; Logical OR long $01EFEF.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	eor ($60.b,X)		; 41 60 ; Exclusive OR accumulator with memory ($60.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $DF0FF0.l		; 0F F0 0F DF ; OR accumulator with memory (long) $DF0FF0.l [Writes: Accumulator] [Flags: NZ]
	cop $24.b		; 02 24 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($1F.b)		; 12 1F ; OR accumulator with memory (indirect) ($1F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $EEDC.w		; EE DC EE ; Increment $EEDC.w [Flags: NZ]
	inc $CDDB.w,X		; FE DB CD ; Increment memory $CDDB.w,X [Reads: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	sbc ($35.b),Y		; F1 35 ; Subtract with carry ($35.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr $EFDE.w		; 20 DE EF ; Jump to subroutine at $EFDE.w [Writes: Stack Pointer] [Flow: call]
	.db $F0, $10		; F0 10 ; Branch if equal to $F0, $10 [Flow: branch]
	brk $76.b		; 00 76 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($21.b,X)		; E1 21 ; Subtract with carry ($21.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($FE.b),Y		; 11 FE ; OR accumulator with memory ($FE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $CECC.w,X		; DD CC CE ; Compare accumulator $CECC.w,X [Reads: X Index] [Flags: NCZ]
	rol $7A.b		; 26 7A ; Rotate left $7A.b [Reads: Direct Page] [Flags: NCZ]
	and ($31.b,S),Y		; 33 31 ; AND accumulator (stack relative indirect indexed) ($31.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx $E0BC.w		; EC BC E0 ; Compare $E0BC.w with X register [Reads: X Index] [Flags: NCZ]
	.db $10, $FD		; 10 FD ; Branch if plus to $10, $FD [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	.db $F0, $33		; F0 33 ; Branch if equal to $F0, $33 [Flow: branch]
	and $01EFFE.l		; 2F FE EF 01 ; AND accumulator with memory (long) $01EFFE.l [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	and $F2.b		; 25 F2 ; Logical AND $F2.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($F0.b,X)		; 01 F0 ; Logical OR ($F0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($10.b)		; 12 10 ; OR accumulator with memory (indirect) ($10.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $EFDC.w,X		; FE DC EF ; Increment memory $EFDC.w,X [Reads: X Index] [Flags: NZ]
	asl $CBED.w		; 0E ED CB ; Arithmetic shift left $CBED.w [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	.db $F0, $23		; F0 23 ; Branch if equal to $F0, $23 [Flow: branch]
	.db $30, $FE		; 30 FE ; Branch if minus to $30, $FE [Flow: branch]
	sbc $0001F0.l,X		; FF F0 01 00 ; Subtract with carry (long,X) $0001F0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lda [$52.b],Y		; B7 52 ; Load accumulator (long indexed) [$52.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $F00101.l		; 22 01 01 F0 ; Jump to subroutine long $F00101.l [Writes: Stack Pointer] [Flow: call]
	and $67.b		; 25 67 ; Logical AND $67.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	eor $30.b,S		; 43 30 ; Exclusive OR accumulator with stack relative $30.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr ($EFCC.w,X)		; FC CC EF ; Jump to subroutine indirect indexed ($EFCC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora ($FD.b),Y		; 11 FD ; OR accumulator with memory ($FD.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	.db $F0, $34		; F0 34 ; Branch if equal to $F0, $34 [Flow: branch]
	and $00F0DE.l		; 2F DE F0 00 ; AND accumulator with memory (long) $00F0DE.l [Writes: Accumulator] [Flags: NZ]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	tsb $42.b		; 04 42 ; Test and set bits $42.b [Reads: Accumulator] [Flags: Z]
	.db $10, $F0		; 10 F0 ; Branch if plus to $10, $F0 [Flow: branch]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($10.b)		; 12 10 ; OR accumulator with memory (indirect) ($10.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $EFDC.w,X		; FE DC EF ; Increment memory $EFDC.w,X [Reads: X Index] [Flags: NZ]
	ora $AACBEC.l		; 0F EC CB AA ; OR accumulator with memory (long) $AACBEC.l [Writes: Accumulator] [Flags: NZ]
	.db $F0, $23		; F0 23 ; Branch if equal to $F0, $23 [Flow: branch]
	.db $30, $FE		; 30 FE ; Branch if minus to $30, $FE [Flow: branch]
	sbc $0001F0.l,X		; FF F0 01 00 ; Subtract with carry (long,X) $0001F0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ldx $62.b,Y		; B6 62 ; Load X register $62.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $67.b,X		; 15 67 ; OR accumulator with memory $67.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	mvp $ED,$20		; 44 20 ED ; Move block positive $ED,$20 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cpy $10E0.w		; CC E0 10 ; Compare $10E0.w with Y register [Reads: Y Index] [Flags: NCZ]
	sbc $AACA.w,X		; FD CA AA ; Subtract with carry $AACA.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $34		; F0 34 ; Branch if equal to $F0, $34 [Flow: branch]
	and $10E0ED.l		; 2F ED E0 10 ; AND accumulator with memory (long) $10E0ED.l [Writes: Accumulator] [Flags: NZ]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora [$72.b],Y		; 17 72 ; OR accumulator with memory (long indexed) [$72.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsr $0FF0.w		; 20 F0 0F ; Jump to subroutine at $0FF0.w [Writes: Stack Pointer] [Flow: call]
	inc $4502.w		; EE 02 45 ; Increment $4502.w [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($10.b)		; 12 10 ; OR accumulator with memory (indirect) ($10.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $EFDD.w		; EE DD EF ; Increment $EFDD.w [Flags: NZ]
	ora $AACBEC.l		; 0F EC CB AA ; OR accumulator with memory (long) $AACBEC.l [Writes: Accumulator] [Flags: NZ]
	sbc $FE3024.l,X		; FF 24 30 FE ; Subtract with carry (long,X) $FE3024.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $010000.l		; EF 00 00 01 ; Subtract with carry (long) $010000.l [Writes: Accumulator] [Flags: NCVZ]
	ror $62.b,X		; 76 62 ; Rotate right $62.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cpx #$0F.b		; E0 0F ; Compare #$0F.b with X register [Reads: X Index] [Flags: NCZ]
	sbc $BBCC.w		; ED CC BB ; Subtract $BBCC.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	lda $7A04.w,X		; BD 04 7A ; Load $7A04.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	mvp $EE,$20		; 44 20 EE ; Move block positive $EE,$20 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ldy $01E0.w,X		; BC E0 01 ; Load Y register $01E0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	sbc $ABCB.w,X		; FD CB AB ; Subtract with carry $ABCB.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $34		; F0 34 ; Branch if equal to $F0, $34 [Flow: branch]
	ora $01EFEF.l,X		; 1F EF EF 01 ; Logical OR long $01EFEF.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B0.b		; 00 B0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $2011.w		; 6E 11 20 ; Rotate right $2011.w [Flags: NCZ]
	ora ($12.b),Y		; 11 12 ; OR accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $A0		; 10 A0 ; Branch if plus to $10, $A0 [Flow: branch]
	eor $F344FD.l,X		; 5F FD 44 F3 ; Exclusive OR accumulator with memory (long,X) $F344FD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $6E6C.w,X		; 1E 6C 6E ; Arithmetic shift left $6E6C.w,X [Reads: X Index] [Flags: NCZ]
	lda $D01CB0.l,X		; BF B0 1C D0 ; Load long $D01CB0.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $1E0F.w,X		; 1D 0F 1E ; OR accumulator with memory $1E0F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $ED.b		; 00 ED ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $A4.b		; 02 A4 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $E1.b,X		; 95 E1 ; Store accumulator to $E1.b,X [Reads: Accumulator, X Index]
	ora ($0B.b)		; 12 0B ; OR accumulator with memory (indirect) ($0B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror $B3BF.w		; 6E BF B3 ; Rotate right $B3BF.w [Flags: NCZ]
	eor $E1D2B4.l,X		; 5F B4 D2 E1 ; Exclusive OR accumulator with memory (long,X) $E1D2B4.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $E3.b		; E5 E3 ; Subtract $E3.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $EE		; 10 EE ; Branch if plus to $10, $EE [Flow: branch]
	sbc $B401.w,X		; FD 01 B4 ; Subtract with carry $B401.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	and ($2F.b),Y		; 31 2F ; AND accumulator with memory ($2F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$CF.b		; E0 CF ; Compare #$CF.b with X register [Reads: X Index] [Flags: NCZ]
	lda ($0F.b,S),Y		; B3 0F ; Load accumulator (stack relative indirect indexed) ($0F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $B4.b,S		; 03 B4 ; OR accumulator with stack relative $B4.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $D3.b,S		; 23 D3 ; AND accumulator with stack relative $D3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $EE1D01.l		; 2F 01 1D EE ; AND accumulator with memory (long) $EE1D01.l [Writes: Accumulator] [Flags: NZ]
	sta ($C0.b),Y		; 91 C0 ; Store accumulator ($C0.b),Y [Reads: Direct Page, Y Index, Accumulator]
	clv		; B8 ; Clear overflow flag [Flags: V]
	asl $412D.w,X		; 1E 2D 41 ; Arithmetic shift left $412D.w,X [Reads: X Index] [Flags: NCZ]
	sbc $004E.w,X		; FD 4E 00 ; Subtract with carry $004E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $F2.b		; 00 F2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clv		; B8 ; Clear overflow flag [Flags: V]
	sta $C4.b,X		; 95 C4 ; Store accumulator to $C4.b,X [Reads: Accumulator, X Index]
	inc $AF.b		; E6 AF ; Increment $AF.b [Reads: Direct Page] [Flags: NZ]
	and ($C2.b)		; 32 C2 ; AND accumulator with memory (indirect) ($C2.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $F1.b		; 02 F1 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $23.b,X		; B4 23 ; Load Y register $23.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	trb $F2.b		; 14 F2 ; Test and reset bits $F2.b [Reads: Accumulator] [Flags: Z]
	sbc $EFDE.w,X		; FD DE EF ; Subtract with carry $EFDE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $02B43C.l		; EF 3C B4 02 ; Subtract with carry (long) $02B43C.l [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $11		; F0 11 ; Branch if equal to $F0, $11 [Flow: branch]
.ACCU 8
	sep #$EF		; E2 EF
	jsl $B42124.l		; 22 24 21 B4 ; Jump to subroutine long $B42124.l [Writes: Stack Pointer] [Flow: call]
	cpx #$1C.b		; E0 1C ; Compare #$1C.b with X register [Reads: X Index] [Flags: NCZ]
	.db $10, $1E		; 10 1E ; Branch if plus to $10, $1E [Flow: branch]
	inc $F00F.w,X		; FE 0F F0 ; Increment memory $F00F.w,X [Reads: X Index] [Flags: NZ]
	sbc ($B0.b),Y		; F1 B0 ; Subtract with carry ($B0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $1102E2.l,X		; FF E2 02 11 ; Subtract with carry (long,X) $1102E2.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($1E.b,S),Y		; 53 1E ; XOR accumulator (stack relative indirect indexed) ($1E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $34.b,S		; 43 34 ; Exclusive OR accumulator with stack relative $34.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldy $FE.b,X		; B4 FE ; Load Y register $FE.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	cmp ($F1.b),Y		; D1 F1 ; Compare accumulator ($F1.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	sep #$02		; E2 02 ; Set processor status bits #$02 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	.db $30, $4F		; 30 4F ; Branch if minus to $30, $4F [Flow: branch]
	ora ($B4.b,X)		; 01 B4 ; Logical OR ($B4.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp ($BF.b),Y		; D1 BF ; Compare accumulator ($BF.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	.db $B0, $B3		; B0 B3 ; Branch if carry set to $B0, $B3 [Flow: branch]
	bit $13.b		; 24 13 ; Test bits $13.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	bit $2E.b		; 24 2E ; Test bits $2E.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cpy $1E.b		; C4 1E ; Compare $1E.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	asl $C1F2.w		; 0E F2 C1 ; Arithmetic shift left $C1F2.w [Flags: NCZ]
	sbc ($FF.b,X)		; E1 FF ; Subtract with carry ($FF.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $B402.w		; 0E 02 B4 ; Arithmetic shift left $B402.w [Flags: NCZ]
	cmp $50.b,X		; D5 50 ; Compare accumulator $50.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	bit $0F.b,X		; 34 0F ; Test bits $0F.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora $C6.b,S		; 03 C6 ; OR accumulator with stack relative $C6.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpy #$4F.b		; C0 4F ; Compare #$4F.b with Y register [Reads: Y Index] [Flags: NCZ]
	ldy $E0.b,X		; B4 E0 ; Load Y register $E0.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	inc $D1FC.w,X		; FE FC D1 ; Increment memory $D1FC.w,X [Reads: X Index] [Flags: NZ]
	lda $14B303.l		; AF 03 B3 14 ; Load long $14B303.l into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy $15.b,X		; B4 15 ; Load Y register $15.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	ora [$10.b]		; 07 10 ; OR accumulator with memory (long) [$10.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $EDDB.w,X		; FD DB ED ; Subtract with carry $EDDB.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy $01.b		; C4 01 ; Compare $01.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	ora ($F4.b,X)		; 01 F4 ; Logical OR ($F4.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc ($30.b),Y		; F1 30 ; Subtract with carry ($30.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$0F.b		; E0 0F ; Compare #$0F.b with X register [Reads: X Index] [Flags: NCZ]
	brk $C4.b		; 00 C4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($0F.b,X)		; E1 0F ; Subtract with carry ($0F.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($E4.b,X)		; 01 E4 ; Logical OR ($E4.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $F2.b,S		; 03 F2 ; OR accumulator with stack relative $F2.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $C41E.w,X		; FE 1E C4 ; Increment memory $C41E.w,X [Reads: X Index] [Flags: NZ]
	.db $F0, $D1		; F0 D1 ; Branch if equal to $F0, $D1 [Flow: branch]
	sbc $103F.w,X		; FD 3F 10 ; Subtract with carry $103F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($E4.b),Y		; F1 E4 ; Subtract with carry ($E4.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp ($C4.b),Y		; D1 C4 ; Compare accumulator ($C4.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	lsr $1E10.w		; 4E 10 1E ; Logical shift right $1E10.w [Flags: NCZ]
	tsb $E0.b		; 04 E0 ; Test and set bits $E0.b [Reads: Accumulator] [Flags: Z]
	and $E110.w		; 2D 10 E1 ; Logical AND $E110.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ldy $F0.b,X		; B4 F0 ; Load Y register $F0.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	.db $F0, $0B		; F0 0B ; Branch if equal to $F0, $0B [Flow: branch]
	rol $A2F1.w,X		; 3E F1 A2 ; Rotate left $A2F1.w,X [Reads: X Index] [Flags: NCZ]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	ldy $43.b,X		; B4 43 ; Load Y register $43.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	bit $D5.b,X		; 34 D5 ; Test bits $D5.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	inc $CCC0.w,X		; FE C0 CC ; Increment memory $CCC0.w,X [Reads: X Index] [Flags: NZ]
	bit $B8DF.w,X		; 3C DF B8 ; Test bits $B8DF.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	cpx $1F.b		; E4 1F ; Compare $1F.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	and $CEF2.w,X		; 3D F2 CE ; AND accumulator with memory $CEF2.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jmp $C42C.w		; 4C 2C C4 ; Jump to $C42C.w [Flow: jump]
	lsr $20E1.w		; 4E E1 20 ; Logical shift right $20E1.w [Flags: NCZ]
	ora $F2.b		; 05 F2 ; Logical OR $F2.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $F1		; 10 F1 ; Branch if plus to $10, $F1 [Flow: branch]
	cmp ($B4.b,X)		; C1 B4 ; Compare accumulator ($B4.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	lda ($CF.b),Y		; B1 CF ; Load accumulator ($CF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	.db $50, $F2		; 50 F2 ; Branch if overflow clear to $50, $F2 [Flow: branch]
	.db $D0, $22		; D0 22 ; Branch if not equal to $D0, $22 [Flow: branch]
	ldy $C4.b		; A4 C4 ; Load $C4.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	ora $2EC402.l		; 0F 02 C4 2E ; OR accumulator with memory (long) $2EC402.l [Writes: Accumulator] [Flags: NZ]
	jsr $0002.w		; 20 02 00 ; Jump to subroutine at $0002.w [Writes: Stack Pointer] [Flow: call]
	and $0EC4.w		; 2D C4 0E ; Logical AND $0EC4.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0F11.w,X		; 1D 11 0F ; OR accumulator with memory $0F11.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $1E1F4D.l		; CF 4D 1F 1E ; Compare accumulator (long) $1E1F4D.l [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $DF		; B0 DF ; Branch if carry set to $B0, $DF [Flow: branch]
	and [$65.b]		; 27 65 ; AND accumulator with memory (long) [$65.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc [$E4.b],Y		; 77 E4 ; Add with carry (long indexed) [$E4.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($50.b,X)		; 61 50 ; Add with carry ($50.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ldy $6F.b,X		; B4 6F ; Load Y register $6F.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	asl $96.b		; 06 96 ; Arithmetic shift left $96.b [Reads: Direct Page] [Flags: NCZ]
	cmp $3C7B.w		; CD 7B 3C ; Compare $3C7B.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cpx #$CF.b		; E0 CF ; Compare #$CF.b with X register [Reads: X Index] [Flags: NCZ]
	ldy $15.b,X		; B4 15 ; Load Y register $15.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	dec $0660.w		; CE 60 06 ; Decrement $0660.w [Flags: NZ]
	rol $D45E.w,X		; 3E 5E D4 ; Rotate left $D45E.w,X [Reads: X Index] [Flags: NCZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	cpy $3F.b		; C4 3F ; Compare $3F.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	sbc $E00EFF.l		; EF FF 0E E0 ; Subtract with carry (long) $E00EFF.l [Writes: Accumulator] [Flags: NCVZ]
	ora $C4E312.l		; 0F 12 E3 C4 ; OR accumulator with memory (long) $C4E312.l [Writes: Accumulator] [Flags: NZ]
.INDEX 8
	sep #$13		; E2 13
	sbc $F1144C.l		; EF 4C 14 F1 ; Subtract with carry (long) $F1144C.l [Writes: Accumulator] [Flags: NCVZ]
	inc $C43F.w,X		; FE 3F C4 ; Increment memory $C43F.w,X [Reads: X Index] [Flags: NZ]
	ora $E43A.w,X		; 1D 3A E4 ; OR accumulator with memory $E43A.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($FF.b,X)		; C1 FF ; Compare accumulator ($FF.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cpx #$4E.b		; E0 4E ; Compare #$4E.b with X register [Reads: X Index] [Flags: NCZ]
	.db $B0, $F6		; B0 F6 ; Branch if carry set to $B0, $F6 [Flow: branch]
	ora $401532.l		; 0F 32 15 40 ; OR accumulator with memory (long) $401532.l [Writes: Accumulator] [Flags: NZ]
	ora $ED.b,X		; 15 ED ; OR accumulator with memory $ED.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	asl $20C0.w,X		; 1E C0 20 ; Arithmetic shift left $20C0.w,X [Reads: X Index] [Flags: NCZ]
	sbc ($30.b),Y		; F1 30 ; Subtract with carry ($30.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($2D.b),Y		; F1 2D ; Subtract with carry ($2D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $C0D40F.l		; CF 0F D4 C0 ; Compare accumulator (long) $C0D40F.l [Reads: Accumulator] [Flags: NCZ]
	inc $FEDE.w,X		; FE DE FE ; Increment memory $FEDE.w,X [Reads: X Index] [Flags: NZ]
	inc $0640.w		; EE 40 06 ; Increment $0640.w [Flags: NZ]
	.db $42, $33		; 42 33 ; Reserved instruction
	cpy $0C.b		; C4 0C ; Compare $0C.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	sbc $22E200.l,X		; FF 00 E2 22 ; Subtract with carry (long,X) $22E200.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $E4		; F0 E4 ; Branch if equal to $F0, $E4 [Flow: branch]
	cmp ($C4.b,S),Y		; D3 C4 ; Compare accumulator (stack relative indirect indexed) ($C4.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	cmp $EC.b,S		; C3 EC ; Compare accumulator (stack relative) $EC.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	.db $10, $0E		; 10 0E ; Branch if plus to $10, $0E [Flow: branch]
	jsl $1E14F1.l		; 22 F1 14 1E ; Jump to subroutine long $1E14F1.l [Writes: Stack Pointer] [Flow: call]
	cpy $30.b		; C4 30 ; Compare $30.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	ora $1FDEE1.l		; 0F E1 DE 1F ; OR accumulator with memory (long) $1FDEE1.l [Writes: Accumulator] [Flags: NZ]
	sbc $C030F1.l,X		; FF F1 30 C0 ; Subtract with carry (long,X) $C030F1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp ($FD.b,X)		; C1 FD ; Compare accumulator ($FD.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	cop $16.b		; 02 16 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $43.b,S		; 63 43 ; Add with carry (stack relative) $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	brk $1B.b		; 00 1B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$DD.b		; C0 DD ; Compare #$DD.b with Y register [Reads: Y Index] [Flags: NCZ]
	dec $140E.w		; CE 0E 14 ; Decrement $140E.w [Flags: NZ]
	sbc ($43.b)		; F2 43 ; Subtract with carry (indirect) ($43.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	bit $F1.b,X		; 34 F1 ; Test bits $F1.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $B0, $1C		; B0 1C ; Branch if carry set to $B0, $1C [Flow: branch]
	ldx #$9F.b		; A2 9F ; Load #$9F.b into X register [Writes: X Index] [Flags: NZ]
	and $EFEFE3.l		; 2F E3 EF EF ; AND accumulator with memory (long) $EFEFE3.l [Writes: Accumulator] [Flags: NZ]
	rep #$C0		; C2 C0 ; Reset processor status bits #$C0 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	sbc $5E2431.l,X		; FF 31 24 5E ; Subtract with carry (long,X) $5E2431.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($CD.b,X)		; 01 CD ; Logical OR ($CD.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	.db $D0, $2F		; D0 2F ; Branch if not equal to $D0, $2F [Flow: branch]
	tsb $21.b		; 04 21 ; Test and set bits $21.b [Reads: Accumulator] [Flags: Z]
	and ($32.b)		; 32 32 ; AND accumulator with memory (indirect) ($32.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $CFC011.l		; 0F 11 C0 CF ; OR accumulator with memory (long) $CFC011.l [Writes: Accumulator] [Flags: NZ]
	bit $FDF0.w		; 2C F0 FD ; Test bits $FDF0.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	sbc $620102.l,X		; FF 02 01 62 ; Subtract with carry (long,X) $620102.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy $21.b		; C4 21 ; Compare $21.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	sbc ($0C.b)		; F2 0C ; Subtract with carry (indirect) ($0C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	asl $3C1B.w		; 0E 1B 3C ; Arithmetic shift left $3C1B.w [Flags: NCZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$EC.b		; C0 EC ; Compare #$EC.b with Y register [Reads: Y Index] [Flags: NCZ]
	jsl $533452.l		; 22 52 34 53 ; Jump to subroutine long $533452.l [Writes: Stack Pointer] [Flow: call]
	bit $3E.b,X		; 34 3E ; Test bits $3E.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sbc $C0.b,S		; E3 C0 ; Subtract stack-relative $C0.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	sbc $DDC1.w		; ED C1 DD ; Subtract $DDC1.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	inc $22F4.w,X		; FE F4 22 ; Increment memory $22F4.w,X [Reads: X Index] [Flags: NZ]
	.db $42, $35		; 42 35 ; Reserved instruction
	cpy #$0E.b		; C0 0E ; Compare #$0E.b with Y register [Reads: Y Index] [Flags: NCZ]
	bit $CCEE.w,X		; 3C EE CC ; Test bits $CCEE.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: NCZ]
	sbc ($43.b)		; F2 43 ; Subtract with carry (indirect) ($43.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ldy $03.b,X		; B4 03 ; Load Y register $03.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	asl $B4D2.w,X		; 1E D2 B4 ; Arithmetic shift left $B4D2.w,X [Reads: X Index] [Flags: NCZ]
	sta ($FA.b)		; 92 FA ; Store accumulator (indirect) ($FA.b) [Reads: Direct Page, Accumulator]
	brk $F1.b		; 00 F1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy $2F.b		; C4 2F ; Compare $2F.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	.db $10, $E5		; 10 E5 ; Branch if plus to $10, $E5 [Flow: branch]
	sbc $F4.b,S		; E3 F4 ; Subtract stack-relative $F4.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	sbc $C4121E.l		; EF 1E 12 C4 ; Subtract with carry (long) $C4121E.l [Writes: Accumulator] [Flags: NCVZ]
	jsr ($E32C.w,X)		; FC 2C E3 ; Jump to subroutine indirect indexed ($E32C.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	pei ($DF.b)		; D4 DF ; Push effective indirect address ($DF.b) [Reads: Direct Page] [Writes: Stack Pointer]
	and $C05F3C.l,X		; 3F 3C 5F C0 ; AND accumulator with memory (long,X) $C05F3C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($D5.b,X)		; 21 D5 ; Logical AND ($D5.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsr $0F31.w		; 20 31 0F ; Jump to subroutine at $0F31.w [Writes: Stack Pointer] [Flow: call]
	asl $C300.w		; 0E 00 C3 ; Arithmetic shift left $C300.w [Flags: NCZ]
	cpy #$0E.b		; C0 0E ; Compare #$0E.b with Y register [Reads: Y Index] [Flags: NCZ]
	ora ($24.b)		; 12 24 ; OR accumulator with memory (indirect) ($24.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($32.b)		; 32 32 ; AND accumulator with memory (indirect) ($32.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $C0E220.l,X		; FF 20 E2 C0 ; Subtract with carry (long,X) $C0E220.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $0D.b,S		; 03 0D ; OR accumulator with stack relative $0D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	asl $01CC.w,X		; 1E CC 01 ; Arithmetic shift left $01CC.w,X [Reads: X Index] [Flags: NCZ]
	rep #$C0		; C2 C0 ; Reset processor status bits #$C0 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	and ($3F.b),Y		; 31 3F ; AND accumulator with memory ($3F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($2F.b),Y		; 31 2F ; AND accumulator with memory ($2F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($FF.b,S),Y		; 13 FF ; OR accumulator (stack relative indirect indexed) ($FF.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $10.b		; 02 10 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$0F.b		; C0 0F ; Compare #$0F.b with Y register [Reads: Y Index] [Flags: NCZ]
	inc $00F1.w,X		; FE F1 00 ; Increment memory $00F1.w,X [Reads: X Index] [Flags: NZ]
	sbc $DEB0E1.l,X		; FF E1 B0 DE ; Subtract with carry (long,X) $DEB0E1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy $1F.b		; C4 1F ; Compare $1F.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	and ($E2.b)		; 32 E2 ; AND accumulator with memory (indirect) ($E2.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc ($C4.b,S),Y		; F3 C4 ; Subtract with carry (stack relative indirect indexed) ($C4.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cmp $FD.b,S		; C3 FD ; Compare accumulator (stack relative) $FD.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	eor $1DCDC0.l		; 4F C0 CD 1D ; Exclusive OR accumulator with memory (long) $1DCDC0.l [Writes: Accumulator] [Flags: NZ]
	lda $EDDD.w		; AD DD ED ; Load $EDDD.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp $C40EEF.l,X		; DF EF 0E C4 ; Compare accumulator (long,X) $C40EEF.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	tsb $2F.b		; 04 2F ; Test and set bits $2F.b [Reads: Accumulator] [Flags: Z]
	and ($D4.b,X)		; 21 D4 ; Logical AND ($D4.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $1CFD1F.l,X		; FF 1F FD 1C ; Subtract with carry (long,X) $1CFD1F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$FC.b		; C0 FC ; Compare #$FC.b with Y register [Reads: Y Index] [Flags: NCZ]
	cmp $FFBD.w,X		; DD BD FF ; Compare accumulator $FFBD.w,X [Reads: X Index] [Flags: NCZ]
.ACCU 16
	rep #$ED		; C2 ED
	ora ($22.b),Y		; 11 22 ; OR accumulator with memory ($22.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpy $E0.b		; C4 E0 ; Compare $E0.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	eor $03DFD5.l		; 4F D5 DF 03 ; Exclusive OR accumulator with memory (long) $03DFD5.l [Writes: Accumulator] [Flags: NZ]
	.db $B0, $F0		; B0 F0 ; Branch if carry set to $B0, $F0 [Flow: branch]
	asl $91B0.w		; 0E B0 91 ; Arithmetic shift left $91B0.w [Flags: NCZ]
	sbc $0BE0.w,Y		; F9 E0 0B ; Subtract with carry $0BE0.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($32.b,S),Y		; 13 32 ; OR accumulator (stack relative indirect indexed) ($32.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda ($50.b)		; B2 50 ; Load accumulator (indirect) ($50.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpy #$21.b		; C0 21 ; Compare #$21.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $10, $E1		; 10 E1 ; Branch if plus to $10, $E1 [Flow: branch]
	eor ($31.b,X)		; 41 31 ; Exclusive OR accumulator with memory ($31.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor $D1FF.w		; 4D FF D1 ; Exclusive OR $D1FF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cpy #$BE.b		; C0 BE ; Compare #$BE.b with Y register [Reads: Y Index] [Flags: NCZ]
	sbc $2030ED.l,X		; FF ED 30 20 ; Subtract with carry (long,X) $2030ED.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $E0.b		; C5 E0 ; Compare $E0.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	and $C4.b,S		; 23 C4 ; AND accumulator with stack relative $C4.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp ($F3.b),Y		; D1 F3 ; Compare accumulator ($F3.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	ora $DE14.w		; 0D 14 DE ; Logical OR $DE14.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($E0.b),Y		; 11 E0 ; OR accumulator with memory ($E0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $C0.b,S		; E3 C0 ; Subtract stack-relative $C0.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $F0F030.l,X		; 1F 30 F0 F0 ; Logical OR long $F0F030.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $3F		; D0 3F ; Branch if not equal to $D0, $3F [Flow: branch]
	sbc $0E2FC0.l		; EF C0 2F 0E ; Subtract with carry (long) $0E2FC0.l [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $CC		; F0 CC ; Branch if equal to $F0, $CC [Flow: branch]
	jsl $4151D2.l		; 22 D2 51 41 ; Jump to subroutine long $4151D2.l [Writes: Stack Pointer] [Flow: call]
	cpy #$22.b		; C0 22 ; Compare #$22.b with Y register [Reads: Y Index] [Flags: NCZ]
	ora $FFF0.w,X		; 1D F0 FF ; OR accumulator with memory $FFF0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $DFEE.w,X		; FE EE DF ; Increment memory $DFEE.w,X [Reads: X Index] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $B0, $00		; B0 00 ; Branch if carry set to $B0, $00 [Flow: branch]
	ora ($13.b),Y		; 11 13 ; OR accumulator with memory ($13.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $21.b,X		; 75 21 ; Add $21.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $D1		; 10 D1 ; Branch if plus to $10, $D1 [Flow: branch]
	cpx $C0.b		; E4 C0 ; Compare $C0.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $F0, $1E		; F0 1E ; Branch if equal to $F0, $1E [Flow: branch]
	.db $B0, $12		; B0 12 ; Branch if carry set to $B0, $12 [Flow: branch]
	inc $1BFD.w,X		; FE FD 1B ; Increment memory $1BFD.w,X [Reads: X Index] [Flags: NZ]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $412032.l		; EF 32 20 41 ; Subtract with carry (long) $412032.l [Writes: Accumulator] [Flags: NCVZ]
	ora $1F0004.l		; 0F 04 00 1F ; OR accumulator with memory (long) $1F0004.l [Writes: Accumulator] [Flags: NZ]
	cpy #$31.b		; C0 31 ; Compare #$31.b with Y register [Reads: Y Index] [Flags: NCZ]
	sbc ($1E.b,S),Y		; F3 1E ; Subtract with carry (stack relative indirect indexed) ($1E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cpy $0F.b		; C4 0F ; Compare $0F.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	sbc ($FF.b,X)		; E1 FF ; Subtract with carry ($FF.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda ($C0.b)		; B2 C0 ; Load accumulator (indirect) ($C0.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $F24110.l		; 2F 10 41 F2 ; AND accumulator with memory (long) $F24110.l [Writes: Accumulator] [Flags: NZ]
	ora ($B0.b,X)		; 01 B0 ; Logical OR ($B0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $26B003.l,X		; 1F 03 B0 26 ; Logical OR long $26B003.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $11		; F0 11 ; Branch if equal to $F0, $11 [Flow: branch]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $31.b,S		; 03 31 ; OR accumulator with stack relative $31.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $5F.b		; 24 5F ; Test bits $5F.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	.db $B0, $D3		; B0 D3 ; Branch if carry set to $B0, $D3 [Flow: branch]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $90, $CC		; 90 CC ; Branch if carry clear to $90, $CC [Flow: branch]
	cpy $05.b		; C4 05 ; Compare $05.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	and $26.b		; 25 26 ; Logical AND $26.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpy #$CE.b		; C0 CE ; Compare #$CE.b with Y register [Reads: Y Index] [Flags: NCZ]
	trb $F0F2.w		; 1C F2 F0 ; Test and reset bits $F0F2.w [Reads: Accumulator] [Flags: Z]
	and $25.b,S		; 23 25 ; AND accumulator with stack relative $25.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($40.b)		; 12 40 ; OR accumulator with memory (indirect) ($40.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $0E		; B0 0E ; Branch if carry set to $B0, $0E [Flow: branch]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lda $EF.b,S		; A3 EF ; Load accumulator (stack relative) $EF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $30, $02		; 30 02 ; Branch if minus to $30, $02 [Flow: branch]
	ldy $1FC0.w,X		; BC C0 1F ; Load Y register $1FC0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
.INDEX 16
	rep #$1E		; C2 1E
	ora $44.b,X		; 15 44 ; OR accumulator with memory $44.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($2F.b,S),Y		; 13 2F ; OR accumulator (stack relative indirect indexed) ($2F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cpy #$DDEC.w		; C0 EC DD ; Compare #$DDEC.w with Y register [Reads: Y Index] [Flags: NCZ]
	cmp $EF.b,X		; D5 EF ; Compare accumulator $EF.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	and ($21.b),Y		; 31 21 ; AND accumulator with memory ($21.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $ED.b		; 00 ED ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$ECA2.w		; C0 A2 EC ; Compare #$ECA2.w with Y register [Reads: Y Index] [Flags: NCZ]
	and $F3.b,S		; 23 F3 ; AND accumulator with stack relative $F3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $51.b		; 05 51 ; Logical OR $51.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b,S		; 43 1A ; Exclusive OR accumulator with stack relative $1A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpy #$C110.w		; C0 10 C1 ; Compare #$C110.w with Y register [Reads: Y Index] [Flags: NCZ]
	dec $FDFB.w		; CE FB FD ; Decrement $FDFB.w [Flags: NZ]
	ora $E1E0.w,X		; 1D E0 E1 ; OR accumulator with memory $E1E0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$2F21.w		; C0 21 2F ; Compare #$2F21.w with Y register [Reads: Y Index] [Flags: NCZ]
	bit $25.b		; 24 25 ; Test bits $25.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	and ($40.b)		; 32 40 ; AND accumulator with memory (indirect) ($40.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $C020.w		; 2C 20 C0 ; Test bits $C020.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	asl $FEFD.w		; 0E FD FE ; Arithmetic shift left $FEFD.w [Flags: NCZ]
	and $EDB11C.l		; 2F 1C B1 ED ; AND accumulator with memory (long) $EDB11C.l [Writes: Accumulator] [Flags: NZ]
	trb $C0.b		; 14 C0 ; Test and reset bits $C0.b [Reads: Accumulator] [Flags: Z]
	cpx $24.b		; E4 24 ; Compare $24.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	and ($13.b,S),Y		; 33 13 ; AND accumulator (stack relative indirect indexed) ($13.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $DF42.w,X		; 3C 42 DF ; Test bits $DF42.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	.db $B0, $01		; B0 01 ; Branch if carry set to $B0, $01 [Flow: branch]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc ($BF.b),Y		; F1 BF ; Subtract with carry ($BF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp.w [$1207]		; DC 07 12 ; Jump long indirect [$1207] [Flow: jump]
	cpy #$3243.w		; C0 43 32 ; Compare #$3243.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora ($DE.b,S),Y		; 13 DE ; OR accumulator (stack relative indirect indexed) ($DE.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($EE.b,X)		; 01 EE ; Logical OR ($EE.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $E1C0DE.l		; 0F DE C0 E1 ; OR accumulator with memory (long) $E1C0DE.l [Writes: Accumulator] [Flags: NZ]
	and ($15.b),Y		; 31 15 ; AND accumulator with memory ($15.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $C02EEE.l		; CF EE 2E C0 ; Compare accumulator (long) $C02EEE.l [Reads: Accumulator] [Flags: NCZ]
	ora ($D0.b)		; 12 D0 ; OR accumulator with memory (indirect) ($D0.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $10		; F0 10 ; Branch if equal to $F0, $10 [Flow: branch]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	bit $1F00.w		; 2C 00 1F ; Test bits $1F00.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	cpy #$4001.w		; C0 01 40 ; Compare #$4001.w with Y register [Reads: Y Index] [Flags: NCZ]
	eor ($15.b)		; 52 15 ; Exclusive OR accumulator with memory (indirect) ($15.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $02		; D0 02 ; Branch if not equal to $D0, $02 [Flow: branch]
	inc $C00F.w		; EE 0F C0 ; Increment $C00F.w [Flags: NZ]
	cmp ($C0.b)		; D2 C0 ; Compare accumulator (indirect) ($C0.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cpx $EE3E.w		; EC 3E EE ; Compare $EE3E.w with X register [Reads: X Index] [Flags: NCZ]
	and ($22.b,X)		; 21 22 ; Logical AND ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($C0.b),Y		; 11 C0 ; OR accumulator with memory ($C0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jmp $0EE05F.l		; 5C 5F E0 0E ; Jump long to $0EE05F.l [Flow: jump]
	tsb $2F11.w		; 0C 11 2F ; Test and set bits $2F11.w [Reads: Accumulator] [Flags: Z]
	rol $03C0.w		; 2E C0 03 ; Rotate left $03C0.w [Flags: NCZ]
	ora $F0B1FE.l,X		; 1F FE B1 F0 ; Logical OR long $F0B1FE.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $4E2F.w,X		; 3D 2F 4E ; AND accumulator with memory $4E2F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$2513.w		; C0 13 25 ; Compare #$2513.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora ($3D.b)		; 12 3D ; OR accumulator with memory (indirect) ($3D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $DFEF.w,X		; FE EF DF ; Increment memory $DFEF.w,X [Reads: X Index] [Flags: NZ]
	inc $00C4.w		; EE C4 00 ; Increment $00C4.w [Flags: NZ]
	cop $E0.b		; 02 E0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $3F3E3C.l		; 2F 3C 3E 3F ; AND accumulator with memory (long) $3F3E3C.l [Writes: Accumulator] [Flags: NZ]
	ora $C0.b		; 05 C0 ; Logical OR $C0.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($13.b)		; 12 13 ; OR accumulator with memory (indirect) ($13.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $2D0E.w,X		; 1E 0E 2D ; Arithmetic shift left $2D0E.w,X [Reads: X Index] [Flags: NCZ]
	cpy #$C3FB.w		; C0 FB C3 ; Compare #$C3FB.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpy #$20DE.w		; C0 DE 20 ; Compare #$20DE.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora ($21.b)		; 12 21 ; OR accumulator with memory (indirect) ($21.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $322D01.l,X		; 5F 01 2D 32 ; Exclusive OR accumulator with memory (long,X) $322D01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$CEF0.w		; C0 F0 CE ; Compare #$CEF0.w with Y register [Reads: Y Index] [Flags: NCZ]
	bit $20E1.w		; 2C E1 20 ; Test bits $20E1.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	ora ($A3.b,X)		; 01 A3 ; Logical OR ($A3.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jmp.w [$40C0]		; DC C0 40 ; Jump long indirect [$40C0] [Flow: jump]
	cmp $30.b,S		; C3 30 ; Compare accumulator (stack relative) $30.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	.db $10, $43		; 10 43 ; Branch if plus to $10, $43 [Flow: branch]
	ora $C0D220.l,X		; 1F 20 D2 C0 ; Logical OR long $C0D220.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $F0030C.l		; EF 0C 03 F0 ; Subtract with carry (long) $F0030C.l [Writes: Accumulator] [Flags: NCVZ]
	and $010ECF.l		; 2F CF 0E 01 ; AND accumulator with memory (long) $010ECF.l [Writes: Accumulator] [Flags: NZ]
	cpy #$C324.w		; C0 24 C3 ; Compare #$C324.w with Y register [Reads: Y Index] [Flags: NCZ]
	and ($13.b),Y		; 31 13 ; AND accumulator with memory ($13.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	inc $A01E.w,X		; FE 1E A0 ; Increment memory $A01E.w,X [Reads: X Index] [Flags: NZ]
	ldy $1DC0.w		; AC C0 1D ; Load $1DC0.w into Y register [Writes: Y Index] [Flags: NZ]
	and ($01.b,X)		; 21 01 ; Logical AND ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $E2.b		; 25 E2 ; Logical AND $E2.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($F0.b,X)		; 21 F0 ; Logical AND ($F0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $60213C.l		; CF 3C 21 60 ; Compare accumulator (long) $60213C.l [Reads: Accumulator] [Flags: NCZ]
	ora ($DF.b)		; 12 DF ; OR accumulator with memory (indirect) ($DF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $C0DC.w,X		; DD DC C0 ; Compare accumulator $C0DC.w,X [Reads: X Index] [Flags: NCZ]
	sbc $022C.w,X		; FD 2C 02 ; Subtract with carry $022C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $3302F4.l,X		; 1F F4 02 33 ; Logical OR long $3302F4.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rol $31C0.w		; 2E C0 31 ; Rotate left $31C0.w [Flags: NCZ]
	ora ($2F.b),Y		; 11 2F ; OR accumulator with memory ($2F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $1D		; F0 1D ; Branch if equal to $F0, $1D [Flow: branch]
	ldy $FDDB.w,X		; BC DB FD ; Load Y register $FDDB.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	cpy #$4E4D.w		; C0 4D 4E ; Compare #$4E4D.w with Y register [Reads: Y Index] [Flags: NCZ]
	eor $101115.l,X		; 5F 15 11 10 ; Exclusive OR accumulator with memory (long,X) $101115.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	ora ($C4.b,X)		; 01 C4 ; Logical OR ($C4.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp $2DEE3F.l,X		; DF 3F EE 2D ; Compare accumulator (long,X) $2DEE3F.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	eor $C404.w		; 4D 04 C4 ; Exclusive OR $C404.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc ($C0.b),Y		; F1 C0 ; Subtract with carry ($C0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $23.b		; 04 23 ; Test and set bits $23.b [Reads: Accumulator] [Flags: Z]
	ora ($21.b)		; 12 21 ; OR accumulator with memory (indirect) ($21.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $30, $4A		; 30 4A ; Branch if minus to $30, $4A [Flow: branch]
	and ($0D.b)		; 32 0D ; AND accumulator with memory (indirect) ($0D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpy #$EC2F.w		; C0 2F EC ; Compare #$EC2F.w with Y register [Reads: Y Index] [Flags: NCZ]
	sbc $CDD1FD.l,X		; FF FD D1 CD ; Subtract with carry (long,X) $CDD1FD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($22.b,X)		; 41 22 ; Exclusive OR accumulator with memory ($22.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$1104.w		; C0 04 11 ; Compare #$1104.w with Y register [Reads: Y Index] [Flags: NCZ]
	tsb $DD.b		; 04 DD ; Test and set bits $DD.b [Reads: Accumulator] [Flags: Z]
	.db $F0, $A1		; F0 A1 ; Branch if equal to $F0, $A1 [Flow: branch]
	cmp ($02.b),Y		; D1 02 ; Compare accumulator ($02.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cpy #$2E21.w		; C0 21 2E ; Compare #$2E21.w with Y register [Reads: Y Index] [Flags: NCZ]
	and $10.b,S		; 23 10 ; AND accumulator with stack relative $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $1D3D.w		; 0D 3D 1D ; Logical OR $1D3D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $0EC0.w		; 20 C0 0E ; Jump to subroutine at $0EC0.w [Writes: Stack Pointer] [Flow: call]
	rol $3F21.w,X		; 3E 21 3F ; Rotate left $3F21.w,X [Reads: X Index] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	ora ($0C.b,S),Y		; 13 0C ; OR accumulator (stack relative indirect indexed) ($0C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($C0.b,X)		; 21 C0 ; Logical AND ($C0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp ($0C.b,X)		; C1 0C ; Compare accumulator ($0C.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
.INDEX 8
	sep #$D1		; E2 D1
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $10, $2D		; 10 2D ; Branch if plus to $10, $2D [Flow: branch]
	cpy #$11.b		; C0 11 ; Compare #$11.b with Y register [Reads: Y Index] [Flags: NCZ]
	cmp ($2E.b,S),Y		; D3 2E ; Compare accumulator (stack relative indirect indexed) ($2E.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	jsr $5E10.w		; 20 10 5E ; Jump to subroutine at $5E10.w [Writes: Stack Pointer] [Flow: call]
	ora $CF.b		; 05 CF ; Logical OR $CF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpy #$3E.b		; C0 3E ; Compare #$3E.b with Y register [Reads: Y Index] [Flags: NCZ]
	rol $DFC0.w,X		; 3E C0 DF ; Rotate left $DFC0.w,X [Reads: X Index] [Flags: NCZ]
	rol $413F.w		; 2E 3F 41 ; Rotate left $413F.w [Flags: NCZ]
	ora $C0.b,S		; 03 C0 ; OR accumulator with stack relative $C0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $E0.b,S		; A3 E0 ; Load accumulator (stack relative) $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $D2EF1D.l,X		; BF 1D EF D2 ; Load long $D2EF1D.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $C01F.w,X		; 1D 1F C0 ; OR accumulator with memory $C01F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $32EF04.l		; 0F 04 EF 32 ; OR accumulator with memory (long) $32EF04.l [Writes: Accumulator] [Flags: NZ]
	sbc $110E22.l		; EF 22 0E 11 ; Subtract with carry (long) $110E22.l [Writes: Accumulator] [Flags: NCVZ]
	cpy #$1C.b		; C0 1C ; Compare #$1C.b with Y register [Reads: Y Index] [Flags: NCZ]
	ora $1F100F.l,X		; 1F 0F 10 1F ; Logical OR long $1F100F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($3B.b)		; F2 3B ; Subtract with carry (indirect) ($3B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($C0.b,S),Y		; 13 C0 ; OR accumulator (stack relative indirect indexed) ($C0.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $20		; D0 20 ; Branch if not equal to $D0, $20 [Flow: branch]
	and ($FF.b,X)		; 21 FF ; Logical AND ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $3FEFFF.l,X		; 1F FF EF 3F ; Logical OR long $3FEFFF.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $2E416E.l,X		; 3F 6E 41 2E ; AND accumulator with memory (long,X) $2E416E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldy $63.b,X		; B4 63 ; Load Y register $63.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	eor $10.b,S		; 43 10 ; Exclusive OR accumulator with stack relative $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $E0.b,S		; C3 E0 ; Compare accumulator (stack relative) $E0.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	tsb $0B.b		; 04 0B ; Test and set bits $0B.b [Reads: Accumulator] [Flags: Z]
	ldy $E3.b,X		; B4 E3 ; Load Y register $E3.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	inc $4D10.w,X		; FE 10 4D ; Increment memory $4D10.w,X [Reads: X Index] [Flags: NZ]
	and $F024.w,Y		; 39 24 F0 ; AND accumulator with memory $F024.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora [$C0.b],Y		; 17 C0 ; OR accumulator with memory (long indexed) [$C0.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$6F.b		; E0 6F ; Compare #$6F.b with X register [Reads: X Index] [Flags: NCZ]
	ora $D33E20.l,X		; 1F 20 3E D3 ; Logical OR long $D33E20.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($03.b),Y		; 11 03 ; OR accumulator with memory ($03.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$FD.b		; C0 FD ; Compare #$FD.b with Y register [Reads: Y Index] [Flags: NCZ]
	ora ($B0.b,S),Y		; 13 B0 ; OR accumulator (stack relative indirect indexed) ($B0.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $10.b		; 02 10 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $01.b,S		; E3 01 ; Subtract stack-relative $01.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	cmp ($C0.b),Y		; D1 C0 ; Compare accumulator ($C0.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	inc $1C02.w,X		; FE 02 1C ; Increment memory $1C02.w,X [Reads: X Index] [Flags: NZ]
	jsr $0F02.w		; 20 02 0F ; Jump to subroutine at $0F02.w [Writes: Stack Pointer] [Flow: call]
	asl $C01E.w,X		; 1E 1E C0 ; Arithmetic shift left $C01E.w,X [Reads: X Index] [Flags: NCZ]
	.db $10, $EE		; 10 EE ; Branch if plus to $10, $EE [Flow: branch]
	brk $2C.b		; 00 2C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($01.b),Y		; 31 01 ; AND accumulator with memory ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpy #$0D.b		; C0 0D ; Compare #$0D.b with Y register [Reads: Y Index] [Flags: NCZ]
	ora $C0F4.w		; 0D F4 C0 ; Logical OR $C0F4.w with accumulator [Writes: Accumulator] [Flags: NZ]
	eor ($3E.b,X)		; 41 3E ; Exclusive OR accumulator with memory ($3E.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor $C020.w		; 4D 20 C0 ; Exclusive OR $C020.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $FF		; F0 FF ; Branch if equal to $F0, $FF [Flow: branch]
	ora $E2F0EE.l,X		; 1F EE F0 E2 ; Logical OR long $E2F0EE.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $C060.w,X		; 1D 60 C0 ; OR accumulator with memory $C060.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $0F02.w,X		; 5D 02 0F ; Exclusive OR accumulator with memory $0F02.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $5F3E.w,X		; 5D 3E 5F ; Exclusive OR accumulator with memory $5F3E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $0BC0D1.l,X		; 5F D1 C0 0B ; Exclusive OR accumulator with memory (long,X) $0BC0D1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rol $290A.w		; 2E 0A 29 ; Rotate left $290A.w [Flags: NCZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $C034.w		; 4E 34 C0 ; Logical shift right $C034.w [Flags: NCZ]
	tsb $E0.b		; 04 E0 ; Test and set bits $E0.b [Reads: Accumulator] [Flags: Z]
	inc $1EED.w		; EE ED 1E ; Increment $1EED.w [Flags: NZ]
	sbc ($21.b)		; F2 21 ; Subtract with carry (indirect) ($21.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($C0.b),Y		; 11 C0 ; OR accumulator with memory ($C0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($1E.b,S),Y		; 33 1E ; AND accumulator (stack relative indirect indexed) ($1E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $10, $DD		; 10 DD ; Branch if plus to $10, $DD [Flow: branch]
	sbc $401FD3.l,X		; FF D3 1F 40 ; Subtract with carry (long,X) $401FD3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$54.b		; C0 54 ; Compare #$54.b with Y register [Reads: Y Index] [Flags: NCZ]
	jsr $C0F5.w		; 20 F5 C0 ; Jump to subroutine at $C0F5.w [Writes: Stack Pointer] [Flow: call]
	ora $1100D2.l		; 0F D2 00 11 ; OR accumulator with memory (long) $1100D2.l [Writes: Accumulator] [Flags: NZ]
	cpy #$D0.b		; C0 D0 ; Compare #$D0.b with Y register [Reads: Y Index] [Flags: NCZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($D1.b),Y		; 11 D1 ; OR accumulator with memory ($D1.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $F3.b,S		; E3 F3 ; Subtract stack-relative $F3.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	.db $F0, $3F		; F0 3F ; Branch if equal to $F0, $3F [Flow: branch]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: NCZ]
	cmp ($CF.b,X)		; C1 CF ; Compare accumulator ($CF.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	sbc $03F012.l		; EF 12 F0 03 ; Subtract with carry (long) $03F012.l [Writes: Accumulator] [Flags: NCVZ]
	ora $C0.b		; 05 C0 ; Logical OR $C0.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $FFFF00.l		; 2F 00 FF FF ; AND accumulator with memory (long) $FFFF00.l [Writes: Accumulator] [Flags: NZ]
	inc $301B.w,X		; FE 1B 30 ; Increment memory $301B.w,X [Reads: X Index] [Flags: NZ]
	ora ($C0.b),Y		; 11 C0 ; OR accumulator with memory ($C0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $0EFF00.l,X		; 1F 00 FF 0E ; Logical OR long $0EFF00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($F0.b),Y		; 11 F0 ; OR accumulator with memory ($F0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($5F.b),Y		; 31 5F ; AND accumulator with memory ($5F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$03.b		; C0 03 ; Compare #$03.b with Y register [Reads: Y Index] [Flags: NCZ]
	inc $0C0E.w		; EE 0E 0C ; Increment $0C0E.w [Flags: NZ]
	rol $0FD1.w,X		; 3E D1 0F ; Rotate left $0FD1.w,X [Reads: X Index] [Flags: NCZ]
	.db $50, $C0		; 50 C0 ; Branch if overflow clear to $50, $C0 [Flow: branch]
	ora ($5D.b,X)		; 01 5D ; Logical OR ($5D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($ED.b),Y		; 11 ED ; OR accumulator with memory ($ED.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tsb $F0F1.w		; 0C F1 F0 ; Test and set bits $F0F1.w [Reads: Accumulator] [Flags: Z]
	cop $C0.b		; 02 C0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($20.b)		; D2 20 ; Compare accumulator (indirect) ($20.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	rol $0E2F.w,X		; 3E 2F 0E ; Rotate left $0E2F.w,X [Reads: X Index] [Flags: NCZ]
	ora $C00C11.l,X		; 1F 11 0C C0 ; Logical OR long $C00C11.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $D0C4.w		; 2D C4 D0 ; Logical AND $D0C4.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $110103.l		; 2F 03 01 11 ; AND accumulator with memory (long) $110103.l [Writes: Accumulator] [Flags: NZ]
	sbc ($B0.b,S),Y		; F3 B0 ; Subtract with carry (stack relative indirect indexed) ($B0.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	stz $044E.w		; 9C 4E 04 ; Store zero to $044E.w
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	.db $F0, $F2		; F0 F2 ; Branch if equal to $F0, $F2 [Flow: branch]
	ora ($D0.b),Y		; 11 D0 ; OR accumulator with memory ($D0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$B1.b		; C0 B1 ; Compare #$B1.b with Y register [Reads: Y Index] [Flags: NCZ]
	rol $1D2E.w		; 2E 2E 1D ; Rotate left $1D2E.w [Flags: NCZ]
	ora $E0.b,S		; 03 E0 ; OR accumulator with stack relative $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
.ACCU 8
.INDEX 8
	sep #$F0		; E2 F0
	cpy #$EF.b		; C0 EF ; Compare #$EF.b with Y register [Reads: Y Index] [Flags: NCZ]
	rol $E00F.w,X		; 3E 0F E0 ; Rotate left $E00F.w,X [Reads: X Index] [Flags: NCZ]
	cmp ($12.b)		; D2 12 ; Compare accumulator (indirect) ($12.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$0E.b		; C0 0E ; Compare #$0E.b with Y register [Reads: Y Index] [Flags: NCZ]
	and $E0D0.w,X		; 3D D0 E0 ; AND accumulator with memory $E0D0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($D7.b),Y		; F1 D7 ; Subtract with carry ($D7.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $20C04F.l		; EF 4F C0 20 ; Subtract with carry (long) $20C04F.l [Writes: Accumulator] [Flags: NCVZ]
	ora $DFDFFE.l,X		; 1F FE DF DF ; Logical OR long $DFDFFE.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($4C.b)		; F2 4C ; Subtract with carry (indirect) ($4C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($B0.b,S),Y		; 13 B0 ; OR accumulator (stack relative indirect indexed) ($B0.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $FD3E.w,X		; 1E 3E FD ; Arithmetic shift left $FD3E.w,X [Reads: X Index] [Flags: NCZ]
	bit $501E.w		; 2C 1E 50 ; Test bits $501E.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	eor $41B002.l,X		; 5F 02 B0 41 ; Exclusive OR accumulator with memory (long,X) $41B002.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $F1F0E4.l,X		; 1F E4 F0 F1 ; Logical OR long $F1F0E4.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $C00F4C.l,X		; 3F 4C 0F C0 ; AND accumulator with memory (long,X) $C00F4C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $EFDE0D.l,X		; 3F 0D DE EF ; AND accumulator with memory (long,X) $EFDE0D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $30FF11.l		; 2F 11 FF 30 ; AND accumulator with memory (long) $30FF11.l [Writes: Accumulator] [Flags: NZ]
	cpy #$41.b		; C0 41 ; Compare #$41.b with Y register [Reads: Y Index] [Flags: NCZ]
	jsr $F00D.w		; 20 0D F0 ; Jump to subroutine at $F00D.w [Writes: Stack Pointer] [Flow: call]
	cmp ($C1.b)		; D2 C1 ; Compare accumulator (indirect) ($C1.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	and ($12.b,X)		; 21 12 ; Logical AND ($12.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpy $1F.b		; C4 1F ; Compare $1F.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	sbc ($E1.b),Y		; F1 E1 ; Subtract with carry ($E1.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	trb $C410.w		; 1C 10 C4 ; Test and reset bits $C410.w [Reads: Accumulator] [Flags: Z]
	asl $C032.w		; 0E 32 C0 ; Arithmetic shift left $C032.w [Flags: NCZ]
	sbc $F4304E.l,X		; FF 4E 30 F4 ; Subtract with carry (long,X) $F4304E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $1FE1E1.l,X		; FF E1 E1 1F ; Subtract with carry (long,X) $1FE1E1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$12.b		; C0 12 ; Compare #$12.b with Y register [Reads: Y Index] [Flags: NCZ]
	ora ($F2.b),Y		; 11 F2 ; OR accumulator with memory ($F2.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($FC.b),Y		; 11 FC ; OR accumulator with memory ($FC.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $C0FFD1.l,X		; FF D1 FF C0 ; Subtract with carry (long,X) $C0FFD1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($F2.b,S),Y		; F3 F2 ; Subtract with carry (stack relative indirect indexed) ($F2.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora ($F0.b),Y		; 11 F0 ; OR accumulator with memory ($F0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $B03E.w,X		; 1D 3E B0 ; OR accumulator with memory $B03E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$CD.b		; C0 CD ; Compare #$CD.b with Y register [Reads: Y Index] [Flags: NCZ]
	ora $3E.b,S		; 03 3E ; OR accumulator with stack relative $3E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $FF300B.l,X		; 5F 0B 30 FF ; Exclusive OR accumulator with memory (long,X) $FF300B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$2A.b		; C0 2A ; Compare #$2A.b with Y register [Reads: Y Index] [Flags: NCZ]
	asl $1F1F.w,X		; 1E 1F 1F ; Arithmetic shift left $1F1F.w,X [Reads: X Index] [Flags: NCZ]
	sbc $FE.b,S		; E3 FE ; Subtract stack-relative $FE.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	eor $FFC015.l,X		; 5F 15 C0 FF ; Exclusive OR accumulator with memory (long,X) $FFC015.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $3D		; 10 3D ; Branch if plus to $10, $3D [Flow: branch]
	ora $DC001D.l		; 0F 1D 00 DC ; OR accumulator with memory (long) $DC001D.l [Writes: Accumulator] [Flags: NZ]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	cmp ($13.b),Y		; D1 13 ; Compare accumulator ($13.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	tsb $12.b		; 04 12 ; Test and set bits $12.b [Reads: Accumulator] [Flags: Z]
	rol $E022.w		; 2E 22 E0 ; Rotate left $E022.w [Flags: NCZ]
	bit $E0C0.w		; 2C C0 E0 ; Test bits $E0C0.w with accumulator [Reads: Accumulator] [Flags: NVZ]
.INDEX 8
	sep #$10		; E2 10
	ora ($F3.b,X)		; 01 F3 ; Logical OR ($F3.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $DEF0.w,X		; 3C F0 DE ; Test bits $DEF0.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	ldy $4F.b,X		; B4 4F ; Load Y register $4F.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	brk $6B.b		; 00 6B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $DC24.w		; 4D 24 DC ; Exclusive OR $DC24.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $00C0C3.l,X		; 3F C3 C0 00 ; AND accumulator with memory (long,X) $00C0C3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $11		; F0 11 ; Branch if equal to $F0, $11 [Flow: branch]
	ora $FF001F.l		; 0F 1F 00 FF ; OR accumulator with memory (long) $FF001F.l [Writes: Accumulator] [Flags: NZ]
	ldy #$C0.b		; A0 C0 ; Load #$C0.b into Y register [Writes: Y Index] [Flags: NZ]
	sbc $0FD0.w,X		; FD D0 0F ; Subtract with carry $0FD0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($01.b,S),Y		; 13 01 ; OR accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $30, $40		; 30 40 ; Branch if minus to $30, $40 [Flow: branch]
	cmp ($C0.b)		; D2 C0 ; Compare accumulator (indirect) ($C0.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	inc $ED11.w		; EE 11 ED ; Increment $ED11.w [Flags: NZ]
	tsb $01FE.w		; 0C FE 01 ; Test and set bits $01FE.w [Reads: Accumulator] [Flags: Z]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$F3.b		; C0 F3 ; Compare #$F3.b with Y register [Reads: Y Index] [Flags: NCZ]
	eor $0DFF.w		; 4D FF 0D ; Exclusive OR $0DFF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and ($F2.b),Y		; 31 F2 ; AND accumulator with memory ($F2.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($0F.b,X)		; E1 0F ; Subtract with carry ($0F.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $B0, $02		; B0 02 ; Branch if carry set to $B0, $02 [Flow: branch]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sbc ($D0.b,S),Y		; F3 D0 ; Subtract with carry (stack relative indirect indexed) ($D0.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $DA		; F0 DA ; Branch if equal to $F0, $DA [Flow: branch]
	lsr $D1.b		; 46 D1 ; Logical shift right $D1.b [Reads: Direct Page] [Flags: NCZ]
	cpy #$4E.b		; C0 4E ; Compare #$4E.b with Y register [Reads: Y Index] [Flags: NCZ]
	and $E0FFE2.l,X		; 3F E2 FF E0 ; AND accumulator with memory (long,X) $E0FFE2.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$21.b		; C0 21 ; Compare #$21.b with Y register [Reads: Y Index] [Flags: NCZ]
	jsr $3DB4.w		; 20 B4 3D ; Jump to subroutine at $3DB4.w [Writes: Stack Pointer] [Flow: call]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	trb $CB.b		; 14 CB ; Test and reset bits $CB.b [Reads: Accumulator] [Flags: Z]
	ora ($B7.b,S),Y		; 13 B7 ; OR accumulator (stack relative indirect indexed) ($B7.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $C4.b		; C5 C4 ; Compare $C4.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	.db $10, $F4		; 10 F4 ; Branch if plus to $10, $F4 [Flow: branch]
	sbc $FD20.w		; ED 20 FD ; Subtract $FD20.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	and $C0D401.l		; 2F 01 D4 C0 ; AND accumulator with memory (long) $C0D401.l [Writes: Accumulator] [Flags: NZ]
	cmp ($03.b)		; D2 03 ; Compare accumulator (indirect) ($03.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
.ACCU 8
	sep #$21		; E2 21
	ora $E21B0D.l,X		; 1F 0D 1B E2 ; Logical OR long $E21B0D.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $AD		; B0 AD ; Branch if carry set to $B0, $AD [Flow: branch]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl $FF.b		; 06 FF ; Arithmetic shift left $FF.b [Reads: Direct Page] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	lda $FF.b,S		; A3 FF ; Load accumulator (stack relative) $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ror $0FC0.w		; 6E C0 0F ; Rotate right $0FC0.w [Flags: NCZ]
	asl $1E02.w,X		; 1E 02 1E ; Arithmetic shift left $1E02.w,X [Reads: X Index] [Flags: NCZ]
	brk $E2.b		; 00 E2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
.ACCU 16
	rep #$EF		; C2 EF
	cpy #$0E.b		; C0 0E ; Compare #$0E.b with Y register [Reads: Y Index] [Flags: NCZ]
	eor $2E30.w		; 4D 30 2E ; Exclusive OR $2E30.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($0F.b,S),Y		; 13 0F ; OR accumulator (stack relative indirect indexed) ($0F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $4C		; B0 4C ; Branch if carry set to $B0, $4C [Flow: branch]
	and ($20.b),Y		; 31 20 ; AND accumulator with memory ($20.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $CEDF.w,Y		; 19 DF CE ; OR accumulator with memory $CEDF.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and $FFB0F4.l,X		; 3F F4 B0 FF ; AND accumulator with memory (long,X) $FFB0F4.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $4DBFE7.l,X		; 3F E7 BF 4D ; AND accumulator with memory (long,X) $4DBFE7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $FF.b,X		; D5 FF ; Compare accumulator $FF.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($B0.b,X)		; 01 B0 ; Logical OR ($B0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and ($F4.b),Y		; 31 F4 ; AND accumulator with memory ($F4.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda $E2.b		; A5 E2 ; Load $E2.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $FEF1.w,X		; FD F1 FE ; Subtract with carry $FEF1.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sep #$C0		; E2 C0 ; Set processor status bits #$C0 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	asl $E110.w		; 0E 10 E1 ; Arithmetic shift left $E110.w [Flags: NCZ]
	and $02F3D3.l,X		; 3F D3 F3 02 ; AND accumulator with memory (long,X) $02F3D3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $D0, $0F		; D0 0F ; Branch if not equal to $D0, $0F [Flow: branch]
	cmp $0F.b,S		; C3 0F ; Compare accumulator (stack relative) $0F.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	sbc $1F.b,S		; E3 1F ; Subtract stack-relative $1F.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$0F.b		; C0 0F ; Compare #$0F.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $10, $F1		; 10 F1 ; Branch if plus to $10, $F1 [Flow: branch]
	jsr $1341.w		; 20 41 13 ; Jump to subroutine at $1341.w [Writes: Stack Pointer] [Flow: call]
	cop $12.b		; 02 12 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$1D.b		; C0 1D ; Compare #$1D.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $D0, $D0		; D0 D0 ; Branch if not equal to $D0, $D0 [Flow: branch]
	.db $B0, $FD		; B0 FD ; Branch if carry set to $B0, $FD [Flow: branch]
	jsr $132F.w		; 20 2F 13 ; Jump to subroutine at $132F.w [Writes: Stack Pointer] [Flow: call]
	.db $B0, $43		; B0 43 ; Branch if carry set to $B0, $43 [Flow: branch]
	cmp $4D.b,X		; D5 4D ; Compare accumulator $4D.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $30, $F0		; 30 F0 ; Branch if minus to $30, $F0 [Flow: branch]
	sbc $C03D4B.l,X		; FF 4B 3D C0 ; Subtract with carry (long,X) $C03D4B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $C0F1.w		; 2C F1 C0 ; Test bits $C0F1.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	sbc $1F00.w,X		; FD 00 1F ; Subtract with carry $1F00.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	ora ($C0.b,S),Y		; 13 C0 ; OR accumulator (stack relative indirect indexed) ($C0.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $10, $49		; 10 49 ; Branch if plus to $10, $49 [Flow: branch]
	jsr $020D.w		; 20 0D 02 ; Jump to subroutine at $020D.w [Writes: Stack Pointer] [Flow: call]
	.db $D0, $1D		; D0 1D ; Branch if not equal to $D0, $1D [Flow: branch]
	sbc $F6B0.w,X		; FD B0 F6 ; Subtract with carry $F6B0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($2AF3.w,X)		; FC F3 2A ; Jump to subroutine indirect indexed ($2AF3.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $42, $A7		; 42 A7 ; Reserved instruction
	cmp $D3.b,X		; D5 D3 ; Compare accumulator $D3.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $B0, $EF		; B0 EF ; Branch if carry set to $B0, $EF [Flow: branch]
	cmp $2C0532.l,X		; DF 32 05 2C ; Compare accumulator (long,X) $2C0532.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	stz $14.b		; 64 14 ; Store zero to $14.b
	ora $E300C4.l		; 0F C4 00 E3 ; OR accumulator with memory (long) $E300C4.l [Writes: Accumulator] [Flags: NZ]
	cmp ($D2.b),Y		; D1 D2 ; Compare accumulator ($D2.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	cpy #$12.b		; C0 12 ; Compare #$12.b with Y register [Reads: Y Index] [Flags: NCZ]
	ora $F0.b,S		; 03 F0 ; OR accumulator with stack relative $F0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp ($CF.b),Y		; D1 CF ; Compare accumulator ($CF.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cpx #$0E.b		; E0 0E ; Compare #$0E.b with X register [Reads: X Index] [Flags: NCZ]
	ora ($B0.b),Y		; 11 B0 ; OR accumulator with memory ($B0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $F5.b,S		; E3 F5 ; Subtract stack-relative $F5.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	ora ($E0.b,S),Y		; 13 E0 ; OR accumulator (stack relative indirect indexed) ($E0.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $A32F.w,X		; 1D 2F A3 ; OR accumulator with memory $A32F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($B0.b,X)		; 01 B0 ; Logical OR ($B0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $4E.b,X		; 34 4E ; Test bits $4E.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $F0E3.w,X		; 3C E3 F0 ; Test bits $F0E3.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	ora $C50F.w,X		; 1D 0F C5 ; OR accumulator with memory $C50F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $B0		; B0 B0 ; Branch if carry set to $B0, $B0 [Flow: branch]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	tsb $D500.w		; 0C 00 D5 ; Test and set bits $D500.w [Reads: Accumulator] [Flags: Z]
	sbc $33B05F.l,X		; FF 5F B0 33 ; Subtract with carry (long,X) $33B05F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $DD.b		; 24 DD ; Test bits $DD.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	cmp $EEBE.w,X		; DD BE EE ; Compare accumulator $EEBE.w,X [Reads: X Index] [Flags: NCZ]
	.db $B0, $32		; B0 32 ; Branch if carry set to $B0, $32 [Flow: branch]
	adc $0DC243.l		; 6F 43 C2 0D ; Add with carry (long) $0DC243.l [Writes: Accumulator] [Flags: NCVZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sbc ($C0.b,X)		; E1 C0 ; Subtract with carry ($C0.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $FF		; F0 FF ; Branch if equal to $F0, $FF [Flow: branch]
	.db $10, $30		; 10 30 ; Branch if plus to $10, $30 [Flow: branch]
	bit $E0.b		; 24 E0 ; Test bits $E0.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sbc ($EE.b),Y		; F1 EE ; Subtract with carry ($EE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $B0, $1D		; B0 1D ; Branch if carry set to $B0, $1D [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	cmp ($E3.b)		; D2 E3 ; Compare accumulator (indirect) ($E3.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sbc $01.b,X		; F5 01 ; Subtract $01.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $05.b		; 06 05 ; Arithmetic shift left $05.b [Reads: Direct Page] [Flags: NCZ]
	cpy #$E3.b		; C0 E3 ; Compare #$E3.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $F0, $10		; F0 10 ; Branch if equal to $F0, $10 [Flow: branch]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	cpx #$D1.b		; E0 D1 ; Compare #$D1.b with X register [Reads: X Index] [Flags: NCZ]
	sbc $2201C0.l,X		; FF C0 01 22 ; Subtract with carry (long,X) $2201C0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $31.b		; 00 31 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($2C.b),Y		; F1 2C ; Subtract with carry ($2C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $ED		; 10 ED ; Branch if plus to $10, $ED [Flow: branch]
	cpy #$0E.b		; C0 0E ; Compare #$0E.b with Y register [Reads: Y Index] [Flags: NCZ]
	ora $022000.l		; 0F 00 20 02 ; OR accumulator with memory (long) $022000.l [Writes: Accumulator] [Flags: NZ]
	sbc ($3F.b)		; F2 3F ; Subtract with carry (indirect) ($3F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cpy #$11.b		; C0 11 ; Compare #$11.b with Y register [Reads: Y Index] [Flags: NCZ]
	ora $C33F.w		; 0D 3F C3 ; Logical OR $C33F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $F120.w		; 0D 20 F1 ; Logical OR $F120.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $4EB0.w		; 0E B0 4E ; Arithmetic shift left $4EB0.w [Flags: NCZ]
	and ($6E.b,X)		; 21 6E ; Logical AND ($6E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	cpx #$C1.b		; E0 C1 ; Compare #$C1.b with X register [Reads: X Index] [Flags: NCZ]
	sbc $B0.b		; E5 B0 ; Subtract $B0.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	rep #$C1		; C2 C1 ; Reset processor status bits #$C1 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	rol $1C23.w,X		; 3E 23 1C ; Rotate left $1C23.w,X [Reads: X Index] [Flags: NCZ]
	eor ($B1.b)		; 52 B1 ; Exclusive OR accumulator with memory (indirect) ($B1.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $FECFC0.l,X		; FF C0 CF FE ; Subtract with carry (long,X) $FECFC0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $D4		; F0 D4 ; Branch if equal to $F0, $D4 [Flow: branch]
	ora $20E042.l,X		; 1F 42 E0 20 ; Logical OR long $20E042.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$03.b		; C0 03 ; Compare #$03.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $F0, $0E		; F0 0E ; Branch if equal to $F0, $0E [Flow: branch]
	ora $0EC0C1.l		; 0F C1 C0 0E ; OR accumulator with memory (long) $0EC0C1.l [Writes: Accumulator] [Flags: NZ]
	sbc $242CB0.l,X		; FF B0 2C 24 ; Subtract with carry (long,X) $242CB0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $E5.b		; E5 E5 ; Subtract $E5.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $50, $34		; 50 34 ; Branch if overflow clear to $50, $34 [Flow: branch]
	and $D2B4E0.l		; 2F E0 B4 D2 ; AND accumulator with memory (long) $D2B4E0.l [Writes: Accumulator] [Flags: NZ]
	jsr ($314D.w,X)		; FC 4D 31 ; Jump to subroutine indirect indexed ($314D.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	tsb $10.b		; 04 10 ; Test and set bits $10.b [Reads: Accumulator] [Flags: Z]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	.db $B0, $E5		; B0 E5 ; Branch if carry set to $B0, $E5 [Flow: branch]
	dec $D131.w,X		; DE 31 D1 ; Decrement memory $D131.w,X [Reads: X Index] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	jsl $32C00E.l		; 22 0E C0 32 ; Jump to subroutine long $32C00E.l [Writes: Stack Pointer] [Flow: call]
	.db $10, $0E		; 10 0E ; Branch if plus to $10, $0E [Flow: branch]
	ora $1D0F.w,X		; 1D 0F 1D ; OR accumulator with memory $1D0F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $B0, $40		; B0 40 ; Branch if carry set to $B0, $40 [Flow: branch]
	and ($15.b),Y		; 31 15 ; AND accumulator with memory ($15.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $13, $FB		; 62 13 FB ; Push effective relative address $62, $13, $FB [Writes: Stack Pointer]
	inc $B0F1.w,X		; FE F1 B0 ; Increment memory $B0F1.w,X [Reads: X Index] [Flags: NZ]
	dec $F32B.w		; CE 2B F3 ; Decrement $F32B.w [Flags: NZ]
	sbc ($F3.b)		; F2 F3 ; Subtract with carry (indirect) ($F3.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	dec $DF.b,X		; D6 DF ; Decrement memory $DF.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	cop $C0.b		; 02 C0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($D2.b),Y		; D1 D2 ; Compare accumulator ($D2.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	ora ($22.b),Y		; 11 22 ; OR accumulator with memory ($22.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	dec $B0FE.w,X		; DE FE B0 ; Decrement memory $B0FE.w,X [Reads: X Index] [Flags: NZ]
	jsl $B404C2.l		; 22 C2 04 B4 ; Jump to subroutine long $B404C2.l [Writes: Stack Pointer] [Flow: call]
	sbc $C730.w,X		; FD 30 C7 ; Subtract with carry $C730.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $90, $B0		; 90 B0 ; Branch if carry clear to $90, $B0 [Flow: branch]
	cop $B1.b		; 02 B1 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $02		; 30 02 ; Branch if minus to $30, $02 [Flow: branch]
	ora ($1E.b)		; 12 1E ; OR accumulator with memory (indirect) ($1E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jmp $FEB0D2.l		; 5C D2 B0 FE ; Jump long to $FEB0D2.l [Flow: jump]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

.ACCU 8
	sep #$2D		; E2 2D
	ora $30EAD2.l,X		; 1F D2 EA 30 ; Logical OR long $30EAD2.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$E1.b		; C0 E1 ; Compare #$E1.b with Y register [Reads: Y Index] [Flags: NCZ]
	rol $343F.w		; 2E 3F 34 ; Rotate left $343F.w [Flags: NCZ]
	rol $B011.w,X		; 3E 11 B0 ; Rotate left $B011.w,X [Reads: X Index] [Flags: NCZ]
	trb $00C0.w		; 1C C0 00 ; Test and reset bits $00C0.w [Reads: Accumulator] [Flags: Z]
	brk $2E.b		; 00 2E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $F2.b,X		; 35 F2 ; Logical AND $F2.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $10		; 30 10 ; Branch if minus to $30, $10 [Flow: branch]
	ora $A1DDB0.l		; 0F B0 DD A1 ; OR accumulator with memory (long) $A1DDB0.l [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	.db $62, $06, $1F		; 62 06 1F ; Push effective relative address $62, $06, $1F [Writes: Stack Pointer]
	ror $B00B.w		; 6E 0B B0 ; Rotate right $B00B.w [Flags: NCZ]
	and ($C1.b,X)		; 21 C1 ; Logical AND ($C1.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $1342C2.l		; 0F C2 42 13 ; OR accumulator with memory (long) $1342C2.l [Writes: Accumulator] [Flags: NZ]
	sbc $00B00D.l,X		; FF 0D B0 00 ; Subtract with carry (long,X) $00B00D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $2F042E.l,X		; FF 2E 04 2F ; Subtract with carry (long,X) $2F042E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $012F.w		; 4D 2F 01 ; Exclusive OR $012F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: NCZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $FFE3.w		; 20 E3 FF ; Jump to subroutine at $FFE3.w [Writes: Stack Pointer] [Flow: call]
	ora ($E3.b)		; 12 E3 ; OR accumulator with memory (indirect) ($E3.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $D1		; B0 D1 ; Branch if carry set to $B0, $D1 [Flow: branch]
	ora ($D3.b,X)		; 01 D3 ; Logical OR ($D3.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $B030.w,X		; 1E 30 B0 ; Arithmetic shift left $B030.w,X [Reads: X Index] [Flags: NCZ]
	asl $C016.w		; 0E 16 C0 ; Arithmetic shift left $C016.w [Flags: NCZ]
	cpx #$FF.b		; E0 FF ; Compare #$FF.b with X register [Reads: X Index] [Flags: NCZ]
	.db $42, $F2		; 42 F2 ; Reserved instruction
	asl $0012.w		; 0E 12 00 ; Arithmetic shift left $0012.w [Flags: NCZ]
	lda ($B0.b)		; B2 B0 ; Load accumulator (indirect) ($B0.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $EDDD.w,X		; BD DD ED ; Load $EDDD.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dec $E3.b,X		; D6 E3 ; Decrement memory $E3.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	trb $3E.b		; 14 3E ; Test and reset bits $3E.b [Reads: Accumulator] [Flags: Z]
	and $C0.b,S		; 23 C0 ; AND accumulator with stack relative $C0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr $EDD2.w		; 20 D2 ED ; Jump to subroutine at $EDD2.w [Writes: Stack Pointer] [Flow: call]
	rol $03E0.w		; 2E E0 03 ; Rotate left $03E0.w [Flags: NCZ]
	pea $B003.w		; F4 03 B0 ; Push absolute address $B003.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	and $BDAFC5.l,X		; 3F C5 AF BD ; AND accumulator with memory (long,X) $BDAFC5.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$2F.b		; 09 2F ; Logical OR #$2F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $15C0.w		; 20 C0 15 ; Jump to subroutine at $15C0.w [Writes: Stack Pointer] [Flow: call]
	cop $33.b		; 02 33 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	inc $E001.w		; EE 01 E0 ; Increment $E001.w [Flags: NZ]
	.db $B0, $B1		; B0 B1 ; Branch if carry set to $B0, $B1 [Flow: branch]
	sbc ($03.b),Y		; F1 03 ; Subtract with carry ($03.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $D0, $0D		; D0 0D ; Branch if not equal to $D0, $0D [Flow: branch]
	.db $10, $B4		; 10 B4 ; Branch if plus to $10, $B4 [Flow: branch]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $15		; B0 15 ; Branch if carry set to $B0, $15 [Flow: branch]
	and $14.b		; 25 14 ; Logical AND $14.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($1F.b)		; 12 1F ; OR accumulator with memory (indirect) ($1F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $BDB4.w,X		; FD B4 BD ; Subtract with carry $BDB4.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $B0, $C3		; B0 C3 ; Branch if carry set to $B0, $C3 [Flow: branch]
	and ($FA.b,X)		; 21 FA ; Logical AND ($FA.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $4F1CB1.l,X		; 3F B1 1C 4F ; AND accumulator with memory (long,X) $4F1CB1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $50, $B4		; 50 B4 ; Branch if overflow clear to $50, $B4 [Flow: branch]
	and $EE025A.l,X		; 3F 5A 02 EE ; AND accumulator with memory (long,X) $EE025A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $3BFF.w,X		; 5D FF 3B ; Exclusive OR accumulator with memory $3BFF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldy $5E.b,X		; B4 5E ; Load Y register $5E.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	eor $C411.w		; 4D 11 C4 ; Exclusive OR $C411.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cpx #$5D.b		; E0 5D ; Compare #$5D.b with X register [Reads: X Index] [Flags: NCZ]
	.db $30, $C3		; 30 C3 ; Branch if minus to $30, $C3 [Flow: branch]
	cpy #$3F.b		; C0 3F ; Compare #$3F.b with Y register [Reads: Y Index] [Flags: NCZ]
	cpx $DF.b		; E4 DF ; Compare $DF.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc $FFE0D1.l		; EF D1 E0 FF ; Subtract with carry (long) $FFE0D1.l [Writes: Accumulator] [Flags: NCVZ]
	cmp $C0.b,S		; C3 C0 ; Compare accumulator (stack relative) $C0.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	sbc ($23.b),Y		; F1 23 ; Subtract with carry ($23.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	pea $11F1.w		; F4 F1 11 ; Push absolute address $11F1.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sbc ($F0.b),Y		; F1 F0 ; Subtract with carry ($F0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($C0.b),Y		; F1 C0 ; Subtract with carry ($C0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($D2.b),Y		; F1 D2 ; Subtract with carry ($D2.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($11.b)		; F2 11 ; Subtract with carry (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($C1.b),Y		; F1 C1 ; Subtract with carry ($C1.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$FD.b		; C0 FD ; Compare #$FD.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $10, $D1		; 10 D1 ; Branch if plus to $10, $D1 [Flow: branch]
	ora $110200.l,X		; 1F 00 02 11 ; Logical OR long $110200.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $C0.b,S		; 03 C0 ; OR accumulator with stack relative $C0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $11.b		; 02 11 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$1D.b		; E0 1D ; Compare #$1D.b with X register [Reads: X Index] [Flags: NCZ]
	ora $3EECCF.l		; 0F CF EC 3E ; OR accumulator with memory (long) $3EECCF.l [Writes: Accumulator] [Flags: NZ]
	cpy #$01.b		; C0 01 ; Compare #$01.b with Y register [Reads: Y Index] [Flags: NCZ]
	cop $15.b		; 02 15 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pea $202E.w		; F4 2E 20 ; Push absolute address $202E.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sbc ($FD.b)		; F2 FD ; Subtract with carry (indirect) ($FD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $B0, $6F		; B0 6F ; Branch if carry set to $B0, $6F [Flow: branch]
	cmp $F34D.w		; CD 4D F3 ; Compare $F34D.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	sty $FC.b,X		; 94 FC ; Store Y register $FC.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	ora ($BE.b)		; 12 BE ; OR accumulator with memory (indirect) ($BE.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpy #$20.b		; C0 20 ; Compare #$20.b with Y register [Reads: Y Index] [Flags: NCZ]
	rep #$02		; C2 02 ; Reset processor status bits #$02 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	lsr $DF43.w,X		; 5E 43 DF ; Logical shift right $DF43.w,X [Reads: X Index] [Flags: NCZ]
	and $FEC0D0.l,X		; 3F D0 C0 FE ; AND accumulator with memory (long,X) $FEC0D0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsr $1004.w		; 20 04 10 ; Jump to subroutine at $1004.w [Writes: Stack Pointer] [Flow: call]
	and $2DDCE2.l,X		; 3F E2 DC 2D ; AND accumulator with memory (long,X) $2DDCE2.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$C3.b		; C0 C3 ; Compare #$C3.b with Y register [Reads: Y Index] [Flags: NCZ]
	sbc ($3F.b),Y		; F1 3F ; Subtract with carry ($3F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($F0.b,S),Y		; 33 F0 ; AND accumulator (stack relative indirect indexed) ($F0.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($C2.b,X)		; 21 C2 ; Logical AND ($C2.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $F000B0.l		; 0F B0 00 F0 ; OR accumulator with memory (long) $F000B0.l [Writes: Accumulator] [Flags: NZ]
	ora ($D5.b,X)		; 01 D5 ; Logical OR ($D5.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpy #$3F.b		; C0 3F ; Compare #$3F.b with Y register [Reads: Y Index] [Flags: NCZ]
	cpx #$1C.b		; E0 1C ; Compare #$1C.b with X register [Reads: X Index] [Flags: NCZ]
	.db $B0, $20		; B0 20 ; Branch if carry set to $B0, $20 [Flow: branch]
	cmp $2F.b,X		; D5 2F ; Compare accumulator $2F.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	eor ($F6.b),Y		; 51 F6 ; Exclusive OR accumulator with memory ($F6.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ldy $FD.b,X		; B4 FD ; Load Y register $FD.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	cpx #$B0.b		; E0 B0 ; Compare #$B0.b with X register [Reads: X Index] [Flags: NCZ]
	asl $E2E3.w,X		; 1E E3 E2 ; Arithmetic shift left $E2E3.w,X [Reads: X Index] [Flags: NCZ]
	ora $0F1D.w,X		; 1D 1D 0F ; OR accumulator with memory $0F1D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $0EC0D3.l		; EF D3 C0 0E ; Subtract with carry (long) $0EC0D3.l [Writes: Accumulator] [Flags: NCVZ]
	ora $1F002F.l		; 0F 2F 00 1F ; OR accumulator with memory (long) $1F002F.l [Writes: Accumulator] [Flags: NZ]
	jsl $B0301C.l		; 22 1C 30 B0 ; Jump to subroutine long $B0301C.l [Writes: Stack Pointer] [Flow: call]
.ACCU 16
	rep #$E1		; C2 E1
	asl $0D22.w		; 0E 22 0D ; Arithmetic shift left $0D22.w [Flags: NCZ]
	eor $B00DAF.l		; 4F AF 0D B0 ; Exclusive OR accumulator with memory (long) $B00DAF.l [Writes: Accumulator] [Flags: NZ]
	cmp $33F1F0.l		; CF F0 F1 33 ; Compare accumulator (long) $33F1F0.l [Reads: Accumulator] [Flags: NCZ]
	ora $3F.b		; 05 3F ; Logical OR $3F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $3C.b		; 02 3C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $B0, $10		; B0 10 ; Branch if carry set to $B0, $10 [Flow: branch]
	cmp ($2D.b),Y		; D1 2D ; Compare accumulator ($2D.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	eor $3CCFF5.l		; 4F F5 CF 3C ; Exclusive OR accumulator with memory (long) $3CCFF5.l [Writes: Accumulator] [Flags: NZ]
	tsb $BFB0.w		; 0C B0 BF ; Test and set bits $BFB0.w [Reads: Accumulator] [Flags: Z]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $42, $C3		; 42 C3 ; Reserved instruction
	and ($12.b)		; 32 12 ; AND accumulator with memory (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($00.b)		; 32 00 ; AND accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpy #$F2.b		; C0 F2 ; Compare #$F2.b with Y register [Reads: Y Index] [Flags: NCZ]
	inc $FE2C.w,X		; FE 2C FE ; Increment memory $FE2C.w,X [Reads: X Index] [Flags: NZ]
	ora $0F200F.l,X		; 1F 0F 20 0F ; Logical OR long $0F200F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $6E		; B0 6E ; Branch if carry set to $B0, $6E [Flow: branch]
	cmp ($2B.b,S),Y		; D3 2B ; Compare accumulator (stack relative indirect indexed) ($2B.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	eor ($21.b),Y		; 51 21 ; Exclusive OR accumulator with memory ($21.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $B0D55D.l		; 2F 5D D5 B0 ; AND accumulator with memory (long) $B0D55D.l [Writes: Accumulator] [Flags: NZ]
	cpx #$4F.b		; E0 4F ; Compare #$4F.b with X register [Reads: X Index] [Flags: NCZ]
	sbc ($E0.b),Y		; F1 E0 ; Subtract with carry ($E0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $0BD0.w		; 2C D0 0B ; Test bits $0BD0.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	jsr $E3B0.w		; 20 B0 E3 ; Jump to subroutine at $E3B0.w [Writes: Stack Pointer] [Flow: call]
	sbc $245D.w,X		; FD 5D 24 ; Subtract with carry $245D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $D0403E.l,X		; DF 3E 40 D0 ; Compare accumulator (long,X) $D0403E.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	.db $B0, $20		; B0 20 ; Branch if carry set to $B0, $20 [Flow: branch]
	ora ($2F.b)		; 12 2F ; OR accumulator with memory (indirect) ($2F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp ($BD.b),Y		; D1 BD ; Compare accumulator ($BD.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	ora $EFC2.w		; 0D C2 EF ; Logical OR $EFC2.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $B0, $33		; B0 33 ; Branch if carry set to $B0, $33 [Flow: branch]
	jsl $422E03.l		; 22 03 2E 42 ; Jump to subroutine long $422E03.l [Writes: Stack Pointer] [Flow: call]
	sbc $B0001B.l		; EF 1B 00 B0 ; Subtract with carry (long) $B0001B.l [Writes: Accumulator] [Flags: NCVZ]
	cmp $1A.b,S		; C3 1A ; Compare accumulator (stack relative) $1A.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	eor $ECFDFF.l		; 4F FF FD EC ; Exclusive OR accumulator with memory (long) $ECFDFF.l [Writes: Accumulator] [Flags: NZ]
	asl $B012.w		; 0E 12 B0 ; Arithmetic shift left $B012.w [Flags: NCZ]
	sbc ($01.b)		; F2 01 ; Subtract with carry (indirect) ($01.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($F3.b),Y		; 11 F3 ; OR accumulator with memory ($F3.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	inc $B510.w,X		; FE 10 B5 ; Increment memory $B510.w,X [Reads: X Index] [Flags: NZ]
	ora $01B0.w		; 0D B0 01 ; Logical OR $01B0.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc ($1F.b,X)		; E1 1F ; Subtract with carry ($1F.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $DF		; 10 DF ; Branch if plus to $10, $DF [Flow: branch]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	jsl $0DB0D1.l		; 22 D1 B0 0D ; Jump to subroutine long $0DB0D1.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $F1		; 30 F1 ; Branch if minus to $30, $F1 [Flow: branch]
	rol $C312.w		; 2E 12 C3 ; Rotate left $C312.w [Flags: NCZ]
	cpx #$0F.b		; E0 0F ; Compare #$0F.b with X register [Reads: X Index] [Flags: NCZ]
	.db $B0, $B3		; B0 B3 ; Branch if carry set to $B0, $B3 [Flow: branch]
	and $FD12.w		; 2D 12 FD ; Logical AND $FD12.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc ($FF.b,S),Y		; F3 FF ; Subtract with carry (stack relative indirect indexed) ($FF.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	jsr $B012.w		; 20 12 B0 ; Jump to subroutine at $B012.w [Writes: Stack Pointer] [Flow: call]
	cmp ($3B.b,S),Y		; D3 3B ; Compare accumulator (stack relative indirect indexed) ($3B.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	eor ($EE.b,X)		; 41 EE ; Exclusive OR accumulator with memory ($EE.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $3DB0.w		; 0E B0 3D ; Arithmetic shift left $3DB0.w [Flags: NCZ]
	and $0AF011.l		; 2F 11 F0 0A ; AND accumulator with memory (long) $0AF011.l [Writes: Accumulator] [Flags: NZ]
	rol $000F.w		; 2E 0F 00 ; Rotate left $000F.w [Flags: NCZ]
	.db $B0, $4E		; B0 4E ; Branch if carry set to $B0, $4E [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	ror $F0A2.w		; 6E A2 F0 ; Rotate right $F0A2.w [Flags: NCZ]
	eor $B02F.w,Y		; 59 2F B0 ; Exclusive OR accumulator with memory $B02F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tsb $E33F.w		; 0C 3F E3 ; Test and set bits $E33F.w [Reads: Accumulator] [Flags: Z]
	.db $30, $3C		; 30 3C ; Branch if minus to $30, $3C [Flow: branch]
	and $EE.b,S		; 23 EE ; AND accumulator with stack relative $EE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $B0		; F0 B0 ; Branch if equal to $F0, $B0 [Flow: branch]
	cmp $13E540.l		; CF 40 E5 13 ; Compare accumulator (long) $13E540.l [Reads: Accumulator] [Flags: NCZ]
	cmp ($21.b)		; D2 21 ; Compare accumulator (indirect) ($21.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy #$B3.b		; A0 B3 ; Load #$B3.b into Y register [Writes: Y Index] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cmp ($F9.b,S),Y		; D3 F9 ; Compare accumulator (stack relative indirect indexed) ($F9.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	adc $E3.b,X		; 75 E3 ; Add $E3.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy $FB.b		; C4 FB ; Compare $FB.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	.db $B0, $41		; B0 41 ; Branch if carry set to $B0, $41 [Flow: branch]
.INDEX 8
	sep #$D3		; E2 D3
.ACCU 16
	rep #$E4		; C2 E4
	.db $D0, $E0		; D0 E0 ; Branch if not equal to $D0, $E0 [Flow: branch]
	ora ($A0.b)		; 12 A0 ; OR accumulator with memory (indirect) ($A0.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	stx $D2.b,Y		; 96 D2 ; Store X register $D2.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	eor $11FE.w		; 4D FE 11 ; Exclusive OR $11FE.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and ($F0.b,X)		; 21 F0 ; Logical AND ($F0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	.db $B0, $0D		; B0 0D ; Branch if carry set to $B0, $0D [Flow: branch]
	eor $2DDFF2.l		; 4F F2 DF 2D ; Exclusive OR accumulator with memory (long) $2DDFF2.l [Writes: Accumulator] [Flags: NZ]
	and $B01100.l,X		; 3F 00 11 B0 ; AND accumulator with memory (long,X) $B01100.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($E3.b),Y		; 11 E3 ; OR accumulator with memory ($E3.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $E22D.w		; 1C 2D E2 ; Test and reset bits $E22D.w [Reads: Accumulator] [Flags: Z]
	dec $013D.w,X		; DE 3D 01 ; Decrement memory $013D.w,X [Reads: X Index] [Flags: NZ]
	cpy #$10.b		; C0 10 ; Compare #$10.b with Y register [Reads: Y Index] [Flags: NCZ]
	and ($10.b,X)		; 21 10 ; Logical AND ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $E0004F.l		; 2F 4F 00 E0 ; AND accumulator with memory (long) $E0004F.l [Writes: Accumulator] [Flags: NZ]
	sbc $EE1FB0.l,X		; FF B0 1F EE ; Subtract with carry (long,X) $EE1FB0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($E4.b),Y		; 31 E4 ; AND accumulator with memory ($E4.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cop $F0.b		; 02 F0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $C3		; 10 C3 ; Branch if plus to $10, $C3 [Flow: branch]
	ldy $B4.b,X		; B4 B4 ; Load Y register $B4.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	lda ($5B.b),Y		; B1 5B ; Load accumulator ($5B.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $E4		; 30 E4 ; Branch if minus to $30, $E4 [Flow: branch]
	cpy $A7.b		; C4 A7 ; Compare $A7.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	cpy #$B0.b		; C0 B0 ; Compare #$B0.b with Y register [Reads: Y Index] [Flags: NCZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	and $F0C0C1.l		; 2F C1 C0 F0 ; AND accumulator with memory (long) $F0C0C1.l [Writes: Accumulator] [Flags: NZ]
	and ($F3.b),Y		; 31 F3 ; AND accumulator with memory ($F3.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $B0.b		; 14 B0 ; Test and reset bits $B0.b [Reads: Accumulator] [Flags: Z]
	.db $D0, $FF		; D0 FF ; Branch if not equal to $D0, $FF [Flow: branch]
	dec $D54F.w,X		; DE 4F D5 ; Decrement memory $D54F.w,X [Reads: X Index] [Flags: NZ]
	pei ($1D.b)		; D4 1D ; Push effective indirect address ($1D.b) [Reads: Direct Page] [Writes: Stack Pointer]
	adc $C0.b,S		; 63 C0 ; Add with carry (stack relative) $C0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc $D0C101.l,X		; FF 01 C1 D0 ; Subtract with carry (long,X) $D0C101.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $0220.w		; 0E 20 02 ; Arithmetic shift left $0220.w [Flags: NCZ]
	and ($A0.b,X)		; 21 A0 ; Logical AND ($A0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ldy $1E.b		; A4 1E ; Load $1E.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	jmp $90F40E.l		; 5C 0E F4 90 ; Jump long to $90F40E.l [Flow: jump]
	.db $F0, $4B		; F0 4B ; Branch if equal to $F0, $4B [Flow: branch]
	.db $B0, $11		; B0 11 ; Branch if carry set to $B0, $11 [Flow: branch]
	cmp ($C2.b)		; D2 C2 ; Compare accumulator (indirect) ($C2.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	inc $0F21.w		; EE 21 0F ; Increment $0F21.w [Flags: NZ]
	asl $D0.b		; 06 D0 ; Arithmetic shift left $D0.b [Reads: Direct Page] [Flags: NCZ]
	.db $B0, $0F		; B0 0F ; Branch if carry set to $B0, $0F [Flow: branch]
	asl $EE20.w,X		; 1E 20 EE ; Arithmetic shift left $EE20.w,X [Reads: X Index] [Flags: NCZ]
	sbc ($C1.b,S),Y		; F3 C1 ; Subtract with carry (stack relative indirect indexed) ($C1.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora ($F0.b,X)		; 01 F0 ; Logical OR ($F0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $B0, $E2		; B0 E2 ; Branch if carry set to $B0, $E2 [Flow: branch]
	pea $001F.w		; F4 1F 00 ; Push absolute address $001F.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	cop $E3.b		; 02 E3 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $F0B001.l,X		; 1F 01 B0 F0 ; Logical OR long $F0B001.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$CE.b		; E0 CE ; Compare #$CE.b with X register [Reads: X Index] [Flags: NCZ]
	lda ($DF.b)		; B2 DF ; Load accumulator (indirect) ($DF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($21.b),Y		; 11 21 ; OR accumulator with memory ($21.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $B0.b,S		; 03 B0 ; OR accumulator with stack relative $B0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $02		; F0 02 ; Branch if equal to $F0, $02 [Flow: branch]
	sbc ($1E.b,X)		; E1 1E ; Subtract with carry ($1E.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $C3		; F0 C3 ; Branch if equal to $F0, $C3 [Flow: branch]
	and $B012.w,X		; 3D 12 B0 ; AND accumulator with memory $B012.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($01.b)		; F2 01 ; Subtract with carry (indirect) ($01.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($1F.b,X)		; E1 1F ; Subtract with carry ($1F.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $F101.w,X		; 5D 01 F1 ; Exclusive OR accumulator with memory $F101.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $A0		; F0 A0 ; Branch if equal to $F0, $A0 [Flow: branch]
	eor ($CF.b),Y		; 51 CF ; Exclusive OR accumulator with memory ($CF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	and ($10.b)		; 32 10 ; AND accumulator with memory (indirect) ($10.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $40		; 10 40 ; Branch if plus to $10, $40 [Flow: branch]
	.db $F0, $B0		; F0 B0 ; Branch if equal to $F0, $B0 [Flow: branch]
	ora ($00.b,S),Y		; 13 00 ; OR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $E2101C.l		; 2F 1C 10 E2 ; AND accumulator with memory (long) $E2101C.l [Writes: Accumulator] [Flags: NZ]
	.db $F0, $F2		; F0 F2 ; Branch if equal to $F0, $F2 [Flow: branch]
	.db $B0, $F0		; B0 F0 ; Branch if carry set to $B0, $F0 [Flow: branch]
	.db $30, $F5		; 30 F5 ; Branch if minus to $30, $F5 [Flow: branch]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	ora $1EF1.w		; 0D F1 1E ; Logical OR $1EF1.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $B0, $DE		; B0 DE ; Branch if carry set to $B0, $DE [Flow: branch]
	ora $F701E0.l		; 0F E0 01 F7 ; OR accumulator with memory (long) $F701E0.l [Writes: Accumulator] [Flags: NZ]
	ora ($33.b),Y		; 11 33 ; OR accumulator with memory ($33.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $01B0.w,X		; 1E B0 01 ; Arithmetic shift left $01B0.w,X [Reads: X Index] [Flags: NCZ]
	dec $00CF.w,X		; DE CF 00 ; Decrement memory $00CF.w,X [Reads: X Index] [Flags: NZ]
	sbc ($0F.b),Y		; F1 0F ; Subtract with carry ($0F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($02.b),Y		; 51 02 ; Exclusive OR accumulator with memory ($02.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $10		; B0 10 ; Branch if carry set to $B0, $10 [Flow: branch]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $C101.w,X		; 1E 01 C1 ; Arithmetic shift left $C101.w,X [Reads: X Index] [Flags: NCZ]
	ora $B00E.w,X		; 1D 0E B0 ; OR accumulator with memory $B00E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $F2.b,S		; E3 F2 ; Subtract stack-relative $F2.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	jsl $323004.l		; 22 04 30 32 ; Jump to subroutine long $323004.l [Writes: Stack Pointer] [Flow: call]
	pea $B4E1.w		; F4 E1 B4 ; Push absolute address $B4E1.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sbc $4F2CD2.l,X		; FF D2 2C 4F ; Subtract with carry (long,X) $4F2CD2.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $E1.b,S		; E3 E1 ; Subtract stack-relative $E1.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	ora ($04.b),Y		; 11 04 ; OR accumulator with memory ($04.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $41		; B0 41 ; Branch if carry set to $B0, $41 [Flow: branch]
	ora ($F2.b,S),Y		; 13 F2 ; OR accumulator (stack relative indirect indexed) ($F2.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $ECD0F0.l		; 2F F0 D0 EC ; AND accumulator with memory (long) $ECD0F0.l [Writes: Accumulator] [Flags: NZ]
	cpx #$A0.b		; E0 A0 ; Compare #$A0.b with X register [Reads: X Index] [Flags: NCZ]
	sbc $405A.w,X		; FD 5A 40 ; Subtract with carry $405A.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $BE.b,S		; E3 BE ; Subtract stack-relative $BE.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	sbc ($DF.b,X)		; E1 DF ; Subtract with carry ($DF.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($A0.b,X)		; 21 A0 ; Logical AND ($A0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($14.b),Y		; 11 14 ; OR accumulator with memory ($14.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cop $31.b		; 02 31 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $2E3E4F.l,X		; DF 4F 3E 2E ; Compare accumulator (long,X) $2E3E4F.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	ldy #$DE.b		; A0 DE ; Load #$DE.b into Y register [Writes: Y Index] [Flags: NZ]
	ora $0CCD.w		; 0D CD 0C ; Logical OR $0CCD.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $E3403F.l,X		; FF 3F 40 E3 ; Subtract with carry (long,X) $E3403F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy #$F1.b		; A0 F1 ; Load #$F1.b into Y register [Writes: Y Index] [Flags: NZ]
	eor $11FFF4.l,X		; 5F F4 FF 11 ; Exclusive OR accumulator with memory (long,X) $11FFF4.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $A4ED1F.l,X		; DF 1F ED A4 ; Compare accumulator (long,X) $A4ED1F.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	sbc ($E2.b,S),Y		; F3 E2 ; Subtract with carry (stack relative indirect indexed) ($E2.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	asl $1001.w,X		; 1E 01 10 ; Arithmetic shift left $1001.w,X [Reads: X Index] [Flags: NCZ]
	sbc ($11.b),Y		; F1 11 ; Subtract with carry ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp ($A0.b,X)		; C1 A0 ; Compare accumulator ($A0.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	and $02F12F.l,X		; 3F 2F F1 02 ; AND accumulator with memory (long,X) $02F12F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $F2.b		; 00 F2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($B2.b,S),Y		; F3 B2 ; Subtract with carry (stack relative indirect indexed) ($B2.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ldy #$EB.b		; A0 EB ; Load #$EB.b into Y register [Writes: Y Index] [Flags: NZ]
	and $E21CCE.l		; 2F CE 1C E2 ; AND accumulator with memory (long) $E21CCE.l [Writes: Accumulator] [Flags: NZ]
	brk $2F.b		; 00 2F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($90.b,X)		; 01 90 ; Logical OR ($90.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $44.b,X		; 34 44 ; Test bits $44.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	adc ($F5.b,S),Y		; 73 F5 ; Add with carry (stack relative indirect indexed) ($F5.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cmp $5B.b,S		; C3 5B ; Compare accumulator (stack relative) $5B.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	cmp $A0DB.w,X		; DD DB A0 ; Compare accumulator $A0DB.w,X [Reads: X Index] [Flags: NCZ]
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $D0, $EF		; D0 EF ; Branch if not equal to $D0, $EF [Flow: branch]
	eor $314D12.l,X		; 5F 12 4D 31 ; Exclusive OR accumulator with memory (long,X) $314D12.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	brk $F1.b		; 00 F1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda ($3C.b),Y		; B1 3C ; Load accumulator ($3C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($DF.b)		; 12 DF ; OR accumulator with memory (indirect) ($DF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $FFFFA0.l		; 2F A0 FF FF ; AND accumulator with memory (long) $FFFFA0.l [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	mvn $3F,$00		; 54 00 3F ; Move block negative $3F,$00 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $E2.b		; 05 E2 ; Logical OR $E2.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy #$1D.b		; A0 1D ; Load #$1D.b into Y register [Writes: Y Index] [Flags: NZ]
	and $332DEF.l		; 2F EF 2D 33 ; AND accumulator with memory (long) $332DEF.l [Writes: Accumulator] [Flags: NZ]
	cmp ($F2.b)		; D2 F2 ; Compare accumulator (indirect) ($F2.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sbc $1ADFA0.l		; EF A0 DF 1A ; Subtract with carry (long) $1ADFA0.l [Writes: Accumulator] [Flags: NCVZ]
	ora ($0E.b,X)		; 01 0E ; Logical OR ($0E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and ($1C.b),Y		; 31 1C ; AND accumulator with memory ($1C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($2F.b,X)		; 21 2F ; Logical AND ($2F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ldy #$30.b		; A0 30 ; Load #$30.b into Y register [Writes: Y Index] [Flags: NZ]
	.db $10, $13		; 10 13 ; Branch if plus to $10, $13 [Flow: branch]
	.db $F0, $D0		; F0 D0 ; Branch if equal to $F0, $D0 [Flow: branch]
	sbc $A00C00.l		; EF 00 0C A0 ; Subtract with carry (long) $A00C00.l [Writes: Accumulator] [Flags: NCVZ]
	cpx #$D4.b		; E0 D4 ; Compare #$D4.b with X register [Reads: X Index] [Flags: NCZ]
	ora $522033.l		; 0F 33 20 52 ; OR accumulator with memory (long) $522033.l [Writes: Accumulator] [Flags: NZ]
	brk $2E.b		; 00 2E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $0B		; 90 0B ; Branch if carry clear to $90, $0B [Flow: branch]
	ldx $04CD.w,Y		; BE CD 04 ; Load X register $04CD.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	cmp $A421FC.l,X		; DF FC 21 A4 ; Compare accumulator (long,X) $A421FC.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	ldy #$DE.b		; A0 DE ; Load #$DE.b into Y register [Writes: Y Index] [Flags: NZ]
	and ($01.b,X)		; 21 01 ; Logical AND ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $F142.w,X		; 3D 42 F1 ; AND accumulator with memory $F142.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $3F90F0.l		; 22 F0 90 3F ; Jump to subroutine long $3F90F0.l [Writes: Stack Pointer] [Flow: call]
	sta ($FB.b,S),Y		; 93 FB ; Store accumulator (stack relative indirect indexed) ($FB.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	ora $45E02F.l,X		; 1F 2F E0 45 ; Logical OR long $45E02F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	ldy #$FD.b		; A0 FD ; Load #$FD.b into Y register [Writes: Y Index] [Flags: NZ]
	sbc $2100CF.l		; EF CF 00 21 ; Subtract with carry (long) $2100CF.l [Writes: Accumulator] [Flags: NCVZ]
	sbc $5F.b,X		; F5 5F ; Subtract $5F.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $90		; 30 90 ; Branch if minus to $30, $90 [Flow: branch]
	ora ($3F.b,X)		; 01 3F ; Logical OR ($3F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ldy $9BD0.w,X		; BC D0 9B ; Load Y register $9BD0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ora $A031F0.l		; 0F F0 31 A0 ; OR accumulator with memory (long) $A031F0.l [Writes: Accumulator] [Flags: NZ]
	sbc $451FFF.l,X		; FF FF 1F 45 ; Subtract with carry (long,X) $451FFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $21.b		; 00 21 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $3E		; 10 3E ; Branch if plus to $10, $3E [Flow: branch]
	.db $90, $DE		; 90 DE ; Branch if carry clear to $90, $DE [Flow: branch]
	cpy #$CB.b		; C0 CB ; Compare #$CB.b with Y register [Reads: Y Index] [Flags: NCZ]
	jsr ($E532.w,X)		; FC 32 E5 ; Jump to subroutine indirect indexed ($E532.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	tsb $E1.b		; 04 E1 ; Test and set bits $E1.b [Reads: Accumulator] [Flags: Z]
	ldy #$21.b		; A0 21 ; Load #$21.b into Y register [Writes: Y Index] [Flags: NZ]
	ora ($1B.b,X)		; 01 1B ; Logical OR ($1B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $0E00.w,X		; 1D 00 0E ; OR accumulator with memory $0E00.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($E2.b,X)		; 21 E2 ; Logical AND ($E2.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $90, $11		; 90 11 ; Branch if carry clear to $90, $11 [Flow: branch]
	.db $30, $32		; 30 32 ; Branch if minus to $30, $32 [Flow: branch]
	asl $BEE2.w		; 0E E2 BE ; Arithmetic shift left $BEE2.w [Flags: NCZ]
	sbc $90DF.w,X		; FD DF 90 ; Subtract with carry $90DF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$2F.b		; C0 2F ; Compare #$2F.b with Y register [Reads: Y Index] [Flags: NCZ]
	cmp ($0E.b)		; D2 0E ; Compare accumulator (indirect) ($0E.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sbc $21.b,X		; F5 21 ; Subtract $21.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	pei ($2F.b)		; D4 2F ; Push effective indirect address ($2F.b) [Reads: Direct Page] [Writes: Stack Pointer]
	ldy #$1F.b		; A0 1F ; Load #$1F.b into Y register [Writes: Y Index] [Flags: NZ]
	and $0001.w		; 2D 01 00 ; Logical AND $0001.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $B0, $FD		; B0 FD ; Branch if carry set to $B0, $FD [Flow: branch]
	and ($20.b,X)		; 21 20 ; Logical AND ($20.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $90, $16		; 90 16 ; Branch if carry clear to $90, $16 [Flow: branch]
	cpy #$EC.b		; C0 EC ; Compare #$EC.b with Y register [Reads: Y Index] [Flags: NCZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $FD		; F0 FD ; Branch if equal to $F0, $FD [Flow: branch]
	eor ($F3.b)		; 52 F3 ; Exclusive OR accumulator with memory (indirect) ($F3.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $90, $5D		; 90 5D ; Branch if carry clear to $90, $5D [Flow: branch]
	.db $10, $41		; 10 41 ; Branch if plus to $10, $41 [Flow: branch]
	rol $ED.b		; 26 ED ; Rotate left $ED.b [Reads: Direct Page] [Flags: NCZ]
	ora $D04B.w,Y		; 19 4B D0 ; OR accumulator with memory $D04B.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $90, $1E		; 90 1E ; Branch if carry clear to $90, $1E [Flow: branch]
	ora $5B112D.l		; 0F 2D 11 5B ; OR accumulator with memory (long) $5B112D.l [Writes: Accumulator] [Flags: NZ]
	cop $13.b		; 02 13 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $A0		; 10 A0 ; Branch if plus to $10, $A0 [Flow: branch]
	.db $30, $01		; 30 01 ; Branch if minus to $30, $01 [Flow: branch]
	ora $0DE001.l,X		; 1F 01 E0 0D ; Logical OR long $0DE001.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $1F		; 10 1F ; Branch if plus to $10, $1F [Flow: branch]
	.db $90, $5E		; 90 5E ; Branch if carry clear to $90, $5E [Flow: branch]
	and ($2F.b,X)		; 21 2F ; Logical AND ($2F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $11DE.w,X		; DD DE 11 ; Compare accumulator $11DE.w,X [Reads: X Index] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $90, $41		; 90 41 ; Branch if carry clear to $90, $41 [Flow: branch]
	eor ($10.b),Y		; 51 10 ; Exclusive OR accumulator with memory ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($0C.b)		; F2 0C ; Subtract with carry (indirect) ($0C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: NCZ]
	.db $90, $1D		; 90 1D ; Branch if carry clear to $90, $1D [Flow: branch]
	pea $232C.w		; F4 2C 23 ; Push absolute address $232C.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sbc $313D1F.l		; EF 1F 3D 31 ; Subtract with carry (long) $313D1F.l [Writes: Accumulator] [Flags: NCVZ]
	.db $90, $12		; 90 12 ; Branch if carry clear to $90, $12 [Flow: branch]
	tsb $EF.b		; 04 EF ; Test and set bits $EF.b [Reads: Accumulator] [Flags: Z]
	bit $1E1C.w		; 2C 1C 1E ; Test bits $1E1C.w with accumulator [Reads: Accumulator] [Flags: NVZ]
.ACCU 16
.INDEX 16
	rep #$F0		; C2 F0
	.db $90, $F2		; 90 F2 ; Branch if carry clear to $90, $F2 [Flow: branch]
	brk $2E.b		; 00 2E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $331AD2.l		; 0F D2 1A 33 ; OR accumulator with memory (long) $331AD2.l [Writes: Accumulator] [Flags: NZ]
	cmp $94.b,S		; C3 94 ; Compare accumulator (stack relative) $94.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	pei ($E3.b)		; D4 E3 ; Push effective indirect address ($E3.b) [Reads: Direct Page] [Writes: Stack Pointer]
	sbc ($1D.b),Y		; F1 1D ; Subtract with carry ($1D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($CE.b)		; F2 CE ; Subtract with carry (indirect) ($CE.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	rol $90ED.w,X		; 3E ED 90 ; Rotate left $90ED.w,X [Reads: X Index] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	bit $E2E0.w		; 2C E0 E2 ; Test bits $E2E0.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	jsl $120010.l		; 22 10 00 12 ; Jump to subroutine long $120010.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $10		; 90 10 ; Branch if carry clear to $90, $10 [Flow: branch]
	trb $E1.b		; 14 E1 ; Test and reset bits $E1.b [Reads: Accumulator] [Flags: Z]
	.db $42, $03		; 42 03 ; Reserved instruction
	cpx #$0D1C.w		; E0 1C 0D ; Compare #$0D1C.w with X register [Reads: X Index] [Flags: NCZ]
	.db $90, $BC		; 90 BC ; Branch if carry clear to $90, $BC [Flow: branch]
	sbc ($E0.b),Y		; F1 E0 ; Subtract with carry ($E0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $11.b		; E5 11 ; Subtract $11.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc $900F32.l,X		; 7F 32 0F 90 ; Add long $900F32.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $330BFF.l		; 0F FF 0B 33 ; OR accumulator with memory (long) $330BFF.l [Writes: Accumulator] [Flags: NZ]
	tsb $12.b		; 04 12 ; Test and set bits $12.b [Reads: Accumulator] [Flags: Z]
	.db $42, $FF		; 42 FF ; Reserved instruction
	.db $90, $DB		; 90 DB ; Branch if carry clear to $90, $DB [Flow: branch]
	lda $4FEED1.l		; AF D1 EE 4F ; Load long $4FEED1.l into accumulator [Writes: Accumulator] [Flags: NZ]
	and ($16.b,S),Y		; 33 16 ; AND accumulator (stack relative indirect indexed) ($16.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($90.b,X)		; 01 90 ; Logical OR ($90.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $2F1911.l,X		; 3F 11 19 2F ; AND accumulator with memory (long,X) $2F1911.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0D		; F0 0D ; Branch if equal to $F0, $0D [Flow: branch]
	ora $FC90FE.l,X		; 1F FE 90 FC ; Logical OR long $FC90FE.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $CE		; D0 CE ; Branch if not equal to $D0, $CE [Flow: branch]
	rol $2122.w,X		; 3E 22 21 ; Rotate left $2122.w,X [Reads: X Index] [Flags: NCZ]
	and ($32.b,X)		; 21 32 ; Logical AND ($32.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $90, $FE		; 90 FE ; Branch if carry clear to $90, $FE [Flow: branch]
	bit $E0E0.w,X		; 3C E0 E0 ; Test bits $E0E0.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	.db $F0, $0F		; F0 0F ; Branch if equal to $F0, $0F [Flow: branch]
	sbc ($3E.b,X)		; E1 3E ; Subtract with carry ($3E.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $90, $01		; 90 01 ; Branch if carry clear to $90, $01 [Flow: branch]
	.db $F0, $2E		; F0 2E ; Branch if equal to $F0, $2E [Flow: branch]
	rol $0E0F.w		; 2E 0F 0E ; Rotate left $0E0F.w [Flags: NCZ]
	trb $00.b		; 14 00 ; Test and reset bits $00.b [Reads: Accumulator] [Flags: Z]
	.db $90, $41		; 90 41 ; Branch if carry clear to $90, $41 [Flow: branch]
	rol $FD0E.w		; 2E 0E FD ; Rotate left $FD0E.w [Flags: NCZ]
	cpx #$20EE.w		; E0 EE 20 ; Compare #$20EE.w with X register [Reads: X Index] [Flags: NCZ]
	cpx #$2090.w		; E0 90 20 ; Compare #$2090.w with X register [Reads: X Index] [Flags: NCZ]
	ora ($10.b),Y		; 11 10 ; OR accumulator with memory ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $32		; 30 32 ; Branch if minus to $30, $32 [Flow: branch]
	ora $801050.l		; 0F 50 10 80 ; OR accumulator with memory (long) $801050.l [Writes: Accumulator] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	lsr $D0D3.w,X		; 5E D3 D0 ; Logical shift right $D0D3.w,X [Reads: X Index] [Flags: NCZ]
	ora $0D2F0F.l		; 0F 0F 2F 0D ; OR accumulator with memory (long) $0D2F0F.l [Writes: Accumulator] [Flags: NZ]
	.db $80, $D0		; 80 D0 ; Branch always to $80, $D0 [Flow: branch]
	cpx $F34D.w		; EC 4D F3 ; Compare $F34D.w with X register [Reads: X Index] [Flags: NCZ]
	brk $4D.b		; 00 4D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $1D.b,X		; 36 1D ; Rotate left $1D.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $90, $4F		; 90 4F ; Branch if carry clear to $90, $4F [Flow: branch]
	pea $1FF0.w		; F4 F0 1F ; Push absolute address $1FF0.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sbc $E22DFD.l		; EF FD 2D E2 ; Subtract with carry (long) $E22DFD.l [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $0B		; 80 0B ; Branch always to $80, $0B [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	and $023F10.l		; 2F 10 3F 02 ; AND accumulator with memory (long) $023F10.l [Writes: Accumulator] [Flags: NZ]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	.db $80, $3D		; 80 3D ; Branch always to $80, $3D [Flow: branch]
	and $FD.b,X		; 35 FD ; Logical AND $FD.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	trb $DFCD.w		; 1C CD DF ; Test and reset bits $DFCD.w [Reads: Accumulator] [Flags: Z]
	.db $D0, $F0		; D0 F0 ; Branch if not equal to $D0, $F0 [Flow: branch]
	.db $80, $01		; 80 01 ; Branch always to $80, $01 [Flow: branch]
	eor $1F.b,S		; 43 1F ; Exclusive OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lsr $10F2.w,X		; 5E F2 10 ; Logical shift right $10F2.w,X [Reads: X Index] [Flags: NCZ]
	sbc ($4F.b)		; F2 4F ; Subtract with carry (indirect) ($4F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $43		; 80 43 ; Branch always to $80, $43 [Flow: branch]
	ora ($FF.b),Y		; 11 FF ; OR accumulator with memory ($FF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $EB0F.w,Y		; 39 0F EB ; AND accumulator with memory $EB0F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $2E		; 80 2E ; Branch always to $80, $2E [Flow: branch]
	and ($10.b),Y		; 31 10 ; AND accumulator with memory ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ora $84FE.w		; 0D FE 84 ; Logical OR $84FE.w with accumulator [Writes: Accumulator] [Flags: NZ]
	eor $4CFF20.l		; 4F 20 FF 4C ; Exclusive OR accumulator with memory (long) $4CFF20.l [Writes: Accumulator] [Flags: NZ]
	inc $D302.w,X		; FE 02 D3 ; Increment memory $D302.w,X [Reads: X Index] [Flags: NZ]
	ora $3E80.w,X		; 1D 80 3E ; OR accumulator with memory $3E80.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $42, $12		; 42 12 ; Reserved instruction
	ora ($03.b),Y		; 11 03 ; OR accumulator with memory ($03.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $0080.w		; EE 80 00 ; Increment $0080.w [Flags: NZ]
	asl $F101.w		; 0E 01 F1 ; Arithmetic shift left $F101.w [Flags: NCZ]
	tsb $DF.b		; 04 DF ; Test and set bits $DF.b [Reads: Accumulator] [Flags: Z]
	asl $700C.w		; 0E 0C 70 ; Arithmetic shift left $700C.w [Flags: NCZ]
	sbc ($0E.b),Y		; F1 0E ; Subtract with carry ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $E5.b,S		; 63 E5 ; Add with carry (stack relative) $E5.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	trb $00.b		; 14 00 ; Test and reset bits $00.b [Reads: Accumulator] [Flags: Z]
	jsl $1D80BC.l		; 22 BC 80 1D ; Jump to subroutine long $1D80BC.l [Writes: Stack Pointer] [Flow: call]
	sbc $41F0F2.l,X		; FF F2 F0 41 ; Subtract with carry (long,X) $41F0F2.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $70011E.l,X		; 1F 1E 01 70 ; Logical OR long $70011E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
.ACCU 16
	rep #$A3		; C2 A3
	sbc $FF11.w		; ED 11 FF ; Subtract $FF11.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	adc $0031.w		; 6D 31 00 ; Add $0031.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $FD		; 70 FD ; Branch if overflow set to $70, $FD [Flow: branch]
	cmp ($CA.b,S),Y		; D3 CA ; Compare accumulator (stack relative indirect indexed) ($CA.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	lsr $3FD1.w		; 4E D1 3F ; Logical shift right $3FD1.w [Flags: NCZ]
	adc $24.b,S		; 63 24 ; Add with carry (stack relative) $24.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	ora ($DD.b)		; 12 DD ; OR accumulator with memory (indirect) ($DD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cmp $E3243F.l		; CF 3F 24 E3 ; Compare accumulator (long) $E3243F.l [Reads: Accumulator] [Flags: NCZ]
	.db $70, $21		; 70 21 ; Branch if overflow set to $70, $21 [Flow: branch]
	rol $1C3E.w,X		; 3E 3E 1C ; Rotate left $1C3E.w,X [Reads: X Index] [Flags: NCZ]
	ora ($FF.b,S),Y		; 13 FF ; OR accumulator (stack relative indirect indexed) ($FF.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($3F.b,X)		; 01 3F ; Logical OR ($3F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $70, $0F		; 70 0F ; Branch if overflow set to $70, $0F [Flow: branch]
	.db $F0, $FA		; F0 FA ; Branch if equal to $F0, $FA [Flow: branch]
	tsb $01E3.w		; 0C E3 01 ; Test and set bits $01E3.w [Reads: Accumulator] [Flags: Z]
	and $43.b,S		; 23 43 ; AND accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $70, $32		; 70 32 ; Branch if overflow set to $70, $32 [Flow: branch]
	eor ($1E.b)		; 52 1E ; Exclusive OR accumulator with memory (indirect) ($1E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $0CFF.w		; 2D FF 0C ; Logical AND $0CFF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $703F.w,X		; 1D 3F 70 ; OR accumulator with memory $703F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($1E.b,X)		; E1 1E ; Subtract with carry ($1E.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
.ACCU 8
.INDEX 8
	sep #$FF		; E2 FF
	sbc ($FF.b),Y		; F1 FF ; Subtract with carry ($FF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr $7021.w		; 4E 21 70 ; Logical shift right $7021.w [Flags: NCZ]
	sbc $CEF21C.l,X		; FF 1C F2 CE ; Subtract with carry (long,X) $CEF21C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $1EF1.w		; 2E F1 1E ; Rotate left $1EF1.w [Flags: NCZ]
	ora $011270.l,X		; 1F 70 12 01 ; Logical OR long $011270.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $2AE0.w,X		; 1E E0 2A ; Arithmetic shift left $2AE0.w,X [Reads: X Index] [Flags: NCZ]
	brk $F2.b		; 00 F2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($70.b)		; 12 70 ; OR accumulator with memory (indirect) ($70.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $50, $1F		; 50 1F ; Branch if overflow clear to $50, $1F [Flow: branch]
	.db $50, $03		; 50 03 ; Branch if overflow clear to $50, $03 [Flow: branch]
	.db $F0, $20		; F0 20 ; Branch if equal to $F0, $20 [Flow: branch]
	inc $60CE.w		; EE CE 60 ; Increment $60CE.w [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr ($320D.w,X)		; FC 0D 32 ; Jump to subroutine indirect indexed ($320D.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	bit $42.b		; 24 42 ; Test bits $42.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	asl $F3.b		; 06 F3 ; Arithmetic shift left $F3.b [Reads: Direct Page] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $00E520.l,X		; 1F 20 E5 00 ; Logical OR long $00E520.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $EF2F1D.l		; EF 1D 2F EF ; Subtract with carry (long) $EF2F1D.l [Writes: Accumulator] [Flags: NCVZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ldx $C4FF.w,Y		; BE FF C4 ; Load X register $C4FF.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ora $0D0331.l		; 0F 31 03 0D ; OR accumulator with memory (long) $0D0331.l [Writes: Accumulator] [Flags: NZ]
	.db $30, $60		; 30 60 ; Branch if minus to $30, $60 [Flow: branch]
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($D0.b,X)		; E1 D0 ; Subtract with carry ($D0.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	trb $5F2E.w		; 1C 2E 5F ; Test and reset bits $5F2E.w [Reads: Accumulator] [Flags: Z]
	.db $30, $60		; 30 60 ; Branch if minus to $30, $60 [Flow: branch]
	cmp ($E0.b),Y		; D1 E0 ; Compare accumulator ($E0.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	trb $2E2E.w		; 1C 2E 2E ; Test and reset bits $2E2E.w [Reads: Accumulator] [Flags: Z]
	jsl $601011.l		; 22 11 10 60 ; Jump to subroutine long $601011.l [Writes: Stack Pointer] [Flow: call]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	sbc $1D2F2F.l		; EF 2F 2F 1D ; Subtract with carry (long) $1D2F2F.l [Writes: Accumulator] [Flags: NCVZ]
	sbc $B0.b,X		; F5 B0 ; Subtract $B0.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $3F1DFE.l,X		; FF FE 1D 3F ; Subtract with carry (long,X) $3F1DFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $02.b		; E5 02 ; Subtract $02.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and ($01.b)		; 32 01 ; AND accumulator with memory (indirect) ($01.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $50, $1F		; 50 1F ; Branch if overflow clear to $50, $1F [Flow: branch]
	rol $09DC.w,X		; 3E DC 09 ; Rotate left $09DC.w,X [Reads: X Index] [Flags: NCZ]
	ora ($94.b)		; 12 94 ; OR accumulator with memory (indirect) ($94.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp ($C3.b,S),Y		; D3 C3 ; Compare accumulator (stack relative indirect indexed) ($C3.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	.db $50, $1E		; 50 1E ; Branch if overflow clear to $50, $1E [Flow: branch]
	lsr $D5D1.w,X		; 5E D1 D5 ; Logical shift right $D5D1.w,X [Reads: X Index] [Flags: NCZ]
	sbc $1120F1.l,X		; FF F1 20 11 ; Subtract with carry (long,X) $1120F1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $50, $E0		; 50 E0 ; Branch if overflow clear to $50, $E0 [Flow: branch]
	asl $D0FD.w,X		; 1E FD D0 ; Arithmetic shift left $D0FD.w,X [Reads: X Index] [Flags: NCZ]
	.db $F0, $E4		; F0 E4 ; Branch if equal to $F0, $E4 [Flow: branch]
	rol $5062.w		; 2E 62 50 ; Rotate left $5062.w [Flags: NCZ]
	.db $10, $F2		; 10 F2 ; Branch if plus to $10, $F2 [Flow: branch]
	cmp ($B2.b)		; D2 B2 ; Compare accumulator (indirect) ($B2.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	inc $FF01.w,X		; FE 01 FF ; Increment memory $FF01.w,X [Reads: X Index] [Flags: NZ]
	and ($40.b,X)		; 21 40 ; Logical AND ($40.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	dec $E2.b		; C6 E2 ; Decrement $E2.b [Reads: Direct Page] [Flags: NZ]
	bit $EF11.w,X		; 3C 11 EF ; Test bits $EF11.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	cmp $500ED2.l,X		; DF D2 0E 50 ; Compare accumulator (long,X) $500ED2.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	jsr $F020.w		; 20 20 F0 ; Jump to subroutine at $F020.w [Writes: Stack Pointer] [Flow: call]
	cpx #$1F.b		; E0 1F ; Compare #$1F.b with X register [Reads: X Index] [Flags: NCZ]
	rol $F201.w,X		; 3E 01 F2 ; Rotate left $F201.w,X [Reads: X Index] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	lda ($EF.b,X)		; A1 EF ; Load accumulator ($EF.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $D64C.w		; 0C 4C D6 ; Test and set bits $D64C.w [Reads: Accumulator] [Flags: Z]
	sbc $23.b,S		; E3 23 ; Subtract stack-relative $23.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	eor ($40.b),Y		; 51 40 ; Exclusive OR accumulator with memory ($40.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $1AB1E6.l		; 22 E6 B1 1A ; Jump to subroutine long $1AB1E6.l [Writes: Stack Pointer] [Flow: call]
	sbc $E303FE.l,X		; FF FE 03 E3 ; Subtract with carry (long,X) $E303FE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rol $023D.w		; 2E 3D 02 ; Rotate left $023D.w [Flags: NCZ]
	ora ($E5.b,X)		; 01 E5 ; Logical OR ($E5.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $10, $5D		; 10 5D ; Branch if plus to $10, $5D [Flow: branch]
	and ($40.b,X)		; 21 40 ; Logical AND ($40.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($EF.b,X)		; 01 EF ; Logical OR ($EF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	inc $F1EF.w,X		; FE EF F1 ; Increment memory $F1EF.w,X [Reads: X Index] [Flags: NZ]
	cpy #$FF.b		; C0 FF ; Compare #$FF.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $10, $34		; 10 34 ; Branch if plus to $10, $34 [Flow: branch]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	.db $10, $B3		; 10 B3 ; Branch if plus to $10, $B3 [Flow: branch]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	jsr $1F00.w		; 20 00 1F ; Jump to subroutine at $1F00.w [Writes: Stack Pointer] [Flow: call]
	.db $30, $23		; 30 23 ; Branch if minus to $30, $23 [Flow: branch]
	cmp $FE104D.l,X		; DF 4D 10 FE ; Compare accumulator (long,X) $FE104D.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	sbc $240201.l,X		; FF 01 02 24 ; Subtract with carry (long,X) $240201.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $0FE2.w		; 2E E2 0F ; Rotate left $0FE2.w [Flags: NCZ]
	brk $2C.b		; 00 2C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $2D		; 30 2D ; Branch if minus to $30, $2D [Flow: branch]
	cop $10.b		; 02 10 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0D.b,S		; E3 0D ; Subtract stack-relative $0D.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	cpx #$F0.b		; E0 F0 ; Compare #$F0.b with X register [Reads: X Index] [Flags: NCZ]
	ora ($10.b),Y		; 11 10 ; OR accumulator with memory ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $10		; 30 10 ; Branch if minus to $30, $10 [Flow: branch]
	lsr $F123.w		; 4E 23 F1 ; Logical shift right $F123.w [Flags: NCZ]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $10, $3E		; 10 3E ; Branch if plus to $10, $3E [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $56.b		; 00 56 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C2.b		; 00 C2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($0F.b,X)		; 21 0F ; Logical AND ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $72BEFE.l,X		; FF FE BE 72 ; Subtract with carry (long,X) $72BEFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $20AA24.l,X		; 1F 24 AA 20 ; Logical OR long $20AA24.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $0FF0.w,X		; FE F0 0F ; Increment memory $0FF0.w,X [Reads: X Index] [Flags: NZ]
	cmp $111041.l,X		; DF 41 10 11 ; Compare accumulator (long,X) $111041.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	jsr $F0FE.w		; 20 FE F0 ; Jump to subroutine at $F0FE.w [Writes: Stack Pointer] [Flow: call]
	ora $1F41EF.l		; 0F EF 41 1F ; OR accumulator with memory (long) $1F41EF.l [Writes: Accumulator] [Flags: NZ]
	ora ($BA.b,X)		; 01 BA ; Logical OR ($BA.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $30, $EE		; 30 EE ; Branch if minus to $30, $EE [Flow: branch]
	.db $F0, $FF		; F0 FF ; Branch if equal to $F0, $FF [Flow: branch]
	cpx #$41.b		; E0 41 ; Compare #$41.b with X register [Reads: X Index] [Flags: NCZ]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	and $00FFFE.l		; 2F FE FF 00 ; AND accumulator with memory (long) $00FFFE.l [Writes: Accumulator] [Flags: NZ]
	inc $1F42.w		; EE 42 1F ; Increment $1F42.w [Flags: NZ]
	ora ($BA.b,X)		; 01 BA ; Logical OR ($BA.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $30, $ED		; 30 ED ; Branch if minus to $30, $ED [Flow: branch]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$41.b		; E0 41 ; Compare #$41.b with X register [Reads: X Index] [Flags: NCZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	.db $30, $ED		; 30 ED ; Branch if minus to $30, $ED [Flow: branch]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $011F42.l		; EF 42 1F 01 ; Subtract with carry (long) $011F42.l [Writes: Accumulator] [Flags: NCVZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	.db $30, $ED		; 30 ED ; Branch if minus to $30, $ED [Flow: branch]
	sbc ($0F.b),Y		; F1 0F ; Subtract with carry ($0F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $010042.l,X		; DF 42 00 01 ; Compare accumulator (long,X) $010042.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	and ($FD.b,X)		; 21 FD ; Logical AND ($FD.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: NCZ]
	inc $0F42.w		; EE 42 0F ; Increment $0F42.w [Flags: NZ]
	ora ($BA.b)		; 12 BA ; OR accumulator with memory (indirect) ($BA.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $F0EE.w		; 20 EE F0 ; Jump to subroutine at $F0EE.w [Writes: Stack Pointer] [Flow: call]
	sbc $0051EF.l,X		; FF EF 51 00 ; Subtract with carry (long,X) $0051EF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $BA		; 10 BA ; Branch if plus to $10, $BA [Flow: branch]
	and ($FD.b,X)		; 21 FD ; Logical AND ($FD.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $F0, $FF		; F0 FF ; Branch if equal to $F0, $FF [Flow: branch]
	sbc $011031.l,X		; FF 31 10 01 ; Subtract with carry (long,X) $011031.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	and ($ED.b),Y		; 31 ED ; AND accumulator with memory ($ED.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: NCZ]
	inc $0042.w		; EE 42 00 ; Increment $0042.w [Flags: NZ]
	ora ($BA.b,X)		; 01 BA ; Logical OR ($BA.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and ($FD.b,X)		; 21 FD ; Logical AND ($FD.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $42EE00.l,X		; FF 00 EE 42 ; Subtract with carry (long,X) $42EE00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	and ($EE.b,X)		; 21 EE ; Logical AND ($EE.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $F0, $FF		; F0 FF ; Branch if equal to $F0, $FF [Flow: branch]
	inc $1F42.w,X		; FE 42 1F ; Increment memory $1F42.w,X [Reads: X Index] [Flags: NZ]
	ora ($BA.b,X)		; 01 BA ; Logical OR ($BA.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and ($EE.b,X)		; 21 EE ; Logical AND ($EE.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	inc $0042.w		; EE 42 00 ; Increment $0042.w [Flags: NZ]
	ora ($BA.b,X)		; 01 BA ; Logical OR ($BA.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $1FE0ED.l		; 22 ED E0 1F ; Jump to subroutine long $1FE0ED.l [Writes: Stack Pointer] [Flow: call]
	inc $0042.w		; EE 42 00 ; Increment $0042.w [Flags: NZ]
	ora ($BA.b,X)		; 01 BA ; Logical OR ($BA.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and ($FD.b,X)		; 21 FD ; Logical AND ($FD.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpx #$1F.b		; E0 1F ; Compare #$1F.b with X register [Reads: X Index] [Flags: NCZ]
	inc $0042.w		; EE 42 00 ; Increment $0042.w [Flags: NZ]
	ora ($BA.b,X)		; 01 BA ; Logical OR ($BA.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and ($FD.b,X)		; 21 FD ; Logical AND ($FD.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpx #$1F.b		; E0 1F ; Compare #$1F.b with X register [Reads: X Index] [Flags: NCZ]
	inc $0042.w		; EE 42 00 ; Increment $0042.w [Flags: NZ]
	ora ($BA.b,X)		; 01 BA ; Logical OR ($BA.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and ($FD.b,X)		; 21 FD ; Logical AND ($FD.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $F0, $0E		; F0 0E ; Branch if equal to $F0, $0E [Flow: branch]
	sbc $010042.l		; EF 42 00 01 ; Subtract with carry (long) $010042.l [Writes: Accumulator] [Flags: NCVZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	and ($FE.b,X)		; 21 FE ; Logical AND ($FE.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $33EE00.l		; EF 00 EE 33 ; Subtract with carry (long) $33EE00.l [Writes: Accumulator] [Flags: NCVZ]
	ora $61AAF2.l,X		; 1F F2 AA 61 ; Logical OR long $61AAF2.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	wai		; CB ; Wait for interrupt
	.db $D0, $0F		; D0 0F ; Branch if not equal to $D0, $0F [Flow: branch]
	cpy $2F74.w		; CC 74 2F ; Compare $2F74.w with Y register [Reads: Y Index] [Flags: NCZ]
	cop $BA.b		; 02 BA ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($FE.b,X)		; 21 FE ; Logical AND ($FE.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $42EE00.l		; EF 00 EE 42 ; Subtract with carry (long) $42EE00.l [Writes: Accumulator] [Flags: NCVZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	and ($FE.b,X)		; 21 FE ; Logical AND ($FE.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $42EE00.l		; EF 00 EE 42 ; Subtract with carry (long) $42EE00.l [Writes: Accumulator] [Flags: NCVZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	jsl $0FE1ED.l		; 22 ED E1 0F ; Jump to subroutine long $0FE1ED.l [Writes: Stack Pointer] [Flow: call]
	inc $0042.w		; EE 42 00 ; Increment $0042.w [Flags: NZ]
	ora ($AA.b,X)		; 01 AA ; Logical OR ($AA.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	mvp $D1,$CA		; 44 CA D1 ; Move block positive $D1,$CA [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	.db $F0, $CB		; F0 CB ; Branch if equal to $F0, $CB [Flow: branch]
	ror $1F.b		; 66 1F ; Rotate right $1F.b [Reads: Direct Page] [Flags: NCZ]
	cop $AA.b		; 02 AA ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($DB.b)		; 52 DB ; Exclusive OR accumulator with memory (indirect) ($DB.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp ($FF.b,X)		; C1 FF ; Compare accumulator ($FF.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	adc $2F.b		; 65 2F ; Add $2F.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cop $AA.b		; 02 AA ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $DB.b,S		; 43 DB ; Exclusive OR accumulator with stack relative $DB.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: NCZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	adc [$1F.b]		; 67 1F ; Add with carry (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($AA.b,S),Y		; F3 AA ; Subtract with carry (stack relative indirect indexed) ($AA.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	eor $CC.b,S		; 43 CC ; Exclusive OR accumulator with stack relative $CC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpy #$0F.b		; C0 0F ; Compare #$0F.b with Y register [Reads: Y Index] [Flags: NCZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ror $2F.b		; 66 2F ; Rotate right $2F.b [Reads: Direct Page] [Flags: NCZ]
	ora ($AA.b,X)		; 01 AA ; Logical OR ($AA.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor ($DB.b,S),Y		; 53 DB ; XOR accumulator (stack relative indirect indexed) ($DB.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda ($0F.b),Y		; B1 0F ; Load accumulator ($0F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	lsr $2F.b,X		; 56 2F ; Logical shift right $2F.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc ($AA.b)		; F2 AA ; Subtract with carry (indirect) ($AA.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	eor ($CC.b,S),Y		; 53 CC ; XOR accumulator (stack relative indirect indexed) ($CC.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp ($FF.b,X)		; C1 FF ; Compare accumulator ($FF.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	cpy $2F56.w		; CC 56 2F ; Compare $2F56.w with Y register [Reads: Y Index] [Flags: NCZ]
	sbc ($AA.b)		; F2 AA ; Subtract with carry (indirect) ($AA.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	eor ($CC.b,S),Y		; 53 CC ; XOR accumulator (stack relative indirect indexed) ($CC.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $56DBF0.l,X		; DF F0 DB 56 ; Compare accumulator (long,X) $56DBF0.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	and $53AAF2.l		; 2F F2 AA 53 ; AND accumulator with memory (long) $53AAF2.l [Writes: Accumulator] [Flags: NZ]
	cpy $00C0.w		; CC C0 00 ; Compare $00C0.w with Y register [Reads: Y Index] [Flags: NCZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	ror $2F.b		; 66 2F ; Rotate right $2F.b [Reads: Direct Page] [Flags: NCZ]
	sbc ($AA.b)		; F2 AA ; Subtract with carry (indirect) ($AA.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	mvp $B0,$DC		; 44 DC B0 ; Move block positive $B0,$DC [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	brk $BB.b		; 00 BB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $2F.b		; 66 2F ; Rotate right $2F.b [Reads: Direct Page] [Flags: NCZ]
	sbc ($AA.b)		; F2 AA ; Subtract with carry (indirect) ($AA.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	mvp $B0,$DC		; 44 DC B0 ; Move block positive $B0,$DC [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	.db $F0, $DB		; F0 DB ; Branch if equal to $F0, $DB [Flow: branch]
	eor $20.b,X		; 55 20 ; Exclusive OR accumulator with memory $20.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($AA.b,X)		; 01 AA ; Logical OR ($AA.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	mvp $C0,$DB		; 44 DB C0 ; Move block positive $C0,$DB [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	.db $F0, $DA		; F0 DA ; Branch if equal to $F0, $DA [Flow: branch]
	ror $2F.b		; 66 2F ; Rotate right $2F.b [Reads: Direct Page] [Flags: NCZ]
	sbc ($AA.b)		; F2 AA ; Subtract with carry (indirect) ($AA.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	eor $EC.b,S		; 43 EC ; Exclusive OR accumulator with stack relative $EC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $F1		; B0 F1 ; Branch if carry set to $B0, $F1 [Flow: branch]
	wai		; CB ; Wait for interrupt
	lsr $20.b		; 46 20 ; Logical shift right $20.b [Reads: Direct Page] [Flags: NCZ]
	cop $AA.b		; 02 AA ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($EC.b,S),Y		; 33 EC ; AND accumulator (stack relative indirect indexed) ($EC.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $F1		; B0 F1 ; Branch if carry set to $B0, $F1 [Flow: branch]
	wai		; CB ; Wait for interrupt
	eor [$2F.b]		; 47 2F ; Exclusive OR accumulator with memory (long) [$2F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc ($AA.b)		; F2 AA ; Subtract with carry (indirect) ($AA.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	eor $EC.b,S		; 43 EC ; Exclusive OR accumulator with stack relative $EC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $00		; B0 00 ; Branch if carry set to $B0, $00 [Flow: branch]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	ror $10.b		; 66 10 ; Rotate right $10.b [Reads: Direct Page] [Flags: NCZ]
	sbc ($AA.b)		; F2 AA ; Subtract with carry (indirect) ($AA.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	mvp $B0,$DC		; 44 DC B0 ; Move block positive $B0,$DC [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sbc ($D9.b),Y		; F1 D9 ; Subtract with carry ($D9.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr $3F.b,X		; 56 3F ; Logical shift right $3F.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc ($BA.b)		; F2 BA ; Subtract with carry (indirect) ($BA.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jsl $00E0FD.l		; 22 FD E0 00 ; Jump to subroutine long $00E0FD.l [Writes: Stack Pointer] [Flow: call]
	jsr ($1F24.w,X)		; FC 24 1F ; Jump to subroutine indirect indexed ($1F24.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora ($AA.b,X)		; 01 AA ; Logical OR ($AA.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	mvp $CF,$EB		; 44 EB CF ; Move block positive $CF,$EB [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	.db $F0, $DC		; F0 DC ; Branch if equal to $F0, $DC [Flow: branch]
	rol $20.b,X		; 36 20 ; Rotate left $20.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cop $AA.b		; 02 AA ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($FC.b)		; 32 FC ; AND accumulator with memory (indirect) ($FC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $25DD0F.l		; CF 0F DD 25 ; Compare accumulator (long) $25DD0F.l [Reads: Accumulator] [Flags: NCZ]
	.db $30, $02		; 30 02 ; Branch if minus to $30, $02 [Flow: branch]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	and ($FC.b)		; 32 FC ; AND accumulator with memory (indirect) ($FC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $25DD0F.l		; CF 0F DD 25 ; Compare accumulator (long) $25DD0F.l [Reads: Accumulator] [Flags: NCZ]
	.db $30, $02		; 30 02 ; Branch if minus to $30, $02 [Flow: branch]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	and ($FC.b)		; 32 FC ; AND accumulator with memory (indirect) ($FC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $25DD0F.l		; CF 0F DD 25 ; Compare accumulator (long) $25DD0F.l [Reads: Accumulator] [Flags: NCZ]
	.db $30, $02		; 30 02 ; Branch if minus to $30, $02 [Flow: branch]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7A.b		; 00 7A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $02DF.w		; CD DF 02 ; Compare $02DF.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	and $55.b,X		; 35 55 ; Logical AND $55.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and ($20.b,S),Y		; 33 20 ; AND accumulator (stack relative indirect indexed) ($20.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$EE8A]		; DC 8A EE ; Jump long indirect [$EE8A] [Flow: jump]
	inc $01F0.w		; EE F0 01 ; Increment $01F0.w [Flags: NZ]
	.db $10, $EE		; 10 EE ; Branch if plus to $10, $EE [Flow: branch]
	sbc $7ACC.w		; ED CC 7A ; Subtract $7ACC.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	sbc ($35.b,X)		; E1 35 ; Subtract with carry ($35.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr $64.b,X		; 56 64 ; Logical shift right $64.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	and ($11.b)		; 32 11 ; AND accumulator with memory (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($7A.b),Y		; 11 7A ; OR accumulator with memory ($7A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($34.b,S),Y		; 13 34 ; OR accumulator (stack relative indirect indexed) ($34.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $21.b,X		; 34 21 ; Test bits $21.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sbc $02DFDD.l,X		; FF DD DF 02 ; Subtract with carry (long,X) $02DFDD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and $56.b,X		; 35 56 ; Logical AND $56.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	mvp $FE,$20		; 44 20 FE ; Move block positive $FE,$20 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sbc $DCED.w		; ED ED DC ; Subtract $DCED.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	inc $DAFE.w,X		; FE FE DA ; Increment memory $DAFE.w,X [Reads: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda #$BD.b		; A9 BD ; Load #$BD.b into accumulator [Writes: Accumulator] [Flags: NZ]
	cpx #$14.b		; E0 14 ; Compare #$14.b with X register [Reads: X Index] [Flags: NCZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	eor $54.b		; 45 54 ; Exclusive OR $54.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($00.b),Y		; 31 00 ; AND accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $66.b,X		; 34 66 ; Test bits $66.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	stz $1F.b		; 64 1F ; Store zero to $1F.b
	jmp.w [$BEBB]		; DC BB BE ; Jump long indirect [$BEBB] [Flow: jump]
	ora ($35.b,S),Y		; 13 35 ; OR accumulator (stack relative indirect indexed) ($35.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $7A.b		; 65 7A ; Add $7A.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	eor $2F.b,S		; 43 2F ; Exclusive OR accumulator with stack relative $2F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $DEDD.w		; ED DD DE ; Subtract $DEDD.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	dec $EDF0.w,X		; DE F0 ED ; Decrement memory $EDF0.w,X [Reads: X Index] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	cpy $BDAB.w		; CC AB BD ; Compare $BDAB.w with Y register [Reads: Y Index] [Flags: NCZ]
	cmp $322301.l,X		; DF 01 23 32 ; Compare accumulator (long,X) $322301.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	jsl $33127A.l		; 22 7A 12 33 ; Jump to subroutine long $33127A.l [Writes: Stack Pointer] [Flow: call]
	and ($43.b,S),Y		; 33 43 ; AND accumulator (stack relative indirect indexed) ($43.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $31.b,X		; 34 31 ; Test bits $31.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $DC.b		; 00 DC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	cmp $02DE.w		; CD DE 02 ; Compare $02DE.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	mvp $52,$55		; 44 55 52 ; Move block positive $52,$55 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $EE8AED.l,X		; 1F ED 8A EE ; Logical OR long $EE8AED.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $00F0.w		; EE F0 00 ; Increment $00F0.w [Flags: NZ]
	.db $10, $FF		; 10 FF ; Branch if plus to $10, $FF [Flow: branch]
	jmp.w [$7ACD]		; DC CD 7A ; Jump long indirect [$7ACD] [Flow: jump]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	sbc ($34.b,X)		; E1 34 ; Subtract with carry ($34.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr $65.b,X		; 56 65 ; Logical shift right $65.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	and ($01.b)		; 32 01 ; AND accumulator with memory (indirect) ($01.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($7A.b)		; 12 7A ; OR accumulator with memory (indirect) ($7A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($34.b)		; 12 34 ; OR accumulator with memory (indirect) ($34.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $21.b,S		; 43 21 ; Exclusive OR accumulator with stack relative $21.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $EFDD.w		; 0E DD EF ; Arithmetic shift left $EFDD.w [Flags: NCZ]
	sbc ($6A.b),Y		; F1 6A ; Subtract with carry ($6A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr $55.b,X		; 56 55 ; Logical shift right $55.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	eor ($20.b,S),Y		; 53 20 ; XOR accumulator (stack relative indirect indexed) ($20.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $DDEE.w,X		; FE EE DD ; Increment memory $DDEE.w,X [Reads: X Index] [Flags: NZ]
	cmp $EF7A.w,X		; DD 7A EF ; Compare accumulator $EF7A.w,X [Reads: X Index] [Flags: NCZ]
	sbc $B9CC.w,X		; FD CC B9 ; Subtract with carry $B9CC.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	ldy $23E0.w,X		; BC E0 23 ; Load Y register $23E0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	eor $53.b,X		; 55 53 ; Exclusive OR accumulator with memory $53.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and ($10.b),Y		; 31 10 ; AND accumulator with memory ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $12		; F0 12 ; Branch if equal to $F0, $12 [Flow: branch]
	and $66.b		; 25 66 ; Logical AND $66.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	mvn $EC,$1F		; 54 1F EC ; Move block negative $EC,$1F [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	dec $4503.w		; CE 03 45 ; Decrement $4503.w [Flags: NZ]
	eor $7A.b,X		; 55 7A ; Exclusive OR accumulator with memory $7A.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($1F.b,S),Y		; 53 1F ; XOR accumulator (stack relative indirect indexed) ($1F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $DEDC.w,X		; FD DC DE ; Subtract with carry $DEDC.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $FDFF.w		; EE FF FD ; Increment $FDFF.w [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	wai		; CB ; Wait for interrupt
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	cmp $11DE.w		; CD DE 11 ; Compare $11DE.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsl $7A3232.l		; 22 32 32 7A ; Jump to subroutine long $7A3232.l [Writes: Stack Pointer] [Flow: call]
	and ($23.b,X)		; 21 23 ; Logical AND ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $22.b,X		; 34 22 ; Test bits $22.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora $CC7BDD.l		; 0F DD 7B CC ; OR accumulator with memory (long) $CC7BDD.l [Writes: Accumulator] [Flags: NZ]
	cmp $553502.l,X		; DF 02 35 55 ; Compare accumulator (long,X) $553502.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	eor $1F.b,S		; 43 1F ; Exclusive OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx $0002.w		; EC 02 00 ; Compare $0002.w with X register [Reads: X Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7A.b		; 00 7A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$1E.b		; E0 1E ; Compare #$1E.b with X register [Reads: X Index] [Flags: NCZ]
	sbc ($46.b,S),Y		; F3 46 ; Subtract with carry (stack relative indirect indexed) ($46.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ror $F3.b		; 66 F3 ; Rotate right $F3.b [Reads: Direct Page] [Flags: NCZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	tsb $CCAF.w		; 0C AF CC ; Test and set bits $CCAF.w [Reads: Accumulator] [Flags: Z]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and $10.b		; 25 10 ; Logical AND $10.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rol $DDDE.w		; 2E DE DD ; Rotate left $DDDE.w [Flags: NCZ]
	sbc $2312DD.l		; EF DD 12 23 ; Subtract with carry (long) $2312DD.l [Writes: Accumulator] [Flags: NCVZ]
	and ($8A.b),Y		; 31 8A ; AND accumulator with memory ($8A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	inc $32D0.w		; EE D0 32 ; Increment $32D0.w [Flags: NZ]
	and ($0F.b,X)		; 21 0F ; Logical AND ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	mvp $3F,$34		; 44 34 3F ; Move block positive $3F,$34 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($21.b,X)		; E1 21 ; Subtract with carry ($21.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($02.b,X)		; 21 02 ; Logical AND ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $0D1115.l		; 0F 15 11 0D ; OR accumulator with memory (long) $0D1115.l [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dec $DFEC.w,X		; DE EC DF ; Decrement memory $DFEC.w,X [Reads: X Index] [Flags: NZ]
	asl $0011.w		; 0E 11 00 ; Arithmetic shift left $0011.w [Flags: NCZ]
	and $BB8AFE.l		; 2F FE 8A BB ; AND accumulator with memory (long) $BB8AFE.l [Writes: Accumulator] [Flags: NZ]
	.db $F0, $14		; F0 14 ; Branch if equal to $F0, $14 [Flow: branch]
	and $421301.l		; 2F 01 13 42 ; AND accumulator with memory (long) $421301.l [Writes: Accumulator] [Flags: NZ]
	sbc $02EE8A.l,X		; FF 8A EE 02 ; Subtract with carry (long,X) $02EE8A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $8ACC.w,X		; 1E CC 8A ; Arithmetic shift left $8ACC.w,X [Reads: X Index] [Flags: NCZ]
	inc $FECD.w,X		; FE CD FE ; Increment memory $FECD.w,X [Reads: X Index] [Flags: NZ]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	ora $8A0EF1.l,X		; 1F F1 0E 8A ; Logical OR long $8A0EF1.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $113103.l		; EF 03 31 11 ; Subtract with carry (long) $113103.l [Writes: Accumulator] [Flags: NCVZ]
	ora ($33.b),Y		; 11 33 ; OR accumulator with memory ($33.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($2F.b,S),Y		; 33 2F ; AND accumulator (stack relative indirect indexed) ($2F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	sbc ($24.b,X)		; E1 24 ; Subtract with carry ($24.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($EF.b,X)		; 41 EF ; Exclusive OR accumulator with memory ($EF.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $33.b,S		; 03 33 ; OR accumulator with stack relative $33.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	dec $BE7A.w		; CE 7A BE ; Decrement $BE7A.w [Flags: NZ]
	jsr ($EEBE.w,X)		; FC BE EE ; Jump to subroutine indirect indexed ($EEBE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	asl $0EDF.w		; 0E DF 0E ; Arithmetic shift left $0EDF.w [Flags: NCZ]
	cpx $D07A.w		; EC 7A D0 ; Compare $D07A.w with X register [Reads: X Index] [Flags: NCZ]
	and ($33.b,S),Y		; 33 33 ; AND accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr $4613.w		; 20 13 46 ; Jump to subroutine at $4613.w [Writes: Stack Pointer] [Flow: call]
	adc ($F0.b,X)		; 61 F0 ; Add with carry ($F0.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	sbc ($33.b),Y		; F1 33 ; Subtract with carry ($33.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and $4E250F.l		; 2F 0F 25 4E ; AND accumulator with memory (long) $4E250F.l [Writes: Accumulator] [Flags: NZ]
	dec $7ACE.w,X		; DE CE 7A ; Decrement memory $7ACE.w,X [Reads: X Index] [Flags: NZ]
	inc $BCDD.w,X		; FE DD BC ; Increment memory $BCDD.w,X [Reads: X Index] [Flags: NZ]
	sbc $2011F2.l		; EF F2 11 20 ; Subtract with carry (long) $2011F2.l [Writes: Accumulator] [Flags: NCVZ]
	cmp $0F7A.w,X		; DD 7A 0F ; Compare accumulator $0F7A.w,X [Reads: X Index] [Flags: NCZ]
	cop $20.b		; 02 20 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($13.b),Y		; 11 13 ; OR accumulator with memory ($13.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor ($31.b,S),Y		; 53 31 ; XOR accumulator (stack relative indirect indexed) ($31.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $7A		; F0 7A ; Branch if equal to $F0, $7A [Flow: branch]
	bit $31.b		; 24 31 ; Test bits $31.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	asl $53E2.w		; 0E E2 53 ; Arithmetic shift left $53E2.w [Flags: NCZ]
	.db $10, $DD		; 10 DD ; Branch if plus to $10, $DD [Flow: branch]
	sbc $DBFF7A.l		; EF 7A FF DB ; Subtract with carry (long) $DBFF7A.l [Writes: Accumulator] [Flags: NCVZ]
	sbc $221100.l		; EF 00 11 22 ; Subtract with carry (long) $221100.l [Writes: Accumulator] [Flags: NCVZ]
	sbc $7ADF.w,X		; FD DF 7A ; Subtract with carry $7ADF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $011211.l		; EF 11 12 01 ; Subtract with carry (long) $011211.l [Writes: Accumulator] [Flags: NCVZ]
	bit $31.b,X		; 34 31 ; Test bits $31.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora $227AF0.l,X		; 1F F0 7A 22 ; Logical OR long $227AF0.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsr $23CF.w		; 20 CF 23 ; Jump to subroutine at $23CF.w [Writes: Stack Pointer] [Flow: call]
	and ($FC.b,S),Y		; 33 FC ; AND accumulator (stack relative indirect indexed) ($FC.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $7ADF.w,X		; DD DF 7A ; Compare accumulator $7ADF.w,X [Reads: X Index] [Flags: NCZ]
	sbc $EFCC.w,X		; FD CC EF ; Subtract with carry $EFCC.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $EE1E12.l,X		; FF 12 1E EE ; Subtract with carry (long,X) $EE1E12.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $0E6A.w,X		; DE 6A 0E ; Decrement memory $0E6A.w,X [Reads: X Index] [Flags: NZ]
	ora ($1F.b,S),Y		; 13 1F ; OR accumulator (stack relative indirect indexed) ($1F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $55.b		; 26 55 ; Rotate left $55.b [Reads: Direct Page] [Flags: NCZ]
	mvp $34,$01		; 44 01 34 ; Move block positive $34,$01 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	eor $FC.b,S		; 43 FC ; Exclusive OR accumulator with stack relative $FC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc ($34.b,X)		; E1 34 ; Subtract with carry ($34.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr $DFEE.w		; 20 EE DF ; Jump to subroutine at $DFEE.w [Writes: Stack Pointer] [Flow: call]
	brk $6A.b		; 00 6A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ldy $D0DD.w,X		; BC DD D0 ; Load Y register $D0DD.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	.db $30, $DC		; 30 DC ; Branch if minus to $30, $DC [Flow: branch]
	ldy $7ACD.w,X		; BC CD 7A ; Load Y register $7ACD.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ora ($1F.b,X)		; 01 1F ; Logical OR ($1F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc ($12.b),Y		; F1 12 ; Subtract with carry ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	mvp $20,$21		; 44 21 20 ; Move block positive $20,$21 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	and $7A.b,X		; 35 7A ; Logical AND $7A.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor $4313EF.l		; 4F EF 13 43 ; Exclusive OR accumulator with memory (long) $4313EF.l [Writes: Accumulator] [Flags: NZ]
	.db $10, $EE		; 10 EE ; Branch if plus to $10, $EE [Flow: branch]
	.db $F0, $0F		; F0 0F ; Branch if equal to $F0, $0F [Flow: branch]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lda $ADBC.w,Y		; B9 BC AD ; Load $ADBC.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $CBAB1D.l		; 0F 1D AB CB ; OR accumulator with memory (long) $CBAB1D.l [Writes: Accumulator] [Flags: NZ]
	ldx $007A.w		; AE 7A 00 ; Load $007A.w into X register [Writes: X Index] [Flags: NZ]
	sbc $3313F0.l,X		; FF F0 13 33 ; Subtract with carry (long,X) $3313F0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($13.b),Y		; 11 13 ; OR accumulator with memory ($13.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($7A.b,S),Y		; 33 7A ; AND accumulator (stack relative indirect indexed) ($7A.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $34E0.w,X		; 1E E0 34 ; Arithmetic shift left $34E0.w,X [Reads: X Index] [Flags: NCZ]
	eor ($0F.b)		; 52 0F ; Exclusive OR accumulator with memory (indirect) ($0F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $ACDC6A.l,X		; 1F 6A DC AC ; Logical OR long $ACDC6A.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($11.b,X)		; E1 11 ; Subtract with carry ($11.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $CDDD.w,X		; FE DD CD ; Increment memory $CDDD.w,X [Reads: X Index] [Flags: NZ]
	.db $F0, $7A		; F0 7A ; Branch if equal to $F0, $7A [Flow: branch]
	.db $F0, $0F		; F0 0F ; Branch if equal to $F0, $0F [Flow: branch]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $42, $00		; 42 00 ; Reserved instruction
	and $20.b,S		; 23 20 ; AND accumulator with stack relative $20.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	inc $34F0.w		; EE F0 34 ; Increment $34F0.w [Flags: NZ]
	jsr $F0FF.w		; 20 FF F0 ; Jump to subroutine at $F0FF.w [Writes: Stack Pointer] [Flow: call]
	.db $10, $ED		; 10 ED ; Branch if plus to $10, $ED [Flow: branch]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	cmp $F1CE.w,X		; DD CE F1 ; Compare accumulator $F1CE.w,X [Reads: X Index] [Flags: NCZ]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $7AF0F0.l,X		; FF F0 F0 7A ; Subtract with carry (long,X) $7AF0F0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $4302F0.l,X		; FF F0 02 43 ; Subtract with carry (long,X) $4302F0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($22.b)		; 32 22 ; AND accumulator with memory (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($1F.b,S),Y		; 33 1F ; AND accumulator (stack relative indirect indexed) ($1F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cmp $2F6514.l,X		; DF 14 65 2F ; Compare accumulator (long,X) $2F6514.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	dec $0F11.w		; CE 11 0F ; Decrement $0F11.w [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	cpy $00D0.w		; CC D0 00 ; Compare $00D0.w with Y register [Reads: Y Index] [Flags: NCZ]
	sbc $EFFEEF.l,X		; FF EF FE EF ; Subtract with carry (long,X) $EFFEEF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $DF6A.w		; 0E 6A DF ; Arithmetic shift left $DF6A.w [Flags: NCZ]
	ora $327536.l		; 0F 36 75 32 ; OR accumulator with memory (long) $327536.l [Writes: Accumulator] [Flags: NZ]
	eor $51.b		; 45 51 ; Exclusive OR $51.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $E07A.w		; ED 7A E0 ; Subtract $E07A.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	and $32.b,S		; 23 32 ; AND accumulator with stack relative $32.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0F0000.l		; 0F 00 00 0F ; OR accumulator with memory (long) $0F0000.l [Writes: Accumulator] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	ldx $0001.w,Y		; BE 01 00 ; Load X register $0001.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ora $0EFFFF.l		; 0F FF FF 0E ; OR accumulator with memory (long) $0EFFFF.l [Writes: Accumulator] [Flags: NZ]
	sbc $03ED6A.l,X		; FF 6A ED 03 ; Subtract with carry (long,X) $03ED6A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc [$63.b]		; 67 63 ; Add with carry (long) [$63.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	bit $63.b,X		; 34 63 ; Test bits $63.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora $F17ADD.l,X		; 1F DD 7A F1 ; Logical OR long $F17ADD.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($20.b,S),Y		; 33 20 ; AND accumulator (stack relative indirect indexed) ($20.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $0D1010.l,X		; FF 10 10 0D ; Subtract with carry (long,X) $0D1010.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	wai		; CB ; Wait for interrupt
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cpy #$11.b		; C0 11 ; Compare #$11.b with Y register [Reads: Y Index] [Flags: NCZ]
	ora $FFFFFF.l,X		; 1F FF FF FF ; Logical OR long $FFFFFF.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $6AFE.w		; EE FE 6A ; Increment $6AFE.w [Flags: NZ]
	cpx #$14.b		; E0 14 ; Compare #$14.b with X register [Reads: X Index] [Flags: NCZ]
	adc [$24.b]		; 67 24 ; Add with carry (long) [$24.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	eor $32.b		; 45 32 ; Exclusive OR $32.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $7ADD.w		; 0E DD 7A ; Arithmetic shift left $7ADD.w [Flags: NCZ]
	ora $32.b,S		; 03 32 ; OR accumulator with stack relative $32.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0000F0.l		; 0F F0 00 00 ; OR accumulator with memory (long) $0000F0.l [Writes: Accumulator] [Flags: NZ]
	sbc $5ACC.w		; ED CC 5A ; Subtract $5ACC.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	lda ($51.b,X)		; A1 51 ; Load accumulator ($51.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	asl $F1DD.w		; 0E DD F1 ; Arithmetic shift left $F1DD.w [Flags: NCZ]
	inc $EDDE.w,X		; FE DE ED ; Increment memory $EDDE.w,X [Reads: X Index] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc ($46.b)		; F2 46 ; Subtract with carry (indirect) ($46.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	mvn $64,$45		; 54 45 64 ; Move block negative $64,$45 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	.db $30, $FD		; 30 FD ; Branch if minus to $30, $FD [Flow: branch]
	cpx #$7A.b		; E0 7A ; Compare #$7A.b with X register [Reads: X Index] [Flags: NCZ]
	and $10.b,S		; 23 10 ; AND accumulator with stack relative $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($1E.b,X)		; 01 1E ; Logical OR ($1E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpy $5ADE.w		; CC DE 5A ; Compare $5ADE.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $B0, $00		; B0 00 ; Branch if carry set to $B0, $00 [Flow: branch]
	jmp.w [$FECE]		; DC CE FE ; Jump long indirect [$FECE] [Flow: jump]
	cmp $BBBA.w		; CD BA BB ; Compare $BBBA.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cop $44.b		; 02 44 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $43,$56		; 44 56 43 ; Move block positive $43,$56 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	asl $03CE.w,X		; 1E CE 03 ; Arithmetic shift left $03CE.w,X [Reads: X Index] [Flags: NCZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	jsl $01F010.l		; 22 10 F0 01 ; Jump to subroutine long $01F010.l [Writes: Stack Pointer] [Flow: call]
	ora ($FD.b)		; 12 FD ; OR accumulator with memory (indirect) ($FD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $6AE0.w,X		; BD E0 6A ; Load $6AE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $FF		; F0 FF ; Branch if equal to $F0, $FF [Flow: branch]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	ora $DFEBEE.l		; 0F EE EB DF ; OR accumulator with memory (long) $DFEBEE.l [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and $44.b		; 25 44 ; Logical AND $44.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $56.b,X		; 34 56 ; Test bits $56.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	eor $1F.b,S		; 43 1F ; Exclusive OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $7BF4.w		; CD F4 7B ; Compare $7BF4.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsl $010F10.l		; 22 10 0F 01 ; Jump to subroutine long $010F10.l [Writes: Stack Pointer] [Flow: call]
	and ($FD.b,X)		; 21 FD ; Logical AND ($FD.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp $00DF.w		; CD DF 00 ; Compare $00DF.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $DD		; 90 DD ; Branch if carry clear to $90, $DD [Flow: branch]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	and $0F22.w,X		; 3D 22 0F ; AND accumulator with memory $0F22.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($F0.b),Y		; 11 F0 ; OR accumulator with memory ($F0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $212D.w,X		; 5D 2D 21 ; Exclusive OR accumulator with memory $212D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpx $10.b		; E4 10 ; Compare $10.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	cop $FD.b		; 02 FD ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $1D		; 90 1D ; Branch if carry clear to $90, $1D [Flow: branch]
	sbc ($1F.b,X)		; E1 1F ; Subtract with carry ($1F.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $1C.b,S		; 03 1C ; OR accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $80F1EE.l		; 0F EE F1 80 ; OR accumulator with memory (long) $80F1EE.l [Writes: Accumulator] [Flags: NZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $E0.b		; E5 E0 ; Subtract $E0.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $1EE1F3.l,X		; FF F3 E1 1E ; Subtract with carry (long,X) $1EE1F3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy #$1E.b		; A0 1E ; Load #$1E.b into Y register [Writes: Y Index] [Flags: NZ]
	ora ($F1.b),Y		; 11 F1 ; OR accumulator with memory ($F1.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	rol $101D.w		; 2E 1D 10 ; Rotate left $101D.w [Flags: NCZ]
	trb $A03E.w		; 1C 3E A0 ; Test and reset bits $A03E.w [Reads: Accumulator] [Flags: Z]
	asl $2A02.w,X		; 1E 02 2A ; Arithmetic shift left $2A02.w,X [Reads: X Index] [Flags: NCZ]
	adc $1FFF.w		; 6D FF 1F ; Add $1FFF.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	and $B001.w,X		; 3D 01 B0 ; AND accumulator with memory $B001.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $2F4E.w,X		; 1E 4E 2F ; Arithmetic shift left $2F4E.w,X [Reads: X Index] [Flags: NCZ]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	.db $10, $2C		; 10 2C ; Branch if plus to $10, $2C [Flow: branch]
	.db $30, $B0		; 30 B0 ; Branch if minus to $30, $B0 [Flow: branch]
	ora $3FDD12.l		; 0F 12 DD 3F ; OR accumulator with memory (long) $3FDD12.l [Writes: Accumulator] [Flags: NZ]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	sep #$4B		; E2 4B ; Set processor status bits #$4B [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	.db $B0, $41		; B0 41 ; Branch if carry set to $B0, $41 [Flow: branch]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	inc $6E7A.w		; EE 7A 6E ; Increment $6E7A.w [Flags: NZ]
	ora $01C0E1.l,X		; 1F E1 C0 01 ; Logical OR long $01C0E1.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $E0.b,S		; E3 E0 ; Subtract stack-relative $E0.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	ora $0F1E2B.l,X		; 1F 2B 1E 0F ; Logical OR long $0F1E2B.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $B0.b		; 00 B0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $3F3F.w		; 20 3F 3F ; Jump to subroutine at $3F3F.w [Writes: Stack Pointer] [Flow: call]
	ora $FF0F.w,X		; 1D 0F FF ; OR accumulator with memory $FF0F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy #$13.b		; A0 13 ; Load #$13.b into Y register [Writes: Y Index] [Flags: NZ]
	.db $30, $F0		; 30 F0 ; Branch if minus to $30, $F0 [Flow: branch]
	bit $DF1F.w		; 2C 1F DF ; Test bits $DF1F.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	cop $32.b		; 02 32 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy #$5F.b		; A0 5F ; Load #$5F.b into Y register [Writes: Y Index] [Flags: NZ]
	and ($1F.b)		; 32 1F ; AND accumulator with memory (indirect) ($1F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $F010.w		; 2E 10 F0 ; Rotate left $F010.w [Flags: NCZ]
	.db $10, $03		; 10 03 ; Branch if plus to $10, $03 [Flow: branch]
	ldy #$E2.b		; A0 E2 ; Load #$E2.b into Y register [Writes: Y Index] [Flags: NZ]
	.db $F0, $0F		; F0 0F ; Branch if equal to $F0, $0F [Flow: branch]
	jsr $0F1C.w		; 20 1C 0F ; Jump to subroutine at $0F1C.w [Writes: Stack Pointer] [Flow: call]
	sbc ($05.b),Y		; F1 05 ; Subtract with carry ($05.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy $CF.b		; A4 CF ; Load $CF.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	jsr $C7D2.w		; 20 D2 C7 ; Jump to subroutine at $C7D2.w [Writes: Stack Pointer] [Flow: call]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($FF.b),Y		; D1 FF ; Compare accumulator ($FF.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	ldy $EE.b		; A4 EE ; Load $EE.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	lda ($EE.b)		; B2 EE ; Load accumulator (indirect) ($EE.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $FE.b		; 02 FE ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($E2.b,X)		; E1 E2 ; Subtract with carry ($E2.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
.INDEX 8
	sep #$94		; E2 94
	ora [$F7.b],Y		; 17 F7 ; OR accumulator with memory (long indexed) [$F7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $64.b		; 24 64 ; Test bits $64.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sbc ($F5.b,S),Y		; F3 F5 ; Subtract with carry (stack relative indirect indexed) ($F5.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sbc $69A4.w,Y		; F9 A4 69 ; Subtract with carry $69A4.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp $D24D.w		; 4C 4D D2 ; Jump to $D24D.w [Flow: jump]
	.db $B0, $EF		; B0 EF ; Branch if carry set to $B0, $EF [Flow: branch]
	cmp $E2.b,S		; C3 E2 ; Compare accumulator (stack relative) $E2.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	ldy $E2.b		; A4 E2 ; Load $E2.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	ora ($F4.b),Y		; 11 F4 ; OR accumulator with memory ($F4.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	dec $E2.b,X		; D6 E2 ; Decrement memory $E2.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	ora $980F12.l,X		; 1F 12 0F 98 ; Logical OR long $980F12.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($1B.b)		; 32 1B ; AND accumulator with memory (indirect) ($1B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	sbc $FB.b,X		; F5 FB ; Subtract $FB.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $EB.b,X		; F6 EB ; Increment memory $EB.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	rol $94.b,X		; 36 94 ; Rotate left $94.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cpx #$F2.b		; E0 F2 ; Compare #$F2.b with X register [Reads: X Index] [Flags: NCZ]
	.db $10, $E4		; 10 E4 ; Branch if plus to $10, $E4 [Flow: branch]
	inc $114E.w		; EE 4E 11 ; Increment $114E.w [Flags: NZ]
	eor ($94.b),Y		; 51 94 ; Exclusive OR accumulator with memory ($94.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsr $1413.w		; 20 13 14 ; Jump to subroutine at $1413.w [Writes: Stack Pointer] [Flow: call]
	sta $EF.b,X		; 95 EF ; Store accumulator to $EF.b,X [Reads: Accumulator, X Index]
	lda ($E2.b)		; B2 E2 ; Load accumulator (indirect) ($E2.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpy $94.b		; C4 94 ; Compare $94.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	cmp ($FF.b,X)		; C1 FF ; Compare accumulator ($FF.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sbc ($DF.b,X)		; E1 DF ; Subtract with carry ($DF.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $1213.w,X		; 3E 13 12 ; Rotate left $1213.w,X [Reads: X Index] [Flags: NCZ]
	ldy #$20.b		; A0 20 ; Load #$20.b into Y register [Writes: Y Index] [Flags: NZ]
	.db $42, $23		; 42 23 ; Reserved instruction
	and ($02.b,X)		; 21 02 ; Logical AND ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $94.b,S		; 23 94 ; AND accumulator with stack relative $94.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $CF.b,S		; E3 CF ; Subtract stack-relative $CF.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	cmp $11E0D1.l,X		; DF D1 E0 11 ; Compare accumulator (long,X) $11E0D1.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	ora $4E940F.l,X		; 1F 0F 94 4E ; Logical OR long $4E940F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
.INDEX 8
	sep #$13		; E2 13
	sbc ($E3.b)		; F2 E3 ; Subtract with carry (indirect) ($E3.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $94F110.l		; 0F 10 F1 94 ; OR accumulator with memory (long) $94F110.l [Writes: Accumulator] [Flags: NZ]
	bit $2E1F.w,X		; 3C 1F 2E ; Test bits $2E1F.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	cpx #$F0.b		; E0 F0 ; Compare #$F0.b with X register [Reads: X Index] [Flags: NCZ]
	brk $94.b		; 00 94 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
.ACCU 16
.INDEX 16
	rep #$F3		; C2 F3
.ACCU 8
.INDEX 8
	sep #$F4		; E2 F4
	cmp ($00.b),Y		; D1 00 ; Compare accumulator ($00.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	sbc $00.b,S		; E3 00 ; Subtract stack-relative $00.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	sty $F2.b,X		; 94 F2 ; Store Y register $F2.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	sbc $0E.b,S		; E3 0E ; Subtract stack-relative $0E.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	ora ($E4.b),Y		; 11 E4 ; OR accumulator with memory ($E4.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($E3.b,X)		; C1 E3 ; Compare accumulator ($E3.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	sbc ($80.b,S),Y		; F3 80 ; Subtract with carry (stack relative indirect indexed) ($80.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$DE.b		; C0 DE ; Compare #$DE.b with Y register [Reads: Y Index] [Flags: NCZ]
	cmp #$9B.b		; C9 9B ; Compare #$9B.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp $F12DFB.l		; CF FB 2D F1 ; Compare accumulator (long) $F12DFB.l [Reads: Accumulator] [Flags: NCZ]
	.db $80, $A2		; 80 A2 ; Branch always to $80, $A2 [Flow: branch]
	bit $46F1.w		; 2C F1 46 ; Test bits $46F1.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	and ($20.b),Y		; 31 20 ; AND accumulator with memory ($20.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr $55.b		; 46 55 ; Logical shift right $55.b [Reads: Direct Page] [Flags: NCZ]
	.db $80, $E1		; 80 E1 ; Branch always to $80, $E1 [Flow: branch]
	and ($23.b),Y		; 31 23 ; AND accumulator with memory ($23.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $C0FC.w,X		; FD FC C0 ; Subtract with carry $C0FC.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $90D1.w		; 0D D1 90 ; Logical OR $90D1.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cpy #$FE.b		; C0 FE ; Compare #$FE.b with Y register [Reads: Y Index] [Flags: NCZ]
	asl $F1E1.w		; 0E E1 F1 ; Arithmetic shift left $F1E1.w [Flags: NCZ]
	and $2403.w		; 2D 03 24 ; Logical AND $2403.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $90, $13		; 90 13 ; Branch if carry clear to $90, $13 [Flow: branch]
	rol $143F.w		; 2E 3F 14 ; Rotate left $143F.w [Flags: NCZ]
.ACCU 16
	rep #$E0		; C2 E0
	and $900F.w		; 2D 0F 90 ; Logical AND $900F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $0E0C.w		; 0C 0C 0E ; Test and set bits $0E0C.w [Reads: Accumulator] [Flags: Z]
	sbc ($F2.b)		; F2 F2 ; Subtract with carry (indirect) ($F2.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $2F0F90.l		; 0F 90 0F 2F ; OR accumulator with memory (long) $2F0F90.l [Writes: Accumulator] [Flags: NZ]
	sbc $41F5.w		; ED F5 41 ; Subtract $41F5.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ora $742332.l		; 0F 32 23 74 ; OR accumulator with memory (long) $742332.l [Writes: Accumulator] [Flags: NZ]
	lda $B730BD.l		; AF BD 30 B7 ; Load long $B730BD.l into accumulator [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	eor $0EE6.w,X		; 5D E6 0E ; Exclusive OR accumulator with memory $0EE6.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $90, $0F		; 90 0F ; Branch if carry clear to $90, $0F [Flow: branch]
	ora $FC20.w,X		; 1D 20 FC ; OR accumulator with memory $FC20.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $F0ED.w		; EE ED F0 ; Increment $F0ED.w [Flags: NZ]
	cop $84.b		; 02 84 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $2F,$C2		; 44 C2 2F ; Move block positive $2F,$C2 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	and $CF.b,S		; 23 CF ; AND accumulator with stack relative $CF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $DFCF.w,X		; 1D CF DF ; OR accumulator with memory $DFCF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sty $DF.b		; 84 DF ; Store Y register to $DF.b [Reads: Y Index]
	sbc $2EF2.w,X		; FD F2 2E ; Subtract with carry $2EF2.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $50, $12		; 50 12 ; Branch if overflow clear to $50, $12 [Flow: branch]
	cop $10.b		; 02 10 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $4F.b		; 84 4F ; Store Y register to $4F.b [Reads: Y Index]
	ora $E3.b,S		; 03 E3 ; OR accumulator with stack relative $E3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $BCE2E0.l,X		; DF E0 E2 BC ; Compare accumulator (long,X) $BCE2E0.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	.db $10, $84		; 10 84 ; Branch if plus to $10, $84 [Flow: branch]
	cmp ($11.b,S),Y		; D3 11 ; Compare accumulator (stack relative indirect indexed) ($11.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	ora $305F60.l		; 0F 60 5F 30 ; OR accumulator with memory (long) $305F60.l [Writes: Accumulator] [Flags: NZ]
	sbc ($10.b,X)		; E1 10 ; Subtract with carry ($10.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sty $E0.b		; 84 E0 ; Store Y register to $E0.b [Reads: Y Index]
	cmp $0CEFCF.l		; CF CF EF 0C ; Compare accumulator (long) $0CEFCF.l [Reads: Accumulator] [Flags: NCZ]
	sbc ($2F.b,X)		; E1 2F ; Subtract with carry ($2F.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $84		; 30 84 ; Branch if minus to $30, $84 [Flow: branch]
	eor $705E42.l		; 4F 42 5E 70 ; Exclusive OR accumulator with memory (long) $705E42.l [Writes: Accumulator] [Flags: NZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx #$1F.b		; A2 1F ; Load #$1F.b into X register [Writes: X Index] [Flags: NZ]
	sty $CC.b		; 84 CC ; Store Y register to $CC.b [Reads: Y Index]
	inc $E1FF.w		; EE FF E1 ; Increment $E1FF.w [Flags: NZ]
	ora ($EC.b),Y		; 11 EC ; OR accumulator with memory ($EC.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $4584.w,X		; 1D 84 45 ; OR accumulator with memory $4584.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($11.b),Y		; F1 11 ; Subtract with carry ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $BA24FD.l		; 6F FD 24 BA ; Add with carry (long) $BA24FD.l [Writes: Accumulator] [Flags: NCVZ]
	jsl $B1CE84.l		; 22 84 CE B1 ; Jump to subroutine long $B1CE84.l [Writes: Stack Pointer] [Flow: call]
	and $0FF202.l,X		; 3F 02 F2 0F ; AND accumulator with memory (long,X) $0FF202.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	bit $0B.b,X		; 34 0B ; Test bits $0B.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sty $22.b		; 84 22 ; Store Y register to $22.b [Reads: Y Index]
	.db $F0, $FF		; F0 FF ; Branch if equal to $F0, $FF [Flow: branch]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	cmp $CE50.w,X		; DD 50 CE ; Compare accumulator $CE50.w,X [Reads: X Index] [Flags: NCZ]
	ora ($84.b),Y		; 11 84 ; OR accumulator with memory ($84.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $5A23.w		; 2D 23 5A ; Logical AND $5A23.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $7E.b,S		; 03 7E ; OR accumulator with stack relative $7E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $84FA23.l		; EF 23 FA 84 ; Subtract with carry (long) $84FA23.l [Writes: Accumulator] [Flags: NCVZ]
	ora ($EA.b),Y		; 11 EA ; OR accumulator with memory ($EA.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $7A.b,S		; E3 7A ; Subtract stack-relative $7A.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	cpx $3150.w		; EC 50 31 ; Compare $3150.w with X register [Reads: X Index] [Flags: NCZ]
	sbc ($74.b)		; F2 74 ; Subtract with carry (indirect) ($74.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	stz $FD.b		; 64 FD ; Store zero to $FD.b
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	and $EF6ADC.l		; 2F DC 6A EF ; AND accumulator with memory (long) $EF6ADC.l [Writes: Accumulator] [Flags: NZ]
	sty $6A.b		; 84 6A ; Store Y register to $6A.b [Reads: Y Index]
	asl $401F.w,X		; 1E 1F 40 ; Arithmetic shift left $401F.w,X [Reads: X Index] [Flags: NCZ]
	cop $1F.b		; 02 1F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $10, $78		; 10 78 ; Branch if plus to $10, $78 [Flow: branch]
	pea $3EB0.w		; F4 B0 3E ; Push absolute address $3EB0.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	cmp ($1D.b,S),Y		; D3 1D ; Compare accumulator (stack relative indirect indexed) ($1D.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	rol $53D2.w		; 2E D2 53 ; Rotate left $53D2.w [Flags: NCZ]
	sty $E3.b		; 84 E3 ; Store Y register to $E3.b [Reads: Y Index]
	ora ($5F.b),Y		; 11 5F ; OR accumulator with memory ($5F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sep #$01		; E2 01 ; Set processor status bits #$01 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	tsb $3E.b		; 04 3E ; Test and set bits $3E.b [Reads: Accumulator] [Flags: Z]
	and $4298.w,Y		; 39 98 42 ; AND accumulator with memory $4298.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $2001.w		; ED 01 20 ; Subtract $2001.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	brk $C1.b		; 00 C1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($44.b,S),Y		; D3 44 ; Compare accumulator (stack relative indirect indexed) ($44.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	asl $00FE.w		; 0E FE 00 ; Arithmetic shift left $00FE.w [Flags: NCZ]
	jsl $1F0C2E.l		; 22 2E 0C 1F ; Jump to subroutine long $1F0C2E.l [Writes: Stack Pointer] [Flow: call]
	and $3D4194.l		; 2F 94 41 3D ; AND accumulator with memory (long) $3D4194.l [Writes: Accumulator] [Flags: NZ]
	cmp $F2CD.w,X		; DD CD F2 ; Compare accumulator $F2CD.w,X [Reads: X Index] [Flags: NCZ]
	and ($2D.b)		; 32 2D ; AND accumulator with memory (indirect) ($2D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $3F6E88.l		; 0F 88 6E 3F ; OR accumulator with memory (long) $3F6E88.l [Writes: Accumulator] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	ora $4F02FD.l,X		; 1F FD 02 4F ; Logical OR long $4F02FD.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	trb $1D88.w		; 1C 88 1D ; Test and reset bits $1D88.w [Reads: Accumulator] [Flags: Z]
	cop $F1.b		; 02 F1 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($01.b),Y		; F1 01 ; Subtract with carry ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	ora $8851.w		; 0D 51 88 ; Logical OR $8851.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc ($1D.b)		; F2 1D ; Subtract with carry (indirect) ($1D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$5D.b		; C0 5D ; Compare #$5D.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $30, $FC		; 30 FC ; Branch if minus to $30, $FC [Flow: branch]
	and $942D.w,X		; 3D 2D 94 ; AND accumulator with memory $942D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $FF20.w,X		; FD 20 FF ; Subtract with carry $FF20.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $24022D.l		; 2F 2D 02 24 ; AND accumulator with memory (long) $24022D.l [Writes: Accumulator] [Flags: NZ]
	and ($94.b,X)		; 21 94 ; Logical AND ($94.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc ($33.b),Y		; F1 33 ; Subtract with carry ($33.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $CB23CF.l,X		; FF CF 23 CB ; Subtract with carry (long,X) $CB23CF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$02.b		; C0 02 ; Compare #$02.b with Y register [Reads: Y Index] [Flags: NCZ]
	sty $1D.b,X		; 94 1D ; Store Y register $1D.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	.db $F0, $13		; F0 13 ; Branch if equal to $F0, $13 [Flow: branch]
	asl $34F0.w,X		; 1E F0 34 ; Arithmetic shift left $34F0.w,X [Reads: X Index] [Flags: NCZ]
	ora $4384E0.l,X		; 1F E0 84 43 ; Logical OR long $4384E0.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $3D24.w,X		; DD 24 3D ; Compare accumulator $3D24.w,X [Reads: X Index] [Flags: NCZ]
	dec $F1FC.w,X		; DE FC F1 ; Decrement memory $F1FC.w,X [Reads: X Index] [Flags: NZ]
	ora $2C84.w		; 0D 84 2C ; Logical OR $2C84.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $53F4.w,X		; FD F4 53 ; Subtract with carry $53F4.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
.ACCU 8
	sep #$23		; E2 23
	eor $88.b,S		; 43 88 ; Exclusive OR accumulator with stack relative $88.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp ($FF.b),Y		; D1 FF ; Compare accumulator ($FF.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	jsr $1B4D.w		; 20 4D 1B ; Jump to subroutine at $1B4D.w [Writes: Stack Pointer] [Flow: call]
	ora $780F42.l		; 0F 42 0F 78 ; OR accumulator with memory (long) $780F42.l [Writes: Accumulator] [Flags: NZ]
	lda $6230.w		; AD 30 62 ; Load $6230.w into accumulator [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	bit $61CE.w,X		; 3C CE 61 ; Test bits $61CE.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	lsr $1F84.w,X		; 5E 84 1F ; Logical shift right $1F84.w,X [Reads: X Index] [Flags: NCZ]
	sbc $01F0.w		; ED F0 01 ; Subtract $01F0.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ora $04CEFC.l,X		; 1F FC CE 04 ; Logical OR long $04CEFC.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $F0, $FC		; F0 FC ; Branch if equal to $F0, $FC [Flow: branch]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $F2		; F0 F2 ; Branch if equal to $F0, $F2 [Flow: branch]
	lsr $78D0.w,X		; 5E D0 78 ; Logical shift right $78D0.w,X [Reads: X Index] [Flags: NCZ]
	sbc $F3.b,S		; E3 F3 ; Subtract stack-relative $F3.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	sbc ($F1.b,S),Y		; F3 F1 ; Subtract with carry (stack relative indirect indexed) ($F1.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	lda $03F6.w		; AD F6 03 ; Load $03F6.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp $E00078.l,X		; DF 78 00 E0 ; Compare accumulator (long,X) $E00078.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ror $631C.w		; 6E 1C 63 ; Rotate right $631C.w [Flags: NCZ]
	cmp ($84.b),Y		; D1 84 ; Compare accumulator ($84.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	sbc $13FD.w,X		; FD FD 13 ; Subtract with carry $13FD.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	pea $0ECD.w		; F4 CD 0E ; Push absolute address $0ECD.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	eor $D1841F.l		; 4F 1F 84 D1 ; Exclusive OR accumulator with memory (long) $D1841F.l [Writes: Accumulator] [Flags: NZ]
	ora $3EFFEE.l		; 0F EE FF 3E ; OR accumulator with memory (long) $3EFFEE.l [Writes: Accumulator] [Flags: NZ]
	eor $74605B.l		; 4F 5B 60 74 ; Exclusive OR accumulator with memory (long) $74605B.l [Writes: Accumulator] [Flags: NZ]
	sbc [$C1.b]		; E7 C1 ; Subtract with carry (long) [$C1.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp $30.b,S		; C3 30 ; Compare accumulator (stack relative) $30.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	lda ($F2.b,X)		; A1 F2 ; Load accumulator ($F2.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ldx #$12.b		; A2 12 ; Load #$12.b into X register [Writes: X Index] [Flags: NZ]
	stz $0C.b,X		; 74 0C ; Store zero to $0C.b,X [Reads: X Index]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	sbc ($E1.b),Y		; F1 E1 ; Subtract with carry ($E1.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx $B2.b		; E4 B2 ; Compare $B2.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	cmp $01.b,X		; D5 01 ; Compare accumulator $01.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	stz $F1.b,X		; 74 F1 ; Store zero to $F1.b,X [Reads: X Index]
	rol $1543.w		; 2E 43 15 ; Rotate left $1543.w [Flags: NCZ]
	.db $D0, $CD		; D0 CD ; Branch if not equal to $D0, $CD [Flow: branch]
	jsr $64FF.w		; 20 FF 64 ; Jump to subroutine at $64FF.w [Writes: Stack Pointer] [Flow: call]
	ora $DFE0.w		; 0D E0 DF ; Logical OR $DFE0.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cpx #$34.b		; E0 34 ; Compare #$34.b with X register [Reads: X Index] [Flags: NCZ]
	sep #$0E		; E2 0E ; Set processor status bits #$0E [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	stz $2F.b		; 64 2F ; Store zero to $2F.b
	inc $B3.b,X		; F6 B3 ; Increment memory $B3.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	bit $6F.b		; 24 6F ; Test bits $6F.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora $6805BE.l,X		; 1F BE 05 68 ; Logical OR long $6805BE.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta ($A1.b),Y		; 91 A1 ; Store accumulator ($A1.b),Y [Reads: Direct Page, Y Index, Accumulator]
	mvn $C5,$FB		; 54 FB C5 ; Move block negative $C5,$FB [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	stz $03.b,X		; 74 03 ; Store zero to $03.b,X [Reads: X Index]
	mvn $CC,$0D		; 54 0D CC ; Move block negative $CC,$0D [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sbc $CFFE34.l,X		; FF 34 FE CF ; Subtract with carry (long,X) $CFFE34.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sty $03.b		; 84 03 ; Store Y register to $03.b [Reads: Y Index]
	and ($10.b,S),Y		; 33 10 ; AND accumulator (stack relative indirect indexed) ($10.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $0FEE.w,X		; FD EE 0F ; Subtract with carry $0FEE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($D0.b,X)		; 01 D0 ; Logical OR ($D0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cpx #$26.b		; E0 26 ; Compare #$26.b with X register [Reads: X Index] [Flags: NCZ]
	.db $F0, $9B		; F0 9B ; Branch if equal to $F0, $9B [Flow: branch]
	eor $3B.b,X		; 55 3B ; Exclusive OR accumulator with memory $3B.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lda $3F.b		; A5 3F ; Load $3F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cmp ($23.b,X)		; C1 23 ; Compare accumulator ($23.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	bit $2E.b		; 24 2E ; Test bits $2E.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sbc ($30.b,X)		; E1 30 ; Subtract with carry ($30.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $5478.w,X		; DD 78 54 ; Compare accumulator $5478.w,X [Reads: X Index] [Flags: NCZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	sbc $30.b,S		; E3 30 ; Subtract stack-relative $30.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	cmp ($21.b)		; D2 21 ; Compare accumulator (indirect) ($21.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp ($22.b),Y		; D1 22 ; Compare accumulator ($22.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	stz $40.b,X		; 74 40 ; Store zero to $40.b,X [Reads: X Index]
	ora $A2CD.w		; 0D CD A2 ; Logical OR $A2CD.w with accumulator [Writes: Accumulator] [Flags: NZ]
	inc $13EF.w		; EE EF 13 ; Increment $13EF.w [Flags: NZ]
	eor ($64.b,S),Y		; 53 64 ; XOR accumulator (stack relative indirect indexed) ($64.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $DF0FCB.l		; 22 CB 0F DF ; Jump to subroutine long $DF0FCB.l [Writes: Stack Pointer] [Flow: call]
.INDEX 16
	rep #$13		; C2 13
	ora ($71.b)		; 12 71 ; OR accumulator with memory (indirect) ($71.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	stz $2D.b,X		; 74 2D ; Store zero to $2D.b,X [Reads: X Index]
	sbc ($20.b,X)		; E1 20 ; Subtract with carry ($20.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $FD0010.l		; CF 10 00 FD ; Compare accumulator (long) $FD0010.l [Reads: Accumulator] [Flags: NCZ]
	ora $4EF074.l,X		; 1F 74 F0 4E ; Logical OR long $4EF074.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($41.b,S),Y		; F3 41 ; Subtract with carry (stack relative indirect indexed) ($41.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	jsl $B010EF.l		; 22 EF 10 B0 ; Jump to subroutine long $B010EF.l [Writes: Stack Pointer] [Flow: call]
	stz $ED.b,X		; 74 ED ; Store zero to $ED.b,X [Reads: X Index]
	sbc ($E2.b,X)		; E1 E2 ; Subtract with carry ($E2.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	mvp $FF,$1E		; 44 1E FF ; Move block positive $FF,$1E [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	pea $64FF.w		; F4 FF 64 ; Push absolute address $64FF.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	trb $C7FE.w		; 1C FE C7 ; Test and reset bits $C7FE.w [Reads: Accumulator] [Flags: Z]
	adc ($D0.b,S),Y		; 73 D0 ; Add with carry (stack relative indirect indexed) ($D0.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $74.b		; 06 74 ; Arithmetic shift left $74.b [Reads: Direct Page] [Flags: NCZ]
	sbc $210D.w,X		; FD 0D 21 ; Subtract with carry $210D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $E00F.w		; 0E 0F E0 ; Arithmetic shift left $E00F.w [Flags: NCZ]
	.db $42, $21		; 42 21 ; Reserved instruction
	stz $2E.b,X		; 74 2E ; Store zero to $2E.b,X [Reads: X Index]
	cpx #$FDF2.w		; E0 F2 FD ; Compare #$FDF2.w with X register [Reads: X Index] [Flags: NCZ]
	jsr ($2040.w,X)		; FC 40 20 ; Jump to subroutine indirect indexed ($2040.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sep #$00		; E2 00 ; Set processor status bits #$00 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	rol $0E4E.w,X		; 3E 4E 0E ; Rotate left $0E4E.w,X [Reads: X Index] [Flags: NCZ]
	.db $B0, $74		; B0 74 ; Branch if carry set to $B0, $74 [Flow: branch]
	stx $EE.b,Y		; 96 EE ; Store X register $EE.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc $DFE435.l		; 6F 35 E4 DF ; Add with carry (long) $DFE435.l [Writes: Accumulator] [Flags: NCVZ]
	and $6F70.w		; 2D 70 6F ; Logical AND $6F70.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jsr ($D19D.w,X)		; FC 9D D1 ; Jump to subroutine indirect indexed ($D19D.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cop $F0.b		; 02 F0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($31.b)		; F2 31 ; Subtract with carry (indirect) ($31.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $F0, $3F		; F0 3F ; Branch if equal to $F0, $3F [Flow: branch]
	ora ($DE.b),Y		; 11 DE ; OR accumulator with memory ($DE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	pea $3DE4.w		; F4 E4 3D ; Push absolute address $3DE4.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	inc $B388.w,X		; FE 88 B3 ; Increment memory $B388.w,X [Reads: X Index] [Flags: NZ]
	eor ($DF.b,S),Y		; 53 DF ; XOR accumulator (stack relative indirect indexed) ($DF.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$2241]		; DC 41 22 ; Jump long indirect [$2241] [Flow: jump]
	jsr ($88E2.w,X)		; FC E2 88 ; Jump to subroutine indirect indexed ($88E2.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	pea $DF5C.w		; F4 5C DF ; Push absolute address $DF5C.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
.ACCU 8
.INDEX 8
	sep #$32		; E2 32
	sbc $330E.w		; ED 0E 33 ; Subtract $330E.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sty $55.b		; 84 55 ; Store Y register to $55.b [Reads: Y Index]
	sbc $0213CB.l		; EF CB 13 02 ; Subtract with carry (long) $0213CB.l [Writes: Accumulator] [Flags: NCVZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	cpx #$23.b		; E0 23 ; Compare #$23.b with X register [Reads: X Index] [Flags: NCZ]
	stz $20.b,X		; [PATTERN: Memory clearing operation] 74 20 ; Store zero to $20.b,X [Reads: X Index]
	cmp $FE4332.l		; CF 32 43 FE ; Compare accumulator (long) $FE4332.l [Reads: Accumulator] [Flags: NCZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	inc $EC.b,X		; F6 EC ; Increment memory $EC.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	stz $3C.b,X		; 74 3C ; Store zero to $3C.b,X [Reads: X Index]
	cop $ED.b		; 02 ED ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $D0, $4E		; D0 4E ; Branch if not equal to $D0, $4E [Flow: branch]
	.db $50, $DF		; 50 DF ; Branch if overflow clear to $50, $DF [Flow: branch]
	sbc ($78.b)		; F2 78 ; Subtract with carry (indirect) ($78.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($C0.b,S),Y		; F3 C0 ; Subtract with carry (stack relative indirect indexed) ($C0.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$50.b		; E0 50 ; Compare #$50.b with X register [Reads: X Index] [Flags: NCZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	cmp ($C7.b),Y		; D1 C7 ; Compare accumulator ($C7.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	and $84.b		; 25 84 ; Logical AND $84.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $E2DF.w,X		; 1E DF E2 ; Arithmetic shift left $E2DF.w,X [Reads: X Index] [Flags: NCZ]
	and ($1F.b,X)		; 21 1F ; Logical AND ($1F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpx #$02.b		; E0 02 ; Compare #$02.b with X register [Reads: X Index] [Flags: NCZ]
	.db $10, $84		; 10 84 ; Branch if plus to $10, $84 [Flow: branch]
	asl $F110.w,X		; 1E 10 F1 ; Arithmetic shift left $F110.w,X [Reads: X Index] [Flags: NCZ]
	sbc ($0E.b),Y		; F1 0E ; Subtract with carry ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp ($D5.b)		; D2 D5 ; Compare accumulator (indirect) ($D5.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	pei ($80.b)		; D4 80 ; Push effective indirect address ($80.b) [Reads: Direct Page] [Writes: Stack Pointer]
	inc $C1DD.w,X		; FE DD C1 ; Increment memory $C1DD.w,X [Reads: X Index] [Flags: NZ]
	and ($21.b)		; 32 21 ; AND accumulator with memory (indirect) ($21.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($14.b),Y		; 11 14 ; OR accumulator with memory ($14.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsr $1D74.w		; 20 74 1D ; Jump to subroutine at $1D74.w [Writes: Stack Pointer] [Flow: call]
	sbc $AE.b,X		; F5 AE ; Subtract $AE.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $D20E01.l,X		; 3F 01 0E D2 ; AND accumulator with memory (long,X) $D20E01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpx $74.b		; E4 74 ; Compare $74.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	trb $3E.b		; 14 3E ; Test and reset bits $3E.b [Reads: Accumulator] [Flags: Z]
	sbc $1E2F20.l,X		; FF 20 2F 1E ; Subtract with carry (long,X) $1E2F20.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($DF.b),Y		; [PATTERN: Memory clearing operation] F1 DF ; Subtract with carry ($DF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	stz $0E.b,X		; 74 0E ; Store zero to $0E.b,X [Reads: X Index]
	sbc $3130FF.l		; EF FF 30 31 ; Subtract with carry (long) $3130FF.l [Writes: Accumulator] [Flags: NCVZ]
	inc $17E5.w,X		; FE E5 17 ; Increment memory $17E5.w,X [Reads: X Index] [Flags: NZ]
	stz $0C.b,X		; 74 0C ; Store zero to $0C.b,X [Reads: X Index]
	sbc $CE.b,S		; E3 CE ; Subtract stack-relative $CE.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	and ($20.b,X)		; 21 20 ; Logical AND ($20.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsr ($CEF0.w,X)		; FC F0 CE ; Jump to subroutine indirect indexed ($CEF0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	stz $20.b,X		; 74 20 ; Store zero to $20.b,X [Reads: X Index]
	asl $0232.w,X		; 1E 32 02 ; Arithmetic shift left $0232.w,X [Reads: X Index] [Flags: NCZ]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp ($A4.b,S),Y		; D3 A4 ; Compare accumulator (stack relative indirect indexed) ($A4.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	sty $01.b		; 84 01 ; Store Y register to $01.b [Reads: Y Index]
	sbc ($C3.b)		; F2 C3 ; Subtract with carry (indirect) ($C3.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $0FFE0F.l		; EF 0F FE 0F ; Subtract with carry (long) $0FFE0F.l [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $84		; F0 84 ; Branch if equal to $F0, $84 [Flow: branch]
	jsl $32D304.l		; 22 04 D3 32 ; Jump to subroutine long $32D304.l [Writes: Stack Pointer] [Flow: call]
	cmp ($D1.b,X)		; C1 D1 ; Compare accumulator ($D1.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $80, $FD		; 80 FD ; Branch always to $80, $FD [Flow: branch]
	dec $00D0.w		; CE D0 00 ; Decrement $00D0.w [Flags: NZ]
	asl $E5EE.w		; 0E EE E5 ; Arithmetic shift left $E5EE.w [Flags: NCZ]
	lsr $2E80.w		; 4E 80 2E ; Logical shift right $2E80.w [Flags: NCZ]
	sbc $43.b		; E5 43 ; Subtract $43.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	eor ($F3.b,S),Y		; 53 F3 ; XOR accumulator (stack relative indirect indexed) ($F3.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $900BAE.l		; CF AE 0B 90 ; Compare accumulator (long) $900BAE.l [Reads: Accumulator] [Flags: NCZ]
	ora $220CD0.l,X		; 1F D0 0C 22 ; Logical OR long $220CD0.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $1C.b,S		; 03 1C ; OR accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc ($D0.b),Y		; F1 D0 ; Subtract with carry ($D0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sty $32.b		; 84 32 ; Store Y register to $32.b [Reads: Y Index]
	bit $0BC4.w,X		; 3C C4 0B ; Test bits $0BC4.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	ora ($CF.b),Y		; 11 CF ; OR accumulator with memory ($CF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($4F.b),Y		; F1 4F ; Subtract with carry ($4F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sty $F0.b		; 84 F0 ; Store Y register to $F0.b [Reads: Y Index]
	lsr $3953.w		; 4E 53 39 ; Logical shift right $3953.w [Flags: NCZ]
	and $A2FF.w		; 2D FF A2 ; Logical AND $A2FF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	sty $10.b,X		; 94 10 ; Store Y register $10.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	ora ($FF.b,S),Y		; 13 FF ; OR accumulator (stack relative indirect indexed) ($FF.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lsr $E1DF.w		; 4E DF E1 ; Logical shift right $E1DF.w [Flags: NCZ]
	sbc $0384F2.l		; EF F2 84 03 ; Subtract with carry (long) $0384F2.l [Writes: Accumulator] [Flags: NCVZ]
	sbc $61711D.l,X		; FF 1D 71 61 ; Subtract with carry (long,X) $61711D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($F0.b),Y		; F1 F0 ; Subtract with carry ($F0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	trb $0198.w		; 1C 98 01 ; Test and reset bits $0198.w [Reads: Accumulator] [Flags: Z]
	bit $0D.b		; 24 0D ; Test bits $0D.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sbc $03FFC1.l,X		; FF C1 FF 03 ; Subtract with carry (long,X) $03FFC1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $98.b,X		; D5 98 ; Compare accumulator $98.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	lsr $2C01.w		; 4E 01 2C ; Logical shift right $2C01.w [Flags: NCZ]
	rol $1EDE.w,X		; 3E DE 1E ; Rotate left $1EDE.w,X [Reads: X Index] [Flags: NCZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sty $11.b,X		; 94 11 ; Store Y register $11.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	asl $F0.b,X		; 16 F0 ; Arithmetic shift left $F0.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $11A2.w		; CE A2 11 ; Decrement $11A2.w [Flags: NZ]
	ldy $10.b		; A4 10 ; Load $10.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	bit $21.b		; 24 21 ; Test bits $21.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sbc $21E1.w		; ED E1 21 ; Subtract $21E1.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ldx $9800.w,Y		; BE 00 98 ; Load X register $9800.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ora $DF42.w		; 0D 42 DF ; Logical OR $DF42.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp.w [$40F1]		; DC F1 40 ; Jump long indirect [$40F1] [Flow: jump]
	sty $7D.b		; 84 7D ; Store Y register to $7D.b [Reads: Y Index]
	ldx $FB33.w		; AE 33 FB ; Load $FB33.w into X register [Writes: X Index] [Flags: NZ]
	sbc $F2222E.l,X		; FF 2E 22 F2 ; Subtract with carry (long,X) $F2222E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $220E.w,X		; 1D 0E 22 ; OR accumulator with memory $220E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	sbc $D1CF22.l,X		; FF 22 CF D1 ; Subtract with carry (long,X) $D1CF22.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $20.b,X		; F5 20 ; Subtract $20.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx $00.b		; E4 00 ; Compare $00.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $F2C1.w		; 0D C1 F2 ; Logical OR $F2C1.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $2F88.w		; 2D 88 2F ; Logical AND $2F88.w with accumulator [Writes: Accumulator] [Flags: NZ]
	bit $EE.b,X		; 34 EE ; Test bits $EE.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cmp $21.b,S		; C3 21 ; Compare accumulator (stack relative) $21.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	cpx #$FC.b		; E0 FC ; Compare #$FC.b with X register [Reads: X Index] [Flags: NCZ]
	ror $98.b,X		; 76 98 ; Rotate right $98.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc $2296A5.l,X		; FF A5 96 22 ; Subtract with carry (long,X) $2296A5.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $B00B.w,X		; 3C 0B B0 ; Test bits $B00B.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	sbc ($A8.b)		; F2 A8 ; Subtract with carry (indirect) ($A8.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($11.b,S),Y		; 13 11 ; OR accumulator (stack relative indirect indexed) ($11.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $E3		; F0 E3 ; Branch if equal to $F0, $E3 [Flow: branch]
.INDEX 16
	rep #$D2		; C2 D2
	ora ($E3.b,X)		; 01 E3 ; Logical OR ($E3.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ldy $B1.b		; A4 B1 ; Load $B1.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	cmp ($C1.b,X)		; C1 C1 ; Compare accumulator ($C1.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	sbc $2610.w,X		; FD 10 26 ; Subtract with carry $2610.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $21.b		; 24 21 ; Test bits $21.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	cpx #$E2F1.w		; E0 F1 E2 ; Compare #$E2F1.w with X register [Reads: X Index] [Flags: NCZ]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	sbc ($2E.b,X)		; E1 2E ; Subtract with carry ($2E.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $FF01B4.l		; 4F B4 01 FF ; Exclusive OR accumulator with memory (long) $FF01B4.l [Writes: Accumulator] [Flags: NZ]
	sbc $01E10F.l		; EF 0F E1 01 ; Subtract with carry (long) $01E10F.l [Writes: Accumulator] [Flags: NCVZ]
	ora ($E4.b,X)		; 01 E4 ; Logical OR ($E4.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ldy $23.b		; A4 23 ; Load $23.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	inc $F01A.w		; EE 1A F0 ; Increment $F01A.w [Flags: NZ]
	and ($04.b,X)		; 21 04 ; Logical AND ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $0EB8E0.l,X		; FF E0 B8 0E ; Subtract with carry (long,X) $0EB8E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr $10F1.w		; 20 F1 10 ; Jump to subroutine at $10F1.w [Writes: Stack Pointer] [Flow: call]
	cmp ($E2.b)		; D2 E2 ; Compare accumulator (indirect) ($E2.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	jmp $FDB41B.l		; 5C 1B B4 FD ; Jump long to $FDB41B.l [Flow: jump]
	cmp ($03.b),Y		; D1 03 ; Compare accumulator ($03.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	bit $D11F.w,X		; 3C 1F D1 ; Test bits $D11F.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	cop $2E.b		; 02 2E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $4F.b,X		; B4 4F ; Load Y register $4F.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	asl $C2C0.w,X		; 1E C0 C2 ; Arithmetic shift left $C2C0.w,X [Reads: X Index] [Flags: NCZ]
	and ($5F.b,X)		; 21 5F ; Logical AND ($5F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $B4E0.w		; 0E E0 B4 ; Arithmetic shift left $B4E0.w [Flags: NCZ]
	sbc $F1.b,X		; F5 F1 ; Subtract $F1.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $F1FE.w,X		; FE FE F1 ; Increment memory $F1FE.w,X [Reads: X Index] [Flags: NZ]
	jsl $B43E42.l		; 22 42 3E B4 ; Jump to subroutine long $B43E42.l [Writes: Stack Pointer] [Flow: call]
	cmp $F0FC.w		; CD FC F0 ; Compare $F0FC.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ror $0EE3.w		; 6E E3 0E ; Rotate right $0EE3.w [Flags: NCZ]
	ora ($B3.b),Y		; 11 B3 ; OR accumulator with memory ($B3.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ldy $F0.b,X		; B4 F0 ; Load Y register $F0.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	ora ($04.b,S),Y		; 13 04 ; OR accumulator (stack relative indirect indexed) ($04.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sep #$C0		; E2 C0 ; Set processor status bits #$C0 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	cmp ($2F.b,S),Y		; D3 2F ; Compare accumulator (stack relative indirect indexed) ($2F.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	asl $31A4.w		; 0E A4 31 ; Arithmetic shift left $31A4.w [Flags: NCZ]
	sbc ($1C.b),Y		; F1 1C ; Subtract with carry ($1C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $EF.b,X		; F6 EF ; Increment memory $EF.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	lda ($D2.b),Y		; B1 D2 ; Load accumulator ($D2.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsr ($0FB4.w,X)		; FC B4 0F ; Jump to subroutine indirect indexed ($0FB4.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	trb $21.b		; 14 21 ; Test and reset bits $21.b [Reads: Accumulator] [Flags: Z]
	cmp ($5C.b)		; D2 5C ; Compare accumulator (indirect) ($5C.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	bit $ED1C.w		; 2C 1C ED ; Test bits $ED1C.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	ora ($22.b,S),Y		; 13 22 ; OR accumulator (stack relative indirect indexed) ($22.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp ($DD.b),Y		; D1 DD ; Compare accumulator ($DD.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	ora $FFE142.l		; 0F 42 E1 FF ; OR accumulator with memory (long) $FFE142.l [Writes: Accumulator] [Flags: NZ]
	ldy $10.b,X		; B4 10 ; Load Y register $10.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $C103F3.l		; 2F F3 03 C1 ; AND accumulator with memory (long) $C103F3.l [Writes: Accumulator] [Flags: NZ]
	brk $B0.b		; 00 B0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $12.b,X		; 34 12 ; Test bits $12.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and ($ED.b,X)		; 21 ED ; Logical AND ($ED.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ldx $E012.w		; AE 12 E0 ; Load $E012.w into X register [Writes: X Index] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	ldy $13.b,X		; B4 13 ; Load Y register $13.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	lsr $AF.b		; 46 AF ; Logical shift right $AF.b [Reads: Direct Page] [Flags: NCZ]
	cmp ($FE.b,S),Y		; D3 FE ; Compare accumulator (stack relative indirect indexed) ($FE.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	cpx #$6DFF.w		; E0 FF 6D ; Compare #$6DFF.w with X register [Reads: X Index] [Flags: NCZ]
	ldy $01.b,X		; B4 01 ; Load Y register $01.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	and $FA1132.l,X		; 3F 32 11 FA ; AND accumulator with memory (long,X) $FA1132.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $52CC.w,X		; 3D CC 52 ; AND accumulator with memory $52CC.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $CB		; B0 CB ; Branch if carry set to $B0, $CB [Flow: branch]
	ora ($F2.b),Y		; 11 F2 ; OR accumulator with memory ($F2.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($36.b,S),Y		; 13 36 ; OR accumulator (stack relative indirect indexed) ($36.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda ($CD.b)		; B2 CD ; Load accumulator (indirect) ($CD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $01		; B0 01 ; Branch if carry set to $B0, $01 [Flow: branch]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $42		; F0 42 ; Branch if equal to $F0, $42 [Flow: branch]
	ora ($B0.b),Y		; 11 B0 ; OR accumulator with memory ($B0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $01CEB0.l		; 22 B0 CE 01 ; Jump to subroutine long $01CEB0.l [Writes: Stack Pointer] [Flow: call]
	jsl $D1F02F.l		; 22 2F F0 D1 ; Jump to subroutine long $D1F02F.l [Writes: Stack Pointer] [Flow: call]
	ora $2E.b,S		; 03 2E ; OR accumulator with stack relative $2E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $0D		; B0 0D ; Branch if carry set to $B0, $0D [Flow: branch]
	.db $42, $C0		; 42 C0 ; Reserved instruction
	sbc $5F15.w,X		; FD 15 5F ; Subtract with carry $5F15.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $B01B.w,X		; DE 1B B0 ; Decrement memory $B01B.w,X [Reads: X Index] [Flags: NZ]
	pei ($F2.b)		; D4 F2 ; Push effective indirect address ($F2.b) [Reads: Direct Page] [Writes: Stack Pointer]
	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($43.b)		; 12 43 ; OR accumulator with memory (indirect) ($43.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr ($B0EF.w,X)		; FC EF B0 ; Jump to subroutine indirect indexed ($B0EF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr $F2E0.w		; 20 E0 F2 ; Jump to subroutine at $F2E0.w [Writes: Stack Pointer] [Flow: call]
	lsr $1E00.w		; 4E 00 1E ; Logical shift right $1E00.w [Flags: NCZ]
	ora ($20.b),Y		; 11 20 ; OR accumulator with memory ($20.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$10C0.w		; C0 C0 10 ; Compare #$10C0.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $30FF.w,X		; DE FF 30 ; Decrement memory $30FF.w,X [Reads: X Index] [Flags: NZ]
	and $330DB4.l		; 2F B4 0D 33 ; AND accumulator with memory (long) $330DB4.l [Writes: Accumulator] [Flags: NZ]
	eor $03DD.w,X		; 5D DD 03 ; Exclusive OR accumulator with memory $03DD.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($1E.b),Y		; 11 1E ; OR accumulator with memory ($1E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($A0.b),Y		; F1 A0 ; Subtract with carry ($A0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $3CFE2F.l,X		; DF 2F FE 3C ; Compare accumulator (long,X) $3CFE2F.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	sbc $FC2E11.l		; EF 11 2E FC ; Subtract with carry (long) $FC2E11.l [Writes: Accumulator] [Flags: NCVZ]
	ldy #$41E2.w		; A0 E2 41 ; Load #$41E2.w into Y register [Writes: Y Index] [Flags: NZ]
	cmp ($F0.b),Y		; D1 F0 ; Compare accumulator ($F0.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
.INDEX 16
	rep #$D5		; C2 D5
	ora ($F3.b)		; 12 F3 ; OR accumulator with memory (indirect) ($F3.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy #$02E5.w		; A0 E5 02 ; Load #$02E5.w into Y register [Writes: Y Index] [Flags: NZ]
	jsr ($D4DF.w,X)		; FC DF D4 ; Jump to subroutine indirect indexed ($D4DF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($A0.b)		; 12 A0 ; OR accumulator with memory (indirect) ($A0.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $CF.b,X		; 34 CF ; Test bits $CF.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora $2F2F.w		; 0D 2F 2F ; Logical OR $2F2F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp $3120.w		; CD 20 31 ; Compare $3120.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $1D		; B0 1D ; Branch if carry set to $B0, $1D [Flow: branch]
	sbc $0012F4.l		; EF F4 12 00 ; Subtract with carry (long) $0012F4.l [Writes: Accumulator] [Flags: NCVZ]
	sbc $A020EE.l		; EF EE 20 A0 ; Subtract with carry (long) $A020EE.l [Writes: Accumulator] [Flags: NCVZ]
	and $1E.b,S		; 23 1E ; AND accumulator with stack relative $1E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($33.b,X)		; 01 33 ; Logical OR ($33.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($EB.b,X)		; 01 EB ; Logical OR ($EB.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $A450.w,X		; FD 50 A4 ; Subtract with carry $A450.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $F2E0.w		; 2E E0 F2 ; Rotate left $F2E0.w [Flags: NCZ]
	ora ($DD.b)		; 12 DD ; OR accumulator with memory (indirect) ($DD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $0311.w,X		; 3E 11 03 ; Rotate left $0311.w,X [Reads: X Index] [Flags: NCZ]
	.db $90, $25		; 90 25 ; Branch if carry clear to $90, $25 [Flow: branch]
	eor $FC51F2.l		; 4F F2 51 FC ; Exclusive OR accumulator with memory (long) $FC51F2.l [Writes: Accumulator] [Flags: NZ]
	jsr ($252E.w,X)		; FC 2E 25 ; Jump to subroutine indirect indexed ($252E.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $90, $4F		; 90 4F ; Branch if carry clear to $90, $4F [Flow: branch]
	bit $0202.w		; 2C 02 02 ; Test bits $0202.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	dec $23BF.w,X		; DE BF 23 ; Decrement memory $23BF.w,X [Reads: X Index] [Flags: NZ]
	asl $02A0.w,X		; 1E A0 02 ; Arithmetic shift left $02A0.w,X [Reads: X Index] [Flags: NCZ]
	ora $1FE5.w,X		; 1D E5 1F ; OR accumulator with memory $1FE5.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $32BF.w		; 0D BF 32 ; Logical OR $32BF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	inc $2490.w,X		; FE 90 24 ; Increment memory $2490.w,X [Reads: X Index] [Flags: NZ]
	eor ($13.b,X)		; 41 13 ; Exclusive OR accumulator with memory ($13.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	inc $3EED.w,X		; FE ED 3E ; Increment memory $3EED.w,X [Reads: X Index] [Flags: NZ]
	bit $90E1.w		; 2C E1 90 ; Test bits $90E1.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	adc ($E3.b,S),Y		; 73 E3 ; Add with carry (stack relative indirect indexed) ($E3.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	and [$3C.b]		; 27 3C ; AND accumulator with memory (long) [$3C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc ($DD.b,X)		; E1 DD ; Subtract with carry ($DD.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
.ACCU 8
	sep #$22		; E2 22
	.db $90, $CA		; 90 CA ; Branch if carry clear to $90, $CA [Flow: branch]
	sbc ($53.b)		; F2 53 ; Subtract with carry (indirect) ($53.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and ($DD.b),Y		; 31 DD ; AND accumulator with memory ($DD.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $90E25D.l,X		; 1F 5D E2 90 ; Logical OR long $90E25D.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda ($F0.b,S),Y		; B3 F0 ; Load accumulator (stack relative indirect indexed) ($F0.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $4C		; D0 4C ; Branch if not equal to $D0, $4C [Flow: branch]
	eor $1F23.w		; 4D 23 1F ; Exclusive OR $1F23.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $FFA0.w		; ED A0 FF ; Subtract $FFA0.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ora $10.b		; 05 10 ; Logical OR $10.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $0F01.w		; ED 01 0F ; Subtract $0F01.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cmp ($03.b),Y		; D1 03 ; Compare accumulator ($03.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	ldy #$10EB.w		; A0 EB 10 ; Load #$10EB.w into Y register [Writes: Y Index] [Flags: NZ]
	trb $FC.b		; 14 FC ; Test and reset bits $FC.b [Reads: Accumulator] [Flags: Z]
	sbc ($0F.b)		; F2 0F ; Subtract with carry (indirect) ($0F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($0E.b,S),Y		; 13 0E ; OR accumulator (stack relative indirect indexed) ($0E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldy #$B60D.w		; A0 0D B6 ; Load #$B60D.w into Y register [Writes: Y Index] [Flags: NZ]
	rol $7F.b		; 26 7F ; Rotate left $7F.b [Reads: Direct Page] [Flags: NCZ]
	trb $FADD.w		; 1C DD FA ; Test and reset bits $FADD.w [Reads: Accumulator] [Flags: Z]
	ora $32D3A4.l		; 0F A4 D3 32 ; OR accumulator with memory (long) $32D3A4.l [Writes: Accumulator] [Flags: NZ]
	sbc $1E0F2E.l,X		; FF 2E 0F 1E ; Subtract with carry (long,X) $1E0F2E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $B0A0EF.l		; 0F EF A0 B0 ; OR accumulator with memory (long) $B0A0EF.l [Writes: Accumulator] [Flags: NZ]
	ora ($6F.b,S),Y		; 13 6F ; OR accumulator (stack relative indirect indexed) ($6F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($1F.b,S),Y		; 33 1F ; AND accumulator (stack relative indirect indexed) ($1F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $FE		; F0 FE ; Branch if equal to $F0, $FE [Flow: branch]
	asl $DEA0.w,X		; 1E A0 DE ; Arithmetic shift left $DEA0.w,X [Reads: X Index] [Flags: NCZ]
	.db $D0, $43		; D0 43 ; Branch if not equal to $D0, $43 [Flow: branch]
	.db $10, $02		; 10 02 ; Branch if plus to $10, $02 [Flow: branch]
	and ($FF.b),Y		; 31 FF ; AND accumulator with memory ($FF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($94.b),Y		; F1 94 ; Subtract with carry ($94.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp $100E.w		; 4C 0E 10 ; Jump to $100E.w [Flow: jump]
	asl $E0E5.w		; 0E E5 E0 ; Arithmetic shift left $E0E5.w [Flags: NCZ]
	.db $D0, $0F		; D0 0F ; Branch if not equal to $D0, $0F [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and $FE1010.l		; 2F 10 10 FE ; AND accumulator with memory (long) $FE1010.l [Writes: Accumulator] [Flags: NZ]
	jmp $0E20.w		; 4C 20 0E ; Jump to $0E20.w [Flow: jump]
	sbc $F2F0A4.l,X		; FF A4 F0 F2 ; Subtract with carry (long,X) $F2F0A4.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($1F.b),Y		; F1 1F ; Subtract with carry ($1F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cpx #$1FF1.w		; E0 F1 1F ; Compare #$1FF1.w with X register [Reads: X Index] [Flags: NCZ]
	sty $30.b,X		; 94 30 ; Store Y register $30.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	ora ($22.b),Y		; 11 22 ; OR accumulator with memory ($22.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda $0D01.w,X		; BD 01 0D ; Load $0D01.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($E1.b,X)		; E1 E1 ; Subtract with carry ($E1.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sty $10.b		; 84 10 ; Store Y register to $10.b [Reads: Y Index]
	sbc $2F.b		; E5 2F ; Subtract $2F.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F13162.l,X		; FF 62 31 F1 ; Subtract with carry (long,X) $F13162.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	sty $1E.b,X		; 94 1E ; Store Y register $1E.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	cpx $3F60.w		; EC 60 3F ; Compare $3F60.w with X register [Reads: X Index] [Flags: NCZ]
	cpx #$01E0.w		; E0 E0 01 ; Compare #$01E0.w with X register [Reads: X Index] [Flags: NCZ]
	sbc ($94.b)		; F2 94 ; Subtract with carry (indirect) ($94.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	pea $1D2E.w		; F4 2E 1D ; Push absolute address $1D2E.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sbc $FE0221.l		; EF 21 02 FE ; Subtract with carry (long) $FE0221.l [Writes: Accumulator] [Flags: NCVZ]
	sbc $4F94.w		; ED 94 4F ; Subtract $4F94.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ora ($3E.b,S),Y		; 13 3E ; OR accumulator (stack relative indirect indexed) ($3E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $E221.w		; 0D 21 E2 ; Logical OR $E221.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cpx $ED.b		; E4 ED ; Compare $ED.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	sty $FC.b,X		; 94 FC ; Store Y register $FC.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	ora $FFD043.l,X		; 1F 43 D0 FF ; Logical OR long $FFD043.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $43.b,S		; 03 43 ; OR accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $ECA4.w		; 6D A4 EC ; Add $ECA4.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
.ACCU 16
.INDEX 16
	rep #$34		; C2 34
	and $E0CB.w,X		; 3D CB E0 ; AND accumulator with memory $E0CB.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr $30.b,X		; 56 30 ; Logical shift right $30.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	.db $B0, $22		; B0 22 ; Branch if carry set to $B0, $22 [Flow: branch]
	and $DE.b,X		; 35 DE ; Logical AND $DE.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $4203.w		; CD 03 42 ; Compare $4203.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora $01DCA8.l		; 0F A8 DC 01 ; OR accumulator with memory (long) $01DCA8.l [Writes: Accumulator] [Flags: NZ]
	and ($20.b),Y		; 31 20 ; AND accumulator with memory ($20.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $40FF.w,X		; FD FF 40 ; Subtract with carry $40FF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($A4.b,X)		; 01 A4 ; Logical OR ($A4.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $20FFD1.l,X		; 1F D1 FF 20 ; Logical OR long $20FFD1.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($E0.b,X)		; 01 E0 ; Logical OR ($E0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	sty $DF.b		; 84 DF ; Store Y register to $DF.b [Reads: Y Index]
	ora [$31.b],Y		; 17 31 ; OR accumulator with memory (long indexed) [$31.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $A2BB.w,X		; FD BB A2 ; Subtract with carry $A2BB.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $F4.b,S		; 43 F4 ; Exclusive OR accumulator with stack relative $F4.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sty $0F.b,X		; 94 0F ; Store Y register $0F.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	ora $F305.w		; 0D 05 F3 ; Logical OR $F305.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $12EE.w,X		; 3D EE 12 ; AND accumulator with memory $12EE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($94.b),Y		; 11 94 ; OR accumulator with memory ($94.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sbc $1111E1.l		; EF E1 11 11 ; Subtract with carry (long) $1111E1.l [Writes: Accumulator] [Flags: NCVZ]
	ora ($0F.b),Y		; 11 0F ; OR accumulator with memory ($0F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $98		; F0 98 ; Branch if equal to $F0, $98 [Flow: branch]
	ora ($FD.b),Y		; 11 FD ; OR accumulator with memory ($FD.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($FB.b),Y		; 31 FB ; AND accumulator with memory ($FB.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $11.b,S		; 03 11 ; OR accumulator with stack relative $11.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc ($3E.b),Y		; F1 3E ; Subtract with carry ($3E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sty $DF.b		; 84 DF ; Store Y register to $DF.b [Reads: Y Index]
	cmp $1620.w		; CD 20 16 ; Compare $1620.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	and $52BBBF.l		; 2F BF BB 52 ; AND accumulator with memory (long) $52BBBF.l [Writes: Accumulator] [Flags: NZ]
	sty $12.b		; 84 12 ; Store Y register to $12.b [Reads: Y Index]
	ora ($DD.b,X)		; 01 DD ; Logical OR ($DD.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor $30.b,S		; 43 30 ; Exclusive OR accumulator with stack relative $30.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $EF		; F0 EF ; Branch if equal to $F0, $EF [Flow: branch]
	cpy #$0F88.w		; C0 88 0F ; Compare #$0F88.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora ($F1.b,X)		; 01 F1 ; Logical OR ($F1.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc ($DF.b)		; F2 DF ; Subtract with carry (indirect) ($DF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	bit $1B.b,X		; 34 1B ; Test bits $1B.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sbc $F3F488.l		; EF 88 F4 F3 ; Subtract with carry (long) $F3F488.l [Writes: Accumulator] [Flags: NCVZ]
	jmp.w [$1033]		; DC 33 10 ; Jump long indirect [$1033] [Flow: jump]
	cmp ($D1.b,X)		; C1 D1 ; Compare accumulator ($D1.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	and ($84.b)		; 32 84 ; AND accumulator with memory (indirect) ($84.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor ($0F.b),Y		; 51 0F ; Exclusive OR accumulator with memory ($0F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $E1200D.l,X		; FF 0D 20 E1 ; Subtract with carry (long,X) $E1200D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	trb $903F.w		; 1C 3F 90 ; Test and reset bits $903F.w [Reads: Accumulator] [Flags: Z]
	inc $23FF.w		; EE FF 23 ; Increment $23FF.w [Flags: NZ]
	and ($1D.b,S),Y		; 33 1D ; AND accumulator (stack relative indirect indexed) ($1D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $FF01.w,X		; FE 01 FF ; Increment memory $FF01.w,X [Reads: X Index] [Flags: NZ]
	.db $90, $DE		; 90 DE ; Branch if carry clear to $90, $DE [Flow: branch]
	cmp $2031.w,X		; DD 31 20 ; Compare accumulator $2031.w,X [Reads: X Index] [Flags: NCZ]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($01.b,S),Y		; 33 01 ; AND accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $01.b,S		; C3 01 ; Compare accumulator (stack relative) $01.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	ora $111F.w		; 0D 1F 11 ; Logical OR $111F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $94E2ED.l		; 22 ED E2 94 ; Jump to subroutine long $94E2ED.l [Writes: Stack Pointer] [Flow: call]
	cmp $1FFF32.l,X		; DF 32 FF 1F ; Compare accumulator (long,X) $1FFF32.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	inc $33F0.w,X		; FE F0 33 ; Increment memory $33F0.w,X [Reads: X Index] [Flags: NZ]
	sbc ($98.b)		; F2 98 ; Subtract with carry (indirect) ($98.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $0300.w,X		; FD 00 03 ; Subtract with carry $0300.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $30E1FC.l,X		; 3F FC E1 30 ; AND accumulator with memory (long,X) $30E1FC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pea $3B88.w		; F4 88 3B ; Push absolute address $3B88.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	wai		; CB ; Wait for interrupt
	lsr $5011.w		; 4E 11 50 ; Logical shift right $5011.w [Flags: NCZ]
	jsr ($13C2.w,X)		; FC C2 13 ; Jump to subroutine indirect indexed ($13C2.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	stz $47.b,X		; 74 47 ; Store zero to $47.b,X [Reads: X Index]
	and $EE.b		; 25 EE ; Logical AND $EE.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $0CF6.w,X		; 1E F6 0C ; Arithmetic shift left $0CF6.w,X [Reads: X Index] [Flags: NCZ]
	.db $B0, $22		; B0 22 ; Branch if carry set to $B0, $22 [Flow: branch]
	sty $03.b		; 84 03 ; Store Y register to $03.b [Reads: Y Index]
	sbc ($E0.b,X)		; E1 E0 ; Subtract with carry ($E0.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $D0, $33		; D0 33 ; Branch if not equal to $D0, $33 [Flow: branch]
	ora $78C1FD.l		; 0F FD C1 78 ; OR accumulator with memory (long) $78C1FD.l [Writes: Accumulator] [Flags: NZ]
	tsb $A0.b		; 04 A0 ; Test and set bits $A0.b [Reads: Accumulator] [Flags: Z]
	and $103C.w,X		; 3D 3C 10 ; AND accumulator with memory $103C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $E5.b		; 00 E5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $4B78.w,X		; DD 78 4B ; Compare accumulator $4B78.w,X [Reads: X Index] [Flags: NCZ]
	tsb $23.b		; 04 23 ; Test and set bits $23.b [Reads: Accumulator] [Flags: Z]
	bit $3FBE.w,X		; 3C BE 3F ; Test bits $3FBE.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	cpx $2C.b		; E4 2C ; Compare $2C.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	stz $1D.b,X		; 74 1D ; Store zero to $1D.b,X [Reads: X Index]
	brk $F1.b		; 00 F1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $21.b,X		; F5 21 ; Subtract $21.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $2FE3.w,X		; 1E E3 2F ; Arithmetic shift left $2FE3.w,X [Reads: X Index] [Flags: NCZ]
	.db $70, $23		; 70 23 ; Branch if overflow set to $70, $23 [Flow: branch]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	lda $23F1.w,X		; BD F1 23 ; Load $23F1.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $50, $11		; 50 11 ; Branch if overflow clear to $50, $11 [Flow: branch]
	stz $20.b,X		; [PATTERN: Memory clearing operation] 74 20 ; Store zero to $20.b,X [Reads: X Index]
	sbc $20FD.w,X		; FD FD 20 ; Subtract with carry $20FD.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $2E.b,S		; 43 2E ; Exclusive OR accumulator with stack relative $2E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $D0.b,S		; E3 D0 ; Subtract stack-relative $D0.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	stz $F2.b,X		; 74 F2 ; Store zero to $F2.b,X [Reads: X Index]
	lda ($CF.b,S),Y		; B3 CF ; Load accumulator (stack relative indirect indexed) ($CF.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $B0.b,X		; 34 B0 ; Test bits $B0.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and ($F2.b,S),Y		; 33 F2 ; AND accumulator (stack relative indirect indexed) ($F2.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $10, $64		; 10 64 ; Branch if plus to $10, $64 [Flow: branch]
	cpx $FDA3.w		; EC A3 FD ; Compare $FDA3.w with X register [Reads: X Index] [Flags: NCZ]
	cmp ($16.b)		; D2 16 ; Compare accumulator (indirect) ($16.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	trb $1F.b		; 14 1F ; Test and reset bits $1F.b [Reads: Accumulator] [Flags: Z]
	sbc #$CD74.w		; E9 74 CD ; Subtract #$CD74.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	rol $32.b,X		; 36 32 ; Rotate left $32.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	cmp $D45212.l,X		; DF 12 52 D4 ; Compare accumulator (long,X) $D45212.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	.db $70, $40		; 70 40 ; Branch if overflow set to $70, $40 [Flow: branch]
	sbc $0DCE.w		; ED CE 0D ; Subtract $0DCE.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cop $12.b		; 02 12 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pea $8835.w		; F4 35 88 ; Push absolute address $8835.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	.db $D0, $10		; D0 10 ; Branch if not equal to $D0, $10 [Flow: branch]
	ora $F3.b,S		; 03 F3 ; OR accumulator with stack relative $F3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $F214E0.l		; CF E0 14 F2 ; Compare accumulator (long) $F214E0.l [Reads: Accumulator] [Flags: NCZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sbc $2F13D0.l		; EF D0 13 2F ; Subtract with carry (long) $2F13D0.l [Writes: Accumulator] [Flags: NCVZ]
	sbc $04F1.w,X		; FD F1 04 ; Subtract with carry $04F1.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $DEFE84.l		; 2F 84 FE DE ; AND accumulator with memory (long) $DEFE84.l [Writes: Accumulator] [Flags: NZ]
	sbc $42.b,S		; E3 42 ; Subtract stack-relative $42.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	asl $F1EF.w,X		; 1E EF F1 ; Arithmetic shift left $F1EF.w,X [Reads: X Index] [Flags: NCZ]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp.w [$E1AC]		; DC AC E1 ; Jump long indirect [$E1AC] [Flow: jump]
	eor $10.b,S		; 43 10 ; Exclusive OR accumulator with stack relative $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $35		; F0 35 ; Branch if equal to $F0, $35 [Flow: branch]
	eor $D4DF75.l,X		; 5F 75 DF D4 ; Exclusive OR accumulator with memory (long,X) $D4DF75.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $1E.b,S		; 63 1E ; Add with carry (stack relative) $1E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$54F0.w		; C0 F0 54 ; Compare #$54F0.w with Y register [Reads: Y Index] [Flags: NCZ]
	lda $000002.l		; AF 02 00 00 ; Load long $000002.l into accumulator [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($52.b)		; F2 52 ; Subtract with carry (indirect) ($52.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp $E2FF.w,X		; DD FF E2 ; Compare accumulator $E2FF.w,X [Reads: X Index] [Flags: NCZ]
	and $7A23D0.l,X		; 3F D0 23 7A ; AND accumulator with memory (long,X) $7A23D0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rol $22CD.w		; 2E CD 22 ; Rotate left $22CD.w [Flags: NCZ]
	inc $FF12.w,X		; FE 12 FF ; Increment memory $FF12.w,X [Reads: X Index] [Flags: NZ]
	ora ($10.b),Y		; 11 10 ; OR accumulator with memory ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	inc $FC33.w,X		; FE 33 FC ; Increment memory $FC33.w,X [Reads: X Index] [Flags: NZ]
	cmp ($30.b),Y		; D1 30 ; Compare accumulator ($30.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	inc $ADBA.w		; EE BA AD ; Increment $ADBA.w [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	trb $4F.b		; 14 4F ; Test and reset bits $4F.b [Reads: Accumulator] [Flags: Z]
	ldx $0001.w,Y		; BE 01 00 ; Load X register $0001.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $76.b		; 00 76 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $FC.b		; 64 FC ; Store zero to $FC.b
	bit $0C.b		; 24 0C ; Test bits $0C.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	tsb $41.b		; 04 41 ; Test and set bits $41.b [Reads: Accumulator] [Flags: Z]
	sbc $A6F2.w		; ED F2 A6 ; Subtract $A6F2.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $ED0FFF.l		; 0F FF 0F ED ; OR accumulator with memory (long) $ED0FFF.l [Writes: Accumulator] [Flags: NZ]
	cmp $AAE3.w,X		; DD E3 AA ; Compare accumulator $AAE3.w,X [Reads: X Index] [Flags: NCZ]
	jmp $5FB4.w		; 4C B4 5F ; Jump to $5FB4.w [Flow: jump]
	lda $21F2.w		; AD F2 21 ; Load $21F2.w into accumulator [Writes: Accumulator] [Flags: NZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($1D.b)		; D2 1D ; Compare accumulator (indirect) ($1D.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp ($41.b),Y		; D1 41 ; Compare accumulator ($41.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	ora $12EF.w		; 0D EF 12 ; Logical OR $12EF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and ($8A.b),Y		; 31 8A ; AND accumulator with memory ($8A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $1EF1.w		; 0E F1 1E ; Arithmetic shift left $1EF1.w [Flags: NCZ]
	cmp $10D0.w		; CD D0 10 ; Compare $10D0.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $11		; F0 11 ; Branch if equal to $F0, $11 [Flow: branch]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	trb $2D.b		; 14 2D ; Test and reset bits $2D.b [Reads: Accumulator] [Flags: Z]
	dec $21F1.w		; CE F1 21 ; Decrement $21F1.w [Flags: NZ]
	ora $8A1001.l		; 0F 01 10 8A ; OR accumulator with memory (long) $8A1001.l [Writes: Accumulator] [Flags: NZ]
	cmp $00D0.w		; CD D0 00 ; Compare $00D0.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($21.b)		; 12 21 ; OR accumulator with memory (indirect) ($21.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $10019A.l,X		; DF 9A 01 10 ; Compare accumulator (long,X) $10019A.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	sbc $01EFFF.l		; EF FF EF 01 ; Subtract with carry (long) $01EFFF.l [Writes: Accumulator] [Flags: NCVZ]
	ora ($54.b)		; 12 54 ; OR accumulator with memory (indirect) ($54.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	and $F1BBED.l		; 2F ED BB F1 ; AND accumulator with memory (long) $F1BBED.l [Writes: Accumulator] [Flags: NZ]
	jsl $F01022.l		; 22 22 10 F0 ; Jump to subroutine long $F01022.l [Writes: Stack Pointer] [Flow: call]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	and $4FE3CD.l		; 2F CD E3 4F ; AND accumulator with memory (long) $4FE3CD.l [Writes: Accumulator] [Flags: NZ]
	cmp ($41.b),Y		; D1 41 ; Compare accumulator ($41.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cmp $8A15.w,X		; DD 15 8A ; Compare accumulator $8A15.w,X [Reads: X Index] [Flags: NCZ]
	ora $00F1EE.l,X		; 1F EE F1 00 ; Logical OR long $00F1EE.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cop $FD.b		; 02 FD ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp.w [$9AE6]		; DC E6 9A ; Jump long indirect [$9AE6] [Flow: jump]
	stz $0D.b		; 64 0D ; Store zero to $0D.b
	cpx #$D0FC.w		; E0 FC D0 ; Compare #$D0FC.w with X register [Reads: X Index] [Flags: NCZ]
	and ($20.b,S),Y		; 33 20 ; AND accumulator (stack relative indirect indexed) ($20.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $34247A.l		; EF 7A 24 34 ; Subtract with carry (long) $34247A.l [Writes: Accumulator] [Flags: NCVZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	sta $EE0F33.l,X		; 9F 33 0F EE ; Store accumulator (long,X) $EE0F33.l,X [Reads: Accumulator, X Index]
	.db $F0, $8A		; F0 8A ; Branch if equal to $F0, $8A [Flow: branch]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	ora ($32.b)		; 12 32 ; OR accumulator with memory (indirect) ($32.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $BCEB.w,X		; 1E EB BC ; Arithmetic shift left $BCEB.w,X [Reads: X Index] [Flags: NCZ]
	cmp $00AA.w		; CD AA 00 ; Compare $00AA.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	and $60.b		; 25 60 ; Logical AND $60.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpy $F0EF.w		; CC EF F0 ; Compare $F0EF.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $0EEF43.l		; EF 43 EF 0E ; Subtract with carry (long) $0EEF43.l [Writes: Accumulator] [Flags: NCVZ]
	cmp $F01012.l,X		; DF 12 10 F0 ; Compare accumulator (long,X) $F01012.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $221201.l,X		; FF 01 12 22 ; Subtract with carry (long,X) $221201.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr $DDBB.w		; 20 BB DD ; Jump to subroutine at $DDBB.w [Writes: Stack Pointer] [Flow: call]
	inc $0FBA.w		; EE BA 0F ; Increment $0FBA.w [Flags: NZ]
	sbc ($44.b),Y		; F1 44 ; Subtract with carry ($44.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $E0DD.w,X		; 1E DD E0 ; Arithmetic shift left $E0DD.w,X [Reads: X Index] [Flags: NCZ]
	and ($00.b,X)		; 21 00 ; Logical AND ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $31.b,S		; 43 31 ; Exclusive OR accumulator with stack relative $31.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $EC11.w		; EE 11 EC ; Increment $EC11.w [Flags: NZ]
	sbc ($0F.b)		; F2 0F ; Subtract with carry (indirect) ($0F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cop $7A.b		; 02 7A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($00.b),Y		; 31 00 ; AND accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $EFBD.w,X		; FE BD EF ; Increment memory $EFBD.w,X [Reads: X Index] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	sbc $3F2301.l,X		; FF 01 23 3F ; Subtract with carry (long,X) $3F2301.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $11EF.w,X		; DD EF 11 ; Compare accumulator $11EF.w,X [Reads: X Index] [Flags: NCZ]
	ora ($8A.b),Y		; 11 8A ; OR accumulator with memory ($8A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $01F2.w		; 2D F2 01 ; Logical AND $01F2.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $0002CD.l		; 2F CD 02 00 ; AND accumulator with memory (long) $0002CD.l [Writes: Accumulator] [Flags: NZ]
	sbc ($7A.b),Y		; F1 7A ; Subtract with carry ($7A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($DD.b)		; 52 DD ; Exclusive OR accumulator with memory (indirect) ($DD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $24AB.w,X		; FE AB 24 ; Increment memory $24AB.w,X [Reads: X Index] [Flags: NZ]
	tsb $0FBA.w		; 0C BA 0F ; Test and set bits $0FBA.w [Reads: Accumulator] [Flags: Z]
	.db $F0, $13		; F0 13 ; Branch if equal to $F0, $13 [Flow: branch]
	eor ($DC.b,X)		; 41 DC ; Exclusive OR accumulator with memory ($DC.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $8A1011.l		; EF 11 10 8A ; Subtract with carry (long) $8A1011.l [Writes: Accumulator] [Flags: NCVZ]
	.db $62, $0D, $12		; 62 0D 12 ; Push effective relative address $62, $0D, $12 [Writes: Stack Pointer]
	and ($FC.b,X)		; 21 FC ; Logical AND ($FC.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	dec $1F33.w		; CE 33 1F ; Decrement $1F33.w [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	inc $53F2.w		; EE F2 53 ; Increment $53F2.w [Flags: NZ]
	cpx $FC02.w		; EC 02 FC ; Compare $FC02.w with X register [Reads: X Index] [Flags: NCZ]
	sbc ($3D.b,X)		; E1 3D ; Subtract with carry ($3D.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	sbc $76F3FF.l,X		; FF FF F3 76 ; Subtract with carry (long,X) $76F3FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ldy $23E0.w		; AC E0 23 ; Load $23E0.w into Y register [Writes: Y Index] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	and ($10.b),Y		; 31 10 ; AND accumulator with memory ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $11		; F0 11 ; Branch if equal to $F0, $11 [Flow: branch]
	ora $21F2EE.l		; 0F EE F2 21 ; OR accumulator with memory (long) $21F2EE.l [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	pei ($75.b)		; D4 75 ; Push effective indirect address ($75.b) [Reads: Direct Page] [Writes: Stack Pointer]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	cmp ($1E.b),Y		; D1 1E ; Compare accumulator ($1E.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	sbc $4C.b,S		; E3 4C ; Subtract stack-relative $4C.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	sbc $4501FE.l,X		; FF FE 01 45 ; Subtract with carry (long,X) $4501FE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	dec $8612.w		; CE 12 86 ; Decrement $8612.w [Flags: NZ]
	ldy #$4622.w		; A0 22 46 ; Load #$4622.w into Y register [Writes: Y Index] [Flags: NZ]
	ror $65.b		; 66 65 ; Rotate right $65.b [Reads: Direct Page] [Flags: NCZ]
	ora $F1BD.w,X		; 1D BD F1 ; OR accumulator with memory $F1BD.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	cmp ($65.b,S),Y		; D3 65 ; Compare accumulator (stack relative indirect indexed) ($65.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	eor $BF0DCE.l		; 4F CE 0D BF ; Exclusive OR accumulator with memory (long) $BF0DCE.l [Writes: Accumulator] [Flags: NZ]
	.db $10, $AA		; 10 AA ; Branch if plus to $10, $AA [Flow: branch]
	ora $2401FF.l		; 0F FF 01 24 ; OR accumulator with memory (long) $2401FF.l [Writes: Accumulator] [Flags: NZ]
	and ($ED.b),Y		; 31 ED ; AND accumulator with memory ($ED.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpy $9AF2.w		; CC F2 9A ; Compare $9AF2.w with Y register [Reads: Y Index] [Flags: NCZ]
	adc $10.b,S		; 63 10 ; Add with carry (stack relative) $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	ora $11F0FF.l		; 0F FF F0 11 ; OR accumulator with memory (long) $11F0FF.l [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	jsr ($45E1.w,X)		; FC E1 45 ; Jump to subroutine indirect indexed ($45E1.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	eor ($EE.b,X)		; 41 EE ; Exclusive OR accumulator with memory ($EE.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $E0BC.w,X		; DD BC E0 ; Compare accumulator $E0BC.w,X [Reads: X Index] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($12.b,X)		; 01 12 ; Logical OR ($12.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and ($FD.b),Y		; 31 FD ; AND accumulator with memory ($FD.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	dec $9AF0.w,X		; DE F0 9A ; Decrement memory $9AF0.w,X [Reads: X Index] [Flags: NZ]
	and $40.b		; 25 40 ; Logical AND $40.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx #$FF20.w		; E0 20 FF ; Compare #$FF20.w with X register [Reads: X Index] [Flags: NCZ]
	ora $7A1000.l		; 0F 00 10 7A ; OR accumulator with memory (long) $7A1000.l [Writes: Accumulator] [Flags: NZ]
	asl $1011.w		; 0E 11 10 ; Arithmetic shift left $1011.w [Flags: NCZ]
	ora ($0E.b,S),Y		; 13 0E ; OR accumulator (stack relative indirect indexed) ($0E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $DC		; D0 DC ; Branch if not equal to $D0, $DC [Flow: branch]
	cpy #$009A.w		; C0 9A 00 ; Compare #$009A.w with Y register [Reads: Y Index] [Flags: NCZ]
	sbc $4235F1.l,X		; FF F1 35 42 ; Subtract with carry (long,X) $4235F1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cmp $8ADF.w		; CD DF 8A ; Compare $8ADF.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	adc [$61.b]		; 67 61 ; Add with carry (long) [$61.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inc $0E01.w,X		; FE 01 0E ; Increment memory $0E01.w,X [Reads: X Index] [Flags: NZ]
	.db $F0, $11		; F0 11 ; Branch if equal to $F0, $11 [Flow: branch]
	.db $10, $6A		; 10 6A ; Branch if plus to $10, $6A [Flow: branch]
	and $23E0CB.l		; 2F CB E0 23 ; AND accumulator with memory (long) $23E0CB.l [Writes: Accumulator] [Flags: NZ]
	.db $30, $FF		; 30 FF ; Branch if minus to $30, $FF [Flow: branch]
	inc $9ADF.w,X		; FE DF 9A ; Increment memory $9ADF.w,X [Reads: X Index] [Flags: NZ]
	asl $00EF.w		; 0E EF 00 ; Arithmetic shift left $00EF.w [Flags: NCZ]
	bit $54.b		; 24 54 ; Test bits $54.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	tsb $E0BB.w		; 0C BB E0 ; Test and set bits $E0BB.w [Reads: Accumulator] [Flags: Z]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	bit $53.b,X		; 34 53 ; Test bits $53.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sbc $FF0001.l,X		; FF 01 00 FF ; Subtract with carry (long,X) $FF0001.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and $E29A.w		; 2D 9A E2 ; Logical AND $E29A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1D0154.l		; 22 54 01 1D ; Jump to subroutine long $1D0154.l [Writes: Stack Pointer] [Flow: call]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	.db $F0, $EE		; F0 EE ; Branch if equal to $F0, $EE [Flow: branch]
	.db $F0, $14		; F0 14 ; Branch if equal to $F0, $14 [Flow: branch]
	adc $1D.b		; 65 1D ; Add $1D.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cpy $8ACC.w		; CC CC 8A ; Compare $8ACC.w with Y register [Reads: Y Index] [Flags: NCZ]
	asl $73.b,X		; 16 73 ; Arithmetic shift left $73.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($10.b),Y		; 11 10 ; OR accumulator with memory ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	inc $0000.w,X		; FE 00 00 ; Increment memory $0000.w,X [Reads: X Index] [Flags: NZ]
	brk $7A.b		; 00 7A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($EE.b,X)		; 21 EE ; Logical AND ($EE.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpx #$2024.w		; E0 24 20 ; Compare #$2024.w with X register [Reads: X Index] [Flags: NCZ]
	ora $9ADDFE.l		; 0F FE DD 9A ; OR accumulator with memory (long) $9ADDFE.l [Writes: Accumulator] [Flags: NZ]
	ora $13FFFF.l		; 0F FF FF 13 ; OR accumulator with memory (long) $13FFFF.l [Writes: Accumulator] [Flags: NZ]
	eor $30.b		; 45 30 ; Exclusive OR $30.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	wai		; CB ; Wait for interrupt
	lda $E19A.w,X		; BD 9A E1 ; Load $E19A.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	mvp $00,$20		; 44 20 00 ; Move block positive $00,$20 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $01F0F0.l		; 0F F0 F0 01 ; OR accumulator with memory (long) $01F0F0.l [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	and ($EF.b,X)		; 21 EF ; Logical AND ($EF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($EF.b),Y		; 31 EF ; AND accumulator with memory ($EF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $9ACD.w		; 0D CD 9A ; Logical OR $9ACD.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $02		; F0 02 ; Branch if equal to $F0, $02 [Flow: branch]
	and $30.b,X		; 35 30 ; Logical AND $30.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cpx $9ACC.w		; EC CC 9A ; Compare $9ACC.w with X register [Reads: X Index] [Flags: NCZ]
	sbc $0F4224.l		; EF 24 42 0F ; Subtract with carry (long) $0F4224.l [Writes: Accumulator] [Flags: NCVZ]
	sbc $11F00F.l,X		; FF 0F F0 11 ; Subtract with carry (long,X) $11F00F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	jsr $01DF.w		; 20 DF 01 ; Jump to subroutine at $01DF.w [Writes: Stack Pointer] [Flow: call]
	ora ($0F.b),Y		; 11 0F ; OR accumulator with memory ($0F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($1F.b,X)		; 01 1F ; Logical OR ($1F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	.db $F0, $0F		; F0 0F ; Branch if equal to $F0, $0F [Flow: branch]
	.db $F0, $01		; F0 01 ; Branch if equal to $F0, $01 [Flow: branch]
	bit $31.b,X		; 34 31 ; Test bits $31.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sbc $8ACB.w,X		; FD CB 8A ; Subtract with carry $8ACB.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy #$6646.w		; A0 46 66 ; Load #$6646.w into Y register [Writes: Y Index] [Flags: NZ]
	and $12DFEC.l		; 2F EC DF 12 ; AND accumulator with memory (long) $12DFEC.l [Writes: Accumulator] [Flags: NZ]
	brk $76.b		; 00 76 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($FF.b),Y		; 11 FF ; OR accumulator with memory ($FF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $2D24EF.l,X		; FF EF 24 2D ; Subtract with carry (long,X) $2D24EF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	sbc $01F00F.l,X		; FF 0F F0 01 ; Subtract with carry (long,X) $01F00F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $32.b		; 24 32 ; Test bits $32.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sbc $9ACE.w,X		; FD CE 9A ; Subtract with carry $9ACE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $4403.w,X		; DD 03 44 ; Compare accumulator $4403.w,X [Reads: X Index] [Flags: NCZ]
	and $00F0EE.l		; 2F EE F0 00 ; AND accumulator with memory (long) $00F0EE.l [Writes: Accumulator] [Flags: NZ]
	.db $10, $6A		; 10 6A ; Branch if plus to $10, $6A [Flow: branch]
	eor ($1C.b)		; 52 1C ; Exclusive OR accumulator with memory (indirect) ($1C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0E		; F0 0E ; Branch if equal to $F0, $0E [Flow: branch]
	.db $F0, $01		; F0 01 ; Branch if equal to $F0, $01 [Flow: branch]
	bit $1B.b,X		; 34 1B ; Test bits $1B.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	sbc $000FFF.l,X		; FF FF 0F 00 ; Subtract with carry (long,X) $000FFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($41.b,S),Y		; 33 41 ; AND accumulator (stack relative indirect indexed) ($41.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $9ADB.w,X		; 1E DB 9A ; Arithmetic shift left $9ADB.w,X [Reads: X Index] [Flags: NCZ]
	dec DMASRC1L.w		; CE 12 43 ; Decrement DMASRC1L.w [Flags: NZ]
	.db $30, $FD		; 30 FD ; Branch if minus to $30, $FD [Flow: branch]
	cpx #$0001.w		; E0 01 00 ; Compare #$0001.w with X register [Reads: X Index] [Flags: NCZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	bit $1E.b		; 24 1E ; Test bits $1E.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sbc $F10000.l,X		; FF 00 00 F1 ; Subtract with carry (long,X) $F10000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $FF9AFD.l		; 22 FD 9A FF ; Jump to subroutine long $FF9AFD.l [Writes: Stack Pointer] [Flow: call]
	.db $F0, $0F		; F0 0F ; Branch if equal to $F0, $0F [Flow: branch]
	sbc ($23.b),Y		; F1 23 ; Subtract with carry ($23.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($0F.b)		; 32 0F ; AND accumulator with memory (indirect) ($0F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx $CD9A.w		; EC 9A CD ; Compare $CD9A.w with X register [Reads: X Index] [Flags: NCZ]
	sbc ($45.b)		; F2 45 ; Subtract with carry (indirect) ($45.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $ED		; 30 ED ; Branch if minus to $30, $ED [Flow: branch]
	cpx #$0110.w		; E0 10 01 ; Compare #$0110.w with X register [Reads: X Index] [Flags: NCZ]
	ror $53.b		; 66 53 ; Rotate right $53.b [Reads: Direct Page] [Flags: NCZ]
	ora ($00.b)		; 12 00 ; OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $24FF10.l		; 22 10 FF 24 ; Jump to subroutine long $24FF10.l [Writes: Stack Pointer] [Flow: call]
	and $EE8A.w		; 2D 8A EE ; Logical AND $EE8A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $FE		; F0 FE ; Branch if equal to $F0, $FE [Flow: branch]
	ora ($25.b,X)		; 01 25 ; Logical OR ($25.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	stz $FE.b,X		; 74 FE ; Store zero to $FE.b,X [Reads: X Index]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	lda $35F2.w,X		; BD F2 35 ; Load $35F2.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $ED		; 30 ED ; Branch if minus to $30, $ED [Flow: branch]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	.db $10, $66		; 10 66 ; Branch if plus to $10, $66 [Flow: branch]
	.db $D0, $43		; D0 43 ; Branch if not equal to $D0, $43 [Flow: branch]
	and ($33.b,S),Y		; 33 33 ; AND accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr $02EE.w		; 20 EE 02 ; Jump to subroutine at $02EE.w [Writes: Stack Pointer] [Flow: call]
	ora $EFFE8A.l,X		; 1F 8A FE EF ; Logical OR long $EFFE8A.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	and $64.b		; 25 64 ; Logical AND $64.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $9ABB.w		; 2E BB 9A ; Rotate left $9ABB.w [Flags: NCZ]
	cmp $34E2.w,X		; DD E2 34 ; Compare accumulator $34E2.w,X [Reads: X Index] [Flags: NCZ]
	and ($FD.b),Y		; 31 FD ; AND accumulator with memory ($FD.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $11		; D0 11 ; Branch if not equal to $D0, $11 [Flow: branch]
	brk $66.b		; 00 66 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx $2224.w,Y		; BE 24 22 ; Load X register $2224.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	lsr $3F.b		; 46 3F ; Logical shift right $3F.b [Reads: Direct Page] [Flags: NCZ]
	dec $FFFF.w		; CE FF FF ; Decrement $FFFF.w [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $FFFF.w,X		; FE FF FF ; Increment memory $FFFF.w,X [Reads: X Index] [Flags: NZ]
	.db $F0, $24		; F0 24 ; Branch if equal to $F0, $24 [Flow: branch]
	stz $10.b		; 64 10 ; Store zero to $10.b
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	cpy $45E1.w		; CC E1 45 ; Compare $45E1.w with Y register [Reads: Y Index] [Flags: NCZ]
	and ($ED.b),Y		; 31 ED ; AND accumulator with memory ($ED.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($01.b),Y		; D1 01 ; Compare accumulator ($01.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	ora ($6A.b,X)		; 01 6A ; Logical OR ($6A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp ($F3.b),Y		; D1 F3 ; Compare accumulator ($F3.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpx $42D1.w		; EC D1 42 ; Compare $42D1.w with X register [Reads: X Index] [Flags: NCZ]
	ora $EFFE8A.l,X		; 1F 8A FE EF ; Logical OR long $EFFE8A.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $6414F0.l		; 0F F0 14 64 ; OR accumulator with memory (long) $6414F0.l [Writes: Accumulator] [Flags: NZ]
	.db $10, $FB		; 10 FB ; Branch if plus to $10, $FB [Flow: branch]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	cmp $35E0.w		; CD E0 35 ; Compare $35E0.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	eor ($ED.b,X)		; 41 ED ; Exclusive OR accumulator with memory ($ED.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $11		; D0 11 ; Branch if not equal to $D0, $11 [Flow: branch]
	brk $6A.b		; 00 6A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $1F, $FF		; 62 1F FF ; Push effective relative address $62, $1F, $FF [Writes: Stack Pointer]
	ora ($FC.b)		; 12 FC ; OR accumulator with memory (indirect) ($FC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $44		; D0 44 ; Branch if not equal to $D0, $44 [Flow: branch]
	rol $FE8A.w,X		; 3E 8A FE ; Rotate left $FE8A.w,X [Reads: X Index] [Flags: NCZ]
	sbc $1300FF.l		; EF FF 00 13 ; Subtract with carry (long) $1300FF.l [Writes: Accumulator] [Flags: NCVZ]
	mvn $FF,$2F		; 54 2F FF ; Move block negative $FF,$2F [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cpy #$4136.w		; C0 36 41 ; Compare #$4136.w with Y register [Reads: Y Index] [Flags: NCZ]
	sbc $12DF.w		; ED DF 12 ; Subtract $12DF.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $6A		; 10 6A ; Branch if plus to $10, $6A [Flow: branch]
	sbc $2211E0.l,X		; FF E0 11 22 ; Subtract with carry (long,X) $2211E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($62B2.w,X)		; FC B2 62 ; Jump to subroutine indirect indexed ($62B2.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $FF8A.w,X		; FE 8A FF ; Increment memory $FF8A.w,X [Reads: X Index] [Flags: NZ]
	sbc $1200EF.l,X		; FF EF 00 12 ; Subtract with carry (long,X) $1200EF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	mvp $EB,$41		; 44 41 EB ; Move block positive $EB,$41 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	cmp $24E0.w,X		; DD E0 24 ; Compare accumulator $24E0.w,X [Reads: X Index] [Flags: NCZ]
	.db $42, $FC		; 42 FC ; Reserved instruction
	.db $D0, $11		; D0 11 ; Branch if not equal to $D0, $11 [Flow: branch]
	.db $10, $6A		; 10 6A ; Branch if plus to $10, $6A [Flow: branch]
	dec $0F32.w,X		; DE 32 0F ; Decrement memory $0F32.w,X [Reads: X Index] [Flags: NZ]
	tsb $3D.b		; 04 3D ; Test and set bits $3D.b [Reads: Accumulator] [Flags: Z]
	sta $8A2E43.l,X		; 9F 43 2E 8A ; Store accumulator (long,X) $8A2E43.l,X [Reads: Accumulator, X Index]
	inc $FFFF.w,X		; FE FF FF ; Increment memory $FFFF.w,X [Reads: X Index] [Flags: NZ]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $1E,$11		; 44 11 1E ; Move block positive $1E,$11 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	jmp.w [$36CF]		; DC CF 36 ; Jump long indirect [$36CF] [Flow: jump]
	eor ($EC.b),Y		; 51 EC ; Exclusive OR accumulator with memory ($EC.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $11		; D0 11 ; Branch if not equal to $D0, $11 [Flow: branch]
	.db $10, $6A		; 10 6A ; Branch if plus to $10, $6A [Flow: branch]
	asl $330F.w,X		; 1E 0F 33 ; Arithmetic shift left $330F.w,X [Reads: X Index] [Flags: NCZ]
	ora ($FD.b,X)		; 01 FD ; Logical OR ($FD.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpy #$1032.w		; C0 32 10 ; Compare #$1032.w with Y register [Reads: Y Index] [Flags: NCZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $0EF0.w,X		; FE F0 0E ; Increment memory $0EF0.w,X [Reads: X Index] [Flags: NZ]
	sbc $214412.l,X		; FF 12 44 21 ; Subtract with carry (long,X) $214412.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $DFDB9A.l,X		; 1F 9A DB DF ; Logical OR long $DFDB9A.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $51.b,X		; 35 51 ; Logical AND $51.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cpx $01E0.w		; EC E0 01 ; Compare $01E0.w with X register [Reads: X Index] [Flags: NCZ]
	jsr $CC6A.w		; 20 6A CC ; Jump to subroutine at $CC6A.w [Writes: Stack Pointer] [Flow: call]
	.db $10, $43		; 10 43 ; Branch if plus to $10, $43 [Flow: branch]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx $2E45.w,Y		; BE 45 2E ; Load X register $2E45.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $0FF0.w,X		; FE F0 0F ; Increment memory $0FF0.w,X [Reads: X Index] [Flags: NZ]
	sbc $213402.l,X		; FF 02 34 21 ; Subtract with carry (long,X) $213402.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $9A		; 10 9A ; Branch if plus to $10, $9A [Flow: branch]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cmp $EB5235.l		; CF 35 52 EB ; Compare accumulator (long) $EB5235.l [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $12		; D0 12 ; Branch if not equal to $D0, $12 [Flow: branch]
	.db $10, $6A		; 10 6A ; Branch if plus to $10, $6A [Flow: branch]
	cmp ($C1.b),Y		; D1 C1 ; Compare accumulator ($C1.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	and ($F1.b,S),Y		; 33 F1 ; AND accumulator (stack relative indirect indexed) ($F1.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $33C0.w,X		; FD C0 33 ; Subtract with carry $33C0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($7A.b),Y		; 31 7A ; AND accumulator with memory ($7A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpx $0FDF.w		; EC DF 0F ; Compare $0FDF.w with X register [Reads: X Index] [Flags: NCZ]
	inc $77F2.w,X		; FE F2 77 ; Increment memory $77F2.w,X [Reads: X Index] [Flags: NZ]
	eor ($2D.b,S),Y		; 53 2D ; XOR accumulator (stack relative indirect indexed) ($2D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	sbc $26CE.w		; ED CE 26 ; Subtract $26CE.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	eor ($EC.b),Y		; 51 EC ; Exclusive OR accumulator with memory ($EC.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $6A2012.l,X		; DF 12 20 6A ; Compare accumulator (long,X) $6A2012.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	dec $12FF.w,X		; DE FF 12 ; Decrement memory $12FF.w,X [Reads: X Index] [Flags: NZ]
	ora ($0C.b,X)		; 01 0C ; Logical OR ($0C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $B0, $54		; B0 54 ; Branch if carry set to $B0, $54 [Flow: branch]
	.db $30, $8A		; 30 8A ; Branch if minus to $30, $8A [Flow: branch]
	inc $00FF.w,X		; FE FF 00 ; Increment memory $00FF.w,X [Reads: X Index] [Flags: NZ]
	asl $34F1.w		; 0E F1 34 ; Arithmetic shift left $34F1.w [Flags: NCZ]
	and ($00.b),Y		; 31 00 ; AND accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	jsr ($26CE.w,X)		; FC CE 26 ; Jump to subroutine indirect indexed ($26CE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	adc ($DB.b,X)		; 61 DB ; Add with carry ($DB.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $D0, $12		; D0 12 ; Branch if not equal to $D0, $12 [Flow: branch]
	jsr $EF6A.w		; 20 6A EF ; Jump to subroutine at $EF6A.w [Writes: Stack Pointer] [Flow: call]
	jsr ($0221.w,X)		; FC 21 02 ; Jump to subroutine indirect indexed ($0221.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	trb $43BF.w		; 1C BF 43 ; Test and reset bits $43BF.w [Reads: Accumulator] [Flags: Z]
	.db $42, $7A		; 42 7A ; Reserved instruction
	cpx $00DF.w		; EC DF 00 ; Compare $00DF.w with X register [Reads: X Index] [Flags: NCZ]
	inc $57E2.w		; EE E2 57 ; Increment $57E2.w [Flags: NZ]
	mvn $9A,$3E		; 54 3E 9A ; Move block negative $9A,$3E [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sbc $26CE.w		; ED CE 26 ; Subtract $26CE.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	eor ($EC.b),Y		; 51 EC ; Exclusive OR accumulator with memory ($EC.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $6A1F23.l		; CF 23 1F 6A ; Compare accumulator (long) $6A1F23.l [Reads: Accumulator] [Flags: NCZ]
	cop $0E.b		; 02 0E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($12.b),Y		; 11 12 ; OR accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tsb $54AF.w		; 0C AF 54 ; Test and set bits $54AF.w [Reads: Accumulator] [Flags: Z]
	and ($7A.b),Y		; 31 7A ; AND accumulator with memory ($7A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpx $10D0.w		; EC D0 10 ; Compare $10D0.w with X register [Reads: X Index] [Flags: NCZ]
	sbc $56E1.w		; ED E1 56 ; Subtract $56E1.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	eor $52.b,S		; 43 52 ; Exclusive OR accumulator with stack relative $52.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	cpx $26CE.w		; EC CE 26 ; Compare $26CE.w with X register [Reads: X Index] [Flags: NCZ]
	adc ($EB.b,X)		; 61 EB ; Add with carry ($EB.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $6A1122.l		; CF 22 11 6A ; Compare accumulator (long) $6A1122.l [Reads: Accumulator] [Flags: NCZ]
	bit $0290.w,X		; 3C 90 02 ; Test bits $0290.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	and $1C.b,S		; 23 1C ; AND accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	stz $3244.w,X		; 9E 44 32 ; Store zero to $3244.w,X [Reads: X Index]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	sbc $1FD0.w		; ED D0 1F ; Subtract $1FD0.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	inc $36EF.w,X		; FE EF 36 ; Increment memory $36EF.w,X [Reads: X Index] [Flags: NZ]
	adc $22.b,S		; 63 22 ; Add with carry (stack relative) $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	sbc $15CE.w,X		; FD CE 15 ; Subtract with carry $15CE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $62, $EB, $CF		; 62 EB CF ; Push effective relative address $62, $EB, $CF [Writes: Stack Pointer]
	ora ($20.b,S),Y		; 13 20 ; OR accumulator (stack relative indirect indexed) ($20.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	cpx #$01FF.w		; E0 FF 01 ; Compare #$01FF.w with X register [Reads: X Index] [Flags: NCZ]
	ora ($1E.b),Y		; 11 1E ; OR accumulator with memory ($1E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	dec $1033.w		; CE 33 10 ; Decrement $1033.w [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	sbc $1FE0.w,X		; FD E0 1F ; Subtract with carry $1FE0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $44D0.w,X		; FD D0 44 ; Subtract with carry $44D0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	mvp $9A,$51		; 44 51 9A ; Move block positive $9A,$51 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sbc $25CE.w,X		; FD CE 25 ; Subtract with carry $25CE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($EB.b)		; 52 EB ; Exclusive OR accumulator with memory (indirect) ($EB.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $13		; B0 13 ; Branch if carry set to $B0, $13 [Flow: branch]
	ora ($7A.b),Y		; 11 7A ; OR accumulator with memory ($7A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $DF.b		; 00 DF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b),Y		; 11 01 ; OR accumulator with memory ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $23CE.w,X		; 1E CE 23 ; Arithmetic shift left $23CE.w,X [Reads: X Index] [Flags: NCZ]
	and ($7A.b,X)		; 21 7A ; Logical AND ($7A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $11D1.w		; ED D1 11 ; Subtract $11D1.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sbc $23D0.w		; ED D0 23 ; Subtract $23D0.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	eor $52.b		; 45 52 ; Exclusive OR $52.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	sbc $25CE.w,X		; FD CE 25 ; Subtract with carry $25CE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($EA.b,X)		; 61 EA ; Add with carry ($EA.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $7A2023.l		; CF 23 20 7A ; Compare accumulator (long) $7A2023.l [Reads: Accumulator] [Flags: NCZ]
	sbc $0011F0.l		; EF F0 11 00 ; Subtract with carry (long) $0011F0.l [Writes: Accumulator] [Flags: NCVZ]
	asl $22DE.w,X		; 1E DE 22 ; Arithmetic shift left $22DE.w,X [Reads: X Index] [Flags: NCZ]
	jsr $FE7A.w		; 20 7A FE ; Jump to subroutine at $FE7A.w [Writes: Stack Pointer] [Flow: call]
	sbc $CEFE11.l		; EF 11 FE CE ; Subtract with carry (long) $CEFE11.l [Writes: Accumulator] [Flags: NCVZ]
	and $43.b		; 25 43 ; Logical AND $43.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor ($9A.b,S),Y		; 53 9A ; XOR accumulator (stack relative indirect indexed) ($9A.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $26CE.w,X		; FD CE 26 ; Subtract with carry $26CE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($DA.b)		; 52 DA ; Exclusive OR accumulator with memory (indirect) ($DA.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $23		; B0 23 ; Branch if carry set to $B0, $23 [Flow: branch]
	jsr $ED6A.w		; 20 6A ED ; Jump to subroutine at $ED6A.w [Writes: Stack Pointer] [Flow: call]
	.db $F0, $11		; F0 11 ; Branch if equal to $F0, $11 [Flow: branch]
	ora ($0D.b,X)		; 01 0D ; Logical OR ($0D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda $3244.w		; AD 44 32 ; Load $3244.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	sbc $10E0.w,X		; FD E0 10 ; Subtract with carry $10E0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $13DE.w		; 0E DE 13 ; Arithmetic shift left $13DE.w [Flags: NCZ]
	eor $44.b,S		; 43 44 ; Exclusive OR accumulator with stack relative $44.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	ora $16CE.w		; 0D CE 16 ; Logical OR $16CE.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $62, $DA, $BF		; 62 DA BF ; Push effective relative address $62, $DA, $BF [Writes: Stack Pointer]
	and $21.b,S		; 23 21 ; AND accumulator with stack relative $21.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	asl $11D0.w		; 0E D0 11 ; Arithmetic shift left $11D0.w [Flags: NCZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $2122.w,X		; DE 22 21 ; Decrement memory $2122.w,X [Reads: X Index] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	sbc $11E0.w,X		; FD E0 11 ; Subtract with carry $11E0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $13CD.w		; 0E CD 13 ; Arithmetic shift left $13CD.w [Flags: NCZ]
	mvp $9A,$42		; 44 42 9A ; Move block positive $9A,$42 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	inc $15DE.w,X		; FE DE 15 ; Increment memory $15DE.w,X [Reads: X Index] [Flags: NZ]
	.db $62, $E9, $BF		; 62 E9 BF ; Push effective relative address $62, $E9, $BF [Writes: Stack Pointer]
	and $30.b,S		; 23 30 ; AND accumulator with stack relative $30.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	sbc $F1001F.l		; EF 1F 00 F1 ; Subtract with carry (long) $F1001F.l [Writes: Accumulator] [Flags: NCVZ]
	ora $1122CF.l,X		; 1F CF 22 11 ; Logical OR long $1122CF.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	inc $11E0.w,X		; FE E0 11 ; Increment memory $11E0.w,X [Reads: X Index] [Flags: NZ]
	asl $03CD.w		; 0E CD 03 ; Arithmetic shift left $03CD.w [Flags: NCZ]
	eor $54.b,S		; 43 54 ; Exclusive OR accumulator with stack relative $54.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	sbc $15DF.w,X		; FD DF 15 ; Subtract with carry $15DF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $62, $D9, $B0		; 62 D9 B0 ; Push effective relative address $62, $D9, $B0 [Writes: Stack Pointer]
	and $21.b,S		; 23 21 ; AND accumulator with stack relative $21.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	inc $11E0.w		; EE E0 11 ; Increment $11E0.w [Flags: NZ]
	sbc ($1E.b),Y		; F1 1E ; Subtract with carry ($1E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $7A2122.l		; CF 22 21 7A ; Compare accumulator (long) $7A2122.l [Reads: Accumulator] [Flags: NCZ]
	inc $11E0.w,X		; FE E0 11 ; Increment memory $11E0.w,X [Reads: X Index] [Flags: NZ]
	ora $12CE.w		; 0D CE 12 ; Logical OR $12CE.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $55.b,S		; 23 55 ; AND accumulator with stack relative $55.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	inc $16DE.w,X		; FE DE 16 ; Increment memory $16DE.w,X [Reads: X Index] [Flags: NZ]
	adc ($DA.b,X)		; 61 DA ; Add with carry ($DA.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $7A2123.l,X		; BF 23 21 7A ; Load long $7A2123.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $11D0.w,X		; 1E D0 11 ; Arithmetic shift left $11D0.w,X [Reads: X Index] [Flags: NCZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $0133.w		; CE 33 01 ; Decrement $0133.w [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	asl $11E0.w		; 0E E0 11 ; Arithmetic shift left $11E0.w [Flags: NCZ]
	asl $02CD.w		; 0E CD 02 ; Arithmetic shift left $02CD.w [Flags: NCZ]
	and ($44.b,S),Y		; 33 44 ; AND accumulator (stack relative indirect indexed) ($44.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ora $3013EF.l		; 0F EF 13 30 ; OR accumulator with memory (long) $3013EF.l [Writes: Accumulator] [Flags: NZ]
	sbc $12DF.w,X		; FD DF 12 ; Subtract with carry $12DF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr $ED7A.w		; 20 7A ED ; Jump to subroutine at $ED7A.w [Writes: Stack Pointer] [Flow: call]
	and $0101.w		; 2D 01 01 ; Logical AND $0101.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $22CF.w		; 0E CF 22 ; Arithmetic shift left $22CF.w [Flags: NCZ]
	ora ($7A.b)		; 12 7A ; OR accumulator with memory (indirect) ($7A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $11E0.w		; 0E E0 11 ; Arithmetic shift left $11E0.w [Flags: NCZ]
	asl $F2CD.w		; 0E CD F2 ; Arithmetic shift left $F2CD.w [Flags: NCZ]
	and ($44.b,S),Y		; 33 44 ; AND accumulator (stack relative indirect indexed) ($44.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ora $3113EF.l		; 0F EF 13 31 ; OR accumulator with memory (long) $3113EF.l [Writes: Accumulator] [Flags: NZ]
	cpx $11E0.w		; EC E0 11 ; Compare $11E0.w with X register [Reads: X Index] [Flags: NCZ]
	.db $10, $7A		; 10 7A ; Branch if plus to $10, $7A [Flow: branch]
	adc $EB.b,S		; 63 EB ; Add with carry (stack relative) $EB.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $33BE.w,X		; 1E BE 33 ; Arithmetic shift left $33BE.w,X [Reads: X Index] [Flags: NCZ]
	ora ($7A.b),Y		; 11 7A ; OR accumulator with memory ($7A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $12E0.w		; 0E E0 12 ; Arithmetic shift left $12E0.w [Flags: NCZ]
	ora $01BD.w,X		; 1D BD 01 ; OR accumulator with memory $01BD.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $44.b,S		; 23 44 ; AND accumulator with stack relative $44.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ora $3113EF.l		; 0F EF 13 31 ; OR accumulator with memory (long) $3113EF.l [Writes: Accumulator] [Flags: NZ]
	jsr ($12DF.w,X)		; FC DF 12 ; Jump to subroutine indirect indexed ($12DF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr $DF7A.w		; 20 7A DF ; Jump to subroutine at $DF7A.w [Writes: Stack Pointer] [Flow: call]
	ora $1EF100.l,X		; 1F 00 F1 1E ; Logical OR long $1EF100.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dec $2032.w		; CE 32 20 ; Decrement $2032.w [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	ora $0E12E0.l		; 0F E0 12 0E ; OR accumulator with memory (long) $0E12E0.l [Writes: Accumulator] [Flags: NZ]
	cpy $23F1.w		; CC F1 23 ; Compare $23F1.w with Y register [Reads: Y Index] [Flags: NCZ]
	mvp $0F,$AA		; 44 AA 0F ; Move block positive $0F,$AA [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sbc $ED3103.l,X		; FF 03 31 ED ; Subtract with carry (long,X) $ED3103.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $D0, $11		; D0 11 ; Branch if not equal to $D0, $11 [Flow: branch]
	ora ($7A.b),Y		; 11 7A ; OR accumulator with memory ($7A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $00D1.w,X		; 3C D1 00 ; Test bits $00D1.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	sbc ($1E.b),Y		; F1 1E ; Subtract with carry ($1E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $1132.w		; CE 32 11 ; Decrement $1132.w [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	asl $12E0.w,X		; 1E E0 12 ; Arithmetic shift left $12E0.w,X [Reads: X Index] [Flags: NCZ]
	asl $F1BC.w,X		; 1E BC F1 ; Arithmetic shift left $F1BC.w,X [Reads: X Index] [Flags: NCZ]
	jsl $0FAA44.l		; 22 44 AA 0F ; Jump to subroutine long $0FAA44.l [Writes: Stack Pointer] [Flow: call]
	sbc $FC3112.l,X		; FF 12 31 FC ; Subtract with carry (long,X) $FC3112.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $D0, $11		; D0 11 ; Branch if not equal to $D0, $11 [Flow: branch]
	ora ($7A.b),Y		; 11 7A ; OR accumulator with memory ($7A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr $00DF.w		; 4E DF 00 ; Logical shift right $00DF.w [Flags: NCZ]
	ora ($0E.b,X)		; 01 0E ; Logical OR ($0E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp $7A1222.l		; CF 22 12 7A ; Compare accumulator (long) $7A1222.l [Reads: Accumulator] [Flags: NCZ]
	asl $21E1.w		; 0E E1 21 ; Arithmetic shift left $21E1.w [Flags: NCZ]
	asl $F0CC.w		; 0E CC F0 ; Arithmetic shift left $F0CC.w [Flags: NCZ]
	jsl $0FAA34.l		; 22 34 AA 0F ; Jump to subroutine long $0FAA34.l [Writes: Stack Pointer] [Flow: call]
	sbc $FC3013.l,X		; FF 13 30 FC ; Subtract with carry (long,X) $FC3013.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $7A1022.l,X		; DF 22 10 7A ; Compare accumulator (long,X) $7A1022.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	ora ($E0.b),Y		; 11 E0 ; OR accumulator with memory ($E0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $01		; F0 01 ; Branch if equal to $F0, $01 [Flow: branch]
	asl $32CF.w		; 0E CF 32 ; Arithmetic shift left $32CF.w [Flags: NCZ]
	.db $10, $7A		; 10 7A ; Branch if plus to $10, $7A [Flow: branch]
	ora $0E22F0.l		; 0F F0 22 0E ; OR accumulator with memory (long) $0E22F0.l [Writes: Accumulator] [Flags: NZ]
	cpy $13E0.w		; CC E0 13 ; Compare $13E0.w with Y register [Reads: Y Index] [Flags: NCZ]
	eor $AA.b,S		; 43 AA ; Exclusive OR accumulator with stack relative $AA.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $3113FF.l		; 0F FF 13 31 ; OR accumulator with memory (long) $3113FF.l [Writes: Accumulator] [Flags: NZ]
	cpx $11D0.w		; EC D0 11 ; Compare $11D0.w with X register [Reads: X Index] [Flags: NCZ]
	jsr $3E7A.w		; 20 7A 3E ; Jump to subroutine at $3E7A.w [Writes: Stack Pointer] [Flow: call]
	and $F20F.w,X		; 3D 0F F2 ; AND accumulator with memory $F20F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $33BF.w,X		; 1D BF 33 ; OR accumulator with memory $33BF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($7A.b),Y		; 11 7A ; OR accumulator with memory ($7A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $1E11F1.l,X		; FF F1 11 1E ; Subtract with carry (long,X) $1E11F1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy $12E0.w		; CC E0 12 ; Compare $12E0.w with Y register [Reads: Y Index] [Flags: NCZ]
	bit $AA.b,X		; 34 AA ; Test bits $AA.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora $3112F0.l		; 0F F0 12 31 ; OR accumulator with memory (long) $3112F0.l [Writes: Accumulator] [Flags: NZ]
	cpx $12D0.w		; EC D0 12 ; Compare $12D0.w with X register [Reads: X Index] [Flags: NCZ]
	.db $10, $7A		; 10 7A ; Branch if plus to $10, $7A [Flow: branch]
	and ($0D.b)		; 32 0D ; AND accumulator with memory (indirect) ($0D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $32CF.w		; 0D CF 32 ; Logical OR $32CF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($7A.b),Y		; 11 7A ; OR accumulator with memory ($7A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $1D22F0.l		; 0F F0 22 1D ; OR accumulator with memory (long) $1D22F0.l [Writes: Accumulator] [Flags: NZ]
	ldy $12F0.w,X		; BC F0 12 ; Load Y register $12F0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	and $AA.b,S		; 23 AA ; AND accumulator with stack relative $AA.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $3013F0.l		; 0F F0 13 30 ; OR accumulator with memory (long) $3013F0.l [Writes: Accumulator] [Flags: NZ]
	cpx $12D0.w		; EC D0 12 ; Compare $12D0.w with X register [Reads: X Index] [Flags: NCZ]
	ora ($7A.b),Y		; 11 7A ; OR accumulator with memory ($7A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$01D0.w		; E0 D0 01 ; Compare #$01D0.w with X register [Reads: X Index] [Flags: NCZ]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec COLDATA.w		; CE 32 21 ; Decrement COLDATA.w [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	asl $21F1.w		; 0E F1 21 ; Arithmetic shift left $21F1.w [Flags: NCZ]
	asl $FFCB.w,X		; 1E CB FF ; Arithmetic shift left $FFCB.w,X [Reads: X Index] [Flags: NCZ]
	ora ($33.b),Y		; 11 33 ; OR accumulator with memory ($33.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ora $3013F0.l		; 0F F0 13 30 ; OR accumulator with memory (long) $3013F0.l [Writes: Accumulator] [Flags: NZ]
	cpx $12D0.w		; EC D0 12 ; Compare $12D0.w with X register [Reads: X Index] [Flags: NCZ]
	ora ($7A.b),Y		; 11 7A ; OR accumulator with memory ($7A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $D1		; D0 D1 ; Branch if not equal to $D0, $D1 [Flow: branch]
	ora ($F0.b,X)		; 01 F0 ; Logical OR ($F0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $32CF.w		; 0E CF 32 ; Arithmetic shift left $32CF.w [Flags: NCZ]
	ora ($7A.b),Y		; 11 7A ; OR accumulator with memory ($7A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $21F2.w		; 0E F2 21 ; Arithmetic shift left $21F2.w [Flags: NCZ]
	asl $EFCC.w		; 0E CC EF ; Arithmetic shift left $EFCC.w [Flags: NCZ]
	ora ($23.b)		; 12 23 ; OR accumulator with memory (indirect) ($23.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ora $3013F0.l		; 0F F0 13 30 ; OR accumulator with memory (long) $3013F0.l [Writes: Accumulator] [Flags: NZ]
	cpx $12D0.w		; EC D0 12 ; Compare $12D0.w with X register [Reads: X Index] [Flags: NCZ]
	ora ($7A.b),Y		; 11 7A ; OR accumulator with memory ($7A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $F10FE2.l,X		; DF E2 0F F1 ; Compare accumulator (long,X) $F10FE2.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	asl $33BE.w,X		; 1E BE 33 ; Arithmetic shift left $33BE.w,X [Reads: X Index] [Flags: NCZ]
	ora ($7A.b),Y		; 11 7A ; OR accumulator with memory ($7A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $1E12F1.l		; 0F F1 12 1E ; OR accumulator with memory (long) $1E12F1.l [Writes: Accumulator] [Flags: NZ]
	ldy $01FF.w,X		; BC FF 01 ; Load Y register $01FF.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	and ($AA.b)		; 32 AA ; AND accumulator with memory (indirect) ($AA.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $301200.l		; 0F 00 12 30 ; OR accumulator with memory (long) $301200.l [Writes: Accumulator] [Flags: NZ]
	cpx $12D0.w		; EC D0 12 ; Compare $12D0.w with X register [Reads: X Index] [Flags: NCZ]
	ora ($7A.b),Y		; 11 7A ; OR accumulator with memory ($7A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsr $F0CF.w		; 20 CF F0 ; Jump to subroutine at $F0CF.w [Writes: Stack Pointer] [Flow: call]
	ora ($FE.b,X)		; 01 FE ; Logical OR ($FE.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp $7A2122.l		; CF 22 21 7A ; Compare accumulator (long) $7A2122.l [Reads: Accumulator] [Flags: NCZ]
	asl $2101.w		; 0E 01 21 ; Arithmetic shift left $2101.w [Flags: NCZ]
	asl $EECC.w,X		; 1E CC EE ; Arithmetic shift left $EECC.w,X [Reads: X Index] [Flags: NCZ]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ora $301200.l		; 0F 00 12 30 ; OR accumulator with memory (long) $301200.l [Writes: Accumulator] [Flags: NZ]
	cpx $12EF.w		; EC EF 12 ; Compare $12EF.w with X register [Reads: X Index] [Flags: NCZ]
	jsr $F07A.w		; 20 7A F0 ; Jump to subroutine at $F07A.w [Writes: Stack Pointer] [Flow: call]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	.db $F0, $0E		; F0 0E ; Branch if equal to $F0, $0E [Flow: branch]
	cmp $7A1132.l		; CF 32 11 7A ; Compare accumulator (long) $7A1132.l [Reads: Accumulator] [Flags: NCZ]
	ora $1E22F1.l		; 0F F1 22 1E ; OR accumulator with memory (long) $1E22F1.l [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	sbc $AA2201.l,X		; FF 01 22 AA ; Subtract with carry (long,X) $AA2201.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $311200.l		; 0F 00 12 31 ; OR accumulator with memory (long) $311200.l [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $12		; D0 12 ; Branch if not equal to $D0, $12 [Flow: branch]
	jsr $F17A.w		; 20 7A F1 ; Jump to subroutine at $F17A.w [Writes: Stack Pointer] [Flow: call]
	asl $F10F.w,X		; 1E 0F F1 ; Arithmetic shift left $F10F.w,X [Reads: X Index] [Flags: NCZ]
	asl $32CE.w		; 0E CE 32 ; Arithmetic shift left $32CE.w [Flags: NCZ]
	jsr $0F7A.w		; 20 7A 0F ; Jump to subroutine at $0F7A.w [Writes: Stack Pointer] [Flow: call]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $FFBC.w		; 0E BC FF ; Arithmetic shift left $FFBC.w [Flags: NCZ]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ora $311200.l		; 0F 00 12 31 ; OR accumulator with memory (long) $311200.l [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $12		; D0 12 ; Branch if not equal to $D0, $12 [Flow: branch]
	jsr $F17A.w		; 20 7A F1 ; Jump to subroutine at $F17A.w [Writes: Stack Pointer] [Flow: call]
	ora $0000.w,X		; 1D 00 00 ; OR accumulator with memory $0000.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $32CF.w		; 0D CF 32 ; Logical OR $32CF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($7A.b),Y		; 11 7A ; OR accumulator with memory ($7A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $1E2101.l		; 0F 01 21 1E ; OR accumulator with memory (long) $1E2101.l [Writes: Accumulator] [Flags: NZ]
	wai		; CB ; Wait for interrupt
	sbc $AA1111.l		; EF 11 11 AA ; Subtract with carry (long) $AA1111.l [Writes: Accumulator] [Flags: NCVZ]
	ora $311200.l		; 0F 00 12 31 ; OR accumulator with memory (long) $311200.l [Writes: Accumulator] [Flags: NZ]
	cpx $12C0.w		; EC C0 12 ; Compare $12C0.w with X register [Reads: X Index] [Flags: NCZ]
	ora ($7A.b),Y		; 11 7A ; OR accumulator with memory ($7A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $F001CF.l		; 4F CF 01 F0 ; Exclusive OR accumulator with memory (long) $F001CF.l [Writes: Accumulator] [Flags: NZ]
	inc $32CF.w,X		; FE CF 32 ; Increment memory $32CF.w,X [Reads: X Index] [Flags: NZ]
	ora ($7A.b),Y		; 11 7A ; OR accumulator with memory ($7A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $1E2101.l		; 0F 01 21 1E ; OR accumulator with memory (long) $1E2101.l [Writes: Accumulator] [Flags: NZ]
	wai		; CB ; Wait for interrupt
	sbc $AA1110.l		; EF 10 11 AA ; Subtract with carry (long) $AA1110.l [Writes: Accumulator] [Flags: NCVZ]
	ora $301300.l		; 0F 00 13 30 ; OR accumulator with memory (long) $301300.l [Writes: Accumulator] [Flags: NZ]
	cpx $23CF.w		; EC CF 23 ; Compare $23CF.w with X register [Reads: X Index] [Flags: NCZ]
	.db $10, $7A		; 10 7A ; Branch if plus to $10, $7A [Flow: branch]
	ora ($E0.b)		; 12 E0 ; OR accumulator with memory (indirect) ($E0.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $F1		; F0 F1 ; Branch if equal to $F0, $F1 [Flow: branch]
	inc $22CF.w,X		; FE CF 22 ; Increment memory $22CF.w,X [Reads: X Index] [Flags: NZ]
	and ($7A.b,X)		; 21 7A ; Logical AND ($7A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $1E2101.l		; 0F 01 21 1E ; OR accumulator with memory (long) $1E2101.l [Writes: Accumulator] [Flags: NZ]
	ldy $F1FF.w,X		; BC FF F1 ; Load Y register $F1FF.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ora ($AA.b),Y		; 11 AA ; OR accumulator with memory ($AA.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $301300.l		; 0F 00 13 30 ; OR accumulator with memory (long) $301300.l [Writes: Accumulator] [Flags: NZ]
	cpx $23CF.w		; EC CF 23 ; Compare $23CF.w with X register [Reads: X Index] [Flags: NCZ]
	.db $10, $7A		; 10 7A ; Branch if plus to $10, $7A [Flow: branch]
	ora ($E0.b)		; 12 E0 ; OR accumulator with memory (indirect) ($E0.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $CE0EF0.l		; 0F F0 0E CE ; OR accumulator with memory (long) $CE0EF0.l [Writes: Accumulator] [Flags: NZ]
	and ($11.b,S),Y		; 33 11 ; AND accumulator (stack relative indirect indexed) ($11.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	ora $0E22F2.l		; 0F F2 22 0E ; OR accumulator with memory (long) $0E22F2.l [Writes: Accumulator] [Flags: NZ]
	ldy $11EF.w,X		; BC EF 11 ; Load Y register $11EF.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	brk $AA.b		; 00 AA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $301300.l		; 0F 00 13 30 ; OR accumulator with memory (long) $301300.l [Writes: Accumulator] [Flags: NZ]
	cpx $12C0.w		; EC C0 12 ; Compare $12C0.w with X register [Reads: X Index] [Flags: NCZ]
	ora ($7A.b),Y		; 11 7A ; OR accumulator with memory ($7A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor ($DD.b,X)		; 41 DD ; Exclusive OR accumulator with memory ($DD.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $BF1DF0.l,X		; 1F F0 1D BF ; Logical OR long $BF1DF0.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $42, $01		; 42 01 ; Reserved instruction
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	ora $0E32F1.l,X		; 1F F1 32 0E ; Logical OR long $0E32F1.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldy $01EF.w,X		; BC EF 01 ; Load Y register $01EF.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	.db $10, $AA		; 10 AA ; Branch if plus to $10, $AA [Flow: branch]
	ora $301300.l		; 0F 00 13 30 ; OR accumulator with memory (long) $301300.l [Writes: Accumulator] [Flags: NZ]
	cpx $12C0.w		; EC C0 12 ; Compare $12C0.w with X register [Reads: X Index] [Flags: NCZ]
	ora ($7A.b),Y		; 11 7A ; OR accumulator with memory ($7A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor ($DD.b,X)		; 41 DD ; Exclusive OR accumulator with memory ($DD.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $FF		; 10 FF ; Branch if plus to $10, $FF [Flow: branch]
	asl $33CE.w		; 0E CE 33 ; Arithmetic shift left $33CE.w [Flags: NCZ]
	ora ($7A.b),Y		; 11 7A ; OR accumulator with memory ($7A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $0E22F2.l		; 0F F2 22 0E ; OR accumulator with memory (long) $0E22F2.l [Writes: Accumulator] [Flags: NZ]
	ldy $00FF.w,X		; BC FF 00 ; Load Y register $00FF.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ora ($AA.b,X)		; 01 AA ; Logical OR ($AA.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $301300.l		; 0F 00 13 30 ; OR accumulator with memory (long) $301300.l [Writes: Accumulator] [Flags: NZ]
	cpx $12C0.w		; EC C0 12 ; Compare $12C0.w with X register [Reads: X Index] [Flags: NCZ]
	ora ($7A.b),Y		; 11 7A ; OR accumulator with memory ($7A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor ($DD.b,X)		; 41 DD ; Exclusive OR accumulator with memory ($DD.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $F1.b		; 00 F1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $32BF.w		; 0D BF 32 ; Logical OR $32BF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and ($7A.b,X)		; 21 7A ; Logical AND ($7A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $0E32F1.l		; 0F F1 32 0E ; OR accumulator with memory (long) $0E32F1.l [Writes: Accumulator] [Flags: NZ]
	ldy $00E0.w,X		; BC E0 00 ; Load Y register $00E0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ora ($AA.b,X)		; 01 AA ; Logical OR ($AA.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $301300.l		; 0F 00 13 30 ; OR accumulator with memory (long) $301300.l [Writes: Accumulator] [Flags: NZ]
	cpx $12C0.w		; EC C0 12 ; Compare $12C0.w with X register [Reads: X Index] [Flags: NCZ]
	ora ($7A.b),Y		; 11 7A ; OR accumulator with memory ($7A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor ($DD.b,X)		; 41 DD ; Exclusive OR accumulator with memory ($DD.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $E0		; 10 E0 ; Branch if plus to $10, $E0 [Flow: branch]
	asl $33BF.w		; 0E BF 33 ; Arithmetic shift left $33BF.w [Flags: NCZ]
	ora ($7B.b),Y		; 11 7B ; OR accumulator with memory ($7B.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $0E32F1.l		; 0F F1 32 0E ; OR accumulator with memory (long) $0E32F1.l [Writes: Accumulator] [Flags: NZ]
	ldy $00E0.w,X		; BC E0 00 ; Load Y register $00E0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	dec $CDED.w,X		; DE ED CD ; Decrement memory $CDED.w,X [Reads: X Index] [Flags: NZ]
	cmp $EBDEDE.l,X		; DF DE DE EB ; Compare accumulator (long,X) $EBDEDE.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl $DECD.w		; 0E CD DE ; Arithmetic shift left $DECD.w [Flags: NCZ]
	inc $F0FE.w		; EE FE F0 ; Increment $F0FE.w [Flags: NZ]
	inc $5AF1.w		; EE F1 5A ; Increment $5AF1.w [Flags: NZ]
	cop $21.b		; 02 21 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($00.b,X)		; 21 00 ; Logical AND ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and ($23.b,X)		; 21 23 ; Logical AND ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($43.b)		; 12 43 ; OR accumulator with memory (indirect) ($43.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	eor $43.b		; 45 43 ; Exclusive OR $43.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	mvn $32,$32		; 54 32 32 ; Move block negative $32,$32 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	and ($32.b,S),Y		; 33 32 ; AND accumulator (stack relative indirect indexed) ($32.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $5A.b,X		; 34 5A ; Test bits $5A.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $ECDF.w		; 0E DF EC ; Arithmetic shift left $ECDF.w [Flags: NCZ]
	dec $CEDD.w,X		; DE DD CE ; Decrement memory $CEDD.w,X [Reads: X Index] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	cpy $DCBC.w		; CC BC DC ; Compare $DCBC.w with Y register [Reads: Y Index] [Flags: NCZ]
	cmp $EFDE.w		; CD DE EF ; Compare $EFDE.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	inc $4AFF.w		; EE FF 4A ; Increment $4AFF.w [Flags: NZ]
	.db $F0, $02		; F0 02 ; Branch if equal to $F0, $02 [Flow: branch]
	bit $64.b,X		; 34 64 ; Test bits $64.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	mvp $45,$65		; 44 65 45 ; Move block positive $45,$65 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	mvp $61,$4A		; 44 4A 61 ; Move block positive $61,$4A [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	bit $42.b,X		; 34 42 ; Test bits $42.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and ($00.b,X)		; 21 00 ; Logical AND ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	inc $DC0E.w		; EE 0E DC ; Increment $DC0E.w [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	jmp.w [$CCFB]		; DC FB CC ; Jump long indirect [$CCFB] [Flow: jump]
	cmp $9CCA.w		; CD CA 9C ; Compare $9CCA.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	sta $5AEC.w,X		; 9D EC 5A ; Store accumulator to $5AEC.w,X [Reads: Accumulator, X Index]
	inc $1FE0.w,X		; FE E0 1F ; Increment memory $1FE0.w,X [Reads: X Index] [Flags: NZ]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $5A4334.l		; 22 34 43 5A ; Jump to subroutine long $5A4334.l [Writes: Stack Pointer] [Flow: call]
	bit $45.b,X		; 34 45 ; Test bits $45.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	mvn $43,$34		; 54 34 43 ; Move block negative $43,$34 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	and ($41.b)		; 32 41 ; AND accumulator with memory (indirect) ($41.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($4A.b,X)		; 21 4A ; Logical AND ($4A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsr $2FF1.w		; 20 F1 2F ; Jump to subroutine at $2FF1.w [Writes: Stack Pointer] [Flow: call]
	cmp ($CD.b),Y		; D1 CD ; Compare accumulator ($CD.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	inc $BBBC.w,X		; FE BC BB ; Increment memory $BBBC.w,X [Reads: X Index] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	cpx $EDED.w		; EC ED ED ; Compare $EDED.w with X register [Reads: X Index] [Flags: NCZ]
	cmp $EFEECF.l,X		; DF CF EE EF ; Compare accumulator (long,X) $EFEECF.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	brk $4A.b		; 00 4A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($13.b)		; D2 13 ; Compare accumulator (indirect) ($13.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	eor ($53.b)		; 52 53 ; Exclusive OR accumulator with memory (indirect) ($53.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b),Y		; 11 01 ; OR accumulator with memory ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($24.b,X)		; 21 24 ; Logical AND ($24.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $DDFD.w		; 20 FD DD ; Jump to subroutine at $DDFD.w [Writes: Stack Pointer] [Flow: call]
	cpy $DFDC.w		; CC DC DF ; Compare $DFDC.w with Y register [Reads: Y Index] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	jmp.w [$BECA]		; DC CA BE ; Jump long indirect [$BECA] [Flow: jump]
	cop $42.b		; 02 42 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $5A,$53		; 44 53 5A ; Move block positive $5A,$53 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora ($01.b),Y		; 11 01 ; OR accumulator with memory ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($F1.b,X)		; 01 F1 ; Logical OR ($F1.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $12.b,X		; 34 12 ; Test bits $12.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	eor $33.b,S		; 43 33 ; Exclusive OR accumulator with stack relative $33.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	rol $32.b		; 26 32 ; Rotate left $32.b [Reads: Direct Page] [Flags: NCZ]
	ora ($10.b,S),Y		; 13 10 ; OR accumulator (stack relative indirect indexed) ($10.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc ($2F.b)		; F2 2F ; Subtract with carry (indirect) ($2F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	jsr ($DED2.w,X)		; FC D2 DE ; Jump to subroutine indirect indexed ($DED2.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $4AF00F.l,X		; FF 0F F0 4A ; Subtract with carry (long,X) $4AF00F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $F0DC.w,X		; DD DC F0 ; Compare accumulator $F0DC.w,X [Reads: X Index] [Flags: NCZ]
	dec $FF1D.w		; CE 1D FF ; Decrement $FF1D.w [Flags: NZ]
	cop $FE.b		; 02 FE ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	jsl $31120F.l		; 22 0F 12 31 ; Jump to subroutine long $31120F.l [Writes: Stack Pointer] [Flow: call]
	trb $13.b		; 14 13 ; Test and reset bits $13.b [Reads: Accumulator] [Flags: Z]
	and ($13.b,X)		; 21 13 ; Logical AND ($13.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,X		; 15 03 ; OR accumulator with memory $03.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc $CE1C.w		; 6D 1C CE ; Add $CE1C.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	lda $0DBD.w		; AD BD 0D ; Load $0DBD.w into accumulator [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cpy #$CCDA.w		; C0 DA CC ; Compare #$CCDA.w with Y register [Reads: Y Index] [Flags: NCZ]
	wai		; CB ; Wait for interrupt
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	lda $5ACC.w,X		; BD CC 5A ; Load $5ACC.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $F101FF.l,X		; FF FF 01 F1 ; Subtract with carry (long,X) $F101FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($34.b,S),Y		; 13 34 ; OR accumulator (stack relative indirect indexed) ($34.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	mvp $5A,$14		; 44 14 5A ; Move block positive $5A,$14 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	eor $23.b,S		; 43 23 ; Exclusive OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $22.b,X		; 34 22 ; Test bits $22.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and ($43.b)		; 32 43 ; AND accumulator with memory (indirect) ($43.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($32.b)		; 12 32 ; OR accumulator with memory (indirect) ($32.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $CC0DF1.l		; 0F F1 0D CC ; OR accumulator with memory (long) $CC0DF1.l [Writes: Accumulator] [Flags: NZ]
	sbc $ABCE.w		; ED CE AB ; Subtract $ABCE.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cmp $EDCD.w,X		; DD CD ED ; Compare accumulator $EDCD.w,X [Reads: X Index] [Flags: NCZ]
	dec $FF00.w		; CE 00 FF ; Decrement $FF00.w [Flags: NZ]
	brk $4A.b		; 00 4A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($00.b,S),Y		; F3 00 ; Subtract with carry (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	and ($12.b)		; 32 12 ; AND accumulator with memory (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor ($26.b,X)		; 41 26 ; Exclusive OR accumulator with memory ($26.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $22.b,S		; 23 22 ; AND accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	eor $42.b,S		; 43 42 ; Exclusive OR accumulator with stack relative $42.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($4F.b)		; 32 4F ; AND accumulator with memory (indirect) ($4F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($22.b),Y		; 11 22 ; OR accumulator with memory ($22.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($E0.b,X)		; 21 E0 ; Logical AND ($E0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	asl $E0EE.w		; 0E EE E0 ; Arithmetic shift left $E0EE.w [Flags: NCZ]
	sbc $CEEBEE.l,X		; FF EE EB CE ; Subtract with carry (long,X) $CEEBEE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $CF5A.w,X		; DE 5A CF ; Decrement memory $CF5A.w,X [Reads: X Index] [Flags: NZ]
	cmp $DCCB.w,X		; DD CB DC ; Compare accumulator $DCCB.w,X [Reads: X Index] [Flags: NCZ]
	cmp $4534F1.l		; CF F1 34 45 ; Compare accumulator (long) $4534F1.l [Reads: Accumulator] [Flags: NCZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($23.b),Y		; 11 23 ; OR accumulator with memory ($23.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $22.b,S		; 43 22 ; Exclusive OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cmp ($55.b),Y		; D1 55 ; Compare accumulator ($55.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	mvp $53,$23		; 44 23 53 ; Move block positive $53,$23 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	asl $DC1F.w		; 0E 1F DC ; Arithmetic shift left $DC1F.w [Flags: NCZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	dec $0DDE.w,X		; DE DE 0D ; Decrement memory $0DDE.w,X [Reads: X Index] [Flags: NZ]
	ldx $DFED.w,Y		; BE ED DF ; Load X register $DFED.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	sbc $CC4A0F.l		; EF 0F 4A CC ; Subtract with carry (long) $CC4A0F.l [Writes: Accumulator] [Flags: NCVZ]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $34.b		; 06 34 ; Arithmetic shift left $34.b [Reads: Direct Page] [Flags: NCZ]
	ora ($05.b),Y		; 11 05 ; OR accumulator with memory ($05.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $115A.w		; 4D 5A 11 ; Exclusive OR $115A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and ($14.b,X)		; 21 14 ; Logical AND ($14.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and ($30.b)		; 32 30 ; AND accumulator with memory (indirect) ($30.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($13.b,X)		; 01 13 ; Logical OR ($13.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $5A.b		; 00 5A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $01		; F0 01 ; Branch if equal to $F0, $01 [Flow: branch]
	jmp.w [$FFCD]		; DC CD FF ; Jump long indirect [$FFCD] [Flow: jump]
	sbc $CEDD.w		; ED DD CE ; Subtract $CEDD.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	sbc $EDDE.w		; ED DE ED ; Subtract $EDDE.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	cmp $253114.l		; CF 14 31 25 ; Compare accumulator (long) $253114.l [Reads: Accumulator] [Flags: NCZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and $45.b,X		; 35 45 ; Logical AND $45.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor $31.b,X		; 55 31 ; Exclusive OR accumulator with memory $31.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $231220.l		; 22 20 12 23 ; Jump to subroutine long $231220.l [Writes: Stack Pointer] [Flow: call]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	and ($22.b)		; 32 22 ; AND accumulator with memory (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $BCCA00.l		; 0F 00 CA BC ; OR accumulator with memory (long) $BCCA00.l [Writes: Accumulator] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cmp $DECC.w,X		; DD CC DE ; Compare accumulator $DECC.w,X [Reads: X Index] [Flags: NCZ]
	inc $FFEF.w		; EE EF FF ; Increment $FFEF.w [Flags: NZ]
	inc $5AFF.w,X		; FE FF 5A ; Increment memory $5AFF.w,X [Reads: X Index] [Flags: NZ]
	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $341212.l		; 22 12 12 34 ; Jump to subroutine long $341212.l [Writes: Stack Pointer] [Flow: call]
	and $55.b,X		; 35 55 ; Logical AND $55.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	mvp $46,$34		; 44 34 46 ; Move block positive $46,$34 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	eor ($0F.b)		; 52 0F ; Exclusive OR accumulator with memory (indirect) ($0F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $23		; F0 23 ; Branch if equal to $F0, $23 [Flow: branch]
	jsr $FE5A.w		; 20 5A FE ; Jump to subroutine at $FE5A.w [Writes: Stack Pointer] [Flow: call]
	dec $EC01.w		; CE 01 EC ; Decrement $EC01.w [Flags: NZ]
	inc $B9DB.w		; EE DB B9 ; Increment $B9DB.w [Flags: NZ]
	dec $FF7A.w		; CE 7A FF ; Decrement $FF7A.w [Flags: NZ]
	sbc $0EF0FE.l,X		; FF FE F0 0E ; Subtract with carry (long,X) $0EF0FE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$3512.w		; E0 12 35 ; Compare #$3512.w with X register [Reads: X Index] [Flags: NCZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	mvn $22,$22		; 54 22 22 ; Move block negative $22,$22 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	.db $10, $01		; 10 01 ; Branch if plus to $10, $01 [Flow: branch]
	ora ($01.b),Y		; 11 01 ; OR accumulator with memory ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($6A.b),Y		; 11 6A ; OR accumulator with memory ($6A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($11.b),Y		; F1 11 ; Subtract with carry ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $DEFE.w,X		; FE FE DE ; Increment memory $DEFE.w,X [Reads: X Index] [Flags: NZ]
	cpx $CBDE.w		; EC DE CB ; Compare $CBDE.w with X register [Reads: X Index] [Flags: NCZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	wai		; CB ; Wait for interrupt
	ldy $BBBB.w,X		; BC BB BB ; Load Y register $BBBB.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ldy $00DF.w,X		; BC DF 00 ; Load Y register $00DF.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	and ($5A.b,S),Y		; 33 5A ; AND accumulator (stack relative indirect indexed) ($5A.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($43.b,S),Y		; 33 43 ; AND accumulator (stack relative indirect indexed) ($43.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	mvn $24,$22		; 54 22 24 ; Move block negative $24,$22 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	eor $44.b		; 45 44 ; Exclusive OR $44.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc [$5A.b]		; 67 5A ; Add with carry (long) [$5A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	mvp $23,$65		; 44 65 23 ; Move block positive $23,$65 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	eor $22.b,X		; 55 22 ; Exclusive OR accumulator with memory $22.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and ($FD.b,X)		; 21 FD ; Logical AND ($FD.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	dec $FE5A.w,X		; DE 5A FE ; Decrement memory $FE5A.w,X [Reads: X Index] [Flags: NZ]
	cmp $DC9ED9.l,X		; DF D9 9E DC ; Compare accumulator (long,X) $DC9ED9.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	ldy $DCFE.w		; AC FE DC ; Load $DCFE.w into Y register [Writes: Y Index] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	inc $FF00.w,X		; FE 00 FF ; Increment memory $FF00.w,X [Reads: X Index] [Flags: NZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $23		; F0 23 ; Branch if equal to $F0, $23 [Flow: branch]
	lsr $8A.b,X		; 56 8A ; Logical shift right $8A.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	mvp $0F,$21		; 44 21 0F ; Move block positive $0F,$21 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cpx #$0101.w		; E0 01 01 ; Compare #$0101.w with X register [Reads: X Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $30, $0E		; 30 0E ; Branch if minus to $30, $0E [Flow: branch]
	inc $DEDE.w,X		; FE DE DE ; Increment memory $DEDE.w,X [Reads: X Index] [Flags: NZ]
	jmp.w [$DDCD]		; DC CD DD ; Jump long indirect [$DDCD] [Flow: jump]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cpy $CBDC.w		; CC DC CB ; Compare $CBDC.w with Y register [Reads: Y Index] [Flags: NCZ]
	lda $EECD.w,X		; BD CD EE ; Load $EECD.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	and ($03.b)		; 32 03 ; AND accumulator with memory (indirect) ($03.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $554655.l		; 22 55 46 55 ; Jump to subroutine long $554655.l [Writes: Stack Pointer] [Flow: call]
	mvp $5A,$44		; 44 44 5A ; Move block positive $5A,$44 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	and ($10.b),Y		; 31 10 ; AND accumulator with memory ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsr $44E0.w		; 20 E0 44 ; Jump to subroutine at $44E0.w [Writes: Stack Pointer] [Flow: call]
	ora $5ACF31.l,X		; 1F 31 CF 5A ; Logical OR long $5ACF31.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $EE		; 10 EE ; Branch if plus to $10, $EE [Flow: branch]
	cmp $EDDD.w,X		; DD DD ED ; Compare accumulator $EDDD.w,X [Reads: X Index] [Flags: NCZ]
	jmp.w [$1FDE]		; DC DE 1F ; Jump long indirect [$1FDE] [Flow: jump]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
.ACCU 8
	sep #$21		; E2 21
	ora ($52.b,S),Y		; 13 52 ; OR accumulator (stack relative indirect indexed) ($52.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($04.b,S),Y		; 33 04 ; AND accumulator (stack relative indirect indexed) ($04.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($31.b,X)		; 21 31 ; Logical AND ($31.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($24.b)		; 12 24 ; OR accumulator with memory (indirect) ($24.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($00.b),Y		; 31 00 ; AND accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $0000FF.l,X		; FF FF 00 00 ; Subtract with carry (long,X) $0000FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	lsr $FFBD.w,X		; 5E BD FF ; Logical shift right $FFBD.w,X [Reads: X Index] [Flags: NCZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	wai		; CB ; Wait for interrupt
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	lda #$AB.b		; A9 AB ; Load #$AB.b into accumulator [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	stz $BBCC.w		; 9C CC BB ; Store zero to $BBCC.w
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	lda $D11F.w		; AD 1F D1 ; Load $D11F.w into accumulator [Writes: Accumulator] [Flags: NZ]
	and $6A.b,S		; 23 6A ; AND accumulator with stack relative $6A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($10.b,X)		; 21 10 ; Logical AND ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $10E1.w		; 0D E1 10 ; Logical OR $10E1.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and ($24.b,X)		; 21 24 ; Logical AND ($24.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $30, $5A		; 30 5A ; Branch if minus to $30, $5A [Flow: branch]
	bit $1E.b,X		; 34 1E ; Test bits $1E.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sbc ($0F.b),Y		; F1 0F ; Subtract with carry ($0F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $DC12.w,X		; DE 12 DC ; Decrement memory $DC12.w,X [Reads: X Index] [Flags: NZ]
	ora ($4A.b,S),Y		; 13 4A ; OR accumulator (stack relative indirect indexed) ($4A.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	mvp $00,$EE		; 44 EE 00 ; Move block positive $00,$EE [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sbc $21D0.w,X		; FD D0 21 ; Subtract with carry $21D0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $6A.b		; 02 6A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $224312.l		; 22 12 43 22 ; Jump to subroutine long $224312.l [Writes: Stack Pointer] [Flow: call]
	eor $21.b,S		; 43 21 ; Exclusive OR accumulator with stack relative $21.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($F0.b),Y		; 11 F0 ; OR accumulator with memory ($F0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $55.b,S		; 23 55 ; AND accumulator with stack relative $55.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor ($0C.b),Y		; 51 0C ; Exclusive OR accumulator with memory ($0C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	dec $5AFE.w,X		; DE FE 5A ; Decrement memory $5AFE.w,X [Reads: X Index] [Flags: NZ]
	sbc $BECA0D.l		; EF 0D CA BE ; Subtract with carry (long) $BECA0D.l [Writes: Accumulator] [Flags: NCVZ]
	cmp $ACAB.w		; CD AB AC ; Compare $ACAB.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ldy $CC5A.w,X		; BC 5A CC ; Load Y register $CC5A.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	dec $EFDD.w		; CE DD EF ; Decrement $EFDD.w [Flags: NZ]
	.db $F0, $01		; F0 01 ; Branch if equal to $F0, $01 [Flow: branch]
	sbc $5AF0.w,X		; FD F0 5A ; Subtract with carry $5AF0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $40.b,S		; 23 40 ; AND accumulator with stack relative $40.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $3401.w		; CE 01 34 ; Decrement $3401.w [Flags: NZ]
	and ($5A.b,S),Y		; 33 5A ; AND accumulator (stack relative indirect indexed) ($5A.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($10.b)		; 32 10 ; AND accumulator with memory (indirect) ($10.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $EE		; 10 EE ; Branch if plus to $10, $EE [Flow: branch]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $D0, $0C		; D0 0C ; Branch if not equal to $D0, $0C [Flow: branch]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	sbc ($0C.b,X)		; E1 0C ; Subtract with carry ($0C.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$EF0E.w		; E0 0E EF ; Compare #$EF0E.w with X register [Reads: X Index] [Flags: NCZ]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	bit $5A.b		; 24 5A ; Test bits $5A.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	and ($55.b,X)		; 21 55 ; Logical AND ($55.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor $67.b		; 45 67 ; Exclusive OR $67.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $67.b		; 45 67 ; Exclusive OR $67.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	mvn $6A,$12		; 54 12 6A ; Move block negative $6A,$12 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $551201.l,X		; 1F 01 12 55 ; Logical OR long $551201.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	mvn $0E,$52		; 54 52 0E ; Move block negative $0E,$52 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	dec $BA5A.w,X		; DE 5A BA ; Decrement memory $BA5A.w,X [Reads: X Index] [Flags: NZ]
	cpy $CCDC.w		; CC DC CC ; Compare $CCDC.w with Y register [Reads: Y Index] [Flags: NCZ]
	jmp.w [$AAAB]		; DC AB AA ; Jump long indirect [$AAAB] [Flow: jump]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	cmp $DCEE.w		; CD EE DC ; Compare $DCEE.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	dec $FE01.w,X		; DE 01 FE ; Decrement memory $FE01.w,X [Reads: X Index] [Flags: NZ]
	jmp.w [$5AEF]		; DC EF 5A ; Jump long indirect [$5AEF] [Flow: jump]
	.db $F0, $FF		; F0 FF ; Branch if equal to $F0, $FF [Flow: branch]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	mvp $55,$45		; 44 45 55 ; Move block positive $55,$45 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	and ($4A.b),Y		; 31 4A ; AND accumulator with memory ($4A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cmp $E301.w,X		; DD 01 E3 ; Compare accumulator $E301.w,X [Reads: X Index] [Flags: NCZ]
	and ($11.b)		; 32 11 ; AND accumulator with memory (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dec $5A0D.w,X		; DE 0D 5A ; Decrement memory $5A0D.w,X [Reads: X Index] [Flags: NZ]
	.db $F0, $EE		; F0 EE ; Branch if equal to $F0, $EE [Flow: branch]
	inc $ECCC.w,X		; FE CC EC ; Increment memory $ECCC.w,X [Reads: X Index] [Flags: NZ]
	jmp.w [$1FC0]		; DC C0 1F ; Jump long indirect [$1FC0] [Flow: jump]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($23.b)		; 12 23 ; OR accumulator with memory (indirect) ($23.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $33.b,S		; 23 33 ; AND accumulator with stack relative $33.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($33.b,S),Y		; 33 33 ; AND accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and ($21.b),Y		; 31 21 ; AND accumulator with memory ($21.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $543334.l		; 22 34 33 54 ; Jump to subroutine long $543334.l [Writes: Stack Pointer] [Flow: call]
	and $EC5AED.l		; 2F ED 5A EC ; AND accumulator with memory (long) $EC5AED.l [Writes: Accumulator] [Flags: NZ]
	cmp $CBDD.w,X		; DD DD CB ; Compare accumulator $CBDD.w,X [Reads: X Index] [Flags: NCZ]
	ldy $A9BB.w		; AC BB A9 ; Load $A9BB.w into Y register [Writes: Y Index] [Flags: NZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	jmp.w [$0FCE]		; DC CE 0F ; Jump long indirect [$0FCE] [Flow: jump]
	asl $FFDE.w		; 0E DE FF ; Arithmetic shift left $FFDE.w [Flags: NCZ]
	ora $FF7AFF.l		; 0F FF 7A FF ; OR accumulator with memory (long) $FF7AFF.l [Writes: Accumulator] [Flags: NZ]
	sbc $23F0FF.l,X		; FF FF F0 23 ; Subtract with carry (long,X) $23F0FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $21.b,S		; 43 21 ; Exclusive OR accumulator with stack relative $21.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($5A.b),Y		; 11 5A ; OR accumulator with memory ($5A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpx $23BC.w		; EC BC 23 ; Compare $23BC.w with X register [Reads: X Index] [Flags: NCZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lsr $0D.b		; 46 0D ; Logical shift right $0D.b [Reads: Direct Page] [Flags: NCZ]
	ora ($21.b,S),Y		; 13 21 ; OR accumulator (stack relative indirect indexed) ($21.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	ora $B9CD0D.l,X		; 1F 0D CD B9 ; Logical OR long $B9CD0D.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $FECD.w		; ED CD FE ; Subtract $FECD.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sbc $21F06A.l,X		; FF 6A F0 21 ; Subtract with carry (long,X) $21F06A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $33.b		; 02 33 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $44.b,X		; 34 44 ; Test bits $44.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $54.b,X		; 34 54 ; Test bits $54.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	mvp $67,$44		; 44 44 67 ; Move block positive $67,$44 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	mvn $66,$43		; 54 43 66 ; Move block negative $66,$43 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	and $6AEF.w,X		; 3D EF 6A ; AND accumulator with memory $6AEF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $DCFEFE.l		; 0F FE FE DC ; OR accumulator with memory (long) $DCFEFE.l [Writes: Accumulator] [Flags: NZ]
	dec $EEDD.w,X		; DE DD EE ; Decrement memory $EEDD.w,X [Reads: X Index] [Flags: NZ]
	cmp $DB6A.w,X		; DD 6A DB ; Compare accumulator $DB6A.w,X [Reads: X Index] [Flags: NCZ]
	cmp $EFED.w,X		; DD ED EF ; Compare accumulator $EFED.w,X [Reads: X Index] [Flags: NCZ]
	sbc $DE0FF0.l,X		; FF F0 0F DE ; Subtract with carry (long,X) $DE0FF0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $2302EF.l		; EF EF 02 23 ; Subtract with carry (long) $2302EF.l [Writes: Accumulator] [Flags: NCVZ]
	eor $2D.b		; 45 2D ; Exclusive OR $2D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $1D03.w		; CD 03 1D ; Compare $1D03.w with accumulator [Reads: Accumulator] [Flags: NCZ]
.INDEX 8
	sep #$10		; E2 10
	sbc ($10.b),Y		; F1 10 ; Subtract with carry ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $6A		; F0 6A ; Branch if equal to $F0, $6A [Flow: branch]
	eor $1B.b,X		; 55 1B ; Exclusive OR accumulator with memory $1B.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $EFDD.w,X		; DD DD EF ; Compare accumulator $EFDD.w,X [Reads: X Index] [Flags: NCZ]
	cmp $FFF0.w,X		; DD F0 FF ; Compare accumulator $FFF0.w,X [Reads: X Index] [Flags: NCZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and $01.b,S		; 23 01 ; AND accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	mvp $45,$32		; 44 32 45 ; Move block positive $45,$32 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	mvn $43,$65		; 54 65 43 ; Move block negative $43,$65 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	mvp $24,$53		; 44 53 24 ; Move block positive $24,$53 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	and ($32.b,S),Y		; 33 32 ; AND accumulator (stack relative indirect indexed) ($32.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr $1101.w		; 20 01 11 ; Jump to subroutine at $1101.w [Writes: Stack Pointer] [Flow: call]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc $DDDDEE.l,X		; FF EE DD DD ; Subtract with carry (long,X) $DDDDEE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy $DFDD.w		; CC DD DF ; Compare $DFDD.w with Y register [Reads: Y Index] [Flags: NCZ]
	jmp.w [$CD6A]		; DC 6A CD ; Jump long indirect [$CD6A] [Flow: jump]
	inc $01DD.w		; EE DD 01 ; Increment $01DD.w [Flags: NZ]
	sbc $1001E0.l,X		; FF E0 01 10 ; Subtract with carry (long,X) $1001E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $2401FF.l		; EF FF 01 24 ; Subtract with carry (long) $2401FF.l [Writes: Accumulator] [Flags: NCVZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($FE.b)		; 52 FE ; Exclusive OR accumulator with memory (indirect) ($FE.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $D10F.w,X		; FE 0F D1 ; Increment memory $D10F.w,X [Reads: X Index] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cmp $1F6A01.l,X		; DF 01 6A 1F ; Compare accumulator (long,X) $1F6A01.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	pei ($30.b)		; D4 30 ; Push effective indirect address ($30.b) [Reads: Direct Page] [Writes: Stack Pointer]
	sbc $EFDDFE.l		; EF FE DD EF ; Subtract with carry (long) $EFDDFE.l [Writes: Accumulator] [Flags: NCVZ]
	ora $7A.b,S		; 03 7A ; OR accumulator with stack relative $7A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($35.b),Y		; 11 35 ; OR accumulator with memory ($35.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsr $3124.w		; 20 24 31 ; Jump to subroutine at $3124.w [Writes: Stack Pointer] [Flow: call]
	ora ($32.b)		; 12 32 ; OR accumulator with memory (indirect) ($32.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $5A.b		; 00 5A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $10.b		; 65 10 ; Add $10.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and $01.b,S		; 23 01 ; AND accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($2F.b,X)		; 21 2F ; Logical AND ($2F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $6ADC.w		; ED DC 6A ; Subtract $6ADC.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	inc $DDEE.w		; EE EE DD ; Increment $DDEE.w [Flags: NZ]
	jmp.w [$CCCC]		; DC CC CC ; Jump long indirect [$CCCC] [Flow: jump]
	cmp $5ADF.w		; CD DF 5A ; Compare $5ADF.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	sbc $FEFF.w		; ED FF FE ; Subtract $FEFF.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sbc $234203.l		; EF 03 42 23 ; Subtract with carry (long) $234203.l [Writes: Accumulator] [Flags: NCVZ]
	jsl $01007A.l		; 22 7A 00 01 ; Jump to subroutine long $01007A.l [Writes: Stack Pointer] [Flow: call]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $CDECED.l		; 0F ED EC CD ; OR accumulator with memory (long) $CDECED.l [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($23.b),Y		; F1 23 ; Subtract with carry ($23.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($41.b,S),Y		; 13 41 ; OR accumulator (stack relative indirect indexed) ($41.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldy $30E0.w,X		; BC E0 30 ; Load Y register $30E0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	dec $706A.w,X		; DE 6A 70 ; Decrement memory $706A.w,X [Reads: X Index] [Flags: NZ]
	dec $3112.w		; CE 12 31 ; Decrement $3112.w [Flags: NZ]
	ora $3F.b,S		; 03 3F ; OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $367AF2.l,X		; FF F2 7A 36 ; Subtract with carry (long,X) $367AF2.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($14.b)		; 52 14 ; Exclusive OR accumulator with memory (indirect) ($14.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $42, $00		; 42 00 ; Reserved instruction
	ora ($20.b,S),Y		; 13 20 ; OR accumulator (stack relative indirect indexed) ($20.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($5A.b,X)		; 01 5A ; Logical OR ($5A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $42, $21		; 42 21 ; Reserved instruction
	and ($0C.b,X)		; 21 0C ; Logical AND ($0C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp $CAEFCA.l,X		; DF CA EF CA ; Compare accumulator (long,X) $CAEFCA.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	inc $ACDB.w		; EE DB AC ; Increment $ACDB.w [Flags: NZ]
	sbc $FDCDDC.l		; EF DC CD FD ; Subtract with carry (long) $FDCDDC.l [Writes: Accumulator] [Flags: NCVZ]
	cmp $DE5A.w,X		; DD 5A DE ; Compare accumulator $DE5A.w,X [Reads: X Index] [Flags: NCZ]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor $22.b,X		; 55 22 ; Exclusive OR accumulator with memory $22.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $43.b,X		; 35 43 ; Logical AND $43.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($5A.b)		; 12 5A ; OR accumulator with memory (indirect) ($5A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $000F.w		; 20 0F 00 ; Jump to subroutine at $000F.w [Writes: Stack Pointer] [Flow: call]
	ora $CBFE0F.l		; 0F 0F FE CB ; OR accumulator with memory (long) $CBFE0F.l [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	inc $DDED.w		; EE ED DD ; Increment $DDED.w [Flags: NZ]
	sbc ($44.b),Y		; F1 44 ; Subtract with carry ($44.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($21.b,X)		; 21 21 ; Logical AND ($21.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	lda $12ED23.l,X		; BF 23 ED 12 ; Load long $12ED23.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $13		; 10 13 ; Branch if plus to $10, $13 [Flow: branch]
	and ($21.b)		; 32 21 ; AND accumulator with memory (indirect) ($21.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	ora ($24.b)		; 12 24 ; OR accumulator with memory (indirect) ($24.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $34.b,S		; 43 34 ; Exclusive OR accumulator with stack relative $34.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sbc $6A2002.l,X		; FF 02 20 6A ; Subtract with carry (long,X) $6A2002.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($21.b,S),Y		; F3 21 ; Subtract with carry (stack relative indirect indexed) ($21.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	asl $ECE0.w		; 0E E0 EC ; Arithmetic shift left $ECE0.w [Flags: NCZ]
	cmp $6ABEEC.l,X		; DF EC BE 6A ; Compare accumulator (long,X) $6ABEEC.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	sbc $DCDF.w		; ED DF DC ; Subtract $DCDF.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cpy $CCCE.w		; CC CE CC ; Compare $CCCE.w with Y register [Reads: Y Index] [Flags: NCZ]
	sbc ($0F.b)		; F2 0F ; Subtract with carry (indirect) ($0F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	jmp.w [$2203]		; DC 03 22 ; Jump long indirect [$2203] [Flow: jump]
	ora ($55.b,S),Y		; 13 55 ; OR accumulator (stack relative indirect indexed) ($55.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	mvp $31,$32		; 44 32 31 ; Move block positive $31,$32 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	ora ($21.b,X)		; 01 21 ; Logical OR ($21.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $9CBAED.l		; 0F ED BA 9C ; OR accumulator with memory (long) $9CBAED.l [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	inc $EEEE.w		; EE EE EE ; Increment $EEEE.w [Flags: NZ]
	sbc $3F3411.l		; EF 11 34 3F ; Subtract with carry (long) $3F3411.l [Writes: Accumulator] [Flags: NCVZ]
	jmp.w [$F27A]		; DC 7A F2 ; Jump long indirect [$F27A] [Flow: jump]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sbc ($2F.b)		; F2 2F ; Subtract with carry (indirect) ($2F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $227A34.l		; 22 34 7A 22 ; Jump to subroutine long $227A34.l [Writes: Stack Pointer] [Flow: call]
	jsl $130111.l		; 22 11 01 13 ; Jump to subroutine long $130111.l [Writes: Stack Pointer] [Flow: call]
	mvn $11,$00		; 54 00 11 ; Move block negative $11,$00 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $CF30A0.l		; 0F A0 30 CF ; OR accumulator with memory (long) $CF30A0.l [Writes: Accumulator] [Flags: NZ]
	ora $DBDDEE.l		; 0F EE DD DB ; OR accumulator with memory (long) $DBDDEE.l [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lda $BEDC.w,X		; BD DC BE ; Load $BEDC.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $EFDD.w		; 0E DD EF ; Arithmetic shift left $EFDD.w [Flags: NCZ]
	sbc $5AE1.w,X		; FD E1 5A ; Subtract with carry $5AE1.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $32F4.w,X		; 1E F4 32 ; Arithmetic shift left $32F4.w,X [Reads: X Index] [Flags: NCZ]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	adc $32.b		; 65 32 ; Add $32.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($6A.b),Y		; F1 6A ; Subtract with carry ($6A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($10.b),Y		; 11 10 ; OR accumulator with memory ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($FF.b)		; 12 FF ; OR accumulator with memory (indirect) ($FF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $FEF0.w		; ED F0 FE ; Subtract $FEF0.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cmp $FF8A.w,X		; DD 8A FF ; Compare accumulator $FF8A.w,X [Reads: X Index] [Flags: NCZ]
	inc $00FF.w		; EE FF 00 ; Increment $00FF.w [Flags: NZ]
	ora ($32.b)		; 12 32 ; OR accumulator with memory (indirect) ($32.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $7AC0.w		; 0D C0 7A ; Logical OR $7AC0.w with accumulator [Writes: Accumulator] [Flags: NZ]
	adc $2012BF.l		; 6F BF 12 20 ; Add with carry (long) $2012BF.l [Writes: Accumulator] [Flags: NCVZ]
	sbc ($30.b,S),Y		; F3 30 ; Subtract with carry (stack relative indirect indexed) ($30.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $51.b		; 05 51 ; Logical OR $51.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rol $63.b,X		; 36 63 ; Rotate left $63.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	eor $41.b		; 45 41 ; Exclusive OR $41.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	ora ($22.b),Y		; 11 22 ; OR accumulator with memory ($22.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	eor $0D.b		; 45 0D ; Exclusive OR $0D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $BB00.w,X		; DD 00 BB ; Compare accumulator $BB00.w,X [Reads: X Index] [Flags: NCZ]
	brk $DC.b		; 00 DC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $DD6A.w,X		; DD 6A DD ; Compare accumulator $DD6A.w,X [Reads: X Index] [Flags: NCZ]
	cmp $CCCD.w		; CD CD CC ; Compare $CCCD.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	dec $00E0.w,X		; DE E0 00 ; Decrement memory $00E0.w,X [Reads: X Index] [Flags: NZ]
	brk $5A.b		; 00 5A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $1E		; F0 1E ; Branch if equal to $F0, $1E [Flow: branch]
	cop $41.b		; 02 41 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $74.b,X		; 34 74 ; Test bits $74.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	jsr $5A03.w		; 20 03 5A ; Jump to subroutine at $5A03.w [Writes: Stack Pointer] [Flow: call]
	and $1F1001.l		; 2F 01 10 1F ; AND accumulator with memory (long) $1F1001.l [Writes: Accumulator] [Flags: NZ]
	brk $CB.b		; 00 CB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $8AB9.w,X		; DD B9 8A ; Compare accumulator $8AB9.w,X [Reads: X Index] [Flags: NCZ]
	inc $FEFE.w,X		; FE FE FE ; Increment memory $FEFE.w,X [Reads: X Index] [Flags: NZ]
	.db $F0, $45		; F0 45 ; Branch if equal to $F0, $45 [Flow: branch]
	.db $30, $DD		; 30 DD ; Branch if minus to $30, $DD [Flow: branch]
	ora ($7A.b,X)		; 01 7A ; Logical OR ($7A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ldy $5101.w		; AC 01 51 ; Load $5101.w into Y register [Writes: Y Index] [Flags: NZ]
	cmp $44F253.l		; CF 53 F2 44 ; Compare accumulator (long) $44F253.l [Reads: Accumulator] [Flags: NCZ]
	and $6A.b,S		; 23 6A ; AND accumulator with stack relative $6A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $14.b,S		; 63 14 ; Add with carry (stack relative) $14.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	stz $42.b		; 64 42 ; Store zero to $42.b
	ora ($20.b)		; 12 20 ; OR accumulator with memory (indirect) ($20.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	jsl $DA000F.l		; 22 0F 00 DA ; Jump to subroutine long $DA000F.l [Writes: Stack Pointer] [Flow: call]
	cmp ($EC.b),Y		; D1 EC ; Compare accumulator ($EC.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cpy $6AEC.w		; CC EC 6A ; Compare $6AEC.w with Y register [Reads: Y Index] [Flags: NCZ]
	jmp.w [$DDDE]		; DC DE DD ; Jump long indirect [$DDDE] [Flow: jump]
	jmp.w [$EFCD]		; DC CD EF ; Jump long indirect [$EFCD] [Flow: jump]
	sbc $0F5A01.l,X		; FF 01 5A 0F ; Subtract with carry (long,X) $0F5A01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($00.b),Y		; F1 00 ; Subtract with carry ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $76.b,S		; 03 76 ; OR accumulator with stack relative $76.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $01.b,S		; 63 01 ; Add with carry (stack relative) $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	eor ($5A.b,X)		; 41 5A ; Exclusive OR accumulator with memory ($5A.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $14		; F0 14 ; Branch if equal to $F0, $14 [Flow: branch]
	.db $30, $CF		; 30 CF ; Branch if minus to $30, $CF [Flow: branch]
	jsr ($C0DC.w,X)		; FC DC C0 ; Jump to subroutine indirect indexed ($C0DC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	tsb $FF8A.w		; 0C 8A FF ; Test and set bits $FF8A.w [Reads: Accumulator] [Flags: Z]
	inc $01EE.w,X		; FE EE 01 ; Increment memory $01EE.w,X [Reads: X Index] [Flags: NZ]
	and ($21.b,X)		; 21 21 ; Logical AND ($21.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $907AEA.l		; 22 EA 7A 90 ; Jump to subroutine long $907AEA.l [Writes: Stack Pointer] [Flow: call]
	ror $EA.b		; 66 EA ; Rotate right $EA.b [Reads: Direct Page] [Flags: NCZ]
	tsb $11.b		; 04 11 ; Test and set bits $11.b [Reads: Accumulator] [Flags: Z]
	bit $32.b,X		; 34 32 ; Test bits $32.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and ($7A.b,S),Y		; 33 7A ; AND accumulator (stack relative indirect indexed) ($7A.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($23.b,S),Y		; 33 23 ; AND accumulator (stack relative indirect indexed) ($23.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($00.b)		; 32 00 ; AND accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $F0		; 10 F0 ; Branch if plus to $10, $F0 [Flow: branch]
	ora ($12.b),Y		; 11 12 ; OR accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	jsr $0D01.w		; 20 01 0D ; Jump to subroutine at $0D01.w [Writes: Stack Pointer] [Flow: call]
	cmp $EFEE0F.l		; CF 0F EE EF ; Compare accumulator (long) $EFEE0F.l [Reads: Accumulator] [Flags: NCZ]
	sbc $CD6A.w,X		; FD 6A CD ; Subtract with carry $CD6A.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx $DDCD.w		; EC CD DD ; Compare $DDCD.w with X register [Reads: X Index] [Flags: NCZ]
	dec $F0FE.w		; CE FE F0 ; Decrement $F0FE.w [Flags: NZ]
	ora ($5A.b,X)		; 01 5A ; Logical OR ($5A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rol $2222.w,X		; 3E 22 22 ; Rotate left $2222.w,X [Reads: X Index] [Flags: NCZ]
	bit $53.b,X		; 34 53 ; Test bits $53.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	mvn $FD,$63		; 54 63 FD ; Move block negative $FD,$63 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	cpx #$11.b		; E0 11 ; Compare #$11.b with X register [Reads: X Index] [Flags: NCZ]
	cmp $DFFD21.l,X		; DF 21 FD DF ; Compare accumulator (long,X) $DFFD21.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	cpx $8AAB.w		; EC AB 8A ; Compare $8AAB.w with X register [Reads: X Index] [Flags: NCZ]
	ora $FEFFEE.l		; 0F EE FF FE ; OR accumulator with memory (long) $FEFFEE.l [Writes: Accumulator] [Flags: NZ]
	ora ($34.b,X)		; 01 34 ; Logical OR ($34.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rol $7ADF.w,X		; 3E DF 7A ; Rotate left $7ADF.w,X [Reads: X Index] [Flags: NCZ]
	.db $F0, $0D		; F0 0D ; Branch if equal to $F0, $0D [Flow: branch]
	cpx $4E.b		; E4 4E ; Compare $4E.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	tsb $42.b		; 04 42 ; Test and set bits $42.b [Reads: Accumulator] [Flags: Z]
	and ($45.b,S),Y		; 33 45 ; AND accumulator (stack relative indirect indexed) ($45.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	.db $42, $43		; 42 43 ; Reserved instruction
	ora $01FD11.l,X		; 1F 11 FD 01 ; Logical OR long $01FD11.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $22		; 10 22 ; Branch if plus to $10, $22 [Flow: branch]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	eor ($0D.b,X)		; 41 0D ; Exclusive OR accumulator with memory ($0D.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lda #$BE.b		; A9 BE ; Load #$BE.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $0DAB.w,X		; FD AB 0D ; Subtract with carry $0DAB.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cmp $CEBC.w,X		; DD BC CE ; Compare accumulator $CEBC.w,X [Reads: X Index] [Flags: NCZ]
	sbc $00DE.w		; ED DE 00 ; Subtract $00DE.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	jsl $433333.l		; 22 33 33 43 ; Jump to subroutine long $433333.l [Writes: Stack Pointer] [Flow: call]
	eor $34.b,S		; 43 34 ; Exclusive OR accumulator with stack relative $34.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $32.b,S		; 23 32 ; AND accumulator with stack relative $32.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	ora $00DD.w,X		; 1D DD 00 ; OR accumulator with memory $00DD.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $FEFF.w,X		; FE FF FE ; Increment memory $FEFF.w,X [Reads: X Index] [Flags: NZ]
	cpx $8ABD.w		; EC BD 8A ; Compare $8ABD.w with X register [Reads: X Index] [Flags: NCZ]
	.db $F0, $FF		; F0 FF ; Branch if equal to $F0, $FF [Flow: branch]
	sbc $00E0EE.l		; EF EE E0 00 ; Subtract with carry (long) $00E0EE.l [Writes: Accumulator] [Flags: NCVZ]
	ora ($42.b,S),Y		; 13 42 ; OR accumulator (stack relative indirect indexed) ($42.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	jmp.w [$30D1]		; DC D1 30 ; Jump long indirect [$30D1] [Flow: jump]
	sep #$43		; E2 43 ; Set processor status bits #$43 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	bit $54.b		; 24 54 ; Test bits $54.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	jsl $42347A.l		; 22 7A 34 42 ; Jump to subroutine long $42347A.l [Writes: Stack Pointer] [Flow: call]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0E		; F0 0E ; Branch if equal to $F0, $0E [Flow: branch]
	sbc ($1F.b),Y		; F1 1F ; Subtract with carry ($1F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and $0A.b		; 25 0A ; Logical AND $0A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy $99CC.w		; AC CC 99 ; Load $99CC.w into Y register [Writes: Y Index] [Flags: NZ]
	cmp $6ACCCB.l,X		; DF CB CC 6A ; Compare accumulator (long,X) $6ACCCB.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	cpy $FEDE.w		; CC DE FE ; Compare $FEDE.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $F0, $01		; F0 01 ; Branch if equal to $F0, $01 [Flow: branch]
	ora ($22.b),Y		; 11 22 ; OR accumulator with memory ($22.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	stz $33.b,X		; 74 33 ; Store zero to $33.b,X [Reads: X Index]
	and $64.b,X		; 35 64 ; Logical AND $64.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	jsr $2102.w		; 20 02 21 ; Jump to subroutine at $2102.w [Writes: Stack Pointer] [Flow: call]
	and ($5A.b,X)		; 21 5A ; Logical AND ($5A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $0F.b		; 02 0F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $0CEF.w		; CD EF 0C ; Compare $0CEF.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp $BCDB.w,X		; DD DB BC ; Compare accumulator $BCDB.w,X [Reads: X Index] [Flags: NCZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	sbc $EDFEEE.l,X		; FF EE FE ED ; Subtract with carry (long,X) $EDFEEE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $12DF.w		; ED DF 12 ; Subtract $12DF.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	bit $7A.b		; 24 7A ; Test bits $7A.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	stz $10.b		; 64 10 ; Store zero to $10.b
	sbc $342234.l,X		; FF 34 22 34 ; Subtract with carry (long,X) $342234.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($33.b,S),Y		; 33 33 ; AND accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and ($24.b)		; 32 24 ; AND accumulator with memory (indirect) ($24.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor ($12.b,S),Y		; 53 12 ; XOR accumulator (stack relative indirect indexed) ($12.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $FCCE.w,X		; 1E CE FC ; Arithmetic shift left $FCCE.w,X [Reads: X Index] [Flags: NCZ]
	cmp ($7A.b,X)		; C1 7A ; Compare accumulator ($7A.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	and $DCFEE0.l		; 2F E0 FE DC ; AND accumulator with memory (long) $DCFEE0.l [Writes: Accumulator] [Flags: NZ]
	cmp $FEDEFD.l		; CF FD DE FE ; Compare accumulator (long) $FEDEFD.l [Reads: Accumulator] [Flags: NCZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	wai		; CB ; Wait for interrupt
	sbc $10E0EE.l		; EF EE E0 10 ; Subtract with carry (long) $10E0EE.l [Writes: Accumulator] [Flags: NCVZ]
	ora ($22.b),Y		; 11 22 ; OR accumulator with memory ($22.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($5A.b,S),Y		; 33 5A ; AND accumulator (stack relative indirect indexed) ($5A.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	mvn $42,$56		; 54 56 42 ; Move block negative $42,$56 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	and ($32.b,S),Y		; 33 32 ; AND accumulator (stack relative indirect indexed) ($32.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr $11EF.w		; 20 EF 11 ; Jump to subroutine at $11EF.w [Writes: Stack Pointer] [Flow: call]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	and ($FF.b,X)		; 21 FF ; Logical AND ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $CDFE.w,X		; FD FE CD ; Subtract with carry $CDFE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $ABCB.w		; ED CB AB ; Subtract $ABCB.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	sbc $EFFEEF.l,X		; FF EF FE EF ; Subtract with carry (long,X) $EFFEEF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $E0EE.w		; ED EE E0 ; Subtract $E0EE.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	rol $7A.b,X		; 36 7A ; Rotate left $7A.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	adc $21.b		; 65 21 ; Add $21.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and $0F.b,S		; 23 0F ; AND accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $54.b		; 24 54 ; Test bits $54.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	jsr $6A23.w		; 20 23 6A ; Jump to subroutine at $6A23.w [Writes: Stack Pointer] [Flow: call]
	.db $42, $45		; 42 45 ; Reserved instruction
	and ($32.b)		; 32 32 ; AND accumulator with memory (indirect) ($32.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $DDAA0F.l,X		; FF 0F AA DD ; Subtract with carry (long,X) $DDAA0F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	sbc $DEFF00.l		; EF 00 FF DE ; Subtract with carry (long) $DEFF00.l [Writes: Accumulator] [Flags: NCVZ]
	sbc $FEBE.w		; ED BE FE ; Subtract $FEBE.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	inc $CB5A.w		; EE 5A CB ; Increment $CB5A.w [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	.db $90, $01		; 90 01 ; Branch if carry clear to $90, $01 [Flow: branch]
	sbc ($24.b,S),Y		; F3 24 ; Subtract with carry (stack relative indirect indexed) ($24.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	eor $55.b,S		; 43 55 ; Exclusive OR accumulator with stack relative $55.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and ($43.b)		; 32 43 ; AND accumulator with memory (indirect) ($43.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($22.b,X)		; 21 22 ; Logical AND ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	ora ($FF.b),Y		; 11 FF ; OR accumulator with memory ($FF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	.db $F0, $21		; F0 21 ; Branch if equal to $F0, $21 [Flow: branch]
	asl $ECDD.w		; 0E DD EC ; Arithmetic shift left $ECDD.w [Flags: NCZ]
	ldy $DBDC.w,X		; BC DC DB ; Load Y register $DBDC.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	inc $EEFF.w,X		; FE FF EE ; Increment memory $EEFF.w,X [Reads: X Index] [Flags: NZ]
	.db $F0, $FE		; F0 FE ; Branch if equal to $F0, $FE [Flow: branch]
	cmp $34E0.w,X		; DD E0 34 ; Compare accumulator $34E0.w,X [Reads: X Index] [Flags: NCZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	eor $45.b,X		; 55 45 ; Exclusive OR accumulator with memory $45.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $5045E0.l,X		; 3F E0 45 50 ; AND accumulator with memory (long,X) $5045E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $42.b,S		; 03 42 ; OR accumulator with stack relative $42.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	bit $22.b,X		; 34 22 ; Test bits $22.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and ($22.b,S),Y		; 33 22 ; AND accumulator (stack relative indirect indexed) ($22.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $10, $ED		; 10 ED ; Branch if plus to $10, $ED [Flow: branch]
	cmp $6ADB.w,X		; DD DB 6A ; Compare accumulator $6ADB.w,X [Reads: X Index] [Flags: NCZ]
	cpy $DCDD.w		; CC DD DC ; Compare $DCDD.w with Y register [Reads: Y Index] [Flags: NCZ]
	inc $CCBA.w,X		; FE BA CC ; Increment memory $CCBA.w,X [Reads: X Index] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	cpy $DD5A.w		; CC 5A DD ; Compare $DD5A.w with Y register [Reads: Y Index] [Flags: NCZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	ora $2423E0.l		; 0F E0 23 24 ; OR accumulator with memory (long) $2423E0.l [Writes: Accumulator] [Flags: NZ]
	eor $54.b,S		; 43 54 ; Exclusive OR accumulator with stack relative $54.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	mvp $66,$46		; 44 46 66 ; Move block positive $66,$46 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	eor ($12.b,X)		; 41 12 ; Exclusive OR accumulator with memory ($12.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $F0		; 30 F0 ; Branch if minus to $30, $F0 [Flow: branch]
	.db $F0, $5A		; F0 5A ; Branch if equal to $F0, $5A [Flow: branch]
	ora $FF0E10.l		; 0F 10 0E FF ; OR accumulator with memory (long) $FF0E10.l [Writes: Accumulator] [Flags: NZ]
	jmp.w [$ABCC]		; DC CC AB ; Jump long indirect [$ABCC] [Flow: jump]
	cpy $FF7A.w		; CC 7A FF ; Compare $FF7A.w with Y register [Reads: Y Index] [Flags: NCZ]
	inc $FEFF.w,X		; FE FF FE ; Increment memory $FEFF.w,X [Reads: X Index] [Flags: NZ]
	inc $01DE.w,X		; FE DE 01 ; Increment memory $01DE.w,X [Reads: X Index] [Flags: NZ]
	and $7A.b,S		; 23 7A ; AND accumulator with stack relative $7A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $74.b,X		; 55 74 ; Exclusive OR accumulator with memory $74.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	asl $74E3.w		; 0E E3 74 ; Arithmetic shift left $74E3.w [Flags: NCZ]
	sbc ($22.b)		; F2 22 ; Subtract with carry (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and ($6A.b,S),Y		; 33 6A ; AND accumulator (stack relative indirect indexed) ($6A.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($11.b,S),Y		; 33 11 ; AND accumulator (stack relative indirect indexed) ($11.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $40.b,X		; 15 40 ; OR accumulator with memory $40.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $FC		; F0 FC ; Branch if equal to $F0, $FC [Flow: branch]
	cmp $6ACA.w,X		; DD CA 6A ; Compare accumulator $6ACA.w,X [Reads: X Index] [Flags: NCZ]
	cmp $DFCA.w		; CD CA DF ; Compare $DFCA.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	sbc $A9DE.w,X		; FD DE A9 ; Subtract with carry $A9DE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	.db $D0, $6A		; D0 6A ; Branch if not equal to $D0, $6A [Flow: branch]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	sbc ($FE.b),Y		; F1 FE ; Subtract with carry ($FE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($21.b,X)		; 01 21 ; Logical OR ($21.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($23.b),Y		; 11 23 ; OR accumulator with memory ($23.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($5A.b)		; 32 5A ; AND accumulator with memory (indirect) ($5A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	mvp $54,$45		; 44 45 54 ; Move block positive $54,$45 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	and ($32.b),Y		; 31 32 ; AND accumulator with memory ($32.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $FF		; 10 FF ; Branch if plus to $10, $FF [Flow: branch]
	.db $10, $5A		; 10 5A ; Branch if plus to $10, $5A [Flow: branch]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $EDEF.w		; EC EF ED ; Compare $EDEF.w with X register [Reads: X Index] [Flags: NCZ]
	cmp $BBEC.w		; CD EC BB ; Compare $BBEC.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	sbc $FFF0EE.l,X		; FF EE F0 FF ; Subtract with carry (long,X) $FFF0EE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $F1EF.w		; EE EF F1 ; Increment $F1EF.w [Flags: NZ]
	and $7A.b,X		; 35 7A ; Logical AND $7A.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ror $43.b		; 66 43 ; Rotate right $43.b [Reads: Direct Page] [Flags: NCZ]
	ora ($11.b)		; 12 11 ; OR accumulator with memory (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $43.b		; 14 43 ; Test and reset bits $43.b [Reads: Accumulator] [Flags: Z]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and ($25.b,X)		; 21 25 ; Logical AND ($25.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and ($01.b)		; 32 01 ; AND accumulator with memory (indirect) ($01.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $DBDE.w,X		; FE DE DB ; Increment memory $DBDE.w,X [Reads: X Index] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	ldy $F0EE.w,X		; BC EE F0 ; Load Y register $F0EE.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	cmp #$AB.b		; C9 AB ; Compare #$AB.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp $5ABB.w		; CD BB 5A ; Compare $5ABB.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	brk $DD.b		; 00 DD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($66.b,S),Y		; 13 66 ; OR accumulator (stack relative indirect indexed) ($66.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	mvp $5A,$55		; 44 55 5A ; Move block positive $5A,$55 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	eor [$63.b]		; 47 63 ; Exclusive OR accumulator with memory (long) [$63.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($12.b,S),Y		; 33 12 ; AND accumulator (stack relative indirect indexed) ($12.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $100F10.l,X		; 1F 10 0F 10 ; Logical OR long $100F10.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	ora ($0C.b)		; 12 0C ; OR accumulator with memory (indirect) ($0C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $FC		; D0 FC ; Branch if not equal to $D0, $FC [Flow: branch]
	jmp.w [$CCCC]		; DC CC CC ; Jump long indirect [$CCCC] [Flow: jump]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	sbc $FFFFEF.l,X		; FF EF FF FF ; Subtract with carry (long,X) $FFFFEF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $F0EF.w,X		; FE EF F0 ; Increment memory $F0EF.w,X [Reads: X Index] [Flags: NZ]
	rol $7A.b,X		; 36 7A ; Rotate left $7A.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	adc $53.b		; 65 53 ; Add $53.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($20.b),Y		; 11 20 ; OR accumulator with memory ($20.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $42.b		; 24 42 ; Test bits $42.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	.db $10, $22		; 10 22 ; Branch if plus to $10, $22 [Flow: branch]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $3225.w		; 20 25 32 ; Jump to subroutine at $3225.w [Writes: Stack Pointer] [Flow: call]
	ora ($FD.b),Y		; 11 FD ; OR accumulator with memory ($FD.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	dec $CBDB.w,X		; DE DB CB ; Decrement memory $CBDB.w,X [Reads: X Index] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $74.b		; 00 74 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	wai		; CB ; Wait for interrupt
	ldy $CCBC.w,X		; BC BC CC ; Load Y register $CCBC.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	dec $DFED.w,X		; DE ED DF ; Decrement memory $DFED.w,X [Reads: X Index] [Flags: NZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	brk $32.b		; 00 32 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1F1F.w		; 0C 1F 1F ; Test and set bits $1F1F.w [Reads: Accumulator] [Flags: Z]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	brk $94.b		; 00 94 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $32.b		; 05 32 ; Logical OR $32.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($12.b)		; 12 12 ; OR accumulator with memory (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $447811.l		; 22 11 78 44 ; Jump to subroutine long $447811.l [Writes: Stack Pointer] [Flow: call]
	and $33.b,S		; 23 33 ; AND accumulator with stack relative $33.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($22.b,S),Y		; 33 22 ; AND accumulator (stack relative indirect indexed) ($22.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($21.b,S),Y		; 33 21 ; AND accumulator (stack relative indirect indexed) ($21.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $ECA8.w		; 2C A8 EC ; Test bits $ECA8.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	and $EF10E6.l		; 2F E6 10 EF ; AND accumulator with memory (long) $EF10E6.l [Writes: Accumulator] [Flags: NZ]
	cpy #$3E.b		; C0 3E ; Compare #$3E.b with Y register [Reads: Y Index] [Flags: NCZ]
	ora $BEED84.l,X		; 1F 84 ED BE ; Logical OR long $BEED84.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $EEDD.w		; CD DD EE ; Compare $EEDD.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp $EDDE.w,X		; DD DE ED ; Compare accumulator $EDDE.w,X [Reads: X Index] [Flags: NCZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $FF		; F0 FF ; Branch if equal to $F0, $FF [Flow: branch]
	.db $F0, $FF		; F0 FF ; Branch if equal to $F0, $FF [Flow: branch]
	ora $633EF1.l		; 0F F1 3E 63 ; OR accumulator with memory (long) $633EF1.l [Writes: Accumulator] [Flags: NZ]
	ldy $2C.b,X		; B4 2C ; Load Y register $2C.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	cmp $CC3F45.l,X		; DF 45 3F CC ; Compare accumulator (long,X) $CC3F45.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	sbc $61.b,X		; F5 61 ; Subtract $61.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $012BB8.l,X		; 1F B8 2B 01 ; Logical OR long $012BB8.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1F0C41.l		; 4F 41 0C 1F ; Exclusive OR accumulator with memory (long) $1F0C41.l [Writes: Accumulator] [Flags: NZ]
	brk $ED.b		; 00 ED ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $D4.b,X		; B4 D4 ; Load Y register $D4.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	and $03E1A0.l		; 2F A0 E1 03 ; AND accumulator with memory (long) $03E1A0.l [Writes: Accumulator] [Flags: NZ]
	.db $30, $BE		; 30 BE ; Branch if minus to $30, $BE [Flow: branch]
	sbc ($A8.b),Y		; F1 A8 ; Subtract with carry ($A8.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $D0, $F0		; D0 F0 ; Branch if not equal to $D0, $F0 [Flow: branch]
	asl $001F.w,X		; 1E 1F 00 ; Arithmetic shift left $001F.w,X [Reads: X Index] [Flags: NCZ]
	ora ($30.b)		; 12 30 ; OR accumulator with memory (indirect) ($30.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $EF3325.l		; AF 25 33 EF ; Load long $EF3325.l into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $42, $BF		; 42 BF ; Reserved instruction
	ora ($01.b),Y		; 11 01 ; OR accumulator with memory ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sty $13.b		; 84 13 ; Store Y register to $13.b [Reads: Y Index]
	and ($34.b,S),Y		; 33 34 ; AND accumulator (stack relative indirect indexed) ($34.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $33.b,S		; 43 33 ; Exclusive OR accumulator with stack relative $33.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($23.b,S),Y		; 33 23 ; AND accumulator (stack relative indirect indexed) ($23.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($78.b,S),Y		; 33 78 ; AND accumulator (stack relative indirect indexed) ($78.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $33.b		; 24 33 ; Test bits $33.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	bit $33.b,X		; 34 33 ; Test bits $33.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and $32.b,S		; 23 32 ; AND accumulator with stack relative $32.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($EB.b,X)		; 01 EB ; Logical OR ($EB.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp [$04.b],Y		; D7 04 ; Compare accumulator (long indexed) [$04.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	.db $42, $BA		; 42 BA ; Reserved instruction
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	ldy $D075.w		; AC 75 D0 ; Load $D075.w into Y register [Writes: Y Index] [Flags: NZ]
	ora $0F1F1D.l		; 0F 1D 1F 0F ; OR accumulator with memory (long) $0F1F1D.l [Writes: Accumulator] [Flags: NZ]
	.db $F0, $84		; F0 84 ; Branch if equal to $F0, $84 [Flow: branch]
	jsr ($CEDD.w,X)		; FC DD CE ; Jump to subroutine indirect indexed ($CEDD.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cmp $DDED.w,X		; DD ED DD ; Compare accumulator $DDED.w,X [Reads: X Index] [Flags: NCZ]
	dec $A8EE.w,X		; DE EE A8 ; Decrement memory $A8EE.w,X [Reads: X Index] [Flags: NZ]
	ora $01FF00.l		; 0F 00 FF 01 ; OR accumulator with memory (long) $01FF00.l [Writes: Accumulator] [Flags: NZ]
	and $FE.b,S		; 23 FE ; AND accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $A813.w		; EE 13 A8 ; Increment $A813.w [Flags: NZ]
	jsl $0100FE.l		; 22 FE 00 01 ; Jump to subroutine long $0100FE.l [Writes: Stack Pointer] [Flow: call]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	cmp $BC8840.l,X		; DF 40 88 BC ; Compare accumulator (long,X) $BC8840.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	ror $EED6.w,X		; 7E D6 EE ; Rotate right $EED6.w,X [Reads: X Index] [Flags: NCZ]
	sbc $EFEFEF.l		; EF EF EF EF ; Subtract with carry (long) $EFEFEF.l [Writes: Accumulator] [Flags: NCVZ]
	sty $EE.b		; 84 EE ; Store Y register to $EE.b [Reads: Y Index]
	inc $EEEE.w		; EE EE EE ; Increment $EEEE.w [Flags: NZ]
	sbc $DC23FF.l,X		; FF FF 23 DC ; Subtract with carry (long,X) $DC23FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	mvn $0E,$3F		; 54 3F 0E ; Move block negative $0E,$3F [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sep #$00		; E2 00 ; Set processor status bits #$00 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	and ($DF.b,S),Y		; 33 DF ; AND accumulator (stack relative indirect indexed) ($DF.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $A4.b		; C6 A4 ; Decrement $A4.b [Reads: Direct Page] [Flags: NZ]
	eor ($01.b,S),Y		; 53 01 ; XOR accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $10, $EE		; 10 EE ; Branch if plus to $10, $EE [Flow: branch]
	and $31.b,S		; 23 31 ; AND accumulator with stack relative $31.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $10, $01		; 10 01 ; Branch if plus to $10, $01 [Flow: branch]
	ldy $1E.b		; A4 1E ; Load $1E.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	cmp ($41.b)		; D2 41 ; Compare accumulator (indirect) ($41.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($A8.b),Y		; 11 A8 ; OR accumulator with memory ($A8.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $0B5332.l		; CF 32 53 0B ; Compare accumulator (long) $0B5332.l [Reads: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	.db $D0, $C0		; D0 C0 ; Branch if not equal to $D0, $C0 [Flow: branch]
	bit $1E.b,X		; 34 1E ; Test bits $1E.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sbc ($0F.b),Y		; F1 0F ; Subtract with carry ($0F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldy $01.b		; A4 01 ; Load $01.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $ED.b		; 00 ED ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $98.b		; 24 98 ; Test bits $98.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ldx $0020.w		; AE 20 00 ; Load $0020.w into X register [Writes: X Index] [Flags: NZ]
	cpx $35C1.w		; EC C1 35 ; Compare $35C1.w with X register [Reads: X Index] [Flags: NCZ]
	ora $980E.w		; 0D 0E 98 ; Logical OR $980E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $13DC0E.l		; EF 0E DC 13 ; Subtract with carry (long) $13DC0E.l [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFEEF.l,X		; FF EF FE FF ; Subtract with carry (long,X) $FFFEEF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	lda $BCDB.w,Y		; B9 DB BC ; Load $BCDB.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	wai		; CB ; Wait for interrupt
	wai		; CB ; Wait for interrupt
	cpy $CCCC.w		; CC CC CC ; Compare $CCCC.w with Y register [Reads: Y Index] [Flags: NCZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cpy $CCDC.w		; CC DC CC ; Compare $CCDC.w with Y register [Reads: Y Index] [Flags: NCZ]
	cmp $DCDC.w,X		; DD DC DC ; Compare accumulator $DCDC.w,X [Reads: X Index] [Flags: NCZ]
	cmp $88DD.w,X		; DD DD 88 ; Compare accumulator $88DD.w,X [Reads: X Index] [Flags: NCZ]
	inc $FFEF.w,X		; FE EF FF ; Increment memory $FFEF.w,X [Reads: X Index] [Flags: NZ]
	sbc $F5FFE0.l		; EF E0 FF F5 ; Subtract with carry (long) $F5FFE0.l [Writes: Accumulator] [Flags: NCVZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	clv		; B8 ; Clear overflow flag [Flags: V]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $FC.b		; 02 FC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $30.b,S		; E3 30 ; Subtract stack-relative $30.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	cpx #$12.b		; E0 12 ; Compare #$12.b with X register [Reads: X Index] [Flags: NCZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and $1301BB.l		; 2F BB 01 13 ; AND accumulator with memory (long) $1301BB.l [Writes: Accumulator] [Flags: NZ]
	eor $1C.b,X		; 55 1C ; Exclusive OR accumulator with memory $1C.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $24A8C0.l,X		; DF C0 A8 24 ; Compare accumulator (long,X) $24A8C0.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	and $DF0DF2.l		; 2F F2 0D DF ; AND accumulator with memory (long) $DF0DF2.l [Writes: Accumulator] [Flags: NZ]
	and ($20.b,S),Y		; 33 20 ; AND accumulator (stack relative indirect indexed) ($20.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $1003A8.l		; 0F A8 03 10 ; OR accumulator with memory (long) $1003A8.l [Writes: Accumulator] [Flags: NZ]
	inc $D30D.w,X		; FE 0D D3 ; Increment memory $D30D.w,X [Reads: X Index] [Flags: NZ]
	.db $30, $02		; 30 02 ; Branch if minus to $30, $02 [Flow: branch]
	jsl $AD1098.l		; 22 98 10 AD ; Jump to subroutine long $AD1098.l [Writes: Stack Pointer] [Flow: call]
	and ($11.b,X)		; 21 11 ; Logical AND ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($01.b),Y		; 11 01 ; OR accumulator with memory ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b),Y		; 11 01 ; OR accumulator with memory ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sty $11.b,X		; 94 11 ; Store Y register $11.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $A830F3.l		; 0F F3 30 A8 ; OR accumulator with memory (long) $A830F3.l [Writes: Accumulator] [Flags: NZ]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	ora $62B1.w		; 0D B1 62 ; Logical OR $62B1.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jmp.w [$2598]		; DC 98 25 ; Jump long indirect [$2598] [Flow: jump]
	cmp $FFFFEF.l,X		; DF EF FF FF ; Compare accumulator (long,X) $FFFFEF.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	inc $FFFF.w,X		; FE FF FF ; Increment memory $FFFF.w,X [Reads: X Index] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	cpy $CCDC.w		; CC DC CC ; Compare $CCDC.w with Y register [Reads: Y Index] [Flags: NCZ]
	cmp $DDCD.w		; CD CD DD ; Compare $DDCD.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cpy $BB68.w		; CC 68 BB ; Compare $BB68.w with Y register [Reads: Y Index] [Flags: NCZ]
	lda #$AA.b		; A9 AA ; Load #$AA.b into accumulator [Writes: Accumulator] [Flags: NZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	cpy $0FA8.w		; CC A8 0F ; Compare $0FA8.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $C1D0.w,X		; 3E D0 C1 ; Rotate left $C1D0.w,X [Reads: X Index] [Flags: NCZ]
	eor ($1F.b,X)		; 41 1F ; Exclusive OR accumulator with memory ($1F.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $EC		; 10 EC ; Branch if plus to $10, $EC [Flow: branch]
	cmp ($65.b)		; D2 65 ; Compare accumulator (indirect) ($65.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	cmp ($54.b,X)		; C1 54 ; Compare accumulator ($54.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	mvp $1A,$A4		; 44 A4 1A ; Move block positive $1A,$A4 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	lda $21F2.w		; AD F2 21 ; Load $21F2.w into accumulator [Writes: Accumulator] [Flags: NZ]
	rol $22DF.w		; 2E DF 22 ; Rotate left $22DF.w [Flags: NCZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	ldy $C0.b		; A4 C0 ; Load $C0.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and ($11.b)		; 32 11 ; AND accumulator with memory (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $6F.b		; 14 6F ; Test and reset bits $6F.b [Reads: Accumulator] [Flags: Z]
	ldy $42A8.w		; AC A8 42 ; Load $42A8.w into Y register [Writes: Y Index] [Flags: NZ]
	asl $23D0.w		; 0E D0 23 ; Arithmetic shift left $23D0.w [Flags: NCZ]
	trb $4B.b		; 14 4B ; Test and reset bits $4B.b [Reads: Accumulator] [Flags: Z]
	lda $D99846.l		; AF 46 98 D9 ; Load long $D99846.l into accumulator [Writes: Accumulator] [Flags: NZ]
	eor ($10.b,X)		; 41 10 ; Exclusive OR accumulator with memory ($10.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($34.b),Y		; 11 34 ; OR accumulator with memory ($34.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($11.b)		; D2 11 ; Compare accumulator (indirect) ($11.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora ($78.b),Y		; 11 78 ; OR accumulator with memory ($78.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($54.b,S),Y		; 33 54 ; AND accumulator (stack relative indirect indexed) ($54.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $44.b,X		; 34 44 ; Test bits $44.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and ($33.b,S),Y		; 33 33 ; AND accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	mvp $98,$22		; 44 22 98 ; Move block positive $98,$22 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $5D11EF.l,X		; 1F EF 11 5D ; Logical OR long $5D11EF.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda ($21.b,X)		; A1 21 ; Load accumulator ($21.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($CD.b,S),Y		; 53 CD ; XOR accumulator (stack relative indirect indexed) ($CD.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	ora $30D11E.l		; 0F 1E D1 30 ; OR accumulator with memory (long) $30D11E.l [Writes: Accumulator] [Flags: NZ]
	bit $EB.b		; 24 EB ; Test bits $EB.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cmp ($01.b),Y		; D1 01 ; Compare accumulator ($01.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	mvn $52,$AC		; 54 AC 52 ; Move block negative $52,$AC [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	lda ($0A.b),Y		; B1 0A ; Load accumulator ($0A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	inc $2D.b,X		; F6 2D ; Increment memory $2D.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	cmp ($A8.b,X)		; C1 A8 ; Compare accumulator ($A8.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	.db $62, $AA, $14		; 62 AA 14 ; Push effective relative address $62, $AA, $14 [Writes: Stack Pointer]
	tsb $FC03.w		; 0C 03 FC ; Test and set bits $FC03.w [Reads: Accumulator] [Flags: Z]
	.db $30, $F0		; 30 F0 ; Branch if minus to $30, $F0 [Flow: branch]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	jsl $FFFFED.l		; 22 ED FF FF ; Jump to subroutine long $FFFFED.l [Writes: Stack Pointer] [Flow: call]
	eor ($BF.b,X)		; 41 BF ; Exclusive OR accumulator with memory ($BF.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $0DA411.l,X		; 3F 11 A4 0D ; AND accumulator with memory (long,X) $0DA411.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($21.b,X)		; E1 21 ; Subtract with carry ($21.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp.w [$1FF0]		; DC F0 1F ; Jump long indirect [$1FF0] [Flow: jump]
	.db $F0, $0F		; F0 0F ; Branch if equal to $F0, $0F [Flow: branch]
	sty $F0.b,X		; 94 F0 ; Store Y register $F0.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	.db $10, $22		; 10 22 ; Branch if plus to $10, $22 [Flow: branch]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc $2C.b,S		; E3 2C ; Subtract stack-relative $2C.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	cmp ($2F.b,X)		; C1 2F ; Compare accumulator ($2F.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $30.b		; 02 30 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $0C		; F0 0C ; Branch if equal to $F0, $0C [Flow: branch]
	cmp ($32.b)		; D2 32 ; Compare accumulator (indirect) ($32.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	asl $34EF.w,X		; 1E EF 34 ; Arithmetic shift left $34EF.w,X [Reads: X Index] [Flags: NCZ]
	asl $E021.w,X		; 1E 21 E0 ; Arithmetic shift left $E021.w,X [Reads: X Index] [Flags: NCZ]
	ora $98E1.w,X		; 1D E1 98 ; OR accumulator with memory $98E1.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $42, $E1		; 42 E1 ; Reserved instruction
	eor ($D3.b),Y		; 51 D3 ; Exclusive OR accumulator with memory ($D3.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsr $41E0.w		; 20 E0 41 ; Jump to subroutine at $41E0.w [Writes: Stack Pointer] [Flow: call]
	cmp ($A8.b),Y		; D1 A8 ; Compare accumulator ($A8.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	asl $4D06.w		; 0E 06 4D ; Arithmetic shift left $4D06.w [Flags: NCZ]
	cmp ($22.b,X)		; C1 22 ; Compare accumulator ($22.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	.db $F0, $01		; F0 01 ; Branch if equal to $F0, $01 [Flow: branch]
	.db $10, $88		; 10 88 ; Branch if plus to $10, $88 [Flow: branch]
	tsb $31.b		; 04 31 ; Test and set bits $31.b [Reads: Accumulator] [Flags: Z]
	jsl $112211.l		; 22 11 22 11 ; Jump to subroutine long $112211.l [Writes: Stack Pointer] [Flow: call]
	jsl $228421.l		; 22 21 84 22 ; Jump to subroutine long $228421.l [Writes: Stack Pointer] [Flow: call]
	jsl $112222.l		; 22 22 22 11 ; Jump to subroutine long $112222.l [Writes: Stack Pointer] [Flow: call]
	ora $A85FD6.l,X		; 1F D6 5F A8 ; Logical OR long $A85FD6.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $D14FF1.l,X		; 1F F1 4F D1 ; Logical OR long $D14FF1.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($F0.b),Y		; F1 F0 ; Subtract with carry ($F0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $D0, $24		; D0 24 ; Branch if not equal to $D0, $24 [Flow: branch]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	sbc $3F.b,X		; F5 3F ; Subtract $3F.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($DD.b,X)		; E1 DD ; Subtract with carry ($DD.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	trb $EB.b		; 14 EB ; Test and reset bits $EB.b [Reads: Accumulator] [Flags: Z]
	cmp ($A4.b,S),Y		; D3 A4 ; Compare accumulator (stack relative indirect indexed) ($A4.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	ora $DC22F0.l		; 0F F0 22 DC ; OR accumulator with memory (long) $DC22F0.l [Writes: Accumulator] [Flags: NZ]
	sbc $EF1FF0.l,X		; FF F0 1F EF ; Subtract with carry (long,X) $EF1FF0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $FE		; 10 FE ; Branch if plus to $10, $FE [Flow: branch]
	cpx $1F14.w		; EC 14 1F ; Compare $1F14.w with X register [Reads: X Index] [Flags: NCZ]
	.db $F0, $A8		; F0 A8 ; Branch if equal to $F0, $A8 [Flow: branch]
	and $D30C01.l		; 2F 01 0C D3 ; AND accumulator with memory (long) $D30C01.l [Writes: Accumulator] [Flags: NZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $02		; 10 02 ; Branch if plus to $10, $02 [Flow: branch]
	ldy $51.b		; A4 51 ; Load $51.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	ldy $E022.w,X		; BC 22 E0 ; Load Y register $E022.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	mvn $03,$EC		; 54 EC 03 ; Move block negative $03,$EC [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	tsb $F5A8.w		; 0C A8 F5 ; Test and set bits $F5A8.w [Reads: Accumulator] [Flags: Z]
	lsr $55AF.w,X		; 5E AF 55 ; Logical shift right $55AF.w,X [Reads: X Index] [Flags: NCZ]
	dec $430F.w,X		; DE 0F 43 ; Decrement memory $430F.w,X [Reads: X Index] [Flags: NZ]
	lda $23A4.w		; AD A4 23 ; Load $23A4.w into accumulator [Writes: Accumulator] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	ora $22DE11.l		; 0F 11 DE 22 ; OR accumulator with memory (long) $22DE11.l [Writes: Accumulator] [Flags: NZ]
	lsr $31.b		; 46 31 ; Logical shift right $31.b [Reads: Direct Page] [Flags: NCZ]
	ldy $21.b,X		; B4 21 ; Load Y register $21.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $3024.w		; CD 24 30 ; Compare $3024.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cpx $A8E0.w		; EC E0 A8 ; Compare $A8E0.w with X register [Reads: X Index] [Flags: NCZ]
	adc $F15DA1.l,X		; 7F A1 5D F1 ; Add long $F15DA1.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $21.b		; 00 21 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clv		; B8 ; Clear overflow flag [Flags: V]
	sbc $001100.l,X		; FF 00 11 00 ; Subtract with carry (long,X) $001100.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $40		; F0 40 ; Branch if equal to $F0, $40 [Flow: branch]
	.db $D0, $1E		; D0 1E ; Branch if not equal to $D0, $1E [Flow: branch]
	ldy $BF.b		; A4 BF ; Load $BF.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	jsr $32DC.w		; 20 DC 32 ; Jump to subroutine at $32DC.w [Writes: Stack Pointer] [Flow: call]
	mvp $BA,$1E		; 44 1E BA ; Move block positive $BA,$1E [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora ($A4.b)		; 12 A4 ; OR accumulator with memory (indirect) ($A4.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $42AE.w		; 20 AE 42 ; Jump to subroutine at $42AE.w [Writes: Stack Pointer] [Flow: call]
	.db $F0, $0C		; F0 0C ; Branch if equal to $F0, $0C [Flow: branch]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: NCZ]
	.db $10, $98		; 10 98 ; Branch if plus to $10, $98 [Flow: branch]
	ora $20E4EA.l		; 0F EA E4 20 ; OR accumulator with memory (long) $20E4EA.l [Writes: Accumulator] [Flags: NZ]
	ldy $1341.w,X		; BC 41 13 ; Load Y register $1341.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ldy $22.b		; A4 22 ; Load $22.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	sbc $0ED00D.l,X		; FF 0D D0 0E ; Subtract with carry (long,X) $0ED00D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $DC.b		; 02 DC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $A8.b		; 46 A8 ; Logical shift right $A8.b [Reads: Direct Page] [Flags: NCZ]
	cmp $02E1.w		; CD E1 02 ; Compare $02E1.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cpx $32.b		; E4 32 ; Compare $32.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	lda $DDB47D.l,X		; BF 7D B4 DD ; Load long $DDB47D.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($20.b,X)		; 01 20 ; Logical OR ($20.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp $1100.w		; CD 00 11 ; Compare $1100.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora ($0E.b),Y		; 11 0E ; OR accumulator with memory ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ldy $E4.b		; A4 E4 ; Load $E4.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	eor ($FD.b)		; 52 FD ; Exclusive OR accumulator with memory (indirect) ($FD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $FE0E22.l		; EF 22 0E FE ; Subtract with carry (long) $FE0E22.l [Writes: Accumulator] [Flags: NCVZ]
	cmp $FC42A8.l,X		; DF A8 42 FC ; Compare accumulator (long,X) $FC42A8.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	sbc ($0D.b,S),Y		; F3 0D ; Subtract with carry (stack relative indirect indexed) ($0D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $F3		; F0 F3 ; Branch if equal to $F0, $F3 [Flow: branch]
	rol $A4F2.w,X		; 3E F2 A4 ; Rotate left $A4F2.w,X [Reads: X Index] [Flags: NCZ]
	.db $30, $DB		; 30 DB ; Branch if minus to $30, $DB [Flow: branch]
	pea $F151.w		; F4 51 F1 ; Push absolute address $F151.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	and ($10.b)		; 32 10 ; AND accumulator with memory (indirect) ($10.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($A4.b,S),Y		; 13 A4 ; OR accumulator (stack relative indirect indexed) ($A4.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	trb $1FF3.w		; 1C F3 1F ; Test and reset bits $1FF3.w [Reads: Accumulator] [Flags: Z]
	ora ($32.b,X)		; 01 32 ; Logical OR ($32.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	ora ($F2.b,X)		; 01 F2 ; Logical OR ($F2.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	and $10F2.w		; 2D F2 10 ; Logical AND $10F2.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $DD.b		; 00 DD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $30.b,X		; 15 30 ; OR accumulator with memory $30.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $F4FEA4.l,X		; FF A4 FE F4 ; Subtract with carry (long,X) $F4FEA4.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	dec $E51C.w		; CE 1C E5 ; Decrement $E51C.w [Flags: NZ]
	ora $1FA445.l,X		; 1F 45 A4 1F ; Logical OR long $1FA445.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($EC.b,X)		; 01 EC ; Logical OR ($EC.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpx $51.b		; E4 51 ; Compare $51.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc $A8F122.l,X		; FF 22 F1 A8 ; Subtract with carry (long,X) $A8F122.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $0F1000.l,X		; 1F 00 10 0F ; Logical OR long $0F1000.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $ECFE55.l,X		; DF 55 FE EC ; Compare accumulator (long,X) $ECFE55.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	sbc $00.b		; E5 00 ; Subtract $00.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $0F1EF1.l,X		; 1F F1 1E 0F ; Logical OR long $0F1EF1.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $A823.w,X		; FE 23 A8 ; Increment memory $A823.w,X [Reads: X Index] [Flags: NZ]
	jsr ($52C0.w,X)		; FC C0 52 ; Jump to subroutine indirect indexed ($52C0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jmp.w [$1B13]		; DC 13 1B ; Jump long indirect [$1B13] [Flow: jump]
	cpy $21.b		; C4 21 ; Compare $21.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	cmp $04CB21.l,X		; DF 21 CB 04 ; Compare accumulator (long,X) $04CB21.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	asl $3FE2.w,X		; 1E E2 3F ; Arithmetic shift left $3FE2.w,X [Reads: X Index] [Flags: NCZ]
	cmp ($A4.b,X)		; C1 A4 ; Compare accumulator ($A4.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	eor ($AE.b,X)		; 41 AE ; Exclusive OR accumulator with memory ($AE.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $01		; 10 01 ; Branch if plus to $10, $01 [Flow: branch]
	asl $20BE.w		; 0E BE 20 ; Arithmetic shift left $20BE.w [Flags: NCZ]
	cmp $00FFA4.l,X		; DF A4 FF 00 ; Compare accumulator (long,X) $00FFA4.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $0B.b		; 24 0B ; Test bits $0B.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sbc $5C.b		; E5 5C ; Subtract $5C.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ldy $91.b		; A4 91 ; Load $91.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	and $144025.l		; 2F 25 40 14 ; AND accumulator with memory (long) $144025.l [Writes: Accumulator] [Flags: NZ]
	and $A8EDEF.l,X		; 3F EF ED A8 ; AND accumulator with memory (long,X) $A8EDEF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $FC.b,X		; 35 FC ; Logical AND $FC.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $F3.b		; 00 F3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $FD42D0.l		; 2F D0 42 FD ; AND accumulator with memory (long) $FD42D0.l [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	pea $D62C.w		; F4 2C D6 ; Push absolute address $D62C.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	eor $01D2.w,X		; 5D D2 01 ; Exclusive OR accumulator with memory $01D2.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $0FA410.l,X		; 1F 10 A4 0F ; Logical OR long $0FA410.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dec $2D24.w,X		; DE 24 2D ; Decrement memory $2D24.w,X [Reads: X Index] [Flags: NZ]
	cmp ($61.b,S),Y		; D3 61 ; Compare accumulator (stack relative indirect indexed) ($61.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $01.b		; A4 01 ; Load $01.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	and ($00.b,X)		; 21 00 ; Logical AND ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $BDF0.w,X		; FD F0 BD ; Subtract with carry $BDF0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($11.b,S),Y		; 13 11 ; OR accumulator (stack relative indirect indexed) ($11.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	and $E34DB1.l		; 2F B1 4D E3 ; AND accumulator with memory (long) $E34DB1.l [Writes: Accumulator] [Flags: NZ]
	and ($EB.b,S),Y		; 33 EB ; AND accumulator (stack relative indirect indexed) ($EB.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc ($ED.b)		; F2 ED ; Subtract with carry (indirect) ($ED.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ldy $E5.b		; A4 E5 ; Load $E5.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	tsb $04DD.w		; 0C DD 04 ; Test and set bits $04DD.w [Reads: Accumulator] [Flags: Z]
	and $13FE12.l		; 2F 12 FE 13 ; AND accumulator with memory (long) $13FE12.l [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	.db $F0, $0B		; F0 0B ; Branch if equal to $F0, $0B [Flow: branch]
	pea $F32D.w		; F4 2D F3 ; Push absolute address $F32D.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	ldy $E055.w,X		; BC 55 E0 ; Load Y register $E055.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	ora $0F20E1.l		; 0F E1 20 0F ; OR accumulator with memory (long) $0F20E1.l [Writes: Accumulator] [Flags: NZ]
	dec $0022.w,X		; DE 22 00 ; Decrement memory $0022.w,X [Reads: X Index] [Flags: NZ]
	sbc $50F4A4.l,X		; FF A4 F4 50 ; Subtract with carry (long,X) $50F4A4.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	jsl $9433EE.l		; 22 EE 33 94 ; Jump to subroutine long $9433EE.l [Writes: Stack Pointer] [Flow: call]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	lda $D0EC.w		; AD EC D0 ; Load $D0EC.w into accumulator [Writes: Accumulator] [Flags: NZ]
	asl $6D.b,X		; 16 6D ; Arithmetic shift left $6D.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
.ACCU 16
.INDEX 16
	rep #$35		; C2 35
	ldy $11.b,X		; B4 11 ; Load Y register $11.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	and ($DC.b,X)		; 21 DC ; Logical AND ($DC.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc ($40.b,S),Y		; F3 40 ; Subtract with carry (stack relative indirect indexed) ($40.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$EF20.w		; E0 20 EF ; Compare #$EF20.w with X register [Reads: X Index] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lsr $3FC2.w,X		; 5E C2 3F ; Logical shift right $3FC2.w,X [Reads: X Index] [Flags: NCZ]
	pea $9F3D.w		; F4 3D 9F ; Push absolute address $9F3D.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	ora $6F.b,X		; 15 6F ; OR accumulator with memory $6F.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ldy $0F.b		; A4 0F ; Load $0F.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and ($F0.b),Y		; 31 F0 ; AND accumulator with memory ($F0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $42		; F0 42 ; Branch if equal to $F0, $42 [Flow: branch]
	cpy #$3EA4.w		; C0 A4 3E ; Compare #$3EA4.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpy #$2122.w		; C0 22 21 ; Compare #$2122.w with Y register [Reads: Y Index] [Flags: NCZ]
	inc $4203.w,X		; FE 03 42 ; Increment memory $4203.w,X [Reads: X Index] [Flags: NZ]
	cpx $E2A4.w		; EC A4 E2 ; Compare $E2A4.w with X register [Reads: X Index] [Flags: NCZ]
	asl $0E35.w		; 0E 35 0E ; Arithmetic shift left $0E35.w [Flags: NCZ]
	.db $F0, $EB		; F0 EB ; Branch if equal to $F0, $EB [Flow: branch]
	sbc $40.b,S		; E3 40 ; Subtract stack-relative $40.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	sbc $32ED34.l		; EF 34 ED 32 ; Subtract with carry (long) $32ED34.l [Writes: Accumulator] [Flags: NCVZ]
	dec $1100.w,X		; DE 00 11 ; Decrement memory $1100.w,X [Reads: X Index] [Flags: NZ]
	jsl $05DA98.l		; 22 98 DA 05 ; Jump to subroutine long $05DA98.l [Writes: Stack Pointer] [Flow: call]
	trb $E012.w		; 1C 12 E0 ; Test and reset bits $E012.w [Reads: Accumulator] [Flags: Z]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	inc $A8C2.w,X		; FE C2 A8 ; Increment memory $A8C2.w,X [Reads: X Index] [Flags: NZ]
	and ($0D.b,X)		; 21 0D ; Logical AND ($0D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc ($1E.b)		; F2 1E ; Subtract with carry (indirect) ($1E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jsl $2F23CE.l		; 22 CE 23 2F ; Jump to subroutine long $2F23CE.l [Writes: Stack Pointer] [Flow: call]
	ldy $FF.b		; A4 FF ; Load $FF.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	sbc $EFF0.w,X		; FD F0 EF ; Subtract with carry $EFF0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	mvp $F0,$20		; 44 20 F0 ; Move block positive $F0,$20 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	asl $F294.w		; 0E 94 F2 ; Arithmetic shift left $F294.w [Flags: NCZ]
	and ($EF.b,X)		; 21 EF ; Logical AND ($EF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $CFDA35.l		; 0F 35 DA CF ; OR accumulator with memory (long) $CFDA35.l [Writes: Accumulator] [Flags: NZ]
	ora $FEF1A4.l,X		; 1F A4 F1 FE ; Logical OR long $FEF1A4.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $EF20CE.l,X		; FF CE 20 EF ; Subtract with carry (long,X) $EF20CE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $3D.b,S		; 03 3D ; OR accumulator with stack relative $3D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldy $C1.b		; A4 C1 ; Load $C1.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	bit $00AF.w		; 2C AF 00 ; Test bits $00AF.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	ora ($1D.b,S),Y		; 13 1D ; OR accumulator (stack relative indirect indexed) ($1D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc ($10.b)		; F2 10 ; Subtract with carry (indirect) ($10.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $F122.w		; 1C 22 F1 ; Test and reset bits $F122.w [Reads: Accumulator] [Flags: Z]
	wai		; CB ; Wait for interrupt
	cmp ($40.b,S),Y		; D3 40 ; Compare accumulator (stack relative indirect indexed) ($40.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	.db $F0, $33		; F0 33 ; Branch if equal to $F0, $33 [Flow: branch]
	sty $0D.b,X		; 94 0D ; Store Y register $0D.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	cop $63.b		; 02 63 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $AF0A.w		; CE 0A AF ; Decrement $AF0A.w [Flags: NZ]
	sbc $23A434.l,X		; FF 34 A4 23 ; Subtract with carry (long,X) $23A434.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($F0.b,X)		; 41 F0 ; Exclusive OR accumulator with memory ($F0.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and ($00.b,X)		; 21 00 ; Logical AND ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc ($50.b),Y		; F1 50 ; Subtract with carry ($50.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $98.b,S		; E3 98 ; Subtract stack-relative $98.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	sbc ($25.b,S),Y		; F3 25 ; Subtract with carry (stack relative indirect indexed) ($25.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	bit $1CD4.w,X		; 3C D4 1C ; Test bits $1CD4.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	sbc ($53.b,X)		; E1 53 ; Subtract with carry ($53.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($2C.b,S),Y		; F3 2C ; Subtract with carry (stack relative indirect indexed) ($2C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
.INDEX 16
	rep #$10		; C2 10
	eor ($BF.b)		; 52 BF ; Exclusive OR accumulator with memory (indirect) ($BF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $34A8EE.l		; 22 EE A8 34 ; Jump to subroutine long $34A8EE.l [Writes: Stack Pointer] [Flow: call]
	inc $050E.w		; EE 0E 05 ; Increment $050E.w [Flags: NZ]
	asl $EE20.w		; 0E 20 EE ; Arithmetic shift left $EE20.w [Flags: NCZ]
	and ($94.b,S),Y		; 33 94 ; AND accumulator (stack relative indirect indexed) ($94.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	bit $FD.b		; 24 FD ; Test bits $FD.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	trb $0D.b		; 14 0D ; Test and reset bits $0D.b [Reads: Accumulator] [Flags: Z]
	bit $0F.b		; 24 0F ; Test bits $0F.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora $3E03A4.l,X		; 1F A4 03 3E ; Logical OR long $3E03A4.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $01DE.w		; CD DE 01 ; Compare $01DE.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	and ($EF.b,S),Y		; 33 EF ; AND accumulator (stack relative indirect indexed) ($EF.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $A8.b		; 00 A8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $D0		; 10 D0 ; Branch if plus to $10, $D0 [Flow: branch]
	ora $1E0201.l,X		; 1F 01 02 1E ; Logical OR long $1E0201.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $BD.b		; 00 BD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $C3.b		; A4 C3 ; Load $C3.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	eor $0F0FE1.l		; 4F E1 0F 0F ; Exclusive OR accumulator with memory (long) $0F0FE1.l [Writes: Accumulator] [Flags: NZ]
	cpx #$3012.w		; E0 12 30 ; Compare #$3012.w with X register [Reads: X Index] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	cmp $EE3F13.l		; CF 13 3F EE ; Compare accumulator (long) $EE3F13.l [Reads: Accumulator] [Flags: NCZ]
	sbc ($3E.b)		; F2 3E ; Subtract with carry (indirect) ($3E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp $94F3.w,X		; DD F3 94 ; Compare accumulator $94F3.w,X [Reads: X Index] [Flags: NCZ]
	and [$6F.b],Y		; 37 6F ; AND accumulator with memory (long indexed) [$6F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $ED25FB.l		; CF FB 25 ED ; Compare accumulator (long) $ED25FB.l [Reads: Accumulator] [Flags: NCZ]
	sbc $4594E0.l,X		; FF E0 94 45 ; Subtract with carry (long,X) $4594E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	nop		; EA ; No operation
	cpx #$03FD.w		; E0 FD 03 ; Compare #$03FD.w with X register [Reads: X Index] [Flags: NCZ]
	jsl $A8BA40.l		; 22 40 BA A8 ; Jump to subroutine long $A8BA40.l [Writes: Stack Pointer] [Flow: call]
	ora ($21.b),Y		; 11 21 ; OR accumulator with memory ($21.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $130DE1.l,X		; 1F E1 0D 13 ; Logical OR long $130DE1.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	trb $A402.w		; 1C 02 A4 ; Test and reset bits $A402.w [Reads: Accumulator] [Flags: Z]
	.db $10, $CF		; 10 CF ; Branch if plus to $10, $CF [Flow: branch]
	adc $11.b		; 65 11 ; Add $11.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $44E2FE.l,X		; 1F FE E2 44 ; Logical OR long $44E2FE.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sty $6F.b,X		; 94 6F ; Store Y register $6F.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	sbc ($DB.b,X)		; E1 DB ; Subtract with carry ($DB.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	wai		; CB ; Wait for interrupt
	asl $5F.b		; 06 5F ; Arithmetic shift left $5F.b [Reads: Direct Page] [Flags: NCZ]
	cmp ($D0.b),Y		; D1 D0 ; Compare accumulator ($D0.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	ldy $55.b		; A4 55 ; Load $55.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	jsr ($0101.w,X)		; FC 01 01 ; Jump to subroutine indirect indexed ($0101.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	eor ($F0.b,X)		; 41 F0 ; Exclusive OR accumulator with memory ($F0.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	inc $A4ED.w,X		; FE ED A4 ; Increment memory $A4ED.w,X [Reads: X Index] [Flags: NZ]
	sbc ($01.b),Y		; F1 01 ; Subtract with carry ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $F0E0.w,X		; 3E E0 F0 ; Rotate left $F0E0.w,X [Reads: X Index] [Flags: NCZ]
	.db $10, $24		; 10 24 ; Branch if plus to $10, $24 [Flow: branch]
	ora $0EA0.w,X		; 1D A0 0E ; OR accumulator with memory $0EA0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$52B2.w		; C9 B2 52 ; Compare #$52B2.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $10		; F0 10 ; Branch if equal to $F0, $10 [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldy #$ECA8.w		; A0 A8 EC ; Load #$ECA8.w into Y register [Writes: Y Index] [Flags: NZ]
	ora ($1D.b),Y		; 11 1D ; OR accumulator with memory ($1D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($4F.b)		; D2 4F ; Compare accumulator (indirect) ($4F.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	.db $F0, $20		; F0 20 ; Branch if equal to $F0, $20 [Flow: branch]
	sbc $42A8.w		; ED A8 42 ; Subtract $42A8.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cpx DMADEST0.w		; EC 01 43 ; Compare DMADEST0.w with X register [Reads: X Index] [Flags: NCZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cop $3E.b		; 02 3E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$F494.w		; E0 94 F4 ; Compare #$F494.w with X register [Reads: X Index] [Flags: NCZ]
	bit $E9F2.w,X		; 3C F2 E9 ; Test bits $E9F2.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	cpx $FB.b		; E4 FB ; Compare $FB.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	eor [$2F.b]		; 47 2F ; Exclusive OR accumulator with memory (long) [$2F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	jsr $B0FE.w		; 20 FE B0 ; Jump to subroutine at $B0FE.w [Writes: Stack Pointer] [Flow: call]
	mvp $E1,$EF		; 44 EF E1 ; Move block positive $E1,$EF [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	and $0C9421.l		; 2F 21 94 0C ; AND accumulator with memory (long) $0C9421.l [Writes: Accumulator] [Flags: NZ]
	cmp ($2E.b),Y		; D1 2E ; Compare accumulator ($2E.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cmp ($2E.b,X)		; C1 2E ; Compare accumulator ($2E.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	sbc ($ED.b)		; F2 ED ; Subtract with carry (indirect) ($ED.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and ($A4.b),Y		; 31 A4 ; AND accumulator with memory ($A4.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cop $1F.b		; 02 1F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $43CF.w		; ED CF 43 ; Subtract $43CF.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	inc $24DE.w,X		; FE DE 24 ; Increment memory $24DE.w,X [Reads: X Index] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	ora $12D0.w		; 0D D0 12 ; Logical OR $12D0.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $FD02.w		; 0E 02 FD ; Arithmetic shift left $FD02.w [Flags: NCZ]
	ora $2F.b,S		; 03 2F ; OR accumulator with stack relative $2F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sty $22.b,X		; 94 22 ; Store Y register $22.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	ora $5D.b,X		; 15 5D ; OR accumulator with memory $5D.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lda ($31.b),Y		; B1 31 ; Load accumulator ($31.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $22DF.w		; 0D DF 22 ; Logical OR $22DF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($2E.b),Y		; F1 2E ; Subtract with carry ($2E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
.INDEX 8
	sep #$1C		; E2 1C
	sbc $41.b,S		; E3 41 ; Subtract stack-relative $41.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	ora $F0A4AF.l,X		; 1F AF A4 F0 ; Logical OR long $F0A4AF.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($32.b,X)		; 01 32 ; Logical OR ($32.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($0E.b,X)		; 01 0E ; Logical OR ($0E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	dec $0C24.w,X		; DE 24 0C ; Decrement memory $0C24.w,X [Reads: X Index] [Flags: NZ]
	sty $01.b,X		; 94 01 ; Store Y register $01.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	lda $F266.w		; AD 66 F2 ; Load $F266.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $50, $DE		; 50 DE ; Branch if overflow clear to $50, $DE [Flow: branch]
	ldy $A804.w,X		; BC 04 A8 ; Load Y register $A804.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	asl $1F01.w		; 0E 01 1F ; Arithmetic shift left $1F01.w [Flags: NCZ]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $DD.b,S		; 03 DD ; OR accumulator with stack relative $DD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $A8.b		; 24 A8 ; Test bits $A8.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	.db $F0, $1E		; F0 1E ; Branch if equal to $F0, $1E [Flow: branch]
	sbc ($20.b,X)		; E1 20 ; Subtract with carry ($20.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($FC.b,X)		; 21 FC ; Logical AND ($FC.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $0C.b,S		; 03 0C ; OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sty $B3.b,X		; 94 B3 ; Store Y register $B3.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	and ($1F.b,X)		; 21 1F ; Logical AND ($1F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and [$50.b],Y		; 37 50 ; AND accumulator with memory (long indexed) [$50.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($EC.b),Y		; 11 EC ; OR accumulator with memory ($EC.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$84.b		; E0 84 ; Compare #$84.b with X register [Reads: X Index] [Flags: NCZ]
	cmp ($62.b),Y		; D1 62 ; Compare accumulator ($62.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	asl $AEBB.w		; 0E BB AE ; Arithmetic shift left $AEBB.w [Flags: NCZ]
	adc [$0D.b]		; 67 0D ; Add with carry (long) [$0D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jsr $DDA4.w		; 20 A4 DD ; Jump to subroutine at $DDA4.w [Writes: Stack Pointer] [Flow: call]
	inc $0E02.w,X		; FE 02 0E ; Increment memory $0E02.w,X [Reads: X Index] [Flags: NZ]
	sbc $24CE.w		; ED CE 24 ; Subtract $24CE.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ora $F3A4.w,X		; 1D A4 F3 ; OR accumulator with memory $F3A4.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $00F1CC.l,X		; 3F CC F1 00 ; AND accumulator with memory (long,X) $00F1CC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $ED		; 10 ED ; Branch if plus to $10, $ED [Flow: branch]
	cpx #$A8.b		; E0 A8 ; Compare #$A8.b with X register [Reads: X Index] [Flags: NCZ]
	ora ($F0.b),Y		; 11 F0 ; OR accumulator with memory ($F0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $CC24FE.l,X		; FF FE 24 CC ; Subtract with carry (long,X) $CC24FE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($0F.b,S),Y		; 33 0F ; AND accumulator (stack relative indirect indexed) ($0F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldy $10.b		; A4 10 ; Load $10.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	inc $24DE.w,X		; FE DE 24 ; Increment memory $24DE.w,X [Reads: X Index] [Flags: NZ]
	.db $30, $DF		; 30 DF ; Branch if minus to $30, $DF [Flow: branch]
	and ($FD.b)		; 32 FD ; AND accumulator with memory (indirect) ($FD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sty $D5.b,X		; 94 D5 ; Store Y register $D5.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	ror $FEE2.w		; 6E E2 FE ; Rotate right $FEE2.w [Flags: NCZ]
	cmp $FF55.w		; CD 55 FF ; Compare $FF55.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cop $A4.b		; 02 A4 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1EFF34.l		; 0F 34 FF 1E ; OR accumulator with memory (long) $1EFF34.l [Writes: Accumulator] [Flags: NZ]
.INDEX 8
	sep #$1E		; E2 1E
	cpx #$31.b		; E0 31 ; Compare #$31.b with X register [Reads: X Index] [Flags: NCZ]
	ldy $F0.b		; A4 F0 ; Load $F0.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	ora ($12.b),Y		; 11 12 ; OR accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $DC.b,S		; 43 DC ; Exclusive OR accumulator with stack relative $DC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $1F.b		; 02 1F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($98.b),Y		; F1 98 ; Subtract with carry ($98.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx $3602.w		; EC 02 36 ; Compare $3602.w with X register [Reads: X Index] [Flags: NCZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	eor $DB.b		; 45 DB ; Exclusive OR $DB.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($C1.b,S),Y		; 33 C1 ; AND accumulator (stack relative indirect indexed) ($C1.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldy $ED.b		; A4 ED ; Load $ED.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	trb $0D.b		; 14 0D ; Test and reset bits $0D.b [Reads: Accumulator] [Flags: Z]
	dec $1311.w,X		; DE 11 13 ; Decrement memory $1311.w,X [Reads: X Index] [Flags: NZ]
	ora $119412.l,X		; 1F 12 94 11 ; Logical OR long $119412.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $EDDF0E.l		; 0F 0E DF ED ; OR accumulator with memory (long) $EDDF0E.l [Writes: Accumulator] [Flags: NZ]
.INDEX 8
	sep #$51		; E2 51
	sta $0EA4.w,X		; 9D A4 0E ; Store accumulator to $0EA4.w,X [Reads: Accumulator, X Index]
	sbc ($22.b),Y		; F1 22 ; Subtract with carry ($22.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx $0F13.w		; EC 13 0F ; Compare $0F13.w with X register [Reads: X Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $12.b,X		; 94 12 ; Store Y register $12.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	ora $6DB5DA.l		; 0F DA B5 6D ; OR accumulator with memory (long) $6DB5DA.l [Writes: Accumulator] [Flags: NZ]
	.db $B0, $32		; B0 32 ; Branch if carry set to $B0, $32 [Flow: branch]
	and ($94.b,X)		; 21 94 ; Logical AND ($94.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsr ($EB04.w,X)		; FC 04 EB ; Jump to subroutine indirect indexed ($EB04.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora $E2DB11.l		; 0F 11 DB E2 ; OR accumulator with memory (long) $E2DB11.l [Writes: Accumulator] [Flags: NZ]
	and ($84.b),Y		; 31 84 ; AND accumulator with memory ($84.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($0E.b)		; 12 0E ; OR accumulator with memory (indirect) ($0E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $1B04.w,X		; FE 04 1B ; Increment memory $1B04.w,X [Reads: X Index] [Flags: NZ]
	lda $94640E.l		; AF 0E 64 94 ; Load long $94640E.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp $24CD40.l		; CF 40 CD 24 ; Compare accumulator (long) $24CD40.l [Reads: Accumulator] [Flags: NCZ]
	.db $10, $1E		; 10 1E ; Branch if plus to $10, $1E [Flow: branch]
	cmp ($30.b),Y		; D1 30 ; Compare accumulator ($30.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
.ACCU 8
	sep #$2A		; E2 2A
	inc $0D.b,X		; F6 0D ; Increment memory $0D.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	sbc ($54.b,X)		; E1 54 ; Subtract with carry ($54.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	and ($98.b,X)		; 21 98 ; Logical AND ($98.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp ($33.b),Y		; D1 33 ; Compare accumulator ($33.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	eor $CD.b		; 45 CD ; Exclusive OR $CD.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($50.b,S),Y		; 13 50 ; OR accumulator (stack relative indirect indexed) ($50.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldy $D0A4.w,X		; BC A4 D0 ; Load Y register $D0A4.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	jsr $0E02.w		; 20 02 0E ; Jump to subroutine at $0E02.w [Writes: Stack Pointer] [Flow: call]
	ora ($CC.b),Y		; 11 CC ; OR accumulator with memory ($CC.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ldy #$23.b		; A0 23 ; Load #$23.b into Y register [Writes: Y Index] [Flags: NZ]
	jsr $0000.w		; 20 00 00 ; Jump to subroutine at $0000.w [Writes: Stack Pointer] [Flow: call]
	ora $D04F04.l		; 0F 04 4F D0 ; OR accumulator with memory (long) $D04F04.l [Writes: Accumulator] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $3E		; D0 3E ; Branch if not equal to $D0, $3E [Flow: branch]
	jmp.w [$3EF6]		; DC F6 3E ; Jump long indirect [$3EF6] [Flow: jump]
	sbc $1B.b,S		; E3 1B ; Subtract stack-relative $1B.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	cmp $98.b		; C5 98 ; Compare $98.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	lsr $F1D1.w,X		; 5E D1 F1 ; Logical shift right $F1D1.w,X [Reads: X Index] [Flags: NCZ]
	and $52EEF2.l		; 2F F2 EE 52 ; AND accumulator with memory (long) $52EEF2.l [Writes: Accumulator] [Flags: NZ]
	sbc $C488.w		; ED 88 C4 ; Subtract $C488.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	eor $F2FF.w,X		; 5D FF F2 ; Exclusive OR accumulator with memory $F2FF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsr $3B23.w		; 20 23 3B ; Jump to subroutine at $3B23.w [Writes: Stack Pointer] [Flow: call]
	cpx #$94.b		; E0 94 ; Compare #$94.b with X register [Reads: X Index] [Flags: NCZ]
	cpy $3113.w		; CC 13 31 ; Compare $3113.w with Y register [Reads: Y Index] [Flags: NCZ]
	cmp $0D1331.l,X		; DF 31 13 0D ; Compare accumulator (long,X) $0D1331.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	cmp $7398.w		; CD 98 73 ; Compare $7398.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	ora $3E.b		; 05 3E ; Logical OR $3E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc ($23.b,X)		; E1 23 ; Subtract with carry ($23.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ora ($98.b,X)		; 01 98 ; Logical OR ($98.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($02.b),Y		; 11 02 ; OR accumulator with memory ($02.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $EA44AD.l		; 4F AD 44 EA ; Exclusive OR accumulator with memory (long) $EA44AD.l [Writes: Accumulator] [Flags: NZ]
	sbc $64.b,S		; E3 64 ; Subtract stack-relative $64.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	sty $5E.b,X		; 94 5E ; Store Y register $5E.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	ldx $CEFE.w,Y		; BE FE CE ; Load X register $CEFE.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	rol $4F.b,X		; 36 4F ; Rotate left $4F.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	inc $94AB.w		; EE AB 94 ; Increment $94AB.w [Flags: NZ]
	and $11.b,S		; 23 11 ; AND accumulator with stack relative $11.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($ED.b,X)		; 21 ED ; Logical AND ($ED.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $1C.b		; 05 1C ; Logical OR $1C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $94E0.w		; EE E0 94 ; Increment $94E0.w [Flags: NZ]
	inc $2102.w,X		; FE 02 21 ; Increment memory $2102.w,X [Reads: X Index] [Flags: NZ]
	jsr $FD01.w		; 20 01 FD ; Jump to subroutine at $FD01.w [Writes: Stack Pointer] [Flow: call]
	wai		; CB ; Wait for interrupt
	lda ($A4.b),Y		; B1 A4 ; Load accumulator ($A4.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor ($DE.b,X)		; 41 DE ; Exclusive OR accumulator with memory ($DE.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $FEF0.w		; 20 F0 FE ; Jump to subroutine at $FEF0.w [Writes: Stack Pointer] [Flow: call]
	cpx #$98.b		; E0 98 ; Compare #$98.b with X register [Reads: X Index] [Flags: NCZ]
	rol $F3DE.w,X		; 3E DE F3 ; Rotate left $F3DE.w,X [Reads: X Index] [Flags: NCZ]
	and $3F30C0.l,X		; 3F C0 30 3F ; AND accumulator with memory (long,X) $3F30C0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda $23EF98.l,X		; BF 98 EF 23 ; Load long $23EF98.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($B1.b,X)		; 41 B1 ; Exclusive OR accumulator with memory ($B1.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	trb $11F1.w		; 1C F1 11 ; Test and reset bits $11F1.w [Reads: Accumulator] [Flags: Z]
	sbc $4E1694.l		; EF 94 16 4E ; Subtract with carry (long) $4E1694.l [Writes: Accumulator] [Flags: NCVZ]
	cmp ($10.b),Y		; D1 10 ; Compare accumulator ($10.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cop $33.b		; 02 33 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($00.b,X)		; 21 00 ; Logical AND ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sty $22.b		; 84 22 ; Store Y register to $22.b [Reads: Y Index]
	asl $FD12.w,X		; 1E 12 FD ; Arithmetic shift left $FD12.w,X [Reads: X Index] [Flags: NCZ]
	bit $D2.b,X		; 34 D2 ; Test bits $D2.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	adc $54.b,X		; 75 54 ; Add $54.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sty $00.b,X		; 94 00 ; Store Y register $00.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	cmp $62.b		; C5 62 ; Compare $62.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	and ($FE.b,X)		; 21 FE ; Logical AND ($FE.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpy $A8F3.w		; CC F3 A8 ; Compare $A8F3.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora $F12FEF.l,X		; 1F EF 2F F1 ; Logical OR long $F12FEF.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $ED		; 30 ED ; Branch if minus to $30, $ED [Flow: branch]
	pea $945F.w		; F4 5F 94 ; Push absolute address $945F.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	dec $DE1D.w		; CE 1D DE ; Decrement $DE1D.w [Flags: NZ]
	cmp $FFFF43.l		; CF 43 FF FF ; Compare accumulator (long) $FFFF43.l [Reads: Accumulator] [Flags: NCZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $B22D.w,X		; FD 2D B2 ; Subtract with carry $B22D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $FA.b,X		; 55 FA ; Exclusive OR accumulator with memory $FA.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lda $94.b,S		; A3 94 ; Load accumulator (stack relative) $94.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($F2.b),Y		; 11 F2 ; OR accumulator with memory ($F2.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $10F2FE.l,X		; 1F FE F2 10 ; Logical OR long $10F2FE.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	mvp $98,$ED		; 44 ED 98 ; Move block positive $98,$ED [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	and $1C0201.l		; 2F 01 02 1C ; AND accumulator with memory (long) $1C0201.l [Writes: Accumulator] [Flags: NZ]
	lda $EE1243.l,X		; BF 43 12 EE ; Load long $EE1243.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $41B1.w,X		; 1E B1 41 ; Arithmetic shift left $41B1.w,X [Reads: X Index] [Flags: NCZ]
	sbc $0F1E02.l		; EF 02 1E 0F ; Subtract with carry (long) $0F1E02.l [Writes: Accumulator] [Flags: NCVZ]
	ldy #$94.b		; A0 94 ; Load #$94.b into Y register [Writes: Y Index] [Flags: NZ]
	and $EC.b,S		; 23 EC ; AND accumulator with stack relative $EC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $1D.b		; 05 1D ; Logical OR $1D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $53.b,S		; E3 53 ; Subtract stack-relative $53.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	inc $98F0.w,X		; FE F0 98 ; Increment memory $98F0.w,X [Reads: X Index] [Flags: NZ]
	cpx #$40.b		; E0 40 ; Compare #$40.b with X register [Reads: X Index] [Flags: NCZ]
	ldy $1045.w,X		; BC 45 10 ; Load Y register $1045.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ora $9442BF.l		; 0F BF 42 94 ; OR accumulator with memory (long) $9442BF.l [Writes: Accumulator] [Flags: NZ]
	asl $51F4.w,X		; 1E F4 51 ; Arithmetic shift left $51F4.w,X [Reads: X Index] [Flags: NCZ]
	cmp $30E2.w,X		; DD E2 30 ; Compare accumulator $30E2.w,X [Reads: X Index] [Flags: NCZ]
	inc $94F2.w		; EE F2 94 ; Increment $94F2.w [Flags: NZ]
	jsr $F3FD.w		; 20 FD F3 ; Jump to subroutine at $F3FD.w [Writes: Stack Pointer] [Flow: call]
	.db $50, $F2		; 50 F2 ; Branch if overflow clear to $50, $F2 [Flow: branch]
	.db $10, $CA		; 10 CA ; Branch if plus to $10, $CA [Flow: branch]
	inc $98.b		; E6 98 ; Increment $98.b [Reads: Direct Page] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	lda $22FC34.l,X		; BF 34 FC 22 ; Load long $22FC34.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $2F.b		; 00 2F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $CD94.w		; EE 94 CD ; Increment $CD94.w [Flags: NZ]
	ora ($32.b,X)		; 01 32 ; Logical OR ($32.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $31D0.w,X		; FD D0 31 ; Subtract with carry $31D0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	trb $5F.b		; 14 5F ; Test and reset bits $5F.b [Reads: Accumulator] [Flags: Z]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	rep #$42		; C2 42 ; Reset processor status bits #$42 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	inc $10F0.w,X		; FE F0 10 ; Increment memory $10F0.w,X [Reads: X Index] [Flags: NZ]
	sbc ($01.b)		; F2 01 ; Subtract with carry (indirect) ($01.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	rol $F084.w		; 2E 84 F0 ; Rotate left $F084.w [Flags: NCZ]
	.db $10, $46		; 10 46 ; Branch if plus to $10, $46 [Flow: branch]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	cmp $DC02.w,X		; DD 02 DC ; Compare accumulator $DC02.w,X [Reads: X Index] [Flags: NCZ]
	and $98.b,X		; 35 98 ; Logical AND $98.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	dec $EF43.w,X		; DE 43 EF ; Decrement memory $EF43.w,X [Reads: X Index] [Flags: NZ]
	and ($AA.b,X)		; 21 AA ; Logical AND ($AA.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $32.b,X		; 34 32 ; Test bits $32.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	inc $2198.w		; EE 98 21 ; Increment $2198.w [Flags: NZ]
	cmp $32F12E.l,X		; DF 2E F1 32 ; Compare accumulator (long,X) $32F12E.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	ora $02DE.w		; 0D DE 02 ; Logical OR $02DE.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sty $34.b		; 84 34 ; Store Y register to $34.b [Reads: Y Index]
	and $EA.b,S		; 23 EA ; AND accumulator with stack relative $EA.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $FE.b		; 24 FE ; Test bits $FE.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sbc $986203.l,X		; FF 03 62 98 ; Subtract with carry (long,X) $986203.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $3004.w		; CE 04 30 ; Decrement $3004.w [Flags: NZ]
	ora $40D1.w		; 0D D1 40 ; Logical OR $40D1.w with accumulator [Writes: Accumulator] [Flags: NZ]
	inc $9400.w,X		; FE 00 94 ; Increment memory $9400.w,X [Reads: X Index] [Flags: NZ]
	sbc $0D02.w		; ED 02 0D ; Subtract $0D02.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	dec $1F34.w		; CE 34 1F ; Decrement $1F34.w [Flags: NZ]
	sbc $98D0.w,X		; FD D0 98 ; Subtract with carry $98D0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $0D		; 10 0D ; Branch if plus to $10, $0D [Flow: branch]
	sbc ($1E.b)		; F2 1E ; Subtract with carry (indirect) ($1E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp $02EC53.l		; CF 53 EC 02 ; Compare accumulator (long) $02EC53.l [Reads: Accumulator] [Flags: NCZ]
	sty $13.b,X		; 94 13 ; Store Y register $13.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	asl $1D14.w,X		; 1E 14 1D ; Arithmetic shift left $1D14.w,X [Reads: X Index] [Flags: NCZ]
	cmp $22E0.w		; CD E0 22 ; Compare $22E0.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsr $0384.w		; 20 84 03 ; Jump to subroutine at $0384.w [Writes: Stack Pointer] [Flow: call]
	cop $5F.b		; 02 5F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($5F.b,S),Y		; D3 5F ; Compare accumulator (stack relative indirect indexed) ($5F.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	cpy #$03.b		; C0 03 ; Compare #$03.b with Y register [Reads: Y Index] [Flags: NCZ]
	eor ($84.b)		; 52 84 ; Exclusive OR accumulator with memory (indirect) ($84.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $30, $9C		; 30 9C ; Branch if minus to $30, $9C [Flow: branch]
	adc [$FE.b]		; 67 FE ; Add with carry (long) [$FE.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $3E.b		; 24 3E ; Test bits $3E.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sty $CF.b		; 84 CF ; Store Y register to $CF.b [Reads: Y Index]
	and $5541D4.l		; 2F D4 41 55 ; AND accumulator with memory (long) $5541D4.l [Writes: Accumulator] [Flags: NZ]
	asl $3DE6.w,X		; 1E E6 3D ; Arithmetic shift left $3DE6.w,X [Reads: X Index] [Flags: NCZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	bit $1F.b,X		; 34 1F ; Test bits $1F.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sbc $50E6.w		; ED E6 50 ; Subtract $50E6.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ora ($BF.b),Y		; 11 BF ; OR accumulator with memory ($BF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr $F094.w,X		; 5E 94 F0 ; Logical shift right $F094.w,X [Reads: X Index] [Flags: NCZ]
	cmp $1024.w,X		; DD 24 10 ; Compare accumulator $1024.w,X [Reads: X Index] [Flags: NCZ]
	and $0B.b,X		; 35 0B ; Logical AND $0B.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $DF9833.l		; CF 33 98 DF ; Compare accumulator (long) $DF9833.l [Reads: Accumulator] [Flags: NCZ]
	and $ED32F1.l		; 2F F1 32 ED ; AND accumulator with memory (long) $ED32F1.l [Writes: Accumulator] [Flags: NZ]
	.db $10, $D0		; 10 D0 ; Branch if plus to $10, $D0 [Flow: branch]
	and $98.b,S		; 23 98 ; AND accumulator with stack relative $98.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $45CE.w,X		; 1D CE 45 ; OR accumulator with memory $45CE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $0CF42D.l		; EF 2D F4 0C ; Subtract with carry (long) $0CF42D.l [Writes: Accumulator] [Flags: NCVZ]
	sbc ($88.b),Y		; F1 88 ; Subtract with carry ($88.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	eor ($11.b,X)		; 41 11 ; Exclusive OR accumulator with memory ($11.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$B3.b		; 09 B3 ; Logical OR #$B3.b with accumulator [Writes: Accumulator] [Flags: NZ]
	mvn $EC,$FE		; 54 FE EC ; Move block negative $EC,$FE [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cop $EE.b		; 02 EE ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $2200DE.l		; 22 DE 00 22 ; Jump to subroutine long $2200DE.l [Writes: Stack Pointer] [Flow: call]
	cmp $9423.w		; CD 23 94 ; Compare $9423.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora ($31.b)		; 12 31 ; OR accumulator with memory (indirect) ($31.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $DFDE.w,X		; FD DE DF ; Subtract with carry $DFDE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	mvp $ED,$98		; 44 98 ED ; Move block positive $ED,$98 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	.db $D0, $12		; D0 12 ; Branch if not equal to $D0, $12 [Flow: branch]
	and ($DF.b),Y		; 31 DF ; AND accumulator with memory ($DF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $E123.w,X		; FD 23 E1 ; Subtract with carry $E123.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and $41D4FD.l		; 2F FD D4 41 ; AND accumulator with memory (long) $41D4FD.l [Writes: Accumulator] [Flags: NZ]
	.db $F0, $EF		; F0 EF ; Branch if equal to $F0, $EF [Flow: branch]
	ora ($3E.b)		; 12 3E ; OR accumulator with memory (indirect) ($3E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sty $DC.b,X		; 94 DC ; Store Y register $DC.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	sbc ($41.b)		; F2 41 ; Subtract with carry (indirect) ($41.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $1221EF.l		; 0F EF 21 12 ; OR accumulator with memory (long) $1221EF.l [Writes: Accumulator] [Flags: NZ]
	jsr $FF84.w		; 20 84 FF ; Jump to subroutine at $FF84.w [Writes: Stack Pointer] [Flow: call]
	sbc $2411EE.l,X		; FF EE 11 24 ; Subtract with carry (long,X) $2411EE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $31AF.w		; 2C AF 31 ; Test bits $31AF.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
.ACCU 8
.INDEX 8
	sep #$3E		; E2 3E
	tsb $E3.b		; 04 E3 ; Test and set bits $E3.b [Reads: Accumulator] [Flags: Z]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	dec $3D25.w		; CE 25 3D ; Decrement $3D25.w [Flags: NZ]
	sty $02.b,X		; 94 02 ; Store Y register $02.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	and ($CD.b),Y		; 31 CD ; AND accumulator with memory ($CD.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($ED.b,S),Y		; 33 ED ; AND accumulator (stack relative indirect indexed) ($ED.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	trb $1F.b		; 14 1F ; Test and reset bits $1F.b [Reads: Accumulator] [Flags: Z]
	sbc $3498.w,X		; FD 98 34 ; Subtract with carry $3498.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx $2001.w		; EC 01 20 ; Compare $2001.w with X register [Reads: X Index] [Flags: NCZ]
	.db $F0, $1D		; F0 1D ; Branch if equal to $F0, $1D [Flow: branch]
	sbc ($3E.b,S),Y		; F3 3E ; Subtract with carry (stack relative indirect indexed) ($3E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $AF3E23.l		; EF 23 3E AF ; Subtract with carry (long) $AF3E23.l [Writes: Accumulator] [Flags: NCVZ]
	ora ($4B.b,S),Y		; 13 4B ; OR accumulator (stack relative indirect indexed) ($4B.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $41.b,S		; C3 41 ; Compare accumulator (stack relative) $41.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	cop $33.b		; 02 33 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	cmp ($11.b),Y		; D1 11 ; Compare accumulator ($11.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cmp $9834.w,X		; DD 34 98 ; Compare accumulator $9834.w,X [Reads: X Index] [Flags: NCZ]
	sbc $11E21E.l		; EF 1E E2 11 ; Subtract with carry (long) $11E21E.l [Writes: Accumulator] [Flags: NCVZ]
	dec $031F.w,X		; DE 1F 03 ; Decrement memory $031F.w,X [Reads: X Index] [Flags: NZ]
	and $00FC94.l,X		; 3F 94 FC 00 ; AND accumulator with memory (long,X) $00FC94.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $F1.b		; 00 F1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($1F.b,S),Y		; 33 1F ; AND accumulator (stack relative indirect indexed) ($1F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $9423.w,X		; DE 23 94 ; Decrement memory $9423.w,X [Reads: X Index] [Flags: NZ]
	.db $10, $FE		; 10 FE ; Branch if plus to $10, $FE [Flow: branch]
	inc $41E3.w		; EE E3 41 ; Increment $41E3.w [Flags: NZ]
	ora $02DF.w		; 0D DF 02 ; Logical OR $02DF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($FC.b),Y		; 31 FC ; AND accumulator with memory ($FC.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	dec $1033.w		; CE 33 10 ; Decrement $1033.w [Flags: NZ]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($98.b)		; 12 98 ; OR accumulator with memory (indirect) ($98.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $1012.w,X		; FD 12 10 ; Subtract with carry $1012.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $54EF.w,X		; FE EF 54 ; Increment memory $54EF.w,X [Reads: X Index] [Flags: NZ]
	ldy $8823.w,X		; BC 23 88 ; Load Y register $8823.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	rol $62BE.w		; 2E BE 62 ; Rotate left $62BE.w [Flags: NCZ]
	cpy $51F4.w		; CC F4 51 ; Compare $51F4.w with Y register [Reads: Y Index] [Flags: NCZ]
	lda $80C5.w,X		; BD C5 80 ; Load $80C5.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	trb $20.b		; 14 20 ; Test and reset bits $20.b [Reads: Accumulator] [Flags: Z]
	inc $0F02.w		; EE 02 0F ; Increment $0F02.w [Flags: NZ]
	jsl $9823EF.l		; 22 EF 23 98 ; Jump to subroutine long $9823EF.l [Writes: Stack Pointer] [Flow: call]
	ora ($F0.b,X)		; 01 F0 ; Logical OR ($F0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $1E03.w,X		; 1E 03 1E ; Arithmetic shift left $1E03.w,X [Reads: X Index] [Flags: NCZ]
	cpy #$54.b		; C0 54 ; Compare #$54.b with Y register [Reads: Y Index] [Flags: NCZ]
	cpx $E284.w		; EC 84 E2 ; Compare $E284.w with X register [Reads: X Index] [Flags: NCZ]
	trb $31C2.w		; 1C C2 31 ; Test and reset bits $31C2.w [Reads: Accumulator] [Flags: Z]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $D0, $0E		; D0 0E ; Branch if not equal to $D0, $0E [Flow: branch]
	and $94.b,X		; 35 94 ; Logical AND $94.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	asl $4F03.w		; 0E 03 4F ; Arithmetic shift left $4F03.w [Flags: NCZ]
	dec $1300.w		; CE 00 13 ; Decrement $1300.w [Flags: NZ]
	and $E288EF.l		; 2F EF 88 E2 ; AND accumulator with memory (long) $E288EF.l [Writes: Accumulator] [Flags: NZ]
	and $11BC52.l		; 2F 52 BC 11 ; AND accumulator with memory (long) $11BC52.l [Writes: Accumulator] [Flags: NZ]
	sbc ($4F.b,S),Y		; F3 4F ; Subtract with carry (stack relative indirect indexed) ($4F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	inc $0394.w		; EE 94 03 ; Increment $0394.w [Flags: NZ]
	and ($FF.b),Y		; 31 FF ; AND accumulator with memory ($FF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $1410E0.l		; 0F E0 10 14 ; OR accumulator with memory (long) $1410E0.l [Writes: Accumulator] [Flags: NZ]
	ora $AE74.w,X		; 1D 74 AE ; OR accumulator with memory $AE74.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldy $6B.b,X		; B4 6B ; Load Y register $6B.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	lda ($41.b)		; B2 41 ; Load accumulator (indirect) ($41.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy #$3E.b		; A0 3E ; Load #$3E.b into Y register [Writes: Y Index] [Flags: NZ]
	ldy $2394.w		; AC 94 23 ; Load $2394.w into Y register [Writes: Y Index] [Flags: NZ]
	inc $EC00.w,X		; FE 00 EC ; Increment memory $EC00.w,X [Reads: X Index] [Flags: NZ]
	ldx $DD53.w,Y		; BE 53 DD ; Load X register $DD53.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ora $84.b,S		; 03 84 ; OR accumulator with stack relative $84.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
.ACCU 16
	rep #$2F		; C2 2F
	sbc ($20.b),Y		; F1 20 ; Subtract with carry ($20.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	wai		; CB ; Wait for interrupt
	sta $3488.w,Y		; 99 88 34 ; Store accumulator to $3488.w,Y [Reads: Y Index, Accumulator]
	sbc $13FC0F.l,X		; FF 0F FC 13 ; Subtract with carry (long,X) $13FC0F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $5C14.w,X		; BD 14 5C ; Load $5C14.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sty $CA.b		; 84 CA ; Store Y register to $CA.b [Reads: Y Index]
	.db $D0, $36		; D0 36 ; Branch if not equal to $D0, $36 [Flow: branch]
	ora $3304.w,X		; 1D 04 33 ; OR accumulator with memory $3304.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $84C0.w		; 0C C0 84 ; Test and set bits $84C0.w [Reads: Accumulator] [Flags: Z]
	and $52.b,S		; 23 52 ; AND accumulator with stack relative $52.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $0D65.w		; AD 65 0D ; Load $0D65.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $881D35.l		; EF 35 1D 88 ; Subtract with carry (long) $881D35.l [Writes: Accumulator] [Flags: NCVZ]
	ora $3F.b,S		; 03 3F ; OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc ($0F.b),Y		; F1 0F ; Subtract with carry ($0F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $0C.b,S		; 03 0C ; OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	pea $947E.w		; F4 7E 94 ; Push absolute address $947E.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sbc $D03E24.l,X		; FF 24 3E D0 ; Subtract with carry (long,X) $D03E24.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $11		; 10 11 ; Branch if plus to $10, $11 [Flow: branch]
	ora ($11.b)		; 12 11 ; OR accumulator with memory (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	and $22E1.w		; 2D E1 22 ; Logical AND $22E1.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $0F12FF.l,X		; 3F FF 12 0F ; AND accumulator with memory (long,X) $0F12FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $98.b,S		; E3 98 ; Subtract stack-relative $98.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	rol $0E03.w		; 2E 03 0E ; Rotate left $0E03.w [Flags: NCZ]
	ora ($F1.b),Y		; 11 F1 ; OR accumulator with memory ($F1.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $22E1.w,X		; 1D E1 22 ; OR accumulator with memory $22E1.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	inc $2F11.w		; EE 11 2F ; Increment $2F11.w [Flags: NZ]
	cmp ($3C.b,S),Y		; D3 3C ; Compare accumulator (stack relative indirect indexed) ($3C.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	cpx #$22.b		; E0 22 ; Compare #$22.b with X register [Reads: X Index] [Flags: NCZ]
	sbc $BB4184.l		; EF 84 41 BB ; Subtract with carry (long) $BB4184.l [Writes: Accumulator] [Flags: NCVZ]
	sbc $44CFED.l		; EF ED CF 44 ; Subtract with carry (long) $44CFED.l [Writes: Accumulator] [Flags: NCVZ]
	sbc $94F0.w,X		; FD F0 94 ; Subtract with carry $94F0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $0F		; F0 0F ; Branch if equal to $F0, $0F [Flow: branch]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $11AF.w		; 2C AF 11 ; Test bits $11AF.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	sbc $E5FC84.l,X		; FF 84 FC E5 ; Subtract with carry (long,X) $E5FC84.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($20.b)		; 52 20 ; Exclusive OR accumulator with memory (indirect) ($20.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
.INDEX 8
	sep #$10		; E2 10
	ora ($98.b,S),Y		; 13 98 ; OR accumulator (stack relative indirect indexed) ($98.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $E0110F.l,X		; FF 0F 11 E0 ; Subtract with carry (long,X) $E0110F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($20.b),Y		; 11 20 ; OR accumulator with memory ($20.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $8812.w		; CD 12 88 ; Compare $8812.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cpy #$3F.b		; C0 3F ; Compare #$3F.b with Y register [Reads: Y Index] [Flags: NCZ]
	lda $04EF6F.l,X		; BF 6F EF 04 ; Load long $04EF6F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr $CD98.w,X		; 5E 98 CD ; Logical shift right $CD98.w,X [Reads: X Index] [Flags: NCZ]
	cop $32.b		; 02 32 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $12F1.w,X		; FE F1 12 ; Increment memory $12F1.w,X [Reads: X Index] [Flags: NZ]
	ora $88E1.w		; 0D E1 88 ; Logical OR $88E1.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $2510.w		; 20 10 25 ; Jump to subroutine at $2510.w [Writes: Stack Pointer] [Flow: call]
	wai		; CB ; Wait for interrupt
	and ($E3.b,S),Y		; 33 E3 ; AND accumulator (stack relative indirect indexed) ($E3.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $88F0.w		; 2D F0 88 ; Logical AND $88F0.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc ($41.b),Y		; F1 41 ; Subtract with carry ($41.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$EC.b		; E0 EC ; Compare #$EC.b with X register [Reads: X Index] [Flags: NCZ]
	and $31.b,X		; 35 31 ; Logical AND $31.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	lsr $84.b		; 46 84 ; Logical shift right $84.b [Reads: Direct Page] [Flags: NCZ]
	asl $1023.w		; 0E 23 10 ; Arithmetic shift left $1023.w [Flags: NCZ]
	dec $EE42.w		; CE 42 EE ; Decrement $EE42.w [Flags: NZ]
	ora $1198EE.l		; 0F EE 98 11 ; OR accumulator with memory (long) $1198EE.l [Writes: Accumulator] [Flags: NZ]
	cop $1B.b		; 02 1B ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $51.b,S		; C3 51 ; Compare accumulator (stack relative) $51.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	cmp $0F12.w,X		; DD 12 0F ; Compare accumulator $0F12.w,X [Reads: X Index] [Flags: NCZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sbc ($1F.b,S),Y		; F3 1F ; Subtract with carry (stack relative indirect indexed) ($1F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	dec $2F14.w,X		; DE 14 2F ; Decrement memory $2F14.w,X [Reads: X Index] [Flags: NZ]
	lda $F252.w,X		; BD 52 F2 ; Load $F252.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	dec $5AF5.w		; CE F5 5A ; Decrement $5AF5.w [Flags: NZ]
	cpx $E1.b		; E4 E1 ; Compare $E1.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	jsr $74CF.w		; 20 CF 74 ; Jump to subroutine at $74CF.w [Writes: Stack Pointer] [Flow: call]
	.db $D0, $53		; D0 53 ; Branch if not equal to $D0, $53 [Flow: branch]
	cop $CB.b		; 02 CB ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($F1.b),Y		; 31 F1 ; AND accumulator with memory ($F1.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor ($EE.b,X)		; 41 EE ; Exclusive OR accumulator with memory ($EE.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	and $0E.b,S		; 23 0E ; AND accumulator with stack relative $0E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $0E2212.l,X		; FF 12 22 0E ; Subtract with carry (long,X) $0E2212.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $84.b		; 04 84 ; Test and set bits $84.b [Reads: Accumulator] [Flags: Z]
	rol $F1D0.w,X		; 3E D0 F1 ; Rotate left $F1D0.w,X [Reads: X Index] [Flags: NCZ]
	tsb $2DD4.w		; 0C D4 2D ; Test and set bits $2DD4.w [Reads: Accumulator] [Flags: Z]
	sbc ($41.b,X)		; E1 41 ; Subtract with carry ($41.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sty $DD.b		; 84 DD ; Store Y register to $DD.b [Reads: Y Index]
	sbc ($40.b)		; F2 40 ; Subtract with carry (indirect) ($40.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ldx $0D21.w,Y		; BE 21 0D ; Load X register $0D21.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	cmp $3C7801.l		; CF 01 78 3C ; Compare accumulator (long) $3C7801.l [Reads: Accumulator] [Flags: NCZ]
	ldy $53F2.w,X		; BC F2 53 ; Load Y register $53F2.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ora $CBF0.w		; 0D F0 CB ; Logical OR $CBF0.w with accumulator [Writes: Accumulator] [Flags: NZ]
	rol $94.b		; 26 94 ; Rotate left $94.b [Reads: Direct Page] [Flags: NCZ]
	.db $F0, $1F		; F0 1F ; Branch if equal to $F0, $1F [Flow: branch]
	sbc $1E02.w		; ED 02 1E ; Subtract $1E02.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cmp $88FD44.l,X		; DF 44 FD 88 ; Compare accumulator (long,X) $88FD44.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	adc ($F1.b,X)		; 61 F1 ; Add with carry ($F1.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $B0, $61		; B0 61 ; Branch if carry set to $B0, $61 [Flow: branch]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cmp ($62.b),Y		; D1 62 ; Compare accumulator ($62.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cpy $3188.w		; CC 88 31 ; Compare $3188.w with Y register [Reads: Y Index] [Flags: NCZ]
	sbc $FEEE53.l		; EF 53 EE FE ; Subtract with carry (long) $FEEE53.l [Writes: Accumulator] [Flags: NCVZ]
	cmp ($50.b,S),Y		; D3 50 ; Compare accumulator (stack relative indirect indexed) ($50.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	cpx #$88.b		; E0 88 ; Compare #$88.b with X register [Reads: X Index] [Flags: NCZ]
	sbc ($3F.b,X)		; E1 3F ; Subtract with carry ($3F.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $F1.b		; 00 F1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $5ED52F.l,X		; 1F 2F D5 5E ; Logical OR long $5ED52F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cmp $1230D3.l,X		; DF D3 30 12 ; Compare accumulator (long,X) $1230D3.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	trb $1DE3.w		; 1C E3 1D ; Test and reset bits $1DE3.w [Reads: Accumulator] [Flags: Z]
	trb $74.b		; 14 74 ; Test and reset bits $74.b [Reads: Accumulator] [Flags: Z]
	nop		; EA ; No operation
	asl $32.b,X		; 16 32 ; Arithmetic shift left $32.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $47D0.w,X		; 1D D0 47 ; OR accumulator with memory $47D0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $41.b		; 65 41 ; Add $41.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sbc ($4E.b,X)		; E1 4E ; Subtract with carry ($4E.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
.ACCU 16
	rep #$2F		; C2 2F
	ora ($01.b),Y		; 11 01 ; OR accumulator with memory ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $88F2.w,X		; 1E F2 88 ; Arithmetic shift left $88F2.w,X [Reads: X Index] [Flags: NCZ]
	and $10D0.w,X		; 3D D0 10 ; AND accumulator with memory $10D0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($DC.b,S),Y		; 33 DC ; AND accumulator (stack relative indirect indexed) ($DC.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $10, $21		; 10 21 ; Branch if plus to $10, $21 [Flow: branch]
	lda $101484.l,X		; BF 84 14 10 ; Load long $101484.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($20.b)		; F2 20 ; Subtract with carry (indirect) ($20.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($DB.b),Y		; 11 DB ; OR accumulator with memory ($DB.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $BE8832.l,X		; DF 32 88 BE ; Compare accumulator (long,X) $BE8832.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	ora ($32.b)		; 12 32 ; OR accumulator with memory (indirect) ($32.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $42B2.w,Y		; F9 B2 42 ; Subtract with carry $42B2.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $88ED.w		; 2E ED 88 ; Rotate left $88ED.w [Flags: NCZ]
	sbc ($31.b),Y		; F1 31 ; Subtract with carry ($31.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy $4C04.w		; CC 04 4C ; Compare $4C04.w with Y register [Reads: Y Index] [Flags: NCZ]
	cmp ($20.b,X)		; C1 20 ; Compare accumulator ($20.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	ora $2D1384.l		; 0F 84 13 2D ; OR accumulator with memory (long) $2D1384.l [Writes: Accumulator] [Flags: NZ]
	cpy #$0C.b		; C0 0C ; Compare #$0C.b with Y register [Reads: Y Index] [Flags: NCZ]
	cmp ($31.b)		; D2 31 ; Compare accumulator (indirect) ($31.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cop $3F.b		; 02 3F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sbc ($11.b,X)		; E1 11 ; Subtract with carry ($11.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($DD.b,S),Y		; 13 DD ; OR accumulator (stack relative indirect indexed) ($DD.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $30, $D2		; 30 D2 ; Branch if minus to $30, $D2 [Flow: branch]
	lsr $88AE.w		; 4E AE 88 ; Logical shift right $88AE.w [Flags: NCZ]
	sbc ($60.b,S),Y		; F3 60 ; Subtract with carry (stack relative indirect indexed) ($60.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	lda $DD33.w		; AD 33 DD ; Load $DD33.w into accumulator [Writes: Accumulator] [Flags: NZ]
	lsr $EC.b		; 46 EC ; Logical shift right $EC.b [Reads: Direct Page] [Flags: NCZ]
	cmp ($84.b)		; D2 84 ; Compare accumulator (indirect) ($84.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	and $252FC1.l,X		; 3F C1 2F 25 ; AND accumulator with memory (long,X) $252FC1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $61F30F.l		; 2F 0F F3 61 ; AND accumulator with memory (long) $61F30F.l [Writes: Accumulator] [Flags: NZ]
	stz $A2.b,X		; 74 A2 ; Store zero to $A2.b,X [Reads: X Index]
	.db $50, $03		; 50 03 ; Branch if overflow clear to $50, $03 [Flow: branch]
	bit $3F.b,X		; 34 3F ; Test bits $3F.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	stz $25.b,X		; 74 25 ; Store zero to $25.b,X [Reads: X Index]
	eor ($1C.b,S),Y		; 53 1C ; XOR accumulator (stack relative indirect indexed) ($1C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $30922A.l,X		; 9F 2A 92 30 ; Store accumulator (long,X) $30922A.l,X [Reads: Accumulator, X Index]
	cmp $DC4274.l,X		; DF 74 42 DC ; Compare accumulator (long,X) $DC4274.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	ora ($2F.b,S),Y		; 13 2F ; OR accumulator (stack relative indirect indexed) ($2F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $E5EDFC.l		; EF FC ED E5 ; Subtract with carry (long) $E5EDFC.l [Writes: Accumulator] [Flags: NCVZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ora $F4DF.w,X		; 1D DF F4 ; OR accumulator with memory $F4DF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $21E1ED.l		; 4F ED E1 21 ; Exclusive OR accumulator with memory (long) $21E1ED.l [Writes: Accumulator] [Flags: NZ]
	asl $EE84.w,X		; 1E 84 EE ; Arithmetic shift left $EE84.w,X [Reads: X Index] [Flags: NCZ]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($FE.b)		; 12 FE ; OR accumulator with memory (indirect) ($FE.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $0B.b		; 45 0B ; Exclusive OR $0B.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $2088.w,X		; BD 88 20 ; Load $2088.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $10		; F0 10 ; Branch if equal to $F0, $10 [Flow: branch]
	and $F211CE.l,X		; 3F CE 11 F2 ; AND accumulator with memory (long,X) $F211CE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	bit $E278.w,X		; 3C 78 E2 ; Test bits $E278.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	ora $1F3DE2.l,X		; 1F E2 3D 1F ; Logical OR long $1F3DE2.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $84D271.l,X		; 9F 71 D2 84 ; Store accumulator (long,X) $84D271.l,X [Reads: Accumulator, X Index]
	bit $20.b,X		; 34 20 ; Test bits $20.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	asl $E5CB.w		; 0E CB E5 ; Arithmetic shift left $E5CB.w [Flags: NCZ]
	eor $21C0.w,X		; 5D C0 21 ; Exclusive OR accumulator with memory $21C0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sep #$0D		; E2 0D ; Set processor status bits #$0D [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	cmp ($2F.b,X)		; C1 2F ; Compare accumulator ($2F.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	sbc ($25.b),Y		; F1 25 ; Subtract with carry ($25.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $842F.w		; 0D 2F 84 ; Logical OR $842F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $1B		; F0 1B ; Branch if equal to $F0, $1B [Flow: branch]
	lda ($55.b,X)		; A1 55 ; Load accumulator ($55.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	bit $2FC1.w,X		; 3C C1 2F ; Test bits $2FC1.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	cpx #$84.b		; E0 84 ; Compare #$84.b with X register [Reads: X Index] [Flags: NCZ]
	and $0C.b,S		; 23 0C ; AND accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sep #$43		; E2 43 ; Set processor status bits #$43 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	ora $31C1EC.l,X		; 1F EC C1 31 ; Logical OR long $31C1EC.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $70, $33		; 70 33 ; Branch if overflow set to $70, $33 [Flow: branch]
	ora $1CD0.w		; 0D D0 1C ; Logical OR $1CD0.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cpy #$FD.b		; C0 FD ; Compare #$FD.b with Y register [Reads: Y Index] [Flags: NCZ]
	inc $8803.w		; EE 03 88 ; Increment $8803.w [Flags: NZ]
	dec $5E12.w,X		; DE 12 5E ; Decrement memory $5E12.w,X [Reads: X Index] [Flags: NZ]
	cpy #$3E.b		; C0 3E ; Compare #$3E.b with Y register [Reads: Y Index] [Flags: NCZ]
	cpy $2C.b		; C4 2C ; Compare $2C.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	pea $2D84.w		; F4 84 2D ; Push absolute address $2D84.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	cmp ($66.b,X)		; C1 66 ; Compare accumulator ($66.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	cmp $3006.w,Y		; D9 06 30 ; Compare accumulator $3006.w,Y [Reads: Y Index] [Flags: NCZ]
	sbc $BD7410.l,X		; FF 10 74 BD ; Subtract with carry (long,X) $BD7410.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and [$0A.b],Y		; 37 0A ; AND accumulator with memory (long indexed) [$0A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $5C.b		; E5 5C ; Subtract $5C.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda $78E254.l		; AF 54 E2 78 ; Load long $78E254.l into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $30, $AA		; 30 AA ; Branch if minus to $30, $AA [Flow: branch]
	adc $ED.b		; 65 ED ; Add $ED.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	pea $071A.w		; F4 1A 07 ; Push absolute address $071A.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cmp ($40.b),Y		; D1 40 ; Compare accumulator ($40.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	lda ($5D.b,S),Y		; B3 5D ; Load accumulator (stack relative indirect indexed) ($5D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp ($FD.b),Y		; D1 FD ; Compare accumulator ($FD.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	and $FC.b,X		; 35 FC ; Logical AND $FC.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	stz $04.b,X		; 74 04 ; Store zero to $04.b,X [Reads: X Index]
	jsr ($13FF.w,X)		; FC FF 13 ; Jump to subroutine indirect indexed ($13FF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $E947.w,X		; FD 47 E9 ; Subtract with carry $E947.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($84.b,X)		; E1 84 ; Subtract with carry ($84.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $0F32F1.l		; 0F F1 32 0F ; OR accumulator with memory (long) $0F32F1.l [Writes: Accumulator] [Flags: NZ]
	dec $FC34.w,X		; DE 34 FC ; Decrement memory $FC34.w,X [Reads: X Index] [Flags: NZ]
	.db $F0, $88		; F0 88 ; Branch if equal to $F0, $88 [Flow: branch]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $FE15.w,X		; DD 15 FE ; Compare accumulator $FE15.w,X [Reads: X Index] [Flags: NCZ]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sep #$88		; E2 88 ; Set processor status bits #$88 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	rol $05FE.w		; 2E FE 05 ; Rotate left $05FE.w [Flags: NCZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda ($31.b),Y		; B1 31 ; Load accumulator ($31.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $8813.w		; ED 13 88 ; Subtract $8813.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cpx $0012.w		; EC 12 00 ; Compare $0012.w with X register [Reads: X Index] [Flags: NCZ]
	ora $1020D0.l,X		; 1F D0 20 10 ; Logical OR long $1020D0.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $CC80.w		; EE 80 CC ; Increment $CC80.w [Flags: NZ]
	tsb $31.b		; 04 31 ; Test and set bits $31.b [Reads: Accumulator] [Flags: Z]
	.db $10, $F0		; 10 F0 ; Branch if plus to $10, $F0 [Flow: branch]
	asl $20F2.w		; 0E F2 20 ; Arithmetic shift left $20F2.w [Flags: NCZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	lda ($4F.b,S),Y		; B3 4F ; Load accumulator (stack relative indirect indexed) ($4F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $41F3.w		; ED F3 41 ; Subtract $41F3.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sbc $78F1.w		; ED F1 78 ; Subtract $78F1.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	eor ($F0.b,X)		; 41 F0 ; Exclusive OR accumulator with memory ($F0.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ldx $1F12.w		; AE 12 1F ; Load $1F12.w into X register [Writes: X Index] [Flags: NZ]
	and $EB.b		; 25 EB ; Logical AND $EB.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	and $DF.b,S		; 23 DF ; AND accumulator with stack relative $DF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $4F.b		; 02 4F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $133E14.l		; CF 14 3E 13 ; Compare accumulator (long) $133E14.l [Reads: Accumulator] [Flags: NCZ]
	sty $0E.b		; 84 0E ; Store Y register to $0E.b [Reads: Y Index]
	sbc ($ED.b),Y		; F1 ED ; Subtract with carry ($ED.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	trb $31.b		; 14 31 ; Test and reset bits $31.b [Reads: Accumulator] [Flags: Z]
	dec $ED34.w		; CE 34 ED ; Decrement $ED34.w [Flags: NZ]
	sty $F0.b		; 84 F0 ; Store Y register to $F0.b [Reads: Y Index]
	and ($FE.b,S),Y		; 33 FE ; AND accumulator (stack relative indirect indexed) ($FE.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $ED.b		; 00 ED ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $41.b		; 04 41 ; Test and set bits $41.b [Reads: Accumulator] [Flags: Z]
	sbc $F488.w,X		; FD 88 F4 ; Subtract with carry $F488.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $2EB21E.l,X		; 3F 1E B2 2E ; AND accumulator with memory (long,X) $2EB21E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $741EFE.l		; 22 FE 1E 74 ; Jump to subroutine long $741EFE.l [Writes: Stack Pointer] [Flow: call]
	cmp $02CB32.l		; CF 32 CB 02 ; Compare accumulator (long) $02CB32.l [Reads: Accumulator] [Flags: NCZ]
	.db $10, $CF		; 10 CF ; Branch if plus to $10, $CF [Flow: branch]
	.db $30, $DA		; 30 DA ; Branch if minus to $30, $DA [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sep #$40		; E2 40 ; Set processor status bits #$40 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	sbc ($2C.b,X)		; E1 2C ; Subtract with carry ($2C.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp ($1F.b),Y		; D1 1F ; Compare accumulator ($1F.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	sbc ($3F.b),Y		; F1 3F ; Subtract with carry ($3F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	stz $FB.b,X		; 74 FB ; Store zero to $FB.b,X [Reads: X Index]
	dec $34E1.w		; CE E1 34 ; Decrement $34E1.w [Flags: NZ]
	and $E31C04.l,X		; 3F 04 1C E3 ; AND accumulator with memory (long,X) $E31C04.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jsr ($2CE2.w,X)		; FC E2 2C ; Jump to subroutine indirect indexed ($2CE2.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	pea $FE5F.w		; F4 5F FE ; Push absolute address $FE5F.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
.ACCU 8
	sep #$EE		; E2 EE
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cop $2E.b		; 02 2E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($12.b),Y		; F1 12 ; Subtract with carry ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $2790.w		; 2C 90 27 ; Test bits $2790.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	eor $229D78.l,X		; 5F 78 9D 22 ; Exclusive OR accumulator with memory (long,X) $229D78.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $CB.b,S		; 43 CB ; Exclusive OR accumulator with stack relative $CB.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $33		; D0 33 ; Branch if not equal to $D0, $33 [Flow: branch]
	and ($CD.b),Y		; 31 CD ; AND accumulator with memory ($CD.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	stz $12.b,X		; 74 12 ; Store zero to $12.b,X [Reads: X Index]
	jsl $C05E26.l		; 22 26 5E C0 ; Jump to subroutine long $C05E26.l [Writes: Stack Pointer] [Flow: call]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	wai		; CB ; Wait for interrupt
	cmp $FE2374.l,X		; DF 74 23 FE ; Compare accumulator (long,X) $FE2374.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	eor $13.b,S		; 43 13 ; Exclusive OR accumulator with stack relative $13.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor ($F2.b,X)		; 41 F2 ; Exclusive OR accumulator with memory ($F2.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($6E.b)		; 12 6E ; OR accumulator with memory (indirect) ($6E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cpy $3E.b		; C4 3E ; Compare $3E.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	cpx #$32.b		; E0 32 ; Compare #$32.b with X register [Reads: X Index] [Flags: NCZ]
	dec $0E32.w,X		; DE 32 0E ; Decrement memory $0E32.w,X [Reads: X Index] [Flags: NZ]
	.db $D0, $84		; D0 84 ; Branch if not equal to $D0, $84 [Flow: branch]
	ora ($0D.b,X)		; 01 0D ; Logical OR ($0D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $51.b,S		; E3 51 ; Subtract stack-relative $51.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	cpy $0E12.w		; CC 12 0E ; Compare $0E12.w with Y register [Reads: Y Index] [Flags: NCZ]
	dec $CA74.w,X		; DE 74 CA ; Decrement memory $CA74.w,X [Reads: X Index] [Flags: NZ]
	ora $35.b		; 05 35 ; Logical OR $35.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $EE1FC0.l,X		; 5F C0 1F EE ; Exclusive OR accumulator with memory (long,X) $EE1FC0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($74.b),Y		; 11 74 ; OR accumulator with memory ($74.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$C5.b		; C9 C5 ; Compare #$C5.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	adc $11B0.w		; 6D B0 11 ; Add $11B0.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	ora ($3E.b,X)		; 01 3E ; Logical OR ($3E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda ($84.b,X)		; A1 84 ; Load accumulator ($84.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($CD.b,X)		; 41 CD ; Exclusive OR accumulator with memory ($CD.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	bit $20.b		; 24 20 ; Test bits $20.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	inc $31E1.w,X		; FE E1 31 ; Increment memory $31E1.w,X [Reads: X Index] [Flags: NZ]
	sbc $3F1178.l,X		; FF 78 11 3F ; Subtract with carry (long,X) $3F1178.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($33.b)		; F2 33 ; Subtract with carry (indirect) ($33.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	eor $78.b,X		; 55 78 ; Exclusive OR accumulator with memory $78.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$2DE2]		; DC E2 2D ; Jump long indirect [$2DE2] [Flow: jump]
	ora ($F1.b)		; 12 F1 ; OR accumulator with memory (indirect) ($F1.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $51B3.w,X		; 3D B3 51 ; AND accumulator with memory $51B3.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	stz $2C.b,X		; 74 2C ; Store zero to $2C.b,X [Reads: X Index]
	cpy #$FE.b		; C0 FE ; Compare #$FE.b with Y register [Reads: Y Index] [Flags: NCZ]
	bit $54.b		; 24 54 ; Test bits $54.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	jsr ($F1EF.w,X)		; FC EF F1 ; Jump to subroutine indirect indexed ($F1EF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	and $04D0.w,X		; 3D D0 04 ; AND accumulator with memory $04D0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $B32D.w		; 0E 2D B3 ; Arithmetic shift left $B32D.w [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpx #$88.b		; E0 88 ; Compare #$88.b with X register [Reads: X Index] [Flags: NCZ]
	cpx #$F1.b		; E0 F1 ; Compare #$F1.b with X register [Reads: X Index] [Flags: NCZ]
	and ($EF.b),Y		; 31 EF ; AND accumulator with memory ($EF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $1E		; F0 1E ; Branch if equal to $F0, $1E [Flow: branch]
	sbc ($1E.b,S),Y		; F3 1E ; Subtract with carry (stack relative indirect indexed) ($1E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sbc $F2EC42.l		; EF 42 EC F2 ; Subtract with carry (long) $F2EC42.l [Writes: Accumulator] [Flags: NCVZ]
	and $1E00F0.l,X		; 3F F0 00 1E ; AND accumulator with memory (long,X) $1E00F0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	stz $B2.b,X		; 74 B2 ; Store zero to $B2.b,X [Reads: X Index]
	lsr $339E.w,X		; 5E 9E 33 ; Logical shift right $339E.w,X [Reads: X Index] [Flags: NCZ]
	cpx $DD01.w		; EC 01 DD ; Compare $DD01.w with X register [Reads: X Index] [Flags: NCZ]
	rol $74.b		; 26 74 ; Rotate left $74.b [Reads: Direct Page] [Flags: NCZ]
	eor $3D.b,X		; 55 3D ; Exclusive OR accumulator with memory $3D.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	stz $0D66.w,X		; 9E 66 0D ; Store zero to $0D66.w,X [Reads: X Index]
	inc $71C2.w,X		; FE C2 71 ; Increment memory $71C2.w,X [Reads: X Index] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	lda ($2E.b),Y		; B1 2E ; Load accumulator ($2E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $21.b		; E5 21 ; Subtract $21.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	rol $42A0.w		; 2E A0 42 ; Rotate left $42A0.w [Flags: NCZ]
	sbc ($78.b),Y		; F1 78 ; Subtract with carry ($78.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	cpx $30.b		; E4 30 ; Compare $30.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $2E33D0.l		; 0F D0 33 2E ; OR accumulator with memory (long) $2E33D0.l [Writes: Accumulator] [Flags: NZ]
	cmp $0488.w		; CD 88 04 ; Compare $0488.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	and $0011CF.l,X		; 3F CF 11 00 ; AND accumulator with memory (long,X) $0011CF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsr $2EFF.w		; 20 FF 2E ; Jump to subroutine at $2EFF.w [Writes: Stack Pointer] [Flow: call]
	stz $B2.b,X		; 74 B2 ; Store zero to $B2.b,X [Reads: X Index]
	lsr $2EC1.w		; 4E C1 2E ; Logical shift right $2EC1.w [Flags: NCZ]
	ldx $2322.w,Y		; BE 22 23 ; Load X register $2322.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	.db $10, $78		; 10 78 ; Branch if plus to $10, $78 [Flow: branch]
	sbc $CF43.w,X		; FD 43 CF ; Subtract with carry $CF43.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($DF.b),Y		; 51 DF ; Exclusive OR accumulator with memory ($DF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda $1252.w,X		; BD 52 12 ; Load $1252.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	inc $42D2.w,X		; FE D2 42 ; Increment memory $42D2.w,X [Reads: X Index] [Flags: NZ]
	sbc $33EF.w		; ED EF 33 ; Subtract $33EF.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sbc $7400.w		; ED 00 74 ; Subtract $7400.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ora $0C24DD.l		; 0F DD 24 0C ; OR accumulator with memory (long) $0C24DD.l [Writes: Accumulator] [Flags: NZ]
	lda $32DF.w,X		; BD DF 32 ; Load $32DF.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($74.b,X)		; 21 74 ; Logical AND ($74.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $E03101.l,X		; FF 01 31 E0 ; Subtract with carry (long,X) $E03101.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $60F5FA.l		; 22 FA F5 60 ; Jump to subroutine long $60F5FA.l [Writes: Stack Pointer] [Flow: call]
	stz $CC.b,X		; 74 CC ; Store zero to $CC.b,X [Reads: X Index]
	cmp $021133.l		; CF 33 11 02 ; Compare accumulator (long) $021133.l [Reads: Accumulator] [Flags: NCZ]
	and $34D1.w,X		; 3D D1 34 ; AND accumulator with memory $34D1.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cpx $41F5.w		; EC F5 41 ; Compare $41F5.w with X register [Reads: X Index] [Flags: NCZ]
	sbc $AF21.w		; ED 21 AF ; Subtract $AF21.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	and $2E.b,X		; 35 2E ; Logical AND $2E.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	inc $20E4.w		; EE E4 20 ; Increment $20E4.w [Flags: NZ]
	.db $42, $BD		; 42 BD ; Reserved instruction
	cop $20.b		; 02 20 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($78.b,X)		; C1 78 ; Compare accumulator ($78.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	eor ($EB.b),Y		; 51 EB ; Exclusive OR accumulator with memory ($EB.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($22.b)		; F2 22 ; Subtract with carry (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and $3EE3.w		; 2D E3 3E ; Logical AND $3EE3.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp ($84.b)		; D2 84 ; Compare accumulator (indirect) ($84.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora ($21.b,X)		; 01 21 ; Logical OR ($21.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jmp.w [$1013]		; DC 13 10 ; Jump long indirect [$1013] [Flow: jump]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $1678.w,X		; FE 78 16 ; Increment memory $1678.w,X [Reads: X Index] [Flags: NZ]
	ora $1A02.w,X		; 1D 02 1A ; OR accumulator with memory $1A02.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldx #$6F.b		; A2 6F ; Load #$6F.b into X register [Writes: X Index] [Flags: NZ]
	cmp ($22.b),Y		; D1 22 ; Compare accumulator ($22.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda ($2D.b)		; B2 2D ; Load accumulator (indirect) ($2D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpy $DD34.w		; CC 34 DD ; Compare $DD34.w with Y register [Reads: Y Index] [Flags: NCZ]
	stz $D1.b,X		; 74 D1 ; Store zero to $D1.b,X [Reads: X Index]
	lsr $5E.b,X		; 56 5E ; Logical shift right $5E.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	lda $DB0000.l,X		; BF 00 00 DB ; Load long $DB0000.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($74.b),Y		; F1 74 ; Subtract with carry ($74.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FC4411.l,X		; FF 11 44 FC ; Subtract with carry (long,X) $FC4411.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $2D0352.l		; CF 52 03 2D ; Compare accumulator (long) $2D0352.l [Reads: Accumulator] [Flags: NCZ]
	stz $E1.b,X		; 74 E1 ; Store zero to $E1.b,X [Reads: X Index]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	and $42.b		; 25 42 ; Logical AND $42.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $36DE.w		; 0E DE 36 ; Arithmetic shift left $36DE.w [Flags: NCZ]
	eor $E1DD74.l,X		; 5F 74 DD E1 ; Exclusive OR accumulator with memory (long,X) $E1DD74.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $04		; 30 04 ; Branch if minus to $30, $04 [Flow: branch]
	rol $42C2.w,X		; 3E C2 42 ; Rotate left $42C2.w,X [Reads: X Index] [Flags: NCZ]
	ora $0278.w		; 0D 78 02 ; Logical OR $0278.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $BD0D43.l,X		; FF 43 0D BD ; Subtract with carry (long,X) $BD0D43.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $01.b,X		; 75 01 ; Add $01.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	stz $B4.b		; [PATTERN: Memory clearing operation] 64 B4 ; Store zero to $B4.b
	eor $62.b,S		; 43 62 ; Exclusive OR accumulator with stack relative $62.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $5EC1.w		; AD C1 5E ; Load $5EC1.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cpy #$FF.b		; C0 FF ; Compare #$FF.b with Y register [Reads: Y Index] [Flags: NCZ]
	stz $00.b,X		; 74 00 ; Store zero to $00.b,X [Reads: X Index]
	.db $10, $E1		; 10 E1 ; Branch if plus to $10, $E1 [Flow: branch]
	adc $DB.b		; 65 DB ; Add $DB.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($1F.b,X)		; 01 1F ; Logical OR ($1F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $78.b,X		; 15 78 ; OR accumulator with memory $78.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $D12F.w,X		; DD 2F D1 ; Compare accumulator $D12F.w,X [Reads: X Index] [Flags: NCZ]
	and $34DD02.l,X		; 3F 02 DD 34 ; AND accumulator with memory (long,X) $34DD02.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $12DD78.l,X		; 1F 78 DD 12 ; Logical OR long $12DD78.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($2D.b),Y		; F1 2D ; Subtract with carry ($2D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	rep #$40		; C2 40 ; Reset processor status bits #$40 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	ldx $7422.w		; AE 22 74 ; Load $7422.w into X register [Writes: X Index] [Flags: NZ]
	ora ($0D.b)		; 12 0D ; OR accumulator with memory (indirect) ($0D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $55		; D0 55 ; Branch if not equal to $D0, $55 [Flow: branch]
	sbc $DDFE.w,X		; FD FE DD ; Subtract with carry $DDFE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $1E1278.l,X		; FF 78 12 1E ; Subtract with carry (long,X) $1E1278.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $0F12.w		; CD 12 0F ; Compare $0F12.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	sbc ($21.b,S),Y		; F3 21 ; Subtract with carry (stack relative indirect indexed) ($21.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	inc $D378.w		; EE 78 D3 ; Increment $D378.w [Flags: NZ]
	eor $D123BE.l		; 4F BE 23 D1 ; Exclusive OR accumulator with memory (long) $D123BE.l [Writes: Accumulator] [Flags: NZ]
	eor ($C0.b,X)		; 41 C0 ; Exclusive OR accumulator with memory ($C0.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($74.b,X)		; 01 74 ; Logical OR ($74.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	mvp $BB,$30		; 44 30 BB ; Move block positive $BB,$30 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	and $1F.b		; 25 1F ; Logical AND $1F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $1D.b		; 24 1D ; Test bits $1D.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sbc ($74.b),Y		; F1 74 ; Subtract with carry ($74.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $11		; F0 11 ; Branch if equal to $F0, $11 [Flow: branch]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $41B1.w		; 1C B1 41 ; Test and reset bits $41B1.w [Reads: Accumulator] [Flags: Z]
	inc $F074.w		; EE 74 F0 ; Increment $F074.w [Flags: NZ]
	ora ($F0.b),Y		; 11 F0 ; OR accumulator with memory ($F0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $0140D2.l		; 2F D2 40 01 ; AND accumulator with memory (long) $0140D2.l [Writes: Accumulator] [Flags: NZ]
	and ($74.b,X)		; 21 74 ; Logical AND ($74.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpx $22DF.w		; EC DF 22 ; Compare $22DF.w with X register [Reads: X Index] [Flags: NCZ]
	cop $3F.b		; 02 3F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $30F3.w,X		; [PATTERN: Memory clearing operation] DD F3 30 ; Compare accumulator $30F3.w,X [Reads: X Index] [Flags: NCZ]
	stz $FE.b,X		; 74 FE ; Store zero to $FE.b,X [Reads: X Index]
	cmp $4124DD.l,X		; DF DD 24 41 ; Compare accumulator (long,X) $4124DD.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	cpy $E1FE.w		; CC FE E1 ; Compare $E1FE.w with Y register [Reads: Y Index] [Flags: NCZ]
	stz $42.b,X		; 74 42 ; Store zero to $42.b,X [Reads: X Index]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	inc $0F02.w		; EE 02 0F ; Increment $0F02.w [Flags: NZ]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	cmp $CF5078.l,X		; DF 78 50 CF ; Compare accumulator (long,X) $CF5078.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	sbc ($1E.b),Y		; F1 1E ; Subtract with carry ($1E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $24		; F0 24 ; Branch if equal to $F0, $24 [Flow: branch]
	tsb $68E0.w		; 0C E0 68 ; Test and set bits $68E0.w [Reads: Accumulator] [Flags: Z]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sbc ($F0.b,X)		; E1 F0 ; Subtract with carry ($F0.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $11.b		; 02 11 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $74F30E.l,X		; 1F 0E F3 74 ; Logical OR long $74F30E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $E240BF.l		; 2F BF 40 E2 ; AND accumulator with memory (long) $E240BF.l [Writes: Accumulator] [Flags: NZ]
	ora $12EE21.l		; 0F 21 EE 12 ; OR accumulator with memory (long) $12EE21.l [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sbc $1113.w,X		; FD 13 11 ; Subtract with carry $1113.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	trb $21D1.w		; 1C D1 21 ; Test and reset bits $21D1.w [Reads: Accumulator] [Flags: Z]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	stz $F2.b,X		; 74 F2 ; Store zero to $F2.b,X [Reads: X Index]
	ora $3104.w		; 0D 04 31 ; Logical OR $3104.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $10, $EF		; 10 EF ; Branch if plus to $10, $EF [Flow: branch]
	cop $31.b		; 02 31 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $3D		; 70 3D ; Branch if overflow set to $70, $3D [Flow: branch]
	.db $D0, $22		; D0 22 ; Branch if not equal to $D0, $22 [Flow: branch]
	ora $E20F00.l		; 0F 00 0F E2 ; OR accumulator with memory (long) $E20F00.l [Writes: Accumulator] [Flags: NZ]
	eor $68.b,X		; 55 68 ; Exclusive OR accumulator with memory $68.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	rol $F0D1.w		; 2E D1 F0 ; Rotate left $F0D1.w [Flags: NCZ]
	jsr $4DF6.w		; 20 F6 4D ; Jump to subroutine at $4DF6.w [Writes: Stack Pointer] [Flow: call]
	lda $317414.l,X		; BF 14 74 31 ; Load long $317414.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $BD20.w		; EE 20 BD ; Increment $BD20.w [Flags: NZ]
	mvp $01,$FE		; 44 FE 01 ; Move block positive $01,$FE [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sbc $F274.w,X		; FD 74 F2 ; Subtract with carry $F274.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $21EFBD.l		; 4F BD EF 21 ; Exclusive OR accumulator with memory (long) $21EFBD.l [Writes: Accumulator] [Flags: NZ]
	cmp $33F1.w,X		; DD F1 33 ; Compare accumulator $33F1.w,X [Reads: X Index] [Flags: NCZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cpy #$0C.b		; C0 0C ; Compare #$0C.b with Y register [Reads: Y Index] [Flags: NCZ]
	cpx $2E.b		; E4 2E ; Compare $2E.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $21		; F0 21 ; Branch if equal to $F0, $21 [Flow: branch]
	stz $22.b,X		; 74 22 ; Store zero to $22.b,X [Reads: X Index]
	rol $24CE.w		; 2E CE 24 ; Rotate left $24CE.w [Flags: NCZ]
	sbc $1B35.w,X		; FD 35 1B ; Subtract with carry $1B35.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
.ACCU 16
	rep #$68		; C2 68
	eor #$CD13.w		; 49 13 CD ; Exclusive OR #$CD13.w with accumulator [Writes: Accumulator] [Flags: NZ]
	bit $2F.b,X		; 34 2F ; Test bits $2F.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cpy #$63.b		; C0 63 ; Compare #$63.b with Y register [Reads: Y Index] [Flags: NCZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	adc $4211.w,Y		; 79 11 42 ; Add $4211.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp ($0D.b),Y		; D1 0D ; Compare accumulator ($0D.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	and ($DD.b,S),Y		; 33 DD ; AND accumulator (stack relative indirect indexed) ($DD.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $6A.b		; 00 6A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp.w [$CFFF]		; DC FF CF ; Jump long indirect [$CFFF] [Flow: jump]
	and $23.b,S		; 23 23 ; AND accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $61D3.w,X		; 1E D3 61 ; Arithmetic shift left $61D3.w,X [Reads: X Index] [Flags: NCZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	cpx #$32.b		; E0 32 ; Compare #$32.b with X register [Reads: X Index] [Flags: NCZ]
	sbc $01CD0E.l,X		; FF 0E CD 01 ; Subtract with carry (long,X) $01CD0E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc $01EF.w		; ED EF 01 ; Subtract $01EF.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	.db $42, $EF		; 42 EF ; Reserved instruction
	bit $52.b,X		; 34 52 ; Test bits $52.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sbc $E06A.w,X		; FD 6A E0 ; Subtract with carry $E06A.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	lda $32DF3F.l		; AF 3F DF 32 ; Load long $32DF3F.l into accumulator [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	sbc $F00E13.l,X		; FF 13 0E F0 ; Subtract with carry (long,X) $F00E13.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($44.b)		; 12 44 ; OR accumulator with memory (indirect) ($44.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $6ADF.w,X		; 1D DF 6A ; OR accumulator with memory $6ADF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dec $0D14.w,X		; DE 14 0D ; Decrement memory $0D14.w,X [Reads: X Index] [Flags: NZ]
	sbc $1C.b,S		; E3 1C ; Subtract stack-relative $1C.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	stz $E51E.w,X		; 9E 1E E5 ; Store zero to $E51E.w,X [Reads: X Index]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	and ($0E.b)		; 32 0E ; AND accumulator with memory (indirect) ($0E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $4413.w		; EE 13 44 ; Increment $4413.w [Flags: NZ]
	and $7AFFCE.l,X		; 3F CE FF 7A ; AND accumulator with memory (long,X) $7AFFCE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	inc $F0F0.w		; EE F0 F0 ; Increment $F0F0.w [Flags: NZ]
	bit $7A.b		; 24 7A ; Test bits $7A.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora $12DF.w,X		; 1D DF 12 ; OR accumulator with memory $12DF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	bit $31.b,X		; 34 31 ; Test bits $31.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sbc $00E0.w		; ED E0 00 ; Subtract $00E0.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cpx $31C0.w		; EC C0 31 ; Compare $31C0.w with X register [Reads: X Index] [Flags: NCZ]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp $7AEB44.l		; CF 44 EB 7A ; Compare accumulator (long) $7AEB44.l [Reads: Accumulator] [Flags: NCZ]
	sbc $422313.l		; EF 13 23 42 ; Subtract with carry (long) $422313.l [Writes: Accumulator] [Flags: NCVZ]
	cpx $1FF1.w		; EC F1 1F ; Compare $1FF1.w with X register [Reads: X Index] [Flags: NCZ]
	sbc $B0DB6A.l,X		; FF 6A DB B0 ; Subtract with carry (long,X) $B0DB6A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $11.b,X		; 55 11 ; Exclusive OR accumulator with memory $11.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($2D.b,S),Y		; 13 2D ; OR accumulator (stack relative indirect indexed) ($2D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda #$7AAB.w		; A9 AB 7A ; Load #$7AAB.w into accumulator [Writes: Accumulator] [Flags: NZ]
	bit $33.b		; 24 33 ; Test bits $33.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	eor ($EC.b,S),Y		; 53 EC ; XOR accumulator (stack relative indirect indexed) ($EC.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	dec $2102.w,X		; DE 02 21 ; Decrement memory $2102.w,X [Reads: X Index] [Flags: NZ]
	bit $1E.b,X		; 34 1E ; Test bits $1E.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	jmp.w [$03BC]		; DC BC 03 ; Jump long indirect [$03BC] [Flow: jump]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	eor $54.b		; 45 54 ; Exclusive OR $54.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $11BE.w		; 1C BE 11 ; Test and reset bits $11BE.w [Reads: Accumulator] [Flags: Z]
	ora ($1E.b,X)		; 01 1E ; Logical OR ($1E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda $117A.w,X		; BD 7A 11 ; Load $117A.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($55.b,X)		; 01 55 ; Logical OR ($55.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $DBDF.w		; 0D DF DB ; Logical OR $DBDF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc ($33.b,X)		; E1 33 ; Subtract with carry ($33.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	eor $3E.b,X		; 55 3E ; Exclusive OR accumulator with memory $3E.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	dec $02F0.w		; CE F0 02 ; Decrement $02F0.w [Flags: NZ]
	asl $11BD.w,X		; 1E BD 11 ; Arithmetic shift left $11BD.w,X [Reads: X Index] [Flags: NCZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and $75.b,S		; 23 75 ; AND accumulator with stack relative $75.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	trb $FFBB.w		; 1C BB FF ; Test and reset bits $FFBB.w [Reads: Accumulator] [Flags: Z]
	sbc $66F4.w		; ED F4 66 ; Subtract $66F4.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	and ($0D.b)		; 32 0D ; AND accumulator with memory (indirect) ($0D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $CB1011.l,X		; DF 11 10 CB ; Compare accumulator (long,X) $CB1011.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	mvn $CE,$FC		; 54 FC CE ; Move block negative $CE,$FC [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora ($0F.b),Y		; 11 0F ; OR accumulator with memory ($0F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($F1.b),Y		; 11 F1 ; OR accumulator with memory ($F1.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $7A.b,S		; 43 7A ; Exclusive OR accumulator with stack relative $7A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $F1FF.w,X		; FE FF F1 ; Increment memory $F1FF.w,X [Reads: X Index] [Flags: NZ]
	jsr $EFCC.w		; 20 CC EF ; Jump to subroutine at $EFCC.w [Writes: Stack Pointer] [Flow: call]
	ora $74.b,X		; 15 74 ; OR accumulator with memory $74.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	jsr ($F1CC.w,X)		; FC CC F1 ; Jump to subroutine indirect indexed ($F1CC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr $0011.w		; 20 11 00 ; Jump to subroutine at $0011.w [Writes: Stack Pointer] [Flow: call]
	and $1E.b,S		; 23 1E ; AND accumulator with stack relative $1E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	dec $0F11.w,X		; DE 11 0F ; Decrement memory $0F11.w,X [Reads: X Index] [Flags: NZ]
	inc $15DD.w,X		; FE DD 15 ; Increment memory $15DD.w,X [Reads: X Index] [Flags: NZ]
	adc $1D.b		; 65 1D ; Add $1D.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	ldy $00F1.w,X		; BC F1 00 ; Load Y register $00F1.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ora ($F0.b)		; 12 F0 ; OR accumulator with memory (indirect) ($F0.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $1E.b,X		; 35 1E ; Logical AND $1E.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $E17A.w		; CD 7A E1 ; Compare $E17A.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora $04FD0F.l		; 0F 0F FD 04 ; OR accumulator with memory (long) $04FD0F.l [Writes: Accumulator] [Flags: NZ]
	adc ($1F.b,S),Y		; 73 1F ; Add with carry (stack relative indirect indexed) ($1F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	jmp.w [$F17A]		; DC 7A F1 ; Jump long indirect [$F17A] [Flow: jump]
	ora $35FF10.l		; 0F 10 FF 35 ; OR accumulator with memory (long) $35FF10.l [Writes: Accumulator] [Flags: NZ]
	eor $7ADDEC.l		; 4F EC DD 7A ; Exclusive OR accumulator with memory (long) $7ADDEC.l [Writes: Accumulator] [Flags: NZ]
	sbc $06FC22.l		; EF 22 FC 06 ; Subtract with carry (long) $06FC22.l [Writes: Accumulator] [Flags: NCVZ]
	eor ($01.b),Y		; 51 01 ; Exclusive OR accumulator with memory ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $7A02.w		; ED 02 7A ; Subtract $7A02.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$24.b		; C0 24 ; Compare #$24.b with Y register [Reads: Y Index] [Flags: NCZ]
	and ($0E.b,S),Y		; 33 0E ; AND accumulator (stack relative indirect indexed) ($0E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpy $7ACD.w		; CC CD 7A ; Compare $7ACD.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora ($1E.b)		; 12 1E ; OR accumulator with memory (indirect) ($1E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $41.b		; 14 41 ; Test and reset bits $41.b [Reads: Accumulator] [Flags: Z]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	ora $10DF.w		; 0D DF 10 ; Logical OR $10DF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $2F.b		; 25 2F ; Logical AND $2F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $F1BB.w		; EE BB F1 ; Increment $F1BB.w [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($F1.b,X)		; 21 F1 ; Logical AND ($F1.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($F0.b)		; 12 F0 ; OR accumulator with memory (indirect) ($F0.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($ED.b),Y		; 11 ED ; OR accumulator with memory ($ED.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	cpx #$0F.b		; E0 0F ; Compare #$0F.b with X register [Reads: X Index] [Flags: NCZ]
	trb $31.b		; 14 31 ; Test and reset bits $31.b [Reads: Accumulator] [Flags: Z]
	inc $E0CB.w,X		; FE CB E0 ; Increment memory $E0CB.w,X [Reads: X Index] [Flags: NZ]
	ora $1E347A.l		; 0F 7A 34 1E ; OR accumulator with memory (long) $1E347A.l [Writes: Accumulator] [Flags: NZ]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $E1ECF0.l,X		; 3F F0 EC E1 ; AND accumulator with memory (long,X) $E1ECF0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $E0CC0E.l		; 22 0E CC E0 ; Jump to subroutine long $E0CC0E.l [Writes: Stack Pointer] [Flow: call]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	ora $4126E0.l		; 0F E0 26 41 ; OR accumulator with memory (long) $4126E0.l [Writes: Accumulator] [Flags: NZ]
	.db $F0, $DB		; F0 DB ; Branch if equal to $F0, $DB [Flow: branch]
	.db $D0, $10		; D0 10 ; Branch if not equal to $D0, $10 [Flow: branch]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	ora ($32.b,S),Y		; 13 32 ; OR accumulator (stack relative indirect indexed) ($32.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $EDCE.w		; 0D CE ED ; Logical OR $EDCE.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $31.b,S		; 03 31 ; OR accumulator with stack relative $31.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $DE7A.w,X		; FE 7A DE ; Increment memory $DE7A.w,X [Reads: X Index] [Flags: NZ]
	and [$62.b]		; 27 62 ; AND accumulator with memory (long) [$62.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $DB		; 10 DB ; Branch if plus to $10, $DB [Flow: branch]
	cmp $7A1200.l		; CF 00 12 7A ; Compare accumulator (long) $7A1200.l [Reads: Accumulator] [Flags: NCZ]
	mvp $BE,$1C		; 44 1C BE ; Move block positive $BE,$1C [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	inc $42F3.w		; EE F3 42 ; Increment $42F3.w [Flags: NZ]
	sbc $7ADE.w		; ED DE 7A ; Subtract $7ADE.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ora $65.b		; 05 65 ; Logical OR $65.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($CC.b),Y		; 31 CC ; AND accumulator with memory ($CC.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	dec $10E1.w		; CE E1 10 ; Decrement $10E1.w [Flags: NZ]
	rol $7A.b,X		; 36 7A ; Rotate left $7A.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	and $DBDF.w		; 2D DF DB ; Logical AND $DBDF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc ($41.b,S),Y		; F3 41 ; Subtract with carry (stack relative indirect indexed) ($41.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc $04DE.w,X		; FD DE 04 ; Subtract with carry $04DE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	eor $41.b,X		; 55 41 ; Exclusive OR accumulator with memory $41.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cpx $F0CD.w		; EC CD F0 ; Compare $F0CD.w with X register [Reads: X Index] [Flags: NCZ]
	brk $35.b		; 00 35 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $D07A.w,X		; 3E 7A D0 ; Rotate left $D07A.w,X [Reads: X Index] [Flags: NCZ]
	jsr ($41D1.w,X)		; FC D1 41 ; Jump to subroutine indirect indexed ($41D1.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jmp.w [$13E0]		; DC E0 13 ; Jump long indirect [$13E0] [Flow: jump]
	eor $7A.b		; 45 7A ; Exclusive OR $7A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor ($CD.b),Y		; 51 CD ; Exclusive OR accumulator with memory ($CD.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsr ($2FC1.w,X)		; FC C1 2F ; Jump to subroutine indirect indexed ($2FC1.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora $4F.b,X		; 15 4F ; OR accumulator with memory $4F.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$7A.b		; E0 7A ; Compare #$7A.b with X register [Reads: X Index] [Flags: NCZ]
	ora $30D0.w		; 0D D0 30 ; Logical OR $30D0.w with accumulator [Writes: Accumulator] [Flags: NZ]
	wai		; CB ; Wait for interrupt
	cpx #$14.b		; E0 14 ; Compare #$14.b with X register [Reads: X Index] [Flags: NCZ]
	eor $52.b		; 45 52 ; Exclusive OR $52.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	sbc $C0EB.w		; ED EB C0 ; Subtract $C0EB.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	jsr $3114.w		; 20 14 31 ; Jump to subroutine at $3114.w [Writes: Stack Pointer] [Flow: call]
	sbc $E07AFF.l,X		; FF FF 7A E0 ; Subtract with carry (long,X) $E07AFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr $CFCA.w		; 20 CA CF ; Jump to subroutine at $CFCA.w [Writes: Stack Pointer] [Flow: call]
	bit $44.b,X		; 34 44 ; Test bits $44.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	mvn $7A,$FC		; 54 FC 7A ; Move block negative $7A,$FC [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	inc $12BC.w		; EE BC 12 ; Increment $12BC.w [Flags: NZ]
	and ($20.b,S),Y		; 33 20 ; AND accumulator (stack relative indirect indexed) ($20.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $10, $EE		; 10 EE ; Branch if plus to $10, $EE [Flow: branch]
	ora ($7A.b,X)		; 01 7A ; Logical OR ($7A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $10, $D9		; 10 D9 ; Branch if plus to $10, $D9 [Flow: branch]
	ldx $5525.w		; AE 25 55 ; Load $5525.w into X register [Writes: X Index] [Flags: NZ]
	mvp $DD,$1E		; 44 1E DD ; Move block positive $DD,$1E [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sbc $52.b,S		; E3 52 ; Subtract stack-relative $52.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	cop $20.b		; 02 20 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $2003.w		; EE 03 20 ; Increment $2003.w [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $02CE.w		; ED CE 02 ; Subtract $02CE.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	and ($22.b,S),Y		; 33 22 ; AND accumulator (stack relative indirect indexed) ($22.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $10, $FE		; 10 FE ; Branch if plus to $10, $FE [Flow: branch]
	inc $C07A.w		; EE 7A C0 ; Increment $C07A.w [Flags: NZ]
	mvp $22,$01		; 44 01 22 ; Move block positive $22,$01 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sbc $3F03.w,X		; FD 03 3F ; Subtract with carry $3F03.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	wai		; CB ; Wait for interrupt
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	cpx $65.b		; E4 65 ; Compare $65.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	eor $33.b,S		; 43 33 ; Exclusive OR accumulator with stack relative $33.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	cpy $7ABE.w		; CC BE 7A ; Compare $7ABE.w with Y register [Reads: Y Index] [Flags: NCZ]
	eor $10.b		; 45 10 ; Exclusive OR $10.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $0E.b,S		; 23 0E ; AND accumulator with stack relative $0E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc ($3F.b,S),Y		; F3 3F ; Subtract with carry (stack relative indirect indexed) ($3F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ldy $7AC9.w,X		; BC C9 7A ; Load Y register $7AC9.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda ($65.b)		; B2 65 ; Load accumulator (indirect) ($65.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $41.b,X		; 55 41 ; Exclusive OR accumulator with memory $41.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $BDCD.w,X		; FD CD BD ; Subtract with carry $BDCD.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $7A.b		; 25 7A ; Logical AND $7A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $13		; 10 13 ; Branch if plus to $10, $13 [Flow: branch]
	.db $10, $F2		; 10 F2 ; Branch if plus to $10, $F2 [Flow: branch]
	.db $30, $CC		; 30 CC ; Branch if minus to $30, $CC [Flow: branch]
	cmp #$7AA0.w		; C9 A0 7A ; Compare #$7AA0.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	eor $55.b,X		; 55 55 ; Exclusive OR accumulator with memory $55.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($0E.b,X)		; 41 0E ; Exclusive OR accumulator with memory ($0E.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cpy $04DE.w		; CC DE 04 ; Compare $04DE.w with Y register [Reads: Y Index] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	sbc ($30.b)		; F2 30 ; Subtract with carry (indirect) ($30.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($31.b,X)		; E1 31 ; Subtract with carry ($31.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $9FD9.w		; CD D9 9F ; Compare $9FD9.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	and ($7A.b,S),Y		; 33 7A ; AND accumulator (stack relative indirect indexed) ($7A.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor [$62.b],Y		; 57 62 ; Exclusive OR accumulator with memory (long indexed) [$62.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $FFBC.w		; 0E BC FF ; Arithmetic shift left $FFBC.w [Flags: NCZ]
	sbc ($41.b),Y		; F1 41 ; Subtract with carry ($41.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $8A		; F0 8A ; Branch if equal to $F0, $8A [Flow: branch]
	ora ($01.b),Y		; 11 01 ; OR accumulator with memory ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $EF		; 10 EF ; Branch if plus to $10, $EF [Flow: branch]
	sbc $00D0.w		; ED D0 00 ; Subtract $00D0.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	and $7A.b		; 25 7A ; Logical AND $7A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc ($00.b,X)		; 61 00 ; Add with carry ($00.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	wai		; CB ; Wait for interrupt
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	.db $42, $EF		; 42 EF ; Reserved instruction
	and ($8A.b)		; 32 8A ; AND accumulator with memory (indirect) ($8A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $0FDFFD.l		; EF FD DF 0F ; Subtract with carry (long) $0FDFFD.l [Writes: Accumulator] [Flags: NCVZ]
	ora $41.b,X		; 15 41 ; OR accumulator with memory $41.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	ora ($DB.b,X)		; 01 DB ; Logical OR ($DB.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpx #$F1.b		; E0 F1 ; Compare #$F1.b with X register [Reads: X Index] [Flags: NCZ]
	and ($F0.b)		; 32 F0 ; AND accumulator with memory (indirect) ($F0.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $E0EDFF.l,X		; 1F FF ED E0 ; Logical OR long $E0EDFF.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $4205.w,X		; FE 05 42 ; Increment memory $4205.w,X [Reads: X Index] [Flags: NZ]
	ora ($7A.b,X)		; 01 7A ; Logical OR ($7A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jmp.w [$F0E0]		; DC E0 F0 ; Jump long indirect [$F0E0] [Flow: jump]
	and ($0F.b)		; 32 0F ; AND accumulator with memory (indirect) ($0F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsr $FD8A.w		; 20 8A FD ; Jump to subroutine at $FD8A.w [Writes: Stack Pointer] [Flow: call]
	inc $0EFF.w		; EE FF 0E ; Increment $0EFF.w [Flags: NZ]
	cop $42.b		; 02 42 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($0F.b),Y		; 11 0F ; OR accumulator with memory ($0F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	cmp $1012F0.l,X		; DF F0 12 10 ; Compare accumulator (long,X) $1012F0.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	sbc ($23.b),Y		; F1 23 ; Subtract with carry ($23.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($EB.b,X)		; 21 EB ; Logical AND ($EB.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	.db $D0, $1F		; D0 1F ; Branch if not equal to $D0, $1F [Flow: branch]
	cmp ($55.b),Y		; D1 55 ; Compare accumulator ($55.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	jsl $8AFE22.l		; 22 22 FE 8A ; Jump to subroutine long $8AFE22.l [Writes: Stack Pointer] [Flow: call]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $11.b		; 02 11 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $7ACC.w		; 0E CC 7A ; Arithmetic shift left $7ACC.w [Flags: NCZ]
	cmp ($30.b),Y		; D1 30 ; Compare accumulator ($30.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cpx #$22.b		; E0 22 ; Compare #$22.b with X register [Reads: X Index] [Flags: NCZ]
	ora ($44.b,S),Y		; 13 44 ; OR accumulator (stack relative indirect indexed) ($44.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $8AEF.w,X		; 1E EF 8A ; Arithmetic shift left $8AEF.w,X [Reads: X Index] [Flags: NCZ]
	ora $021F01.l		; 0F 01 1F 02 ; OR accumulator with memory (long) $021F01.l [Writes: Accumulator] [Flags: NZ]
	and ($0E.b,X)		; 21 0E ; Logical AND ($0E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpy $8AEF.w		; CC EF 8A ; Compare $8AEF.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora ($1F.b)		; 12 1F ; OR accumulator with memory (indirect) ($1F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $11		; F0 11 ; Branch if equal to $F0, $11 [Flow: branch]
	and $30.b,S		; 23 30 ; AND accumulator with stack relative $30.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $F18AFF.l		; EF FF 8A F1 ; Subtract with carry (long) $F18AFF.l [Writes: Accumulator] [Flags: NCVZ]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $CDDC1E.l		; 22 1E DC CD ; Jump to subroutine long $CDDC1E.l [Writes: Stack Pointer] [Flow: call]
	trb $8A.b		; 14 8A ; Test and reset bits $8A.b [Reads: Accumulator] [Flags: Z]
	and $35F0EF.l,X		; 3F EF F0 35 ; AND accumulator with memory (long,X) $35F0EF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($FE.b),Y		; 31 FE ; AND accumulator with memory ($FE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $218AF0.l		; EF F0 8A 21 ; Subtract with carry (long) $218AF0.l [Writes: Accumulator] [Flags: NCVZ]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $F4CDDC.l,X		; 1F DC CD F4 ; Logical OR long $F4CDDC.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dec $25FF.w,X		; DE FF 25 ; Decrement memory $25FF.w,X [Reads: X Index] [Flags: NZ]
	eor ($1E.b,S),Y		; 53 1E ; XOR accumulator (stack relative indirect indexed) ($1E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $23EF.w,X		; DD EF 23 ; Compare accumulator $23EF.w,X [Reads: X Index] [Flags: NCZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $DD2F12.l,X		; 1F 12 2F DD ; Logical OR long $DD2F12.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$52D3]		; DC D3 52 ; Jump long indirect [$52D3] [Flow: jump]
	cmp $E08A.w,X		; DD 8A E0 ; Compare accumulator $E08A.w,X [Reads: X Index] [Flags: NCZ]
	trb $55.b		; 14 55 ; Test and reset bits $55.b [Reads: Accumulator] [Flags: Z]
	rol $EECE.w		; 2E CE EE ; Rotate left $EECE.w [Flags: NCZ]
	tsb $30.b		; 04 30 ; Test and set bits $30.b [Reads: Accumulator] [Flags: Z]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($20.b),Y		; F1 20 ; Subtract with carry ($20.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $D0EC.w		; ED EC D0 ; Subtract $D0EC.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	eor ($FC.b)		; 52 FC ; Exclusive OR accumulator with memory (indirect) ($FC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $46248A.l,X		; DF 8A 24 46 ; Compare accumulator (long,X) $46248A.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	lda $F2EE.w,X		; BD EE F2 ; Load $F2EE.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($0F.b,X)		; 41 0F ; Exclusive OR accumulator with memory ($0F.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($0E.b),Y		; 11 0E ; OR accumulator with memory ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $23DF.w,X		; DD DF 23 ; Compare accumulator $23DF.w,X [Reads: X Index] [Flags: NCZ]
	tsb $22DF.w		; 0C DF 22 ; Test and set bits $22DF.w [Reads: Accumulator] [Flags: Z]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $51.b,X		; 55 51 ; Exclusive OR accumulator with memory $51.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cpx $F1DD.w		; EC DD F1 ; Compare $F1DD.w with X register [Reads: X Index] [Flags: NCZ]
	.db $42, $0F		; 42 0F ; Reserved instruction
	ora ($8A.b),Y		; 11 8A ; OR accumulator with memory ($8A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $F1EEED.l		; 0F ED EE F1 ; OR accumulator with memory (long) $F1EEED.l [Writes: Accumulator] [Flags: NZ]
	and $32C0.w		; 2D C0 32 ; Logical AND $32C0.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $8A.b		; 25 8A ; Logical AND $8A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $EC.b,S		; 63 EC ; Add with carry (stack relative) $EC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	dec $34EF.w,X		; DE EF 34 ; Decrement memory $34EF.w,X [Reads: X Index] [Flags: NZ]
	ora $8A11F0.l,X		; 1F F0 11 8A ; Logical OR long $8A11F0.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $EEFF.w		; ED FF EE ; Subtract $EEFF.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ora $3423DE.l,X		; 1F DE 23 34 ; Logical OR long $3423DE.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	mvn $0D,$8A		; 54 8A 0D ; Move block negative $0D,$8A [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	dec $03EF.w		; CE EF 03 ; Decrement $03EF.w [Flags: NZ]
	and ($EF.b),Y		; 31 EF ; AND accumulator with memory ($EF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($FF.b),Y		; 11 FF ; OR accumulator with memory ($FF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $FFF0CC.l		; 0F CC F0 FF ; OR accumulator with memory (long) $FFF0CC.l [Writes: Accumulator] [Flags: NZ]
	jsl $2F4333.l		; 22 33 43 2F ; Jump to subroutine long $2F4333.l [Writes: Stack Pointer] [Flow: call]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $02EE.w,X		; DD EE 02 ; Compare accumulator $02EE.w,X [Reads: X Index] [Flags: NCZ]
	and ($FF.b),Y		; 31 FF ; AND accumulator with memory ($FF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $CFDB8A.l		; 0F 8A DB CF ; OR accumulator with memory (long) $CFDB8A.l [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $23.b,S		; 43 23 ; Exclusive OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $30, $EE		; 30 EE ; Branch if minus to $30, $EE [Flow: branch]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $32D0.w,X		; FE D0 32 ; Increment memory $32D0.w,X [Reads: X Index] [Flags: NZ]
	sbc $002101.l,X		; FF 01 21 00 ; Subtract with carry (long,X) $002101.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldy $2201.w		; AC 01 22 ; Load $2201.w into Y register [Writes: Y Index] [Flags: NZ]
	and ($22.b,S),Y		; 33 22 ; AND accumulator (stack relative indirect indexed) ($22.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $8AEE0E.l		; 22 0E EE 8A ; Jump to subroutine long $8AEE0E.l [Writes: Stack Pointer] [Flow: call]
	sbc $F11F11.l,X		; FF 11 1F F1 ; Subtract with carry (long,X) $F11F11.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $9BEB11.l		; 22 11 EB 9B ; Jump to subroutine long $9BEB11.l [Writes: Stack Pointer] [Flow: call]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	cmp ($44.b,S),Y		; D3 44 ; Compare accumulator (stack relative indirect indexed) ($44.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	adc [$52.b]		; 67 52 ; Add with carry (long) [$52.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	bit $3F.b,X		; 34 3F ; Test bits $3F.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	wai		; CB ; Wait for interrupt
	dec $F08A.w,X		; DE 8A F0 ; Decrement memory $F08A.w,X [Reads: X Index] [Flags: NZ]
	and ($FF.b,X)		; 21 FF ; Logical AND ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $31.b,S		; 23 31 ; AND accumulator with stack relative $31.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	.db $D0, $7A		; D0 7A ; Branch if not equal to $D0, $7A [Flow: branch]
	and $55.b,X		; 35 55 ; Logical AND $55.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	mvn $41,$33		; 54 33 41 ; Move block negative $41,$33 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cpx $EEDD.w		; EC DD EE ; Compare $EEDD.w with X register [Reads: X Index] [Flags: NCZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($31.b,S),Y		; 13 31 ; OR accumulator (stack relative indirect indexed) ($31.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr ($D0AA.w,X)		; FC AA D0 ; Jump to subroutine indirect indexed ($D0AA.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora ($7A.b)		; 12 7A ; OR accumulator with memory (indirect) ($7A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	mvp $44,$34		; 44 34 44 ; Move block positive $44,$34 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	eor ($FC.b,S),Y		; 53 FC ; XOR accumulator (stack relative indirect indexed) ($FC.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $F2CC.w,X		; DE CC F2 ; Decrement memory $F2CC.w,X [Reads: X Index] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $13		; 10 13 ; Branch if plus to $10, $13 [Flow: branch]
	.db $42, $FC		; 42 FC ; Reserved instruction
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	cmp $7A2102.l,X		; DF 02 21 7A ; Compare accumulator (long,X) $7A2102.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	ora $56.b,S		; 03 56 ; OR accumulator with stack relative $56.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $1D.b,X		; 55 1D ; Exclusive OR accumulator with memory $1D.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $E0DC.w		; CD DC E0 ; Compare $E0DC.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	and ($8A.b,X)		; 21 8A ; Logical AND ($8A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($42.b,S),Y		; 13 42 ; OR accumulator (stack relative indirect indexed) ($42.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $D1AA.w		; 0D AA D1 ; Logical OR $D1AA.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	ora ($8A.b,X)		; 01 8A ; Logical OR ($8A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $43.b,S		; 23 43 ; AND accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $E0EEFE.l,X		; 1F FE EE E0 ; Logical OR long $E0EEFE.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($13.b),Y		; 11 13 ; OR accumulator with memory ($13.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $42, $0D		; 42 0D ; Reserved instruction
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	.db $D0, $11		; D0 11 ; Branch if not equal to $D0, $11 [Flow: branch]
	sbc $8A14F0.l,X		; FF F0 14 8A ; Subtract with carry (long,X) $8A14F0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	mvp $ED,$21		; 44 21 ED ; Move block positive $ED,$21 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	inc $10FF.w		; EE FF 10 ; Increment $10FF.w [Flags: NZ]
	ora ($54.b)		; 12 54 ; OR accumulator with memory (indirect) ($54.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $CFCC.w		; 0C CC CF ; Test and set bits $CFCC.w [Reads: Accumulator] [Flags: Z]
	jsl $F3EEFF.l		; 22 FF EE F3 ; Jump to subroutine long $F3EEFF.l [Writes: Stack Pointer] [Flow: call]
	eor $8A.b,X		; 55 8A ; Exclusive OR accumulator with memory $8A.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $42, $FC		; 42 FC ; Reserved instruction
	dec $11FF.w,X		; DE FF 11 ; Decrement memory $11FF.w,X [Reads: X Index] [Flags: NZ]
	ora ($43.b),Y		; 11 43 ; OR accumulator with memory ($43.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $DB8A.w,X		; 1E 8A DB ; Arithmetic shift left $DB8A.w,X [Reads: X Index] [Flags: NCZ]
	cmp $DD1F11.l,X		; DF 11 1F DD ; Compare accumulator (long,X) $DD1F11.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	sbc ($35.b),Y		; F1 35 ; Subtract with carry ($35.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	stz $8A.b		; 64 8A ; Store zero to $8A.b
	ora $DFDD.w		; 0D DD DF ; Logical OR $DFDD.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and ($11.b,X)		; 21 11 ; Logical AND ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and ($2F.b,S),Y		; 33 2F ; AND accumulator (stack relative indirect indexed) ($2F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$CE8A]		; DC 8A CE ; Jump long indirect [$CE8A] [Flow: jump]
	ora ($10.b)		; 12 10 ; OR accumulator with memory (indirect) ($10.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx $35C0.w		; EC C0 35 ; Compare $35C0.w with X register [Reads: X Index] [Flags: NCZ]
	eor $2F.b,X		; 55 2F ; Exclusive OR accumulator with memory $2F.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$12CF]		; DC CF 12 ; Jump long indirect [$12CF] [Flow: jump]
	ora ($23.b)		; 12 23 ; OR accumulator with memory (indirect) ($23.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $EC		; 10 EC ; Branch if plus to $10, $EC [Flow: branch]
	cmp $01108A.l		; CF 8A 10 01 ; Compare accumulator (long) $01108A.l [Reads: Accumulator] [Flags: NCZ]
	ora $04CD.w		; 0D CD 04 ; Logical OR $04CD.w with accumulator [Writes: Accumulator] [Flags: NZ]
	eor $42.b,X		; 55 42 ; Exclusive OR accumulator with memory $42.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cpx $CD8A.w		; EC 8A CD ; Compare $CD8A.w with X register [Reads: X Index] [Flags: NCZ]
	sbc ($34.b),Y		; F1 34 ; Subtract with carry ($34.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($F0.b),Y		; 31 F0 ; AND accumulator with memory ($F0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	inc $00DE.w,X		; FE DE 00 ; Increment memory $00DE.w,X [Reads: X Index] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $45E2.w,X		; DD E2 45 ; Compare accumulator $45E2.w,X [Reads: X Index] [Flags: NCZ]
	eor $1D.b,S		; 43 1D ; Exclusive OR accumulator with stack relative $1D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldy $F08A.w,X		; BC 8A F0 ; Load Y register $F08A.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	and $43.b,S		; 23 43 ; AND accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $EDF0.w		; 0E F0 ED ; Arithmetic shift left $EDF0.w [Flags: NCZ]
	sbc ($00.b),Y		; F1 00 ; Subtract with carry ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $24E0EE.l,X		; FF EE E0 24 ; Subtract with carry (long,X) $24E0EE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($31.b,S),Y		; 33 31 ; AND accumulator (stack relative indirect indexed) ($31.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	wai		; CB ; Wait for interrupt
	.db $D0, $8A		; D0 8A ; Branch if not equal to $D0, $8A [Flow: branch]
	ora ($45.b)		; 12 45 ; OR accumulator with memory (indirect) ($45.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $EFDF.w		; 2E DF EF ; Rotate left $EFDF.w [Flags: NCZ]
	sbc ($10.b),Y		; F1 10 ; Subtract with carry ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FF8A.w		; ED 8A FF ; Subtract $FF8A.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sbc $223213.l,X		; FF 13 32 22 ; Subtract with carry (long,X) $223213.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($01DE.w,X)		; FC DE 01 ; Jump to subroutine indirect indexed ($01DE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $40.b		; 45 40 ; Exclusive OR $40.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $01EF.w,X		; DD EF 01 ; Compare accumulator $01EF.w,X [Reads: X Index] [Flags: NCZ]
	ora $8AEEFD.l,X		; 1F FD EE 8A ; Logical OR long $8AEEFD.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $11		; 10 11 ; Branch if plus to $10, $11 [Flow: branch]
	and ($12.b,X)		; 21 12 ; Logical AND ($12.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $24F1DD.l,X		; 1F DD F1 24 ; Logical OR long $24F1DD.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($FD.b)		; 52 FD ; Exclusive OR accumulator with memory (indirect) ($FD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dec $1101.w,X		; DE 01 11 ; Decrement memory $1101.w,X [Reads: X Index] [Flags: NZ]
	sbc $F1DE.w,X		; FD DE F1 ; Subtract with carry $F1DE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b)		; 12 11 ; OR accumulator with memory (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $14E0.w		; ED E0 14 ; Subtract $14E0.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	eor ($8A.b,S),Y		; 53 8A ; XOR accumulator (stack relative indirect indexed) ($8A.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $F1DC.w,X		; 1E DC F1 ; Arithmetic shift left $F1DC.w,X [Reads: X Index] [Flags: NCZ]
	and ($0D.b),Y		; 31 0D ; AND accumulator with memory ($0D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $12F0.w		; CD F0 12 ; Compare $12F0.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($0F.b),Y		; 31 0F ; AND accumulator with memory ($0F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($0E.b,X)		; 01 0E ; Logical OR ($0E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $2F5502.l		; EF 02 55 2F ; Subtract with carry (long) $2F5502.l [Writes: Accumulator] [Flags: NCVZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $21D1.w,X		; DD D1 21 ; Compare accumulator $21D1.w,X [Reads: X Index] [Flags: NCZ]
	brk $EB.b		; 00 EB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $D0, $11		; D0 11 ; Branch if not equal to $D0, $11 [Flow: branch]
	and $8A.b,S		; 23 8A ; AND accumulator with stack relative $8A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $EE0FF0.l,X		; 1F F0 0F EE ; Logical OR long $EE0FF0.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cop $34.b		; 02 34 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $42, $FC		; 42 FC ; Reserved instruction
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $FD0022.l		; CF 22 00 FD ; Compare accumulator (long) $FD0022.l [Reads: Accumulator] [Flags: NCZ]
	ldx $2302.w,Y		; BE 02 23 ; Load X register $2302.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	jsr $FF8A.w		; 20 8A FF ; Jump to subroutine at $FF8A.w [Writes: Stack Pointer] [Flow: call]
	sbc $24F0FF.l,X		; FF FF F0 24 ; Subtract with carry (long,X) $24F0FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $1E.b,S		; 43 1E ; Exclusive OR accumulator with stack relative $1E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $028A.w		; CD 8A 02 ; Compare $028A.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	and ($0E.b,X)		; 21 0E ; Logical AND ($0E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ldy $22F2.w,X		; BC F2 22 ; Load Y register $22F2.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ora ($0F.b)		; 12 0F ; OR accumulator with memory (indirect) ($0F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $03FFFF.l		; EF FF FF 03 ; Subtract with carry (long) $03FFFF.l [Writes: Accumulator] [Flags: NCVZ]
	adc $2F.b		; 65 2F ; Add $2F.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cpy $8AF2.w		; CC F2 8A ; Compare $8AF2.w with Y register [Reads: Y Index] [Flags: NCZ]
	and ($0F.b,X)		; 21 0F ; Logical AND ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	.db $D0, $33		; D0 33 ; Branch if not equal to $D0, $33 [Flow: branch]
	jsr $FF00.w		; 20 00 FF ; Jump to subroutine at $FF00.w [Writes: Stack Pointer] [Flow: call]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $4502DE.l		; 0F DE 02 45 ; OR accumulator with memory (long) $4502DE.l [Writes: Accumulator] [Flags: NZ]
	eor ($FC.b,X)		; 41 FC ; Exclusive OR accumulator with memory ($FC.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$32.b		; C0 32 ; Compare #$32.b with Y register [Reads: Y Index] [Flags: NCZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $EC.b		; 00 EC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec W12SEL.w		; CE 23 21 ; Decrement W12SEL.w [Flags: NZ]
	ora $8A00E0.l,X		; 1F E0 00 8A ; Logical OR long $8A00E0.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $45E0.w		; ED E0 45 ; Subtract $45E0.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	eor ($0E.b)		; 52 0E ; Exclusive OR accumulator with memory (indirect) ($0E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dec $1013.w		; CE 13 10 ; Decrement $1013.w [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $12CD.w,X		; FD CD 12 ; Subtract with carry $12CD.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($1F.b),Y		; 31 1F ; AND accumulator with memory ($1F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $8AFF01.l		; EF 01 FF 8A ; Subtract with carry (long) $8AFF01.l [Writes: Accumulator] [Flags: NCVZ]
	dec $6404.w,X		; DE 04 64 ; Decrement memory $6404.w,X [Reads: X Index] [Flags: NZ]
	jsr $F2DC.w		; 20 DC F2 ; Jump to subroutine at $F2DC.w [Writes: Stack Pointer] [Flow: call]
	and ($FF.b,X)		; 21 FF ; Logical AND ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$53D2]		; DC D2 53 ; Jump long indirect [$53D2] [Flow: jump]
	ora $10F1EE.l		; 0F EE F1 10 ; OR accumulator with memory (long) $10F1EE.l [Writes: Accumulator] [Flags: NZ]
	cmp $E28A.w,X		; DD 8A E2 ; Compare accumulator $E28A.w,X [Reads: X Index] [Flags: NCZ]
	lsr $41.b		; 46 41 ; Logical shift right $41.b [Reads: Direct Page] [Flags: NCZ]
	sbc $22E0.w		; ED E0 22 ; Subtract $22E0.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ora $D08ADD.l		; 0F DD 8A D0 ; OR accumulator with memory (long) $D08ADD.l [Writes: Accumulator] [Flags: NZ]
	bit $2F.b,X		; 34 2F ; Test bits $2F.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sbc $22E0.w		; ED E0 22 ; Subtract $22E0.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sbc $8ACF.w,X		; FD CF 8A ; Subtract with carry $8ACF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $43.b,X		; 35 43 ; Logical AND $43.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	asl $12DE.w,X		; 1E DE 12 ; Arithmetic shift left $12DE.w,X [Reads: X Index] [Flags: NCZ]
	.db $10, $FE		; 10 FE ; Branch if plus to $10, $FE [Flow: branch]
	dec $148A.w		; CE 8A 14 ; Decrement $148A.w [Flags: NZ]
	eor ($EC.b,X)		; 41 EC ; Exclusive OR accumulator with memory ($EC.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	dec $2012.w,X		; DE 12 20 ; Decrement memory $2012.w,X [Reads: X Index] [Flags: NZ]
	cmp $8AF3.w,X		; DD F3 8A ; Compare accumulator $8AF3.w,X [Reads: X Index] [Flags: NCZ]
	mvp $EE,$21		; 44 21 EE ; Move block positive $EE,$21 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sbc ($11.b,X)		; E1 11 ; Subtract with carry ($11.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $8AF2ED.l		; 0F ED F2 8A ; OR accumulator with memory (long) $8AF2ED.l [Writes: Accumulator] [Flags: NZ]
	eor $0D.b,S		; 43 0D ; Exclusive OR accumulator with stack relative $0D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $23F0.w		; CD F0 23 ; Compare $23F0.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora $23D1.w		; 0D D1 23 ; Logical OR $23D1.w with accumulator [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($1F.b)		; 32 1F ; AND accumulator with memory (indirect) ($1F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dec $0E22.w,X		; DE 22 0E ; Decrement memory $0E22.w,X [Reads: X Index] [Flags: NZ]
	ora $8A34EF.l		; 0F EF 34 8A ; OR accumulator with memory (long) $8A34EF.l [Writes: Accumulator] [Flags: NZ]
	rol $EFCC.w		; 2E CC EF ; Rotate left $EFCC.w [Flags: NCZ]
	ora ($20.b)		; 12 20 ; OR accumulator with memory (indirect) ($20.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $3202.w,X		; FE 02 32 ; Increment memory $3202.w,X [Reads: X Index] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	and ($EC.b,X)		; 21 EC ; Logical AND ($EC.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp ($30.b)		; D2 30 ; Compare accumulator (indirect) ($30.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sbc $5115FF.l		; EF FF 15 51 ; Subtract with carry (long) $5115FF.l [Writes: Accumulator] [Flags: NCVZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpx $02CD.w		; EC CD 02 ; Compare $02CD.w with X register [Reads: X Index] [Flags: NCZ]
	jsl $02F000.l		; 22 00 F0 02 ; Jump to subroutine long $02F000.l [Writes: Stack Pointer] [Flow: call]
	ora ($7A.b),Y		; 11 7A ; OR accumulator with memory ($7A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsr $21CE.w		; 20 CE 21 ; Jump to subroutine at $21CE.w [Writes: Stack Pointer] [Flow: call]
	sbc $530211.l,X		; FF 11 02 53 ; Subtract with carry (long,X) $530211.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $13D0.w,X		; DD D0 13 ; Compare accumulator $13D0.w,X [Reads: X Index] [Flags: NCZ]
	and ($F0.b,X)		; 21 F0 ; Logical AND ($F0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($7A.b,X)		; 21 7A ; Logical AND ($7A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpx $0E02.w		; EC 02 0E ; Compare $0E02.w with X register [Reads: X Index] [Flags: NCZ]
	trb $2F.b		; 14 2F ; Test and reset bits $2F.b [Reads: Accumulator] [Flags: Z]
	trb $1B.b		; 14 1B ; Test and reset bits $1B.b [Reads: Accumulator] [Flags: Z]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	cpy $65E3.w		; CC E3 65 ; Compare $65E3.w with Y register [Reads: Y Index] [Flags: NCZ]
	and ($FE.b,X)		; 21 FE ; Logical AND ($FE.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $F0, $13		; F0 13 ; Branch if equal to $F0, $13 [Flow: branch]
	and $0FD07A.l		; 2F 7A D0 0F ; AND accumulator with memory (long) $0FD07A.l [Writes: Accumulator] [Flags: NZ]
	sbc ($43.b,S),Y		; F3 43 ; Subtract with carry (stack relative indirect indexed) ($43.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	and ($0E.b,X)		; 21 0E ; Logical AND ($0E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	cmp $CD7A.w,X		; DD 7A CD ; Compare accumulator $CD7A.w,X [Reads: X Index] [Flags: NCZ]
	rol $63.b,X		; 36 63 ; Rotate left $63.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $32F2DC.l,X		; 1F DC F2 32 ; Logical OR long $32F2DC.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $F0FF7A.l		; 0F 7A FF F0 ; OR accumulator with memory (long) $F0FF7A.l [Writes: Accumulator] [Flags: NZ]
	lsr $40.b		; 46 40 ; Logical shift right $40.b [Reads: Direct Page] [Flags: NCZ]
	asl $CECA.w		; 0E CA CE ; Arithmetic shift left $CECA.w [Flags: NCZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	cpx $75.b		; E4 75 ; Compare $75.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $42, $FB		; 42 FB ; Reserved instruction
	ldx $3113.w,Y		; BE 13 31 ; Load X register $3113.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	inc $FF8A.w,X		; FE 8A FF ; Increment memory $FF8A.w,X [Reads: X Index] [Flags: NZ]
	ora ($42.b,S),Y		; 13 42 ; OR accumulator (stack relative indirect indexed) ($42.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $EFEE.w		; 0E EE EF ; Arithmetic shift left $EFEE.w [Flags: NCZ]
	sbc $258ADF.l,X		; FF DF 8A 25 ; Subtract with carry (long,X) $258ADF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($0F.b),Y		; 31 0F ; AND accumulator with memory ($0F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	dec $13F0.w,X		; DE F0 13 ; Decrement memory $13F0.w,X [Reads: X Index] [Flags: NZ]
	ora $F18AFF.l,X		; 1F FF 8A F1 ; Logical OR long $F18AFF.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $20.b,S		; 43 20 ; Exclusive OR accumulator with stack relative $20.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $00DF.w		; ED DF 00 ; Subtract $00DF.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	inc $8AF2.w		; EE F2 8A ; Increment $8AF2.w [Flags: NZ]
	eor $20.b,S		; 43 20 ; Exclusive OR accumulator with stack relative $20.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr ($11DF.w,X)		; FC DF 11 ; Jump to subroutine indirect indexed ($11DF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsl $8AE00E.l		; 22 0E E0 8A ; Jump to subroutine long $8AE00E.l [Writes: Stack Pointer] [Flow: call]
	bit $31.b		; 24 31 ; Test bits $31.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	inc $00DE.w,X		; FE DE 00 ; Increment memory $00DE.w,X [Reads: X Index] [Flags: NZ]
	inc $24E0.w,X		; FE E0 24 ; Increment memory $24E0.w,X [Reads: X Index] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($FE.b)		; 32 FE ; AND accumulator with memory (indirect) ($FE.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $22F1.w		; CD F1 22 ; Compare $22F1.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsr $F2FE.w		; 20 FE F2 ; Jump to subroutine at $F2FE.w [Writes: Stack Pointer] [Flow: call]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $0F.b,S		; 43 0F ; Exclusive OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $0FE0.w		; EE E0 0F ; Increment $0FE0.w [Flags: NZ]
	sbc $8A4302.l		; EF 02 43 8A ; Subtract with carry (long) $8A4302.l [Writes: Accumulator] [Flags: NCVZ]
	ora $13DEEC.l,X		; 1F EC DE 13 ; Logical OR long $13DEEC.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($0F.b),Y		; 31 0F ; AND accumulator with memory ($0F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$33.b		; E0 33 ; Compare #$33.b with X register [Reads: X Index] [Flags: NCZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	and $0FDEFD.l		; 2F FD DE 0F ; AND accumulator with memory (long) $0FDEFD.l [Writes: Accumulator] [Flags: NZ]
	jmp.w [$55F3]		; DC F3 55 ; Jump long indirect [$55F3] [Flow: jump]
	eor ($7A.b,X)		; 41 7A ; Exclusive OR accumulator with memory ($7A.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	nop		; EA ; No operation
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
.INDEX 8
	sep #$56		; E2 56
	eor ($ED.b),Y		; 51 ED ; Exclusive OR accumulator with memory ($ED.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($42.b)		; F2 42 ; Subtract with carry (indirect) ($42.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	sbc $ECEFFF.l,X		; FF FF EF EC ; Subtract with carry (long,X) $ECEFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp ($54.b)		; D2 54 ; Compare accumulator (indirect) ($54.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	eor $0C.b,S		; 43 0C ; Exclusive OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	lda #$35BE.w		; A9 BE 35 ; Load #$35BE.w into accumulator [Writes: Accumulator] [Flags: NZ]
	stz $2E.b		; 64 2E ; Store zero to $2E.b
	sbc $8A0F21.l		; EF 21 0F 8A ; Subtract with carry (long) $8A0F21.l [Writes: Accumulator] [Flags: NCVZ]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $1123EF.l,X		; FF EF 23 11 ; Subtract with carry (long,X) $1123EF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $DC		; 10 DC ; Branch if plus to $10, $DC [Flow: branch]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	lda $6603.w		; AD 03 66 ; Load $6603.w into accumulator [Writes: Accumulator] [Flags: NZ]
	eor ($0F.b,X)		; 41 0F ; Exclusive OR accumulator with memory ($0F.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $8A02EE.l,X		; FF EE 02 8A ; Subtract with carry (long,X) $8A02EE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($0F.b),Y		; 11 0F ; OR accumulator with memory ($0F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	dec $3203.w,X		; DE 03 32 ; Decrement memory $3203.w,X [Reads: X Index] [Flags: NZ]
	.db $10, $DC		; 10 DC ; Branch if plus to $10, $DC [Flow: branch]
	cmp $14027A.l		; CF 7A 02 14 ; Compare accumulator (long) $14027A.l [Reads: Accumulator] [Flags: NCZ]
	mvn $0F,$21		; 54 21 0F ; Move block negative $0F,$21 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	jmp.w [$43D1]		; DC D1 43 ; Jump long indirect [$43D1] [Flow: jump]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $FD		; 10 FD ; Branch if plus to $10, $FD [Flow: branch]
	sbc ($33.b,X)		; E1 33 ; Subtract with carry ($33.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr $BDED.w		; 20 ED BD ; Jump to subroutine at $BDED.w [Writes: Stack Pointer] [Flow: call]
	cop $7A.b		; 02 7A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($45.b),Y		; 11 45 ; OR accumulator with memory ($45.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($32.b),Y		; 31 32 ; AND accumulator with memory ($32.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	nop		; EA ; No operation
	lda DMASRC2B.w		; AD 24 43 ; Load DMASRC2B.w into accumulator [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $13EF.w		; 0E EF 13 ; Arithmetic shift left $13EF.w [Flags: NCZ]
	and ($FD.b)		; 32 FD ; AND accumulator with memory (indirect) ($FD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy $32E1.w,X		; BC E1 32 ; Load Y register $32E1.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($1E.b,S),Y		; 33 1E ; AND accumulator (stack relative indirect indexed) ($1E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $54D1.w,Y		; B9 D1 54 ; Load $54D1.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($8A.b),Y		; 31 8A ; AND accumulator with memory ($8A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $43F2.w,X		; FD F2 43 ; Subtract with carry $43F2.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $CFCB.w		; 0E CB CF ; Arithmetic shift left $CFCB.w [Flags: NCZ]
	and $21.b,S		; 23 21 ; AND accumulator with stack relative $21.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	cop $23.b		; 02 23 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($DA.b),Y		; 31 DA ; AND accumulator with memory ($DA.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda $5214.w,X		; BD 14 52 ; Load $5214.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $23F08A.l		; 0F 8A F0 23 ; OR accumulator with memory (long) $23F08A.l [Writes: Accumulator] [Flags: NZ]
	.db $10, $DC		; 10 DC ; Branch if plus to $10, $DC [Flow: branch]
	lda $43F2.w,X		; BD F2 43 ; Load $43F2.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $7A		; 10 7A ; Branch if plus to $10, $7A [Flow: branch]
	ora ($11.b)		; 12 11 ; OR accumulator with memory (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $E0CC.w		; 0E CC E0 ; Arithmetic shift left $E0CC.w [Flags: NCZ]
	bit $20.b,X		; 34 20 ; Test bits $20.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora ($8A.b,X)		; 01 8A ; Logical OR ($8A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($21.b),Y		; 11 21 ; OR accumulator with memory ($21.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsr ($D0BC.w,X)		; FC BC D0 ; Jump to subroutine indirect indexed ($D0BC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	and $31.b,X		; 35 31 ; Logical AND $31.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $6A		; F0 6A ; Branch if equal to $F0, $6A [Flow: branch]
	eor $CB.b		; 45 CB ; Exclusive OR $CB.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $24AC.w		; EE AC 24 ; Increment $24AC.w [Flags: NZ]
	and $45.b,S		; 23 45 ; AND accumulator with stack relative $45.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	mvp $11,$8A		; 44 8A 11 ; Move block positive $11,$8A [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	asl $DFBB.w		; 0E BB DF ; Arithmetic shift left $DFBB.w [Flags: NCZ]
	ora $53.b,S		; 03 53 ; OR accumulator with stack relative $53.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $FC7A10.l,X		; 1F 10 7A FC ; Logical OR long $FC7A10.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0F		; F0 0F ; Branch if equal to $F0, $0F [Flow: branch]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	trb $43.b		; 14 43 ; Test and reset bits $43.b [Reads: Accumulator] [Flags: Z]
	jsl $CB0E8A.l		; 22 8A 0E CB ; Jump to subroutine long $CB0E8A.l [Writes: Stack Pointer] [Flow: call]
	dec $3402.w		; CE 02 34 ; Decrement $3402.w [Flags: NZ]
	and ($00.b)		; 32 00 ; AND accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $BF7A.w,X		; FE 7A BF ; Increment memory $BF7A.w,X [Reads: X Index] [Flags: NZ]
	ora ($01.b),Y		; 11 01 ; OR accumulator with memory ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $F1.b		; 00 F1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $42.b		; 46 42 ; Logical shift right $42.b [Reads: Direct Page] [Flags: NCZ]
	asl $DC8A.w		; 0E 8A DC ; Arithmetic shift left $DC8A.w [Flags: NCZ]
	lda $24E1.w,X		; BD E1 24 ; Load $24E1.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($11.b,S),Y		; 33 11 ; AND accumulator (stack relative indirect indexed) ($11.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $F18ADD.l		; 0F DD 8A F1 ; OR accumulator with memory (long) $F18ADD.l [Writes: Accumulator] [Flags: NZ]
	.db $10, $11		; 10 11 ; Branch if plus to $10, $11 [Flow: branch]
	ora $102023.l		; 0F 23 20 10 ; OR accumulator with memory (long) $102023.l [Writes: Accumulator] [Flags: NZ]
	jsr ($BB8A.w,X)		; FC 8A BB ; Jump to subroutine indirect indexed ($BB8A.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $315502.l		; EF 02 55 31 ; Subtract with carry (long) $315502.l [Writes: Accumulator] [Flags: NCVZ]
	ora $8AEFED.l		; 0F ED EF 8A ; OR accumulator with memory (long) $8AEFED.l [Writes: Accumulator] [Flags: NZ]
	ora ($10.b),Y		; 11 10 ; OR accumulator with memory ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($20.b,X)		; 21 20 ; Logical AND ($20.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $8ADB.w		; ED DB 8A ; Subtract $8ADB.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ldx $3411.w,Y		; BE 11 34 ; Load X register $3411.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	eor ($2F.b,S),Y		; 53 2F ; XOR accumulator (stack relative indirect indexed) ($2F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$00EF]		; DC EF 00 ; Jump long indirect [$00EF] [Flow: jump]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($00.b,X)		; 21 00 ; Logical AND ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($33.b)		; 12 33 ; OR accumulator with memory (indirect) ($33.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $CDCCFE.l,X		; 1F FE CC CD ; Logical OR long $CDCCFE.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $24		; D0 24 ; Branch if not equal to $D0, $24 [Flow: branch]
	eor $41.b,X		; 55 41 ; Exclusive OR accumulator with memory $41.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cpx $01CE.w		; EC CE 01 ; Compare $01CE.w with X register [Reads: X Index] [Flags: NCZ]
	ora ($8A.b,X)		; 01 8A ; Logical OR ($8A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $3143F2.l,X		; 1F F2 43 31 ; Logical OR long $3143F2.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $CCDC.w,X		; FD DC CC ; Subtract with carry $CCDC.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $138A.w		; EE 8A 13 ; Increment $138A.w [Flags: NZ]
	mvp $0D,$54		; 44 54 0D ; Move block positive $0D,$54 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ldy $01F1.w,X		; BC F1 01 ; Load Y register $01F1.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	jsr $E08A.w		; 20 8A E0 ; Jump to subroutine at $E08A.w [Writes: Stack Pointer] [Flow: call]
	and $43.b,X		; 35 43 ; Logical AND $43.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $EFACCA.l		; 0F CA AC EF ; OR accumulator with memory (long) $EFACCA.l [Writes: Accumulator] [Flags: NZ]
	sbc ($8A.b),Y		; F1 8A ; Subtract with carry ($8A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and $54.b,X		; 35 54 ; Logical AND $54.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $CB		; 30 CB ; Branch if minus to $30, $CB [Flow: branch]
	cmp $FF2002.l,X		; DF 02 20 FF ; Compare accumulator (long,X) $FF2002.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($55.b)		; 12 55 ; OR accumulator with memory (indirect) ($55.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $30, $DB		; 30 DB ; Branch if minus to $30, $DB [Flow: branch]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	dec $23F1.w		; CE F1 23 ; Decrement $23F1.w [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $43.b,X		; 35 43 ; Logical AND $43.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	lda $1E130F.l,X		; BF 0F 13 1E ; Load long $1E130F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($8A.b),Y		; F1 8A ; Subtract with carry ($8A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $52.b		; 45 52 ; Exclusive OR $52.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $CD99.w		; 0C 99 CD ; Test and set bits $CD99.w [Reads: Accumulator] [Flags: Z]
	cpx #$12.b		; E0 12 ; Compare #$12.b with X register [Reads: X Index] [Flags: NCZ]
	bit $8A.b,X		; 34 8A ; Test bits $8A.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	mvn $CC,$2D		; 54 2D CC ; Move block negative $CC,$2D [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sbc $FF2011.l,X		; FF 11 20 FF ; Subtract with carry (long,X) $FF2011.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $8A.b		; 25 8A ; Logical AND $8A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	mvn $B9,$1F		; 54 1F B9 ; Move block negative $B9,$1F [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sta $F2EE.w,X		; 9D EE F2 ; Store accumulator to $F2EE.w,X [Reads: Accumulator, X Index]
	and ($44.b,S),Y		; 33 44 ; AND accumulator (stack relative indirect indexed) ($44.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($DB.b,X)		; 41 DB ; Exclusive OR accumulator with memory ($DB.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $01		; D0 01 ; Branch if not equal to $D0, $01 [Flow: branch]
	ora ($FF.b),Y		; 11 FF ; OR accumulator with memory ($FF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($54.b,S),Y		; 13 54 ; OR accumulator (stack relative indirect indexed) ($54.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $EA		; 30 EA ; Branch if minus to $30, $EA [Flow: branch]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	inc $22E0.w		; EE E0 22 ; Increment $22E0.w [Flags: NZ]
	bit $53.b,X		; 34 53 ; Test bits $53.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $01CE.w,X		; FD CE 01 ; Subtract with carry $01CE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($1F.b,X)		; 01 1F ; Logical OR ($1F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc ($44.b)		; F2 44 ; Subtract with carry (indirect) ($44.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	eor $8A.b,S		; 43 8A ; Exclusive OR accumulator with stack relative $8A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	dec $F1FF.w,X		; DE FF F1 ; Decrement memory $F1FF.w,X [Reads: X Index] [Flags: NZ]
	and ($45.b,S),Y		; 33 45 ; AND accumulator (stack relative indirect indexed) ($45.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $DD8A.w,X		; 1E 8A DD ; Arithmetic shift left $DD8A.w,X [Reads: X Index] [Flags: NCZ]
	sbc ($20.b,X)		; E1 20 ; Subtract with carry ($20.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $52.b,X		; 35 52 ; Logical AND $52.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	asl $B98A.w		; 0E 8A B9 ; Arithmetic shift left $B98A.w [Flags: NCZ]
	ldx $F0FF.w,Y		; BE FF F0 ; Load X register $F0FF.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ora ($35.b)		; 12 35 ; OR accumulator with memory (indirect) ($35.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cmp $E08A.w,X		; DD 8A E0 ; Compare accumulator $E08A.w,X [Reads: X Index] [Flags: NCZ]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($2F.b,S),Y		; 53 2F ; XOR accumulator (stack relative indirect indexed) ($2F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	.db $F0, $0F		; F0 0F ; Branch if equal to $F0, $0F [Flow: branch]
	ora ($12.b),Y		; 11 12 ; OR accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $0D.b,S		; 43 0D ; Exclusive OR accumulator with stack relative $0D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $11108A.l		; EF 8A 10 11 ; Subtract with carry (long) $11108A.l [Writes: Accumulator] [Flags: NCVZ]
	ora $314503.l		; 0F 03 45 31 ; OR accumulator with memory (long) $314503.l [Writes: Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	stz $CE7A.w		; 9C 7A CE ; Store zero to $CE7A.w
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $56.b,S		; 23 56 ; AND accumulator with stack relative $56.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $02BD.w,X		; 3E BD 02 ; Rotate left $02BD.w,X [Reads: X Index] [Flags: NCZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor ($FC.b,S),Y		; 53 FC ; XOR accumulator (stack relative indirect indexed) ($FC.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	lda $127A.w,X		; BD 7A 12 ; Load $127A.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $22		; 10 22 ; Branch if plus to $10, $22 [Flow: branch]
	and ($30.b,S),Y		; 33 30 ; AND accumulator (stack relative indirect indexed) ($30.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $2202.w		; EE 02 22 ; Increment $2202.w [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $F1.b		; 00 F1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $34.b,S		; 23 34 ; AND accumulator with stack relative $34.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $BCAA.w,X		; 3E AA BC ; Rotate left $BCAA.w,X [Reads: X Index] [Flags: NCZ]
	sbc ($7A.b,X)		; E1 7A ; Subtract with carry ($7A.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $42, $11		; 42 11 ; Reserved instruction
	and ($10.b),Y		; 31 10 ; AND accumulator with memory ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	inc $43F2.w,X		; FE F2 43 ; Increment memory $43F2.w,X [Reads: X Index] [Flags: NZ]
	ora ($8A.b),Y		; 11 8A ; OR accumulator with memory ($8A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $304403.l		; 0F 03 44 30 ; OR accumulator with memory (long) $304403.l [Writes: Accumulator] [Flags: NZ]
	wai		; CB ; Wait for interrupt
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	cmp $127A21.l		; CF 21 7A 12 ; Compare accumulator (long) $127A21.l [Reads: Accumulator] [Flags: NCZ]
	.db $42, $00		; 42 00 ; Reserved instruction
	inc $66D1.w,X		; FE D1 66 ; Increment memory $66D1.w,X [Reads: X Index] [Flags: NZ]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($44.b),Y		; F1 44 ; Subtract with carry ($44.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($FB.b)		; 32 FB ; AND accumulator with memory (indirect) ($FB.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy $02CD.w		; AC CD 02 ; Load $02CD.w into Y register [Writes: Y Index] [Flags: NZ]
	ora ($7A.b),Y		; 11 7A ; OR accumulator with memory ($7A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $1F.b,S		; 23 1F ; AND accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $26FF.w,X		; DE FF 26 ; Decrement memory $26FF.w,X [Reads: X Index] [Flags: NZ]
	adc ($0F.b)		; 72 0F ; Add with carry (indirect) ($0F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $8A		; F0 8A ; Branch if equal to $F0, $8A [Flow: branch]
	and $33.b,S		; 23 33 ; AND accumulator with stack relative $33.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $CCAB.w		; 2D AB CC ; Logical AND $CCAB.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc ($11.b,X)		; E1 11 ; Subtract with carry ($11.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($8A.b)		; 12 8A ; OR accumulator with memory (indirect) ($8A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $FF		; 10 FF ; Branch if plus to $10, $FF [Flow: branch]
	sbc $004302.l,X		; FF 02 43 00 ; Subtract with carry (long,X) $004302.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	bit $2F.b,X		; 34 2F ; Test bits $2F.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	ldy $12DF.w,X		; BC DF 12 ; Load Y register $12DF.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ora ($21.b),Y		; 11 21 ; OR accumulator with memory ($21.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $F1FF.w,X		; FE FF F1 ; Increment memory $F1FF.w,X [Reads: X Index] [Flags: NZ]
	bit $21.b,X		; 34 21 ; Test bits $21.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($8A.b,S),Y		; 33 8A ; AND accumulator (stack relative indirect indexed) ($8A.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($FB.b),Y		; 31 FB ; AND accumulator with memory ($FB.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ldy $01DD.w,X		; BC DD 01 ; Load Y register $01DD.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	.db $10, $22		; 10 22 ; Branch if plus to $10, $22 [Flow: branch]
	ora $F0ED8A.l,X		; 1F 8A ED F0 ; Logical OR long $F0ED8A.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	bit $41.b,X		; 34 41 ; Test bits $41.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora ($FE.b),Y		; 11 FE ; OR accumulator with memory ($FE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($31.b,S),Y		; 13 31 ; OR accumulator (stack relative indirect indexed) ($31.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $DDBB.w,X		; 1E BB DD ; Arithmetic shift left $DDBB.w,X [Reads: X Index] [Flags: NCZ]
	cpx #$11.b		; E0 11 ; Compare #$11.b with X register [Reads: X Index] [Flags: NCZ]
	jsl $8AEE1F.l		; 22 1F EE 8A ; Jump to subroutine long $8AEE1F.l [Writes: Stack Pointer] [Flow: call]
	sbc $115314.l		; EF 14 53 11 ; Subtract with carry (long) $115314.l [Writes: Accumulator] [Flags: NCVZ]
	ora $0F32F2.l		; 0F F2 32 0F ; OR accumulator with memory (long) $0F32F2.l [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$EFCD]		; DC CD EF ; Jump long indirect [$EFCD] [Flow: jump]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $FE		; 30 FE ; Branch if minus to $30, $FE [Flow: branch]
	cmp $038A.w,X		; DD 8A 03 ; Compare accumulator $038A.w,X [Reads: X Index] [Flags: NCZ]
	eor $21.b,X		; 55 21 ; Exclusive OR accumulator with memory $21.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $E0		; 10 E0 ; Branch if plus to $10, $E0 [Flow: branch]
	and $10.b,S		; 23 10 ; AND accumulator with stack relative $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $BC8A.w		; ED 8A BC ; Subtract $BC8A.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cpx #$FF.b		; E0 FF ; Compare #$FF.b with X register [Reads: X Index] [Flags: NCZ]
	sbc ($32.b)		; F2 32 ; Subtract with carry (indirect) ($32.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	asl $E2DC.w		; 0E DC E2 ; Arithmetic shift left $E2DC.w [Flags: NCZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $32.b		; 65 32 ; Add $32.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jsr $12FE.w		; 20 FE 12 ; Jump to subroutine at $12FE.w [Writes: Stack Pointer] [Flow: call]
	.db $30, $ED		; 30 ED ; Branch if minus to $30, $ED [Flow: branch]
	jmp.w [$DF8A]		; DC 8A DF ; Jump long indirect [$DF8A] [Flow: jump]
	ora $1F23F0.l		; 0F F0 23 1F ; OR accumulator with memory (long) $1F23F0.l [Writes: Accumulator] [Flags: NZ]
	sbc $46CF.w		; ED CF 46 ; Subtract $46CF.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $31.b,S		; 43 31 ; Exclusive OR accumulator with stack relative $31.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $2201.w,X		; FE 01 22 ; Increment memory $2201.w,X [Reads: X Index] [Flags: NZ]
	asl $BEDC.w		; 0E DC BE ; Arithmetic shift left $BEDC.w [Flags: NCZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $30.b,S		; 03 30 ; OR accumulator with stack relative $30.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $06DD.w,X		; DE DD 06 ; Decrement memory $06DD.w,X [Reads: X Index] [Flags: NZ]
	stz $8A.b,X		; 74 8A ; Store zero to $8A.b,X [Reads: X Index]
	jsl $22E01E.l		; 22 1E E0 22 ; Jump to subroutine long $22E01E.l [Writes: Stack Pointer] [Flow: call]
	ora $F1CDDD.l		; 0F DD CD F1 ; OR accumulator with memory (long) $F1CDDD.l [Writes: Accumulator] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	ora $FE21F1.l		; 0F F1 21 FE ; OR accumulator with memory (long) $FE21F1.l [Writes: Accumulator] [Flags: NZ]
	inc $42F2.w,X		; FE F2 42 ; Increment memory $42F2.w,X [Reads: X Index] [Flags: NZ]
	jsl $E01E8A.l		; 22 8A 1E E0 ; Jump to subroutine long $E01E8A.l [Writes: Stack Pointer] [Flow: call]
	ora ($1F.b)		; 12 1F ; OR accumulator with memory (indirect) ($1F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $E0CC.w		; ED CC E0 ; Subtract $E0CC.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ora $33E08A.l,X		; 1F 8A E0 33 ; Logical OR long $33E08A.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $D1DC.w		; 0E DC D1 ; Arithmetic shift left $D1DC.w [Flags: NCZ]
	ror $53.b		; 66 53 ; Rotate right $53.b [Reads: Direct Page] [Flags: NCZ]
	jsr $EF8A.w		; 20 8A EF ; Jump to subroutine at $EF8A.w [Writes: Stack Pointer] [Flow: call]
	cop $11.b		; 02 11 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $D0CC.w		; ED CC D0 ; Subtract $D0CC.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	jsr $8AEE.w		; 20 EE 8A ; Jump to subroutine at $8AEE.w [Writes: Stack Pointer] [Flow: call]
	ora ($1F.b,S),Y		; 13 1F ; OR accumulator (stack relative indirect indexed) ($1F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $36CF.w		; ED CF 36 ; Subtract $36CF.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	adc $30.b		; 65 30 ; Add $30.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $11028A.l		; EF 8A 02 11 ; Subtract with carry (long) $11028A.l [Writes: Accumulator] [Flags: NCVZ]
	inc $DECC.w,X		; FE CC DE ; Increment memory $DECC.w,X [Reads: X Index] [Flags: NZ]
	ora ($0E.b,X)		; 01 0E ; Logical OR ($0E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $8A.b		; 02 8A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $FD		; 10 FD ; Branch if plus to $10, $FD [Flow: branch]
	dec $6525.w		; CE 25 65 ; Decrement $6525.w [Flags: NZ]
	and ($0E.b)		; 32 0E ; AND accumulator with memory (indirect) ($0E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc ($8A.b,X)		; E1 8A ; Subtract with carry ($8A.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($FF.b),Y		; 31 FF ; AND accumulator with memory ($FF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ldx $0E11.w,Y		; BE 11 0E ; Load X register $0E11.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	sbc ($20.b),Y		; F1 20 ; Subtract with carry ($20.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $03DD.w,X		; FE DD 03 ; Increment memory $03DD.w,X [Reads: X Index] [Flags: NZ]
	lsr $62.b,X		; 56 62 ; Logical shift right $62.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc $8A120F.l,X		; FF 0F 12 8A ; Subtract with carry (long,X) $8A120F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $F1BCED.l,X		; 1F ED BC F1 ; Logical OR long $F1BCED.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $FD8AFF.l		; 0F FF 8A FD ; OR accumulator with memory (long) $FD8AFF.l [Writes: Accumulator] [Flags: NZ]
	sbc ($54.b,S),Y		; F3 54 ; Subtract with carry (stack relative indirect indexed) ($54.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	mvn $FF,$1F		; 54 1F FF ; Move block negative $FF,$1F [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cop $2F.b		; 02 2F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $D0DC.w		; ED DC D0 ; Subtract $D0DC.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $01		; 10 01 ; Branch if plus to $10, $01 [Flow: branch]
	ora $8AEEEE.l,X		; 1F EE EE 8A ; Logical OR long $8AEEEE.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cop $34.b		; 02 34 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvn $0F,$10		; 54 10 0F ; Move block negative $0F,$10 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora ($20.b,X)		; 01 20 ; Logical OR ($20.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $DB8A.w		; 0E 8A DB ; Arithmetic shift left $DB8A.w [Flags: NCZ]
	dec $1011.w		; CE 11 10 ; Decrement $1011.w [Flags: NZ]
	ora $12EEFE.l		; 0F FE EE 12 ; OR accumulator with memory (long) $12EEFE.l [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $54.b,S		; 23 54 ; AND accumulator with stack relative $54.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($0F.b),Y		; 11 0F ; OR accumulator with memory ($0F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($11.b),Y		; F1 11 ; Subtract with carry ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $9A7ADC.l,X		; 1F DC 7A 9A ; Logical OR long $9A7ADC.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($43.b)		; D2 43 ; Compare accumulator (indirect) ($43.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora $23B0B9.l		; 0F B9 B0 23 ; OR accumulator with memory (long) $23B0B9.l [Writes: Accumulator] [Flags: NZ]
	lsr $8A.b		; 46 8A ; Logical shift right $8A.b [Reads: Direct Page] [Flags: NCZ]
	and ($31.b,S),Y		; 33 31 ; AND accumulator (stack relative indirect indexed) ($31.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $20110F.l,X		; 1F 0F 11 20 ; Logical OR long $20110F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$7ADD]		; DC DD 7A ; Jump long indirect [$7ADD] [Flow: jump]
	lda $BA2D56.l		; AF 56 2D BA ; Load long $BA2D56.l into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy $6427.w		; AC 27 64 ; Load $6427.w into Y register [Writes: Y Index] [Flags: NZ]
	eor [$8A.b]		; 47 8A ; Exclusive OR accumulator with memory (long) [$8A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $0F02.w		; 20 02 0F ; Jump to subroutine at $0F02.w [Writes: Stack Pointer] [Flow: call]
	sbc ($22.b),Y		; F1 22 ; Subtract with carry ($22.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($DECD.w,X)		; FC CD DE ; Jump to subroutine indirect indexed ($DECD.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	bit $2E.b		; 24 2E ; Test bits $2E.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cmp $14DD.w,X		; DD DD 14 ; Compare accumulator $14DD.w,X [Reads: X Index] [Flags: NCZ]
	and ($33.b)		; 32 33 ; AND accumulator with memory (indirect) ($33.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $8A		; 10 8A ; Branch if plus to $10, $8A [Flow: branch]
	ora ($0F.b),Y		; 11 0F ; OR accumulator with memory ($0F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $DECD.w		; 0E CD DE ; Arithmetic shift left $DECD.w [Flags: NCZ]
	ora $8A.b,S		; 03 8A ; OR accumulator with stack relative $8A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor ($CB.b,X)		; 41 CB ; Exclusive OR accumulator with memory ($CB.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	dec $54F3.w,X		; DE F3 54 ; Decrement memory $54F3.w,X [Reads: X Index] [Flags: NZ]
	jsl $8A0010.l		; 22 10 00 8A ; Jump to subroutine long $8A0010.l [Writes: Stack Pointer] [Flow: call]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	ora ($1F.b),Y		; 11 1F ; OR accumulator with memory ($1F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $F3DD.w		; ED DD F3 ; Subtract $F3DD.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	eor ($8A.b,X)		; 41 8A ; Exclusive OR accumulator with memory ($8A.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$03BD]		; DC BD 03 ; Jump long indirect [$03BD] [Flow: jump]
	mvp $11,$32		; 44 32 11 ; Move block positive $11,$32 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sbc $0F8A02.l,X		; FF 02 8A 0F ; Subtract with carry (long,X) $0F8A02.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $E1EE.w		; ED EE E1 ; Subtract $E1EE.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	eor $EA.b,S		; 43 EA ; Exclusive OR accumulator with stack relative $EA.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldx $4501.w,Y		; BE 01 45 ; Load X register $4501.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	.db $42, $10		; 42 10 ; Reserved instruction
	sbc $8A10F1.l,X		; FF F1 10 8A ; Subtract with carry (long,X) $8A10F1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($10.b),Y		; F1 10 ; Subtract with carry ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $42E2EC.l,X		; FF EC E2 42 ; Subtract with carry (long,X) $42E2EC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ldy $038A.w,X		; BC 8A 03 ; Load Y register $038A.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	eor $43.b,S		; 43 43 ; Exclusive OR accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	brk $8A.b		; 00 8A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $32E0.w,X		; FE E0 32 ; Increment memory $32E0.w,X [Reads: X Index] [Flags: NZ]
	jsr ($03BC.w,X)		; FC BC 03 ; Jump to subroutine indirect indexed ($03BC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($43.b,S),Y		; 33 43 ; AND accumulator (stack relative indirect indexed) ($43.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $01FE00.l,X		; 1F 00 FE 01 ; Logical OR long $01FE00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0F		; F0 0F ; Branch if equal to $F0, $0F [Flow: branch]
	.db $F0, $11		; F0 11 ; Branch if equal to $F0, $11 [Flow: branch]
	ora $F2BC.w		; 0D BC F2 ; Logical OR $F2BC.w with accumulator [Writes: Accumulator] [Flags: NZ]
	bit $8A.b,X		; 34 8A ; Test bits $8A.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $010E01.l		; 0F 01 0E 01 ; OR accumulator with memory (long) $010E01.l [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $FD1000.l		; 0F 00 10 FD ; OR accumulator with memory (long) $FD1000.l [Writes: Accumulator] [Flags: NZ]
	cmp $34F2.w		; CD F2 34 ; Compare $34F2.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	and ($6A.b,S),Y		; 33 6A ; AND accumulator (stack relative indirect indexed) ($6A.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $FA16.w		; 0D 16 FA ; Logical OR $FA16.w with accumulator [Writes: Accumulator] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	sbc ($FB.b,X)		; E1 FB ; Subtract with carry ($FB.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	pea $7A2E.w		; F4 2E 7A ; Push absolute address $7A2E.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	bit $1C.b		; 24 1C ; Test bits $1C.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cpy $059A.w		; CC 9A 05 ; Compare $059A.w with Y register [Reads: Y Index] [Flags: NCZ]
	lsr $53.b,X		; 56 53 ; Logical shift right $53.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $7A.b		; 00 7A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($2F.b,S),Y		; 13 2F ; OR accumulator (stack relative indirect indexed) ($2F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	sbc ($FE.b,X)		; E1 FE ; Subtract with carry ($FE.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $8A.b		; 26 8A ; Rotate left $8A.b [Reads: Direct Page] [Flags: NCZ]
	asl $EECE.w,X		; 1E CE EE ; Arithmetic shift left $EECE.w,X [Reads: X Index] [Flags: NCZ]
	sbc ($32.b,S),Y		; F3 32 ; Subtract with carry (stack relative indirect indexed) ($32.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	jsl $7A010F.l		; 22 0F 01 7A ; Jump to subroutine long $7A010F.l [Writes: Stack Pointer] [Flow: call]
	eor ($CA.b,X)		; 41 CA ; Exclusive OR accumulator with memory ($CA.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $1201EE.l		; EF EE 01 12 ; Subtract with carry (long) $1201EE.l [Writes: Accumulator] [Flags: NCVZ]
	eor $3C.b		; 45 3C ; Exclusive OR $3C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldy $12E0.w,X		; BC E0 12 ; Load Y register $12E0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	and ($2F.b,S),Y		; 33 2F ; AND accumulator (stack relative indirect indexed) ($2F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $11		; F0 11 ; Branch if equal to $F0, $11 [Flow: branch]
	ora ($8A.b)		; 12 8A ; OR accumulator with memory (indirect) ($8A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $E0DE.w,X		; FE DE E0 ; Increment memory $E0DE.w,X [Reads: X Index] [Flags: NZ]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($2D.b,S),Y		; 33 2D ; AND accumulator (stack relative indirect indexed) ($2D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	cmp ($55.b,X)		; C1 55 ; Compare accumulator ($55.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	adc $3E.b		; 65 3E ; Add $3E.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$10.b		; E0 10 ; Compare #$10.b with X register [Reads: X Index] [Flags: NCZ]
	and ($1C.b,S),Y		; 33 1C ; AND accumulator (stack relative indirect indexed) ($1C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dec $F0EF.w,X		; DE EF F0 ; Decrement memory $F0EF.w,X [Reads: X Index] [Flags: NZ]
	ora ($34.b)		; 12 34 ; OR accumulator with memory (indirect) ($34.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $D1AB.w		; 2D AB D1 ; Logical AND $D1AB.w with accumulator [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $22.b		; 45 22 ; Exclusive OR $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $1110EF.l,X		; 1F EF 10 11 ; Logical OR long $1110EF.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $DE8ADD.l		; 2F DD 8A DE ; AND accumulator with memory (long) $DE8ADD.l [Writes: Accumulator] [Flags: NZ]
	sbc ($13.b),Y		; F1 13 ; Subtract with carry ($13.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	mvp $BB,$0E		; 44 0E BB ; Move block positive $BB,$0E [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cmp ($44.b,X)		; C1 44 ; Compare accumulator ($44.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($1F.b)		; 32 1F ; AND accumulator with memory (indirect) ($1F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $1112F0.l,X		; FF F0 12 11 ; Subtract with carry (long,X) $1112F0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $8ACD.w		; ED CD 8A ; Subtract $8ACD.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cpx #$23.b		; E0 23 ; Compare #$23.b with X register [Reads: X Index] [Flags: NCZ]
	eor $1E.b,S		; 43 1E ; Exclusive OR accumulator with stack relative $1E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	wai		; CB ; Wait for interrupt
	cpy #$45.b		; C0 45 ; Compare #$45.b with Y register [Reads: Y Index] [Flags: NCZ]
	eor $8A.b,S		; 43 8A ; Exclusive OR accumulator with stack relative $8A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $00FFEF.l,X		; 1F EF FF 00 ; Logical OR long $00FFEF.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($0C.b)		; 12 0C ; OR accumulator with memory (indirect) ($0C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dec $8AEF.w		; CE EF 8A ; Decrement $8AEF.w [Flags: NZ]
	trb $54.b		; 14 54 ; Test and reset bits $54.b [Reads: Accumulator] [Flags: Z]
	asl $C0CC.w		; 0E CC C0 ; Arithmetic shift left $C0CC.w [Flags: NCZ]
	bit $43.b,X		; 34 43 ; Test bits $43.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora $F0FF8A.l,X		; 1F 8A FF F0 ; Logical OR long $F0FF8A.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $CD1D02.l		; 0F 02 1D CD ; OR accumulator with memory (long) $CD1D02.l [Writes: Accumulator] [Flags: NZ]
	sbc $548A13.l		; EF 13 8A 54 ; Subtract with carry (long) $548A13.l [Writes: Accumulator] [Flags: NCVZ]
	ora $F1BC.w,X		; 1D BC F1 ; OR accumulator with memory $F1BC.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	trb $53.b		; 14 53 ; Test and reset bits $53.b [Reads: Accumulator] [Flags: Z]
	ora $FF8A0F.l		; 0F 0F 8A FF ; OR accumulator with memory (long) $FF8A0F.l [Writes: Accumulator] [Flags: NZ]
	ora $CE1EF2.l		; 0F F2 1E CE ; OR accumulator with memory (long) $CE1EF2.l [Writes: Accumulator] [Flags: NZ]
	dec $5305.w,X		; DE 05 53 ; Decrement memory $5305.w,X [Reads: X Index] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $F0DD.w		; 0E DD F0 ; Arithmetic shift left $F0DD.w [Flags: NCZ]
	ora ($44.b)		; 12 44 ; OR accumulator with memory (indirect) ($44.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $F0		; 10 F0 ; Branch if plus to $10, $F0 [Flow: branch]
	sbc $00E08A.l,X		; FF 8A E0 00 ; Subtract with carry (long,X) $00E08A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $03EEED.l		; 0F ED EE 03 ; OR accumulator with memory (long) $03EEED.l [Writes: Accumulator] [Flags: NZ]
	eor ($0E.b,S),Y		; 53 0E ; XOR accumulator (stack relative indirect indexed) ($0E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	cop $13.b		; 02 13 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $2F.b,X		; 76 2F ; Rotate right $2F.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($FD.b),Y		; 11 FD ; OR accumulator with memory ($FD.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $DF0E7A.l,X		; DF 7A 0E DF ; Compare accumulator (long,X) $DF0E7A.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	jsr ($15AD.w,X)		; FC AD 15 ; Jump to subroutine indirect indexed ($15AD.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	stz $1D.b		; 64 1D ; Store zero to $1D.b
	cmp $147A.w		; CD 7A 14 ; Compare $147A.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsr $3125.w		; 20 25 31 ; Jump to subroutine at $3125.w [Writes: Stack Pointer] [Flow: call]
	ora ($0E.b)		; 12 0E ; OR accumulator with memory (indirect) ($0E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $7AFC.w		; EE FC 7A ; Increment $7AFC.w [Flags: NZ]
	lda $CC10.w,X		; BD 10 CC ; Load $CC10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $52.b		; 04 52 ; Test and set bits $52.b [Reads: Accumulator] [Flags: Z]
	sbc $2201.w		; ED 01 22 ; Subtract $2201.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	and ($11.b),Y		; 31 11 ; AND accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $DD2112.l		; 22 12 21 DD ; Jump to subroutine long $DD2112.l [Writes: Stack Pointer] [Flow: call]
	sbc $7AAB.w		; ED AB 7A ; Subtract $7AAB.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cop $EC.b		; 02 EC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $2E.b,X		; 15 2E ; OR accumulator with memory $2E.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $305402.l		; EF 02 54 30 ; Subtract with carry (long) $305402.l [Writes: Accumulator] [Flags: NCVZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	sbc $4303.w,X		; FD 03 43 ; Subtract with carry $4303.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($ED.b),Y		; 31 ED ; AND accumulator with memory ($ED.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $D2AA.w,X		; DD AA D2 ; Compare accumulator $D2AA.w,X [Reads: X Index] [Flags: NCZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	ora $CF0C13.l,X		; 1F 13 0C CF ; Logical OR long $CF0C13.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rol $75.b		; 26 75 ; Rotate left $75.b [Reads: Direct Page] [Flags: NCZ]
	and ($DB.b,X)		; 21 DB ; Logical AND ($DB.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	cmp ($54.b,S),Y		; D3 54 ; Compare accumulator (stack relative indirect indexed) ($54.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	jsl $BBBA1F.l		; 22 1F BA BB ; Jump to subroutine long $BBBA1F.l [Writes: Stack Pointer] [Flow: call]
	cmp $108A43.l		; CF 43 8A 10 ; Compare accumulator (long) $108A43.l [Reads: Accumulator] [Flags: NCZ]
	sbc $24DF.w,X		; FD DF 24 ; Subtract with carry $24DF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $20.b,S		; 43 20 ; Exclusive OR accumulator with stack relative $20.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $8AE0.w		; ED E0 8A ; Subtract $8AE0.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	and ($11.b,S),Y		; 33 11 ; AND accumulator (stack relative indirect indexed) ($11.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($ED.b),Y		; 11 ED ; OR accumulator with memory ($ED.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $14DF.w		; CD DF 14 ; Compare $14DF.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsr $DD8A.w		; 20 8A DD ; Jump to subroutine at $DD8A.w [Writes: Stack Pointer] [Flow: call]
	cmp $206425.l		; CF 25 64 20 ; Compare accumulator (long) $206425.l [Reads: Accumulator] [Flags: NCZ]
	cpx $34CF.w		; EC CF 34 ; Compare $34CF.w with X register [Reads: X Index] [Flags: NCZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsr $EC21.w		; 20 21 EC ; Jump to subroutine at $EC21.w [Writes: Stack Pointer] [Flow: call]
	dec $03EE.w,X		; DE EE 03 ; Decrement memory $03EE.w,X [Reads: X Index] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cpy $DE8A.w		; CC 8A DE ; Compare $DE8A.w with Y register [Reads: Y Index] [Flags: NCZ]
	and $65.b		; 25 65 ; Logical AND $65.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	jmp.w [$15CD]		; DC CD 15 ; Jump long indirect [$15CD] [Flow: jump]
	eor ($8A.b,X)		; 41 8A ; Exclusive OR accumulator with memory ($8A.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cop $FC.b		; 02 FC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $50F4ED.l		; CF ED F4 50 ; Compare accumulator (long) $50F4ED.l [Reads: Accumulator] [Flags: NCZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	cmp $66258A.l		; CF 8A 25 66 ; Compare accumulator (long) $66258A.l [Reads: Accumulator] [Flags: NCZ]
	.db $50, $CC		; 50 CC ; Branch if overflow clear to $50, $CC [Flow: branch]
	cmp $53F3.w,X		; DD F3 53 ; Compare accumulator $53F3.w,X [Reads: X Index] [Flags: NCZ]
	ora $DD0E8A.l,X		; 1F 8A 0E DD ; Logical OR long $DD0E8A.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $42F2.w		; EE F2 42 ; Increment $42F2.w [Flags: NZ]
	cmp $35BE.w,Y		; D9 BE 35 ; Compare accumulator $35BE.w,Y [Reads: Y Index] [Flags: NCZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ror $51.b,X		; 76 51 ; Rotate right $51.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	wai		; CB ; Wait for interrupt
	dec $34F1.w,X		; DE F1 34 ; Decrement memory $34F1.w,X [Reads: X Index] [Flags: NZ]
	jsr $8AFF.w		; 20 FF 8A ; Jump to subroutine at $8AFF.w [Writes: Stack Pointer] [Flow: call]
	sbc $11DF.w		; ED DF 11 ; Subtract $11DF.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	and ($D9.b,X)		; 21 D9 ; Logical AND ($D9.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda $8A6634.l,X		; BF 34 66 8A ; Load long $8A6634.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $EB, $CE		; 62 EB CE ; Push effective relative address $62, $EB, $CE [Writes: Stack Pointer]
	cpx #$25.b		; E0 25 ; Compare #$25.b with X register [Reads: X Index] [Flags: NCZ]
	.db $30, $EF		; 30 EF ; Branch if minus to $30, $EF [Flow: branch]
	inc $DF8A.w,X		; FE 8A DF ; Increment memory $DF8A.w,X [Reads: X Index] [Flags: NZ]
	ora ($0F.b)		; 12 0F ; OR accumulator with memory (indirect) ($0F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx $35AD.w		; EC AD 35 ; Compare $35AD.w with X register [Reads: X Index] [Flags: NCZ]
	eor $63.b,X		; 55 63 ; Exclusive OR accumulator with memory $63.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $DFCC.w		; 0D CC DF ; Logical OR $DFCC.w with accumulator [Writes: Accumulator] [Flags: NZ]
	bit $31.b		; 24 31 ; Test bits $31.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	inc $EFF0.w,X		; FE F0 EF ; Increment memory $EFF0.w,X [Reads: X Index] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($FD.b)		; 12 FD ; OR accumulator with memory (indirect) ($FD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $24CE.w,X		; DD CE 24 ; Compare accumulator $24CE.w,X [Reads: X Index] [Flags: NCZ]
	eor $53.b		; 45 53 ; Exclusive OR $53.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $EFCC8A.l,X		; 1F 8A CC EF ; Logical OR long $EFCC8A.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($43.b)		; F2 43 ; Subtract with carry (indirect) ($43.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inc $F0F0.w,X		; FE F0 F0 ; Increment memory $F0F0.w,X [Reads: X Index] [Flags: NZ]
	ora ($8A.b),Y		; 11 8A ; OR accumulator with memory ($8A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsr ($EECD.w,X)		; FC CD EE ; Jump to subroutine indirect indexed ($EECD.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora ($44.b,S),Y		; 13 44 ; OR accumulator (stack relative indirect indexed) ($44.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor ($20.b,S),Y		; 53 20 ; XOR accumulator (stack relative indirect indexed) ($20.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr ($DD8A.w,X)		; FC 8A DD ; Jump to subroutine indirect indexed ($DD8A.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc ($42.b),Y		; F1 42 ; Subtract with carry ($42.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $0001.w,X		; FE 01 00 ; Increment memory $0001.w,X [Reads: X Index] [Flags: NZ]
	jsl $AC8AEB.l		; 22 EB 8A AC ; Jump to subroutine long $AC8AEB.l [Writes: Stack Pointer] [Flow: call]
	sbc ($11.b),Y		; F1 11 ; Subtract with carry ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $42.b,X		; 34 42 ; Test bits $42.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	jsl $8ADD0E.l		; 22 0E DD 8A ; Jump to subroutine long $8ADD0E.l [Writes: Stack Pointer] [Flow: call]
	cpx #$22.b		; E0 22 ; Compare #$22.b with X register [Reads: X Index] [Flags: NCZ]
	ora $3112FF.l,X		; 1F FF 12 31 ; Logical OR long $3112FF.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	nop		; EA ; No operation
	ldy $D17A.w		; AC 7A D1 ; Load $D17A.w into Y register [Writes: Y Index] [Flags: NZ]
	mvp $54,$56		; 44 56 54 ; Move block positive $54,$56 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	lsr $3E.b		; 46 3E ; Logical shift right $3E.b [Reads: Direct Page] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	dec $008A.w,X		; DE 8A 00 ; Decrement memory $008A.w,X [Reads: X Index] [Flags: NZ]
	ora ($FF.b),Y		; 11 FF ; OR accumulator with memory ($FF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $32.b		; 14 32 ; Test and reset bits $32.b [Reads: Accumulator] [Flags: Z]
	nop		; EA ; No operation
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	sbc ($7A.b,X)		; E1 7A ; Subtract with carry ($7A.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $33.b		; 65 33 ; Add $33.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and ($45.b,S),Y		; 33 45 ; AND accumulator (stack relative indirect indexed) ($45.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $62, $DA, $BE		; 62 DA BE ; Push effective relative address $62, $DA, $BE [Writes: Stack Pointer]
	sbc $00018A.l		; EF 8A 01 00 ; Subtract with carry (long) $00018A.l [Writes: Accumulator] [Flags: NCVZ]
	ora ($42.b,S),Y		; 13 42 ; OR accumulator (stack relative indirect indexed) ($42.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	cmp ($23.b),Y		; D1 23 ; Compare accumulator ($23.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	.db $42, $02		; 42 02 ; Reserved instruction
	eor $65.b		; 45 65 ; Exclusive OR $65.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $CDBB.w		; 1C BB CD ; Test and reset bits $CDBB.w [Reads: Accumulator] [Flags: Z]
	sbc ($8A.b)		; F2 8A ; Subtract with carry (indirect) ($8A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $03		; 10 03 ; Branch if plus to $10, $03 [Flow: branch]
	mvn $9A,$EB		; 54 EB 9A ; Move block negative $9A,$EB [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cmp ($22.b),Y		; D1 22 ; Compare accumulator ($22.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	and ($8A.b,X)		; 21 8A ; Logical AND ($8A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $DE,$1F		; 44 1F DE ; Move block positive $DE,$1F [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	inc $10E1.w		; EE E1 10 ; Increment $10E1.w [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($53.b,S),Y		; 13 53 ; OR accumulator (stack relative indirect indexed) ($53.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	cpy #$33.b		; C0 33 ; Compare #$33.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $10, $FF		; 10 FF ; Branch if plus to $10, $FF [Flow: branch]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $44.b,S		; 03 44 ; OR accumulator with stack relative $44.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $30, $ED		; 30 ED ; Branch if minus to $30, $ED [Flow: branch]
	sbc $21E0.w		; ED E0 21 ; Subtract $21E0.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cop $8A.b		; 02 8A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvn $BB,$FC		; 54 FC BB ; Move block negative $BB,$FC [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cpy #$22.b		; C0 22 ; Compare #$22.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $10, $FE		; 10 FE ; Branch if plus to $10, $FE [Flow: branch]
	sbc ($8A.b)		; F2 8A ; Subtract with carry (indirect) ($8A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	eor $41.b,X		; 55 41 ; Exclusive OR accumulator with memory $41.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $DFED.w		; ED ED DF ; Subtract $DFED.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	and ($12.b,X)		; 21 12 ; Logical AND ($12.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor $8A.b,S		; 43 8A ; Exclusive OR accumulator with stack relative $8A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $C0BA.w,X		; 1E BA C0 ; Arithmetic shift left $C0BA.w,X [Reads: X Index] [Flags: NCZ]
	jsl $E2ED10.l		; 22 10 ED E2 ; Jump to subroutine long $E2ED10.l [Writes: Stack Pointer] [Flow: call]
	eor $8A.b		; 45 8A ; Exclusive OR $8A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor ($0D.b,S),Y		; 53 0D ; XOR accumulator (stack relative indirect indexed) ($0D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$12DF]		; DC DF 12 ; Jump long indirect [$12DF] [Flow: jump]
	ora ($33.b)		; 12 33 ; OR accumulator with memory (indirect) ($33.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $CFCB8A.l,X		; 1F 8A CB CF ; Logical OR long $CFCB8A.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($20.b)		; 12 20 ; OR accumulator with memory (indirect) ($20.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx $35E0.w		; EC E0 35 ; Compare $35E0.w with X register [Reads: X Index] [Flags: NCZ]
	stz $8A.b		; 64 8A ; Store zero to $8A.b
	asl $DEDC.w,X		; 1E DC DE ; Arithmetic shift left $DEDC.w,X [Reads: X Index] [Flags: NCZ]
	ora ($22.b),Y		; 11 22 ; OR accumulator with memory ($22.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($1F.b)		; 32 1F ; AND accumulator with memory (indirect) ($1F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx $CE8A.w		; EC 8A CE ; Compare $CE8A.w with X register [Reads: X Index] [Flags: NCZ]
	ora ($11.b)		; 12 11 ; OR accumulator with memory (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr ($24CF.w,X)		; FC CF 24 ; Jump to subroutine indirect indexed ($24CF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	eor $40.b,X		; 55 40 ; Exclusive OR accumulator with memory $40.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	dec $2300.w,X		; DE 00 23 ; Decrement memory $2300.w,X [Reads: X Index] [Flags: NZ]
	and ($1F.b)		; 32 1F ; AND accumulator with memory (indirect) ($1F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $8ACF.w		; ED CF 8A ; Subtract $8ACF.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ora ($F1.b),Y		; 11 F1 ; OR accumulator with memory ($F1.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $02CE.w		; 0E CE 02 ; Arithmetic shift left $02CE.w [Flags: NCZ]
	lsr $52.b		; 46 52 ; Logical shift right $52.b [Reads: Direct Page] [Flags: NCZ]
	jsr ($BC8A.w,X)		; FC 8A BC ; Jump to subroutine indirect indexed ($BC8A.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc ($33.b),Y		; F1 33 ; Subtract with carry ($33.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $42, $FE		; 42 FE ; Reserved instruction
	sbc $8A01DE.l,X		; FF DE 01 8A ; Subtract with carry (long,X) $8A01DE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $45E1.w,X		; DD E1 45 ; Compare accumulator $45E1.w,X [Reads: X Index] [Flags: NCZ]
	eor ($2D.b,S),Y		; 53 2D ; XOR accumulator (stack relative indirect indexed) ($2D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $13		; F0 13 ; Branch if equal to $F0, $13 [Flow: branch]
	eor $0F.b,S		; 43 0F ; Exclusive OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $0F01EE.l		; EF EE 01 0F ; Subtract with carry (long) $0F01EE.l [Writes: Accumulator] [Flags: NCVZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $24E0EE.l		; 0F EE E0 24 ; OR accumulator with memory (long) $24E0EE.l [Writes: Accumulator] [Flags: NZ]
	and ($31.b,S),Y		; 33 31 ; AND accumulator (stack relative indirect indexed) ($31.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	cmp $44138A.l		; CF 8A 13 44 ; Compare accumulator (long) $44138A.l [Reads: Accumulator] [Flags: NCZ]
	rol $FFDE.w		; 2E DE FF ; Rotate left $FFDE.w [Flags: NCZ]
	ora ($1F.b,X)		; 01 1F ; Logical OR ($1F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	inc $FF8A.w		; EE 8A FF ; Increment $FF8A.w [Flags: NZ]
	sbc $313312.l,X		; FF 12 33 31 ; Subtract with carry (long,X) $313312.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F2CE.w,X		; FD CE F2 ; Subtract with carry $F2CE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $40.b,X		; 35 40 ; Logical AND $40.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $01EF.w,X		; DD EF 01 ; Compare accumulator $01EF.w,X [Reads: X Index] [Flags: NCZ]
	.db $10, $FD		; 10 FD ; Branch if plus to $10, $FD [Flow: branch]
	inc $008A.w		; EE 8A 00 ; Increment $008A.w [Flags: NZ]
	ora ($22.b),Y		; 11 22 ; OR accumulator with memory ($22.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($2F.b)		; 12 2F ; OR accumulator with memory (indirect) ($2F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $24F0.w		; CD F0 24 ; Compare $24F0.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($FD.b)		; 52 FD ; Exclusive OR accumulator with memory (indirect) ($FD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $2002.w,X		; DD 02 20 ; Compare accumulator $2002.w,X [Reads: X Index] [Flags: NCZ]
	asl $F1CD.w		; 0E CD F1 ; Arithmetic shift left $F1CD.w [Flags: NCZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($12.b)		; 12 12 ; OR accumulator with memory (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $13E0.w		; ED E0 13 ; Subtract $13E0.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	mvp $1E,$8A		; 44 8A 1E ; Move block positive $1E,$8A [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cmp $21F2.w		; CD F2 21 ; Compare $21F2.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	asl $F1CC.w		; 0E CC F1 ; Arithmetic shift left $F1CC.w [Flags: NCZ]
	ora ($8A.b),Y		; 11 8A ; OR accumulator with memory ($8A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $0F0100.l		; 22 00 01 0F ; Jump to subroutine long $0F0100.l [Writes: Stack Pointer] [Flow: call]
	dec $4503.w,X		; DE 03 45 ; Decrement memory $4503.w,X [Reads: X Index] [Flags: NZ]
	and $E0DC8A.l		; 2F 8A DC E0 ; AND accumulator with memory (long) $E0DC8A.l [Writes: Accumulator] [Flags: NZ]
	and ($10.b),Y		; 31 10 ; AND accumulator with memory ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cpy #$11.b		; C0 11 ; Compare #$11.b with Y register [Reads: Y Index] [Flags: NCZ]
	and $8A.b,S		; 23 8A ; AND accumulator with stack relative $8A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $10, $F0		; 10 F0 ; Branch if plus to $10, $F0 [Flow: branch]
	.db $F0, $EE		; F0 EE ; Branch if equal to $F0, $EE [Flow: branch]
	sbc ($44.b)		; F2 44 ; Subtract with carry (indirect) ($44.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and ($FC.b)		; 32 FC ; AND accumulator with memory (indirect) ($FC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda $FD0033.l,X		; BF 33 00 FD ; Load long $FD0033.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda $3202.w,X		; BD 02 32 ; Load $3202.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($8A.b,X)		; 21 8A ; Logical AND ($8A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	inc $FE00.w,X		; FE 00 FE ; Increment memory $FE00.w,X [Reads: X Index] [Flags: NZ]
	sbc $0E5225.l,X		; FF 25 52 0E ; Subtract with carry (long,X) $0E5225.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $038A.w		; CD 8A 03 ; Compare $038A.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	and ($FE.b,X)		; 21 FE ; Logical AND ($FE.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpy $32F1.w		; CC F1 32 ; Compare $32F1.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora ($1F.b),Y		; 11 1F ; OR accumulator with memory ($1F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $14EF0E.l		; EF 0E EF 14 ; Subtract with carry (long) $14EF0E.l [Writes: Accumulator] [Flags: NCVZ]
	mvn $DB,$2F		; 54 2F DB ; Move block negative $DB,$2F [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sbc ($8A.b)		; F2 8A ; Subtract with carry (indirect) ($8A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and ($0F.b),Y		; 31 0F ; AND accumulator with memory ($0F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpy $23D0.w		; CC D0 23 ; Compare $23D0.w with Y register [Reads: Y Index] [Flags: NCZ]
	and ($1F.b,X)		; 21 1F ; Logical AND ($1F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $DE1F8A.l		; EF 8A 1F DE ; Subtract with carry (long) $DE1F8A.l [Writes: Accumulator] [Flags: NCVZ]
	cop $45.b		; 02 45 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($FC.b),Y		; 31 FC ; AND accumulator with memory ($FC.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $31		; D0 31 ; Branch if not equal to $D0, $31 [Flow: branch]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $13CEFC.l,X		; 1F FC CE 13 ; Logical OR long $13CEFC.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($00.b),Y		; 31 00 ; AND accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $ED8A00.l,X		; FF 00 8A ED ; Subtract with carry (long,X) $ED8A00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$36.b		; E0 36 ; Compare #$36.b with X register [Reads: X Index] [Flags: NCZ]
	eor ($0E.b)		; 52 0E ; Exclusive OR accumulator with memory (indirect) ($0E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $2F23.w		; CD 23 2F ; Compare $2F23.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $13CD.w,X		; FD CD 13 ; Subtract with carry $13CD.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($00.b,X)		; 21 00 ; Logical AND ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $8A0EF1.l,X		; FF F1 0E 8A ; Subtract with carry (long,X) $8A0EF1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $5414.w,X		; DE 14 54 ; Decrement memory $5414.w,X [Reads: X Index] [Flags: NZ]
	jsr $F2DC.w		; 20 DC F2 ; Jump to subroutine at $F2DC.w [Writes: Stack Pointer] [Flow: call]
	.db $30, $FF		; 30 FF ; Branch if minus to $30, $FF [Flow: branch]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$43E2]		; DC E2 43 ; Jump long indirect [$43E2] [Flow: jump]
	ora $10F1EE.l		; 0F EE F1 10 ; OR accumulator with memory (long) $10F1EE.l [Writes: Accumulator] [Flags: NZ]
	sbc $E18A.w		; ED 8A E1 ; Subtract $E18A.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	eor $42.b		; 45 42 ; Exclusive OR $42.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $22D0.w,X		; FD D0 22 ; Subtract with carry $22D0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $D08AEC.l		; 0F EC 8A D0 ; OR accumulator with memory (long) $D08AEC.l [Writes: Accumulator] [Flags: NZ]
	eor $2F.b,S		; 43 2F ; Exclusive OR accumulator with stack relative $2F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $11F0.w		; ED F0 11 ; Subtract $11F0.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	asl $8ACE.w		; 0E CE 8A ; Arithmetic shift left $8ACE.w [Flags: NCZ]
	and $43.b,X		; 35 43 ; Logical AND $43.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	rol $12CE.w		; 2E CE 12 ; Rotate left $12CE.w [Flags: NCZ]
	.db $10, $FE		; 10 FE ; Branch if plus to $10, $FE [Flow: branch]
	dec $138A.w,X		; DE 8A 13 ; Decrement memory $138A.w,X [Reads: X Index] [Flags: NZ]
	eor ($EC.b,X)		; 41 EC ; Exclusive OR accumulator with memory ($EC.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $DC2102.l,X		; DF 02 21 DC ; Compare accumulator (long,X) $DC2102.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	sbc ($8A.b,S),Y		; F3 8A ; Subtract with carry (stack relative indirect indexed) ($8A.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	eor ($21.b,S),Y		; 53 21 ; XOR accumulator (stack relative indirect indexed) ($21.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $21E1.w,X		; FD E1 21 ; Subtract with carry $21E1.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $8AF3ED.l,X		; FF ED F3 8A ; Subtract with carry (long,X) $8AF3ED.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $0C.b,S		; 43 0C ; Exclusive OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldx $1300.w,Y		; BE 00 13 ; Load X register $1300.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ora $23D0.w,X		; 1D D0 23 ; OR accumulator with memory $23D0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $42, $0F		; 42 0F ; Reserved instruction
	inc $0F12.w		; EE 12 0F ; Increment $0F12.w [Flags: NZ]
	sbc $8A34E0.l,X		; FF E0 34 8A ; Subtract with carry (long,X) $8A34E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $E0CC.w,X		; 1E CC E0 ; Arithmetic shift left $E0CC.w,X [Reads: X Index] [Flags: NCZ]
	cop $30.b		; 02 30 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $3211.w		; EE 11 32 ; Increment $3211.w [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	.db $30, $FC		; 30 FC ; Branch if minus to $30, $FC [Flow: branch]
	cmp ($30.b)		; D2 30 ; Compare accumulator (indirect) ($30.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sbc $6016FE.l		; EF FE 16 60 ; Subtract with carry (long) $6016FE.l [Writes: Accumulator] [Flags: NCVZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpx $02CD.w		; EC CD 02 ; Compare $02CD.w with X register [Reads: X Index] [Flags: NCZ]
	jsl $02F000.l		; 22 00 F0 02 ; Jump to subroutine long $02F000.l [Writes: Stack Pointer] [Flow: call]
	ora ($7A.b)		; 12 7A ; OR accumulator with memory (indirect) ($7A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $FF21BF.l,X		; 1F BF 21 FF ; Logical OR long $FF21BF.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($01.b,X)		; 21 01 ; Logical AND ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor $FA.b,S		; 43 FA ; Exclusive OR accumulator with stack relative $FA.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	cmp $12E0.w		; CD E0 12 ; Compare $12E0.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsl $0101FF.l		; 22 FF 01 01 ; Jump to subroutine long $0101FF.l [Writes: Stack Pointer] [Flow: call]
	ora ($02.b),Y		; 11 02 ; OR accumulator with memory ($02.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DB.b		; 00 DB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($302F.w)		; 6C 2F 30 ; Jump indirect to ($302F.w) [Flow: jump]
	ora $C3E76A.l,X		; 1F 6A E7 C3 ; Logical OR long $C3E76A.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda $E2.b,X		; B5 E2 ; Load $E2.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	inc $3BFF.w		; EE FF 3B ; Increment $3BFF.w [Flags: NZ]
	rol $F06A.w,X		; 3E 6A F0 ; Rotate left $F06A.w,X [Reads: X Index] [Flags: NCZ]
	eor $2E11.w		; 4D 11 2E ; Exclusive OR $2E11.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc ($16.b)		; F2 16 ; Subtract with carry (indirect) ($16.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $B0.b,S		; E3 B0 ; Subtract stack-relative $B0.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	cmp $2E2D09.l		; CF 09 2D 2E ; Compare accumulator (long) $2E2D09.l [Reads: Accumulator] [Flags: NCZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	and ($06.b,S),Y		; 33 06 ; AND accumulator (stack relative indirect indexed) ($06.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($6A.b,S),Y		; 33 6A ; AND accumulator (stack relative indirect indexed) ($6A.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $D2.b		; C6 D2 ; Decrement $D2.b [Reads: Direct Page] [Flags: NZ]
	asl $F0E0.w		; 0E E0 F0 ; Arithmetic shift left $F0E0.w [Flags: NCZ]
	lsr $1CA2.w		; 4E A2 1C ; Logical shift right $1CA2.w [Flags: NCZ]
	ror $DD.b,X		; 76 DD ; Rotate right $DD.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	inc $1F0F.w,X		; FE 0F 1F ; Increment memory $1F0F.w,X [Reads: X Index] [Flags: NZ]
	eor $33.b,S		; 43 33 ; Exclusive OR accumulator with stack relative $33.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	mvp $7A,$24		; 44 24 7A ; Move block positive $7A,$24 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	.db $D0, $D3		; D0 D3 ; Branch if not equal to $D0, $D3 [Flow: branch]
	sbc $2F0ED3.l,X		; FF D3 0E 2F ; Subtract with carry (long,X) $2F0ED3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $4B6A3F.l,X		; 3F 3F 6A 4B ; AND accumulator with memory (long,X) $4B6A3F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($FD.b,X)		; 41 FD ; Exclusive OR accumulator with memory ($FD.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $F5F0B2.l		; 0F B2 F0 F5 ; OR accumulator with memory (long) $F5F0B2.l [Writes: Accumulator] [Flags: NZ]
	lda ($6A.b)		; B2 6A ; Load accumulator (indirect) ($6A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda ($04.b),Y		; B1 04 ; Load accumulator ($04.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $3F22.w,X		; 1E 22 3F ; Arithmetic shift left $3F22.w,X [Reads: X Index] [Flags: NCZ]
	ora $7AEC4F.l,X		; 1F 4F EC 7A ; Logical OR long $7AEC4F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $FF.b		; 02 FF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($B4.b,S),Y		; D3 B4 ; Compare accumulator (stack relative indirect indexed) ($B4.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	and $7A.b		; 25 7A ; Logical AND $7A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $EF.b,S		; 03 EF ; OR accumulator with stack relative $EF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $3DFE.w		; 0C FE 3D ; Test and set bits $3DFE.w [Reads: Accumulator] [Flags: Z]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $E37AFF.l,X		; 5F FF 7A E3 ; Exclusive OR accumulator with memory (long,X) $E37AFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($D4.b)		; F2 D4 ; Subtract with carry (indirect) ($D4.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $E3.b,S		; 03 E3 ; OR accumulator with stack relative $E3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7A.b		; 00 7A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	and $132D1E.l		; 2F 1E 2D 13 ; AND accumulator with memory (long) $132D1E.l [Writes: Accumulator] [Flags: NZ]
	sbc $6AF313.l		; EF 13 F3 6A ; Subtract with carry (long) $6AF313.l [Writes: Accumulator] [Flags: NCVZ]
	mvp $9C,$2F		; 44 2F 9C ; Move block positive $9C,$2F [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cmp ($BC.b)		; D2 BC ; Compare accumulator (indirect) ($BC.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sbc $DF.b,X		; F5 DF ; Subtract $DF.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $01016A.l		; 2F 6A 01 01 ; AND accumulator with memory (long) $01016A.l [Writes: Accumulator] [Flags: NZ]
	adc $1F5F25.l		; 6F 25 5F 1F ; Add with carry (long) $1F5F25.l [Writes: Accumulator] [Flags: NCVZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ora ($6A.b),Y		; 11 6A ; OR accumulator with memory ($6A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	lda $6FD014.l,X		; BF 14 D0 6F ; Load long $6FD014.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	bit $7A73.w,X		; 3C 73 7A ; Test bits $7A73.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	.db $30, $10		; 30 10 ; Branch if minus to $30, $10 [Flow: branch]
	inc $1EDD.w		; EE DD 1E ; Increment $1EDD.w [Flags: NZ]
	sbc ($2F.b,X)		; E1 2F ; Subtract with carry ($2F.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($7A.b,X)		; E1 7A ; Subtract with carry ($7A.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($12.b)		; F2 12 ; Subtract with carry (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and ($02.b,X)		; 21 02 ; Logical AND ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor $FEEC2C.l		; 4F 2C EC FE ; Exclusive OR accumulator with memory (long) $FEEC2C.l [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	ora $0F0E11.l		; 0F 11 0E 0F ; OR accumulator with memory (long) $0F0E11.l [Writes: Accumulator] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $15.b,S		; 03 15 ; OR accumulator with stack relative $15.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	sbc $FD.b,X		; F5 FD ; Subtract $FD.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	jsr ($F12D.w,X)		; FC 2D F1 ; Jump to subroutine indirect indexed ($F12D.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	bit $7A1F.w,X		; 3C 1F 7A ; Test bits $7A1F.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	and $071522.l		; 2F 22 15 07 ; AND accumulator with memory (long) $071522.l [Writes: Accumulator] [Flags: NZ]
	ora ($AF.b)		; 12 AF ; OR accumulator with memory (indirect) ($AF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $7ABF.w,X		; BD BF 7A ; Load $7ABF.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $31.b		; 00 31 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $F30E.w		; 0E 0E F3 ; Arithmetic shift left $F30E.w [Flags: NCZ]
	rol $1560.w,X		; 3E 60 15 ; Rotate left $1560.w,X [Reads: X Index] [Flags: NCZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $FF		; 30 FF ; Branch if minus to $30, $FF [Flow: branch]
	cmp $F310C0.l		; CF C0 10 F3 ; Compare accumulator (long) $F310C0.l [Reads: Accumulator] [Flags: NCZ]
	asl $8AE1.w		; 0E E1 8A ; Arithmetic shift left $8AE1.w [Flags: NCZ]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $FD3022.l		; 22 22 30 FD ; Jump to subroutine long $FD3022.l [Writes: Stack Pointer] [Flow: call]
	cpy $7ADF.w		; CC DF 7A ; Compare $7ADF.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $42, $14		; 42 14 ; Reserved instruction
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora $40E3.w,X		; 1D E3 40 ; OR accumulator with memory $40E3.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $34.b,S		; 43 34 ; Exclusive OR accumulator with stack relative $34.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($FD.b),Y		; 31 FD ; AND accumulator with memory ($FD.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpy $11C0.w		; CC C0 11 ; Compare $11C0.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora ($0F.b)		; 12 0F ; OR accumulator with memory (indirect) ($0F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $22E08A.l		; 0F 8A E0 22 ; OR accumulator with memory (long) $22E08A.l [Writes: Accumulator] [Flags: NZ]
	jsl $DC4024.l		; 22 24 40 DC ; Jump to subroutine long $DC4024.l [Writes: Stack Pointer] [Flow: call]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	cpx #$7A.b		; E0 7A ; Compare #$7A.b with X register [Reads: X Index] [Flags: NCZ]
	rol $34.b		; 26 34 ; Rotate left $34.b [Reads: Direct Page] [Flags: NCZ]
	ora $33E2CE.l,X		; 1F CE E2 33 ; Logical OR long $33E2CE.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $42, $57		; 42 57 ; Reserved instruction
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $FD		; 30 FD ; Branch if minus to $30, $FD [Flow: branch]
	lda #$33C0.w		; A9 C0 33 ; Load #$33C0.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($2F.b),Y		; 11 2F ; OR accumulator with memory ($2F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$9A.b		; E0 9A ; Compare #$9A.b with X register [Reads: X Index] [Flags: NCZ]
	sbc $121112.l,X		; FF 12 11 12 ; Subtract with carry (long,X) $121112.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($EE.b,X)		; 21 EE ; Logical AND ($EE.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpy $7AE1.w		; CC E1 7A ; Compare $7AE1.w with Y register [Reads: Y Index] [Flags: NCZ]
	mvn $2D,$66		; 54 66 2D ; Move block negative $2D,$66 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cmp $33E0.w,X		; DD E0 33 ; Compare accumulator $33E0.w,X [Reads: X Index] [Flags: NCZ]
	adc $55.b		; 65 55 ; Add $55.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	.db $10, $0E		; 10 0E ; Branch if plus to $10, $0E [Flow: branch]
	cmp $11E0.w		; CD E0 11 ; Compare $11E0.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	and ($10.b,X)		; 21 10 ; Logical AND ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	inc $F19A.w,X		; FE 9A F1 ; Increment memory $F19A.w,X [Reads: X Index] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $CEED11.l		; 22 11 ED CE ; Jump to subroutine long $CEED11.l [Writes: Stack Pointer] [Flow: call]
	cpx #$8A.b		; E0 8A ; Compare #$8A.b with X register [Reads: X Index] [Flags: NCZ]
	ora ($35.b)		; 12 35 ; OR accumulator with memory (indirect) ($35.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $EE		; 10 EE ; Branch if plus to $10, $EE [Flow: branch]
	sbc ($13.b,X)		; E1 13 ; Subtract with carry ($13.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $218A33.l		; 22 33 8A 21 ; Jump to subroutine long $218A33.l [Writes: Stack Pointer] [Flow: call]
	nop		; EA ; No operation
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	cpy #$22.b		; C0 22 ; Compare #$22.b with Y register [Reads: Y Index] [Flags: NCZ]
	mvp $FC,$2F		; 44 2F FC ; Move block positive $FC,$2F [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	.db $F0, $12		; F0 12 ; Branch if equal to $F0, $12 [Flow: branch]
	jsr $2012.w		; 20 12 20 ; Jump to subroutine at $2012.w [Writes: Stack Pointer] [Flow: call]
	jsr ($F0CD.w,X)		; FC CD F0 ; Jump to subroutine indirect indexed ($F0CD.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($44.b,X)		; 21 44 ; Logical AND ($44.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsr $E0FE.w		; 20 FE E0 ; Jump to subroutine at $E0FE.w [Writes: Stack Pointer] [Flow: call]
	ora ($42.b)		; 12 42 ; OR accumulator with memory (indirect) ($42.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $8A.b,S		; 23 8A ; AND accumulator with stack relative $8A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr $9ADB.w		; 20 DB 9A ; Jump to subroutine at $9ADB.w [Writes: Stack Pointer] [Flow: call]
	cpy #$32.b		; C0 32 ; Compare #$32.b with Y register [Reads: Y Index] [Flags: NCZ]
	mvp $FD,$2F		; 44 2F FD ; Move block positive $FD,$2F [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($23.b),Y		; D1 23 ; Compare accumulator ($23.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	and ($33.b)		; 32 33 ; AND accumulator with memory (indirect) ($33.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $B19ADB.l		; 2F DB 9A B1 ; AND accumulator with memory (long) $B19ADB.l [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $FD2F54.l		; 22 54 2F FD ; Jump to subroutine long $FD2F54.l [Writes: Stack Pointer] [Flow: call]
	sbc ($23.b,X)		; E1 23 ; Subtract with carry ($23.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($12.b)		; 32 12 ; AND accumulator with memory (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsr $A9DB.w		; 20 DB A9 ; Jump to subroutine at $A9DB.w [Writes: Stack Pointer] [Flow: call]
	cpy #$33.b		; C0 33 ; Compare #$33.b with Y register [Reads: Y Index] [Flags: NCZ]
	eor $1F.b		; 45 1F ; Exclusive OR $1F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $F18A.w		; ED 8A F1 ; Subtract $F18A.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	jsl $2F2332.l		; 22 32 23 2F ; Jump to subroutine long $2F2332.l [Writes: Stack Pointer] [Flow: call]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	sta $8AC1.w,Y		; 99 C1 8A ; Store accumulator to $8AC1.w,Y [Reads: Y Index, Accumulator]
	and ($45.b)		; 32 45 ; AND accumulator with memory (indirect) ($45.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $23E1EE.l		; 2F EE E1 23 ; AND accumulator with memory (long) $23E1EE.l [Writes: Accumulator] [Flags: NZ]
	and ($13.b),Y		; 31 13 ; AND accumulator with memory ($13.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $C199DB.l		; 2F DB 99 C1 ; AND accumulator with memory (long) $C199DB.l [Writes: Accumulator] [Flags: NZ]
	eor $45.b,S		; 43 45 ; Exclusive OR accumulator with stack relative $45.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $8AED.w		; 2E ED 8A ; Rotate left $8AED.w [Flags: NCZ]
	sbc ($33.b,X)		; E1 33 ; Subtract with carry ($33.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($23.b),Y		; 31 23 ; AND accumulator with memory ($23.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	rol $9ACB.w		; 2E CB 9A ; Rotate left $9ACB.w [Flags: NCZ]
	cmp ($8A.b),Y		; D1 8A ; Compare accumulator ($8A.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	and ($55.b)		; 32 55 ; AND accumulator with memory (indirect) ($55.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $E1EE.w		; 2E EE E1 ; Rotate left $E1EE.w [Flags: NCZ]
	and ($30.b,S),Y		; 33 30 ; AND accumulator (stack relative indirect indexed) ($30.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $DA2E8A.l		; 22 8A 2E DA ; Jump to subroutine long $DA2E8A.l [Writes: Stack Pointer] [Flow: call]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	sbc ($43.b,X)		; E1 43 ; Subtract with carry ($43.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $1E.b		; 45 1E ; Exclusive OR $1E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $E28A.w		; ED 8A E2 ; Subtract $E28A.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	and ($21.b,S),Y		; 33 21 ; AND accumulator (stack relative indirect indexed) ($21.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $2E.b,S		; 23 2E ; AND accumulator with stack relative $2E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp #$E19B.w		; C9 9B E1 ; Compare #$E19B.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($55.b,S),Y		; 33 55 ; AND accumulator (stack relative indirect indexed) ($55.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $E2EE.w,X		; 1E EE E2 ; Arithmetic shift left $E2EE.w,X [Reads: X Index] [Flags: NCZ]
	and $31.b,S		; 23 31 ; AND accumulator with stack relative $31.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($8A.b)		; 12 8A ; OR accumulator with memory (indirect) ($8A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $AACB.w		; 2D CB AA ; Logical AND $AACB.w with accumulator [Writes: Accumulator] [Flags: NZ]
.ACCU 8
.INDEX 8
	sep #$32		; E2 32
	lsr $1D.b,X		; 56 1D ; Logical shift right $1D.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc $F28A.w		; ED 8A F2 ; Subtract $F28A.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	jsl $1C2332.l		; 22 32 23 1C ; Jump to subroutine long $1C2332.l [Writes: Stack Pointer] [Flow: call]
	wai		; CB ; Wait for interrupt
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	cmp ($8A.b)		; D2 8A ; Compare accumulator (indirect) ($8A.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	eor $45.b,S		; 43 45 ; Exclusive OR accumulator with stack relative $45.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $32E2ED.l,X		; 1F ED E2 32 ; Logical OR long $32E2ED.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($12.b),Y		; 31 12 ; AND accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rol $ABBA.w		; 2E BA AB ; Rotate left $ABBA.w [Flags: NCZ]
.ACCU 8
.INDEX 8
	sep #$33		; E2 33
	lsr $0D.b,X		; 56 0D ; Logical shift right $0D.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc $F28A.w		; ED 8A F2 ; Subtract $F28A.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	and ($31.b)		; 32 31 ; AND accumulator with memory (indirect) ($31.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $1C.b,S		; 23 1C ; AND accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	wai		; CB ; Wait for interrupt
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	sbc $8A.b,S		; E3 8A ; Subtract stack-relative $8A.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	.db $42, $55		; 42 55 ; Reserved instruction
	ora $F2FD.w,X		; 1D FD F2 ; OR accumulator with memory $F2FD.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($21.b)		; 32 21 ; AND accumulator with memory (indirect) ($21.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($8A.b,S),Y		; 13 8A ; OR accumulator (stack relative indirect indexed) ($8A.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $9ACB.w,X		; 1D CB 9A ; OR accumulator with memory $9ACB.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($32.b,S),Y		; F3 32 ; Subtract with carry (stack relative indirect indexed) ($32.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	lsr $0D.b,X		; 56 0D ; Logical shift right $0D.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc $E28A.w,X		; FD 8A E2 ; Subtract with carry $E28A.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($31.b,S),Y		; 33 31 ; AND accumulator (stack relative indirect indexed) ($31.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $1D.b,S		; 03 1D ; OR accumulator with stack relative $1D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	wai		; CB ; Wait for interrupt
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	sbc $8A.b,S		; E3 8A ; Subtract stack-relative $8A.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	.db $42, $56		; 42 56 ; Reserved instruction
	ora $F2EE.w		; 0D EE F2 ; Logical OR $F2EE.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $30.b,S		; 23 30 ; AND accumulator with stack relative $30.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($8A.b,S),Y		; 13 8A ; OR accumulator (stack relative indirect indexed) ($8A.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $9BBB.w,X		; 1D BB 9B ; OR accumulator with memory $9BBB.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $43.b,S		; E3 43 ; Subtract stack-relative $43.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	eor $0D.b,X		; 55 0D ; Exclusive OR accumulator with memory $0D.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $F28A.w		; ED 8A F2 ; Subtract $F28A.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	and ($30.b,S),Y		; 33 30 ; AND accumulator (stack relative indirect indexed) ($30.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($1D.b,S),Y		; 13 1D ; OR accumulator (stack relative indirect indexed) ($1D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	sbc $8A.b,S		; E3 8A ; Subtract stack-relative $8A.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	eor $45.b,S		; 43 45 ; Exclusive OR accumulator with stack relative $45.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $F2EE.w		; 0E EE F2 ; Arithmetic shift left $F2EE.w [Flags: NCZ]
	and $30.b,S		; 23 30 ; AND accumulator with stack relative $30.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $8B.b,S		; 03 8B ; OR accumulator with stack relative $8B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $AABB.w		; 2D BB AA ; Logical AND $AABB.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $43.b,S		; E3 43 ; Subtract stack-relative $43.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	lsr $0D.b		; 46 0D ; Logical shift right $0D.b [Reads: Direct Page] [Flags: NCZ]
	sbc $0000.w		; ED 00 00 ; Subtract $0000.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $74.b		; 00 74 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$13.b		; E0 13 ; Compare #$13.b with X register [Reads: X Index] [Flags: NCZ]
	and $E4E2.w,X		; 3D E2 E4 ; AND accumulator with memory $E4E2.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($44.b,S),Y		; 53 44 ; XOR accumulator (stack relative indirect indexed) ($44.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $2178.w		; EE 78 21 ; Increment $2178.w [Flags: NZ]
	.db $30, $E0		; 30 E0 ; Branch if minus to $30, $E0 [Flow: branch]
	ora $DE0312.l		; 0F 12 03 DE ; OR accumulator with memory (long) $DE0312.l [Writes: Accumulator] [Flags: NZ]
	jmp.w [$FD94]		; DC 94 FD ; Jump long indirect [$FD94] [Flow: jump]
	sbc $51EF.w		; ED EF 51 ; Subtract $51EF.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $42, $25		; 42 25 ; Reserved instruction
	sty $7D.b		; 84 7D ; Store Y register to $7D.b [Reads: Y Index]
	ora $3CF5.w		; 0D F5 3C ; Logical OR $3CF5.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $ADBB.w		; 0C BB AD ; Test and set bits $ADBB.w [Reads: Accumulator] [Flags: Z]
	jsr $0D88.w		; 20 88 0D ; Jump to subroutine at $0D88.w [Writes: Stack Pointer] [Flow: call]
	cpx $22.b		; E4 22 ; Compare $22.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	eor $35CC39.l,X		; 5F 39 CC 35 ; Exclusive OR accumulator with memory (long,X) $35CC39.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda ($98.b)		; B2 98 ; Load accumulator (indirect) ($98.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr ($4A12.w,X)		; FC 12 4A ; Jump to subroutine indirect indexed ($4A12.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsl $234CE0.l		; 22 E0 4C 23 ; Jump to subroutine long $234CE0.l [Writes: Stack Pointer] [Flow: call]
	inc $3A88.w,X		; FE 88 3A ; Increment memory $3A88.w,X [Reads: X Index] [Flags: NZ]
	and ($0B.b,S),Y		; 33 0B ; AND accumulator (stack relative indirect indexed) ($0B.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $FEEF.w,X		; 5D EF FE ; Exclusive OR accumulator with memory $FEEF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $70, $E5		; 70 E5 ; Branch if overflow set to $70, $E5 [Flow: branch]
	ldy $00.b		; A4 00 ; Load $00.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $0FFFFF.l		; 0F FF FF 0F ; OR accumulator with memory (long) $0FFFFF.l [Writes: Accumulator] [Flags: NZ]
	lsr $FD94.w		; 4E 94 FD ; Logical shift right $FD94.w [Flags: NCZ]
	ora $3265.w,X		; 1D 65 32 ; OR accumulator with memory $3265.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $7FF2E0.l		; 4F E0 F2 7F ; Exclusive OR accumulator with memory (long) $7FF2E0.l [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	sbc ($F0.b),Y		; F1 F0 ; Subtract with carry ($F0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and $E1DF14.l		; 2F 14 DF E1 ; AND accumulator with memory (long) $E1DF14.l [Writes: Accumulator] [Flags: NZ]
	ora $EF.b,S		; 03 EF ; OR accumulator with stack relative $EF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldy $E0.b		; A4 E0 ; Load $E0.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	dec $E4ED.w,X		; DE ED E4 ; Decrement memory $E4ED.w,X [Reads: X Index] [Flags: NZ]
	lsr $01E1.w		; 4E E1 01 ; Logical shift right $01E1.w [Flags: NCZ]
	.db $42, $A4		; 42 A4 ; Reserved instruction
	and $3C.b		; 25 3C ; Logical AND $3C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $DDFF.w,X		; 3D FF DD ; AND accumulator with memory $DDFF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsr $4E98.w		; 20 98 4E ; Jump to subroutine at $4E98.w [Writes: Stack Pointer] [Flow: call]
	wai		; CB ; Wait for interrupt
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $D0, $4D		; D0 4D ; Branch if not equal to $D0, $4D [Flow: branch]
	bit $26CF.w		; 2C CF 26 ; Test bits $26CF.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	ldy $40.b,X		; B4 40 ; Load Y register $40.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	cop $0F.b		; 02 0F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b),Y		; 11 02 ; OR accumulator with memory ($02.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $A40FE0.l		; 4F E0 0F A4 ; Exclusive OR accumulator with memory (long) $A40FE0.l [Writes: Accumulator] [Flags: NZ]
	lsr $1AD1.w		; 4E D1 1A ; Logical shift right $1AD1.w [Flags: NCZ]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $B4FDEF.l		; 2F EF FD B4 ; AND accumulator with memory (long) $B4FDEF.l [Writes: Accumulator] [Flags: NZ]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $06EE.w,X		; FE EE 06 ; Increment memory $06EE.w,X [Reads: X Index] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
.ACCU 8
.INDEX 8
	sep #$B8		; E2 B8
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $D422.w		; CD 22 D4 ; Compare $D422.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	asl $E1F2.w		; 0E F2 E1 ; Arithmetic shift left $E1F2.w [Flags: NCZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and $E3.b		; 25 E3 ; Logical AND $E3.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	ora ($02.b,S),Y		; 13 02 ; OR accumulator (stack relative indirect indexed) ($02.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $A1B2.w		; 0E B2 A1 ; Arithmetic shift left $A1B2.w [Flags: NCZ]
	ldy $E0.b,X		; B4 E0 ; Load Y register $E0.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp ($01.b)		; D2 01 ; Compare accumulator (indirect) ($01.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	bit $12.b		; 24 12 ; Test bits $12.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	and $24A8.w		; 2D A8 24 ; Logical AND $24A8.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $30, $0C		; 30 0C ; Branch if minus to $30, $0C [Flow: branch]
	inc $E452.w,X		; FE 52 E4 ; Increment memory $E452.w,X [Reads: X Index] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	asl $02A8.w		; 0E A8 02 ; Arithmetic shift left $02A8.w [Flags: NCZ]
	.db $30, $0C		; 30 0C ; Branch if minus to $30, $0C [Flow: branch]
	ora $6C2FD0.l		; 0F D0 2F 6C ; OR accumulator with memory (long) $6C2FD0.l [Writes: Accumulator] [Flags: NZ]
	ora $A4.b,S		; 03 A4 ; OR accumulator with stack relative $A4.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($C4.b,X)		; 01 C4 ; Logical OR ($C4.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $65.b,X		; 35 65 ; Logical AND $65.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $4E302F.l,X		; 1F 2F 30 4E ; Logical OR long $4E302F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldy $EE.b		; A4 EE ; Load $EE.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	cpx $0112.w		; EC 12 01 ; Compare $0112.w with X register [Reads: X Index] [Flags: NCZ]
	sbc $11F0.w		; ED F0 11 ; Subtract $11F0.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ora ($A8.b),Y		; 11 A8 ; OR accumulator with memory ($A8.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $F0		; D0 F0 ; Branch if not equal to $D0, $F0 [Flow: branch]
	sbc ($D1.b)		; F2 D1 ; Subtract with carry (indirect) ($D1.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	asl $2600.w,X		; 1E 00 26 ; Arithmetic shift left $2600.w,X [Reads: X Index] [Flags: NCZ]
	sta ($A8.b)		; 92 A8 ; Store accumulator (indirect) ($A8.b) [Reads: Direct Page, Accumulator]
	cmp $10.b,S		; C3 10 ; Compare accumulator (stack relative) $10.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $11F3.w,X		; FD F3 11 ; Subtract with carry $11F3.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FF1198.l,X		; FF 98 11 FF ; Subtract with carry (long,X) $FF1198.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $40.b		; E5 40 ; Subtract $40.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cpx $2F03.w		; EC 03 2F ; Compare $2F03.w with X register [Reads: X Index] [Flags: NCZ]
	cpx #$B4.b		; E0 B4 ; Compare #$B4.b with X register [Reads: X Index] [Flags: NCZ]
	brk $EE.b		; 00 EE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $F2FEFF.l		; EF FF FE F2 ; Subtract with carry (long) $F2FEFF.l [Writes: Accumulator] [Flags: NCVZ]
	.db $50, $FF		; 50 FF ; Branch if overflow clear to $50, $FF [Flow: branch]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	.db $42, $1E		; 42 1E ; Reserved instruction
	.db $10, $1F		; 10 1F ; Branch if plus to $10, $1F [Flow: branch]
	lda ($5E.b)		; B2 5E ; Load accumulator (indirect) ($5E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $94.b,X		; D5 94 ; Compare accumulator $94.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $F0, $B9		; F0 B9 ; Branch if equal to $F0, $B9 [Flow: branch]
.INDEX 8
	sep #$D2		; E2 D2
	lda ($62.b),Y		; B1 62 ; Load accumulator ($62.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($D5.b,S),Y		; F3 D5 ; Subtract with carry (stack relative indirect indexed) ($D5.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: NCZ]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $3C131F.l		; 0F 1F 13 3C ; OR accumulator with memory (long) $3C131F.l [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	bit $12.b		; 24 12 ; Test bits $12.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	asl $E13A.w,X		; 1E 3A E1 ; Arithmetic shift left $E13A.w,X [Reads: X Index] [Flags: NCZ]
	trb $3A.b		; 14 3A ; Test and reset bits $3A.b [Reads: Accumulator] [Flags: Z]
	ldy $0C.b		; A4 0C ; Load $0C.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	jsr ($20DB.w,X)		; FC DB 20 ; Jump to subroutine indirect indexed ($20DB.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $30, $EF		; 30 EF ; Branch if minus to $30, $EF [Flow: branch]
	cop $31.b		; 02 31 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $DC		; 10 DC ; Branch if plus to $10, $DC [Flow: branch]
	sbc ($13.b)		; F2 13 ; Subtract with carry (indirect) ($13.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$BF.b		; C0 BF ; Compare #$BF.b with Y register [Reads: Y Index] [Flags: NCZ]
	inc $A804.w,X		; FE 04 A8 ; Increment memory $A804.w,X [Reads: X Index] [Flags: NZ]
	ora $E4.b,S		; 03 E4 ; OR accumulator with stack relative $E4.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldy #$F1.b		; A0 F1 ; Load #$F1.b into Y register [Writes: Y Index] [Flags: NZ]
	and ($2D.b),Y		; 31 2D ; AND accumulator with memory ($2D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($04.b)		; 12 04 ; OR accumulator with memory (indirect) ($04.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dec $5F4A.w		; CE 4A 5F ; Decrement $5F4A.w [Flags: NZ]
	bit $DF.b		; 24 DF ; Test bits $DF.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sty $01.b,X		; 94 01 ; Store Y register $01.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	and $11.b,S		; 23 11 ; AND accumulator with stack relative $11.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $C0EF.w,X		; 1D EF C0 ; OR accumulator with memory $C0EF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $A8CC.w,X		; FE CC A8 ; Increment memory $A8CC.w,X [Reads: X Index] [Flags: NZ]
	sbc ($F1.b,X)		; E1 F1 ; Subtract with carry ($F1.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $412D2B.l		; 0F 2B 2D 41 ; OR accumulator with memory (long) $412D2B.l [Writes: Accumulator] [Flags: NZ]
	bit $A80E.w,X		; 3C 0E A8 ; Test bits $A80E.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	rol $404D.w		; 2E 4D 40 ; Rotate left $404D.w [Flags: NCZ]
	sbc ($D2.b,X)		; E1 D2 ; Subtract with carry ($D2.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $98004F.l		; 0F 4F 00 98 ; OR accumulator with memory (long) $98004F.l [Writes: Accumulator] [Flags: NZ]
	ldy $F0.b		; A4 F0 ; Load $F0.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	and ($3F.b),Y		; 31 3F ; AND accumulator with memory ($3F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$E3.b		; E0 E3 ; Compare #$E3.b with X register [Reads: X Index] [Flags: NCZ]
	ora ($1D.b),Y		; 11 1D ; OR accumulator with memory ($1D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	asl $D2D3.w		; 0E D3 D2 ; Arithmetic shift left $D2D3.w [Flags: NCZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	nop		; EA ; No operation
	sbc $03.b,S		; E3 03 ; Subtract stack-relative $03.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	.db $B0, $94		; B0 94 ; Branch if carry set to $B0, $94 [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	jsr ($051F.w,X)		; FC 1F 05 ; Jump to subroutine indirect indexed ($051F.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $16.b,X		; F6 16 ; Increment memory $16.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	and $4F.b,X		; 35 4F ; Logical AND $4F.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sty $54.b,X		; 94 54 ; Store Y register $54.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	mvp $02,$12		; 44 12 02 ; Move block positive $02,$12 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	asl $2C5F.w,X		; 1E 5F 2C ; Arithmetic shift left $2C5F.w,X [Reads: X Index] [Flags: NCZ]
	ora $F184.w		; 0D 84 F1 ; Logical OR $F184.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc ($E0.b),Y		; F1 E0 ; Subtract with carry ($E0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $F5.b,S		; C3 F5 ; Compare accumulator (stack relative) $F5.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	pei ($BF.b)		; D4 BF ; Push effective indirect address ($BF.b) [Reads: Direct Page] [Writes: Stack Pointer]
	cmp $1E88.w,X		; DD 88 1E ; Compare accumulator $1E88.w,X [Reads: X Index] [Flags: NCZ]
	bit $C102.w		; 2C 02 C1 ; Test bits $C102.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	ora $B003.w,X		; 1D 03 B0 ; OR accumulator with memory $B003.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $0194.w		; 2D 94 01 ; Logical AND $0194.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($EF.b,X)		; 01 EF ; Logical OR ($EF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $3FE1.w,X		; FD E1 3F ; Subtract with carry $3FE1.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $9410.w		; 2C 10 94 ; Test bits $9410.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	rol $4363.w,X		; 3E 63 43 ; Rotate left $4363.w,X [Reads: X Index] [Flags: NCZ]
	cop $26.b		; 02 26 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $E1.b,X		; 34 E1 ; Test bits $E1.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and ($84.b)		; 32 84 ; AND accumulator with memory (indirect) ($84.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $30, $39		; 30 39 ; Branch if minus to $30, $39 [Flow: branch]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	jmp $EDEF.w		; 4C EF ED ; Jump to $EDEF.w [Flow: jump]
	.db $D0, $74		; D0 74 ; Branch if not equal to $D0, $74 [Flow: branch]
	lda ($E3.b,X)		; A1 E3 ; Load accumulator ($E3.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($D1.b,X)		; C1 D1 ; Compare accumulator ($D1.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	cmp $0C.b,S		; C3 0C ; Compare accumulator (stack relative) $0C.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	stz $0E88.w		; 9C 88 0E ; Store zero to $0E88.w
	ora ($F1.b),Y		; 11 F1 ; OR accumulator with memory ($F1.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $F3E3.w		; ED E3 F3 ; Subtract $F3E3.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $B1		; F0 B1 ; Branch if equal to $F0, $B1 [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
.ACCU 8
.INDEX 8
	sep #$FF		; E2 FF
	jmp $FD3F.w		; 4C 3F FD ; Jump to $FD3F.w [Flow: jump]
	rol $5D4D.w		; 2E 4D 5D ; Rotate left $5D4D.w [Flags: NCZ]
	sty $31.b		; 84 31 ; Store Y register to $31.b [Reads: Y Index]
	brk $B3.b		; 00 B3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($32.b)		; 32 32 ; AND accumulator with memory (indirect) ($32.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($11.b,X)		; 21 11 ; Logical AND ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $10, $88		; 10 88 ; Branch if plus to $10, $88 [Flow: branch]
	.db $42, $EE		; 42 EE ; Reserved instruction
	ora $2E50.w,X		; 1D 50 2E ; OR accumulator with memory $2E50.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($74.b),Y		; 11 74 ; OR accumulator with memory ($74.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $BDC13E.l		; CF 3E C1 BD ; Compare accumulator (long) $BDC13E.l [Reads: Accumulator] [Flags: NCZ]
	.db $10, $02		; 10 02 ; Branch if plus to $10, $02 [Flow: branch]
	inc $64FE.w,X		; FE FE 64 ; Increment memory $64FE.w,X [Reads: X Index] [Flags: NZ]
	cmp $B0.b,X		; D5 B0 ; Compare accumulator $B0.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	lda $B2BF.w,Y		; B9 BF B2 ; Load $B2BF.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	bit $64EB.w		; 2C EB 64 ; Test bits $64EB.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	lda $6C31.w		; AD 31 6C ; Load $6C31.w into accumulator [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	and $22.b,S		; 23 22 ; AND accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sbc ($00.b),Y		; F1 00 ; Subtract with carry ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $1EF1.w,X		; 5D F1 1E ; Exclusive OR accumulator with memory $1EF1.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $E1.b		; 04 E1 ; Test and set bits $E1.b [Reads: Accumulator] [Flags: Z]
	ora ($74.b)		; 12 74 ; OR accumulator with memory (indirect) ($74.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $200302.l,X		; FF 02 03 20 ; Subtract with carry (long,X) $200302.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $101FFD.l,X		; FF FD 1F 10 ; Subtract with carry (long,X) $101FFD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	sbc ($22.b,S),Y		; F3 22 ; Subtract with carry (stack relative indirect indexed) ($22.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $C2		; 10 C2 ; Branch if plus to $10, $C2 [Flow: branch]
	sbc ($F1.b,X)		; E1 F1 ; Subtract with carry ($F1.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $0CF068.l		; 2F 68 F0 0C ; AND accumulator with memory (long) $0CF068.l [Writes: Accumulator] [Flags: NZ]
	lsr $1F10.w		; 4E 10 1F ; Logical shift right $1F10.w [Flags: NCZ]
	sbc ($E1.b,X)		; E1 E1 ; Subtract with carry ($E1.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $44.b		; 02 44 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($02.b,S),Y		; 73 02 ; Add with carry (stack relative indirect indexed) ($02.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ldy $121F.w,X		; BC 1F 12 ; Load Y register $121F.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	bit $013F.w		; 2C 3F 01 ; Test bits $013F.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	bit $0B.b,X		; 34 0B ; Test bits $0B.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora ($1D.b,X)		; 01 1D ; Logical OR ($1D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and ($13.b,S),Y		; 33 13 ; AND accumulator (stack relative indirect indexed) ($13.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	ora ($52.b,X)		; 01 52 ; Logical OR ($52.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	ora ($D5.b,S),Y		; 13 D5 ; OR accumulator (stack relative indirect indexed) ($D5.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $92632F.l,X		; BF 2F 63 92 ; Load long $92632F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsr $1505.w		; 20 05 15 ; Jump to subroutine at $1505.w [Writes: Stack Pointer] [Flow: call]
	inc $C022.w,X		; FE 22 C0 ; Increment memory $C022.w,X [Reads: X Index] [Flags: NZ]
	ora $0FEE.w		; 0D EE 0F ; Logical OR $0FEE.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $EE		; F0 EE ; Branch if equal to $F0, $EE [Flow: branch]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7A.b		; 00 7A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $3414.w,X		; FD 14 34 ; Subtract with carry $3414.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $14CF.w		; 2C CF 14 ; Test bits $14CF.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	eor ($CC.b),Y		; 51 CC ; Exclusive OR accumulator with memory ($CC.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	cmp $FF1F22.l,X		; DF 22 1F FF ; Compare accumulator (long,X) $FF1F22.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	ora $42.b,X		; 15 42 ; OR accumulator with memory $42.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $7AAB.w		; 0D AB 7A ; Logical OR $7AAB.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp $01DF.w,X		; DD DF 01 ; Compare accumulator $01DF.w,X [Reads: X Index] [Flags: NCZ]
	jsr $CEDB.w		; 20 DB CE ; Jump to subroutine at $CEDB.w [Writes: Stack Pointer] [Flow: call]
	.db $10, $FD		; 10 FD ; Branch if plus to $10, $FD [Flow: branch]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $11F1.w,X		; DD F1 11 ; Compare accumulator $11F1.w,X [Reads: X Index] [Flags: NCZ]
	asl $10EF.w		; 0E EF 10 ; Arithmetic shift left $10EF.w [Flags: NCZ]
	brk $EC.b		; 00 EC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($45.b),Y		; D1 45 ; Compare accumulator ($45.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	.db $30, $EE		; 30 EE ; Branch if minus to $30, $EE [Flow: branch]
	sbc ($30.b,S),Y		; F3 30 ; Subtract with carry (stack relative indirect indexed) ($30.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	dec $8600.w,X		; DE 00 86 ; Decrement memory $8600.w,X [Reads: X Index] [Flags: NZ]
.INDEX 8
	sep #$53		; E2 53
	ora ($0F.b),Y		; 11 0F ; OR accumulator with memory ($0F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $34F1EE.l,X		; FF EE F1 34 ; Subtract with carry (long,X) $34F1EE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	jsl $D93400.l		; 22 00 34 D9 ; Jump to subroutine long $D93400.l [Writes: Stack Pointer] [Flow: call]
	sbc ($01.b,S),Y		; F3 01 ; Subtract with carry (stack relative indirect indexed) ($01.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	eor ($E3.b),Y		; 51 E3 ; Exclusive OR accumulator with memory ($E3.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $21.b,S		; 43 21 ; Exclusive OR accumulator with stack relative $21.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $11F2.w,X		; FD F2 11 ; Subtract with carry $11F2.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($FD.b,S),Y		; 33 FD ; AND accumulator (stack relative indirect indexed) ($FD.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $8A		; D0 8A ; Branch if not equal to $D0, $8A [Flow: branch]
	brk $EE.b		; 00 EE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $4213.w,X		; DE 13 42 ; Decrement memory $4213.w,X [Reads: X Index] [Flags: NZ]
	and ($0C.b,X)		; 21 0C ; Logical AND ($0C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $EEFF00.l		; CF 00 FF EE ; Compare accumulator (long) $EEFF00.l [Reads: Accumulator] [Flags: NCZ]
	sbc ($11.b),Y		; F1 11 ; Subtract with carry ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lda $F08A.w		; AD 8A F0 ; Load $F08A.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $10, $FD		; 10 FD ; Branch if plus to $10, $FD [Flow: branch]
	sbc ($31.b,X)		; E1 31 ; Subtract with carry ($31.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($11CF.w,X)		; FC CF 11 ; Jump to subroutine indirect indexed ($11CF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	eor $10.b,X		; 55 10 ; Exclusive OR accumulator with memory $10.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor [$75.b],Y		; 57 75 ; Exclusive OR accumulator with memory (long indexed) [$75.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	cmp $8A3123.l		; CF 23 31 8A ; Compare accumulator (long) $8A3123.l [Reads: Accumulator] [Flags: NCZ]
	bit $32.b,X		; 34 32 ; Test bits $32.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and $1330E0.l		; 2F E0 30 13 ; AND accumulator with memory (long) $1330E0.l [Writes: Accumulator] [Flags: NZ]
	rol $8AE1.w		; 2E E1 8A ; Rotate left $8AE1.w [Flags: NCZ]
	and ($21.b,X)		; 21 21 ; Logical AND ($21.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $F0, $45		; F0 45 ; Branch if equal to $F0, $45 [Flow: branch]
	ora $D1BC.w		; 0D BC D1 ; Logical OR $D1BC.w with accumulator [Writes: Accumulator] [Flags: NZ]
	eor $7A.b		; 45 7A ; Exclusive OR $7A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc ($FF.b)		; 72 FF ; Add with carry (indirect) ($FF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	bit $41.b		; 24 41 ; Test bits $41.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	.db $F0, $45		; F0 45 ; Branch if equal to $F0, $45 [Flow: branch]
	eor $1D.b,S		; 43 1D ; Exclusive OR accumulator with stack relative $1D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dec $D0ED.w,X		; DE ED D0 ; Decrement memory $D0ED.w,X [Reads: X Index] [Flags: NZ]
	ora ($66.b,S),Y		; 13 66 ; OR accumulator (stack relative indirect indexed) ($66.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	trb $FFCD.w		; 1C CD FF ; Test and reset bits $FFCD.w [Reads: Accumulator] [Flags: Z]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $E1CC.w		; 0E CC E1 ; Arithmetic shift left $E1CC.w [Flags: NCZ]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $EEFF.w,X		; BC FF EE ; Load Y register $EEFF.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	cpy #$32.b		; C0 32 ; Compare #$32.b with Y register [Reads: Y Index] [Flags: NCZ]
	ora $EFDD.w		; 0D DD EF ; Logical OR $EFDD.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $8ACE.w		; 0E CE 8A ; Arithmetic shift left $8ACE.w [Flags: NCZ]
	ora ($35.b)		; 12 35 ; OR accumulator with memory (indirect) ($35.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $42, $11		; 42 11 ; Reserved instruction
	sbc $35DF0F.l,X		; FF 0F DF 35 ; Subtract with carry (long,X) $35DF0F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	mvp $01,$21		; 44 21 01 ; Move block positive $01,$21 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $3212EF.l,X		; 1F EF 12 32 ; Logical OR long $3212EF.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $EF8A.w		; 0E 8A EF ; Arithmetic shift left $EF8A.w [Flags: NCZ]
	ora ($33.b,S),Y		; 13 33 ; OR accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $11F0CD.l		; 2F CD F0 11 ; AND accumulator with memory (long) $11F0CD.l [Writes: Accumulator] [Flags: NZ]
	sbc $41377A.l,X		; FF 7A 37 41 ; Subtract with carry (long,X) $41377A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp.w [$55F3]		; DC F3 55 ; Jump long indirect [$55F3] [Flow: jump]
	lsr $32.b,X		; 56 32 ; Logical shift right $32.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	eor $8A.b,S		; 43 8A ; Exclusive OR accumulator with stack relative $8A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr ($03AB.w,X)		; FC AB 03 ; Jump to subroutine indirect indexed ($03AB.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	mvp $01,$20		; 44 20 01 ; Move block positive $01,$20 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora ($0D.b),Y		; 11 0D ; OR accumulator with memory ($0D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldy $10F0.w,X		; BC F0 10 ; Load Y register $10F0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	sbc $0FFF.w,X		; FD FF 0F ; Subtract with carry $0FFF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ldy $DF8A.w		; AC 8A DF ; Load $DF8A.w into Y register [Writes: Y Index] [Flags: NZ]
	ora ($EE.b),Y		; 11 EE ; OR accumulator with memory ($EE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($FF.b),Y		; 11 FF ; OR accumulator with memory ($FF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lda $8AEF.w,X		; BD EF 8A ; Load $8AEF.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	trb $32.b		; 14 32 ; Test and reset bits $32.b [Reads: Accumulator] [Flags: Z]
	rol $41.b		; 26 41 ; Rotate left $41.b [Reads: Direct Page] [Flags: NCZ]
	cmp $22E0.w,X		; DD E0 22 ; Compare accumulator $22E0.w,X [Reads: X Index] [Flags: NCZ]
	jsl $52468A.l		; 22 8A 46 52 ; Jump to subroutine long $52468A.l [Writes: Stack Pointer] [Flow: call]
	ora $3125EF.l		; 0F EF 25 31 ; OR accumulator with memory (long) $3125EF.l [Writes: Accumulator] [Flags: NZ]
	asl $8ADF.w		; 0E DF 8A ; Arithmetic shift left $8ADF.w [Flags: NCZ]
	eor $31.b		; 45 31 ; Exclusive OR $31.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $12		; 10 12 ; Branch if plus to $10, $12 [Flow: branch]
	ora $33F2DC.l,X		; 1F DC F2 33 ; Logical OR long $33F2DC.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $F00FE0.l		; 2F E0 0F F0 ; AND accumulator with memory (long) $F00FE0.l [Writes: Accumulator] [Flags: NZ]
	ora ($35.b,X)		; 01 35 ; Logical OR ($35.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	mvn $8A,$0B		; 54 0B 8A ; Move block negative $8A,$0B [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	lda $00EF.w,X		; BD EF 00 ; Load $00EF.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor ($EC.b)		; 52 EC ; Exclusive OR accumulator with memory (indirect) ($EC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $0DFF8A.l		; EF 8A FF 0D ; Subtract with carry (long) $0DFF8A.l [Writes: Accumulator] [Flags: NCVZ]
	cmp $DB2021.l,X		; DF 21 20 DB ; Compare accumulator (long,X) $DB2021.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	cmp $8ADE.w,X		; DD DE 8A ; Compare accumulator $8ADE.w,X [Reads: X Index] [Flags: NCZ]
	inc $22EF.w,X		; FE EF 22 ; Increment memory $22EF.w,X [Reads: X Index] [Flags: NZ]
	jsr $DEED.w		; 20 ED DE ; Jump to subroutine at $DEED.w [Writes: Stack Pointer] [Flow: call]
	cmp $8ADE.w,X		; DD DE 8A ; Compare accumulator $8ADE.w,X [Reads: X Index] [Flags: NCZ]
	cop $44.b		; 02 44 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $42, $11		; 42 11 ; Reserved instruction
	ora $26F0EE.l		; 0F EE F0 26 ; OR accumulator with memory (long) $26F0EE.l [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $0F.b,S		; 63 0F ; Add with carry (stack relative) $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($33.b,X)		; E1 33 ; Subtract with carry ($33.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $21F2DD.l,X		; 1F DD F2 21 ; Logical OR long $21F2DD.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $1E2113.l,X		; FF 13 21 1E ; Subtract with carry (long,X) $1E2113.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy $00F0.w,X		; BC F0 00 ; Load Y register $00F0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ora ($8A.b,X)		; 01 8A ; Logical OR ($8A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and ($FD.b,X)		; 21 FD ; Logical AND ($FD.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpy $25E0.w		; CC E0 25 ; Compare $25E0.w with Y register [Reads: Y Index] [Flags: NCZ]
	eor ($F1.b)		; 52 F1 ; Exclusive OR accumulator with memory (indirect) ($F1.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $CCDE8A.l,X		; 1F 8A DE CC ; Logical OR long $CCDE8A.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($35.b),Y		; D1 35 ; Compare accumulator ($35.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	.db $30, $01		; 30 01 ; Branch if minus to $30, $01 [Flow: branch]
	and ($FE.b),Y		; 31 FE ; AND accumulator with memory ($FE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $11FF.w		; EE FF 11 ; Increment $11FF.w [Flags: NZ]
	.db $10, $FF		; 10 FF ; Branch if plus to $10, $FF [Flow: branch]
	ora $8ACCEE.l		; 0F EE CC 8A ; OR accumulator with memory (long) $8ACCEE.l [Writes: Accumulator] [Flags: NZ]
	sbc ($0F.b),Y		; F1 0F ; Subtract with carry ($0F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $22		; F0 22 ; Branch if equal to $F0, $22 [Flow: branch]
	asl $CCDC.w,X		; 1E DC CC ; Arithmetic shift left $CCDC.w,X [Reads: X Index] [Flags: NCZ]
	sbc $13008A.l		; EF 8A 00 13 ; Subtract with carry (long) $13008A.l [Writes: Accumulator] [Flags: NCVZ]
	mvp $ED,$30		; 44 30 ED ; Move block positive $ED,$30 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cmp $7A4223.l,X		; DF 23 42 7A ; Compare accumulator (long,X) $7A4223.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	sbc $0D6567.l,X		; FF 67 65 0D ; Subtract with carry (long,X) $0D6567.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($10.b),Y		; F1 10 ; Subtract with carry ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $8A02.w,X		; FD 02 8A ; Subtract with carry $8A02.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $001121.l		; 22 21 11 00 ; Jump to subroutine long $001121.l [Writes: Stack Pointer] [Flow: call]
	ora $4305AB.l		; 0F AB 05 43 ; OR accumulator with memory (long) $4305AB.l [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $E1BC.w		; 0D BC E1 ; Logical OR $E1BC.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and ($FF.b,X)		; 21 FF ; Logical AND ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $41.b,X		; 35 41 ; Logical AND $41.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $CC8A.w,X		; FD 8A CC ; Subtract with carry $CC8A.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$F0.b		; E0 F0 ; Compare #$F0.b with X register [Reads: X Index] [Flags: NCZ]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($0E.b,S),Y		; 53 0E ; XOR accumulator (stack relative indirect indexed) ($0E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $FFF08A.l		; EF 8A F0 FF ; Subtract with carry (long) $FFF08A.l [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $12		; F0 12 ; Branch if equal to $F0, $12 [Flow: branch]
	.db $10, $FD		; 10 FD ; Branch if plus to $10, $FD [Flow: branch]
	cmp $8A00.w		; CD 00 8A ; Compare $8A00.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	sbc $22E1.w		; ED E1 22 ; Subtract $22E1.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $CCDC.w		; EE DC CC ; Increment $CCDC.w [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $43.b,S		; 03 43 ; OR accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $30, $F0		; 30 F0 ; Branch if minus to $30, $F0 [Flow: branch]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	mvp $46,$42		; 44 42 46 ; Move block positive $46,$42 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	stz $1C.b		; 64 1C ; Store zero to $1C.b
	ldy #$44.b		; A0 44 ; Load #$44.b into Y register [Writes: Y Index] [Flags: NZ]
	and ($8A.b,X)		; 21 8A ; Logical AND ($8A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $2C5513.l,X		; FF 13 55 2C ; Subtract with carry (long,X) $2C5513.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	sbc ($44.b,S),Y		; F3 44 ; Subtract with carry (stack relative indirect indexed) ($44.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	asl $DE8A.w,X		; 1E 8A DE ; Arithmetic shift left $DE8A.w,X [Reads: X Index] [Flags: NCZ]
	sbc $34E0FE.l,X		; FF FE E0 34 ; Subtract with carry (long,X) $34E0FE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $1F.b,S		; 43 1F ; Exclusive OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $CAED7A.l,X		; FF 7A ED CA ; Subtract with carry (long,X) $CAED7A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $90, $57		; 90 57 ; Branch if carry clear to $90, $57 [Flow: branch]
	ror $21.b,X		; 76 21 ; Rotate right $21.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	and ($0E.b,S),Y		; 33 0E ; AND accumulator (stack relative indirect indexed) ($0E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $12F1.w		; EE F1 12 ; Increment $12F1.w [Flags: NZ]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	sbc $DCFE.w,X		; FD FE DC ; Subtract with carry $DCFE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $FD1001.l		; 0F 01 10 FD ; OR accumulator with memory (long) $FD1001.l [Writes: Accumulator] [Flags: NZ]
	dec $7AF1.w		; CE F1 7A ; Decrement $7AF1.w [Flags: NZ]
	and ($C1.b),Y		; 31 C1 ; AND accumulator with memory ($C1.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	mvn $FB,$53		; 54 53 FB ; Move block negative $FB,$53 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cmp ($33.b)		; D2 33 ; Compare accumulator (indirect) ($33.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	and ($8A.b),Y		; 31 8A ; AND accumulator with memory ($8A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($45.b),Y		; F1 45 ; Subtract with carry ($45.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $42, $0E		; 42 0E ; Reserved instruction
	.db $F0, $22		; F0 22 ; Branch if equal to $F0, $22 [Flow: branch]
	asl $8ADE.w,X		; 1E DE 8A ; Arithmetic shift left $8ADE.w,X [Reads: X Index] [Flags: NCZ]
	ora ($53.b,S),Y		; 13 53 ; OR accumulator (stack relative indirect indexed) ($53.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $03EEEE.l		; 2F EE EE 03 ; AND accumulator with memory (long) $03EEEE.l [Writes: Accumulator] [Flags: NZ]
	.db $10, $11		; 10 11 ; Branch if plus to $10, $11 [Flow: branch]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $D1DC.w,X		; FE DC D1 ; Increment memory $D1DC.w,X [Reads: X Index] [Flags: NZ]
	jsl $222312.l		; 22 12 23 22 ; Jump to subroutine long $222312.l [Writes: Stack Pointer] [Flow: call]
	ora $F0CE8A.l,X		; 1F 8A CE F0 ; Logical OR long $F0CE8A.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $43.b,X		; 34 43 ; Test bits $43.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora $FF8AF0.l,X		; 1F F0 8A FF ; Logical OR long $FF8AF0.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and ($01.b,X)		; 21 01 ; Logical AND ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsr ($FFCE.w,X)		; FC CE FF ; Jump to subroutine indirect indexed ($FFCE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$11E0]		; DC E0 11 ; Jump long indirect [$11E0] [Flow: jump]
	jsl $DEBCEB.l		; 22 EB BC DE ; Jump to subroutine long $DEBCEB.l [Writes: Stack Pointer] [Flow: call]
	cmp $D27A.w,X		; DD 7A D2 ; Compare accumulator $D27A.w,X [Reads: X Index] [Flags: NCZ]
	and ($11.b,S),Y		; 33 11 ; AND accumulator (stack relative indirect indexed) ($11.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $4004.w,X		; FE 04 40 ; Increment memory $4004.w,X [Reads: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	sbc $8A.b		; E5 8A ; Subtract $8A.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	mvn $11,$21		; 54 21 11 ; Move block negative $11,$21 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	and ($10.b,S),Y		; 33 10 ; AND accumulator (stack relative indirect indexed) ($10.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $01E1.w		; EE E1 01 ; Increment $01E1.w [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $FC3212.l		; 22 12 32 FC ; Jump to subroutine long $FC3212.l [Writes: Stack Pointer] [Flow: call]
	cmp $1C4311.l,X		; DF 11 43 1C ; Compare accumulator (long,X) $1C4311.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dec $EE0F.w		; CE 0F EE ; Decrement $EE0F.w [Flags: NZ]
	sbc ($33.b),Y		; F1 33 ; Subtract with carry ($33.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($10.b)		; 32 10 ; AND accumulator with memory (indirect) ($10.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $ED0F8A.l		; 0F 8A 0F ED ; OR accumulator with memory (long) $ED0F8A.l [Writes: Accumulator] [Flags: NZ]
	sbc $104213.l,X		; FF 13 42 10 ; Subtract with carry (long,X) $104213.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($2E.b)		; 12 2E ; OR accumulator with memory (indirect) ($2E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dec BG3VOFS.w		; CE 12 21 ; Decrement BG3VOFS.w [Flags: NZ]
	ora $EB10F0.l		; 0F F0 10 EB ; OR accumulator with memory (long) $EB10F0.l [Writes: Accumulator] [Flags: NZ]
	ldy $FF8A.w,X		; BC 8A FF ; Load Y register $FF8A.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $ACDB0F.l,X		; FF 0F DB AC ; Subtract with carry (long,X) $ACDB0F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $7A		; F0 7A ; Branch if equal to $F0, $7A [Flow: branch]
	asl $04DD.w		; 0E DD 04 ; Arithmetic shift left $04DD.w [Flags: NCZ]
	adc $0D.b		; 65 0D ; Add $0D.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda $1212.w		; AD 12 12 ; Load $1212.w into accumulator [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($24.b,X)		; 21 24 ; Logical AND ($24.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	mvn $FF,$20		; 54 20 FF ; Move block negative $FF,$20 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	.db $10, $1F		; 10 1F ; Branch if plus to $10, $1F [Flow: branch]
	sbc $52358A.l,X		; FF 8A 35 52 ; Subtract with carry (long,X) $52358A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $22E0.w,X		; FD E0 22 ; Subtract with carry $22E0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($10.b,X)		; 21 10 ; Logical AND ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($8A.b),Y		; 11 8A ; OR accumulator with memory ($8A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $F0CD.w		; 0D CD F0 ; Logical OR $F0CD.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($31.b,S),Y		; 13 31 ; OR accumulator (stack relative indirect indexed) ($31.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($23.b),Y		; 11 23 ; OR accumulator with memory ($23.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $CECC7A.l		; 2F 7A CC CE ; AND accumulator with memory (long) $CECC7A.l [Writes: Accumulator] [Flags: NZ]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $2C,$66		; 44 66 2C ; Move block positive $2C,$66 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	dec $118A.w		; CE 8A 11 ; Decrement $118A.w [Flags: NZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($21.b,S),Y		; 13 21 ; OR accumulator (stack relative indirect indexed) ($21.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx $EDCE.w		; EC CE ED ; Compare $EDCE.w with X register [Reads: X Index] [Flags: NCZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $23EF.w		; EE EF 23 ; Increment $23EF.w [Flags: NZ]
	asl $D0CB.w,X		; 1E CB D0 ; Arithmetic shift left $D0CB.w,X [Reads: X Index] [Flags: NCZ]
	jsr ($7ABD.w,X)		; FC BD 7A ; Jump to subroutine indirect indexed ($7ABD.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	lda $4103.w,X		; BD 03 41 ; Load $4103.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $0F11.w		; ED 11 0F ; Subtract $0F11.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	.db $B0, $8A		; B0 8A ; Branch if carry set to $B0, $8A [Flow: branch]
	bit $53.b		; 24 53 ; Test bits $53.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	.db $10, $23		; 10 23 ; Branch if plus to $10, $23 [Flow: branch]
	.db $30, $EC		; 30 EC ; Branch if minus to $30, $EC [Flow: branch]
	.db $D0, $44		; D0 44 ; Branch if not equal to $D0, $44 [Flow: branch]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($00.b),Y		; 31 00 ; AND accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $021002.l,X		; FF 02 10 02 ; Subtract with carry (long,X) $021002.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($1E.b,S),Y		; 33 1E ; AND accumulator (stack relative indirect indexed) ($1E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	dec $14DE.w,X		; DE DE 14 ; Decrement memory $14DE.w,X [Reads: X Index] [Flags: NZ]
	and ($45.b,S),Y		; 33 45 ; AND accumulator (stack relative indirect indexed) ($45.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($22.b,S),Y		; 33 22 ; AND accumulator (stack relative indirect indexed) ($22.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ldy $45F2.w		; AC F2 45 ; Load $45F2.w into Y register [Writes: Y Index] [Flags: NZ]
	and ($02.b)		; 32 02 ; AND accumulator with memory (indirect) ($02.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $20.b,S		; 23 20 ; AND accumulator with stack relative $20.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $34D0.w,X		; FD D0 34 ; Subtract with carry $34D0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $DC1FE0.l		; 2F E0 1F DC ; AND accumulator with memory (long) $DC1FE0.l [Writes: Accumulator] [Flags: NZ]
	cpy $DF8A.w		; CC 8A DF ; Compare $DF8A.w with Y register [Reads: Y Index] [Flags: NCZ]
	and $0D.b,S		; 23 0D ; AND accumulator with stack relative $0D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $BBFEF0.l,X		; DF F0 FE BB ; Compare accumulator (long,X) $BBFEF0.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	dec $F17A.w		; CE 7A F1 ; Decrement $F17A.w [Flags: NZ]
	tsb $64C1.w		; 0C C1 64 ; Test and set bits $64C1.w [Reads: Accumulator] [Flags: Z]
	and ($E9.b,X)		; 21 E9 ; Logical AND ($E9.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda $028A21.l,X		; BF 21 8A 02 ; Load long $028A21.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	bit $44.b,X		; 34 44 ; Test bits $44.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and ($0F.b),Y		; 31 0F ; AND accumulator with memory ($0F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $12		; F0 12 ; Branch if equal to $F0, $12 [Flow: branch]
	jsl $40257A.l		; 22 7A 25 40 ; Jump to subroutine long $40257A.l [Writes: Stack Pointer] [Flow: call]
	cmp ($10.b),Y		; D1 10 ; Compare accumulator ($10.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	rol $74.b		; 26 74 ; Rotate left $74.b [Reads: Direct Page] [Flags: NCZ]
	jsl $FD8A31.l		; 22 31 8A FD ; Jump to subroutine long $FD8A31.l [Writes: Stack Pointer] [Flow: call]
	dec $2100.w,X		; DE 00 21 ; Decrement memory $2100.w,X [Reads: X Index] [Flags: NZ]
	.db $10, $13		; 10 13 ; Branch if plus to $10, $13 [Flow: branch]
	eor $1F.b,S		; 43 1F ; Exclusive OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	cpx #$32.b		; E0 32 ; Compare #$32.b with X register [Reads: X Index] [Flags: NCZ]
	asl $6503.w,X		; 1E 03 65 ; Arithmetic shift left $6503.w,X [Reads: X Index] [Flags: NCZ]
	.db $30, $DC		; 30 DC ; Branch if minus to $30, $DC [Flow: branch]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and ($EC.b,X)		; 21 EC ; Logical AND ($EC.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpy $8ACF.w		; CC CF 8A ; Compare $8ACF.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $10, $DD		; 10 DD ; Branch if plus to $10, $DD [Flow: branch]
	ora ($F0.b,X)		; 01 F0 ; Logical OR ($F0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $EFBC.w		; 0E BC EF ; Arithmetic shift left $EFBC.w [Flags: NCZ]
	jmp.w [$CD8A]		; DC 8A CD ; Jump long indirect [$CD8A] [Flow: jump]
	cop $0F.b		; 02 0F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $DFDD.w		; 0E DD DF ; Arithmetic shift left $DFDD.w [Flags: NCZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $42.b,X		; 35 42 ; Logical AND $42.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $FE2111.l		; 22 11 21 FE ; Jump to subroutine long $FE2111.l [Writes: Stack Pointer] [Flow: call]
	ora ($32.b)		; 12 32 ; OR accumulator with memory (indirect) ($32.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	and ($0F.b),Y		; 31 0F ; AND accumulator with memory ($0F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $13		; F0 13 ; Branch if equal to $F0, $13 [Flow: branch]
	and ($36.b)		; 32 36 ; AND accumulator with memory (indirect) ($36.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	stz $0D.b,X		; 74 0D ; Store zero to $0D.b,X [Reads: X Index]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $0FFF.w		; EE FF 0F ; Increment $0FFF.w [Flags: NZ]
	sbc $0F4314.l,X		; FF 14 43 0F ; Subtract with carry (long,X) $0F4314.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $7A.b		; 02 7A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $F1CD.w		; 2D CD F1 ; Logical AND $F1CD.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and ($20.b,S),Y		; 33 20 ; AND accumulator (stack relative indirect indexed) ($20.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($54.b,S),Y		; 13 54 ; OR accumulator (stack relative indirect indexed) ($54.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	trb $DD8A.w		; 1C 8A DD ; Test and reset bits $DD8A.w [Reads: Accumulator] [Flags: Z]
	sbc ($32.b)		; F2 32 ; Subtract with carry (indirect) ($32.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and ($0D.b)		; 32 0D ; AND accumulator with memory (indirect) ($0D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $8ACC0F.l,X		; DF 0F CC 8A ; Compare accumulator (long,X) $8ACC0F.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	cpy #$11.b		; C0 11 ; Compare #$11.b with Y register [Reads: Y Index] [Flags: NCZ]
	sbc $FDFFFE.l,X		; FF FE FF FD ; Subtract with carry (long,X) $FDFFFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp.w [$8ACE]		; DC CE 8A ; Jump long indirect [$8ACE] [Flow: jump]
	inc $F1DE.w,X		; FE DE F1 ; Increment memory $F1DE.w,X [Reads: X Index] [Flags: NZ]
	jsl $CDEC20.l		; 22 20 EC CD ; Jump to subroutine long $CDEC20.l [Writes: Stack Pointer] [Flow: call]
	sbc ($7A.b),Y		; F1 7A ; Subtract with carry ($7A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr $54.b,X		; 56 54 ; Logical shift right $54.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	eor $40.b		; 45 40 ; Exclusive OR $40.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $223223.l		; EF 23 32 22 ; Subtract with carry (long) $223223.l [Writes: Accumulator] [Flags: NCVZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $2133F1.l,X		; FF F1 33 21 ; Subtract with carry (long,X) $2133F1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($00.b,X)		; 21 00 ; Logical AND ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $22DEED.l		; 0F ED DE 22 ; OR accumulator with memory (long) $22DEED.l [Writes: Accumulator] [Flags: NZ]
	and ($12.b,X)		; 21 12 ; Logical AND ($12.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and ($10.b,X)		; 21 10 ; Logical AND ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $2FF1.w,X		; FD F1 2F ; Subtract with carry $2FF1.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $304401.l		; 0F 01 44 30 ; OR accumulator with memory (long) $304401.l [Writes: Accumulator] [Flags: NZ]
	wai		; CB ; Wait for interrupt
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	cpy $64.b		; C4 64 ; Compare $64.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	ora ($14.b),Y		; 11 14 ; OR accumulator with memory ($14.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor ($EB.b),Y		; 51 EB ; Exclusive OR accumulator with memory ($EB.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda #$CE.b		; A9 CE ; Load #$CE.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	inc $E0DE.w,X		; FE DE E0 ; Increment memory $E0DE.w,X [Reads: X Index] [Flags: NZ]
	and ($DA.b,X)		; 21 DA ; Logical AND ($DA.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	cmp $8AC9.w,X		; DD C9 8A ; Compare accumulator $8AC9.w,X [Reads: X Index] [Flags: NCZ]
	ldy $03DF.w,X		; BC DF 03 ; Load Y register $03DF.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	and ($0F.b),Y		; 31 0F ; AND accumulator with memory ($0F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpx $F0CD.w		; EC CD F0 ; Compare $F0CD.w with X register [Reads: X Index] [Flags: NCZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	lsr $65.b		; 46 65 ; Logical shift right $65.b [Reads: Direct Page] [Flags: NCZ]
	.db $30, $03		; 30 03 ; Branch if minus to $30, $03 [Flow: branch]
	.db $42, $00		; 42 00 ; Reserved instruction
	bit $55.b		; 24 55 ; Test bits $55.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	and ($DC.b,X)		; 21 DC ; Logical AND ($DC.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc ($31.b,S),Y		; F3 31 ; Subtract with carry (stack relative indirect indexed) ($31.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora ($76.b,S),Y		; 13 76 ; OR accumulator (stack relative indirect indexed) ($76.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor ($31.b,S),Y		; 53 31 ; XOR accumulator (stack relative indirect indexed) ($31.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	jmp.w [$CEDE]		; DC DE CE ; Jump long indirect [$CEDE] [Flow: jump]
	cop $45.b		; 02 45 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $43.b,S		; 43 43 ; Exclusive OR accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $138A.w,X		; FD 8A 13 ; Subtract with carry $138A.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $13CE.w,X		; 1E CE 13 ; Arithmetic shift left $13CE.w,X [Reads: X Index] [Flags: NCZ]
	eor $20.b,S		; 43 20 ; Exclusive OR accumulator with stack relative $20.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $0F8A10.l,X		; FF 10 8A 0F ; Subtract with carry (long,X) $0F8A10.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $0E4234.l,X		; FF 34 42 0E ; Subtract with carry (long,X) $0E4234.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $8AEC0F.l,X		; FF 0F EC 8A ; Subtract with carry (long,X) $8AEC0F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FE11F0.l		; EF F0 11 FE ; Subtract with carry (long) $FE11F0.l [Writes: Accumulator] [Flags: NCVZ]
	sbc $DBFEFF.l		; EF FF FE DB ; Subtract with carry (long) $DBFEFF.l [Writes: Accumulator] [Flags: NCVZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldy $12EF.w		; AC EF 12 ; Load $12EF.w into Y register [Writes: Y Index] [Flags: NZ]
	jsl $DECC1E.l		; 22 1E CC DE ; Jump to subroutine long $DECC1E.l [Writes: Stack Pointer] [Flow: call]
	sbc ($7A.b),Y		; F1 7A ; Subtract with carry ($7A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($24.b)		; 32 24 ; AND accumulator with memory (indirect) ($24.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $1E.b		; 65 1E ; Add $1E.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($46.b),Y		; F1 46 ; Subtract with carry ($46.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	stz $2E.b		; 64 2E ; Store zero to $2E.b
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($31.b)		; F2 31 ; Subtract with carry (indirect) ($31.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inc $33E2.w		; EE E2 33 ; Increment $33E2.w [Flags: NZ]
	and $41.b,S		; 23 41 ; AND accumulator with stack relative $41.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $7A.b		; 00 7A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $35AEBA.l		; 2F BA AE 35 ; AND accumulator with memory (long) $35AEBA.l [Writes: Accumulator] [Flags: NZ]
	.db $42, $10		; 42 10 ; Reserved instruction
	trb $64.b		; 14 64 ; Test and reset bits $64.b [Reads: Accumulator] [Flags: Z]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ldy $3311.w		; AC 11 33 ; Load $3311.w into Y register [Writes: Y Index] [Flags: NZ]
	.db $42, $13		; 42 13 ; Reserved instruction
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	cmp ($33.b),Y		; D1 33 ; Compare accumulator ($33.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	bit $32.b,X		; 34 32 ; Test bits $32.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	jsl $DEAA2E.l		; 22 2E AA DE ; Jump to subroutine long $DEAA2E.l [Writes: Stack Pointer] [Flow: call]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $00FF0F.l,X		; FF 0F FF 00 ; Subtract with carry (long,X) $00FF0F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $CB0EE0.l		; 0F E0 0E CB ; OR accumulator with memory (long) $CB0EE0.l [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	sbc ($32.b,X)		; E1 32 ; Subtract with carry ($32.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr $FDEE.w		; 20 EE FD ; Jump to subroutine at $FDEE.w [Writes: Stack Pointer] [Flow: call]
	dec $7AFF.w,X		; DE FF 7A ; Decrement memory $7AFF.w,X [Reads: X Index] [Flags: NZ]
	rol $63.b,X		; 36 63 ; Rotate left $63.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $463214.l		; 0F 14 32 46 ; OR accumulator with memory (long) $463214.l [Writes: Accumulator] [Flags: NZ]
	and ($26.b,X)		; 21 26 ; Logical AND ($26.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($0E.b,X)		; 21 0E ; Logical AND ($0E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $F0, $10		; F0 10 ; Branch if equal to $F0, $10 [Flow: branch]
	jsl $1F5423.l		; 22 23 54 1F ; Jump to subroutine long $1F5423.l [Writes: Stack Pointer] [Flow: call]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	cpx #$0E.b		; E0 0E ; Compare #$0E.b with X register [Reads: X Index] [Flags: NCZ]
	sbc $306702.l		; EF 02 67 30 ; Subtract with carry (long) $306702.l [Writes: Accumulator] [Flags: NCVZ]
	brk $7A.b		; 00 7A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $14D0DD.l		; 0F DD D0 14 ; OR accumulator with memory (long) $14D0DD.l [Writes: Accumulator] [Flags: NZ]
	ror $1E.b		; 66 1E ; Rotate right $1E.b [Reads: Direct Page] [Flags: NCZ]
	sbc $F08A0F.l		; EF 0F 8A F0 ; Subtract with carry (long) $F08A0F.l [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $02		; 10 02 ; Branch if plus to $10, $02 [Flow: branch]
	mvp $EF,$1F		; 44 1F EF ; Move block positive $EF,$1F [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	.db $F0, $FF		; F0 FF ; Branch if equal to $F0, $FF [Flow: branch]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $00F0.w		; EE F0 00 ; Increment $00F0.w [Flags: NZ]
	asl $1F01.w		; 0E 01 1F ; Arithmetic shift left $1F01.w [Flags: NCZ]
	sbc $8ABA.w,X		; FD BA 8A ; Subtract with carry $8ABA.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $11E0.w		; CD E0 11 ; Compare $11E0.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsl $EFCDFC.l		; 22 FC CD EF ; Jump to subroutine long $EFCDFC.l [Writes: Stack Pointer] [Flow: call]
	ora $30027A.l		; 0F 7A 02 30 ; OR accumulator with memory (long) $30027A.l [Writes: Accumulator] [Flags: NZ]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($15.b),Y		; 11 15 ; OR accumulator with memory ($15.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $21.b		; 65 21 ; Add $21.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	inc $14FF.w,X		; FE FF 14 ; Increment memory $14FF.w,X [Reads: X Index] [Flags: NZ]
	adc $2F.b,X		; 75 2F ; Add $2F.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $7A		; F0 7A ; Branch if equal to $F0, $7A [Flow: branch]
	and ($EC.b)		; 32 EC ; AND accumulator with memory (indirect) ($EC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	sbc $55.b,S		; E3 55 ; Subtract stack-relative $55.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	and ($35.b,X)		; 21 35 ; Logical AND ($35.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $CCED7A.l,X		; 3F 7A ED CC ; AND accumulator with memory (long,X) $CCED7A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $52.b		; 05 52 ; Logical OR $52.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($33.b,X)		; 01 33 ; Logical OR ($33.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $CD7AFE.l		; 0F FE 7A CD ; OR accumulator with memory (long) $CD7AFE.l [Writes: Accumulator] [Flags: NZ]
	ora $64.b,X		; 15 64 ; OR accumulator with memory $64.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $41.b,S		; 23 41 ; AND accumulator with stack relative $41.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $8AEEFE.l		; EF FE EE 8A ; Subtract with carry (long) $8AEEFE.l [Writes: Accumulator] [Flags: NCVZ]
	sbc $21F0FE.l,X		; FF FE F0 21 ; Subtract with carry (long,X) $21F0FE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $BBFE00.l		; 0F 00 FE BB ; OR accumulator with memory (long) $BBFE00.l [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda $33D0.w,X		; BD D0 33 ; Load $33D0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $FFDD.w,X		; 1E DD FF ; Arithmetic shift left $FFDD.w,X [Reads: X Index] [Flags: NCZ]
	sbc $7AEF.w		; ED EF 7A ; Subtract $7AEF.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cop $32.b		; 02 32 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $24F1.w,X		; FE F1 24 ; Increment memory $24F1.w,X [Reads: X Index] [Flags: NZ]
	and ($14.b),Y		; 31 14 ; AND accumulator with memory ($14.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	mvp $42,$7A		; 44 7A 42 ; Move block positive $42,$7A [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ldy $5503.w		; AC 03 55 ; Load $5503.w into Y register [Writes: Y Index] [Flags: NZ]
	eor $65.b		; 45 65 ; Exclusive OR $65.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($7A.b,X)		; 21 7A ; Logical AND ($7A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $EECE.w,X		; FD CE EE ; Subtract with carry $EECE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $6604.w		; EE 04 66 ; Increment $6604.w [Flags: NZ]
	eor ($EC.b)		; 52 EC ; Exclusive OR accumulator with memory (indirect) ($EC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	cmp $F30D13.l,X		; DF 13 0D F3 ; Compare accumulator (long,X) $F30D13.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	mvp $FC,$63		; 44 63 FC ; Move block positive $FC,$63 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cpy $037A.w		; CC 7A 03 ; Compare $037A.w with Y register [Reads: Y Index] [Flags: NCZ]
	jsr $6236.w		; 20 36 62 ; Jump to subroutine at $6236.w [Writes: Stack Pointer] [Flow: call]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $EE8ADC.l,X		; 1F DC 8A EE ; Logical OR long $EE8ADC.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0F		; F0 0F ; Branch if equal to $F0, $0F [Flow: branch]
	sbc ($11.b),Y		; F1 11 ; Subtract with carry ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $ED.b		; 00 ED ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda $FF0000.l,X		; BF 00 00 FF ; Load long $FF0000.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $01CEDD.l,X		; FF DD CE 01 ; Subtract with carry (long,X) $01CEDD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $1111EF.l		; 0F EF 11 11 ; OR accumulator with memory (long) $1111EF.l [Writes: Accumulator] [Flags: NZ]
	inc $4303.w,X		; FE 03 43 ; Increment memory $4303.w,X [Reads: X Index] [Flags: NZ]
	and ($8A.b,X)		; 21 8A ; Logical AND ($8A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $13F0.w		; EE F0 13 ; Increment $13F0.w [Flags: NZ]
	eor $32.b,S		; 43 32 ; Exclusive OR accumulator with stack relative $32.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $10, $8A		; 10 8A ; Branch if plus to $10, $8A [Flow: branch]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	jmp.w [$24F1]		; DC F1 24 ; Jump long indirect [$24F1] [Flow: jump]
	and ($00.b),Y		; 31 00 ; AND accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $7A.b		; 00 7A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($EC.b),Y		; 31 EC ; AND accumulator with memory ($EC.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($34.b),Y		; F1 34 ; Subtract with carry ($34.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	mvp $FC,$53		; 44 53 FC ; Move block positive $FC,$53 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cmp $037A.w		; CD 7A 03 ; Compare $037A.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	eor ($22.b,S),Y		; 53 22 ; XOR accumulator (stack relative indirect indexed) ($22.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($34.b,S),Y		; 33 34 ; AND accumulator (stack relative indirect indexed) ($34.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($1E.b)		; 32 1E ; AND accumulator with memory (indirect) ($1E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $008A.w,X		; BD 8A 00 ; Load $008A.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $12E0.w		; EE E0 12 ; Increment $12E0.w [Flags: NZ]
	jsl $DDCD0D.l		; 22 0D CD DD ; Jump to subroutine long $DDCD0D.l [Writes: Stack Pointer] [Flow: call]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $00EF.w		; CD EF 00 ; Compare $00EF.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora $FFEFDC.l,X		; 1F DC EF FF ; Logical OR long $FFEFDC.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $D17A.w,X		; DD 7A D1 ; Compare accumulator $D17A.w,X [Reads: X Index] [Flags: NCZ]
	ora ($1F.b),Y		; 11 1F ; OR accumulator with memory ($1F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $3402.w		; CD 02 34 ; Compare $3402.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	bit $55.b,X		; 34 55 ; Test bits $55.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($FD.b,X)		; 21 FD ; Logical AND ($FD.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $122101.l		; EF 01 21 12 ; Subtract with carry (long) $122101.l [Writes: Accumulator] [Flags: NCVZ]
	mvn $7A,$31		; 54 31 7A ; Move block negative $7A,$31 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	and $D0BA.w		; 2D BA D0 ; Logical AND $D0BA.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and ($13.b,X)		; 21 13 ; Logical AND ($13.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	mvp $0F,$41		; 44 41 0F ; Move block positive $0F,$41 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	.db $10, $FE		; 10 FE ; Branch if plus to $10, $FE [Flow: branch]
	.db $F0, $25		; F0 25 ; Branch if equal to $F0, $25 [Flow: branch]
	adc $31.b		; 65 31 ; Add $31.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	nop		; EA ; No operation
.ACCU 16
.INDEX 16
	rep #$7A		; C2 7A
	and ($12.b)		; 32 12 ; AND accumulator with memory (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($25.b),Y		; 11 25 ; OR accumulator with memory ($25.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	mvn $01,$21		; 54 21 01 ; Move block negative $01,$21 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $DE8A.w		; 0D 8A DE ; Logical OR $DE8A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $101100.l,X		; FF 00 11 10 ; Subtract with carry (long,X) $101100.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $EB		; 10 EB ; Branch if plus to $10, $EB [Flow: branch]
	ldy $EF8A.w,X		; BC 8A EF ; Load Y register $EF8A.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	inc $FFEF.w,X		; FE EF FF ; Increment memory $FFEF.w,X [Reads: X Index] [Flags: NZ]
	sbc $FFCEEC.l,X		; FF EC CE FF ; Subtract with carry (long,X) $FFCEEC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	sbc ($EC.b),Y		; F1 EC ; Subtract with carry ($EC.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx $FD02.w,Y		; BE 02 FD ; Load X register $FD02.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	sbc $57.b,S		; E3 57 ; Subtract stack-relative $57.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	adc $8A.b,X		; 75 8A ; Add $8A.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $FD01EF.l		; 0F EF 01 FD ; OR accumulator with memory (long) $FD01EF.l [Writes: Accumulator] [Flags: NZ]
	sep #$44		; E2 44 ; Set processor status bits #$44 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	mvp $7A,$21		; 44 21 7A ; Move block positive $7A,$21 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $02CEED.l		; 0F ED CE 02 ; OR accumulator with memory (long) $02CEED.l [Writes: Accumulator] [Flags: NZ]
	and ($34.b,S),Y		; 33 34 ; AND accumulator (stack relative indirect indexed) ($34.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($32.b,S),Y		; 33 32 ; AND accumulator (stack relative indirect indexed) ($32.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	inc $F3EF.w		; EE EF F3 ; Increment $F3EF.w [Flags: NZ]
	lsr $53.b,X		; 56 53 ; Logical shift right $53.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $11018A.l,X		; FF 8A 01 11 ; Subtract with carry (long,X) $11018A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	trb $42.b		; 14 42 ; Test and reset bits $42.b [Reads: Accumulator] [Flags: Z]
	ora $EF7AEE.l		; 0F EE 7A EF ; OR accumulator with memory (long) $EF7AEE.l [Writes: Accumulator] [Flags: NZ]
	sbc $25DF.w		; ED DF 25 ; Subtract $25DF.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	.db $62, $CB, $CC		; 62 CB CC ; Push effective relative address $62, $CB, $CC [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $F0DD.w		; ED DD F0 ; Subtract $F0DD.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	brk $DD.b		; 00 DD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $EFEE.w,X		; DE EE EF ; Decrement memory $EFEE.w,X [Reads: X Index] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	sbc $0ECE.w,X		; FD CE 0E ; Subtract with carry $0ECE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	wai		; CB ; Wait for interrupt
	.db $D0, $34		; D0 34 ; Branch if not equal to $D0, $34 [Flow: branch]
	eor $34.b,S		; 43 34 ; Exclusive OR accumulator with stack relative $34.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($0F.b,X)		; 21 0F ; Logical AND ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $00FF.w		; ED FF 00 ; Subtract $00FF.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	bit $43.b,X		; 34 43 ; Test bits $43.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	jsl $DD1F7A.l		; 22 7A 1F DD ; Jump to subroutine long $DD1F7A.l [Writes: Stack Pointer] [Flow: call]
	sbc $460100.l		; EF 00 01 46 ; Subtract with carry (long) $460100.l [Writes: Accumulator] [Flags: NCVZ]
	mvn $7A,$1F		; 54 1F 7A ; Move block negative $7A,$1F [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	dec $23F1.w,X		; DE F1 23 ; Decrement memory $23F1.w,X [Reads: X Index] [Flags: NZ]
	and ($46.b)		; 32 46 ; AND accumulator with memory (indirect) ($46.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sbc $337A01.l		; EF 01 7A 33 ; Subtract with carry (long) $337A01.l [Writes: Accumulator] [Flags: NCVZ]
	asl $47E0.w,X		; 1E E0 47 ; Arithmetic shift left $47E0.w,X [Reads: X Index] [Flags: NCZ]
	adc $44.b,X		; 75 44 ; Add $44.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $EF		; 30 EF ; Branch if minus to $30, $EF [Flow: branch]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $01E0.w		; EE E0 01 ; Increment $01E0.w [Flags: NZ]
	and ($0F.b,X)		; 21 0F ; Logical AND ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $10, $0E		; 10 0E ; Branch if plus to $10, $0E [Flow: branch]
	jmp.w [$CE8A]		; DC 8A CE ; Jump long indirect [$CE8A] [Flow: jump]
	sbc $EEFFEF.l,X		; FF EF FF EE ; Subtract with carry (long,X) $EEFFEF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $EFDD.w		; EE DD EF ; Increment $EFDD.w [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	.db $10, $D9		; 10 D9 ; Branch if plus to $10, $D9 [Flow: branch]
	lda $EFFF.w		; AD FF EF ; Load $EFFF.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $8A7525.l,X		; FF 25 75 8A ; Subtract with carry (long,X) $8A7525.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($0F.b,X)		; 21 0F ; Logical AND ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $00EF.w		; ED EF 00 ; Subtract $00EF.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	and $44.b,S		; 23 44 ; AND accumulator with stack relative $44.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($7A.b),Y		; 31 7A ; AND accumulator with memory ($7A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($FD.b,X)		; 01 FD ; Logical OR ($FD.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp $5424EF.l,X		; DF EF 24 54 ; Compare accumulator (long,X) $5424EF.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	and ($11.b),Y		; 31 11 ; AND accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	asl $25DE.w,X		; 1E DE 25 ; Arithmetic shift left $25DE.w,X [Reads: X Index] [Flags: NCZ]
	adc $2F.b		; 65 2F ; Add $2F.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cop $43.b		; 02 43 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $0F008A.l		; 2F 8A 00 0F ; AND accumulator with memory (long) $0F008A.l [Writes: Accumulator] [Flags: NZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $43.b,S		; 23 43 ; AND accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $FF7AEE.l		; 2F EE 7A FF ; AND accumulator with memory (long) $FF7AEE.l [Writes: Accumulator] [Flags: NZ]
	sbc $45F010.l,X		; FF 10 F0 45 ; Subtract with carry (long,X) $45F010.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $CCCB.w		; 2E CB CC ; Rotate left $CCCB.w [Flags: NCZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $F1DC.w,X		; FE DC F1 ; Increment memory $F1DC.w,X [Reads: X Index] [Flags: NZ]
	ora $F0CDED.l		; 0F ED CD F0 ; OR accumulator with memory (long) $F0CDED.l [Writes: Accumulator] [Flags: NZ]
	ora $CEBB7A.l		; 0F 7A BB CE ; OR accumulator with memory (long) $CEBB7A.l [Writes: Accumulator] [Flags: NZ]
	cmp $CCEE.w,X		; DD EE CC ; Compare accumulator $CCEE.w,X [Reads: X Index] [Flags: NCZ]
	sep #$44		; E2 44 ; Set processor status bits #$44 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	lsr $8A.b		; 46 8A ; Logical shift right $8A.b [Reads: Direct Page] [Flags: NCZ]
	eor ($FE.b,X)		; 41 FE ; Exclusive OR accumulator with memory ($FE.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	inc $01EE.w,X		; FE EE 01 ; Increment memory $01EE.w,X [Reads: X Index] [Flags: NZ]
	jsl $7A3333.l		; 22 33 33 7A ; Jump to subroutine long $7A3333.l [Writes: Stack Pointer] [Flow: call]
	eor $21EFCC.l,X		; 5F CC EF 21 ; Exclusive OR accumulator with memory (long,X) $21EFCC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $45.b		; 00 45 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $0C.b		; 64 0C ; Store zero to $0C.b
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	.db $D0, $12		; D0 12 ; Branch if not equal to $D0, $12 [Flow: branch]
	bit $21.b,X		; 34 21 ; Test bits $21.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora $54.b,S		; 03 54 ; OR accumulator with stack relative $54.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($12.b),Y		; 11 12 ; OR accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $FF		; 10 FF ; Branch if plus to $10, $FF [Flow: branch]
	.db $F0, $13		; F0 13 ; Branch if equal to $F0, $13 [Flow: branch]
	eor $21.b,X		; 55 21 ; Exclusive OR accumulator with memory $21.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $F0		; 10 F0 ; Branch if plus to $10, $F0 [Flow: branch]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $2101EF.l		; 0F EF 01 21 ; OR accumulator with memory (long) $2101EF.l [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $CD8AED.l		; 0F ED 8A CD ; OR accumulator with memory (long) $CD8AED.l [Writes: Accumulator] [Flags: NZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $EFDE.w		; ED DE EF ; Subtract $EFDE.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	asl $8ADE.w		; 0E DE 8A ; Arithmetic shift left $8ADE.w [Flags: NCZ]
	sbc $DEEEEF.l,X		; FF EF EE DE ; Subtract with carry (long,X) $DEEEEF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $4303F0.l		; EF F0 03 43 ; Subtract with carry (long) $4303F0.l [Writes: Accumulator] [Flags: NCVZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($0E.b),Y		; 11 0E ; OR accumulator with memory ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $23EFFE.l		; EF FE EF 23 ; Subtract with carry (long) $23EFFE.l [Writes: Accumulator] [Flags: NCVZ]
	eor ($21.b,S),Y		; 53 21 ; XOR accumulator (stack relative indirect indexed) ($21.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	eor ($ED.b),Y		; 51 ED ; Exclusive OR accumulator with memory ($ED.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	dec $35F1.w,X		; DE F1 35 ; Decrement memory $35F1.w,X [Reads: X Index] [Flags: NZ]
	eor $10.b,S		; 43 10 ; Exclusive OR accumulator with stack relative $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($7A.b),Y		; 11 7A ; OR accumulator with memory ($7A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($44.b,X)		; 01 44 ; Logical OR ($44.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $30, $12		; 30 12 ; Branch if minus to $30, $12 [Flow: branch]
	mvn $8A,$43		; 54 43 8A ; Move block negative $8A,$43 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $22DF.w		; 0D DF 22 ; Logical OR $22DF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $203323.l		; 22 23 33 20 ; Jump to subroutine long $203323.l [Writes: Stack Pointer] [Flow: call]
	sbc $01FF7A.l,X		; FF 7A FF 01 ; Subtract with carry (long,X) $01FF7A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $412402.l,X		; FF 02 24 41 ; Subtract with carry (long,X) $412402.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	lda $EE7A.w,X		; BD 7A EE ; Load $EE7A.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $CCCB.w,X		; FE CB CC ; Increment memory $CCCB.w,X [Reads: X Index] [Flags: NZ]
	dec $CDEC.w		; CE EC CD ; Decrement $CDEC.w [Flags: NZ]
	cmp $FF8A.w		; CD 8A FF ; Compare $FF8A.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	inc $DCFF.w		; EE FF DC ; Increment $DCFF.w [Flags: NZ]
	dec $2003.w		; CE 03 20 ; Decrement $2003.w [Flags: NZ]
	ora ($8A.b,S),Y		; 13 8A ; OR accumulator (stack relative indirect indexed) ($8A.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($10.b,X)		; 21 10 ; Logical AND ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $F0EE.w		; ED EE F0 ; Subtract $F0EE.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ora ($33.b)		; 12 33 ; OR accumulator with memory (indirect) ($33.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $7A.b,S		; 43 7A ; Exclusive OR accumulator with stack relative $7A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $E0DC.w,X		; 3E DC E0 ; Rotate left $E0DC.w,X [Reads: X Index] [Flags: NCZ]
	jsl $132122.l		; 22 22 21 13 ; Jump to subroutine long $132122.l [Writes: Stack Pointer] [Flow: call]
	and ($7A.b),Y		; 31 7A ; AND accumulator with memory ($7A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	dec $3214.w,X		; DE 14 32 ; Decrement memory $3214.w,X [Reads: X Index] [Flags: NZ]
	ora $744602.l		; 0F 02 46 74 ; OR accumulator with memory (long) $744602.l [Writes: Accumulator] [Flags: NZ]
	asl $0F8A.w		; 0E 8A 0F ; Arithmetic shift left $0F8A.w [Flags: NCZ]
	sbc $4324F0.l,X		; FF F0 24 43 ; Subtract with carry (long,X) $4324F0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($10.b,X)		; 21 10 ; Logical AND ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($7A.b),Y		; 11 7A ; OR accumulator with memory ($7A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $02DD.w,X		; 1E DD 02 ; Arithmetic shift left $02DD.w,X [Reads: X Index] [Flags: NCZ]
	jsl $FE0F33.l		; 22 33 0F FE ; Jump to subroutine long $FE0F33.l [Writes: Stack Pointer] [Flow: call]
	dec $EE7A.w,X		; DE 7A EE ; Decrement memory $EE7A.w,X [Reads: X Index] [Flags: NZ]
	dec $BBEC.w,X		; DE EC BB ; Decrement memory $BBEC.w,X [Reads: X Index] [Flags: NZ]
	dec $CAFE.w		; CE FE CA ; Decrement $CAFE.w [Flags: NZ]
	lda $117A.w		; AD 7A 11 ; Load $117A.w into accumulator [Writes: Accumulator] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	lda $14EF.w,X		; BD EF 14 ; Load $14EF.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $8A.b,X		; 55 8A ; Exclusive OR accumulator with memory $8A.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and ($0F.b,X)		; 21 0F ; Logical AND ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	inc $EFED.w,X		; FE ED EF ; Increment memory $EFED.w,X [Reads: X Index] [Flags: NZ]
	jsl $6A3044.l		; 22 44 30 6A ; Jump to subroutine long $6A3044.l [Writes: Stack Pointer] [Flow: call]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$3700.w		; E0 00 37 ; Compare #$3700.w with X register [Reads: X Index] [Flags: NCZ]
	adc $FD.b,X		; 75 FD ; Add $FD.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $7A.b,X		; F5 7A ; Subtract $7A.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($0F.b)		; 32 0F ; AND accumulator with memory (indirect) ($0F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $43.b,S		; 23 43 ; AND accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $41.b,X		; 55 41 ; Exclusive OR accumulator with memory $41.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	nop		; EA ; No operation
	sta $5535.w,X		; 9D 35 55 ; Store accumulator to $5535.w,X [Reads: Accumulator, X Index]
	and ($45.b,S),Y		; 33 45 ; AND accumulator (stack relative indirect indexed) ($45.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $10.b,S		; 43 10 ; Exclusive OR accumulator with stack relative $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	inc $03FF.w		; EE FF 03 ; Increment $03FF.w [Flags: NZ]
	jsr $3202.w		; 20 02 32 ; Jump to subroutine at $3202.w [Writes: Stack Pointer] [Flow: call]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $7A		; D0 7A ; Branch if not equal to $D0, $7A [Flow: branch]
	ora $DDCECB.l,X		; 1F CB CE DD ; Logical OR long $DDCECB.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$DEBB]		; DC BB DE ; Jump long indirect [$DEBB] [Flow: jump]
	sbc $DBEE7A.l,X		; FF 7A EE DB ; Subtract with carry (long,X) $DBEE7A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $CDAA.w,Y		; 99 AA CD ; Store accumulator to $CDAA.w,Y [Reads: Y Index, Accumulator]
	sbc $7A6624.l		; EF 24 66 7A ; Subtract with carry (long) $7A6624.l [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cpx $BDBA.w		; EC BA BD ; Compare $BDBA.w with X register [Reads: X Index] [Flags: NCZ]
	ora $55.b,S		; 03 55 ; OR accumulator with stack relative $55.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	mvp $6A,$32		; 44 32 6A ; Move block positive $6A,$32 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $35BE.w		; 0D BE 35 ; Logical OR $35BE.w with accumulator [Writes: Accumulator] [Flags: NZ]
	eor ($0D.b,S),Y		; 53 0D ; XOR accumulator (stack relative indirect indexed) ($0D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $63.b		; 05 63 ; Logical OR $63.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($8A.b)		; 32 8A ; AND accumulator with memory (indirect) ($8A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $43.b		; 14 43 ; Test and reset bits $43.b [Reads: Accumulator] [Flags: Z]
	jsr $8AFE.w		; 20 FE 8A ; Jump to subroutine at $8AFE.w [Writes: Stack Pointer] [Flow: call]
	sbc $221100.l,X		; FF 00 11 22 ; Subtract with carry (long,X) $221100.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($31.b,S),Y		; 33 31 ; AND accumulator (stack relative indirect indexed) ($31.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	dec $45F1.w,X		; DE F1 45 ; Decrement memory $45F1.w,X [Reads: X Index] [Flags: NZ]
	eor ($FF.b,S),Y		; 53 FF ; XOR accumulator (stack relative indirect indexed) ($FF.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $1D.b		; 24 1D ; Test bits $1D.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	cmp $ACECFF.l,X		; DF FF EC AC ; Compare accumulator (long,X) $ACECFF.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	cmp $DECC.w,X		; DD CC DE ; Compare accumulator $DECC.w,X [Reads: X Index] [Flags: NCZ]
	sbc $FDFF8A.l,X		; FF 8A FF FD ; Subtract with carry (long,X) $FDFF8A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy $EEED.w		; CC ED EE ; Compare $EEED.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($7A.b,S),Y		; 33 7A ; AND accumulator (stack relative indirect indexed) ($7A.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($FC.b),Y		; 31 FC ; AND accumulator with memory ($FC.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda $03BD.w,Y		; B9 BD 03 ; Load $03BD.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $33.b		; 65 33 ; Add $33.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	eor $6B.b,S		; 43 6B ; Exclusive OR accumulator with stack relative $6B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $35AF.w		; 0C AF 35 ; Test and set bits $35AF.w [Reads: Accumulator] [Flags: Z]
	eor $0E.b,S		; 43 0E ; Exclusive OR accumulator with stack relative $0E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	trb $53.b		; 14 53 ; Test and reset bits $53.b [Reads: Accumulator] [Flags: Z]
	.db $42, $AE		; 42 AE ; Reserved instruction
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $FF00.w,X		; 3D 00 FF ; AND accumulator with memory $FF00.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$04B8.w		; E0 B8 04 ; Compare #$04B8.w with X register [Reads: X Index] [Flags: NCZ]
	.db $70, $01		; 70 01 ; Branch if overflow set to $70, $01 [Flow: branch]
	sbc $07B8E0.l,X		; FF E0 B8 07 ; Subtract with carry (long,X) $07B8E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $90, $02		; 90 02 ; Branch if carry clear to $90, $02 [Flow: branch]
	sbc $09B8E0.l,X		; FF E0 B8 09 ; Subtract with carry (long,X) $09B8E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$FF03.w		; C0 03 FF ; Compare #$FF03.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpx #$04B8.w		; E0 B8 04 ; Compare #$04B8.w with X register [Reads: X Index] [Flags: NCZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $04B8E0.l,X		; FF E0 B8 04 ; Subtract with carry (long,X) $04B8E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $04B8E0.l,X		; FF E0 B8 04 ; Subtract with carry (long,X) $04B8E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $06		; 70 06 ; Branch if overflow set to $70, $06 [Flow: branch]
	sbc $04B8E0.l,X		; FF E0 B8 04 ; Subtract with carry (long,X) $04B8E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $07		; 70 07 ; Branch if overflow set to $70, $07 [Flow: branch]
	sbc $04B8E0.l,X		; FF E0 B8 04 ; Subtract with carry (long,X) $04B8E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $08		; 70 08 ; Branch if overflow set to $70, $08 [Flow: branch]
	sbc $07B8E0.l,X		; FF E0 B8 07 ; Subtract with carry (long,X) $07B8E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy #$8F09.w		; A0 09 8F ; Load #$8F09.w into Y register [Writes: Y Index] [Flags: NZ]
	sbc #$01B8.w		; E9 B8 01 ; Subtract #$01B8.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cpx #$8A0A.w		; E0 0A 8A ; Compare #$8A0A.w with X register [Reads: X Index] [Flags: NCZ]
	sbc #$01B8.w		; E9 B8 01 ; Subtract #$01B8.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cpx #$FF0B.w		; E0 0B FF ; Compare #$FF0B.w with X register [Reads: X Index] [Flags: NCZ]
	cpx #$03B8.w		; E0 B8 03 ; Compare #$03B8.w with X register [Reads: X Index] [Flags: NCZ]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $03B8E0.l,X		; FF E0 B8 03 ; Subtract with carry (long,X) $03B8E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy #$FF0D.w		; A0 0D FF ; Load #$FF0D.w into Y register [Writes: Y Index] [Flags: NZ]
	cpx #$01B8.w		; E0 B8 01 ; Compare #$01B8.w with X register [Reads: X Index] [Flags: NCZ]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0EB8EF.l,X		; FF EF B8 0E ; Subtract with carry (long,X) $0EB8EF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy #$FF0F.w		; A0 0F FF ; Load #$FF0F.w into Y register [Writes: Y Index] [Flags: NZ]
	sbc $0006B8.l		; EF B8 06 00 ; Subtract with carry (long) $0006B8.l [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $FF		; 10 FF ; Branch if plus to $10, $FF [Flow: branch]
	cpx #$03B8.w		; E0 B8 03 ; Compare #$03B8.w with X register [Reads: X Index] [Flags: NCZ]
	.db $D0, $11		; D0 11 ; Branch if not equal to $D0, $11 [Flow: branch]
	sta $03B8E0.l		; 8F E0 B8 03 ; Store accumulator (long) $03B8E0.l [Reads: Accumulator]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $06B8E0.l		; 8F E0 B8 06 ; Store accumulator (long) $06B8E0.l [Reads: Accumulator]
	.db $F0, $13		; F0 13 ; Branch if equal to $F0, $13 [Flow: branch]
	sbc $B8E0.w,X		; FD E0 B8 ; Subtract with carry $B8E0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$A0.b]		; 07 A0 ; OR accumulator with memory (long) [$A0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $FF.b		; 14 FF ; Test and reset bits $FF.b [Reads: Accumulator] [Flags: Z]
	cpx #$07B8.w		; E0 B8 07 ; Compare #$07B8.w with X register [Reads: X Index] [Flags: NCZ]
	ldy #$FF15.w		; A0 15 FF ; Load #$FF15.w into Y register [Writes: Y Index] [Flags: NZ]
	cpx #$03B8.w		; E0 B8 03 ; Compare #$03B8.w with X register [Reads: X Index] [Flags: NCZ]
	.db $D0, $16		; D0 16 ; Branch if not equal to $D0, $16 [Flow: branch]
	sta $03B8E0.l		; 8F E0 B8 03 ; Store accumulator (long) $03B8E0.l [Reads: Accumulator]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $02B8E0.l,X		; FF E0 B8 02 ; Subtract with carry (long,X) $02B8E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$FE18.w		; C0 18 FE ; Compare #$FE18.w with Y register [Reads: Y Index] [Flags: NCZ]
	sta $F006B8.l		; 8F B8 06 F0 ; Store accumulator (long) $F006B8.l [Reads: Accumulator]
	and ($65.b)		; 32 65 ; AND accumulator with memory (indirect) ($65.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $CBB298.l,X		; 7F 98 B2 CB ; Add long $CBB298.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FC.b		; E5 FC ; Subtract $FC.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $4C32.w,Y		; 19 32 4C ; OR accumulator with memory $4C32.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $72.b		; 65 72 ; Add $72.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc $A5988C.l,X		; 7F 8C 98 A5 ; Add long $A5988C.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda ($BF.b)		; B2 BF ; Load accumulator (indirect) ($BF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	wai		; CB ; Wait for interrupt
	cld		; D8 ; Clear decimal flag [Flags: D]
	sbc $F2.b		; E5 F2 ; Subtract $F2.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($0F9E.w,X)		; FC 9E 0F ; Jump to subroutine indirect indexed ($0F9E.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $CFCD.w		; 20 CD CF ; Jump to subroutine at $CFCD.w [Writes: Stack Pointer] [Flow: call]
	lda $00E8.w,X		; BD E8 00 ; Load $00E8.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $C8AF.w,X		; 5D AF C8 ; Exclusive OR accumulator with memory $C8AF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$FBD0.w		; E0 D0 FB ; Compare #$FBD0.w with X register [Reads: X Index] [Flags: NCZ]
	cmp $D500.w		; CD 00 D5 ; Compare $D500.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $FAD0.w,X		; 3D D0 FA ; AND accumulator with memory $FAD0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $00.b,X		; D5 00 ; Compare accumulator $00.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $3D.b,S		; 03 3D ; OR accumulator with stack relative $3D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $FA		; D0 FA ; Branch if not equal to $D0, $FA [Flow: branch]
	ldy $223F.w,X		; BC 3F 22 ; Load Y register $223F.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	asl $48A2.w		; 0E A2 48 ; Arithmetic shift left $48A2.w [Flags: NCZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sta $3F0C.w		; 8D 0C 3F ; Store accumulator to $3F0C.w [Reads: Accumulator]
	sbc [$09.b],Y		; F7 09 ; Subtract with carry (long indexed) [$09.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $3F1C.w		; 8D 1C 3F ; Store accumulator to $3F1C.w [Reads: Accumulator]
	sbc [$09.b],Y		; F7 09 ; Subtract with carry (long indexed) [$09.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	bit $5D8D.w,X		; 3C 8D 5D ; Test bits $5D8D.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	and $E809F7.l,X		; 3F F7 09 E8 ; AND accumulator with memory (long,X) $E809F7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $C5		; F0 C5 ; Branch if equal to $F0, $C5 [Flow: branch]
	sbc ($00.b),Y		; F1 00 ; Subtract with carry ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $C5		; 10 C5 ; Branch if plus to $10, $C5 [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	brk $C4.b		; 00 C4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($E8.b,S),Y		; 53 E8 ; XOR accumulator (stack relative indirect indexed) ($E8.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($C5.b,X)		; 01 C5 ; Logical OR ($C5.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc ($00.b),Y		; F1 00 ; Subtract with carry ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $AD0A.w		; 8D 0A AD ; Store accumulator to $AD0A.w [Reads: Accumulator]
	ora $F0.b		; 05 F0 ; Logical OR $F0.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$B0.b]		; 07 B0 ; OR accumulator with memory (long) [$B0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	adc #$4C4D.w		; 69 4D 4C ; Add #$4C4D.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	.db $D0, $11		; D0 11 ; Branch if not equal to $D0, $11 [Flow: branch]
	sbc $4C.b,S		; E3 4C ; Subtract stack-relative $4C.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	asl $ACF6.w		; 0E F6 AC ; Arithmetic shift left $ACF6.w [Flags: NCZ]
	ora ($C5.b),Y		; 11 C5 ; OR accumulator with memory ($C5.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($00.b)		; F2 00 ; Subtract with carry (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inc $B6.b,X		; F6 B6 ; Increment memory $B6.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	ora ($5D.b),Y		; 11 5D ; OR accumulator with memory ($5D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	inc $C5.b		; E6 C5 ; Increment $C5.b [Reads: Direct Page] [Flags: NZ]
	sbc ($00.b,S),Y		; F3 00 ; Subtract with carry (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	inc $CBE2.w,X		; FE E2 CB ; Increment memory $CBE2.w,X [Reads: X Index] [Flags: NZ]
	eor $CB.b		; 45 CB ; Exclusive OR $CB.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr $E4.b		; 46 E4 ; Logical shift right $E4.b [Reads: Direct Page] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	mvp $5C,$19		; 44 19 5C ; Move block positive $5C,$19 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	jmp $186BED.l		; 5C ED 6B 18 ; Jump long to $186BED.l [Flow: jump]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $FDEC.w,Y		; 19 EC FD ; OR accumulator with memory $FDEC.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	adc $38E8.w		; 6D E8 38 ; Add $38E8.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp $438460.l		; CF 60 84 43 ; Compare accumulator (long) $438460.l [Reads: Accumulator] [Flags: NCZ]
	cpy $43.b		; C4 43 ; Compare $43.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	.db $90, $31		; 90 31 ; Branch if carry clear to $90, $31 [Flow: branch]
	and $3F1445.l,X		; 3F 45 14 3F ; AND accumulator with memory (long,X) $3F1445.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $CD13.w		; 6D 13 CD ; Add $CD13.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	ora ($3F.b,X)		; 01 3F ; Logical OR ($3F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $08.b,S		; E3 08 ; Subtract stack-relative $08.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	and $3F14AD.l,X		; 3F AD 14 3F ; AND accumulator with memory (long,X) $3F14AD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda [$13.b],Y		; B7 13 ; Load accumulator (long indexed) [$13.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $3F02.w		; CD 02 3F ; Compare $3F02.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	sbc $08.b,S		; E3 08 ; Subtract stack-relative $08.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	and $3F150B.l,X		; 3F 0B 15 3F ; AND accumulator with memory (long,X) $3F150B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldy $CD13.w,X		; BC 13 CD ; Load Y register $CD13.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ora $3F.b,S		; 03 3F ; OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $08.b,S		; E3 08 ; Subtract stack-relative $08.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	adc #$4C4D.w		; 69 4D 4C ; Add #$4C4D.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $0B		; F0 0B ; Branch if equal to $F0, $0B [Flow: branch]
	ldy $03C7.w		; AC C7 03 ; Load $03C7.w into Y register [Writes: Y Index] [Flags: NZ]
	sbc $C7.b		; E5 C7 ; Subtract $C7.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $5C.b,S		; 03 5C ; OR accumulator with stack relative $5C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $02		; B0 02 ; Branch if carry set to $B0, $02 [Flow: branch]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jmp $53E4.w		; 4C E4 53 ; Jump to $53E4.w [Flow: jump]
	inc $60CF.w		; EE CF 60 ; Increment $60CF.w [Flags: NZ]
	sty $51.b		; 84 51 ; Store Y register to $51.b [Reads: Y Index]
	cpy $51.b		; C4 51 ; Compare $51.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	.db $90, $0B		; 90 0B ; Branch if carry clear to $90, $0B [Flow: branch]
	and $CD0AF9.l,X		; 3F F9 0A CD ; AND accumulator with memory (long,X) $CD0AF9.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $08.b,S		; E3 08 ; Subtract stack-relative $08.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	eor $E40844.l,X		; 5F 44 08 E4 ; Exclusive OR accumulator with memory (long,X) $E40844.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $F0.b		; 04 F0 ; Test and set bits $F0.b [Reads: Accumulator] [Flags: Z]
	ora ($CD.b)		; 12 CD ; OR accumulator with memory (indirect) ($CD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $8F.b		; 00 8F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($47.b,X)		; 01 47 ; Logical OR ($47.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	pea $F031.w		; F4 31 F0 ; Push absolute address $F031.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	ora $3F.b,S		; 03 3F ; OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $10.b,X		; D5 10 ; Compare accumulator $10.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	and $0B3D.w,X		; 3D 3D 0B ; AND accumulator with memory $0B3D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor [$D0.b]		; 47 D0 ; Exclusive OR accumulator with memory (long) [$D0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc ($5F.b,S),Y		; F3 5F ; Subtract with carry (stack relative indirect indexed) ($5F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	mvp $F4,$08		; 44 08 F4 ; Move block positive $F4,$08 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	tsb $D5.b		; 04 D5 ; Test and set bits $D5.b [Reads: Accumulator] [Flags: Z]
	pea $F500.w		; F4 00 F5 ; Push absolute address $F500.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	pea $7500.w		; F4 00 75 ; Push absolute address $7500.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	pea $D000.w		; F4 00 D0 ; Push absolute address $D000.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $00D0.w,X		; FD D0 00 ; Subtract with carry $00D0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	pea $DB08.w		; F4 08 DB ; Push absolute address $DB08.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	dec $0508.w,X		; DE 08 05 ; Decrement memory $0508.w,X [Reads: X Index] [Flags: NZ]
	sta $DB00.w		; 8D 00 DB ; Store accumulator to $DB00.w [Reads: Accumulator]
	brk $6F.b		; 00 6F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	brk $6F.b		; 00 6F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $90CA.w		; AD CA 90 ; Load $90CA.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $3F.b		; 05 3F ; Logical OR $3F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror $0C.b		; 66 0C ; Rotate right $0C.b [Reads: Direct Page] [Flags: NCZ]
	sta $ADA4.w		; 8D A4 AD ; Store accumulator to $ADA4.w [Reads: Accumulator]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $B0, $F2		; B0 F2 ; Branch if carry set to $B0, $F2 [Flow: branch]
	cpx $1A.b		; E4 1A ; Compare $1A.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	bit $47.b		; 24 47 ; Test bits $47.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	.db $D0, $EC		; D0 EC ; Branch if not equal to $D0, $EC [Flow: branch]
	cmp $7F28.w,X		; DD 28 7F ; Compare accumulator $7F28.w,X [Reads: X Index] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sty $50.b		; 84 50 ; Store Y register to $50.b [Reads: Y Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sta $F0.b,X		; 95 F0 ; Store accumulator to $F0.b,X [Reads: Accumulator, X Index]
	cop $D5.b		; 02 D5 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($03.b,X)		; 61 03 ; Add with carry ($03.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $81.b,X		; F5 81 ; Subtract $81.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $D5.b,S		; 03 D5 ; OR accumulator with stack relative $D5.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $F5.b,S		; 03 F5 ; OR accumulator with stack relative $F5.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda ($02.b),Y		; B1 02 ; Load accumulator ($02.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jmp $7C00E8.l		; 5C E8 00 7C ; Jump long to $7C00E8.l [Flow: jump]
	cmp $A0.b,X		; D5 A0 ; Compare accumulator $A0.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cop $E8.b		; 02 E8 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D4.b		; 00 D4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $B0, $D5		; B0 D5 ; Branch if carry set to $B0, $D5 [Flow: branch]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $D0.b,X		; D5 D0 ; Compare accumulator $D0.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cop $D4.b		; 02 D4 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$4709.w		; C0 09 47 ; Compare #$4709.w with Y register [Reads: Y Index] [Flags: NCZ]
	lsr $4709.w,X		; 5E 09 47 ; Logical shift right $4709.w,X [Reads: X Index] [Flags: NCZ]
	eor $F5.b		; 45 F5 ; Exclusive OR $F5.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $80, $02		; 80 02 ; Branch always to $80, $02 [Flow: branch]
	pei ($A0.b)		; D4 A0 ; Push effective indirect address ($A0.b) [Reads: Direct Page] [Writes: Stack Pointer]
	.db $F0, $1E		; F0 1E ; Branch if equal to $F0, $1E [Flow: branch]
	sbc $81.b,X		; F5 81 ; Subtract $81.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $D4.b		; 02 D4 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda ($F5.b,X)		; A1 F5 ; Load accumulator ($F5.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $90, $02		; 90 02 ; Branch if carry clear to $90, $02 [Flow: branch]
	.db $D0, $0A		; D0 0A ; Branch if not equal to $D0, $0A [Flow: branch]
	sbc $61.b,X		; F5 61 ; Subtract $61.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $80.b,S		; 03 80 ; OR accumulator with stack relative $80.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $91.b,X		; B5 91 ; Load $91.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cop $D5.b		; 02 D5 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($03.b,X)		; 61 03 ; Add with carry ($03.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $91.b,X		; F5 91 ; Subtract $91.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $60.b		; 02 60 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $61.b,X		; 95 61 ; Store accumulator to $61.b,X [Reads: Accumulator, X Index]
	ora $3F.b,S		; 03 3F ; OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	asl $C33F.w		; 0E 3F C3 ; Arithmetic shift left $C33F.w [Flags: NCZ]
	asl $008D.w		; 0E 8D 00 ; Arithmetic shift left $008D.w [Flags: NCZ]
	cpx $11.b		; E4 11 ; Compare $11.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $80, $A8		; 80 A8 ; Branch always to $80, $A8 [Flow: branch]
	bit $B0.b,X		; 34 B0 ; Test bits $B0.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora #$11E4.w		; 09 E4 11 ; Logical OR #$11E4.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $80, $A8		; 80 A8 ; Branch always to $80, $A8 [Flow: branch]
	ora ($B0.b,S),Y		; 13 B0 ; OR accumulator (stack relative indirect indexed) ($B0.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $DC.b		; 06 DC ; Arithmetic shift left $DC.b [Reads: Direct Page] [Flags: NCZ]
	trb $107A.w		; 1C 7A 10 ; Test and reset bits $107A.w [Reads: Accumulator] [Flags: Z]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	.db $10, $4D		; 10 4D ; Branch if plus to $10, $4D [Flow: branch]
	cpx $11.b		; E4 11 ; Compare $11.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	trb $008D.w		; 1C 8D 00 ; Test and reset bits $008D.w [Reads: Accumulator] [Flags: Z]
	cmp $9E18.w		; CD 18 9E ; Compare $9E18.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	eor $C2F6.w,X		; 5D F6 C2 ; Exclusive OR accumulator with memory $C2F6.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($C4.b),Y		; 11 C4 ; OR accumulator with memory ($C4.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $F6.b,X		; 15 F6 ; OR accumulator with memory $F6.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($11.b,X)		; C1 11 ; Compare accumulator ($11.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	cpy $14.b		; C4 14 ; Compare $14.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	inc $C4.b,X		; F6 C4 ; Increment memory $C4.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	ora ($2D.b),Y		; 11 2D ; OR accumulator with memory ($2D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	inc $C3.b,X		; F6 C3 ; Increment memory $C3.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	ora ($EE.b),Y		; 11 EE ; OR accumulator with memory ($EE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	trb $EB.b		; 14 EB ; Test and reset bits $EB.b [Reads: Accumulator] [Flags: Z]
	.db $10, $CF		; 10 CF ; Branch if plus to $10, $CF [Flow: branch]
	cmp $008D.w,X		; DD 8D 00 ; Compare accumulator $008D.w,X [Reads: X Index] [Flags: NCZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	trb $CB.b		; 14 CB ; Test and reset bits $CB.b [Reads: Accumulator] [Flags: Z]
	ora $1C.b,X		; 15 1C ; OR accumulator with memory $1C.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	ora $C4.b,X		; 15 C4 ; OR accumulator with memory $C4.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	trb $2F.b		; 14 2F ; Test and reset bits $2F.b [Reads: Accumulator] [Flags: Z]
	tsb $4B.b		; 04 4B ; Test and set bits $4B.b [Reads: Accumulator] [Flags: Z]
	ora $7C.b,X		; 15 7C ; OR accumulator with memory $7C.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $06C8.w,X		; 3D C8 06 ; AND accumulator with memory $06C8.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $F8		; D0 F8 ; Branch if not equal to $D0, $F8 [Flow: branch]
	cpy $14.b		; C4 14 ; Compare $14.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	dec $20F5.w		; CE F5 20 ; Decrement $20F5.w [Flags: NZ]
	cop $EB.b		; 02 EB ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $CF.b,X		; 15 CF ; OR accumulator with memory $CF.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	asl $F5.b,X		; 16 F5 ; Arithmetic shift left $F5.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	jsr $EB02.w		; 20 02 EB ; Jump to subroutine at $EB02.w [Writes: Stack Pointer] [Flow: call]
	trb $CF.b		; 14 CF ; Test and reset bits $CF.b [Reads: Accumulator] [Flags: Z]
	adc $21F5.w		; 6D F5 21 ; Add $21F5.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cop $EB.b		; 02 EB ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $CF.b		; 14 CF ; Test and reset bits $CF.b [Reads: Accumulator] [Flags: Z]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	asl $DA.b,X		; 16 DA ; Arithmetic shift left $DA.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	asl $F5.b,X		; 16 F5 ; Arithmetic shift left $F5.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	and ($02.b,X)		; 21 02 ; Logical AND ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora $CF.b,X		; 15 CF ; OR accumulator with memory $CF.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $7AAE.w,X		; FD AE 7A ; Subtract with carry $7AAE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $DA.b,X		; 16 DA ; Arithmetic shift left $DA.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	asl $7D.b,X		; 16 7D ; Arithmetic shift left $7D.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sta $02085C.l,X		; 9F 5C 08 02 ; Store accumulator (long,X) $02085C.l,X [Reads: Accumulator, X Index]
	sbc $16E4.w,X		; FD E4 16 ; Subtract with carry $16E4.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $FC09EF.l,X		; 3F EF 09 FC ; AND accumulator with memory (long,X) $FC09EF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpx $17.b		; E4 17 ; Compare $17.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	and $47E4.w		; 2D E4 47 ; Logical AND $47E4.w with accumulator [Writes: Accumulator] [Flags: NZ]
	bit $1A.b		; 24 1A ; Test bits $1A.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ldx $06D0.w		; AE D0 06 ; Load $06D0.w into X register [Writes: X Index] [Flags: NZ]
	cpy $00F2.w		; CC F2 00 ; Compare $00F2.w with Y register [Reads: Y Index] [Flags: NCZ]
	cmp $F3.b		; C5 F3 ; Compare $F3.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	brk $6F.b		; 00 6F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	brk $8D.b		; 00 8D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $F73F.w		; 2C 3F F7 ; Test bits $F73F.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	ora #$00E8.w		; 09 E8 00 ; Logical OR #$00E8.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $3F3C.w		; 8D 3C 3F ; Store accumulator to $3F3C.w [Reads: Accumulator]
	sbc [$09.b],Y		; F7 09 ; Subtract with carry (long indexed) [$09.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sbc $3F5C8D.l,X		; FF 8D 5C 3F ; Subtract with carry (long,X) $3F5C8D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$09.b],Y		; F7 09 ; Subtract with carry (long indexed) [$09.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and $E811E6.l,X		; 3F E6 11 E8 ; AND accumulator with memory (long,X) $E811E6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $C5.b		; 00 C5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	ora $C4.b,S		; 03 C4 ; OR accumulator with stack relative $C4.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $C5.b		; 04 C5 ; Test and set bits $C5.b [Reads: Accumulator] [Flags: Z]
	cmp $CBC503.l		; CF 03 C5 CB ; Compare accumulator (long) $CBC503.l [Reads: Accumulator] [Flags: NCZ]
	ora $C5.b,S		; 03 C5 ; OR accumulator with stack relative $C5.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $C403.w		; CD 03 C4 ; Compare $C403.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	adc $D880CD.l		; 6F CD 80 D8 ; Add with carry (long) $D880CD.l [Writes: Accumulator] [Flags: NCVZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	cmp #$03CA.w		; C9 CA 03 ; Compare #$03CA.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	brk $C4.b		; 00 C4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	.db $80, $A4		; 80 A4 ; Branch always to $80, $A4 [Flow: branch]
	eor $CE3F.w,Y		; 59 3F CE ; Exclusive OR accumulator with memory $CE3F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $5CDA.w		; 0E DA 5C ; Arithmetic shift left $5CDA.w [Flags: NCZ]
	eor $E50B00.l,X		; 5F 00 0B E5 ; Exclusive OR accumulator with memory (long,X) $E50B00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($03.b,X)		; E1 03 ; Subtract with carry ($03.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $D0, $1E		; D0 1E ; Branch if not equal to $D0, $1E [Flow: branch]
	cpx $59.b		; E4 59 ; Compare $59.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	cmp $E1.b		; C5 E1 ; Compare $E1.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora $E8.b,S		; 03 E8 ; OR accumulator with stack relative $E8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $70, $C4		; 70 C4 ; Branch if overflow set to $70, $C4 [Flow: branch]
	eor $005F.w,Y		; 59 5F 00 ; Exclusive OR accumulator with memory $005F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sbc $E1.b		; E5 E1 ; Subtract $E1.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $F0.b,S		; 03 F0 ; OR accumulator with stack relative $F0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $E1E5.w		; 0D E5 E1 ; Logical OR $E1E5.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $C4.b,S		; 03 C4 ; OR accumulator with stack relative $C4.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $00E8.w,Y		; 59 E8 00 ; Exclusive OR accumulator with memory $00E8.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $E1.b		; C5 E1 ; Compare $E1.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora $5F.b,S		; 03 5F ; OR accumulator with stack relative $5F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $F0FF68.l		; 6F 68 FF F0 ; Add with carry (long) $F0FF68.l [Writes: Accumulator] [Flags: NCVZ]
	sta [$68.b],Y		; 97 68 ; Store accumulator (long indexed) [$68.b],Y [Reads: Direct Page, Y Index, Accumulator]
	sbc ($F0.b),Y		; F1 F0 ; Subtract with carry ($F0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx $F268.w,Y		; BE 68 F2 ; Load X register $F268.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	.db $F0, $D0		; F0 D0 ; Branch if equal to $F0, $D0 [Flow: branch]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sbc ($F0.b,S),Y		; F3 F0 ; Subtract with carry (stack relative indirect indexed) ($F0.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cmp $F068.w,X		; DD 68 F0 ; Compare accumulator $F068.w,X [Reads: X Index] [Flags: NCZ]
	.db $F0, $0A		; F0 0A ; Branch if equal to $F0, $0A [Flow: branch]
	and $CA8C24.l		; 2F 24 8C CA ; AND accumulator with memory (long) $CA8C24.l [Writes: Accumulator] [Flags: NZ]
	ora $F0.b,S		; 03 F0 ; OR accumulator with stack relative $F0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $5F.b,S		; 03 5F ; OR accumulator with stack relative $5F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $E40B.w		; 0C 0B E4 ; Test and set bits $E40B.w [Reads: Accumulator] [Flags: Z]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	sbc $00460E.l,X		; FF 0E 46 00 ; Subtract with carry (long,X) $00460E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $8F0400.l		; 8F 00 04 8F ; Store accumulator (long) $8F0400.l [Reads: Accumulator]
	brk $47.b		; 00 47 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $F7008D.l		; 6F 8D 00 F7 ; Add with carry (long) $F7008D.l [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	and $40F7.w		; 2D F7 40 ; Logical AND $40F7.w with accumulator [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sbc $6FAE.w,X		; FD AE 6F ; Subtract with carry $6FAE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cmp $C900.w		; CD 00 C9 ; Compare $C900.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	ora $C9.b,S		; 03 C9 ; OR accumulator with stack relative $C9.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc ($03.b,X)		; E1 03 ; Subtract with carry ($03.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy $04.b		; C4 04 ; Compare $04.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	trb $F55D.w		; 1C 5D F5 ; Test and reset bits $F55D.w [Reads: Accumulator] [Flags: Z]
	sbc $F5FDCF.l,X		; FF CF FD F5 ; Subtract with carry (long,X) $F5FDCF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $DACF.w,X		; FE CF DA ; Increment memory $DACF.w,X [Reads: X Index] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sta $E40C02.l		; 8F 02 0C E4 ; Store accumulator (long) $E40C02.l [Reads: Accumulator]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	sbc $00460E.l,X		; FF 0E 46 00 ; Subtract with carry (long,X) $00460E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $8F0ECD.l		; 6F CD 0E 8F ; Add with carry (long) $8F0ECD.l [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $47		; 80 47 ; Branch always to $80, $47 [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sbc $0301D5.l,X		; FF D5 01 03 ; Subtract with carry (long,X) $0301D5.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and $D50CBF.l,X		; 3F BF 0C D5 ; AND accumulator with memory (long,X) $D50CBF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b),Y		; 11 02 ; OR accumulator with memory ($02.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $81.b,X		; D5 81 ; Compare accumulator $81.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $D5.b,S		; 03 D5 ; OR accumulator with stack relative $D5.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $02		; F0 02 ; Branch if equal to $F0, $02 [Flow: branch]
	cmp $80.b,X		; D5 80 ; Compare accumulator $80.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cop $D5.b		; 02 D5 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $B1D403.l,X		; FF 03 D4 B1 ; Subtract with carry (long,X) $B1D403.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	pei ($C1.b)		; D4 C1 ; Push effective indirect address ($C1.b) [Reads: Direct Page] [Writes: Stack Pointer]
	ora $4B1D.w,X		; 1D 1D 4B ; OR accumulator with memory $4B1D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor [$D0.b]		; 47 D0 ; Exclusive OR accumulator with memory (long) [$D0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $5AC4.w,X		; DD C4 5A ; Compare accumulator $5AC4.w,X [Reads: X Index] [Flags: NCZ]
	cpy $68.b		; C4 68 ; Compare $68.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	cpy $54.b		; C4 54 ; Compare $54.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	cpy $50.b		; C4 50 ; Compare $50.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	cpy $42.b		; C4 42 ; Compare $42.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	cpy $5F.b		; C4 5F ; Compare $5F.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	sta $8F59C0.l		; 8F C0 59 8F ; Store accumulator (long) $8F59C0.l [Reads: Accumulator]
	jsr $6F53.w		; 20 53 6F ; Jump to subroutine at $6F53.w [Writes: Stack Pointer] [Flow: call]
	cpx $00.b		; E4 00 ; Compare $00.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	eor $E40A63.l,X		; 5F 63 0A E4 ; Exclusive OR accumulator with memory (long,X) $E40A63.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $F0.b		; 04 F0 ; Test and set bits $F0.b [Reads: Accumulator] [Flags: Z]
	pea $CAE5.w		; F4 E5 CA ; Push absolute address $CAE5.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	ora $F0.b,S		; 03 F0 ; OR accumulator with stack relative $F0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $5F.b,S		; 03 5F ; OR accumulator with stack relative $5F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $E40A.w,Y		; 79 0A E4 ; Add $E40A.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $5DF0.w		; 0C F0 5D ; Test and set bits $5DF0.w [Reads: Accumulator] [Flags: Z]
	ror $AB0C.w		; 6E 0C AB ; Rotate right $AB0C.w [Flags: NCZ]
	and $D00A8F.l,X		; 3F 8F 0A D0 ; AND accumulator with memory (long,X) $D00A8F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $FD.b		; 25 FD ; Logical AND $FD.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	eor $680A81.l,X		; 5F 81 0A 68 ; Exclusive OR accumulator with memory (long,X) $680A81.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $80, $F0		; 80 F0 ; Branch always to $80, $F0 [Flow: branch]
	asl $68.b		; 06 68 ; Arithmetic shift left $68.b [Reads: Direct Page] [Flags: NCZ]
	sta ($D0.b,X)		; 81 D0 ; Store accumulator ($D0.b,X) [Reads: Direct Page, Accumulator, X Index]
	asl $E8.b		; 06 E8 ; Arithmetic shift left $E8.b [Reads: Direct Page] [Flags: NCZ]
	brk $C4.b		; 00 C4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	and $428BE7.l		; 2F E7 8B 42 ; AND accumulator with memory (long) $428BE7.l [Writes: Accumulator] [Flags: NZ]
	.db $10, $02		; 10 02 ; Branch if plus to $10, $02 [Flow: branch]
	cpy $42.b		; C4 42 ; Compare $42.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	and $F80A8F.l,X		; 3F 8F 0A F8 ; AND accumulator with memory (long,X) $F80A8F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $42, $F0		; 42 F0 ; Reserved instruction
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	and $16DAD6.l		; 2F D6 DA 16 ; AND accumulator with memory (long) $16DAD6.l [Writes: Accumulator] [Flags: NZ]
	sta $F70F.w		; 8D 0F F7 ; Store accumulator to $F70F.w [Reads: Accumulator]
	asl $D6.b,X		; 16 D6 ; Arithmetic shift left $D6.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	jmp.w [$F810]		; DC 10 F8 ; Jump long indirect [$F810] [Flow: jump]
	cmp $8F00.w		; CD 00 8F ; Compare $8F00.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora ($47.b,X)		; 01 47 ; Logical OR ($47.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	pea $F031.w		; F4 31 F0 ; Push absolute address $F031.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc $11.b,X		; F5 11 ; Subtract $11.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $D0.b		; 02 D0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $E8.b		; 05 E8 ; Logical OR $E8.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $0C.b		; 66 0C ; Rotate right $0C.b [Reads: Direct Page] [Flags: NCZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	brk $D4.b		; 00 D4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $D4		; 80 D4 ; Branch always to $80, $D4 [Flow: branch]
	.db $90, $D4		; 90 D4 ; Branch if carry clear to $90, $D4 [Flow: branch]
	sta ($BC.b),Y		; 91 BC ; Store accumulator ($BC.b),Y [Reads: Direct Page, Y Index, Accumulator]
	pei ($70.b)		; D4 70 ; Push effective indirect address ($70.b) [Reads: Direct Page] [Writes: Stack Pointer]
	and $0B3D.w,X		; 3D 3D 0B ; AND accumulator with memory $0B3D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor [$D0.b]		; 47 D0 ; Exclusive OR accumulator with memory (long) [$D0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc ($CD.b,X)		; E1 CD ; Subtract with carry ($CD.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $D8.b		; 00 D8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $018F.w,X		; 5E 8F 01 ; Logical shift right $018F.w,X [Reads: X Index] [Flags: NCZ]
	eor [$D8.b]		; 47 D8 ; Exclusive OR accumulator with memory (long) [$D8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	mvp $31,$F4		; 44 F4 31 ; Move block positive $31,$F4 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	.db $F0, $7A		; F0 7A ; Branch if equal to $F0, $7A [Flow: branch]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	.db $70, $D0		; 70 D0 ; Branch if overflow set to $70, $D0 [Flow: branch]
	jmp ($5C3F.w)		; 6C 3F 5C ; Jump indirect to ($5C3F.w) [Flow: jump]
	tsb $17D0.w		; 0C D0 17 ; Test and set bits $17D0.w [Reads: Accumulator] [Flags: Z]
	pea $F080.w		; F4 80 F0 ; Push absolute address $F080.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sty $B73F.w		; 8C 3F B7 ; Store Y register to $B73F.w [Reads: Y Index]
	ora $809B.w		; 0D 9B 80 ; Logical OR $809B.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $F0		; D0 F0 ; Branch if not equal to $D0, $F0 [Flow: branch]
	sbc $30.b,X		; F5 30 ; Subtract $30.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $D4.b		; 02 D4 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $F5		; 30 F5 ; Branch if minus to $30, $F5 [Flow: branch]
	and ($02.b),Y		; 31 02 ; AND accumulator with memory ($02.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	pei ($31.b)		; D4 31 ; Push effective indirect address ($31.b) [Reads: Direct Page] [Writes: Stack Pointer]
	and $2030E4.l		; 2F E4 30 20 ; AND accumulator with memory (long) $2030E4.l [Writes: Accumulator] [Flags: NZ]
	cmp $00.b,X		; D5 00 ; Compare accumulator $00.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cop $3F.b		; 02 3F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp $18300C.l		; 5C 0C 30 18 ; Jump long to $18300C.l [Flow: jump]
	and $289F.w		; 2D 9F 28 ; Logical AND $289F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$FD.b]		; 07 FD ; OR accumulator with memory (long) [$FD.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $96.b,X		; F6 96 ; Increment memory $96.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	and $01D5.w,X		; 3D D5 01 ; AND accumulator with memory $01D5.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cop $AE.b		; 02 AE ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	ora $9EF6FD.l		; 0F FD F6 9E ; OR accumulator with memory (long) $9EF6FD.l [Writes: Accumulator] [Flags: NZ]
	and $10D5.w,X		; 3D D5 10 ; AND accumulator with memory $10D5.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cop $3F.b		; 02 3F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp $E0680C.l		; 5C 0C 68 E0 ; Jump long to $E0680C.l [Flow: jump]
	.db $90, $05		; 90 05 ; Branch if carry clear to $90, $05 [Flow: branch]
	and $2F0C4A.l,X		; 3F 4A 0C 2F ; AND accumulator with memory (long,X) $2F0C4A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda $FFF5.w,Y		; B9 F5 FF ; Load $FFF5.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	.db $D0, $0C		; D0 0C ; Branch if not equal to $D0, $0C [Flow: branch]
	cmp $E42D.w,X		; DD 2D E4 ; Compare accumulator $E42D.w,X [Reads: X Index] [Flags: NCZ]
	eor [$24.b]		; 47 24 ; Exclusive OR accumulator with memory (long) [$24.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ldx $03D0.w		; AE D0 03 ; Load $03D0.w into X register [Writes: X Index] [Flags: NZ]
	and $F50902.l,X		; 3F 02 09 F5 ; AND accumulator with memory (long,X) $F50902.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pei ($70.b)		; D4 70 ; Push effective indirect address ($70.b) [Reads: Direct Page] [Writes: Stack Pointer]
	sbc $01F5.w,X		; FD F5 01 ; Subtract with carry $01F5.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $CF.b		; 02 CF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $01D0.w,X		; DD D0 01 ; Compare accumulator $01D0.w,X [Reads: X Index] [Flags: NCZ]
	ldy $71D4.w,X		; BC D4 71 ; Load Y register $71D4.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	and $1BE407.l		; 2F 07 E4 1B ; AND accumulator with memory (long) $1BE407.l [Writes: Accumulator] [Flags: NZ]
	.db $D0, $06		; D0 06 ; Branch if not equal to $D0, $06 [Flow: branch]
	and $3F0FF6.l,X		; 3F F6 0F 3F ; AND accumulator with memory (long,X) $3F0FF6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	asl $3D3D.w		; 0E 3D 3D ; Arithmetic shift left $3D3D.w [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	eor [$F0.b]		; 47 F0 ; Exclusive OR accumulator with memory (long) [$F0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $5F.b,S		; 03 5F ; OR accumulator with stack relative $5F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	stz $0B.b,X		; 74 0B ; Store zero to $0B.b,X [Reads: X Index]
	cpx $54.b		; E4 54 ; Compare $54.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $F0, $0B		; F0 0B ; Branch if equal to $F0, $0B [Flow: branch]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	lsr $7A.b,X		; 56 7A ; Logical shift right $7A.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	eor ($6E.b)		; 52 6E ; Exclusive OR accumulator with memory (indirect) ($6E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	mvn $BA,$02		; 54 02 BA ; Move block negative $BA,$02 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	mvn $52,$DA		; 54 DA 52 ; Move block negative $52,$DA [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cpx $68.b		; E4 68 ; Compare $68.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $F0, $15		; F0 15 ; Branch if equal to $F0, $15 [Flow: branch]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	stz $7A.b		; 64 7A ; Store zero to $7A.b
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	ror $7A.b		; 66 7A ; Rotate right $7A.b [Reads: Direct Page] [Flags: NCZ]
	.db $62, $6E, $68		; 62 6E 68 ; Push effective relative address $62, $6E, $68 [Writes: Stack Pointer]
	asl $BA.b		; 06 BA ; Arithmetic shift left $BA.b [Reads: Direct Page] [Flags: NCZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	.db $62, $E4, $5A		; 62 E4 5A ; Push effective relative address $62, $E4, $5A [Writes: Stack Pointer]
	.db $F0, $0E		; F0 0E ; Branch if equal to $F0, $0E [Flow: branch]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	jmp $6E587A.l		; 5C 7A 58 6E ; Jump long to $6E587A.l [Flow: jump]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	cop $BA.b		; 02 BA ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $5A		; Opcode 5A overrunning bank boundry at 0CFFFF. Skipping. ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
.ENDS
