.BANK 4 SLOT 0
.ORG $0000

.SECTION "Bank4" FORCE

	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tsb $0D0B.w		; 0C 0B 0D ; Test and set bits $0D0B.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0F.b		; 04 0F ; Test and set bits $0F.b [Reads: Accumulator] [Flags: Z]
	ora ($13.b),Y		; 11 13 ; OR accumulator with memory ($13.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($1C.b)		; 12 1C ; OR accumulator with memory (indirect) ($1C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $001D.w,X		; 1E 1D 00 ; Arithmetic shift left $001D.w,X [Reads: X Index] [Flags: NCZ]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $2422.w		; 20 22 24 ; Jump to subroutine at $2422.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $1225.w		; 0E 25 12 ; Arithmetic shift left $1225.w [Flags: NCZ]
	bit $0000.w		; 2C 00 00 ; Test bits $0000.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	and $302E.w		; 2D 2E 30 ; Logical AND $302E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$13.b],Y		; 37 13 ; AND accumulator with memory (long indexed) [$13.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $0000.w,Y		; 39 00 00 ; AND accumulator with memory $0000.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $36.b,X		; 34 36 ; Test bits $36.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $2E.b,X		; 34 2E ; Test bits $2E.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $42, $04		; 42 04 ; Reserved instruction
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $0A.b		; 24 0A ; Test bits $0A.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	lsr $48.b		; 46 48 ; Logical shift right $48.b [Reads: Direct Page] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp $005639.l		; 5C 39 56 00 ; Jump long to $005639.l [Flow: jump]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $005F5E.l,X		; 1F 5E 5F 00 ; Logical OR long $005F5E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($37.b)		; 12 37 ; OR accumulator with memory (indirect) ($37.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc [$69.b]		; 67 69 ; Add with carry (long) [$69.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $39.b		; 00 39 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	mvp $00,$00		; 44 00 00 ; Move block positive $00,$00 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	eor $5E.b		; 45 5E ; Exclusive OR $5E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $41.b		; 04 41 ; Test and set bits $41.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $6D.b,X		; 34 6D ; Test bits $6D.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $30, $34		; 30 34 ; Branch if minus to $30, $34 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $1D2D21.l,X		; 5F 21 2D 1D ; Exclusive OR accumulator with memory (long,X) $1D2D21.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($6D.b,S),Y		; 33 6D ; AND accumulator (stack relative indirect indexed) ($6D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $66.b		; 00 66 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	ora ($38.b)		; 12 38 ; OR accumulator with memory (indirect) ($38.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($34.b,S),Y		; 33 34 ; AND accumulator (stack relative indirect indexed) ($34.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc #$0021.w		; 69 21 00 ; Add #$0021.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	brk $69.b		; 00 69 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $1D.b,S		; 23 1D ; AND accumulator with stack relative $1D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor [$00.b]		; 47 00 ; Exclusive OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $49.b		; 00 49 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	and ($74.b,X)		; 21 74 ; Logical AND ($74.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $4C.b		; 04 4C ; Test and set bits $4C.b [Reads: Accumulator] [Flags: Z]
	ror $0004.w		; 6E 04 00 ; Rotate right $0004.w [Flags: NCZ]
	brk $56.b		; 00 56 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and #$1115.w		; 29 15 11 ; Logical AND #$1115.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $0447.w,Y		; 39 47 04 ; AND accumulator with memory $0447.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr $00.b,X		; 56 00 ; Logical shift right $00.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $000A5F.l		; 4F 5F 0A 00 ; Exclusive OR accumulator with memory (long) $000A5F.l [Writes: Accumulator] [Flags: NZ]
	brk $46.b		; 00 46 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $30.b,X		; 34 30 ; Test bits $30.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $4C.b		; 00 4C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $38.b,X		; 76 38 ; Rotate right $38.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ror $0000.w		; 6E 00 00 ; Rotate right $0000.w [Flags: NCZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	.db $30, $11		; 30 11 ; Branch if minus to $30, $11 [Flow: branch]
	ora ($00.b)		; 12 00 ; OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $7B.b		; 00 7B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $7E34.w,X		; 7D 34 7E ; Add $7E34.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $105F.w,X		; 5E 5F 10 ; Logical shift right $105F.w,X [Reads: X Index] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $82, $84, $61		; 82 84 61 ; Branch always long to $82, $84, $61 [Flow: branch]
	adc $00.b,S		; 63 00 ; Add with carry (stack relative) $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $30.b		; 85 30 ; Store accumulator to $30.b [Reads: Accumulator]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $1D.b		; 00 1D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $89.b,X		; 34 89 ; Test bits $89.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora ($00.b)		; 12 00 ; OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $94.b		; 00 94 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($96.b,S),Y		; 73 96 ; Add with carry (stack relative indirect indexed) ($96.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $99.b		; 00 99 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	stz $0000.w		; 9C 00 00 ; Store zero to $0000.w
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	sta $3474.w,X		; 9D 74 34 ; Store accumulator to $3474.w,X [Reads: Accumulator, X Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $9F.b,X		; 34 9F ; Test bits $9F.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	lda $A5.b,S		; A3 A5 ; Load accumulator (stack relative) $A5.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda [$34.b]		; A7 34 ; Load accumulator (long) [$34.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $00001D.l,X		; 5F 1D 00 00 ; Exclusive OR accumulator with memory (long,X) $00001D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($34.b,S),Y		; 33 34 ; AND accumulator (stack relative indirect indexed) ($34.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $A7.b		; A5 A7 ; Load $A7.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $AF.b,X		; 36 AF ; Rotate left $AF.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $8C356E.l,X		; 5F 6E 35 8C ; Exclusive OR accumulator with memory (long,X) $8C356E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	lda $0000B1.l		; AF B1 00 00 ; Load long $0000B1.l into accumulator [Writes: Accumulator] [Flags: NZ]
	eor $23.b		; 45 23 ; Exclusive OR $23.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr $6A.b		; 46 6A ; Logical shift right $6A.b [Reads: Direct Page] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	and [$35.b],Y		; 37 35 ; AND accumulator with memory (long indexed) [$35.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1F.b		; 04 1F ; Test and set bits $1F.b [Reads: Accumulator] [Flags: Z]
	eor $040000.l,X		; 5F 00 00 04 ; Exclusive OR accumulator with memory (long,X) $040000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $B7		; 30 B7 ; Branch if minus to $30, $B7 [Flow: branch]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $97.b		; 00 97 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $BA11.w,Y		; B9 11 BA ; Load $BA11.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $6811.w,Y		; 39 11 68 ; AND accumulator with memory $6811.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sty $0000.w		; 8C 00 00 ; Store Y register to $0000.w [Reads: Y Index]
	lda $307DAF.l,X		; BF AF 7D 30 ; Load long $307DAF.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $348D34.l		; 22 34 8D 34 ; Jump to subroutine long $348D34.l [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $49.b,X		; 74 49 ; Store zero to $49.b,X [Reads: X Index]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	ror $0000.w		; 6E 00 00 ; Rotate right $0000.w [Flags: NCZ]
	jmp ($3634.w)		; 6C 34 36 ; Jump indirect to ($3634.w) [Flow: jump]
	eor $340000.l,X		; 5F 00 00 34 ; Exclusive OR accumulator with memory (long,X) $340000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $04		; 30 04 ; Branch if minus to $30, $04 [Flow: branch]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $7D.b		; 00 7D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $34		; 30 34 ; Branch if minus to $30, $34 [Flow: branch]
	lda $B20000.l		; AF 00 00 B2 ; Load long $B20000.l into accumulator [Writes: Accumulator] [Flags: NZ]
	lda $005646.l		; AF 46 56 00 ; Load long $005646.l into accumulator [Writes: Accumulator] [Flags: NZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($34.b,X)		; 81 34 ; Store accumulator ($34.b,X) [Reads: Direct Page, Accumulator, X Index]
	ror $00.b,X		; 76 00 ; Rotate right $00.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $63.b		; 00 63 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $64, $69		; 62 64 69 ; Push effective relative address $62, $64, $69 [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($34.b),Y		; 11 34 ; OR accumulator with memory ($34.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $34.b,X		; 95 34 ; Store accumulator to $34.b,X [Reads: Accumulator, X Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $35.b,X		; 34 35 ; Test bits $35.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $22.b,X		; 34 22 ; Test bits $22.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora ($CB.b)		; 12 CB ; OR accumulator with memory (indirect) ($CB.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $C6.b		; C5 C6 ; Compare $C6.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cpy $00C8.w		; CC C8 00 ; Compare $00C8.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $76C6.w		; CE C6 76 ; Decrement $76C6.w [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pei ($C8.b)		; D4 C8 ; Push effective indirect address ($C8.b) [Reads: Direct Page] [Writes: Stack Pointer]
	cmp #$00C9.w		; C9 C9 00 ; Compare #$00C9.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	brk $D2.b		; 00 D2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $9B.b		; C6 9B ; Decrement $9B.b [Reads: Direct Page] [Flags: NZ]
	sta $0000.w,X		; 9D 00 00 ; Store accumulator to $0000.w,X [Reads: Accumulator, X Index]
	ora ($95.b,S),Y		; 13 95 ; OR accumulator (stack relative indirect indexed) ($95.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $C8C9C9.l,X		; DF C9 C9 C8 ; Compare accumulator (long,X) $C8C9C9.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($34.b)		; D2 34 ; Compare accumulator (indirect) ($34.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sta $83.b,S		; 83 83 ; Store accumulator (stack relative) $83.b,S [Reads: Stack Pointer, Accumulator]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $82, $DA, $DA		; 82 DA DA ; Branch always long to $82, $DA, $DA [Flow: branch]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $34.b,X		; 36 34 ; Rotate left $34.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $D3.b		; 00 D3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $7F.b		; C5 7F ; Compare $7F.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $DA.b		; 00 DA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $36.b,X		; 34 36 ; Test bits $36.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	inc $0000.w		; EE 00 00 ; Increment $0000.w [Flags: NZ]
	sbc $76CE36.l		; EF 36 CE 76 ; Subtract with carry (long) $76CE36.l [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $DE.b,X		; 34 DE ; Test bits $DE.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora ($DA.b)		; 12 DA ; OR accumulator with memory (indirect) ($DA.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $EE.b,X		; 36 EE ; Rotate left $EE.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc $000036.l		; EF 36 00 00 ; Subtract with carry (long) $000036.l [Writes: Accumulator] [Flags: NCVZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc [$25.b]		; E7 25 ; Subtract with carry (long) [$25.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	rol $FA.b,X		; 36 FA ; Rotate left $FA.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	jsr ($0000.w,X)		; FC 00 00 ; Jump to subroutine indirect indexed ($0000.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $3434.w,X		; FE 34 34 ; Increment memory $3434.w,X [Reads: X Index] [Flags: NZ]
	trb $00.b		; 14 00 ; Test and reset bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $A8.b		; 00 A8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $06.b		; 04 06 ; Test and set bits $06.b [Reads: Accumulator] [Flags: Z]
	ora #$1134.w		; 09 34 11 ; Logical OR #$1134.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $10, $36		; 10 36 ; Branch if plus to $10, $36 [Flow: branch]
	bit $4E.b,X		; 34 4E ; Test bits $4E.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cmp $0000.w,Y		; D9 00 00 ; Compare accumulator $0000.w,Y [Reads: Y Index] [Flags: NCZ]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $C4.b,X		; 34 C4 ; Test bits $C4.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$7B05.w		; 09 05 7B ; Logical OR #$7B05.w with accumulator [Writes: Accumulator] [Flags: NZ]
	bit $11.b,X		; 34 11 ; Test bits $11.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $04DA.w		; 0D DA 04 ; Logical OR $04DA.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $D5.b		; 06 D5 ; Arithmetic shift left $D5.b [Reads: Direct Page] [Flags: NCZ]
	cmp $E8.b		; C5 E8 ; Compare $E8.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	bit $B0.b,X		; 34 B0 ; Test bits $B0.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora $C6.b,X		; 15 C6 ; OR accumulator with memory $C6.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $34.b,X		; D5 34 ; Compare accumulator $34.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	bit $F1.b,X		; 34 F1 ; Test bits $F1.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $7BC60C.l		; 4F 0C C6 7B ; Exclusive OR accumulator with memory (long) $7BC60C.l [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc ($36.b,X)		; E1 36 ; Subtract with carry ($36.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $36.b,X		; 36 36 ; Rotate left $36.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $C4.b,X		; 36 C4 ; Rotate left $C4.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	cmp $00.b,X		; D5 00 ; Compare accumulator $00.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $1D.b		; 00 1D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $DA.b,X		; 34 DA ; Test bits $DA.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $16		; 10 16 ; Branch if plus to $10, $16 [Flow: branch]
	ora [$11.b],Y		; 17 11 ; OR accumulator with memory (long indexed) [$11.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($13.b),Y		; 11 13 ; OR accumulator with memory ($13.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora [$17.b],Y		; 17 17 ; OR accumulator with memory (long indexed) [$17.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b)		; 12 11 ; OR accumulator with memory (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($17.b),Y		; 11 17 ; OR accumulator with memory ($17.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($12.b)		; 12 12 ; OR accumulator with memory (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $1111.w,Y		; 19 11 11 ; OR accumulator with memory $1111.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($12.b)		; 12 12 ; OR accumulator with memory (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($23.b),Y		; 11 23 ; OR accumulator with memory ($23.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $34.b		; 25 34 ; Logical AND $34.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $1034.w,X		; 1D 34 10 ; OR accumulator with memory $1034.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $27		; 10 27 ; Branch if plus to $10, $27 [Flow: branch]
	and #$101B.w		; 29 1B 10 ; Logical AND #$101B.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $2D332B.l,X		; 1F 2B 33 2D ; Logical OR long $2D332B.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and $11002E.l		; 2F 2E 00 11 ; AND accumulator with memory (long) $11002E.l [Writes: Accumulator] [Flags: NZ]
	and $373634.l		; 2F 34 36 37 ; AND accumulator with memory (long) $373634.l [Writes: Accumulator] [Flags: NZ]
	.db $10, $11		; 10 11 ; Branch if plus to $10, $11 [Flow: branch]
	and [$38.b],Y		; 37 38 ; AND accumulator with memory (long indexed) [$38.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($3F.b)		; 12 3F ; OR accumulator with memory (indirect) ($3F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor ($34.b,X)		; 41 34 ; Exclusive OR accumulator with memory ($34.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $42, $44		; 42 44 ; Reserved instruction
	.db $10, $11		; 10 11 ; Branch if plus to $10, $11 [Flow: branch]
	lsr $47.b		; 46 47 ; Logical shift right $47.b [Reads: Direct Page] [Flags: NCZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	eor $1111.w		; 4D 11 11 ; Exclusive OR $1111.w with accumulator [Writes: Accumulator] [Flags: NZ]
	eor #$41C8.w		; 49 C8 41 ; Exclusive OR #$41C8.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lsr $1110.w		; 4E 10 11 ; Logical shift right $1110.w [Flags: NCZ]
	lsr $3250.w		; 4E 50 32 ; Logical shift right $3250.w [Flags: NCZ]
	trb $11.b		; 14 11 ; Test and reset bits $11.b [Reads: Accumulator] [Flags: Z]
	ora ($4C.b),Y		; 11 4C ; OR accumulator with memory ($4C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($C8.b)		; 12 C8 ; OR accumulator with memory (indirect) ($C8.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$0011.w		; C9 11 00 ; Compare #$0011.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp #$1254.w		; C9 54 12 ; Compare #$1254.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora ($01.b,S),Y		; 13 01 ; OR accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($13.b),Y		; 11 13 ; OR accumulator with memory ($13.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	trb $1F.b		; 14 1F ; Test and reset bits $1F.b [Reads: Accumulator] [Flags: Z]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor #$5757.w		; 49 57 57 ; Exclusive OR #$5757.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($11.b)		; 12 11 ; OR accumulator with memory (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($4C.b),Y		; 11 4C ; OR accumulator with memory ($4C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($1C.b)		; 12 1C ; OR accumulator with memory (indirect) ($1C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $1111.w,X		; 1D 11 11 ; OR accumulator with memory $1111.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	trb $1F.b		; 14 1F ; Test and reset bits $1F.b [Reads: Accumulator] [Flags: Z]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	.db $10, $11		; 10 11 ; Branch if plus to $10, $11 [Flow: branch]
	asl $11.b,X		; 16 11 ; Arithmetic shift left $11.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($34.b),Y		; 11 34 ; OR accumulator with memory ($34.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	and ($01.b)		; 32 01 ; AND accumulator with memory (indirect) ($01.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($2C.b),Y		; 11 2C ; OR accumulator with memory ($2C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $34.b		; 24 34 ; Test bits $34.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	eor $0111.w,X		; 5D 11 01 ; Exclusive OR accumulator with memory $0111.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr $5B60.w,X		; 5E 60 5B ; Logical shift right $5B60.w,X [Reads: X Index] [Flags: NCZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $6BC8.w,X		; 1D C8 6B ; OR accumulator with memory $6BC8.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $1110.w		; 6D 10 11 ; Add $1110.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	.db $62, $6E, $70		; 62 6E 70 ; Push effective relative address $62, $6E, $70 [Writes: Stack Pointer]
	ror $11.b		; 66 11 ; Rotate right $11.b [Reads: Direct Page] [Flags: NCZ]
	ora ($73.b),Y		; 11 73 ; OR accumulator with memory ($73.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	stz $78.b,X		; 74 78 ; Store zero to $78.b,X [Reads: X Index]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $E3.b,X		; 34 E3 ; Test bits $E3.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dec $0000.w		; CE 00 00 ; Decrement $0000.w [Flags: NZ]
	adc $C634.w,Y		; 79 34 C6 ; Add $C634.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $10.b		; C6 10 ; Decrement $10.b [Reads: Direct Page] [Flags: NZ]
	brk $C6.b		; 00 C6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	eor ($01.b)		; 52 01 ; Exclusive OR accumulator with memory (indirect) ($01.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($80.b),Y		; 11 80 ; OR accumulator with memory ($80.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $82, $39, $34		; 82 39 34 ; Branch always long to $82, $39, $34 [Flow: branch]
	ora ($10.b),Y		; 11 10 ; OR accumulator with memory ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $837DD2.l		; CF D2 7D 83 ; Compare accumulator (long) $837DD2.l [Reads: Accumulator] [Flags: NCZ]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp.w [$DC84]		; DC 84 DC ; Jump long indirect [$DC84] [Flow: jump]
	adc ($01.b,X)		; 61 01 ; Add with carry ($01.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($34.b,X)		; 01 34 ; Logical OR ($34.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp #$DC78.w		; C9 78 DC ; Compare #$DC78.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cmp #$CA86.w		; C9 86 CA ; Compare #$CA86.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $61.b,X		; 34 61 ; Test bits $61.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	eor ($01.b)		; 52 01 ; Exclusive OR accumulator with memory (indirect) ($01.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($6C.b),Y		; 11 6C ; OR accumulator with memory ($6C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $82, $17, $87		; 82 17 87 ; Branch always long to $82, $17, $87 [Flow: branch]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta ($95.b,S),Y		; 93 95 ; Store accumulator (stack relative indirect indexed) ($95.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	sta [$97.b],Y		; 97 97 ; Store accumulator (long indexed) [$97.b],Y [Reads: Direct Page, Y Index, Accumulator]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $9A.b,X		; 95 9A ; Store accumulator to $9A.b,X [Reads: Accumulator, X Index]
	sta ($18.b)		; 92 18 ; Store accumulator (indirect) ($18.b) [Reads: Direct Page, Accumulator]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	ora $112210.l,X		; 1F 10 22 11 ; Logical OR long $112210.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($24.b),Y		; 11 24 ; OR accumulator with memory ($24.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	stz $A2A0.w,X		; 9E A0 A2 ; Store zero to $A2A0.w,X [Reads: X Index]
	.db $10, $11		; 10 11 ; Branch if plus to $10, $11 [Flow: branch]
	lda ($A1.b,X)		; A1 A1 ; Load accumulator ($A1.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lda $A4.b,S		; A3 A4 ; Load accumulator (stack relative) $A4.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta ($26.b)		; 92 26 ; Store accumulator (indirect) ($26.b) [Reads: Direct Page, Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $381111.l,X		; 1F 11 11 38 ; Logical OR long $381111.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and [$36.b],Y		; 37 36 ; AND accumulator with memory (long indexed) [$36.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda #$1011.w		; A9 11 10 ; Load #$1011.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta [$8A.b]		; 87 8A ; Store accumulator (long) [$8A.b] [Reads: Direct Page, Accumulator]
	sty $118D.w		; 8C 8D 11 ; Store Y register to $118D.w [Reads: Y Index]
	ora ($8D.b),Y		; 11 8D ; OR accumulator with memory ($8D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	stx $928F.w		; 8E 8F 92 ; Store X register to $928F.w [Reads: X Index]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $26.b,X		; 34 26 ; Test bits $26.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	asl $0112.w,X		; 1E 12 01 ; Arithmetic shift left $0112.w,X [Reads: X Index] [Flags: NCZ]
	ora ($48.b),Y		; 11 48 ; OR accumulator with memory ($48.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda ($B4.b)		; B2 B4 ; Load accumulator (indirect) ($B4.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta [$11.b]		; 87 11 ; Store accumulator (long) [$11.b] [Reads: Direct Page, Accumulator]
	ora ($B5.b),Y		; 11 B5 ; OR accumulator with memory ($B5.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda [$B8.b],Y		; B7 B8 ; Load accumulator (long indexed) [$B8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda $B7.b,X		; B5 B7 ; Load $B7.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	bit $11.b,X		; 34 11 ; Test bits $11.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora ($01.b),Y		; 11 01 ; OR accumulator with memory ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $AD1C.w		; 2C 1C AD ; Test bits $AD1C.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	cmp $11.b		; C5 11 ; Compare $11.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora ($C7.b,X)		; 01 C7 ; Logical OR ($C7.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp #$CDCB.w		; C9 CB CD ; Compare #$CDCB.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $04D3D1.l		; CF D1 D3 04 ; Compare accumulator (long) $04D3D1.l [Reads: Accumulator] [Flags: NCZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $12.b,X		; D5 12 ; Compare accumulator $12.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	trb $1134.w		; 1C 34 11 ; Test and reset bits $1134.w [Reads: Accumulator] [Flags: Z]
	.db $10, $DD		; 10 DD ; Branch if plus to $10, $DD [Flow: branch]
	cmp $11E1DE.l,X		; DF DE E1 11 ; Compare accumulator (long,X) $11E1DE.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	ora ($E2.b),Y		; 11 E2 ; OR accumulator with memory ($E2.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $11ADE4.l,X		; DF E4 AD 11 ; Compare accumulator (long,X) $11ADE4.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	.db $10, $A4		; 10 A4 ; Branch if plus to $10, $A4 [Flow: branch]
	lda $A5.b		; A5 A5 ; Load $A5.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $4B.b		; 00 4B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $34.b		; E5 34 ; Subtract $34.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	bit $11.b,X		; 34 11 ; Test bits $11.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $EB.b		; 00 EB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp #$CFC9.w		; C9 C9 CF ; Compare #$CFC9.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	cmp $ED.b,X		; D5 ED ; Compare accumulator $ED.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc $10019F.l		; EF 9F 01 10 ; Subtract with carry (long) $10019F.l [Writes: Accumulator] [Flags: NCVZ]
	lda ($D5.b,X)		; A1 D5 ; Load accumulator ($D5.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$F8.b]		; 07 F8 ; OR accumulator with memory (long) [$F8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($34.b)		; F2 34 ; Subtract with carry (indirect) ($34.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	bit $10.b,X		; 34 10 ; Test bits $10.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $10, $A3		; 10 A3 ; Branch if plus to $10, $A3 [Flow: branch]
	jsr ($FE34.w,X)		; FC 34 FE ; Jump to subroutine indirect indexed ($FE34.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $3479D3.l,X		; FF D3 79 34 ; Subtract with carry (long,X) $3479D3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	ora ($EB.b,X)		; 01 EB ; Logical OR ($EB.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	stx $FB.b		; 86 FB ; Store X register to $FB.b [Reads: X Index]
	and ($11.b,X)		; 21 11 ; Logical AND ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$34.b]		; 07 34 ; OR accumulator with memory (long) [$34.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$200B.w		; 09 0B 20 ; Logical OR #$200B.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $C40000.l		; 22 00 00 C4 ; Jump to subroutine long $C40000.l [Writes: Stack Pointer] [Flow: call]
	cmp ($21.b)		; D2 21 ; Compare accumulator (indirect) ($21.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $6A.b,S		; 83 6A ; Store accumulator (stack relative) $6A.b,S [Reads: Stack Pointer, Accumulator]
	lda #$1011.w		; A9 11 10 ; Load #$1011.w into accumulator [Writes: Accumulator] [Flags: NZ]
	bit $12.b,X		; 34 12 ; Test bits $12.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $0500.w,Y		; 79 00 05 ; Add $0500.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $11.b		; 05 11 ; Logical OR $11.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($06.b),Y		; 11 06 ; OR accumulator with memory ($06.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	stx $10.b		; 86 10 ; Store X register to $10.b [Reads: X Index]
	asl $11.b		; 06 11 ; Arithmetic shift left $11.b [Reads: Direct Page] [Flags: NCZ]
	jsl $0E0243.l		; 22 43 02 0E ; Jump to subroutine long $0E0243.l [Writes: Stack Pointer] [Flow: call]
	dec $2012.w		; CE 12 20 ; Decrement $2012.w [Flags: NZ]
	cpy $34.b		; C4 34 ; Compare $34.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	cpy $F6.b		; C4 F6 ; Compare $F6.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $F3.b,X		; 34 F3 ; Test bits $F3.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ldy $E9.b		; A4 E9 ; Load $E9.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp ($4B.b),Y		; D1 4B ; Compare accumulator ($4B.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	eor ($39.b)		; 52 39 ; Exclusive OR accumulator with memory (indirect) ($39.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $A7A5.w,X		; FD A5 A7 ; Subtract with carry $A7A5.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $10.b,X		; 34 10 ; Test bits $10.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $E9.b		; 00 E9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($6150.w)		; 6C 50 61 ; Jump indirect to ($6150.w) [Flow: jump]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $101412.l		; CF 12 14 10 ; Compare accumulator (long) $101412.l [Reads: Accumulator] [Flags: NCZ]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $10, $15		; 10 15 ; Branch if plus to $10, $15 [Flow: branch]
	ora ($11.b)		; 12 11 ; OR accumulator with memory (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($12.b),Y		; 11 12 ; OR accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $12.b,X		; 15 12 ; OR accumulator with memory $12.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	jsr $1111.w		; 20 11 11 ; Jump to subroutine at $1111.w [Writes: Stack Pointer] [Flow: call]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	.db $10, $2A		; 10 2A ; Branch if plus to $10, $2A [Flow: branch]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsr $1212.w		; 20 12 12 ; Jump to subroutine at $1212.w [Writes: Stack Pointer] [Flow: call]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($10.b),Y		; 11 10 ; OR accumulator with memory ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	ora $1111.w,X		; 1D 11 11 ; OR accumulator with memory $1111.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora ($13.b)		; 12 13 ; OR accumulator with memory (indirect) ($13.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $11		; 10 11 ; Branch if plus to $10, $11 [Flow: branch]
	ora ($2A.b),Y		; 11 2A ; OR accumulator with memory ($2A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsr $1411.w		; 20 11 14 ; Jump to subroutine at $1411.w [Writes: Stack Pointer] [Flow: call]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $1A.b,X		; D5 1A ; Compare accumulator $1A.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	asl $1214.w,X		; 1E 14 12 ; Arithmetic shift left $1214.w,X [Reads: X Index] [Flags: NCZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	dec $66.b		; C6 66 ; Decrement $66.b [Reads: Direct Page] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $10, $12		; 10 12 ; Branch if plus to $10, $12 [Flow: branch]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	.db $30, $31		; 30 31 ; Branch if minus to $30, $31 [Flow: branch]
	ora ($21.b)		; 12 21 ; OR accumulator with memory (indirect) ($21.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($10.b),Y		; 11 10 ; OR accumulator with memory ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $1B.b		; 24 1B ; Test bits $1B.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora $2211.w,X		; 1D 11 22 ; OR accumulator with memory $2211.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	trb $716A.w		; 1C 6A 71 ; Test and reset bits $716A.w [Reads: Accumulator] [Flags: Z]
	.db $30, $21		; 30 21 ; Branch if minus to $30, $21 [Flow: branch]
	ora ($3C.b,X)		; 01 3C ; Logical OR ($3C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $3E3E.w,X		; 3D 3E 3E ; AND accumulator with memory $3E3E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $343C.w,X		; 3D 3C 34 ; AND accumulator with memory $343C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	trb $0211.w		; 1C 11 02 ; Test and reset bits $0211.w [Reads: Accumulator] [Flags: Z]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	bit $4B.b,X		; 34 4B ; Test bits $4B.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and ($10.b),Y		; 31 10 ; AND accumulator with memory ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($4C.b),Y		; 11 4C ; OR accumulator with memory ($4C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $11		; 10 11 ; Branch if plus to $10, $11 [Flow: branch]
	bit $1111.w		; 2C 11 11 ; Test bits $1111.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	bit $34.b		; 24 34 ; Test bits $34.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	trb $106A.w		; 1C 6A 10 ; Test and reset bits $106A.w [Reads: Accumulator] [Flags: Z]
	and ($4F.b,X)		; 21 4F ; Logical AND ($4F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	mvn $40,$2C		; 54 2C 40 ; Move block negative $40,$2C [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $5B, $53		; 62 5B 53 ; Push effective relative address $62, $5B, $53 [Writes: Stack Pointer]
	lsr $11.b,X		; 56 11 ; Logical shift right $11.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($12.b),Y		; 11 12 ; OR accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A10.w,Y		; 59 10 1A ; Exclusive OR accumulator with memory $1A10.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cmp $5B.b,X		; D5 5B ; Compare accumulator $5B.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($01.b),Y		; 11 01 ; OR accumulator with memory ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($12.b)		; 32 12 ; AND accumulator with memory (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($21.b)		; 12 21 ; OR accumulator with memory (indirect) ($21.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $325B4A.l,X		; 1F 4A 5B 32 ; Logical OR long $325B4A.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsr $1F10.w		; 20 10 1F ; Jump to subroutine at $1F10.w [Writes: Stack Pointer] [Flow: call]
	ora ($11.b)		; 12 11 ; OR accumulator with memory (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($4C.b),Y		; 11 4C ; OR accumulator with memory ($4C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $12		; 10 12 ; Branch if plus to $10, $12 [Flow: branch]
	dec $11.b		; C6 11 ; Decrement $11.b [Reads: Direct Page] [Flags: NZ]
	.db $10, $C6		; 10 C6 ; Branch if plus to $10, $C6 [Flow: branch]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	dec $00.b		; C6 00 ; Decrement $00.b [Reads: Direct Page] [Flags: NZ]
	brk $C6.b		; 00 C6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	dec $00.b		; C6 00 ; Decrement $00.b [Reads: Direct Page] [Flags: NZ]
	brk $C6.b		; 00 C6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	dec $00.b		; C6 00 ; Decrement $00.b [Reads: Direct Page] [Flags: NZ]
	brk $D1.b		; 00 D1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($59.b),Y		; D1 59 ; Compare accumulator ($59.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	asl $00.b,X		; 16 00 ; Arithmetic shift left $00.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($17.b),Y		; 11 17 ; OR accumulator with memory ($17.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora [$12.b],Y		; 17 12 ; OR accumulator with memory (long indexed) [$12.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jmp $1111.w		; 4C 11 11 ; Jump to $1111.w [Flow: jump]
	ora ($13.b),Y		; 11 13 ; OR accumulator with memory ($13.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $3A.b,S		; 23 3A ; AND accumulator with stack relative $3A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and #$1812.w		; 29 12 18 ; Logical AND #$1812.w with accumulator [Writes: Accumulator] [Flags: NZ]
	eor $1111.w		; 4D 11 11 ; Exclusive OR $1111.w with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	bit $27.b,X		; 34 27 ; Test bits $27.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and ($10.b)		; 32 10 ; AND accumulator with memory (indirect) ($10.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($2D.b),Y		; 11 2D ; OR accumulator with memory ($2D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora ($4C.b,S),Y		; 13 4C ; OR accumulator (stack relative indirect indexed) ($4C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $1A		; 10 1A ; Branch if plus to $10, $1A [Flow: branch]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($C3.b)		; 32 C3 ; AND accumulator with memory (indirect) ($C3.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($1F.b)		; 12 1F ; OR accumulator with memory (indirect) ($1F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl $25.b,X		; 16 25 ; Arithmetic shift left $25.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cmp $11.b,X		; D5 11 ; Compare accumulator $11.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($C2.b),Y		; 11 C2 ; OR accumulator with memory ($C2.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $5918.w,X		; 1E 18 59 ; Arithmetic shift left $5918.w,X [Reads: X Index] [Flags: NCZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and $71.b		; 25 71 ; Logical AND $71.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $11.b		; 65 11 ; Add $11.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($34.b),Y		; 11 34 ; OR accumulator with memory ($34.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $18.b,X		; 34 18 ; Test bits $18.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora ($34.b),Y		; 11 34 ; OR accumulator with memory ($34.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $D0, $17		; D0 17 ; Branch if not equal to $D0, $17 [Flow: branch]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$25.b],Y		; 17 25 ; OR accumulator with memory (long indexed) [$25.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $DB.b,X		; 34 DB ; Test bits $DB.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$CAE0.w		; C9 E0 CA ; Compare #$CAE0.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	adc $00.b		; 65 00 ; Add $00.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($65.b,X)		; 01 65 ; Logical OR ($65.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	adc [$34.b]		; 67 34 ; Add with carry (long) [$34.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	ora ($02.b),Y		; 11 02 ; OR accumulator with memory ($02.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	dec $00.b		; C6 00 ; Decrement $00.b [Reads: Direct Page] [Flags: NZ]
	brk $52.b		; 00 52 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $537F.w,X		; 7E 7F 53 ; Rotate right $537F.w,X [Reads: X Index] [Flags: NCZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$7EDD]		; DC DD 7E ; Jump long indirect [$7EDD] [Flow: jump]
	eor ($00.b,S),Y		; 53 00 ; XOR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($53.b),Y		; 11 53 ; OR accumulator with memory ($53.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor ($DC.b,S),Y		; 53 DC ; XOR accumulator (stack relative indirect indexed) ($DC.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $11.b		; E5 11 ; Subtract $11.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	brk $E3.b		; 00 E3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $DC2B.w		; 2C 2B DC ; Test bits $DC2B.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	cop $20.b		; 02 20 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $30DC.w		; 1C DC 30 ; Test and reset bits $30DC.w [Reads: Accumulator] [Flags: Z]
	jmp.w [$2020]		; DC 20 20 ; Jump long indirect [$2020] [Flow: jump]
	jmp.w [$C8E5]		; DC E5 C8 ; Jump long indirect [$C8E5] [Flow: jump]
	cmp $0000.w,X		; DD 00 00 ; Compare accumulator $0000.w,X [Reads: X Index] [Flags: NCZ]
	ora ($2B.b)		; 12 2B ; OR accumulator with memory (indirect) ($2B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($17.b,S),Y		; 33 17 ; AND accumulator (stack relative indirect indexed) ($17.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($34.b,X)		; 21 34 ; Logical AND ($34.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($10.b),Y		; 11 10 ; OR accumulator with memory ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $2E1818.l		; 2F 18 18 2E ; AND accumulator with memory (long) $2E1818.l [Writes: Accumulator] [Flags: NZ]
	ora ($21.b),Y		; 11 21 ; OR accumulator with memory ($21.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr $2760.w,X		; 5E 60 27 ; Logical shift right $2760.w,X [Reads: X Index] [Flags: NCZ]
	and ($11.b)		; 32 11 ; AND accumulator with memory (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($65.b),Y		; 11 65 ; OR accumulator with memory ($65.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	.db $62, $35, $11		; 62 35 11 ; Push effective relative address $62, $35, $11 [Writes: Stack Pointer]
	ora ($1B.b)		; 12 1B ; OR accumulator with memory (indirect) ($1B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $D121.w		; 20 21 D1 ; Jump to subroutine at $D121.w [Writes: Stack Pointer] [Flow: call]
	adc $34.b,X		; 75 34 ; Add $34.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and [$01.b],Y		; 37 01 ; AND accumulator with memory (long indexed) [$01.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cop $34.b		; 02 34 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and [$20.b]		; 27 20 ; AND accumulator with memory (long) [$20.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jmp.w [$3453]		; DC 53 34 ; Jump long indirect [$3453] [Flow: jump]
	bit $01.b,X		; 34 01 ; Test bits $01.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $37.b		; 00 37 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $6A.b,X		; 34 6A ; Test bits $6A.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $20.b,X		; 34 20 ; Test bits $20.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora ($1E.b),Y		; 11 1E ; OR accumulator with memory ($1E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($2B.b)		; 32 2B ; AND accumulator with memory (indirect) ($2B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$1011]		; DC 11 10 ; Jump long indirect [$1011] [Flow: jump]
	bit $76.b,X		; 34 76 ; Test bits $76.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $E7.b,X		; 34 E7 ; Test bits $E7.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	and #$6156.w		; 29 56 61 ; Logical AND #$6156.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $DB.b,X		; 34 DB ; Test bits $DB.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ror $6C.b,X		; 76 6C ; Rotate right $6C.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($34.b,S),Y		; 53 34 ; XOR accumulator (stack relative indirect indexed) ($34.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $4B.b,X		; 34 4B ; Test bits $4B.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $10, $01		; 10 01 ; Branch if plus to $10, $01 [Flow: branch]
	ora ($40.b)		; 12 40 ; OR accumulator with memory (indirect) ($40.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	sbc $11.b,S		; E3 11 ; Subtract stack-relative $11.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	brk $2D.b		; 00 2D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $3D.b,X		; 34 3D ; Test bits $3D.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and $1F2110.l		; 2F 10 21 1F ; AND accumulator with memory (long) $1F2110.l [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	and $201134.l,X		; 3F 34 11 20 ; AND accumulator with memory (long,X) $201134.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($10.b),Y		; 31 10 ; AND accumulator with memory ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($12.b)		; 12 12 ; OR accumulator with memory (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cmp #$4FC9.w		; C9 C9 4F ; Compare #$4FC9.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $10, $01		; 10 01 ; Branch if plus to $10, $01 [Flow: branch]
	eor ($12.b),Y		; 51 12 ; Exclusive OR accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	eor ($55.b,S),Y		; 53 55 ; XOR accumulator (stack relative indirect indexed) ($55.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $331101.l,X		; 1F 01 11 33 ; Logical OR long $331101.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	bit $55.b		; 24 55 ; Test bits $55.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora $471012.l,X		; 1F 12 10 47 ; Logical OR long $471012.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	bit $4B.b,X		; 34 4B ; Test bits $4B.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $0000.w		; 2C 00 00 ; Test bits $0000.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	.db $90, $37		; 90 37 ; Branch if carry clear to $90, $37 [Flow: branch]
	and ($34.b,S),Y		; 33 34 ; AND accumulator (stack relative indirect indexed) ($34.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $8C.b,X		; 34 8C ; Test bits $8C.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $70, $30		; 70 30 ; Branch if overflow set to $70, $30 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $3440.w		; 2E 40 34 ; Rotate left $3440.w [Flags: NCZ]
	adc #$0000.w		; 69 00 00 ; Add #$0000.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	bit $0445.w		; 2C 45 04 ; Test bits $0445.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	stz $00.b,X		; 74 00 ; Store zero to $00.b,X [Reads: X Index]
	brk $4B.b		; 00 4B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $2E.b		; 04 2E ; Test and set bits $2E.b [Reads: Accumulator] [Flags: Z]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $6421.w,Y		; 39 21 64 ; AND accumulator with memory $6421.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $0E36.w,Y		; 39 36 0E ; AND accumulator with memory $0E36.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and $6C0000.l		; 2F 00 00 6C ; AND accumulator with memory (long) $6C0000.l [Writes: Accumulator] [Flags: NZ]
	eor ($3A.b,X)		; 41 3A ; Exclusive OR accumulator with memory ($3A.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc #$0002.w		; 69 02 00 ; Add #$0002.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	tsb $23.b		; 04 23 ; Test and set bits $23.b [Reads: Accumulator] [Flags: Z]
	lda ($7E.b)		; B2 7E ; Load accumulator (indirect) ($7E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($1D.b,X)		; 41 1D ; Exclusive OR accumulator with memory ($1D.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $34.b		; 04 34 ; Test and set bits $34.b [Reads: Accumulator] [Flags: Z]
	jsr $3F00.w		; 20 00 3F ; Jump to subroutine at $3F00.w [Writes: Stack Pointer] [Flow: call]
	ora [$04.b],Y		; 17 04 ; OR accumulator with memory (long indexed) [$04.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($5B.b)		; 32 5B ; AND accumulator with memory (indirect) ($5B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $34.b		; 45 34 ; Exclusive OR $34.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $6D		; 30 6D ; Branch if minus to $30, $6D [Flow: branch]
	stz $00.b		; 64 00 ; Store zero to $00.b
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $6440.w,X		; 1D 40 64 ; OR accumulator with memory $6440.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc #$7E13.w		; 69 13 7E ; Add #$7E13.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	ldx $0000.w		; AE 00 00 ; Load $0000.w into X register [Writes: X Index] [Flags: NZ]
	and $46.b,S		; 23 46 ; AND accumulator with stack relative $46.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda ($7E.b)		; B2 7E ; Load accumulator (indirect) ($7E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx $8945.w		; AE 45 89 ; Load $8945.w into X register [Writes: X Index] [Flags: NZ]
	ora $340000.l,X		; 1F 00 00 34 ; Logical OR long $340000.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sta ($AE.b)		; 92 AE ; Store accumulator (indirect) ($AE.b) [Reads: Direct Page, Accumulator]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $4434.w		; 8C 34 44 ; Store Y register to $4434.w [Reads: Y Index]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta [$9C.b],Y		; 97 9C ; Store accumulator (long indexed) [$9C.b],Y [Reads: Direct Page, Y Index, Accumulator]
	and $04.b,X		; 35 04 ; Logical AND $04.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda #$B634.w		; A9 34 B6 ; Load #$B634.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0F.b		; 04 0F ; Test and set bits $0F.b [Reads: Accumulator] [Flags: Z]
	eor $0005.w,X		; 5D 05 00 ; Exclusive OR accumulator with memory $0005.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$2F.b]		; 27 2F ; AND accumulator with memory (long) [$2F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $0000.w		; AD 00 00 ; Load $0000.w into accumulator [Writes: Accumulator] [Flags: NZ]
	bit $01.b,X		; 34 01 ; Test bits $01.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $0004.w		; AC 04 00 ; Load $0004.w into Y register [Writes: Y Index] [Flags: NZ]
	and ($00.b,S),Y		; 33 00 ; AND accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $AC.b		; 00 AC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and #$1415.w		; 29 15 14 ; Logical AND #$1415.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $15.b,X		; 16 15 ; Arithmetic shift left $15.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora [$09.b]		; 07 09 ; OR accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $4F4D00.l		; 22 00 4D 4F ; Jump to subroutine long $4F4D00.l [Writes: Stack Pointer] [Flow: call]
	and ($04.b)		; 32 04 ; AND accumulator with memory (indirect) ($04.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $2F.b		; 04 2F ; Test and set bits $2F.b [Reads: Accumulator] [Flags: Z]
	brk $4C.b		; 00 4C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $6E		; 30 6E ; Branch if minus to $30, $6E [Flow: branch]
	bit $AF.b,X		; 34 AF ; Test bits $AF.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $6934.w		; 4E 34 69 ; Logical shift right $6934.w [Flags: NCZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	jsr $1800.w		; 20 00 18 ; Jump to subroutine at $1800.w [Writes: Stack Pointer] [Flow: call]
	and $003434.l,X		; 3F 34 34 00 ; AND accumulator with memory (long,X) $003434.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $363A.w,X		; DE 3A 36 ; Decrement memory $363A.w,X [Reads: X Index] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	tsb $36.b		; 04 36 ; Test and set bits $36.b [Reads: Accumulator] [Flags: Z]
	bit $0000.w		; 2C 00 00 ; Test bits $0000.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	ora ($45.b,S),Y		; 13 45 ; OR accumulator (stack relative indirect indexed) ($45.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $B2.b,S		; 23 B2 ; AND accumulator with stack relative $B2.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $0A.b		; 45 0A ; Exclusive OR $0A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $000076.l,X		; 7F 76 00 00 ; Add long $000076.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $50, $5B		; 50 5B ; Branch if overflow clear to $50, $5B [Flow: branch]
	cpx $E3.b		; E4 E3 ; Compare $E3.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	and ($00.b,X)		; 21 00 ; Logical AND ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpx $34.b		; E4 34 ; Compare $34.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	jmp.w [$0000]		; DC 00 00 ; Jump long indirect [$0000] [Flow: jump]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	eor ($53.b,S),Y		; 53 53 ; XOR accumulator (stack relative indirect indexed) ($53.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp #$1001.w		; C9 01 10 ; Compare #$1001.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp #$C9E7.w		; C9 E7 C9 ; Compare #$C9E7.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	eor ($01.b,S),Y		; 53 01 ; XOR accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $E6.b		; 02 E6 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$53.b]		; E7 53 ; Subtract with carry (long) [$53.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jsl $531201.l		; 22 01 12 53 ; Jump to subroutine long $531201.l [Writes: Stack Pointer] [Flow: call]
	bit $C4.b,X		; 34 C4 ; Test bits $C4.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and [$10.b]		; 27 10 ; AND accumulator with memory (long) [$10.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($5B.b,X)		; 01 5B ; Logical OR ($5B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	bit $27.b,X		; 34 27 ; Test bits $27.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora ($01.b),Y		; 11 01 ; OR accumulator with memory ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($CE.b,X)		; 21 CE ; Logical AND ($CE.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	jmp ($0120.w)		; 6C 20 01 ; Jump indirect to ($0120.w) [Flow: jump]
	.db $82, $53, $53		; 82 53 53 ; Branch always long to $82, $53, $53 [Flow: branch]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	ora ($10.b),Y		; 11 10 ; OR accumulator with memory ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor ($4E.b,S),Y		; 53 4E ; XOR accumulator (stack relative indirect indexed) ($4E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	stz $119F.w,X		; 9E 9F 11 ; Store zero to $119F.w,X [Reads: X Index]
	brk $53.b		; 00 53 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $C9.b,S		; 83 C9 ; Store accumulator (stack relative) $C9.b,S [Reads: Stack Pointer, Accumulator]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $345B.w,Y		; 59 5B 34 ; Exclusive OR accumulator with memory $345B.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	inc $0122.w,X		; FE 22 01 ; Increment memory $0122.w,X [Reads: X Index] [Flags: NZ]
	lda $83A7.w		; AD A7 83 ; Load $83A7.w into accumulator [Writes: Accumulator] [Flags: NZ]
	adc $00.b,S		; 63 00 ; Add with carry (stack relative) $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora ($64.b)		; 12 64 ; OR accumulator with memory (indirect) ($64.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	stz $5E.b		; 64 5E ; Store zero to $5E.b
	bit $22.b,X		; 34 22 ; Test bits $22.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	jsr $67A5.w		; 20 A5 67 ; Jump to subroutine at $67A5.w [Writes: Stack Pointer] [Flow: call]
	eor $120263.l		; 4F 63 02 12 ; Exclusive OR accumulator with memory (long) $120263.l [Writes: Accumulator] [Flags: NZ]
	adc #$706D.w		; 69 6D 70 ; Add #$706D.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	adc #$2222.w		; 69 22 22 ; Add #$2222.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	ror $505D.w		; 6E 5D 50 ; Rotate right $505D.w [Flags: NCZ]
	jmp $E41222.l		; 5C 22 12 E4 ; Jump long to $E41222.l [Flow: jump]
	bit $73.b,X		; 34 73 ; Test bits $73.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	brk $21.b		; 00 21 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $86.b,X		; 34 86 ; Test bits $86.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	stz $0F.b,X		; 74 0F ; Store zero to $0F.b,X [Reads: X Index]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	adc [$0F.b],Y		; 77 0F ; Add with carry (long indexed) [$0F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $4F.b,X		; 34 4F ; Test bits $4F.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	jsl $343401.l		; 22 01 34 34 ; Jump to subroutine long $343401.l [Writes: Stack Pointer] [Flow: call]
	jmp ($00E3.w)		; 6C E3 00 ; Jump indirect to ($00E3.w) [Flow: jump]
	.db $10, $76		; 10 76 ; Branch if plus to $10, $76 [Flow: branch]
	cmp #$4BC9.w		; C9 C9 4B ; Compare #$4BC9.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $10, $01		; 10 01 ; Branch if plus to $10, $01 [Flow: branch]
	cmp #$5D50.w		; C9 50 5D ; Compare #$5D50.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	stz $01.b		; 64 01 ; Store zero to $01.b
	jsl $657B79.l		; 22 79 7B 65 ; Jump to subroutine long $657B79.l [Writes: Stack Pointer] [Flow: call]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jsl $6C6522.l		; 22 22 65 6C ; Jump to subroutine long $6C6522.l [Writes: Stack Pointer] [Flow: call]
	adc $222280.l,X		; 7F 80 22 22 ; Add long $222280.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $78.b,S		; 23 78 ; AND accumulator with stack relative $78.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jmp ($227E.w,X)		; 7C 7E 22 ; Jump indirect indexed to ($227E.w,X) [Reads: X Index] [Flow: jump]
	jsl $CAC482.l		; 22 82 C4 CA ; Jump to subroutine long $CAC482.l [Writes: Stack Pointer] [Flow: call]
	and $20.b,S		; 23 20 ; AND accumulator with stack relative $20.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $78.b		; 02 78 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $82, $83, $22		; 82 83 22 ; Branch always long to $82, $83, $22 [Flow: branch]
	and ($6B.b,X)		; 21 6B ; Logical AND ($6B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	stx $88.b		; 86 88 ; Store X register to $88.b [Reads: X Index]
	adc $22.b		; 65 22 ; Add $22.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jsl $C58C78.l		; 22 78 8C C5 ; Jump to subroutine long $C58C78.l [Writes: Stack Pointer] [Flow: call]
	trb $0212.w		; 1C 12 02 ; Test and reset bits $0212.w [Reads: Accumulator] [Flags: Z]
	sta ($20.b,X)		; 81 20 ; Store accumulator ($20.b,X) [Reads: Direct Page, Accumulator, X Index]
	sbc ($78.b)		; F2 78 ; Subtract with carry (indirect) ($78.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jsl $5E8912.l		; 22 12 89 5E ; Jump to subroutine long $5E8912.l [Writes: Stack Pointer] [Flow: call]
	jmp $222280.l		; 5C 80 22 22 ; Jump long to $222280.l [Flow: jump]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc $86.b		; 65 86 ; Add $86.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	rol $22.b		; 26 22 ; Rotate left $22.b [Reads: Direct Page] [Flags: NCZ]
	ora ($23.b),Y		; 11 23 ; OR accumulator with memory ($23.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	bit #$2280.w		; 89 80 22 ; Test bits #$2280.w with accumulator [Reads: Accumulator] [Flags: Z]
	jsl $247878.l		; 22 78 78 24 ; Jump to subroutine long $247878.l [Writes: Stack Pointer] [Flow: call]
	bit $22.b,X		; 34 22 ; Test bits $22.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $10, $35		; 10 35 ; Branch if plus to $10, $35 [Flow: branch]
	rol $36.b,X		; 36 36 ; Rotate left $36.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sta ($11.b,S),Y		; 93 11 ; Store accumulator (stack relative indirect indexed) ($11.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	ora ($94.b)		; 12 94 ; OR accumulator with memory (indirect) ($94.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $96.b,X		; 95 96 ; Store accumulator to $96.b,X [Reads: Accumulator, X Index]
	sta ($22.b,S),Y		; 93 22 ; Store accumulator (stack relative indirect indexed) ($22.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	jsl $9734F2.l		; 22 F2 34 97 ; Jump to subroutine long $9734F2.l [Writes: Stack Pointer] [Flow: call]
	sta [$00.b],Y		; 97 00 ; Store accumulator (long indexed) [$00.b],Y [Reads: Direct Page, Y Index, Accumulator]
	jsl $9B9A99.l		; 22 99 9A 9B ; Jump to subroutine long $9B9A99.l [Writes: Stack Pointer] [Flow: call]
	sta [$22.b],Y		; 97 22 ; Store accumulator (long indexed) [$22.b],Y [Reads: Direct Page, Y Index, Accumulator]
	jsl $353434.l		; 22 34 34 35 ; Jump to subroutine long $353434.l [Writes: Stack Pointer] [Flow: call]
	eor $00.b		; 45 00 ; Exclusive OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($A2.b),Y		; 11 A2 ; OR accumulator with memory ($A2.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ldx #$78A3.w		; A2 A3 78 ; Load #$78A3.w into X register [Writes: X Index] [Flags: NZ]
	jsl $347822.l		; 22 22 78 34 ; Jump to subroutine long $347822.l [Writes: Stack Pointer] [Flow: call]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jsr $7812.w		; 20 12 78 ; Jump to subroutine at $7812.w [Writes: Stack Pointer] [Flow: call]
	adc $6178.w,X		; 7D 78 61 ; Add $6178.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $786321.l		; 22 21 63 78 ; Jump to subroutine long $786321.l [Writes: Stack Pointer] [Flow: call]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jsl $635C22.l		; 22 22 5C 63 ; Jump to subroutine long $635C22.l [Writes: Stack Pointer] [Flow: call]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jsl $788822.l		; 22 22 88 78 ; Jump to subroutine long $788822.l [Writes: Stack Pointer] [Flow: call]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $80, $22		; 80 22 ; Branch always to $80, $22 [Flow: branch]
	jsl $888678.l		; 22 78 86 88 ; Jump to subroutine long $888678.l [Writes: Stack Pointer] [Flow: call]
	sta $22.b,S		; 83 22 ; Store accumulator (stack relative) $22.b,S [Reads: Stack Pointer, Accumulator]
	jsl $816571.l		; 22 71 65 81 ; Jump to subroutine long $816571.l [Writes: Stack Pointer] [Flow: call]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora ($22.b),Y		; 11 22 ; OR accumulator with memory ($22.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc CGDATA.w		; ED 22 21 ; Subtract CGDATA.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta ($65.b,X)		; 81 65 ; Store accumulator ($65.b,X) [Reads: Direct Page, Accumulator, X Index]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	stz $22.b		; 64 22 ; Store zero to $22.b
	jsl $6D7B79.l		; 22 79 7B 6D ; Jump to subroutine long $6D7B79.l [Writes: Stack Pointer] [Flow: call]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jsl $5C8422.l		; 22 22 84 5C ; Jump to subroutine long $5C8422.l [Writes: Stack Pointer] [Flow: call]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jsl $7A8022.l		; 22 22 80 7A ; Jump to subroutine long $7A8022.l [Writes: Stack Pointer] [Flow: call]
	bit #$225D.w		; 89 5D 22 ; Test bits #$225D.w with accumulator [Reads: Accumulator] [Flags: Z]
	jsl $4BA730.l		; 22 30 A7 4B ; Jump to subroutine long $4BA730.l [Writes: Stack Pointer] [Flow: call]
	.db $50, $22		; 50 22 ; Branch if overflow clear to $50, $22 [Flow: branch]
	ora ($E3.b),Y		; 11 E3 ; OR accumulator with memory ($E3.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda #$02CC.w		; A9 CC 02 ; Load #$02CC.w into accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $3439.w		; 20 39 34 ; Jump to subroutine at $3439.w [Writes: Stack Pointer] [Flow: call]
	lda $2034.w		; AD 34 20 ; Load $2034.w into accumulator [Writes: Accumulator] [Flags: NZ]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $AE34.w		; ED 34 AE ; Subtract $AE34.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $AD.b,X		; 34 AD ; Test bits $AD.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $B0, $D4		; B0 D4 ; Branch if carry set to $B0, $D4 [Flow: branch]
	cop $21.b		; 02 21 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $34.b,X		; D5 34 ; Compare accumulator $34.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ldy $0210.w		; AC 10 02 ; Load $0210.w into Y register [Writes: Y Index] [Flags: NZ]
	sbc [$34.b]		; E7 34 ; Subtract with carry (long) [$34.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	bit $10.b,X		; 34 10 ; Test bits $10.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $C4.b		; 00 C4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $D0, $34		; D0 34 ; Branch if not equal to $D0, $34 [Flow: branch]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $24.b		; 65 24 ; Add $24.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and $216D.w,Y		; 39 6D 21 ; AND accumulator with memory $216D.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($B4.b)		; 12 B4 ; OR accumulator with memory (indirect) ($B4.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldx $E3.b		; A6 E3 ; Load $E3.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jsl $1D6302.l		; 22 02 63 1D ; Jump to subroutine long $1D6302.l [Writes: Stack Pointer] [Flow: call]
	ora $1134.w,X		; 1D 34 11 ; OR accumulator with memory $1134.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $23		; 10 23 ; Branch if plus to $10, $23 [Flow: branch]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sei		; 78 ; Set interrupt disable flag [Flags: I]
	lsr CGDATA.w		; 4E 22 21 ; Logical shift right CGDATA.w [Flags: NCZ]
	and $4F.b,X		; 35 4F ; Logical AND $4F.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	bit $8F.b,X		; 34 8F ; Test bits $8F.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sta [$6B.b]		; 87 6B ; Store accumulator (long) [$6B.b] [Reads: Direct Page, Accumulator]
	eor ($22.b)		; 52 22 ; Exclusive OR accumulator with memory (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($6A.b,X)		; 21 6A ; Logical AND ($6A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ror $68.b		; 66 68 ; Rotate right $68.b [Reads: Direct Page] [Flags: NCZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	and ($22.b,X)		; 21 22 ; Logical AND ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta $83.b,S		; 83 83 ; Store accumulator (stack relative) $83.b,S [Reads: Stack Pointer, Accumulator]
	sta ($75.b,X)		; 81 75 ; Store accumulator ($75.b,X) [Reads: Direct Page, Accumulator, X Index]
	and ($21.b,X)		; 21 21 ; Logical AND ($21.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	ldx $BFB8.w,Y		; BE B8 BF ; Load X register $BFB8.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ora ($22.b)		; 12 22 ; OR accumulator with memory (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dec $83.b		; C6 83 ; Decrement $83.b [Reads: Direct Page] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	ora ($12.b,X)		; 01 12 ; Logical OR ($12.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rep #$C3		; C2 C3 ; Reset processor status bits #$C3 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	eor ($BD.b,S),Y		; 53 BD ; XOR accumulator (stack relative indirect indexed) ($BD.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $C0CB12.l		; 22 12 CB C0 ; Jump to subroutine long $C0CB12.l [Writes: Stack Pointer] [Flow: call]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cmp $22.b		; C5 22 ; Compare $22.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora ($C8.b)		; 12 C8 ; OR accumulator with memory (indirect) ($C8.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $51.b		; 00 51 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $1221.w		; CD 21 12 ; Compare $1221.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp $D0.b,X		; D5 D0 ; Compare accumulator $D0.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cmp ($D3.b)		; D2 D3 ; Compare accumulator (indirect) ($D3.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	jsl $070522.l		; 22 22 05 07 ; Jump to subroutine long $070522.l [Writes: Stack Pointer] [Flow: call]
	eor ($D1.b,S),Y		; 53 D1 ; XOR accumulator (stack relative indirect indexed) ($D1.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($12.b),Y		; 11 12 ; OR accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($D8.b)		; D2 D8 ; Compare accumulator (indirect) ($D8.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp $D9.b,X		; D5 D9 ; Compare accumulator $D9.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	jsl $D3C722.l		; 22 22 C7 D3 ; Jump to subroutine long $D3C722.l [Writes: Stack Pointer] [Flow: call]
	.db $D0, $5B		; D0 5B ; Branch if not equal to $D0, $5B [Flow: branch]
	jsl $DAC501.l		; 22 01 C5 DA ; Jump to subroutine long $DAC501.l [Writes: Stack Pointer] [Flow: call]
	cmp [$CD.b]		; C7 CD ; Compare accumulator (long) [$CD.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	jsl $D2DC22.l		; 22 22 DC D2 ; Jump to subroutine long $D2DC22.l [Writes: Stack Pointer] [Flow: call]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	bit $22.b,X		; 34 22 ; Test bits $22.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	jsr $CA5C.w		; 20 5C CA ; Jump to subroutine at $CA5C.w [Writes: Stack Pointer] [Flow: call]
	cmp $DF.b		; C5 DF ; Compare $DF.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	.db $10, $22		; 10 22 ; Branch if plus to $10, $22 [Flow: branch]
	cmp $C9DB.w,X		; DD DB C9 ; Compare accumulator $C9DB.w,X [Reads: X Index] [Flags: NCZ]
	.db $62, $22, $21		; 62 22 21 ; Push effective relative address $62, $22, $21 [Writes: Stack Pointer]
	sbc ($E2.b,X)		; E1 E2 ; Subtract with carry ($E2.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $C5.b,X		; D5 C5 ; Compare accumulator $C5.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	jsl $C7DD02.l		; 22 02 DD C7 ; Jump to subroutine long $C7DD02.l [Writes: Stack Pointer] [Flow: call]
	sbc #$22EB.w		; E9 EB 22 ; Subtract #$22EB.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	jsl $E6ECCE.l		; 22 CE EC E6 ; Jump to subroutine long $E6ECCE.l [Writes: Stack Pointer] [Flow: call]
	inc $2202.w		; EE 02 22 ; Increment $2202.w [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cmp $CD.b		; C5 CD ; Compare $CD.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp $2202.w		; CD 02 22 ; Compare $2202.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	inc $F6.b,X		; F6 F6 ; Increment memory $F6.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	cmp $2222F0.l,X		; DF F0 22 22 ; Compare accumulator (long,X) $2222F0.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	sty $C9.b		; 84 C9 ; Store Y register to $C9.b [Reads: Y Index]
	sbc $01.b,X		; F5 01 ; Subtract $01.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $EE.b		; 02 EE ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy $58.b		; C4 58 ; Compare $58.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	jsr $F811.w		; 20 11 F8 ; Jump to subroutine at $F811.w [Writes: Stack Pointer] [Flow: call]
	cmp $FACD.w		; CD CD FA ; Compare $FACD.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsl $C7CD22.l		; 22 22 CD C7 ; Jump to subroutine long $C7CD22.l [Writes: Stack Pointer] [Flow: call]
	bit $3A.b,X		; 34 3A ; Test bits $3A.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	jsl $EEE602.l		; 22 02 E6 EE ; Jump to subroutine long $EEE602.l [Writes: Stack Pointer] [Flow: call]
	cmp $012231.l		; CF 31 22 01 ; Compare accumulator (long) $012231.l [Reads: Accumulator] [Flags: NCZ]
	cmp $CDCD.w		; CD CD CD ; Compare $CDCD.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $5E.b,S		; 23 5E ; AND accumulator with stack relative $5E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $116369.l,X		; 5F 69 63 11 ; Exclusive OR accumulator with memory (long,X) $116369.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($EC.b),Y		; 11 EC ; OR accumulator with memory ($EC.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	inc $C4.b		; E6 C4 ; Increment $C4.b [Reads: Direct Page] [Flags: NZ]
	and ($22.b),Y		; 31 22 ; AND accumulator with memory ($22.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($09.b,X)		; 01 09 ; Logical OR ($09.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	and ($33.b,S),Y		; 33 33 ; AND accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $0C.b		; E6 0C ; Increment $0C.b [Reads: Direct Page] [Flags: NZ]
	sbc ($E2.b,X)		; E1 E2 ; Subtract with carry ($E2.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $22.b,S		; 23 22 ; AND accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$E6.b]		; 07 E6 ; OR accumulator with memory (long) [$E6.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	ora ($32.b,S),Y		; 13 32 ; OR accumulator (stack relative indirect indexed) ($32.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($13.b,S),Y		; 13 13 ; OR accumulator (stack relative indirect indexed) ($13.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpy $E6.b		; C4 E6 ; Compare $E6.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	inc $30.b		; E6 30 ; Increment $30.b [Reads: Direct Page] [Flags: NZ]
	jsl $CA15E6.l		; 22 E6 15 CA ; Jump to subroutine long $CA15E6.l [Writes: Stack Pointer] [Flow: call]
	cpy $2223.w		; CC 23 22 ; Compare $2223.w with Y register [Reads: Y Index] [Flags: NCZ]
	cmp $06E61E.l		; CF 1E E6 06 ; Compare accumulator (long) $06E61E.l [Reads: Accumulator] [Flags: NCZ]
	ora $21.b,S		; 03 21 ; OR accumulator with stack relative $21.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr $E6E6.w		; 20 E6 E6 ; Jump to subroutine at $E6E6.w [Writes: Stack Pointer] [Flow: call]
	sbc ($32.b),Y		; F1 32 ; Subtract with carry ($32.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $D4C575.l		; 22 75 C5 D4 ; Jump to subroutine long $D4C575.l [Writes: Stack Pointer] [Flow: call]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ora ($20.b)		; 12 20 ; OR accumulator with memory (indirect) ($20.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cmp $71.b		; C5 71 ; Compare $71.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cpx $1210.w		; EC 10 12 ; Compare $1210.w with X register [Reads: X Index] [Flags: NCZ]
	inc $CFF1.w		; EE F1 CF ; Increment $CFF1.w [Flags: NZ]
	eor ($22.b,S),Y		; 53 22 ; XOR accumulator (stack relative indirect indexed) ($22.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($D1.b,X)		; 01 D1 ; Logical OR ($D1.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $D4.b		; 25 D4 ; Logical AND $D4.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	and $20.b,S		; 23 20 ; AND accumulator with stack relative $20.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp ($20.b)		; D2 20 ; Compare accumulator (indirect) ($20.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	inc $03E6.w,X		; FE E6 03 ; Increment memory $03E6.w,X [Reads: X Index] [Flags: NZ]
	jsr $04D1.w		; 20 D1 04 ; Jump to subroutine at $04D1.w [Writes: Stack Pointer] [Flow: call]
	and ($F7.b,S),Y		; 33 F7 ; AND accumulator (stack relative indirect indexed) ($F7.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $22.b,S		; 23 22 ; AND accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and #$2DFE.w		; 29 FE 2D ; Logical AND #$2DFE.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $763332.l		; 2F 32 33 76 ; AND accumulator with memory (long) $763332.l [Writes: Accumulator] [Flags: NZ]
	adc $7995.w,Y		; 79 95 79 ; Add $7995.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	adc $953434.l,X		; 7F 34 34 95 ; Add long $953434.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	bit $AE.b,X		; 34 AE ; Test bits $AE.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $3533.w		; 9C 33 35 ; Store zero to $3533.w
	bit $03.b,X		; 34 03 ; Test bits $03.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $30, $34		; 30 34 ; Branch if minus to $30, $34 [Flow: branch]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	adc ($00.b),Y		; 71 00 ; Add with carry ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $94.b		; 00 94 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ror $0000.w,X		; 7E 00 00 ; Rotate right $0000.w,X [Reads: X Index] [Flags: NCZ]
	ror $38.b,X		; 76 38 ; Rotate right $38.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	bit $9D.b,X		; 34 9D ; Test bits $9D.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	bit $3E.b,X		; 34 3E ; Test bits $3E.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	sta $7E11.w,X		; 9D 11 7E ; Store accumulator to $7E11.w,X [Reads: Accumulator, X Index]
	ldx $0020.w		; AE 20 00 ; Load $0020.w into X register [Writes: X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	eor ($01.b,X)		; 41 01 ; Exclusive OR accumulator with memory ($01.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and ($43.b,S),Y		; 33 43 ; AND accumulator (stack relative indirect indexed) ($43.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $4D4C.w,X		; 3E 4C 4D ; Rotate left $4D4C.w,X [Reads: X Index] [Flags: NCZ]
	and ($33.b,S),Y		; 33 33 ; AND accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $ED5351.l		; 4F 51 53 ED ; Exclusive OR accumulator with memory (long) $ED5351.l [Writes: Accumulator] [Flags: NZ]
	and ($31.b,S),Y		; 33 31 ; AND accumulator (stack relative indirect indexed) ($31.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lsr $6260.w,X		; 5E 60 62 ; Logical shift right $6260.w,X [Reads: X Index] [Flags: NCZ]
	adc $33.b,S		; 63 33 ; Add with carry (stack relative) $33.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	and ($ED.b,S),Y		; 33 ED ; AND accumulator (stack relative indirect indexed) ($ED.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $66.b,X		; 95 66 ; Store accumulator to $66.b,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	.db $10, $33		; 10 33 ; Branch if plus to $10, $33 [Flow: branch]
	adc $9D68.w,Y		; 79 68 9D ; Add $9D68.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $0313.w		; 6D 13 03 ; Add $0313.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	bit $70.b,X		; 34 70 ; Test bits $70.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	adc ($79.b)		; 72 79 ; Add with carry (indirect) ($79.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $31.b,S		; 03 31 ; OR accumulator with stack relative $31.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc ($73.b)		; 72 73 ; Add with carry (indirect) ($73.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and ($00.b,S),Y		; 33 00 ; AND accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and #$3434.w		; 29 34 34 ; Logical AND #$3434.w with accumulator [Writes: Accumulator] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	jsr $9500.w		; 20 00 95 ; Jump to subroutine at $9500.w [Writes: Stack Pointer] [Flow: call]
	adc $E295.w,Y		; 79 95 E2 ; Add $E295.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc ($7A.b,X)		; E1 7A ; Subtract with carry ($7A.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	jmp ($3303.w,X)		; 7C 03 33 ; Jump indirect indexed to ($3303.w,X) [Reads: X Index] [Flow: jump]
	adc $360F.w,X		; 7D 0F 36 ; Add $360F.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $32.b,X		; 34 32 ; Test bits $32.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $36.b		; 00 36 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($0F36.w,X)		; 7C 36 0F ; Jump indirect indexed to ($0F36.w,X) [Reads: X Index] [Flow: jump]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ror $360F.w,X		; 7E 0F 36 ; Rotate right $360F.w,X [Reads: X Index] [Flags: NCZ]
	adc $0132.w,Y		; 79 32 01 ; Add $0132.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $340F35.l		; 0F 35 0F 34 ; OR accumulator with memory (long) $340F35.l [Writes: Accumulator] [Flags: NZ]
	jsr $7320.w		; 20 20 73 ; Jump to subroutine at $7320.w [Writes: Stack Pointer] [Flow: call]
	adc ($7F.b,S),Y		; 73 7F ; Add with carry (stack relative indirect indexed) ($7F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	adc $3133.w,Y		; 79 33 31 ; Add $3133.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($7E.b,S),Y		; 73 7E ; Add with carry (stack relative indirect indexed) ($7E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	jmp ($339E.w,X)		; 7C 9E 33 ; Jump indirect indexed to ($339E.w,X) [Reads: X Index] [Flow: jump]
	.db $10, $FF		; 10 FF ; Branch if plus to $10, $FF [Flow: branch]
	lda ($79.b,X)		; A1 79 ; Load accumulator ($79.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $341110.l,X		; FF 10 11 34 ; Subtract with carry (long,X) $341110.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $A5.b,X		; 34 A5 ; Test bits $A5.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $C4.b		; 00 C4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $A5.b		; A5 A5 ; Load $A5.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $11.b		; A5 11 ; Load $11.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($A5.b),Y		; 11 A5 ; OR accumulator with memory ($A5.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora [$C4.b],Y		; 17 C4 ; OR accumulator with memory (long indexed) [$C4.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($A5.b),Y		; 11 A5 ; OR accumulator with memory ($A5.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr $4E4E.w		; 4E 4E 4E ; Logical shift right $4E4E.w [Flags: NCZ]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jmp.w [$C613]		; DC 13 C6 ; Jump long indirect [$C613] [Flow: jump]
	dec $20.b		; C6 20 ; Decrement $20.b [Reads: Direct Page] [Flags: NZ]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $82, $6A, $34		; 82 6A 34 ; Branch always long to $82, $6A, $34 [Flow: branch]
	.db $30, $10		; 30 10 ; Branch if minus to $30, $10 [Flow: branch]
	cmp #$53E0.w		; C9 E0 53 ; Compare #$53E0.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $E6F1.w		; 9C F1 E6 ; Store zero to $E6F1.w
	inc $02.b		; E6 02 ; Increment $02.b [Reads: Direct Page] [Flags: NZ]
	jsl $71348A.l		; 22 8A 34 71 ; Jump to subroutine long $71348A.l [Writes: Stack Pointer] [Flow: call]
	rol $30.b,X		; 36 30 ; Rotate left $30.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $DB.b		; 00 DB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp #$3453.w		; C9 53 34 ; Compare #$3453.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $34.b,X		; 36 34 ; Rotate left $34.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	adc ($8E.b,S),Y		; 73 8E ; Add with carry (stack relative indirect indexed) ($8E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	brk $33.b		; 00 33 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($34.b),Y		; 71 34 ; Add with carry ($34.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($8D.b,X)		; E1 8D ; Subtract with carry ($8D.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($83.b,S),Y		; 73 83 ; Add with carry (stack relative indirect indexed) ($83.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and ($00.b,S),Y		; 33 00 ; AND accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $8C.b,X		; 34 8C ; Test bits $8C.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	adc ($03.b,S),Y		; 73 03 ; Add with carry (stack relative indirect indexed) ($03.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $DA.b,S		; 03 DA ; OR accumulator with stack relative $DA.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $90, $0F		; 90 0F ; Branch if carry clear to $90, $0F [Flow: branch]
	sbc ($03.b,X)		; E1 03 ; Subtract with carry ($03.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $E1		; 10 E1 ; Branch if plus to $10, $E1 [Flow: branch]
	ror $7E34.w,X		; 7E 34 7E ; Rotate right $7E34.w,X [Reads: X Index] [Flags: NCZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ror $008D.w,X		; 7E 8D 00 ; Rotate right $008D.w,X [Reads: X Index] [Flags: NCZ]
	and ($36.b,S),Y		; 33 36 ; AND accumulator (stack relative indirect indexed) ($36.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $8D90.w		; 8D 90 8D ; Store accumulator to $8D90.w [Reads: Accumulator]
	ora $33.b,S		; 03 33 ; OR accumulator with stack relative $33.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ror $3690.w,X		; 7E 90 36 ; Rotate right $3690.w,X [Reads: X Index] [Flags: NCZ]
	ror $0333.w,X		; 7E 33 03 ; Rotate right $0333.w,X [Reads: X Index] [Flags: NCZ]
	sta $908D.w		; 8D 8D 90 ; Store accumulator to $908D.w [Reads: Accumulator]
	.db $90, $33		; 90 33 ; Branch if carry clear to $90, $33 [Flow: branch]
	and ($73.b,S),Y		; 33 73 ; AND accumulator (stack relative indirect indexed) ($73.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	.db $90, $71		; 90 71 ; Branch if carry clear to $90, $71 [Flow: branch]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	.db $90, $0F		; 90 0F ; Branch if carry clear to $90, $0F [Flow: branch]
	rol $03.b,X		; 36 03 ; Rotate left $03.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	jsr $3690.w		; 20 90 36 ; Jump to subroutine at $3690.w [Writes: Stack Pointer] [Flow: call]
	.db $90, $8D		; 90 8D ; Branch if carry clear to $90, $8D [Flow: branch]
	.db $30, $33		; 30 33 ; Branch if minus to $30, $33 [Flow: branch]
	sta $36737E.l		; 8F 7E 73 36 ; Store accumulator (long) $36737E.l [Reads: Accumulator]
	and ($30.b,S),Y		; 33 30 ; AND accumulator (stack relative indirect indexed) ($30.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $909073.l,X		; 7F 73 90 90 ; Add long $909073.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($33.b,S),Y		; 33 33 ; AND accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc ($34.b),Y		; 71 34 ; Add with carry ($34.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $73.b		; A5 73 ; Load $73.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $737373.l		; 0F 73 73 73 ; OR accumulator with memory (long) $737373.l [Writes: Accumulator] [Flags: NZ]
	and $33.b,S		; 23 33 ; AND accumulator with stack relative $33.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta ($81.b)		; 92 81 ; Store accumulator (indirect) ($81.b) [Reads: Direct Page, Accumulator]
	adc $333373.l,X		; 7F 73 33 33 ; Add long $333373.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy $A5.b		; C4 A5 ; Compare $A5.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	lda $A5.b		; A5 A5 ; Load $A5.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($10.b),Y		; 11 10 ; OR accumulator with memory ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda $A4.b		; A5 A4 ; Load $A4.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr $004E.w		; 4E 4E 00 ; Logical shift right $004E.w [Flags: NCZ]
	ora ($4E.b),Y		; 11 4E ; OR accumulator with memory ($4E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	ldx $13.b,Y		; B6 13 ; Load X register $13.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	ora ($B7.b)		; 12 B7 ; OR accumulator with memory (indirect) ($B7.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $D4D1.w,Y		; B9 D1 D4 ; Load $D4D1.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $CD3100.l		; 22 00 31 CD ; Jump to subroutine long $CD3100.l [Writes: Stack Pointer] [Flow: call]
	cmp $2212D0.l		; CF D0 12 22 ; Compare accumulator (long) $2212D0.l [Reads: Accumulator] [Flags: NCZ]
	cmp $E195.w		; CD 95 E1 ; Compare $E195.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	sta $20.b,S		; 83 20 ; Store accumulator (stack relative) $20.b,S [Reads: Stack Pointer, Accumulator]
	ora ($CD.b,X)		; 01 CD ; Logical OR ($CD.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp $56D8.w		; CD D8 56 ; Compare $56D8.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsl $F8DC21.l		; 22 21 DC F8 ; Jump to subroutine long $F8DC21.l [Writes: Stack Pointer] [Flow: call]
	and ($CD.b),Y		; 31 CD ; AND accumulator with memory ($CD.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsr $CD12.w		; 20 12 CD ; Jump to subroutine at $CD12.w [Writes: Stack Pointer] [Flow: call]
	cmp $2525.w		; CD 25 25 ; Compare $2525.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsl $252533.l		; 22 33 25 25 ; Jump to subroutine long $252533.l [Writes: Stack Pointer] [Flow: call]
	eor $11336C.l		; 4F 6C 33 11 ; Exclusive OR accumulator with memory (long) $11336C.l [Writes: Accumulator] [Flags: NZ]
	and ($94.b,S),Y		; 33 94 ; AND accumulator (stack relative indirect indexed) ($94.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $35.b		; 04 35 ; Test and set bits $35.b [Reads: Accumulator] [Flags: Z]
	and $32.b,S		; 23 32 ; AND accumulator with stack relative $32.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc ($34.b),Y		; 71 34 ; Add with carry ($34.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $54.b,X		; 36 54 ; Rotate left $54.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $CD.b		; C5 CD ; Compare $CD.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp $22CE.w		; CD CE 22 ; Compare $22CE.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsl $E43434.l		; 22 34 34 E4 ; Jump to subroutine long $E43434.l [Writes: Stack Pointer] [Flow: call]
	cmp $2200.w		; CD 00 22 ; Compare $2200.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	dec $9876.w		; CE 76 98 ; Decrement $9876.w [Flags: NZ]
	ror $3321.w,X		; 7E 21 33 ; Rotate right $3321.w,X [Reads: X Index] [Flags: NCZ]
	rol $F2.b		; 26 F2 ; Rotate left $F2.b [Reads: Direct Page] [Flags: NCZ]
	sta $1125.w,Y		; 99 25 11 ; Store accumulator to $1125.w,Y [Reads: Y Index, Accumulator]
	and ($CD.b,S),Y		; 33 CD ; AND accumulator (stack relative indirect indexed) ($CD.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $56.b,X		; D5 56 ; Compare accumulator $56.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	lda #$1022.w		; A9 22 10 ; Load #$1022.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $90, $F7		; 90 F7 ; Branch if carry clear to $90, $F7 [Flow: branch]
	cmp $22CD.w		; CD CD 22 ; Compare $22CD.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsl $79A42D.l		; 22 2D A4 79 ; Jump to subroutine long $79A42D.l [Writes: Stack Pointer] [Flow: call]
	bit $10.b,X		; 34 10 ; Test bits $10.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $10, $36		; 10 36 ; Branch if plus to $10, $36 [Flow: branch]
	sta $2DCD.w,X		; 9D CD 2D ; Store accumulator to $2DCD.w,X [Reads: Accumulator, X Index]
	and $21.b,S		; 23 21 ; AND accumulator with stack relative $21.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $A7.b,X		; 34 A7 ; Test bits $A7.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	adc $0100.w,Y		; 79 00 01 ; Add $0100.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $C5ED.w,X		; 7E ED C5 ; Rotate right $C5ED.w,X [Reads: X Index] [Flags: NCZ]
	cmp $2231.w		; CD 31 22 ; Compare $2231.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp $342D.w		; CD 2D 34 ; Compare $342D.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp $3021.w,Y		; D9 21 30 ; Compare accumulator $3021.w,Y [Reads: Y Index] [Flags: NCZ]
	adc $C5ED.w,Y		; 79 ED C5 ; Add $C5ED.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $632211.l,X		; FF 11 22 63 ; Subtract with carry (long,X) $632211.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $32.b,X		; 35 32 ; Logical AND $32.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$2010.w		; C9 10 20 ; Compare #$2010.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	eor ($F2.b,X)		; 41 F2 ; Exclusive OR accumulator with memory ($F2.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	bit $79.b,X		; 34 79 ; Test bits $79.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $10, $01		; 10 01 ; Branch if plus to $10, $01 [Flow: branch]
	sty $54.b		; 84 54 ; Store Y register to $54.b [Reads: Y Index]
	sbc $213263.l,X		; FF 63 32 21 ; Subtract with carry (long,X) $213263.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($C4.b),Y		; 71 C4 ; Add with carry ($C4.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $3A.b,X		; 34 3A ; Test bits $3A.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($CE.b)		; F2 CE ; Subtract with carry (indirect) ($CE.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $B7.b,S		; 83 B7 ; Store accumulator (stack relative) $B7.b,S [Reads: Stack Pointer, Accumulator]
	cop $12.b		; 02 12 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($CD.b),Y		; D1 CD ; Compare accumulator ($CD.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cmp #$0213.w		; C9 13 02 ; Compare #$0213.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora $DC.b,S		; 03 DC ; OR accumulator with stack relative $DC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda [$C9.b],Y		; B7 C9 ; Load accumulator (long indexed) [$C9.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda [$02.b],Y		; B7 02 ; Load accumulator (long indexed) [$02.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cop $CD.b		; 02 CD ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $B756.w		; CD 56 B7 ; Compare $B756.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsl $1DDC12.l		; 22 12 DC 1D ; Jump to subroutine long $1DDC12.l [Writes: Stack Pointer] [Flow: call]
	cmp $23CD.w		; CD CD 23 ; Compare $23CD.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsl $00CDCD.l		; 22 CD CD 00 ; Jump to subroutine long $00CDCD.l [Writes: Stack Pointer] [Flow: call]
	and [$22.b]		; 27 22 ; AND accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($25.b,S),Y		; 33 25 ; AND accumulator (stack relative indirect indexed) ($25.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($A2.b,S),Y		; 33 A2 ; AND accumulator (stack relative indirect indexed) ($A2.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldy $32.b		; A4 32 ; Load $32.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	and ($D6.b,S),Y		; 33 D6 ; AND accumulator (stack relative indirect indexed) ($D6.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $33.b,X		; 35 33 ; Logical AND $33.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ror $20.b,X		; 76 20 ; Rotate right $20.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	jsr $319D.w		; 20 9D 31 ; Jump to subroutine at $319D.w [Writes: Stack Pointer] [Flow: call]
	brk $C2.b		; 00 C2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($11.b,X)		; 21 11 ; Logical AND ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $7B.b,X		; 34 7B ; Test bits $7B.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ldx $00.b		; A6 00 ; Load $00.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	ora ($9A.b,S),Y		; 13 9A ; OR accumulator (stack relative indirect indexed) ($9A.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $05.b		; A5 05 ; Load $05.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($33.b,S),Y		; 33 33 ; AND accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($36.b)		; 12 36 ; OR accumulator with memory (indirect) ($36.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	bit $35.b,X		; 34 35 ; Test bits $35.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora $33.b,S		; 03 33 ; OR accumulator with stack relative $33.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $71.b,X		; 34 71 ; Test bits $71.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $AE.b,X		; 34 AE ; Test bits $AE.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $ACAA7F.l		; AF 7F AA AC ; Load long $ACAA7F.l into accumulator [Writes: Accumulator] [Flags: NZ]
	brk $33.b		; 00 33 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	jmp ($0B36.w)		; 6C 36 0B ; Jump indirect to ($0B36.w) [Flow: jump]
	and ($01.b,S),Y		; 33 01 ; AND accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ror $B3.b,X		; 76 B3 ; Rotate right $B3.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	lda $77.b,X		; B5 77 ; Load $77.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $33.b,S		; 03 33 ; OR accumulator with stack relative $33.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $7436.w,Y		; 79 36 74 ; Add $7436.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and $30.b,X		; 35 30 ; Logical AND $30.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $95		; 30 95 ; Branch if minus to $30, $95 [Flow: branch]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	rol $00.b,X		; 36 00 ; Rotate left $00.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $30, $39		; 30 39 ; Branch if minus to $30, $39 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	adc $237F.w		; 6D 7F 23 ; Add $237F.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $C0		; 10 C0 ; Branch if plus to $10, $C0 [Flow: branch]
	bit $C2.b,X		; 34 C2 ; Test bits $C2.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and [$30.b],Y		; 37 30 ; AND accumulator with memory (long indexed) [$30.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($36.b)		; 12 36 ; OR accumulator with memory (indirect) ($36.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $1A.b,X		; 34 1A ; Test bits $1A.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	rep #$02		; C2 02 ; Reset processor status bits #$02 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	and ($05.b,X)		; 21 05 ; Logical AND ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $33.b,X		; 35 33 ; Logical AND $33.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora ($22.b)		; 12 22 ; OR accumulator with memory (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $05.b,X		; 34 05 ; Test bits $05.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and $C2.b,X		; 35 C2 ; Logical AND $C2.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($21.b,X)		; 01 21 ; Logical OR ($21.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	clc		; 18 ; Clear carry flag [Flags: C]
	and ($33.b,S),Y		; 33 33 ; AND accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $22.b,X		; 35 22 ; Logical AND $22.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $253662.l		; 22 62 36 25 ; Jump to subroutine long $253662.l [Writes: Stack Pointer] [Flow: call]
	lda ($12.b),Y		; B1 12 ; Load accumulator ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $6218E0.l		; 22 E0 18 62 ; Jump to subroutine long $6218E0.l [Writes: Stack Pointer] [Flow: call]
.ACCU 16
	rep #$22		; C2 22
	ora ($34.b,S),Y		; 13 34 ; OR accumulator (stack relative indirect indexed) ($34.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $0C.b		; E6 0C ; Increment $0C.b [Reads: Direct Page] [Flags: NZ]
	sbc $22.b		; E5 22 ; Subtract $22.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and ($9E.b)		; 32 9E ; AND accumulator with memory (indirect) ($9E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp [$C9.b]		; C7 C9 ; Compare accumulator (long) [$C9.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	wai		; CB ; Wait for interrupt
	ora $33.b,S		; 03 33 ; OR accumulator with stack relative $33.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpy $CACD.w		; CC CD CA ; Compare $CACD.w with Y register [Reads: Y Index] [Flags: NCZ]
	ror $33.b,X		; 76 33 ; Rotate right $33.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $30, $AD		; 30 AD ; Branch if minus to $30, $AD [Flow: branch]
	lda $C9.b		; A5 C9 ; Load $C9.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $30, $34		; 30 34 ; Branch if minus to $30, $34 [Flow: branch]
	bit $D2.b,X		; 34 D2 ; Test bits $D2.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cmp $00.b,X		; D5 00 ; Compare accumulator $00.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	and ($D7.b,S),Y		; 33 D7 ; AND accumulator (stack relative indirect indexed) ($D7.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $33.b,X		; 34 33 ; Test bits $33.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $30, $D9		; 30 D9 ; Branch if minus to $30, $D9 [Flow: branch]
	lda $DE.b,S		; A3 DE ; Load accumulator (stack relative) $DE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $3F3333.l,X		; DF 33 33 3F ; Compare accumulator (long,X) $3F3333.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	cpx #$76E1.w		; E0 E1 76 ; Compare #$76E1.w with X register [Reads: X Index] [Flags: NCZ]
	and $30.b,S		; 23 30 ; AND accumulator with stack relative $30.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $E8.b		; E6 E8 ; Increment $E8.b [Reads: Direct Page] [Flags: NZ]
	sbc #$3336.w		; E9 36 33 ; Subtract #$3336.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $EA		; 30 EA ; Branch if minus to $30, $EA [Flow: branch]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	pea $33D0.w		; F4 D0 33 ; Push absolute address $33D0.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	and ($D0.b,S),Y		; 33 D0 ; AND accumulator (stack relative indirect indexed) ($D0.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp #$EBF1.w		; C9 F1 EB ; Compare #$EBF1.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $30, $33		; 30 33 ; Branch if minus to $30, $33 [Flow: branch]
	nop		; EA ; No operation
	sbc [$F9.b],Y		; F7 F9 ; Subtract with carry (long indexed) [$F9.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	and ($33.b,S),Y		; 33 33 ; AND accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $C9.b,X		; 34 C9 ; Test bits $C9.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	ora $33.b,S		; 03 33 ; OR accumulator with stack relative $33.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	dec $02.b		; C6 02 ; Decrement $02.b [Reads: Direct Page] [Flags: NZ]
	and ($34.b,S),Y		; 33 34 ; AND accumulator (stack relative indirect indexed) ($34.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	.db $F0, $C9		; F0 C9 ; Branch if equal to $F0, $C9 [Flow: branch]
	mvp $07,$03		; 44 03 07 ; Move block positive $07,$03 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	mvp $CB,$43		; 44 43 CB ; Move block positive $CB,$43 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cpy $F9F6.w		; CC F6 F9 ; Compare $F9F6.w with Y register [Reads: Y Index] [Flags: NCZ]
	and ($30.b,S),Y		; 33 30 ; AND accumulator (stack relative indirect indexed) ($30.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc $0FFF.w,X		; FD FF 0F ; Subtract with carry $0FFF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $11		; 10 11 ; Branch if plus to $10, $11 [Flow: branch]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inc $44.b,X		; F6 44 ; Increment memory $44.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	and ($34.b,S),Y		; 33 34 ; AND accumulator (stack relative indirect indexed) ($34.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $1B.b,X		; F6 1B ; Increment memory $1B.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	bit $03.b,X		; 34 03 ; Test bits $03.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	trb $3433.w		; 1C 33 34 ; Test and reset bits $3433.w [Reads: Accumulator] [Flags: Z]
	cmp $CA34E1.l		; CF E1 34 CA ; Compare accumulator (long) $CA34E1.l [Reads: Accumulator] [Flags: NCZ]
	.db $30, $03		; 30 03 ; Branch if minus to $30, $03 [Flow: branch]
	and $22.b,S		; 23 22 ; AND accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc [$1C.b]		; E7 1C ; Subtract with carry (long) [$1C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	mvp $CD,$34		; 44 34 CD ; Move block positive $CD,$34 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	rol $26.b		; 26 26 ; Rotate left $26.b [Reads: Direct Page] [Flags: NCZ]
	cpy DMASRC3B.w		; CC 34 43 ; Compare DMASRC3B.w with Y register [Reads: Y Index] [Flags: NCZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $30.b,X		; 34 30 ; Test bits $30.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $0335D0.l		; CF D0 35 03 ; Compare accumulator (long) $0335D0.l [Reads: Accumulator] [Flags: NCZ]
	.db $30, $79		; 30 79 ; Branch if minus to $30, $79 [Flow: branch]
	dec $4F.b,X		; D6 4F ; Decrement memory $4F.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	cmp [$10.b],Y		; D7 10 ; Compare accumulator (long indexed) [$10.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
.ACCU 8
	sep #$AC		; E2 AC
	ldx $0000.w		; AE 00 00 ; Load $0000.w into X register [Writes: X Index] [Flags: NZ]
	ror $BE34.w,X		; 7E 34 BE ; Rotate right $BE34.w,X [Reads: X Index] [Flags: NCZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CA.b		; 00 CA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $53.b,X		; 34 53 ; Test bits $53.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sbc [$30.b],Y		; F7 30 ; Subtract with carry (long indexed) [$30.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $F9.b,S		; 03 F9 ; OR accumulator with stack relative $F9.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	cpx $332B.w		; EC 2B 33 ; Compare $332B.w with X register [Reads: X Index] [Flags: NCZ]
	tsb $DA.b		; 04 DA ; Test and set bits $DA.b [Reads: Accumulator] [Flags: Z]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	.db $F0, $C6		; F0 C6 ; Branch if equal to $F0, $C6 [Flow: branch]
	and ($03.b,S),Y		; 33 03 ; AND accumulator (stack relative indirect indexed) ($03.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $50, $C9		; 50 C9 ; Branch if overflow clear to $50, $C9 [Flow: branch]
	and ($31.b)		; 32 31 ; AND accumulator with memory (indirect) ($31.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $E1.b		; 04 E1 ; Test and set bits $E1.b [Reads: Accumulator] [Flags: Z]
	bit $35.b,X		; 34 35 ; Test bits $35.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sbc $344034.l,X		; FF 34 40 34 ; Subtract with carry (long,X) $344034.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $C9.b,X		; 34 C9 ; Test bits $C9.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $D0, $00		; D0 00 ; Branch if not equal to $D0, $00 [Flow: branch]
	and ($1C.b)		; 32 1C ; AND accumulator with memory (indirect) ($1C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $40.b,X		; 34 40 ; Test bits $40.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and ($E2.b,S),Y		; 33 E2 ; AND accumulator (stack relative indirect indexed) ($E2.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $1EF7.w,X		; 1E F7 1E ; Arithmetic shift left $1EF7.w,X [Reads: X Index] [Flags: NCZ]
	ora ($21.b,X)		; 01 21 ; Logical OR ($21.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	dec $CA.b		; C6 CA ; Decrement $CA.b [Reads: Direct Page] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	and [$33.b]		; 27 33 ; AND accumulator with memory (long) [$33.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor ($CA.b,X)		; 41 CA ; Exclusive OR accumulator with memory ($CA.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cpy $D2CD.w		; CC CD D2 ; Compare $D2CD.w with Y register [Reads: Y Index] [Flags: NCZ]
	and ($33.b,S),Y		; 33 33 ; AND accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $26.b		; 26 26 ; Rotate left $26.b [Reads: Direct Page] [Flags: NCZ]
	cmp ($F4.b)		; D2 F4 ; Compare accumulator (indirect) ($F4.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	mvp $D0,$33		; 44 33 D0 ; Move block positive $D0,$33 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cmp ($CE.b),Y		; D1 CE ; Compare accumulator ($CE.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	rol $33.b,X		; 36 33 ; Rotate left $33.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $30, $1C		; 30 1C ; Branch if minus to $30, $1C [Flow: branch]
	inc $34.b,X		; F6 34 ; Increment memory $34.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	eor $03.b,S		; 43 03 ; Exclusive OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx $34CE.w		; EC CE 34 ; Compare $34CE.w with X register [Reads: X Index] [Flags: NCZ]
	and $0403.w,Y		; 39 03 04 ; AND accumulator with memory $0403.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $F0EA.w		; 1C EA F0 ; Test and reset bits $F0EA.w [Reads: Accumulator] [Flags: Z]
	dec $0343.w		; CE 43 03 ; Decrement $0343.w [Flags: NZ]
	eor ($3E.b,S),Y		; 53 3E ; XOR accumulator (stack relative indirect indexed) ($3E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	trb $14E7.w		; 1C E7 14 ; Test and reset bits $14E7.w [Reads: Accumulator] [Flags: Z]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $C5AB.w		; CE AB C5 ; Decrement $C5AB.w [Flags: NZ]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	trb $F634.w		; 1C 34 F6 ; Test and reset bits $F634.w [Reads: Accumulator] [Flags: Z]
	dec $3340.w		; CE 40 33 ; Decrement $3340.w [Flags: NZ]
	trb $D1D0.w		; 1C D0 D1 ; Test and reset bits $D1D0.w [Reads: Accumulator] [Flags: Z]
	bit $43.b,X		; 34 43 ; Test bits $43.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $30, $34		; 30 34 ; Branch if minus to $30, $34 [Flow: branch]
	ora #$D8.b		; 09 D8 ; Logical OR #$D8.b with accumulator [Writes: Accumulator] [Flags: NZ]
	bit $30.b,X		; 34 30 ; Test bits $30.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $87.b		; 00 87 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stx $D9.b		; 86 D9 ; Store X register to $D9.b [Reads: X Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	rol $00.b,X		; 36 00 ; Rotate left $00.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $15.b		; 00 15 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stx $88.b		; 86 88 ; Store X register to $88.b [Reads: X Index]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx $D8.b		; E4 D8 ; Compare $D8.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $4F.b,X		; 76 4F ; Rotate right $4F.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cmp #$00.b		; C9 00 ; Compare #$00.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $004135.l,X		; 7F 35 41 00 ; Add long $004135.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($A8.b,X)		; 01 A8 ; Logical OR ($A8.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpx $CE.b		; E4 CE ; Compare $CE.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	bit $02.b		; 24 02 ; Test bits $02.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	and ($B5.b,X)		; 21 B5 ; Logical AND ($B5.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rol $B6.b		; 26 B6 ; Rotate left $B6.b [Reads: Direct Page] [Flags: NCZ]
	ora #$00.b		; 09 00 ; Logical OR #$00.b with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $8B.b		; 00 8B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx $3400.w,Y		; BE 00 34 ; Load X register $3400.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($CD.b)		; F2 CD ; Subtract with carry (indirect) ($CD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and $1290.w		; 2D 90 12 ; Logical AND $1290.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($CF.b)		; 12 CF ; OR accumulator with memory (indirect) ($CF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $8B.b,X		; 34 8B ; Test bits $8B.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	stz $0020.w		; 9C 20 00 ; Store zero to $0020.w
	bit $36.b,X		; 34 36 ; Test bits $36.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	brk $79.b		; 00 79 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $997C.w		; 2D 7C 99 ; Logical AND $997C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp $142D.w		; CD 2D 14 ; Compare $142D.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	asl $21.b,X		; 16 21 ; Arithmetic shift left $21.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $15.b		; 00 15 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $24D8.w		; 2D D8 24 ; Logical AND $24D8.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $A0.b		; 25 A0 ; Logical AND $A0.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $57.b,X		; 55 57 ; Exclusive OR accumulator with memory $57.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and ($44.b,S),Y		; 33 44 ; AND accumulator (stack relative indirect indexed) ($44.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	eor $5756.w,Y		; 59 56 57 ; Exclusive OR accumulator with memory $5756.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	mvp $32,$44		; 44 44 32 ; Move block positive $32,$44 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ldy $64.b		; A4 64 ; Load $64.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	mvn $44,$23		; 54 23 44 ; Move block negative $44,$23 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	adc $67.b		; 65 67 ; Add $67.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc #$54.b		; 69 54 ; Add #$54.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	mvp $6B,$44		; 44 44 6B ; Move block positive $6B,$44 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	mvn $9F,$6C		; 54 6C 9F ; Move block negative $9F,$6C [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	mvp $36,$43		; 44 43 36 ; Move block positive $36,$43 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ror $6E.b,X		; 76 6E ; Rotate right $6E.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	mvp $78,$70		; 44 70 78 ; Move block positive $78,$70 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	jmp ($4444.w,X)		; 7C 44 44 ; Jump indirect indexed to ($4444.w,X) [Reads: X Index] [Flow: jump]
	eor $9524.w,X		; 5D 24 95 ; Exclusive OR accumulator with memory $9524.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $70, $41		; 70 41 ; Branch if overflow set to $70, $41 [Flow: branch]
	tsb $81.b		; 04 81 ; Test and set bits $81.b [Reads: Accumulator] [Flags: Z]
	sta $72.b,S		; 83 72 ; Store accumulator (stack relative) $72.b,S [Reads: Stack Pointer, Accumulator]
	ror $4344.w,X		; 7E 44 43 ; Rotate right $4344.w,X [Reads: X Index] [Flags: NCZ]
	stx $906F.w		; 8E 6F 90 ; Store X register to $906F.w [Reads: X Index]
	sta ($44.b),Y		; 91 44 ; Store accumulator ($44.b),Y [Reads: Direct Page, Y Index, Accumulator]
	mvp $6E,$57		; 44 57 6E ; Move block positive $6E,$57 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sta ($7E.b,S),Y		; 93 7E ; Store accumulator (stack relative indirect indexed) ($7E.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	mvp $6B,$43		; 44 43 6B ; Move block positive $6B,$43 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	adc $449C9B.l		; 6F 9B 9C 44 ; Add with carry (long) $449C9B.l [Writes: Accumulator] [Flags: NCVZ]
	mvp $87,$9C		; 44 9C 87 ; Move block positive $87,$9C [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cmp $4244.w		; CD 44 42 ; Compare $4244.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	bit $4E.b		; 24 4E ; Test bits $4E.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sta $147E.w,X		; 9D 7E 14 ; Store accumulator to $147E.w,X [Reads: Accumulator, X Index]
	eor $84.b,S		; 43 84 ; Exclusive OR accumulator with stack relative $84.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	sta $444452.l,X		; 9F 52 44 44 ; Store accumulator (long,X) $444452.l,X [Reads: Accumulator, X Index]
	and $04.b		; 25 04 ; Logical AND $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $36.b,X		; 34 36 ; Test bits $36.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and ($00.b,S),Y		; 33 00 ; AND accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda ($5D.b,X)		; A1 5D ; Load accumulator ($5D.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $90, $1C		; 90 1C ; Branch if carry clear to $90, $1C [Flow: branch]
	mvp $34,$21		; 44 21 34 ; Move block positive $34,$21 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	bit $A2.b,X		; 34 A2 ; Test bits $A2.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	lda $00.b,S		; A3 00 ; Load accumulator (stack relative) $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	mvp $A6,$A4		; 44 A4 A6 ; Move block positive $A6,$A4 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	lda [$44.b]		; A7 44 ; Load accumulator (long) [$44.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	mvp $7E,$AE		; 44 AE 7E ; Move block positive $7E,$AE [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	.db $B0, $A7		; B0 A7 ; Branch if carry set to $B0, $A7 [Flow: branch]
	eor $44.b,S		; 43 44 ; Exclusive OR accumulator with stack relative $44.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldx $B782.w		; AE 82 B7 ; Load $B782.w into X register [Writes: X Index] [Flags: NZ]
	adc $BA4443.l		; 6F 43 44 BA ; Add with carry (long) $BA4443.l [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $BB		; F0 BB ; Branch if equal to $F0, $BB [Flow: branch]
	cmp $4240.w		; CD 40 42 ; Compare $4240.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	stz $8F34.w		; 9C 34 8F ; Store zero to $8F34.w
	.db $F0, $30		; F0 30 ; Branch if equal to $F0, $30 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	bit $BD.b,X		; 34 BD ; Test bits $BD.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cmp $0437.w		; CD 37 04 ; Compare $0437.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsl $9F8684.l		; 22 84 86 9F ; Jump to subroutine long $9F8684.l [Writes: Stack Pointer] [Flow: call]
	bit $44.b,X		; 34 44 ; Test bits $44.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	lda $C262.w,X		; BD 62 C2 ; Load $C262.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr $4444.w		; 4E 44 44 ; Logical shift right $4444.w [Flags: NCZ]
	sta $5734.w,X		; 9D 34 57 ; Store accumulator to $5734.w,X [Reads: Accumulator, X Index]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	mvp $9D,$C9		; 44 C9 9D ; Move block positive $9D,$C9 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sbc [$25.b],Y		; F7 25 ; Subtract with carry (long indexed) [$25.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	mvp $25,$23		; 44 23 25 ; Move block positive $25,$23 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	rol $CD.b		; 26 CD ; Rotate left $CD.b [Reads: Direct Page] [Flags: NCZ]
	mvn $24,$33		; 54 33 24 ; Move block negative $24,$33 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	dec $54.b		; C6 54 ; Decrement $54.b [Reads: Direct Page] [Flags: NZ]
	cmp $44449D.l		; CF 9D 44 44 ; Compare accumulator (long) $44449D.l [Reads: Accumulator] [Flags: NCZ]
	ldx $34.b		; A6 34 ; Load $34.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	eor $5C2432.l,X		; 5F 32 24 5C ; Exclusive OR accumulator with memory (long,X) $5C2432.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc ($70.b,X)		; 61 70 ; Add with carry ($70.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	mvp $9D,$44		; 44 44 9D ; Move block positive $9D,$44 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ror $70.b,X		; 76 70 ; Rotate right $70.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	adc ($40.b)		; 72 40 ; Add with carry (indirect) ($40.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	mvp $70,$82		; 44 82 70 ; Move block positive $70,$82 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sta $D4.b,X		; 95 D4 ; Store accumulator to $D4.b,X [Reads: Accumulator, X Index]
	mvp $70,$04		; 44 04 70 ; Move block positive $70,$04 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	eor [$8F.b],Y		; 57 8F ; Exclusive OR accumulator with memory (long indexed) [$8F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($44.b,X)		; C1 44 ; Compare accumulator ($44.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	mvp $D7,$35		; 44 35 D7 ; Move block positive $D7,$35 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	rol $8B.b,X		; 36 8B ; Rotate left $8B.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	stz $448F.w		; 9C 8F 44 ; Store zero to $448F.w
	mvp $34,$C4		; 44 C4 34 ; Move block positive $34,$C4 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	dec $4034.w,X		; DE 34 40 ; Decrement memory $4034.w,X [Reads: X Index] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	eor ($51.b)		; 52 51 ; Exclusive OR accumulator with memory (indirect) ($51.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	sbc $44.b,S		; E3 44 ; Subtract stack-relative $44.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	mvp $35,$36		; 44 36 35 ; Move block positive $35,$36 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
.INDEX 8
	sep #$9D		; E2 9D
	brk $42.b		; 00 42 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $5F.b		; C5 5F ; Compare $5F.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	jmp $44245C.l		; 5C 5C 24 44 ; Jump long to $44245C.l [Flow: jump]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $34.b,S		; C3 34 ; Compare accumulator (stack relative) $34.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	rol $44.b,X		; 36 44 ; Rotate left $44.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $36.b		; 00 36 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$53.b]		; E7 53 ; Subtract with carry (long) [$53.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp ($01.b),Y		; D1 01 ; Compare accumulator ($01.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	ora ($70.b)		; 12 70 ; OR accumulator with memory (indirect) ($70.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $82, $36, $44		; 82 36 44 ; Branch always long to $82, $36, $44 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	bit $36.b,X		; 34 36 ; Test bits $36.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $ED.b,X		; 34 ED ; Test bits $ED.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $30, $31		; 30 31 ; Branch if minus to $30, $31 [Flow: branch]
	sbc ($AD.b)		; F2 AD ; Subtract with carry (indirect) ($AD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	pea $4436.w		; F4 36 44 ; Push absolute address $4436.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cmp $ADF2.w		; CD F2 AD ; Compare $ADF2.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	pea $4424.w		; F4 24 44 ; Push absolute address $4424.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	lsr $00B8.w		; 4E B8 00 ; Logical shift right $00B8.w [Flags: NCZ]
	mvp $9D,$B9		; 44 B9 9D ; Move block positive $9D,$B9 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	rol $A7.b,X		; 36 A7 ; Rotate left $A7.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	mvp $6F,$04		; 44 04 6F ; Move block positive $6F,$04 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cld		; D8 ; Clear decimal flag [Flags: D]
	pea $42FA.w		; F4 FA 42 ; Push absolute address $42FA.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	mvp $4E,$FC		; 44 FC 4E ; Move block positive $4E,$FC [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sta $BF.b		; 85 BF ; Store accumulator to $BF.b [Reads: Accumulator]
	mvp $34,$44		; 44 44 34 ; Move block positive $34,$44 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	pea $FCFA.w		; F4 FA FC ; Push absolute address $FCFA.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	tsb $44.b		; 04 44 ; Test and set bits $44.b [Reads: Accumulator] [Flags: Z]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sta $44A736.l		; 8F 36 A7 44 ; Store accumulator (long) $44A736.l [Reads: Accumulator]
	tsb $36.b		; 04 36 ; Test and set bits $36.b [Reads: Accumulator] [Flags: Z]
	bit $8F.b,X		; 34 8F ; Test bits $8F.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	bit $24.b,X		; 34 24 ; Test bits $24.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($DA.b)		; 12 DA ; OR accumulator with memory (indirect) ($DA.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	mvn $00,$37		; 54 37 00 ; Move block negative $00,$37 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	jsl $4BC634.l		; 22 34 C6 4B ; Jump to subroutine long $4BC634.l [Writes: Stack Pointer] [Flow: call]
	and [$00.b],Y		; 37 00 ; AND accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($36.b)		; 12 36 ; OR accumulator with memory (indirect) ($36.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $C6.b,X		; 34 C6 ; Test bits $C6.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sbc $0200.w,Y		; F9 00 02 ; Subtract with carry $0200.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	bit $70.b,X		; 34 70 ; Test bits $70.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sta $BA1040.l,X		; 9F 40 10 BA ; Store accumulator (long,X) $BA1040.l,X [Reads: Accumulator, X Index]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jmp $5425.w		; 4C 25 54 ; Jump to $5425.w [Flow: jump]
	and $0D.b,X		; 35 0D ; Logical AND $0D.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	dec $0B.b		; C6 0B ; Decrement $0B.b [Reads: Direct Page] [Flags: NZ]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0E0C.w		; 0D 0C 0E ; Logical OR $0E0C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $345555.l		; 0F 55 55 34 ; OR accumulator with memory (long) $345555.l [Writes: Accumulator] [Flags: NZ]
	and $DB.b,X		; 35 DB ; Logical AND $DB.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cpy $00.b		; C4 00 ; Compare $00.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	dec $10.b		; C6 10 ; Decrement $10.b [Reads: Direct Page] [Flags: NZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($12.b),Y		; 11 12 ; OR accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jmp ($55E4.w,X)		; 7C E4 55 ; Jump indirect indexed to ($55E4.w,X) [Reads: X Index] [Flow: jump]
	ora ($C4.b)		; 12 C4 ; OR accumulator with memory (indirect) ($C4.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy $1A18.w		; AC 18 1A ; Load $1A18.w into Y register [Writes: Y Index] [Flags: NZ]
	.db $10, $55		; 10 55 ; Branch if plus to $10, $55 [Flow: branch]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	trb $C41E.w		; 1C 1E C4 ; Test and reset bits $C41E.w [Reads: Accumulator] [Flags: Z]
	eor $51.b,X		; 55 51 ; Exclusive OR accumulator with memory $51.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	bit $AB.b,X		; 34 AB ; Test bits $AB.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cmp $9E.b		; C5 9E ; Compare $9E.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cop $23.b		; 02 23 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $D1AC.w		; AD AC D1 ; Load $D1AC.w into accumulator [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($41.b,X)		; 21 41 ; Logical AND ($41.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $EE.b,X		; 34 EE ; Test bits $EE.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cpx $10.b		; E4 10 ; Compare $10.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($C8.b)		; 12 C8 ; OR accumulator with memory (indirect) ($C8.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $2085.w		; 20 85 20 ; Jump to subroutine at $2085.w [Writes: Stack Pointer] [Flow: call]
	ora $15.b		; 05 15 ; Logical OR $15.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $21.b,X		; 34 21 ; Test bits $21.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sbc $05D4.w,Y		; F9 D4 05 ; Subtract with carry $05D4.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $0F97DC.l		; 22 DC 97 0F ; Jump to subroutine long $0F97DC.l [Writes: Stack Pointer] [Flow: call]
	sbc $3223.w,Y		; F9 23 32 ; Subtract with carry $3223.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and [$25.b]		; 27 25 ; AND accumulator with memory (long) [$25.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $1C.b		; E5 1C ; Subtract $1C.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and ($21.b),Y		; 31 21 ; AND accumulator with memory ($21.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $34.b		; 25 34 ; Logical AND $34.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $E5.b		; 26 E5 ; Rotate left $E5.b [Reads: Direct Page] [Flags: NCZ]
	.db $10, $12		; 10 12 ; Branch if plus to $10, $12 [Flow: branch]
	and $C6A3.w		; 2D A3 C6 ; Logical AND $C6A3.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	.db $10, $01		; 10 01 ; Branch if plus to $10, $01 [Flow: branch]
	sta [$5B.b]		; 87 5B ; Store accumulator (long) [$5B.b] [Reads: Direct Page, Accumulator]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	inc $31.b		; E6 31 ; Increment $31.b [Reads: Direct Page] [Flags: NZ]
	eor ($E6.b)		; 52 E6 ; Exclusive OR accumulator with memory (indirect) ($E6.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $E6.b		; E6 E6 ; Increment $E6.b [Reads: Direct Page] [Flags: NZ]
	and [$22.b]		; 27 22 ; AND accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $28.b		; 25 28 ; Logical AND $28.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx $C926.w		; EC 26 C9 ; Compare $C926.w with X register [Reads: X Index] [Flags: NCZ]
	eor ($50.b)		; 52 50 ; Exclusive OR accumulator with memory (indirect) ($50.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$C9.b		; C9 C9 ; Compare #$C9.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp #$30.b		; C9 30 ; Compare #$30.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $E6.b,X		; 34 E6 ; Test bits $E6.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and #$29.b		; 29 29 ; Logical AND #$29.b with accumulator [Writes: Accumulator] [Flags: NZ]
	eor ($33.b)		; 52 33 ; Exclusive OR accumulator with memory (indirect) ($33.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $E6.b		; E6 E6 ; Increment $E6.b [Reads: Direct Page] [Flags: NZ]
	inc $30.b		; E6 30 ; Increment $30.b [Reads: Direct Page] [Flags: NZ]
	jsl $FEED25.l		; 22 25 ED FE ; Jump to subroutine long $FEED25.l [Writes: Stack Pointer] [Flow: call]
	cpx $22E6.w		; EC E6 22 ; Compare $22E6.w with X register [Reads: X Index] [Flags: NCZ]
	jsl $E6E63B.l		; 22 3B E6 E6 ; Jump to subroutine long $E6E63B.l [Writes: Stack Pointer] [Flow: call]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	eor ($25.b)		; 52 25 ; Exclusive OR accumulator with memory (indirect) ($25.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $3A.b		; E6 3A ; Increment $3A.b [Reads: Direct Page] [Flags: NZ]
	inc $252C.w,X		; FE 2C 25 ; Increment memory $252C.w,X [Reads: X Index] [Flags: NZ]
	and $E6.b		; 25 E6 ; Logical AND $E6.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$C9.b		; C9 C9 ; Compare #$C9.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr $EE05.w		; 20 05 EE ; Jump to subroutine at $EE05.w [Writes: Stack Pointer] [Flow: call]
	.db $42, $3A		; 42 3A ; Reserved instruction
	mvp $55,$25		; 44 25 55 ; Move block positive $55,$25 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	lsr $EC.b		; 46 EC ; Logical shift right $EC.b [Reads: Direct Page] [Flags: NCZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	eor [$52.b]		; 47 52 ; Exclusive OR accumulator with memory (long) [$52.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $28.b,X		; 55 28 ; Exclusive OR accumulator with memory $28.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	inc $29.b		; E6 29 ; Increment $29.b [Reads: Direct Page] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	eor ($35.b)		; 52 35 ; Exclusive OR accumulator with memory (indirect) ($35.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	mvn $55,$4A		; 54 4A 55 ; Move block negative $55,$4A [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	eor $FE.b,X		; 55 FE ; Exclusive OR accumulator with memory $FE.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	inc $2558.w,X		; FE 58 25 ; Increment memory $2558.w,X [Reads: X Index] [Flags: NZ]
	and $29.b		; 25 29 ; Logical AND $29.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and #$3A.b		; 29 3A ; Logical AND #$3A.b with accumulator [Writes: Accumulator] [Flags: NZ]
	and $35.b,X		; 35 35 ; Logical AND $35.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	.db $62, $55, $55		; 62 55 55 ; Push effective relative address $62, $55, $55 [Writes: Stack Pointer]
	inc $E6FE.w,X		; FE FE E6 ; Increment memory $E6FE.w,X [Reads: X Index] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	jsl $666325.l		; 22 25 63 66 ; Jump to subroutine long $666325.l [Writes: Stack Pointer] [Flow: call]
	eor ($3A.b,X)		; 41 3A ; Exclusive OR accumulator with memory ($3A.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor $55.b,X		; 55 55 ; Exclusive OR accumulator with memory $55.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	inc $296A.w,X		; FE 6A 29 ; Increment memory $296A.w,X [Reads: X Index] [Flags: NZ]
	.db $70, $25		; 70 25 ; Branch if overflow set to $70, $25 [Flow: branch]
	and $6D.b,X		; 35 6D ; Logical AND $6D.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($E6.b,S),Y		; 53 E6 ; XOR accumulator (stack relative indirect indexed) ($E6.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc ($55.b),Y		; 71 55 ; Add with carry ($55.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and $FE.b		; 25 FE ; Logical AND $FE.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $E6.b		; E6 E6 ; Increment $E6.b [Reads: Direct Page] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	jsl $4F4F25.l		; 22 25 4F 4F ; Jump to subroutine long $4F4F25.l [Writes: Stack Pointer] [Flow: call]
	eor $55554F.l		; 4F 4F 55 55 ; Exclusive OR accumulator with memory (long) $55554F.l [Writes: Accumulator] [Flags: NZ]
	eor $3A2C73.l		; 4F 73 2C 3A ; Exclusive OR accumulator with memory (long) $3A2C73.l [Writes: Accumulator] [Flags: NZ]
	eor $55.b,X		; 55 55 ; Exclusive OR accumulator with memory $55.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	inc $3B.b		; E6 3B ; Increment $3B.b [Reads: Direct Page] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	eor ($55.b)		; 52 55 ; Exclusive OR accumulator with memory (indirect) ($55.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx $4F4F.w		; EC 4F 4F ; Compare $4F4F.w with X register [Reads: X Index] [Flags: NCZ]
	eor ($25.b),Y		; 51 25 ; Exclusive OR accumulator with memory ($25.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $E6.b,X		; 55 E6 ; Exclusive OR accumulator with memory $E6.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $23EC.w,Y		; 19 EC 23 ; OR accumulator with memory $23EC.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($E6.b)		; 32 E6 ; AND accumulator with memory (indirect) ($E6.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx $282A.w		; EC 2A 28 ; Compare $282A.w with X register [Reads: X Index] [Flags: NCZ]
	jsl $AB3955.l		; 22 55 39 AB ; Jump to subroutine long $AB3955.l [Writes: Stack Pointer] [Flow: call]
	trb $505B.w		; 1C 5B 50 ; Test and reset bits $505B.w [Reads: Accumulator] [Flags: Z]
	and ($26.b,X)		; 21 26 ; Logical AND ($26.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp #$C9.b		; C9 C9 ; Compare #$C9.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	eor ($50.b,X)		; 41 50 ; Exclusive OR accumulator with memory ($50.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $E6.b		; 05 E6 ; Logical OR $E6.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp ($53.b),Y		; D1 53 ; Compare accumulator ($53.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	bit $20.b,X		; 34 20 ; Test bits $20.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora $7D.b,X		; 15 7D ; OR accumulator with memory $7D.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sta [$7E.b]		; 87 7E ; Store accumulator (long) [$7E.b] [Reads: Direct Page, Accumulator]
	adc $7F5553.l,X		; 7F 53 55 7F ; Add long $7F5553.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($82.b,X)		; 81 82 ; Store accumulator ($82.b,X) [Reads: Direct Page, Accumulator, X Index]
	sta $55.b,S		; 83 55 ; Store accumulator (stack relative) $55.b,S [Reads: Stack Pointer, Accumulator]
	eor $42.b,X		; 55 42 ; Exclusive OR accumulator with memory $42.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	inc $FE.b		; E6 FE ; Increment $FE.b [Reads: Direct Page] [Flags: NZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	eor ($25.b)		; 52 25 ; Exclusive OR accumulator with memory (indirect) ($25.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sty $8C.b		; 84 8C ; Store Y register to $8C.b [Reads: Y Index]
	stx $558D.w		; 8E 8D 55 ; Store X register to $558D.w [Reads: X Index]
	eor $8C.b,X		; 55 8C ; Exclusive OR accumulator with memory $8C.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sty $EC8C.w		; 8C 8C EC ; Store Y register to $EC8C.w [Reads: Y Index]
	eor $52.b,X		; 55 52 ; Exclusive OR accumulator with memory $52.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	inc $39.b		; E6 39 ; Increment $39.b [Reads: Direct Page] [Flags: NZ]
	.db $90, $91		; 90 91 ; Branch if carry clear to $90, $91 [Flow: branch]
	and $55.b		; 25 55 ; Logical AND $55.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $916D.w		; 6D 6D 91 ; Add $916D.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta ($55.b),Y		; 91 55 ; Store accumulator ($55.b),Y [Reads: Direct Page, Y Index, Accumulator]
	eor $9B.b,X		; 55 9B ; Exclusive OR accumulator with memory $9B.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sta $729F.w,X		; 9D 9F 72 ; Store accumulator to $729F.w,X [Reads: Accumulator, X Index]
	eor $55.b,X		; 55 55 ; Exclusive OR accumulator with memory $55.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $90, $6D		; 90 6D ; Branch if carry clear to $90, $6D [Flow: branch]
	adc $5555.w		; 6D 55 55 ; Add $5555.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	lda ($A1.b,X)		; A1 A1 ; Load accumulator ($A1.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc $556D.w		; 6D 6D 55 ; Add $556D.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	eor $84.b,X		; 55 84 ; Exclusive OR accumulator with memory $84.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cpy $C4.b		; C4 C4 ; Compare $C4.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	adc $0550.w		; 6D 50 05 ; Add $0550.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	adc $6D6D.w		; 6D 6D 6D ; Add $6D6D.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	adc $5555.w		; 6D 55 55 ; Add $5555.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	adc $C479.w		; 6D 79 C4 ; Add $C479.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	bit $0555.w		; 2C 55 05 ; Test bits $0555.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	ldy $A5.b		; A4 A5 ; Load $A5.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	and ($A6.b),Y		; 31 A6 ; AND accumulator with memory ($A6.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $55.b,X		; 55 55 ; Exclusive OR accumulator with memory $55.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc $A76D.w		; 6D 6D A7 ; Add $A76D.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$55.b		; C9 55 ; Compare #$55.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $50, $8B		; 50 8B ; Branch if overflow clear to $50, $8B [Flow: branch]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	cmp #$C9.b		; C9 C9 ; Compare #$C9.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	eor $00.b,X		; 55 00 ; Exclusive OR accumulator with memory $00.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and ($33.b,S),Y		; 33 33 ; AND accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp #$C9.b		; C9 C9 ; Compare #$C9.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	eor $00.b,X		; 55 00 ; Exclusive OR accumulator with memory $00.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and ($6D.b)		; 32 6D ; AND accumulator with memory (indirect) ($6D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $5538.w		; 6D 38 55 ; Add $5538.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	eor $38.b,X		; 55 38 ; Exclusive OR accumulator with memory $38.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc $E5FE.w		; 6D FE E5 ; Add $E5FE.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	eor $22.b,X		; 55 22 ; Exclusive OR accumulator with memory $22.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	adc $2AC4.w		; 6D C4 2A ; Add $2AC4.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	eor $05.b,X		; 55 05 ; Exclusive OR accumulator with memory $05.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	rol $C9C9.w,X		; 3E C9 C9 ; Rotate left $C9C9.w,X [Reads: X Index] [Flags: NCZ]
	eor $50.b,S		; 43 50 ; Exclusive OR accumulator with stack relative $50.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $43.b		; 05 43 ; Logical OR $43.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	cmp #$38.b		; C9 38 ; Compare #$38.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	eor $05.b,X		; 55 05 ; Exclusive OR accumulator with memory $05.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $2E2D.w,Y		; 39 2D 2E ; AND accumulator with memory $2E2D.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($55.b),Y		; 31 55 ; AND accumulator with memory ($55.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $3B.b,X		; 55 3B ; Exclusive OR accumulator with memory $3B.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	eor $55.b,X		; 55 55 ; Exclusive OR accumulator with memory $55.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and ($28.b)		; 32 28 ; AND accumulator with memory (indirect) ($28.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $552A.w,Y		; 79 2A 55 ; Add $552A.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $E6.b,X		; 55 E6 ; Exclusive OR accumulator with memory $E6.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and [$37.b],Y		; 37 37 ; AND accumulator with memory (long indexed) [$37.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $5525.w,Y		; 39 25 55 ; AND accumulator with memory $5525.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $41.b,X		; 34 41 ; Test bits $41.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and ($C4.b,S),Y		; 33 C4 ; AND accumulator (stack relative indirect indexed) ($C4.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $50.b,X		; 55 50 ; Exclusive OR accumulator with memory $50.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	and #$C9.b		; 29 C9 ; Logical AND #$C9.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $30, $55		; 30 55 ; Branch if minus to $30, $55 [Flow: branch]
	ora $29.b		; 05 29 ; Logical OR $29.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $38.b		; E6 38 ; Increment $38.b [Reads: Direct Page] [Flags: NZ]
	inc $52.b		; E6 52 ; Increment $52.b [Reads: Direct Page] [Flags: NZ]
	eor ($2A.b)		; 52 2A ; Exclusive OR accumulator with memory (indirect) ($2A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	inc $55.b,X		; F6 55 ; Increment memory $55.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	eor ($36.b,S),Y		; 53 36 ; XOR accumulator (stack relative indirect indexed) ($36.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp ($D2.b)		; D2 D2 ; Compare accumulator (indirect) ($D2.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	and ($D0.b,S),Y		; 33 D0 ; AND accumulator (stack relative indirect indexed) ($D0.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $33ACD0.l		; CF D0 AC 33 ; Compare accumulator (long) $33ACD0.l [Reads: Accumulator] [Flags: NCZ]
	and $AE.b,X		; 35 AE ; Logical AND $AE.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lda $55B1EC.l		; AF EC B1 55 ; Load long $55B1EC.l into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $B3.b		; 05 B3 ; Logical OR $B3.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda [$ED.b],Y		; B7 ED ; Load accumulator (long indexed) [$ED.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $55		; F0 55 ; Branch if equal to $F0, $55 [Flow: branch]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $442734.l,X		; 1F 34 27 44 ; Logical OR long $442734.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $BD.b		; 04 BD ; Test and set bits $BD.b [Reads: Accumulator] [Flags: Z]
	lda $55C2BE.l,X		; BF BE C2 55 ; Load long $55C2BE.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $FF.b,X		; 55 FF ; Exclusive OR accumulator with memory $FF.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	dec $03.b		; C6 03 ; Decrement $03.b [Reads: Direct Page] [Flags: NZ]
	and ($C6.b,S),Y		; 33 C6 ; AND accumulator (stack relative indirect indexed) ($C6.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $14.b,X		; 34 14 ; Test bits $14.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $30.b,X		; 34 30 ; Test bits $30.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	bit $D1.b,X		; 34 D1 ; Test bits $D1.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	rol $D0.b,X		; 36 D0 ; Rotate left $D0.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	wai		; CB ; Wait for interrupt
	cpy $E9EB.w		; CC EB E9 ; Compare $E9EB.w with Y register [Reads: Y Index] [Flags: NCZ]
	and ($33.b,S),Y		; 33 33 ; AND accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc #$E9.b		; E9 E9 ; Subtract #$E9.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cmp $36.b		; C5 36 ; Compare $36.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	and ($50.b,S),Y		; 33 50 ; AND accumulator (stack relative indirect indexed) ($50.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $EB.b,X		; 36 EB ; Rotate left $EB.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	stz $039F.w,X		; 9E 9F 03 ; Store zero to $039F.w,X [Reads: X Index]
	brk $ED.b		; 00 ED ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $7FF0.w		; EE F0 7F ; Increment $7FF0.w [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	nop		; EA ; No operation
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lda #$C6.b		; A9 C6 ; Load #$C6.b into accumulator [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $FC.b,X		; 34 FC ; Test bits $FC.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ror $F4.b,X		; 76 F4 ; Rotate right $F4.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $26.b,X		; B5 26 ; Load $26.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc $0000.w,Y		; 79 00 00 ; Add $0000.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $34.b,X		; 95 34 ; Store accumulator to $34.b,X [Reads: Accumulator, X Index]
	bit $7C.b,X		; 34 7C ; Test bits $7C.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($66.b)		; F2 66 ; Subtract with carry (indirect) ($66.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	trb $01.b		; 14 01 ; Test and reset bits $01.b [Reads: Accumulator] [Flags: Z]
	jsr $E9E9.w		; 20 E9 E9 ; Jump to subroutine at $E9E9.w [Writes: Stack Pointer] [Flow: call]
	sbc #$C6.b		; E9 C6 ; Subtract #$C6.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	and ($30.b,S),Y		; 33 30 ; AND accumulator (stack relative indirect indexed) ($30.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $85.b		; 85 85 ; Store accumulator to $85.b [Reads: Accumulator]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	ldx $33.b,Y		; B6 33 ; Load X register $33.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	.db $10, $26		; 10 26 ; Branch if plus to $10, $26 [Flow: branch]
	ora [$78.b]		; 07 78 ; OR accumulator with memory (long) [$78.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	brk $B6.b		; 00 B6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	cmp ($D2.b)		; D2 D2 ; Compare accumulator (indirect) ($D2.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp ($13.b)		; D2 13 ; Compare accumulator (indirect) ($13.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	and ($CA.b,S),Y		; 33 CA ; AND accumulator (stack relative indirect indexed) ($CA.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp #$CE.b		; C9 CE ; Compare #$CE.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	sbc $33.b,X		; F5 33 ; Subtract $33.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($CA.b,S),Y		; 33 CA ; AND accumulator (stack relative indirect indexed) ($CA.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc [$34.b]		; E7 34 ; Subtract with carry (long) [$34.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	bit $33.b,X		; 34 33 ; Test bits $33.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and ($CE.b,S),Y		; 33 CE ; AND accumulator (stack relative indirect indexed) ($CE.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $AD.b,X		; 36 AD ; Rotate left $AD.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ldx $5530.w		; AE 30 55 ; Load $5530.w into X register [Writes: X Index] [Flags: NZ]
	.db $B0, $F6		; B0 F6 ; Branch if carry set to $B0, $F6 [Flow: branch]
	cmp $5553D1.l		; CF D1 53 55 ; Compare accumulator (long) $5553D1.l [Reads: Accumulator] [Flags: NCZ]
	lda $9D.b,X		; B5 9D ; Load $9D.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	dec $5236.w		; CE 36 52 ; Decrement $5236.w [Flags: NZ]
	.db $30, $B9		; 30 B9 ; Branch if minus to $30, $B9 [Flow: branch]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	ldy $55F6.w,X		; BC F6 55 ; Load Y register $55F6.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	eor ($BE.b,S),Y		; 53 BE ; XOR accumulator (stack relative indirect indexed) ($BE.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpy #$C1.b		; C0 C1 ; Compare #$C1.b with Y register [Reads: Y Index] [Flags: NCZ]
	rol $55.b,X		; 36 55 ; Rotate left $55.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $50, $FA		; 50 FA ; Branch if overflow clear to $50, $FA [Flow: branch]
	jsr ($F6FE.w,X)		; FC FE F6 ; Jump to subroutine indirect indexed ($F6FE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $15.b,X		; 36 15 ; Rotate left $15.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	rol $CE.b,X		; 36 CE ; Rotate left $CE.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	and [$CE.b]		; 27 CE ; AND accumulator with memory (long) [$CE.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and [$42.b]		; 27 42 ; AND accumulator with memory (long) [$42.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($44.b,S),Y		; 13 44 ; OR accumulator (stack relative indirect indexed) ($44.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $0A.b,S		; 43 0A ; Exclusive OR accumulator with stack relative $0A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	dec $41.b		; C6 41 ; Decrement $41.b [Reads: Direct Page] [Flags: NZ]
	and ($C6.b,S),Y		; 33 C6 ; AND accumulator (stack relative indirect indexed) ($C6.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $CA.b		; C6 CA ; Decrement $CA.b [Reads: Direct Page] [Flags: NZ]
	dec $33.b		; C6 33 ; Decrement $33.b [Reads: Direct Page] [Flags: NZ]
	and ($C6.b,S),Y		; 33 C6 ; AND accumulator (stack relative indirect indexed) ($C6.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $CA.b		; C6 CA ; Decrement $CA.b [Reads: Direct Page] [Flags: NZ]
	cpy $3333.w		; CC 33 33 ; Compare $3333.w with Y register [Reads: Y Index] [Flags: NCZ]
	rol $CD.b		; 26 CD ; Rotate left $CD.b [Reads: Direct Page] [Flags: NCZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	rol $43.b		; 26 43 ; Rotate left $43.b [Reads: Direct Page] [Flags: NCZ]
	bit $F2.b,X		; 34 F2 ; Test bits $F2.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	dec $AC36.w		; CE 36 AC ; Decrement $AC36.w [Flags: NZ]
	ora ($05.b,S),Y		; 13 05 ; OR accumulator (stack relative indirect indexed) ($05.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp ($AF.b,S),Y		; D3 AF ; Compare accumulator (stack relative indirect indexed) ($AF.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	cpx $5536.w		; EC 36 55 ; Compare $5536.w with X register [Reads: X Index] [Flags: NCZ]
	brk $CE.b		; 00 CE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $3026CE.l,X		; 7F CE 26 30 ; Add long $3026CE.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($CE.b),Y		; 31 CE ; AND accumulator with memory ($CE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda ($B3.b),Y		; B1 B3 ; Load accumulator ($B3.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ldy $35.b,X		; B4 35 ; Load Y register $35.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	eor $34.b,X		; 55 34 ; Exclusive OR accumulator with memory $34.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sbc [$CE.b]		; E7 CE ; Subtract with carry (long) [$CE.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ror $33.b,X		; 76 33 ; Rotate right $33.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $30, $CA		; 30 CA ; Branch if minus to $30, $CA [Flow: branch]
	dec $CED7.w		; CE D7 CE ; Decrement $CED7.w [Flags: NZ]
	and ($53.b,S),Y		; 33 53 ; AND accumulator (stack relative indirect indexed) ($53.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $CE.b,X		; 95 CE ; Store accumulator to $CE.b,X [Reads: Accumulator, X Index]
	lda $5303C6.l,X		; BF C6 03 53 ; Load long $5303C6.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda $26.b,X		; B5 26 ; Load $26.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	bit $E9.b,X		; 34 E9 ; Test bits $E9.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc #$E9.b		; E9 E9 ; Subtract #$E9.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sbc #$C4.b		; E9 C4 ; Subtract #$C4.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	and ($35.b,S),Y		; 33 35 ; AND accumulator (stack relative indirect indexed) ($35.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
.ACCU 8
	sep #$E4		; E2 E4
	inc $78.b		; E6 78 ; Increment $78.b [Reads: Direct Page] [Flags: NZ]
	eor $50.b,X		; 55 50 ; Exclusive OR accumulator with memory $50.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	bit $7C.b,X		; 34 7C ; Test bits $7C.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ldx $79.b,Y		; B6 79 ; Load X register $79.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpy $76.b		; C4 76 ; Compare $76.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	sty $95.b,X		; 94 95 ; Store Y register $95.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sbc $0534C4.l		; EF C4 34 05 ; Subtract with carry (long) $0534C4.l [Writes: Accumulator] [Flags: NCVZ]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $6C.b,X		; F6 6C ; Increment memory $6C.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda [$34.b]		; A7 34 ; Load accumulator (long) [$34.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $22.b,X		; 15 22 ; OR accumulator with memory $22.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $44		; 30 44 ; Branch if minus to $30, $44 [Flow: branch]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sbc $A2.b,S		; E3 A2 ; Subtract stack-relative $A2.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	cmp $763300.l,X		; DF 00 33 76 ; Compare accumulator (long,X) $763300.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	bit $F6.b,X		; 34 F6 ; Test bits $F6.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($51.b,S),Y		; 13 51 ; OR accumulator (stack relative indirect indexed) ($51.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $CD.b,S		; E3 CD ; Subtract stack-relative $CD.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	and $0234.w		; 2D 34 02 ; Logical AND $0234.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $10, $76		; 10 76 ; Branch if plus to $10, $76 [Flow: branch]
	sbc ($DF.b)		; F2 DF ; Subtract with carry (indirect) ($DF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	brk $CD.b		; 00 CD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $95.b		; A5 95 ; Load $95.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $23.b,X		; 34 23 ; Test bits $23.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora $9E.b,S		; 03 9E ; OR accumulator with stack relative $9E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $0134E3.l,X		; FF E3 34 01 ; Subtract with carry (long,X) $0134E3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $9E		; 30 9E ; Branch if minus to $30, $9E [Flow: branch]
	sta $00A5A3.l,X		; 9F A3 A5 00 ; Store accumulator (long,X) $00A5A3.l,X [Reads: Accumulator, X Index]
	ora ($A4.b,X)		; 01 A4 ; Logical OR ($A4.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $C6.b,X		; 34 C6 ; Test bits $C6.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ldy $00.b		; A4 00 ; Load $00.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	.db $30, $A5		; 30 A5 ; Branch if minus to $30, $A5 [Flow: branch]
	ldx $34.b		; A6 34 ; Load $34.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	and $00.b,X		; 35 00 ; Logical AND $00.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cmp #$00.b		; C9 00 ; Compare #$00.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora $9D.b		; 05 9D ; Logical OR $9D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ldx $23.b,Y		; B6 23 ; Load X register $23.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $789D.w,Y		; 79 9D 78 ; Add $789D.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $B6.b		; 26 B6 ; Rotate left $B6.b [Reads: Direct Page] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $78		; 10 78 ; Branch if plus to $10, $78 [Flow: branch]
	adc [$78.b],Y		; 77 78 ; Add with carry (long indexed) [$78.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	brk $B6.b		; 00 B6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $B4.b		; 00 B4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FCFB.w,Y		; F9 FB FC ; Subtract with carry $FCFB.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $55.b		; 45 55 ; Exclusive OR $55.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror $7070.w		; 6E 70 70 ; Rotate right $7070.w [Flags: NCZ]
	.db $70, $44		; 70 44 ; Branch if overflow set to $70, $44 [Flow: branch]
	mvp $01,$FF		; 44 FF 01 ; Move block positive $01,$FF [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	bit $74.b,X		; 34 74 ; Test bits $74.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	lsr $04.b,X		; 56 04 ; Logical shift right $04.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	eor [$05.b],Y		; 57 05 ; Exclusive OR accumulator with memory (long indexed) [$05.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $464606.l		; 6F 06 46 46 ; Add with carry (long) $464606.l [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	bit $54.b,X		; 34 54 ; Test bits $54.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	mvp $9D,$9E		; 44 9E 9D ; Move block positive $9D,$9E [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ldx $44D6.w		; AE D6 44 ; Load $44D6.w into X register [Writes: X Index] [Flags: NZ]
	.db $42, $71		; 42 71 ; Reserved instruction
	jmp $0476C3.l		; 5C C3 76 04 ; Jump long to $0476C3.l [Flow: jump]
	eor ($A7.b,X)		; 41 A7 ; Exclusive OR accumulator with memory ($A7.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	bit $36.b,X		; 34 36 ; Test bits $36.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $30.b,X		; 34 30 ; Test bits $30.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda [$0D.b]		; A7 0D ; Load accumulator (long) [$0D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $04.b,X		; D5 04 ; Compare accumulator $04.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $62, $76, $6C		; 62 76 6C ; Push effective relative address $62, $76, $6C [Writes: Stack Pointer]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	ora ($66.b),Y		; 11 66 ; OR accumulator with memory ($66.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $1125.w		; CD 25 11 ; Compare $1125.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora ($23.b,S),Y		; 13 23 ; OR accumulator (stack relative indirect indexed) ($23.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ror $08.b		; 66 08 ; Rotate right $08.b [Reads: Direct Page] [Flags: NCZ]
	rol $34.b,X		; 36 34 ; Rotate left $34.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ror $0310.w,X		; 7E 10 03 ; Rotate right $0310.w,X [Reads: X Index] [Flags: NCZ]
	ror $26B5.w,X		; 7E B5 26 ; Rotate right $26B5.w,X [Reads: X Index] [Flags: NCZ]
	ldx $30.b,Y		; B6 30 ; Load X register $30.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx $78.b,Y		; B6 78 ; Load X register $78.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $35.b,X		; F6 35 ; Increment memory $35.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	adc ($F2.b),Y		; 71 F2 ; Add with carry ($F2.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	tsb $AD.b		; 04 AD ; Test and set bits $AD.b [Reads: Accumulator] [Flags: Z]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sta $4445B6.l		; 8F B6 45 44 ; Store accumulator (long) $4445B6.l [Reads: Accumulator]
	cmp $1701.w		; CD 01 17 ; Compare $1701.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ror $6426.w		; 6E 26 64 ; Rotate right $6426.w [Flags: NCZ]
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	asl $441B.w,X		; 1E 1B 44 ; Arithmetic shift left $441B.w,X [Reads: X Index] [Flags: NCZ]
	asl $8F.b,X		; 16 8F ; Arithmetic shift left $8F.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	eor [$35.b],Y		; 57 35 ; Exclusive OR accumulator with memory (long indexed) [$35.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $3144.w,X		; 1E 44 31 ; Arithmetic shift left $3144.w,X [Reads: X Index] [Flags: NCZ]
	.db $90, $F2		; 90 F2 ; Branch if carry clear to $90, $F2 [Flow: branch]
	lda $249F.w		; AD 9F 24 ; Load $249F.w into accumulator [Writes: Accumulator] [Flags: NZ]
	mvp $6D,$54		; 44 54 6D ; Move block positive $6D,$54 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	bit $F2.b,X		; 34 F2 ; Test bits $F2.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	eor $04.b,S		; 43 04 ; Exclusive OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $6179.w		; AD 79 61 ; Load $6179.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $44		; F0 44 ; Branch if equal to $F0, $44 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

.INDEX 8
	sep #$1E		; E2 1E
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	lda $1446.w		; AD 46 14 ; Load $1446.w into accumulator [Writes: Accumulator] [Flags: NZ]
.ACCU 8
	sep #$E2		; E2 E2
.ACCU 8
	sep #$E2		; E2 E2
	mvp $E2,$44		; 44 44 E2 ; Move block positive $E2,$44 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
.ACCU 8
	sep #$E2		; E2 E2
	asl $4644.w,X		; 1E 44 46 ; Arithmetic shift left $4644.w,X [Reads: X Index] [Flags: NCZ]
	eor $986CAD.l		; 4F AD 6C 98 ; Exclusive OR accumulator with memory (long) $986CAD.l [Writes: Accumulator] [Flags: NZ]
	trb $13.b		; 14 13 ; Test and reset bits $13.b [Reads: Accumulator] [Flags: Z]
	eor ($AD.b,S),Y		; 53 AD ; XOR accumulator (stack relative indirect indexed) ($AD.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $20.b,X		; D6 20 ; Decrement memory $20.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	trb $26.b		; 14 26 ; Test and reset bits $26.b [Reads: Accumulator] [Flags: Z]
	lda ($A3.b,X)		; A1 A3 ; Load accumulator ($A3.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $1133F0.l,X		; FF F0 33 11 ; Subtract with carry (long,X) $1133F0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $21369F.l,X		; 9F 9F 36 21 ; Store accumulator (long,X) $21369F.l,X [Reads: Accumulator, X Index]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $B6.b		; 26 B6 ; Rotate left $B6.b [Reads: Direct Page] [Flags: NCZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	adc $0000.w,Y		; 79 00 00 ; Add $0000.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $A9.b,X		; 36 A9 ; Rotate left $A9.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	rol $36.b,X		; 36 36 ; Rotate left $36.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvn $AD,$34		; 54 34 AD ; Move block negative $AD,$34 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $A900.w		; 20 00 A9 ; Jump to subroutine at $A900.w [Writes: Stack Pointer] [Flow: call]
	inc $E6.b		; E6 E6 ; Increment $E6.b [Reads: Direct Page] [Flags: NZ]
	sta [$02.b]		; 87 02 ; Store accumulator (long) [$02.b] [Reads: Direct Page, Accumulator]
	and $87.b,S		; 23 87 ; AND accumulator with stack relative $87.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $A6.b		; E6 A6 ; Increment $A6.b [Reads: Direct Page] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($55.b)		; 32 55 ; AND accumulator with memory (indirect) ($55.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($2A.b)		; 32 2A ; AND accumulator with memory (indirect) ($2A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $3A.b		; E6 3A ; Increment $3A.b [Reads: Direct Page] [Flags: NZ]
	eor $25.b,X		; 55 25 ; Exclusive OR accumulator with memory $25.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	inc $E6.b		; E6 E6 ; Increment $E6.b [Reads: Direct Page] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	jsl $3B2A55.l		; 22 55 2A 3B ; Jump to subroutine long $3B2A55.l [Writes: Stack Pointer] [Flow: call]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	and $55.b,X		; 35 55 ; Logical AND $55.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor $32.b,X		; 55 32 ; Exclusive OR accumulator with memory $32.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ldx $35.b		; A6 35 ; Load $35.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	and ($55.b)		; 32 55 ; AND accumulator with memory (indirect) ($55.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $E6.b,X		; 55 E6 ; Exclusive OR accumulator with memory $E6.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and ($29.b)		; 32 29 ; AND accumulator with memory (indirect) ($29.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $3525.w		; 2D 25 35 ; Logical AND $3525.w with accumulator [Writes: Accumulator] [Flags: NZ]
	rol $2F2F.w		; 2E 2F 2F ; Rotate left $2F2F.w [Flags: NCZ]
	and $5555.w		; 2D 55 55 ; Logical AND $5555.w with accumulator [Writes: Accumulator] [Flags: NZ]
	bit $2FF4.w		; 2C F4 2F ; Test bits $2FF4.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	and $3D5552.l		; 2F 52 55 3D ; AND accumulator with memory (long) $3D5552.l [Writes: Accumulator] [Flags: NZ]
	and ($33.b,S),Y		; 33 33 ; AND accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$5055]		; DC 55 50 ; Jump long indirect [$5055] [Flow: jump]
	and ($87.b,S),Y		; 33 87 ; AND accumulator (stack relative indirect indexed) ($87.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $3C.b		; E6 3C ; Increment $3C.b [Reads: Direct Page] [Flags: NZ]
	eor ($25.b,S),Y		; 53 25 ; XOR accumulator (stack relative indirect indexed) ($25.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and [$33.b]		; 27 33 ; AND accumulator with memory (long) [$33.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $E6.b,X		; 36 E6 ; Rotate left $E6.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	eor $52.b,X		; 55 52 ; Exclusive OR accumulator with memory $52.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	inc $3A.b		; E6 3A ; Increment $3A.b [Reads: Direct Page] [Flags: NZ]
	bit $25.b		; 24 25 ; Test bits $25.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	and $66.b		; 25 66 ; Logical AND $66.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and [$29.b]		; 27 29 ; AND accumulator with memory (long) [$29.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	dec $6066.w		; CE 66 60 ; Decrement $6066.w [Flags: NZ]
	inc $2A.b		; E6 2A ; Increment $2A.b [Reads: Direct Page] [Flags: NZ]
	cpy $2531.w		; CC 31 25 ; Compare $2531.w with Y register [Reads: Y Index] [Flags: NCZ]
	asl $33.b		; 06 33 ; Arithmetic shift left $33.b [Reads: Direct Page] [Flags: NCZ]
	and $36.b,X		; 35 36 ; Logical AND $36.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ror $65.b		; 66 65 ; Rotate right $65.b [Reads: Direct Page] [Flags: NCZ]
	rol $2725.w,X		; 3E 25 27 ; Rotate left $2725.w,X [Reads: X Index] [Flags: NCZ]
	and #$66.b		; 29 66 ; Logical AND #$66.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ror $2A.b		; 66 2A ; Rotate right $2A.b [Reads: Direct Page] [Flags: NCZ]
	dec $F3F4.w		; CE F4 F3 ; Decrement $F3F4.w [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $3DF42E.l		; 22 2E F4 3D ; Jump to subroutine long $3DF42E.l [Writes: Stack Pointer] [Flow: call]
	sbc $5152.w		; ED 52 51 ; Subtract $5152.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	rol $DB.b,X		; 36 DB ; Rotate left $DB.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc $85.b,S		; E3 85 ; Subtract stack-relative $85.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora ($E3.b,X)		; 01 E3 ; Logical OR ($E3.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $346A.w		; ED 6A 34 ; Subtract $346A.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $34.b,X		; 35 34 ; Logical AND $34.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $34.b,X		; 35 34 ; Logical AND $34.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
.INDEX 16
	rep #$18		; C2 18
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora ($02.b)		; 12 02 ; OR accumulator with memory (indirect) ($02.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $66.b		; 06 66 ; Arithmetic shift left $66.b [Reads: Direct Page] [Flags: NCZ]
	lda ($6A.b),Y		; B1 6A ; Load accumulator ($6A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($21.b),Y		; 11 21 ; OR accumulator with memory ($21.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $C6.b		; 85 C6 ; Store accumulator to $C6.b [Reads: Accumulator]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $30, $05		; 30 05 ; Branch if minus to $30, $05 [Flow: branch]
	and $C93A.w,Y		; 39 3A C9 ; AND accumulator with memory $C93A.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$55.b		; C9 55 ; Compare #$55.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	brk $33.b		; 00 33 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $26.b		; E6 26 ; Increment $26.b [Reads: Direct Page] [Flags: NZ]
	bit $52.b,X		; 34 52 ; Test bits $52.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	eor $38.b,X		; 55 38 ; Exclusive OR accumulator with memory $38.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	inc $26.b		; E6 26 ; Increment $26.b [Reads: Direct Page] [Flags: NZ]
	eor ($52.b,X)		; 41 52 ; Exclusive OR accumulator with memory ($52.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor $6A.b,X		; 55 6A ; Exclusive OR accumulator with memory $6A.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	bit $CE.b,X		; 34 CE ; Test bits $CE.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	inc $10.b		; E6 10 ; Increment $10.b [Reads: Direct Page] [Flags: NZ]
	cop $3A.b		; 02 3A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $29E6.w,X		; FE E6 29 ; Increment memory $29E6.w,X [Reads: X Index] [Flags: NZ]
	eor ($23.b)		; 52 23 ; Exclusive OR accumulator with memory (indirect) ($23.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	rol $346A.w		; 2E 6A 34 ; Rotate left $346A.w [Flags: NCZ]
	eor $10.b,X		; 55 10 ; Exclusive OR accumulator with memory $10.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	dec $2AE6.w		; CE E6 2A ; Decrement $2AE6.w [Flags: NZ]
	stx $02.b		; 86 02 ; Store X register to $02.b [Reads: X Index]
	eor ($CE.b),Y		; 51 CE ; Exclusive OR accumulator with memory ($CE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	cmp #$42.b		; C9 42 ; Compare #$42.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $68.b,X		; 34 68 ; Test bits $68.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	eor ($03.b,X)		; 41 03 ; Exclusive OR accumulator with memory ($03.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	asl $34.b,X		; 16 34 ; Arithmetic shift left $34.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	jmp ($CE72.w)		; 6C 72 CE ; Jump indirect to ($CE72.w) [Flow: jump]
	ora $30.b,S		; 03 30 ; OR accumulator with stack relative $30.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $41.b		; 24 41 ; Test bits $41.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	bit $49.b,X		; 34 49 ; Test bits $49.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ror $06.b		; 66 06 ; Rotate right $06.b [Reads: Direct Page] [Flags: NCZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	jmp $6679.w		; 4C 79 66 ; Jump to $6679.w [Flow: jump]
	adc $95.b,S		; 63 95 ; Add with carry (stack relative) $95.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	bit $65.b,X		; 34 65 ; Test bits $65.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	eor ($00.b)		; 52 00 ; Exclusive OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $54.b,X		; 36 54 ; Rotate left $54.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	eor $E8.b,X		; 55 E8 ; Exclusive OR accumulator with memory $E8.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	dec $0066.w		; CE 66 00 ; Decrement $0066.w [Flags: NZ]
	eor ($68.b,X)		; 41 68 ; Exclusive OR accumulator with memory ($68.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc $336371.l		; 6F 71 63 33 ; Add with carry (long) $336371.l [Writes: Accumulator] [Flags: NCVZ]
	adc ($34.b)		; 72 34 ; Add with carry (indirect) ($34.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	dec $3077.w		; CE 77 30 ; Decrement $3077.w [Flags: NZ]
	ora $78.b		; 05 78 ; Logical OR $78.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	eor ($9A.b,X)		; 41 9A ; Exclusive OR accumulator with memory ($9A.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor $60.b,X		; 55 60 ; Exclusive OR accumulator with memory $60.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$4B.b		; 49 4B ; Exclusive OR #$4B.b with accumulator [Writes: Accumulator] [Flags: NZ]
	bit $66F4.w		; 2C F4 66 ; Test bits $66F4.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	eor ($2D.b)		; 52 2D ; Exclusive OR accumulator with memory (indirect) ($2D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $30, $2E		; 30 2E ; Branch if minus to $30, $2E [Flow: branch]
	rol $5555.w		; 2E 55 55 ; Rotate left $5555.w [Flags: NCZ]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	adc $56.b		; 65 56 ; Add $56.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	brk $66.b		; 00 66 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $E3.b,X		; 34 E3 ; Test bits $E3.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sbc $C2.b,S		; E3 C2 ; Subtract stack-relative $C2.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
.ACCU 16
.INDEX 16
	rep #$34		; C2 34
	ora $2110C2.l		; 0F C2 10 21 ; OR accumulator with memory (long) $2110C2.l [Writes: Accumulator] [Flags: NZ]
	ora $65.b		; 05 65 ; Logical OR $65.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $C6.b		; 65 C6 ; Add $C6.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($10.b),Y		; 11 10 ; OR accumulator with memory ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	dec $6A.b		; C6 6A ; Decrement $6A.b [Reads: Direct Page] [Flags: NZ]
	sbc $160169.l,X		; FF 69 01 16 ; Subtract with carry (long,X) $160169.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $87.b		; E6 87 ; Increment $87.b [Reads: Direct Page] [Flags: NZ]
	ror $ED.b		; 66 ED ; Rotate right $ED.b [Reads: Direct Page] [Flags: NCZ]
	jsr $5B12.w		; 20 12 5B ; Jump to subroutine at $5B12.w [Writes: Stack Pointer] [Flow: call]
	ldx $5B.b,Y		; B6 5B ; Load X register $5B.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	bit $10.b,X		; 34 10 ; Test bits $10.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $10, $38		; 10 38 ; Branch if plus to $10, $38 [Flow: branch]
	sta $0B0B.w,X		; 9D 0B 0B ; Store accumulator to $0B0B.w,X [Reads: Accumulator, X Index]
	and ($11.b)		; 32 11 ; AND accumulator with memory (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp ($75.b),Y		; D1 75 ; Compare accumulator ($75.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	bit $0B.b,X		; 34 0B ; Test bits $0B.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rol $38.b,X		; 36 38 ; Rotate left $38.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $11.b,S		; 03 11 ; OR accumulator with stack relative $11.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor ($6A.b,S),Y		; 53 6A ; XOR accumulator (stack relative indirect indexed) ($6A.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $0A.b,X		; 36 0A ; Rotate left $0A.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	asl $01.b,X		; 16 01 ; Arithmetic shift left $01.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $9D.b,X		; 34 9D ; Test bits $9D.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	and $6A.b,X		; 35 6A ; Logical AND $6A.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($13.b,S),Y		; 53 13 ; XOR accumulator (stack relative indirect indexed) ($13.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc ($6D.b,X)		; 61 6D ; Add with carry ($6D.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $0B.b,X		; 34 0B ; Test bits $0B.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	rol $40.b,X		; 36 40 ; Rotate left $40.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $10, $0A		; 10 0A ; Branch if plus to $10, $0A [Flow: branch]
	lda $3634.w		; AD 34 36 ; Load $3634.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,S),Y		; 13 00 ; OR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	pea $3838.w		; F4 38 38 ; Push absolute address $3838.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $31.b,S		; 23 31 ; AND accumulator with stack relative $31.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	lda $110A.w		; AD 0A 11 ; Load $110A.w into accumulator [Writes: Accumulator] [Flags: NZ]
	and ($36.b),Y		; 31 36 ; AND accumulator with memory ($36.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	rol $34.b,X		; 36 34 ; Rotate left $34.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sta $0000.w,Y		; 99 00 00 ; Store accumulator to $0000.w,Y [Reads: Y Index, Accumulator]
	inc $F6.b,X		; F6 F6 ; Increment memory $F6.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	lda [$34.b]		; A7 34 ; Load accumulator (long) [$34.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $30.b,X		; 55 30 ; Exclusive OR accumulator with memory $30.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $36.b,X		; 35 36 ; Logical AND $36.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ror $30FE.w		; 6E FE 30 ; Rotate right $30FE.w [Flags: NCZ]
	adc $FE.b,S		; 63 FE ; Add with carry (stack relative) $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	and $36.b,X		; 35 36 ; Logical AND $36.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $30.b,S		; 03 30 ; OR accumulator with stack relative $30.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	adc [$EE.b]		; 67 EE ; Add with carry (long) [$EE.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda [$41.b]		; A7 41 ; Load accumulator (long) [$41.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($36.b,S),Y		; 13 36 ; OR accumulator (stack relative indirect indexed) ($36.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	jsr ($00C6.w,X)		; FC C6 00 ; Jump to subroutine indirect indexed ($00C6.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $6C.b,X		; 76 6C ; Rotate right $6C.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	jmp ($1121.w)		; 6C 21 11 ; Jump indirect to ($1121.w) [Flow: jump]
	jmp ($C66C.w)		; 6C 6C C6 ; Jump indirect to ($C66C.w) [Flow: jump]
.INDEX 16
	rep #$11		; C2 11
	ora ($C2.b,X)		; 01 C2 ; Logical OR ($C2.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	adc $C6.b		; 65 C6 ; Add $C6.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	stz $3479.w,X		; 9E 79 34 ; Store zero to $3479.w,X [Reads: X Index]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $AC.b		; 00 AC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $36D7.w		; 6D D7 36 ; Add $36D7.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $34FB.w,Y		; F9 FB 34 ; Subtract with carry $34FB.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($30.b,S),Y		; 33 30 ; AND accumulator (stack relative indirect indexed) ($30.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc [$75.b]		; E7 75 ; Subtract with carry (long) [$75.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda $2012C9.l		; AF C9 12 20 ; Load long $2012C9.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$0B36.w		; C9 36 0B ; Compare #$0B36.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	stz $00.b,X		; 74 00 ; Store zero to $00.b,X [Reads: X Index]
	lsr $0E.b		; 46 0E ; Logical shift right $0E.b [Reads: Direct Page] [Flags: NCZ]
	eor ($A9.b,S),Y		; 53 A9 ; XOR accumulator (stack relative indirect indexed) ($A9.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jmp ($0141.w,X)		; 7C 41 01 ; Jump indirect indexed to ($0141.w,X) [Reads: X Index] [Flow: jump]
	trb $16.b		; 14 16 ; Test and reset bits $16.b [Reads: Accumulator] [Flags: Z]
	rol $34.b,X		; 36 34 ; Rotate left $34.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $6C.b,X		; 15 6C ; OR accumulator with memory $6C.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lda $4136.w		; AD 36 41 ; Load $4136.w into accumulator [Writes: Accumulator] [Flags: NZ]
	brk $C9.b		; 00 C9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $C9.b		; 84 C9 ; Store Y register to $C9.b [Reads: Y Index]
	ora $01.b,X		; 15 01 ; OR accumulator with memory $01.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $71.b		; 00 71 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $7E7E.w,X		; 7D 7E 7E ; Add $7E7E.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $33.b,S		; 03 33 ; OR accumulator with stack relative $33.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldx $F9F7.w		; AE F7 F9 ; Load $F9F7.w into X register [Writes: X Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	and $33.b,S		; 23 33 ; AND accumulator with stack relative $33.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx $F033.w		; EC 33 F0 ; Compare $F033.w with X register [Reads: X Index] [Flags: NCZ]
	inc $0303.w,X		; FE 03 03 ; Increment memory $0303.w,X [Reads: X Index] [Flags: NZ]
	inc $3300.w,X		; FE 00 33 ; Increment memory $3300.w,X [Reads: X Index] [Flags: NZ]
	rol $34.b,X		; 36 34 ; Rotate left $34.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $30, $FF		; 30 FF ; Branch if minus to $30, $FF [Flow: branch]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	asl $04.b		; 06 04 ; Arithmetic shift left $04.b [Reads: Direct Page] [Flags: NCZ]
	mvp $34,$34		; 44 34 34 ; Move block positive $34,$34 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sbc [$6C.b]		; E7 6C ; Subtract with carry (long) [$6C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $6C		; 80 6C ; Branch always to $80, $6C [Flow: branch]
	and $FC.b,X		; 35 FC ; Logical AND $FC.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($40.b),Y		; 11 40 ; OR accumulator with memory ($40.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	inc $76E7.w,X		; FE E7 76 ; Increment memory $76E7.w,X [Reads: X Index] [Flags: NZ]
	bit $01.b,X		; 34 01 ; Test bits $01.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	jsr $6518.w		; 20 18 65 ; Jump to subroutine at $6518.w [Writes: Stack Pointer] [Flow: call]
	lda $A5.b		; A5 A5 ; Load $A5.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($11.b,X)		; 21 11 ; Logical AND ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($AA.b,S),Y		; 13 AA ; OR accumulator (stack relative indirect indexed) ($AA.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldy $CF.b		; A4 CF ; Load $CF.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	jsr $3400.w		; 20 00 34 ; Jump to subroutine at $3400.w [Writes: Stack Pointer] [Flow: call]
	bit $20.b,X		; 34 20 ; Test bits $20.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $56.b		; 00 56 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $AD7F.w,X		; 7E 7F AD ; Rotate right $AD7F.w,X [Reads: X Index] [Flags: NCZ]
	dec $66.b		; C6 66 ; Decrement $66.b [Reads: Direct Page] [Flags: NZ]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $81.b,X		; 34 81 ; Test bits $81.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	jsr $6560.w		; 20 60 65 ; Jump to subroutine at $6560.w [Writes: Stack Pointer] [Flow: call]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sty $FD.b		; 84 FD ; Store Y register to $FD.b [Reads: Y Index]
	ror $61.b		; 66 61 ; Rotate right $61.b [Reads: Direct Page] [Flags: NCZ]
	asl $FF.b,X		; 16 FF ; Arithmetic shift left $FF.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sta $00219F.l,X		; 9F 9F 21 00 ; Store accumulator (long,X) $00219F.l,X [Reads: Accumulator, X Index]
	sta $CF9F9F.l,X		; 9F 9F 9F CF ; Store accumulator (long,X) $CF9F9F.l,X [Reads: Accumulator, X Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($88.b,X)		; 41 88 ; Exclusive OR accumulator with memory ($88.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sta $1634.w		; 8D 34 16 ; Store accumulator to $1634.w [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jmp ($347B.w,X)		; 7C 7B 34 ; Jump indirect indexed to ($347B.w,X) [Reads: X Index] [Flow: jump]
	jmp ($0666.w,X)		; 7C 66 06 ; Jump indirect indexed to ($0666.w,X) [Reads: X Index] [Flow: jump]
	bit $87.b,X		; 34 87 ; Test bits $87.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	stx $95.b		; 86 95 ; Store X register to $95.b [Reads: X Index]
	asl $66.b		; 06 66 ; Arithmetic shift left $66.b [Reads: Direct Page] [Flags: NCZ]
	sta [$99.b],Y		; 97 99 ; Store accumulator (long indexed) [$99.b],Y [Reads: Direct Page, Y Index, Accumulator]
	sta $56.b,X		; 95 56 ; Store accumulator to $56.b,X [Reads: Accumulator, X Index]
	ror $61.b		; 66 61 ; Rotate right $61.b [Reads: Direct Page] [Flags: NCZ]
	sta $97.b,X		; 95 97 ; Store accumulator to $97.b,X [Reads: Accumulator, X Index]
	sta $6695.w,Y		; 99 95 66 ; Store accumulator to $6695.w,Y [Reads: Y Index, Accumulator]
	ror $CD.b		; 66 CD ; Rotate right $CD.b [Reads: Direct Page] [Flags: NCZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	sta $95.b,X		; 95 95 ; Store accumulator to $95.b,X [Reads: Accumulator, X Index]
	jsl $CD9E66.l		; 22 66 9E CD ; Jump to subroutine long $CD9E66.l [Writes: Stack Pointer] [Flow: call]
	sta $CD.b,X		; 95 CD ; Store accumulator to $CD.b,X [Reads: Accumulator, X Index]
	and ($62.b)		; 32 62 ; AND accumulator with memory (indirect) ($62.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp [$A3.b]		; C7 A3 ; Compare accumulator (long) [$A3.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	lda $27.b,S		; A3 27 ; Load accumulator (stack relative) $27.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $63.b		; 26 63 ; Rotate left $63.b [Reads: Direct Page] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	inc $CD.b,X		; F6 CD ; Increment memory $CD.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	and $22.b		; 25 22 ; Logical AND $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($9F.b,X)		; 21 9F ; Logical AND ($9F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta $001D26.l,X		; 9F 26 1D 00 ; Store accumulator (long,X) $001D26.l,X [Reads: Accumulator, X Index]
	ora ($C4.b),Y		; 11 C4 ; OR accumulator with memory ($C4.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	dec $A6.b		; C6 A6 ; Decrement $A6.b [Reads: Direct Page] [Flags: NZ]
	ora $0210.w,Y		; 19 10 02 ; OR accumulator with memory $0210.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $C4.b,X		; 34 C4 ; Test bits $C4.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sbc $110104.l,X		; FF 04 01 11 ; Subtract with carry (long,X) $110104.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	lda $66C6.w		; AD C6 66 ; Load $66C6.w into accumulator [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc ($C4.b),Y		; 71 C4 ; Add with carry ($C4.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $C6.b		; 65 C6 ; Add $C6.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($10.b),Y		; 11 10 ; OR accumulator with memory ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $57.b		; 85 57 ; Store accumulator to $57.b [Reads: Accumulator]
	ldx $327E.w		; AE 7E 32 ; Load $327E.w into X register [Writes: X Index] [Flags: NZ]
	adc ($D1.b,X)		; 61 D1 ; Add with carry ($D1.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp ($AF.b),Y		; D1 AF ; Compare accumulator ($AF.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	eor ($00.b,S),Y		; 53 00 ; XOR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc ($AE.b,X)		; 61 AE ; Add with carry ($AE.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ror $60C9.w,X		; 7E C9 60 ; Rotate right $60C9.w,X [Reads: X Index] [Flags: NCZ]
	.db $10, $DF		; 10 DF ; Branch if plus to $10, $DF [Flow: branch]
	ldx $C9.b,Y		; B6 C9 ; Load X register $C9.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	eor ($06.b,S),Y		; 53 06 ; XOR accumulator (stack relative indirect indexed) ($06.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($CC.b,X)		; 01 CC ; Logical OR ($CC.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $0F.b,X		; 34 0F ; Test bits $0F.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	stz $2000.w,X		; 9E 00 20 ; Store zero to $2000.w,X [Reads: X Index]
	ldx $534C.w		; AE 4C 53 ; Load $534C.w into X register [Writes: X Index] [Flags: NZ]
	sbc $63.b		; E5 63 ; Subtract $63.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($B7.b),Y		; 11 B7 ; OR accumulator with memory ($B7.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $5E5C.w,X		; 1D 5C 5E ; OR accumulator with memory $5E5C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $11, $5F		; 62 11 5F ; Push effective relative address $62, $11, $5F [Writes: Stack Pointer]
	ldx $AE1C.w		; AE 1C AE ; Load $AE1C.w into X register [Writes: X Index] [Flags: NZ]
	asl $26.b,X		; 16 26 ; Arithmetic shift left $26.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cmp $BC.b,X		; D5 BC ; Compare accumulator $BC.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ldx $06AE.w,Y		; BE AE 06 ; Load X register $06AE.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ror $7C.b		; 66 7C ; Rotate right $7C.b [Reads: Direct Page] [Flags: NCZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	cpy #$16C2.w		; C0 C2 16 ; Compare #$16C2.w with Y register [Reads: Y Index] [Flags: NCZ]
	ror $67.b		; 66 67 ; Rotate right $67.b [Reads: Direct Page] [Flags: NCZ]
	cmp $CC.b,X		; D5 CC ; Compare accumulator $CC.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	dec $6610.w		; CE 10 66 ; Decrement $6610.w [Flags: NZ]
	ldx $D0C5.w		; AE C5 D0 ; Load $D0C5.w into X register [Writes: X Index] [Flags: NZ]
	cmp ($60.b)		; D2 60 ; Compare accumulator (indirect) ($60.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ror $20.b		; 66 20 ; Rotate right $20.b [Reads: Direct Page] [Flags: NCZ]
	cmp ($C7.b,S),Y		; D3 C7 ; Compare accumulator (stack relative indirect indexed) ($C7.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	dec $0626.w,X		; DE 26 06 ; Decrement memory $0626.w,X [Reads: X Index] [Flags: NZ]
	eor ($AE.b,S),Y		; 53 AE ; XOR accumulator (stack relative indirect indexed) ($AE.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp ($C8.b),Y		; D1 C8 ; Compare accumulator ($C8.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	asl $00.b,X		; 16 00 ; Arithmetic shift left $00.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	dec $B4C9.w,X		; DE C9 B4 ; Decrement memory $B4C9.w,X [Reads: X Index] [Flags: NZ]
	cpx #$6660.w		; E0 60 66 ; Compare #$6660.w with X register [Reads: X Index] [Flags: NCZ]
	cmp #$E353.w		; C9 53 E3 ; Compare #$E353.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	sbc $01.b		; E5 01 ; Subtract $01.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ror $AE.b		; 66 AE ; Rotate right $AE.b [Reads: Direct Page] [Flags: NCZ]
	ldx $87DE.w		; AE DE 87 ; Load $87DE.w into X register [Writes: X Index] [Flags: NZ]
	ror $63.b		; 66 63 ; Rotate right $63.b [Reads: Direct Page] [Flags: NCZ]
	eor ($E6.b,S),Y		; 53 E6 ; XOR accumulator (stack relative indirect indexed) ($E6.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sbc #$6616.w		; E9 16 66 ; Subtract #$6616.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sbc [$E7.b]		; E7 E7 ; Subtract with carry (long) [$E7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cpx $66EE.w		; EC EE 66 ; Compare $66EE.w with X register [Reads: X Index] [Flags: NCZ]
	ror $E7.b		; 66 E7 ; Rotate right $E7.b [Reads: Direct Page] [Flags: NCZ]
	sbc [$EF.b]		; E7 EF ; Subtract with carry (long) [$EF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ldx $6666.w		; AE 66 66 ; Load $6666.w into X register [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sbc [$FC.b]		; E7 FC ; Subtract with carry (long) [$FC.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($6666.w,X)		; FC 66 66 ; Jump to subroutine indirect indexed ($6666.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $0100.w,X		; FE 00 01 ; Increment memory $0100.w,X [Reads: X Index] [Flags: NZ]
	sbc [$67.b]		; E7 67 ; Subtract with carry (long) [$67.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ror $FA.b,X		; 76 FA ; Rotate right $FA.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cmp ($E8.b),Y		; D1 E8 ; Compare accumulator ($E8.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	and #$6360.w		; 29 60 63 ; Logical AND #$6360.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc [$03.b]		; E7 03 ; Subtract with carry (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	adc [$77.b]		; 67 77 ; Add with carry (long) [$77.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc ($1F.b),Y		; 71 1F ; Add with carry ($1F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$29.b]		; 07 29 ; OR accumulator with memory (long) [$29.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($73.b)		; 12 73 ; OR accumulator with memory (indirect) ($73.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $04.b		; 06 04 ; Arithmetic shift left $04.b [Reads: Direct Page] [Flags: NCZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldx $3677.w		; AE 77 36 ; Load $3677.w into X register [Writes: X Index] [Flags: NZ]
	adc ($1F.b),Y		; 71 1F ; Add with carry ($1F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $1204.w		; 0C 04 12 ; Test and set bits $1204.w [Reads: Accumulator] [Flags: Z]
	adc [$AE.b],Y		; 77 AE ; Add with carry (long indexed) [$AE.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	jsr $66AE.w		; 20 AE 66 ; Jump to subroutine at $66AE.w [Writes: Stack Pointer] [Flow: call]
	rol $AB.b		; 26 AB ; Rotate left $AB.b [Reads: Direct Page] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	ldx $0620.w		; AE 20 06 ; Load $0620.w into X register [Writes: X Index] [Flags: NZ]
	.db $62, $05, $E7		; 62 05 E7 ; Push effective relative address $62, $05, $E7 [Writes: Stack Pointer]
	asl $16.b,X		; 16 16 ; Arithmetic shift left $16.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ror $77.b,X		; 76 77 ; Rotate right $77.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $AE1A.w,Y		; 19 1A AE ; OR accumulator with memory $AE1A.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc [$76.b],Y		; 77 76 ; Add with carry (long indexed) [$76.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $D0, $7E		; D0 7E ; Branch if not equal to $D0, $7E [Flow: branch]
	.db $D0, $FF		; D0 FF ; Branch if not equal to $D0, $FF [Flow: branch]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	ldx $EAEE.w		; AE EE EA ; Load $EAEE.w into X register [Writes: X Index] [Flags: NZ]
	asl $16.b		; 06 16 ; Arithmetic shift left $16.b [Reads: Direct Page] [Flags: NCZ]
	ldx $D534.w		; AE 34 D5 ; Load $D534.w into X register [Writes: X Index] [Flags: NZ]
	nop		; EA ; No operation
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	asl $C5.b		; 06 C5 ; Arithmetic shift left $C5.b [Reads: Direct Page] [Flags: NCZ]
	ldx $E7AE.w		; AE AE E7 ; Load $E7AE.w into X register [Writes: X Index] [Flags: NZ]
	asl $66.b		; 06 66 ; Arithmetic shift left $66.b [Reads: Direct Page] [Flags: NCZ]
	cmp $EA.b		; C5 EA ; Compare $EA.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	adc $65.b		; 65 65 ; Add $65.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$D1.b]		; 07 D1 ; OR accumulator with memory (long) [$D1.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	ora $5710.w,X		; 1D 10 57 ; OR accumulator with memory $5710.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $E787.w,X		; 1E 87 E7 ; Arithmetic shift left $E787.w,X [Reads: X Index] [Flags: NCZ]
	sbc [$73.b]		; E7 73 ; Subtract with carry (long) [$73.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ror $61.b		; 66 61 ; Rotate right $61.b [Reads: Direct Page] [Flags: NCZ]
	cmp [$D0.b]		; C7 D0 ; Compare accumulator (long) [$D0.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp ($10.b),Y		; D1 10 ; Compare accumulator ($10.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	brk $D1.b		; 00 D1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($AE.b),Y		; D1 AE ; Compare accumulator ($AE.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc [$26.b]		; 67 26 ; Add with carry (long) [$26.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	nop		; EA ; No operation
	.db $D0, $E0		; D0 E0 ; Branch if not equal to $D0, $E0 [Flow: branch]
	ror $06.b,X		; 76 06 ; Rotate right $06.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cmp $29DC.w,X		; DD DC 29 ; Compare accumulator $29DC.w,X [Reads: X Index] [Flags: NCZ]
	sbc [$00.b]		; E7 00 ; Subtract with carry (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ror $EA.b,X		; 76 EA ; Rotate right $EA.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc [$63.b]		; E7 63 ; Subtract with carry (long) [$63.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ror $2D.b,X		; 76 2D ; Rotate right $2D.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	nop		; EA ; No operation
	cpy $E7.b		; C4 E7 ; Compare $E7.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	ror $06.b,X		; 76 06 ; Rotate right $06.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cmp ($E7.b)		; D2 E7 ; Compare accumulator (indirect) ($E7.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sbc [$D3.b]		; E7 D3 ; Subtract with carry (long) [$D3.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	asl $60.b		; 06 60 ; Arithmetic shift left $60.b [Reads: Direct Page] [Flags: NCZ]
	trb $E7FE.w		; 1C FE E7 ; Test and reset bits $E7FE.w [Reads: Accumulator] [Flags: Z]
	sbc ($72.b),Y		; F1 72 ; Subtract with carry ($72.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	bit $D5.b,X		; 34 D5 ; Test bits $D5.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cmp $1A.b,X		; D5 1A ; Compare accumulator $1A.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($12.b,X)		; 01 12 ; Logical OR ($12.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda $1A34.w		; AD 34 1A ; Load $1A34.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	and ($79.b,X)		; 21 79 ; Logical AND ($79.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rol $10.b,X		; 36 10 ; Rotate left $10.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	dec $10.b		; C6 10 ; Decrement $10.b [Reads: Direct Page] [Flags: NZ]
	jsr $9FFF.w		; 20 FF 9F ; Jump to subroutine at $9FFF.w [Writes: Stack Pointer] [Flow: call]
	sta $0110FF.l,X		; 9F FF 10 01 ; Store accumulator (long,X) $0110FF.l,X [Reads: Accumulator, X Index]
	sta $58719E.l,X		; 9F 9E 71 58 ; Store accumulator (long,X) $58719E.l,X [Reads: Accumulator, X Index]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	bit $FD.b,X		; 34 FD ; Test bits $FD.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	lda $10.b		; A5 10 ; Load $10.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $A5		; 10 A5 ; Branch if plus to $10, $A5 [Flow: branch]
	lda $C6.b		; A5 C6 ; Load $C6.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror $0100.w,X		; 7E 00 01 ; Rotate right $0100.w,X [Reads: X Index] [Flags: NCZ]
	stx $40.b		; 86 40 ; Store X register to $40.b [Reads: X Index]
	sbc ($E1.b,X)		; E1 E1 ; Subtract with carry ($E1.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $22.b,X		; 35 22 ; Logical AND $22.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc [$34.b]		; 67 34 ; Add with carry (long) [$34.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ror $1053.w,X		; 7E 53 10 ; Rotate right $1053.w,X [Reads: X Index] [Flags: NCZ]
	ora ($89.b),Y		; 11 89 ; OR accumulator with memory ($89.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	inc $0C.b		; E6 0C ; Increment $0C.b [Reads: Direct Page] [Flags: NZ]
	and [$23.b],Y		; 37 23 ; AND accumulator with memory (long indexed) [$23.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	trb $1FE6.w		; 1C E6 1F ; Test and reset bits $1FE6.w [Reads: Accumulator] [Flags: Z]
	jsl $1F1C23.l		; 22 23 1C 1F ; Jump to subroutine long $1F1C23.l [Writes: Stack Pointer] [Flow: call]
	dec $1A.b		; C6 1A ; Decrement $1A.b [Reads: Direct Page] [Flags: NZ]
	and $03.b,S		; 23 03 ; AND accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $30.b		; E6 30 ; Increment $30.b [Reads: Direct Page] [Flags: NZ]
	ror $07.b		; 66 07 ; Rotate right $07.b [Reads: Direct Page] [Flags: NCZ]
	and [$11.b]		; 27 11 ; AND accumulator with memory (long) [$11.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $C6AD.w		; AD AD C6 ; Load $C6AD.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ror $66.b		; 66 66 ; Rotate right $66.b [Reads: Direct Page] [Flags: NCZ]
	ora ($58.b,X)		; 01 58 ; Logical OR ($58.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	adc $65.b		; 65 65 ; Add $65.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc $11.b		; 65 11 ; Add $11.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($06.b),Y		; 11 06 ; OR accumulator with memory ($06.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ror $AC.b		; 66 AC ; Rotate right $AC.b [Reads: Direct Page] [Flags: NCZ]
	sta $11.b		; 85 11 ; Store accumulator to $11.b [Reads: Accumulator]
	adc $66.b,S		; 63 66 ; Add with carry (stack relative) $66.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $C6		; 30 C6 ; Branch if minus to $30, $C6 [Flow: branch]
	cmp $17.b,X		; D5 17 ; Compare accumulator $17.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $5B.b		; 00 5B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $C6.b		; 85 C6 ; Store accumulator to $C6.b [Reads: Accumulator]
	jsr $0513.w		; 20 13 05 ; Jump to subroutine at $0513.w [Writes: Stack Pointer] [Flow: call]
	bit $E0.b,X		; 34 E0 ; Test bits $E0.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	jmp.w [$0070]		; DC 70 00 ; Jump long indirect [$0070] [Flow: jump]
	cpy $A9DC.w		; CC DC A9 ; Compare $A9DC.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora $AD0200.l		; 0F 00 02 AD ; OR accumulator with memory (long) $AD0200.l [Writes: Accumulator] [Flags: NZ]
	sbc ($34.b)		; F2 34 ; Subtract with carry (indirect) ($34.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $34.b		; C6 34 ; Decrement $34.b [Reads: Direct Page] [Flags: NZ]
	sbc ($38.b,X)		; E1 38 ; Subtract with carry ($38.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($4F.b),Y		; 71 4F ; Add with carry ($4F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp #$01E7.w		; C9 E7 01 ; Compare #$01E7.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora ($6C.b,X)		; 01 6C ; Logical OR ($6C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta ($98.b,X)		; 81 98 ; Store accumulator ($98.b,X) [Reads: Direct Page, Accumulator, X Index]
	ldy $3611.w		; AC 11 36 ; Load $3611.w into Y register [Writes: Y Index] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and $413F.w,X		; 3D 3F 41 ; AND accumulator with memory $413F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$77.b],Y		; 17 77 ; OR accumulator with memory (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $08.b,X		; 34 08 ; Test bits $08.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	eor ($56.b,S),Y		; 53 56 ; XOR accumulator (stack relative indirect indexed) ($56.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta $D2.b,X		; 95 D2 ; Store accumulator to $D2.b,X [Reads: Accumulator, X Index]
	jsr $326A.w		; 20 6A 32 ; Jump to subroutine at $326A.w [Writes: Stack Pointer] [Flow: call]
	and ($48.b,X)		; 21 48 ; Logical AND ($48.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	rol $77.b,X		; 36 77 ; Rotate left $77.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	adc ($56.b,S),Y		; 73 56 ; Add with carry (stack relative indirect indexed) ($56.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cmp ($CD.b),Y		; D1 CD ; Compare accumulator ($CD.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cmp $2212.w		; CD 12 22 ; Compare $2212.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	dec $E4.b,X		; D6 E4 ; Decrement memory $E4.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	bit $22.b,X		; 34 22 ; Test bits $22.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $10, $34		; 10 34 ; Branch if plus to $10, $34 [Flow: branch]
	cmp $CDD9.w		; CD D9 CD ; Compare $CDD9.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $6866.w		; 20 66 68 ; Jump to subroutine at $6866.w [Writes: Stack Pointer] [Flow: call]
	sbc ($21.b)		; F2 21 ; Subtract with carry (indirect) ($21.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $C7		; 10 C7 ; Branch if plus to $10, $C7 [Flow: branch]
	sbc $226658.l		; EF 58 66 22 ; Subtract with carry (long) $226658.l [Writes: Accumulator] [Flags: NCVZ]
	ora ($F2.b),Y		; 11 F2 ; OR accumulator with memory ($F2.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $02C204.l		; EF 04 C2 02 ; Subtract with carry (long) $02C204.l [Writes: Accumulator] [Flags: NCVZ]
	and ($E6.b,S),Y		; 33 E6 ; AND accumulator (stack relative indirect indexed) ($E6.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $06.b		; E6 06 ; Increment $06.b [Reads: Direct Page] [Flags: NZ]
	adc $22.b,X		; 75 22 ; Add $22.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($1C.b),Y		; 31 1C ; AND accumulator with memory ($1C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $CD.b,X		; 34 CD ; Test bits $CD.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cmp [$20.b]		; C7 20 ; Compare accumulator (long) [$20.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	jsl $35E62D.l		; 22 2D E6 35 ; Jump to subroutine long $35E62D.l [Writes: Stack Pointer] [Flow: call]
	inc $5112.w		; EE 12 51 ; Increment $5112.w [Flags: NZ]
	sta $34.b,S		; 83 34 ; Store accumulator (stack relative) $34.b,S [Reads: Stack Pointer, Accumulator]
	cmp $10D5.w		; CD D5 10 ; Compare $10D5.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsl $2053F1.l		; 22 F1 53 20 ; Jump to subroutine long $2053F1.l [Writes: Stack Pointer] [Flow: call]
	adc $21.b,X		; 75 21 ; Add $21.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $C9505B.l		; 22 5B 50 C9 ; Jump to subroutine long $C9505B.l [Writes: Stack Pointer] [Flow: call]
	cmp [$11.b]		; C7 11 ; Compare accumulator (long) [$11.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cop $D9.b		; 02 D9 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	bit $DF.b,X		; 34 DF ; Test bits $DF.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and ($02.b,X)		; 21 02 ; Logical AND ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp [$C7.b]		; C7 C7 ; Compare accumulator (long) [$C7.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp [$C7.b]		; C7 C7 ; Compare accumulator (long) [$C7.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	jsl $71D722.l		; 22 22 D7 71 ; Jump to subroutine long $71D722.l [Writes: Stack Pointer] [Flow: call]
	jmp.w [$207F]		; DC 7F 20 ; Jump long indirect [$207F] [Flow: jump]
	ora ($CC.b,X)		; 01 CC ; Logical OR ($CC.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta $20.b,S		; 83 20 ; Store accumulator (stack relative) $20.b,S [Reads: Stack Pointer, Accumulator]
	cmp [$01.b]		; C7 01 ; Compare accumulator (long) [$01.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	.db $50, $57		; 50 57 ; Branch if overflow clear to $50, $57 [Flow: branch]
	.db $D0, $CC		; D0 CC ; Branch if not equal to $D0, $CC [Flow: branch]
	cmp $0220.w		; CD 20 02 ; Compare $0220.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	adc ($53.b),Y		; 71 53 ; Add with carry ($53.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $C7.b,X		; D5 C7 ; Compare accumulator $C7.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpy $DA.b		; C4 DA ; Compare $DA.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	sbc $2202D6.l		; EF D6 02 22 ; Subtract with carry (long) $2202D6.l [Writes: Accumulator] [Flags: NCVZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inc $56.b,X		; F6 56 ; Increment memory $56.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	lsr $1702.w		; 4E 02 17 ; Logical shift right $1702.w [Flags: NCZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cpx $CD.b		; E4 CD ; Compare $CD.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cop $20.b		; 02 20 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy $4F.b		; C4 4F ; Compare $4F.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	eor $71072D.l		; 4F 2D 07 71 ; Exclusive OR accumulator with memory (long) $71072D.l [Writes: Accumulator] [Flags: NZ]
	tsb $06.b		; 04 06 ; Test and set bits $06.b [Reads: Accumulator] [Flags: Z]
	adc $66.b		; 65 66 ; Add $66.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and ($11.b),Y		; 31 11 ; AND accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $2FC6.w		; 2D C6 2F ; Logical AND $2FC6.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ror $10.b		; 66 10 ; Rotate right $10.b [Reads: Direct Page] [Flags: NCZ]
	adc ($E9.b),Y		; 71 E9 ; Add with carry ($E9.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	cmp $0010C6.l,X		; DF C6 10 00 ; Compare accumulator (long,X) $0010C6.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	cmp $03.b		; C5 03 ; Compare $03.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	jmp $3310.w		; 4C 10 33 ; Jump to $3310.w [Flow: jump]
	dec $CD.b		; C6 CD ; Decrement $CD.b [Reads: Direct Page] [Flags: NZ]
	and [$ED.b],Y		; 37 ED ; AND accumulator with memory (long indexed) [$ED.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cop $21.b		; 02 21 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cmp $CD.b		; C5 CD ; Compare $CD.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ldx $2600.w		; AE 00 26 ; Load $2600.w into X register [Writes: X Index] [Flags: NZ]
	jsr $58E7.w		; 20 E7 58 ; Jump to subroutine at $58E7.w [Writes: Stack Pointer] [Flow: call]
	ora [$26.b]		; 07 26 ; OR accumulator with memory (long) [$26.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc [$E7.b],Y		; 77 E7 ; Add with carry (long indexed) [$E7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	ror $6340.w,X		; 7E 40 63 ; Rotate right $6340.w,X [Reads: X Index] [Flags: NCZ]
	ora $5A.b,X		; 15 5A ; OR accumulator with memory $5A.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor $F4D0.w,X		; 5D D0 F4 ; Exclusive OR accumulator with memory $F4D0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc [$02.b],Y		; 77 02 ; Add with carry (long indexed) [$02.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	ldx $AEE7.w		; AE E7 AE ; Load $AEE7.w into X register [Writes: X Index] [Flags: NZ]
	rol $66.b,X		; 36 66 ; Rotate left $66.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	trb $5F29.w		; 1C 29 5F ; Test and reset bits $5F29.w [Reads: Accumulator] [Flags: Z]
	and #$7373.w		; 29 73 73 ; Logical AND #$7373.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $29.b		; 25 29 ; Logical AND $29.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor ($7F.b,S),Y		; 53 7F ; XOR accumulator (stack relative indirect indexed) ($7F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc ($11.b,S),Y		; 73 11 ; Add with carry (stack relative indirect indexed) ($11.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	trb $1CEE.w		; 1C EE 1C ; Test and reset bits $1CEE.w [Reads: Accumulator] [Flags: Z]
	bit $21.b,X		; 34 21 ; Test bits $21.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	jsl $64E763.l		; 22 63 E7 64 ; Jump to subroutine long $64E763.l [Writes: Stack Pointer] [Flow: call]
	and ($76.b,S),Y		; 33 76 ; AND accumulator (stack relative indirect indexed) ($76.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc ($33.b)		; 72 33 ; Add with carry (indirect) ($33.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	bit $64.b,X		; 34 64 ; Test bits $64.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and $7222.w,Y		; 39 22 72 ; AND accumulator with memory $7222.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $66.b,X		; 34 66 ; Test bits $66.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sta $279E.w,X		; 9D 9E 27 ; Store accumulator to $279E.w,X [Reads: Accumulator, X Index]
	eor $AE.b,X		; 55 AE ; Exclusive OR accumulator with memory $AE.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ror $34.b		; 66 34 ; Rotate right $34.b [Reads: Direct Page] [Flags: NCZ]
	bit $61.b,X		; 34 61 ; Test bits $61.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cop $97.b		; 02 97 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta [$05.b],Y		; 97 05 ; Store accumulator (long indexed) [$05.b],Y [Reads: Direct Page, Y Index, Accumulator]
	ora [$55.b]		; 07 55 ; OR accumulator with memory (long) [$55.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($AE.b),Y		; 11 AE ; OR accumulator with memory ($AE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $65.b		; 65 65 ; Add $65.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc $61.b		; 65 61 ; Add $61.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($65.b),Y		; 11 65 ; OR accumulator with memory ($65.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $AA.b		; 65 AA ; Add $AA.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	stx $11.b,Y		; 96 11 ; Store X register $11.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	ora $68.b		; 05 68 ; Logical OR $68.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $96.b		; 06 96 ; Arithmetic shift left $96.b [Reads: Direct Page] [Flags: NCZ]
	ora $71.b		; 05 71 ; Logical OR $71.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor ($65.b),Y		; 51 65 ; Exclusive OR accumulator with memory ($65.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($B7.b)		; F2 B7 ; Subtract with carry (indirect) ($B7.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inc $6211.w,X		; FE 11 62 ; Increment memory $6211.w,X [Reads: X Index] [Flags: NZ]
	cmp $AE.b		; C5 AE ; Compare $AE.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	asl $77.b		; 06 77 ; Arithmetic shift left $77.b [Reads: Direct Page] [Flags: NCZ]
	inc $EAD0.w,X		; FE D0 EA ; Increment memory $EAD0.w,X [Reads: X Index] [Flags: NZ]
	sbc $556620.l		; EF 20 66 55 ; Subtract with carry (long) $556620.l [Writes: Accumulator] [Flags: NCVZ]
	nop		; EA ; No operation
	sta $E7.b		; 85 E7 ; Store accumulator to $E7.b [Reads: Accumulator]
	ror $36.b,X		; 76 36 ; Rotate right $36.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	eor $6D09.w,Y		; 59 09 6D ; Exclusive OR accumulator with memory $6D09.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and $77.b		; 25 77 ; Logical AND $77.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc [$E6.b],Y		; 77 E6 ; Add with carry (long indexed) [$E6.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$08.b]		; E7 08 ; Subtract with carry (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $D0, $66		; D0 66 ; Branch if not equal to $D0, $66 [Flow: branch]
	.db $70, $D1		; 70 D1 ; Branch if overflow set to $70, $D1 [Flow: branch]
	trb $0907.w		; 1C 07 09 ; Test and reset bits $0907.w [Reads: Accumulator] [Flags: Z]
	ora [$77.b]		; 07 77 ; OR accumulator with memory (long) [$77.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $F907.w		; 6D 07 F9 ; Add $F907.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	adc ($77.b),Y		; 71 77 ; Add with carry ($77.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc [$6E.b]		; 67 6E ; Add with carry (long) [$6E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lsr $E7.b,X		; 56 E7 ; Logical shift right $E7.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora #$6777.w		; 09 77 67 ; Logical OR #$6777.w with accumulator [Writes: Accumulator] [Flags: NZ]
	adc $AEAE.w		; 6D AE AE ; Add $AEAE.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sbc $6676.w,Y		; F9 76 66 ; Subtract with carry $6676.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ror $E7.b,X		; 76 E7 ; Rotate right $E7.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $6777.w,X		; 1D 77 67 ; OR accumulator with memory $6777.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpx $71.b		; E4 71 ; Compare $71.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	ldx $6778.w		; AE 78 67 ; Load $6778.w into X register [Writes: X Index] [Flags: NZ]
	adc [$08.b]		; 67 08 ; Add with carry (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	stz $E4.b		; 64 E4 ; Store zero to $E4.b
	ror $77.b,X		; 76 77 ; Rotate right $77.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	adc [$9E.b]		; 67 9E ; Add with carry (long) [$9E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc #$E464.w		; 69 64 E4 ; Add #$E464.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	lsr $76.b,X		; 56 76 ; Logical shift right $76.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc [$E6.b]		; E7 E6 ; Subtract with carry (long) [$E6.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$5A.b]		; E7 5A ; Subtract with carry (long) [$5A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ror $67.b		; 66 67 ; Rotate right $67.b [Reads: Direct Page] [Flags: NCZ]
	sbc [$AE.b]		; E7 AE ; Subtract with carry (long) [$AE.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc #$6697.w		; 69 97 66 ; Add #$6697.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	adc $97.b		; 65 97 ; Add $97.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta [$9C.b],Y		; 97 9C ; Store accumulator (long indexed) [$9C.b],Y [Reads: Direct Page, Y Index, Accumulator]
	asl $55.b		; 06 55 ; Arithmetic shift left $55.b [Reads: Direct Page] [Flags: NCZ]
	eor ($66.b),Y		; 51 66 ; Exclusive OR accumulator with memory ($66.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $65.b		; 65 65 ; Add $65.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $11.b		; E5 11 ; Subtract $11.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($06.b),Y		; 11 06 ; OR accumulator with memory ($06.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $AEAE.w,X		; 1E AE AE ; Arithmetic shift left $AEAE.w,X [Reads: X Index] [Flags: NCZ]
	ora ($66.b)		; 12 66 ; OR accumulator with memory (indirect) ($66.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldx $C983.w		; AE 83 C9 ; Load $C983.w into X register [Writes: X Index] [Flags: NZ]
	cmp ($61.b)		; D2 61 ; Compare accumulator (indirect) ($61.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	brk $AE.b		; 00 AE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx $571C.w		; AE 1C 57 ; Load $571C.w into X register [Writes: X Index] [Flags: NZ]
	ror $22.b		; 66 22 ; Rotate right $22.b [Reads: Direct Page] [Flags: NCZ]
	ldx $D3AE.w		; AE AE D3 ; Load $D3AE.w into X register [Writes: X Index] [Flags: NZ]
	sta $66.b		; 85 66 ; Store accumulator to $66.b [Reads: Accumulator]
	ora $71.b,S		; 03 71 ; OR accumulator with stack relative $71.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($DB.b,X)		; 01 DB ; Logical OR ($DB.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $790201.l,X		; 1F 01 02 79 ; Logical OR long $790201.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dec $58B7.w		; CE B7 58 ; Decrement $58B7.w [Flags: NZ]
	.db $10, $61		; 10 61 ; Branch if plus to $10, $61 [Flow: branch]
	adc $34AE.w,X		; 7D AE 34 ; Add $34AE.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $0176.w		; 0E 76 01 ; Arithmetic shift left $0176.w [Flags: NCZ]
	sbc $DB58.w,Y		; F9 58 DB ; Subtract with carry $DB58.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($11.b,S),Y		; 53 11 ; XOR accumulator (stack relative indirect indexed) ($11.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($71.b,X)		; 01 71 ; Logical OR ($71.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ldx $5BAE.w		; AE AE 5B ; Load $5BAE.w into X register [Writes: X Index] [Flags: NZ]
	asl $61.b		; 06 61 ; Arithmetic shift left $61.b [Reads: Direct Page] [Flags: NCZ]
	bit $66.b,X		; 34 66 ; Test bits $66.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ldx $01DA.w		; AE DA 01 ; Load $01DA.w into X register [Writes: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ldx $34AE.w		; AE AE 34 ; Load $34AE.w into X register [Writes: X Index] [Flags: NZ]
	adc $66.b,X		; 75 66 ; Add $66.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $83.b,S		; 03 83 ; OR accumulator with stack relative $83.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	ora $347211.l		; 0F 11 72 34 ; OR accumulator with memory (long) $347211.l [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $42, $E6		; 42 E6 ; Reserved instruction
	ora ($52.b,X)		; 01 52 ; Logical OR ($52.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $AB.b		; 05 AB ; Logical OR $AB.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	stx $05.b,Y		; 96 05 ; Store X register $05.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	.db $10, $51		; 10 51 ; Branch if plus to $10, $51 [Flow: branch]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $216207.l		; 0F 07 62 21 ; OR accumulator with memory (long) $216207.l [Writes: Accumulator] [Flags: NZ]
	asl $65.b		; 06 65 ; Arithmetic shift left $65.b [Reads: Direct Page] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sta [$11.b],Y		; 97 11 ; Store accumulator (long indexed) [$11.b],Y [Reads: Direct Page, Y Index, Accumulator]
	and $97.b		; 25 97 ; Logical AND $97.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldx $AB18.w		; AE 18 AB ; Load $AB18.w into X register [Writes: X Index] [Flags: NZ]
	lsr $20.b,X		; 56 20 ; Logical shift right $20.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ldx $C2C2.w		; AE C2 C2 ; Load $C2C2.w into X register [Writes: X Index] [Flags: NZ]
	ldx $1661.w		; AE 61 16 ; Load $1661.w into X register [Writes: X Index] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	ldx $34AB.w		; AE AB 34 ; Load $34AB.w into X register [Writes: X Index] [Flags: NZ]
	ror $00.b		; 66 00 ; Rotate right $00.b [Reads: Direct Page] [Flags: NCZ]
	cmp ($EF.b)		; D2 EF ; Compare accumulator (indirect) ($EF.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ror $1E.b		; 66 1E ; Rotate right $1E.b [Reads: Direct Page] [Flags: NCZ]
	jsl $80C212.l		; 22 12 C2 80 ; Jump to subroutine long $80C212.l [Writes: Stack Pointer] [Flow: call]
	cmp $17C7.w		; CD C7 17 ; Compare $17C7.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsl $66EFDD.l		; 22 DD EF 66 ; Jump to subroutine long $66EFDD.l [Writes: Stack Pointer] [Flow: call]
	adc $22.b		; 65 22 ; Add $22.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($66.b),Y		; 11 66 ; OR accumulator with memory ($66.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	cmp [$81.b]		; C7 81 ; Compare accumulator (long) [$81.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora ($27.b)		; 12 27 ; OR accumulator with memory (indirect) ($27.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $7F.b		; 65 7F ; Add $7F.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ldx #$177E.w		; A2 7E 17 ; Load #$177E.w into X register [Writes: X Index] [Flags: NZ]
	adc ($57.b,X)		; 61 57 ; Add with carry ($57.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp [$C7.b]		; C7 C7 ; Compare accumulator (long) [$C7.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	inc CGDATA.w		; EE 22 21 ; Increment CGDATA.w [Flags: NZ]
	sta $7E.b		; 85 7E ; Store accumulator to $7E.b [Reads: Accumulator]
	cmp ($D1.b),Y		; D1 D1 ; Compare accumulator ($D1.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	and ($00.b),Y		; 31 00 ; AND accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	dec $C7.b		; C6 C7 ; Decrement $C7.b [Reads: Direct Page] [Flags: NZ]
	jsr $0253.w		; 20 53 02 ; Jump to subroutine at $0253.w [Writes: Stack Pointer] [Flow: call]
	and ($87.b,X)		; 21 87 ; Logical AND ($87.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta [$42.b]		; 87 42 ; Store accumulator (long) [$42.b] [Reads: Direct Page, Accumulator]
	eor [$33.b],Y		; 57 33 ; Exclusive OR accumulator with memory (long indexed) [$33.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor ($EE.b)		; 52 EE ; Exclusive OR accumulator with memory (indirect) ($EE.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $F1.b,S		; 83 F1 ; Store accumulator (stack relative) $F1.b,S [Reads: Stack Pointer, Accumulator]
	cmp $2217.w		; CD 17 22 ; Compare $2217.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	inc $2034.w		; EE 34 20 ; Increment $2034.w [Flags: NZ]
	eor ($05.b),Y		; 51 05 ; Exclusive OR accumulator with memory ($05.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsr $ED87.w		; 20 87 ED ; Jump to subroutine at $ED87.w [Writes: Stack Pointer] [Flow: call]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	eor ($21.b,S),Y		; 53 21 ; XOR accumulator (stack relative indirect indexed) ($21.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $08.b,S		; A3 08 ; Load accumulator (stack relative) $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $C6.b		; E6 C6 ; Increment $C6.b [Reads: Direct Page] [Flags: NZ]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $42, $E4		; 42 E4 ; Reserved instruction
	cpx $EC.b		; E4 EC ; Compare $EC.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	lsr $62.b,X		; 56 62 ; Logical shift right $62.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	inc $CD.b		; E6 CD ; Increment $CD.b [Reads: Direct Page] [Flags: NZ]
	inc $25.b		; E6 25 ; Increment $25.b [Reads: Direct Page] [Flags: NZ]
	jsl $EC2823.l		; 22 23 28 EC ; Jump to subroutine long $EC2823.l [Writes: Stack Pointer] [Flow: call]
	inc $E7.b		; E6 E7 ; Increment $E7.b [Reads: Direct Page] [Flags: NZ]
	and ($22.b)		; 32 22 ; AND accumulator with memory (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $E1.b		; 05 E1 ; Logical OR $E1.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rep #$0C		; C2 0C ; Reset processor status bits #$0C [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	and ($33.b)		; 32 33 ; AND accumulator with memory (indirect) ($33.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	cpx #$9796.w		; E0 96 97 ; Compare #$9796.w with X register [Reads: X Index] [Flags: NCZ]
	and ($55.b)		; 32 55 ; AND accumulator with memory (indirect) ($55.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	inc $E6.b		; E6 E6 ; Increment $E6.b [Reads: Direct Page] [Flags: NZ]
	lda ($62.b),Y		; B1 62 ; Load accumulator ($62.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $9C5865.l		; 22 65 58 9C ; Jump to subroutine long $9C5865.l [Writes: Stack Pointer] [Flow: call]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($57.b),Y		; 11 57 ; OR accumulator with memory ($57.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc #$C907.w		; 69 07 C9 ; Add #$C907.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $61.b		; 85 61 ; Store accumulator to $61.b [Reads: Accumulator]
	ora ($CD.b,X)		; 01 CD ; Logical OR ($CD.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $D9.b		; E5 D9 ; Subtract $D9.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc #$2121.w		; E9 21 21 ; Subtract #$2121.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cmp $D6E4.w,X		; DD E4 D6 ; Compare accumulator $D6E4.w,X [Reads: X Index] [Flags: NCZ]
	cmp ($22.b)		; D2 22 ; Compare accumulator (indirect) ($22.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	jsl $C7F6EF.l		; 22 EF F6 C7 ; Jump to subroutine long $C7F6EF.l [Writes: Stack Pointer] [Flow: call]
	and $2122.w		; 2D 22 21 ; Logical AND $2122.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $CD		; D0 CD ; Branch if not equal to $D0, $CD [Flow: branch]
	cmp $2602A2.l,X		; DF A2 02 26 ; Compare accumulator (long,X) $2602A2.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	cpx $C7.b		; E4 C7 ; Compare $C7.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	cmp $22C7.w,Y		; D9 C7 22 ; Compare accumulator $22C7.w,Y [Reads: Y Index] [Flags: NCZ]
	jsl $9005FF.l		; 22 FF 05 90 ; Jump to subroutine long $9005FF.l [Writes: Stack Pointer] [Flow: call]
	sbc ($21.b,X)		; E1 21 ; Subtract with carry ($21.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $0205E1.l		; 22 E1 05 02 ; Jump to subroutine long $0205E1.l [Writes: Stack Pointer] [Flow: call]
	inc $21.b		; E6 21 ; Increment $21.b [Reads: Direct Page] [Flags: NZ]
	and ($C4.b)		; 32 C4 ; AND accumulator with memory (indirect) ($C4.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $8E.b		; E6 8E ; Increment $8E.b [Reads: Direct Page] [Flags: NZ]
	sta $7702.w		; 8D 02 77 ; Store accumulator to $7702.w [Reads: Accumulator]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tsb $E1E1.w		; 0C E1 E1 ; Test and set bits $E1E1.w [Reads: Accumulator] [Flags: Z]
	adc ($22.b,S),Y		; 73 22 ; Add with carry (stack relative indirect indexed) ($22.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $90, $91		; 90 91 ; Branch if carry clear to $90, $91 [Flow: branch]
	sta ($E6.b)		; 92 E6 ; Store accumulator (indirect) ($E6.b) [Reads: Direct Page, Accumulator]
	and [$72.b]		; 27 72 ; AND accumulator with memory (long) [$72.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $E6EC.w		; 8D EC E6 ; Store accumulator to $E6EC.w [Reads: Accumulator]
	dec $72.b		; C6 72 ; Decrement $72.b [Reads: Direct Page] [Flags: NZ]
	jsr $0785.w		; 20 85 07 ; Jump to subroutine at $0785.w [Writes: Stack Pointer] [Flow: call]
	sta $319F.w,X		; 9D 9F 31 ; Store accumulator to $319F.w,X [Reads: Accumulator, X Index]
	adc [$9E.b],Y		; 77 9E ; Add with carry (long indexed) [$9E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy #$A3A2.w		; A0 A2 A3 ; Load #$A3A2.w into Y register [Writes: Y Index] [Flags: NZ]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $A7.b		; A5 A7 ; Load $A7.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldx $AF.b		; A6 AF ; Load $AF.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lda ($B0.b),Y		; B1 B0 ; Load accumulator ($B0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda ($AD.b)		; B2 AD ; Load accumulator (indirect) ($AD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lda ($B5.b,S),Y		; B3 B5 ; Load accumulator (stack relative indirect indexed) ($B5.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda ($B6.b,X)		; A1 B6 ; Load accumulator ($B6.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lda [$C0.b]		; A7 C0 ; Load accumulator (long) [$C0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp ($B2.b,X)		; C1 B2 ; Compare accumulator ($B2.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $C3.b,S		; C3 C3 ; Compare accumulator (stack relative) $C3.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	cpy $AD.b		; C4 AD ; Compare $AD.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $9E.b,S		; C3 9E ; Compare accumulator (stack relative) $9E.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	lda ($AD.b,X)		; A1 AD ; Load accumulator ($AD.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$C6C6.w		; C0 C6 C6 ; Compare #$C6C6.w with Y register [Reads: Y Index] [Flags: NCZ]
	dec $77.b		; C6 77 ; Decrement $77.b [Reads: Direct Page] [Flags: NZ]
	adc [$C6.b],Y		; 77 C6 ; Add with carry (long indexed) [$C6.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $B0.b		; C6 B0 ; Decrement $B0.b [Reads: Direct Page] [Flags: NZ]
	lda $7777.w		; AD 77 77 ; Load $7777.w into accumulator [Writes: Accumulator] [Flags: NZ]
	lda $9DB5.w		; AD B5 9D ; Load $9DB5.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp $77.b,X		; D5 77 ; Compare accumulator $77.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	adc [$D7.b],Y		; 77 D7 ; Add with carry (long indexed) [$D7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $DAD0.w,Y		; D9 D0 DA ; Compare accumulator $DAD0.w,Y [Reads: Y Index] [Flags: NCZ]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta [$A6.b],Y		; 97 A6 ; Store accumulator (long indexed) [$A6.b],Y [Reads: Direct Page, Y Index, Accumulator]
	lda $7777C5.l,X		; BF C5 77 77 ; Load long $7777C5.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc #$EDEB.w		; E9 EB ED ; Subtract #$EDEB.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cpy $77.b		; C4 77 ; Compare $77.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	adc [$F0.b],Y		; 77 F0 ; Add with carry (long indexed) [$F0.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp [$D9.b],Y		; D7 D9 ; Compare accumulator (long indexed) [$D9.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	sbc ($77.b),Y		; F1 77 ; Subtract with carry ($77.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc [$A6.b],Y		; 77 A6 ; Add with carry (long indexed) [$A6.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($A2.b)		; F2 A2 ; Subtract with carry (indirect) ($A2.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $FD7277.l		; 0F 77 72 FD ; OR accumulator with memory (long) $FD7277.l [Writes: Accumulator] [Flags: NZ]
	sbc $77F801.l,X		; FF 01 F8 77 ; Subtract with carry (long,X) $77F801.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta [$BD.b]		; 87 BD ; Store accumulator (long) [$BD.b] [Reads: Direct Page, Accumulator]
	cpy #$D302.w		; C0 02 D3 ; Compare #$D302.w with Y register [Reads: Y Index] [Flags: NCZ]
	adc [$87.b],Y		; 77 87 ; Add with carry (long indexed) [$87.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $F0.b,S		; 03 F0 ; OR accumulator with stack relative $F0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $870F.w		; AD 0F 87 ; Load $870F.w into accumulator [Writes: Accumulator] [Flags: NZ]
	adc ($04.b)		; 72 04 ; Add with carry (indirect) ($04.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	dec $F8.b		; C6 F8 ; Decrement $F8.b [Reads: Direct Page] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	adc [$F3.b],Y		; 77 F3 ; Add with carry (long indexed) [$F3.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $D9.b		; C6 D9 ; Decrement $D9.b [Reads: Direct Page] [Flags: NZ]
	lda $7777.w		; AD 77 77 ; Load $7777.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp ($B0.b,X)		; C1 B0 ; Compare accumulator ($B0.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	sbc ($DA.b)		; F2 DA ; Subtract with carry (indirect) ($DA.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc [$70.b],Y		; 77 70 ; Add with carry (long indexed) [$70.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	dec $0E.b		; C6 0E ; Decrement $0E.b [Reads: Direct Page] [Flags: NZ]
	dec $07.b		; C6 07 ; Decrement $07.b [Reads: Direct Page] [Flags: NZ]
	sta [$0F.b]		; 87 0F ; Store accumulator (long) [$0F.b] [Reads: Direct Page, Accumulator]
	ora ($D4.b),Y		; 11 D4 ; OR accumulator with memory ($D4.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $88.b		; C5 88 ; Compare $88.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	adc [$DA.b],Y		; 77 DA ; Add with carry (long indexed) [$DA.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $07C6DA.l		; CF DA C6 07 ; Compare accumulator (long) $07C6DA.l [Reads: Accumulator] [Flags: NCZ]
	adc [$F8.b],Y		; 77 F8 ; Add with carry (long indexed) [$F8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy $B0.b,X		; B4 B0 ; Load Y register $B0.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	dec $77.b,X		; D6 77 ; Decrement memory $77.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	adc [$D8.b],Y		; 77 D8 ; Add with carry (long indexed) [$D8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	lda $77AD.w		; AD AD 77 ; Load $77AD.w into accumulator [Writes: Accumulator] [Flags: NZ]
	adc [$DB.b],Y		; 77 DB ; Add with carry (long indexed) [$DB.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp #$D8AD.w		; C9 AD D8 ; Compare #$D8AD.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $A5A9.w,Y		; B9 A9 A5 ; Load $A5A9.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$7777.w		; C0 77 77 ; Compare #$7777.w with Y register [Reads: Y Index] [Flags: NCZ]
	dec $17.b,X		; D6 17 ; Decrement memory $17.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	adc [$9D.b],Y		; 77 9D ; Add with carry (long indexed) [$9D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $C6.b,X		; D5 C6 ; Compare accumulator $C6.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cmp $77.b,S		; C3 77 ; Compare accumulator (stack relative) $77.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	adc [$97.b],Y		; 77 97 ; Add with carry (long indexed) [$97.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	sbc $78771A.l		; EF 1A 77 78 ; Subtract with carry (long) $78771A.l [Writes: Accumulator] [Flags: NCVZ]
	lda $C610C9.l,X		; BF C9 10 C6 ; Load long $C610C9.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc [$87.b],Y		; 77 87 ; Add with carry (long indexed) [$87.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($C3.b),Y		; 11 C3 ; OR accumulator with memory ($C3.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda $A6.b		; A5 A6 ; Load $A6.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta [$77.b]		; 87 77 ; Store accumulator (long) [$77.b] [Reads: Direct Page, Accumulator]
	ora $C62221.l,X		; 1F 21 22 C6 ; Logical OR long $C62221.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta [$24.b]		; 87 24 ; Store accumulator (long) [$24.b] [Reads: Direct Page, Accumulator]
	rol $B6.b		; 26 B6 ; Rotate left $B6.b [Reads: Direct Page] [Flags: NCZ]
	and [$88.b]		; 27 88 ; AND accumulator with memory (long) [$88.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cmp $AD.b,S		; C3 AD ; Compare accumulator (stack relative) $AD.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	.db $B0, $C6		; B0 C6 ; Branch if carry set to $B0, $C6 [Flow: branch]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	ldx $77.b		; A6 77 ; Load $77.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	sta [$31.b]		; 87 31 ; Store accumulator (long) [$31.b] [Reads: Direct Page, Accumulator]
	and ($C6.b,S),Y		; 33 C6 ; AND accumulator (stack relative indirect indexed) ($C6.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $88.b,X		; 34 88 ; Test bits $88.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	and $37.b,X		; 35 37 ; Logical AND $37.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	rol $38.b,X		; 36 38 ; Rotate left $38.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cmp $C6C6.w,Y		; D9 C6 C6 ; Compare accumulator $C6C6.w,Y [Reads: Y Index] [Flags: NCZ]
	sta $A37077.l,X		; 9F 77 70 A3 ; Store accumulator (long,X) $A37077.l,X [Reads: Accumulator, X Index]
	bit $B0D9.w,X		; 3C D9 B0 ; Test bits $B0D9.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	adc [$C5.b],Y		; 77 C5 ; Add with carry (long indexed) [$C5.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $2D.b		; C6 2D ; Decrement $2D.b [Reads: Direct Page] [Flags: NZ]
	dec $77.b		; C6 77 ; Decrement $77.b [Reads: Direct Page] [Flags: NZ]
	sta [$C6.b]		; 87 C6 ; Store accumulator (long) [$C6.b] [Reads: Direct Page, Accumulator]
	dec $3C.b		; C6 3C ; Decrement $3C.b [Reads: Direct Page] [Flags: NZ]
	rol $77.b,X		; 36 77 ; Rotate left $77.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $80, $41		; 80 41 ; Branch always to $80, $41 [Flow: branch]
	cmp $C9A4.w,Y		; D9 A4 C9 ; Compare accumulator $C9A4.w,Y [Reads: Y Index] [Flags: NCZ]
	sta [$77.b]		; 87 77 ; Store accumulator (long) [$77.b] [Reads: Direct Page, Accumulator]
	cmp [$C6.b]		; C7 C6 ; Compare accumulator (long) [$C6.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($44.b,X)		; 41 44 ; Exclusive OR accumulator with memory ($44.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $B4.b,S		; 03 B4 ; OR accumulator with stack relative $B4.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta [$D5.b]		; 87 D5 ; Store accumulator (long) [$D5.b] [Reads: Direct Page, Accumulator]
	cmp $4702.w,Y		; D9 02 47 ; Compare accumulator $4702.w,Y [Reads: Y Index] [Flags: NCZ]
	adc [$88.b],Y		; 77 88 ; Add with carry (long indexed) [$88.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	.db $D0, $D0		; D0 D0 ; Branch if not equal to $D0, $D0 [Flow: branch]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta [$F0.b],Y		; 97 F0 ; Store accumulator (long indexed) [$F0.b],Y [Reads: Direct Page, Y Index, Accumulator]
	lda $77C2.w		; AD C2 77 ; Load $77C2.w into accumulator [Writes: Accumulator] [Flags: NZ]
	adc [$C6.b],Y		; 77 C6 ; Add with carry (long indexed) [$C6.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $A5A6.w		; 0D A6 A5 ; Logical OR $A5A6.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	adc [$BF.b],Y		; 77 BF ; Add with carry (long indexed) [$BF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$C211.w		; C0 11 C2 ; Compare #$C211.w with Y register [Reads: Y Index] [Flags: NCZ]
	adc [$87.b],Y		; 77 87 ; Add with carry (long indexed) [$87.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $0D.b		; C6 0D ; Decrement $0D.b [Reads: Direct Page] [Flags: NZ]
	cmp $AD.b,S		; C3 AD ; Compare accumulator (stack relative) $AD.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	adc [$21.b],Y		; 77 21 ; Add with carry (long indexed) [$21.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $B3.b,S		; C3 B3 ; Compare accumulator (stack relative) $B3.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	cmp $87.b		; C5 87 ; Compare $87.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	adc [$F3.b],Y		; 77 F3 ; Add with carry (long indexed) [$F3.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $F8.b		; C6 F8 ; Decrement $F8.b [Reads: Direct Page] [Flags: NZ]
	lda ($77.b)		; B2 77 ; Load accumulator (indirect) ($77.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc [$F3.b],Y		; 77 F3 ; Add with carry (long indexed) [$F3.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $D9F8.w		; 0D F8 D9 ; Logical OR $D9F8.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	adc [$DA.b],Y		; 77 DA ; Add with carry (long indexed) [$DA.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $C6.b,S		; C3 C6 ; Compare accumulator (stack relative) $C6.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $B4AD.w,Y		; D9 AD B4 ; Compare accumulator $B4AD.w,Y [Reads: Y Index] [Flags: NCZ]
	and ($77.b,X)		; 21 77 ; Logical AND ($77.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cmp $C6.b,S		; C3 C6 ; Compare accumulator (stack relative) $C6.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	dec $41.b		; C6 41 ; Decrement $41.b [Reads: Direct Page] [Flags: NZ]
	adc [$78.b],Y		; 77 78 ; Add with carry (long indexed) [$78.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $41.b		; 45 41 ; Exclusive OR $41.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $AD.b,X		; D5 AD ; Compare accumulator $AD.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	adc [$0D.b],Y		; 77 0D ; Add with carry (long indexed) [$0D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr $0D.b		; 46 0D ; Logical shift right $0D.b [Reads: Direct Page] [Flags: NCZ]
	lda ($88.b)		; B2 88 ; Load accumulator (indirect) ($88.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta [$AD.b]		; 87 AD ; Store accumulator (long) [$AD.b] [Reads: Direct Page, Accumulator]
	sed		; F8 ; Set decimal flag [Flags: D]
	asl $7711.w,X		; 1E 11 77 ; Arithmetic shift left $7711.w,X [Reads: X Index] [Flags: NCZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dec $C7.b		; C6 C7 ; Decrement $C7.b [Reads: Direct Page] [Flags: NZ]
	dec $B3.b		; C6 B3 ; Decrement $B3.b [Reads: Direct Page] [Flags: NZ]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	ora $001B.w		; 0D 1B 00 ; Logical OR $001B.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($F7.b)		; 12 F7 ; OR accumulator with memory (indirect) ($F7.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $1B.b,X		; 34 1B ; Test bits $1B.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	jsr $3415.w		; 20 15 34 ; Jump to subroutine at $3415.w [Writes: Stack Pointer] [Flow: call]
	bit $0D.b,X		; 34 0D ; Test bits $0D.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	ora ($57.b,X)		; 01 57 ; Logical OR ($57.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor [$5E.b],Y		; 57 5E ; Exclusive OR accumulator with memory (long indexed) [$5E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $578888.l,X		; 5F 88 88 57 ; Exclusive OR accumulator with memory (long,X) $578888.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $61.b,X		; 55 61 ; Exclusive OR accumulator with memory $61.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($88.b),Y		; 51 88 ; Exclusive OR accumulator with memory ($88.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ora [$17.b],Y		; 17 17 ; OR accumulator with memory (long indexed) [$17.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	ora ($88.b),Y		; 11 88 ; OR accumulator with memory ($88.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $62, $5C, $5C		; 62 5C 5C ; Push effective relative address $62, $5C, $5C [Writes: Stack Pointer]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	eor ($23.b),Y		; 51 23 ; Exclusive OR accumulator with memory ($23.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	rol $51.b		; 26 51 ; Rotate left $51.b [Reads: Direct Page] [Flags: NCZ]
	sta ($18.b,X)		; 81 18 ; Store accumulator ($18.b,X) [Reads: Direct Page, Accumulator, X Index]
	eor ($1C.b)		; 52 1C ; Exclusive OR accumulator with memory (indirect) ($1C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and [$6B.b]		; 27 6B ; AND accumulator with memory (long) [$6B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($18.b,X)		; 81 18 ; Store accumulator ($18.b,X) [Reads: Direct Page, Accumulator, X Index]
	ror $57.b		; 66 57 ; Rotate right $57.b [Reads: Direct Page] [Flags: NCZ]
	adc [$6D.b]		; 67 6D ; Add with carry (long) [$6D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	adc ($73.b)		; 72 73 ; Add with carry (indirect) ($73.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	stz $38.b,X		; 74 38 ; Store zero to $38.b,X [Reads: X Index]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($38.b,X)		; 81 38 ; Store accumulator ($38.b,X) [Reads: Direct Page, Accumulator, X Index]
	sec		; 38 ; Set carry flag [Flags: C]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	adc $8811.w,Y		; 79 11 88 ; Add $8811.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jmp ($847D.w,X)		; 7C 7D 84 ; Jump indirect indexed to ($847D.w,X) [Reads: X Index] [Flow: jump]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ror $5271.w,X		; 7E 71 52 ; Rotate right $5271.w,X [Reads: X Index] [Flags: NCZ]
	eor [$88.b],Y		; 57 88 ; Exclusive OR accumulator with memory (long indexed) [$88.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	eor $61.b,X		; 55 61 ; Exclusive OR accumulator with memory $61.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc $888858.l,X		; 7F 58 88 88 ; Add long $888858.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cmp #$54C9.w		; C9 C9 54 ; Compare #$54C9.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	bit #$5257.w		; 89 57 52 ; Test bits #$5257.w with accumulator [Reads: Accumulator] [Flags: Z]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	eor ($28.b)		; 52 28 ; Exclusive OR accumulator with memory (indirect) ($28.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor ($8B.b,S),Y		; 53 8B ; XOR accumulator (stack relative indirect indexed) ($8B.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta ($88.b,X)		; 81 88 ; Store accumulator ($88.b,X) [Reads: Direct Page, Accumulator, X Index]
	ror $8C8C.w,X		; 7E 8C 8C ; Rotate right $8C8C.w,X [Reads: X Index] [Flags: NCZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	adc $1C5852.l,X		; 7F 52 58 1C ; Add long $1C5852.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($28.b,X)		; 81 28 ; Store accumulator ($28.b,X) [Reads: Direct Page, Accumulator, X Index]
	eor ($8B.b,S),Y		; 53 8B ; XOR accumulator (stack relative indirect indexed) ($8B.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $80, $18		; 80 18 ; Branch always to $80, $18 [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $50, $51		; 50 51 ; Branch if overflow clear to $50, $51 [Flow: branch]
	lsr $8890.w,X		; 5E 90 88 ; Logical shift right $8890.w,X [Reads: X Index] [Flags: NCZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	adc ($52.b),Y		; 71 52 ; Add with carry ($52.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($6F.b)		; 52 6F ; Exclusive OR accumulator with memory (indirect) ($6F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($53.b)		; 92 53 ; Store accumulator (indirect) ($53.b) [Reads: Direct Page, Accumulator]
	cpy $8153.w		; CC 53 81 ; Compare $8153.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora ($A4.b,X)		; 01 A4 ; Logical OR ($A4.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda $A5A5.w		; AD A5 A5 ; Load $A5A5.w into accumulator [Writes: Accumulator] [Flags: NZ]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $85.b		; A5 85 ; Load $85.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sty $34.b,X		; 94 34 ; Store Y register $34.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $80, $A5		; 80 A5 ; Branch always to $80, $A5 [Flow: branch]
	sta ($A5.b,S),Y		; 93 A5 ; Store accumulator (stack relative indirect indexed) ($A5.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	ldy $1018.w		; AC 18 10 ; Load $1018.w into Y register [Writes: Y Index] [Flags: NZ]
	bit $61.b,X		; 34 61 ; Test bits $61.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sta $57.b		; 85 57 ; Store accumulator to $57.b [Reads: Accumulator]
	ora ($88.b,X)		; 01 88 ; Logical OR ($88.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	adc $A7A696.l		; 6F 96 A6 A7 ; Add with carry (long) $A7A696.l [Writes: Accumulator] [Flags: NCVZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	and [$88.b]		; 27 88 ; AND accumulator with memory (long) [$88.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($87.b,X)		; 81 87 ; Store accumulator ($87.b,X) [Reads: Direct Page, Accumulator, X Index]
	ror $5857.w		; 6E 57 58 ; Rotate right $5857.w [Flags: NCZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	lsr $B934.w,X		; 5E 34 B9 ; Logical shift right $B934.w,X [Reads: X Index] [Flags: NCZ]
	ldy #$8880.w		; A0 80 88 ; Load #$8880.w into Y register [Writes: Y Index] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ldy $8888.w,X		; BC 88 88 ; Load Y register $8888.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda ($BE.b)		; B2 BE ; Load accumulator (indirect) ($BE.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and [$88.b]		; 27 88 ; AND accumulator with memory (long) [$88.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($53.b,X)		; 81 53 ; Store accumulator ($53.b,X) [Reads: Direct Page, Accumulator, X Index]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	sec		; 38 ; Set carry flag [Flags: C]
	cmp #$1888.w		; C9 88 18 ; Compare #$1888.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	bit $CC.b,X		; 34 CC ; Test bits $CC.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cmp ($80.b,X)		; C1 80 ; Compare accumulator ($80.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $B0, $D0		; B0 D0 ; Branch if carry set to $B0, $D0 [Flow: branch]
	cmp ($D0.b)		; D2 D0 ; Compare accumulator (indirect) ($D0.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	lda ($D3.b)		; B2 D3 ; Load accumulator (indirect) ($D3.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $1E.b,X		; D5 1E ; Compare accumulator $1E.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($58.b,X)		; 81 58 ; Store accumulator ($58.b,X) [Reads: Direct Page, Accumulator, X Index]
	adc $E4E2.w,X		; 7D E2 E4 ; Add $E4E2.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	bit $E6.b,X		; 34 E6 ; Test bits $E6.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cld		; D8 ; Clear decimal flag [Flags: D]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	nop		; EA ; No operation
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cpx #$51ED.w		; E0 ED 51 ; Compare #$51ED.w with X register [Reads: X Index] [Flags: NCZ]
	adc $348888.l		; 6F 88 88 34 ; Add with carry (long) $348888.l [Writes: Accumulator] [Flags: NCVZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	.db $F0, $D3		; F0 D3 ; Branch if equal to $F0, $D3 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sta ($C3.b,X)		; 81 C3 ; Store accumulator ($C3.b,X) [Reads: Direct Page, Accumulator, X Index]
	sbc $D3C3.w,X		; FD C3 D3 ; Subtract with carry $D3C3.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($FE.b,X)		; 81 FE ; Store accumulator ($FE.b,X) [Reads: Direct Page, Accumulator, X Index]
	bit $58.b,X		; 34 58 ; Test bits $58.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $80.b,X		; 34 80 ; Test bits $80.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $80, $EE		; 80 EE ; Branch always to $80, $EE [Flow: branch]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	bit #$0899.w		; 89 99 08 ; Test bits #$0899.w with accumulator [Reads: Accumulator] [Flags: Z]
	asl $34.b		; 06 34 ; Arithmetic shift left $34.b [Reads: Direct Page] [Flags: NCZ]
	cmp #$0099.w		; C9 99 00 ; Compare #$0099.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp $93.b,X		; D5 93 ; Compare accumulator $93.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $AD.b,X		; 15 AD ; OR accumulator with memory $AD.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsr $36C7.w		; 20 C7 36 ; Jump to subroutine at $36C7.w [Writes: Stack Pointer] [Flow: call]
	lda $79.b		; A5 79 ; Load $79.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $A5.b,X		; 34 A5 ; Test bits $A5.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ldy $0106.w		; AC 06 01 ; Load $0106.w into Y register [Writes: Y Index] [Flags: NZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $F3.b,X		; 34 F3 ; Test bits $F3.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ldy $20.b		; A4 20 ; Load $20.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	.db $10, $85		; 10 85 ; Branch if plus to $10, $85 [Flow: branch]
	lda $94.b		; A5 94 ; Load $94.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	.db $80, $88		; 80 88 ; Branch always to $80, $88 [Flow: branch]
	eor ($50.b,S),Y		; 53 50 ; XOR accumulator (stack relative indirect indexed) ($50.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jmp ($8850.w)		; 6C 50 88 ; Jump indirect to ($8850.w) [Flow: jump]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	jmp $885C0B.l		; 5C 0B 5C 88 ; Jump long to $885C0B.l [Flow: jump]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $9550.w,X		; 5D 50 95 ; Exclusive OR accumulator with memory $9550.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	.db $80, $50		; 80 50 ; Branch always to $80, $50 [Flow: branch]
	asl $8988.w		; 0E 88 89 ; Arithmetic shift left $8988.w [Flags: NCZ]
	eor $81.b,X		; 55 81 ; Exclusive OR accumulator with memory $81.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	jmp ($8863.w)		; 6C 63 88 ; Jump indirect to ($8863.w) [Flow: jump]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	jmp $885050.l		; 5C 50 50 88 ; Jump long to $885050.l [Flow: jump]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	eor ($11.b,S),Y		; 53 11 ; XOR accumulator (stack relative indirect indexed) ($11.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	bit #$5051.w		; 89 51 50 ; Test bits #$5051.w with accumulator [Reads: Accumulator] [Flags: Z]
	.db $50, $67		; 50 67 ; Branch if overflow clear to $50, $67 [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	eor $5050.w,X		; 5D 50 50 ; Exclusive OR accumulator with memory $5050.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $8188.w,X		; 1D 88 81 ; OR accumulator with memory $8188.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $955852.l,X		; 5F 52 58 95 ; Exclusive OR accumulator with memory (long,X) $955852.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	eor $6C5A.w,Y		; 59 5A 6C ; Exclusive OR accumulator with memory $6C5A.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $50, $53		; 50 53 ; Branch if overflow clear to $50, $53 [Flow: branch]
	eor ($1E.b)		; 52 1E ; Exclusive OR accumulator with memory (indirect) ($1E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($53.b,X)		; 81 53 ; Store accumulator ($53.b,X) [Reads: Direct Page, Accumulator, X Index]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $82, $50, $88		; 82 50 88 ; Branch always long to $82, $50, $88 [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $50, $50		; 50 50 ; Branch if overflow clear to $50, $50 [Flow: branch]
	.db $50, $5E		; 50 5E ; Branch if overflow clear to $50, $5E [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $70, $31		; 70 31 ; Branch if overflow set to $70, $31 [Flow: branch]
	.db $50, $0D		; 50 0D ; Branch if overflow clear to $50, $0D [Flow: branch]
	sta ($89.b,X)		; 81 89 ; Store accumulator ($89.b,X) [Reads: Direct Page, Accumulator, X Index]
	bit $70.b		; 24 70 ; Test bits $70.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ror $77.b,X		; 76 77 ; Rotate right $77.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	adc [$D6.b],Y		; 77 D6 ; Add with carry (long indexed) [$D6.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	trb $884B.w		; 1C 4B 88 ; Test and reset bits $884B.w [Reads: Accumulator] [Flags: Z]
	and ($31.b,X)		; 21 31 ; Logical AND ($31.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ror $50.b		; 66 50 ; Rotate right $50.b [Reads: Direct Page] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit #$5050.w		; 89 50 50 ; Test bits #$5050.w with accumulator [Reads: Accumulator] [Flags: Z]
	adc $818824.l		; 6F 24 88 81 ; Add with carry (long) $818824.l [Writes: Accumulator] [Flags: NCVZ]
	eor $6E5D54.l		; 4F 54 5D 6E ; Exclusive OR accumulator with memory (long) $6E5D54.l [Writes: Accumulator] [Flags: NZ]
	ora ($88.b),Y		; 11 88 ; OR accumulator with memory ($88.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $816C88.l		; 6F 88 6C 81 ; Add with carry (long) $816C88.l [Writes: Accumulator] [Flags: NCVZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ror $5871.w		; 6E 71 58 ; Rotate right $5871.w [Flags: NCZ]
	sta [$88.b]		; 87 88 ; Store accumulator (long) [$88.b] [Reads: Direct Page, Accumulator]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $50, $0D		; 50 0D ; Branch if overflow clear to $50, $0D [Flow: branch]
	adc ($87.b),Y		; 71 87 ; Add with carry ($87.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	bit #$5088.w		; 89 88 50 ; Test bits #$5088.w with accumulator [Reads: Accumulator] [Flags: Z]
	.db $50, $53		; 50 53 ; Branch if overflow clear to $50, $53 [Flow: branch]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	jmp $7F5850.l		; 5C 50 58 7F ; Jump long to $7F5850.l [Flow: jump]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ora $5087.w		; 0D 87 50 ; Logical OR $5087.w with accumulator [Writes: Accumulator] [Flags: NZ]
	adc $8898.w		; 6D 98 88 ; Add $8898.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	dec $80.b		; C6 80 ; Decrement $80.b [Reads: Direct Page] [Flags: NZ]
	brk $C6.b		; 00 C6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	dec $00.b		; C6 00 ; Decrement $00.b [Reads: Direct Page] [Flags: NZ]
	brk $C6.b		; 00 C6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $58.b		; C6 58 ; Decrement $58.b [Reads: Direct Page] [Flags: NZ]
	bit #$8800.w		; 89 00 88 ; Test bits #$8800.w with accumulator [Reads: Accumulator] [Flags: Z]
	.db $80, $6D		; 80 6D ; Branch always to $80, $6D [Flow: branch]
	lsr $8817.w,X		; 5E 17 88 ; Logical shift right $8817.w,X [Reads: X Index] [Flags: NCZ]
	sta ($17.b,X)		; 81 17 ; Store accumulator ($17.b,X) [Reads: Direct Page, Accumulator, X Index]
	eor ($12.b,S),Y		; 53 12 ; XOR accumulator (stack relative indirect indexed) ($12.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc [$18.b]		; 67 18 ; Add with carry (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor ($53.b),Y		; 51 53 ; Exclusive OR accumulator with memory ($53.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor ($50.b,S),Y		; 53 50 ; XOR accumulator (stack relative indirect indexed) ($50.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	eor ($95.b,S),Y		; 53 95 ; XOR accumulator (stack relative indirect indexed) ($95.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	bit #$6B27.w		; 89 27 6B ; Test bits #$6B27.w with accumulator [Reads: Accumulator] [Flags: Z]
	eor ($84.b),Y		; 51 84 ; Exclusive OR accumulator with memory ($84.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	eor ($34.b),Y		; 51 34 ; Exclusive OR accumulator with memory ($34.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc ($5F.b),Y		; 71 5F ; Add with carry ($5F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $88		; 80 88 ; Branch always to $80, $88 [Flow: branch]
	eor ($7F.b)		; 52 7F ; Exclusive OR accumulator with memory (indirect) ($7F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor [$6E.b],Y		; 57 6E ; Exclusive OR accumulator with memory (long indexed) [$6E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	adc ($58.b),Y		; 71 58 ; Add with carry ($58.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $8918.w		; 0D 18 89 ; Logical OR $8918.w with accumulator [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cmp #$1E5E.w		; C9 5E 1E ; Compare #$1E5E.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	brk $81.b		; 00 81 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$5F.b],Y		; 17 5F ; OR accumulator with memory (long indexed) [$5F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit #$188A.w		; 89 8A 18 ; Test bits #$188A.w with accumulator [Reads: Accumulator] [Flags: Z]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ror $5F7E.w,X		; 7E 7E 5F ; Rotate right $5F7E.w,X [Reads: X Index] [Flags: NCZ]
	eor [$88.b],Y		; 57 88 ; Exclusive OR accumulator with memory (long indexed) [$88.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	ora [$17.b],Y		; 17 17 ; OR accumulator with memory (long indexed) [$17.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora [$81.b],Y		; 17 81 ; OR accumulator with memory (long indexed) [$81.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($35.b),Y		; 11 35 ; OR accumulator with memory ($35.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $53.b		; 85 53 ; Store accumulator to $53.b [Reads: Accumulator]
	eor ($08.b,S),Y		; 53 08 ; XOR accumulator (stack relative indirect indexed) ($08.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($A7.b),Y		; 11 A7 ; OR accumulator with memory ($A7.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $0C58.w		; 2C 58 0C ; Test bits $0C58.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	jsl $115789.l		; 22 89 57 11 ; Jump to subroutine long $115789.l [Writes: Stack Pointer] [Flow: call]
	.db $10, $12		; 10 12 ; Branch if plus to $10, $12 [Flow: branch]
	bit #$1F99.w		; 89 99 1F ; Test bits #$1F99.w with accumulator [Reads: Accumulator] [Flags: Z]
	ora $991F52.l,X		; 1F 52 1F 99 ; Logical OR long $991F52.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	bit #$5067.w		; 89 67 50 ; Test bits #$5067.w with accumulator [Reads: Accumulator] [Flags: Z]
	adc ($17.b)		; 72 17 ; Add with carry (indirect) ($17.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($53.b,X)		; 81 53 ; Store accumulator ($53.b,X) [Reads: Direct Page, Accumulator, X Index]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	asl $8188.w,X		; 1E 88 81 ; Arithmetic shift left $8188.w,X [Reads: X Index] [Flags: NCZ]
	eor ($50.b)		; 52 50 ; Exclusive OR accumulator with memory (indirect) ($50.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $50, $34		; 50 34 ; Branch if overflow clear to $50, $34 [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $80, $34		; 80 34 ; Branch always to $80, $34 [Flow: branch]
	ora $02535F.l		; 0F 5F 53 02 ; OR accumulator with memory (long) $02535F.l [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	and $71.b,S		; 23 71 ; AND accumulator with stack relative $71.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $63.b,X		; 34 63 ; Test bits $63.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($90.b,X)		; 01 90 ; Logical OR ($90.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $90, $18		; 90 18 ; Branch if carry clear to $90, $18 [Flow: branch]
	cpy $22.b		; C4 22 ; Compare $22.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	jsr $6A27.w		; 20 27 6A ; Jump to subroutine at $6A27.w [Writes: Stack Pointer] [Flow: call]
	sta [$C4.b]		; 87 C4 ; Store accumulator (long) [$C4.b] [Reads: Direct Page, Accumulator]
	ora ($80.b),Y		; 11 80 ; OR accumulator with memory ($80.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and [$ED.b]		; 27 ED ; AND accumulator with memory (long) [$ED.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc ($80.b),Y		; 71 80 ; Add with carry ($80.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($88.b),Y		; 91 88 ; Store accumulator ($88.b),Y [Reads: Direct Page, Y Index, Accumulator]
	and $532B.w,Y		; 39 2B 53 ; AND accumulator with memory $532B.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	and #$3418.w		; 29 18 34 ; Logical AND #$3418.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and ($CA.b)		; 32 CA ; AND accumulator with memory (indirect) ($CA.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $09.b,X		; 35 09 ; Logical AND $09.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$3837.w		; 09 37 38 ; Logical OR #$3837.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $9931.w,Y		; 39 31 99 ; AND accumulator with memory $9931.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta ($58.b),Y		; 91 58 ; Store accumulator ($58.b),Y [Reads: Direct Page, Y Index, Accumulator]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	mvp $34,$46		; 44 46 34 ; Move block positive $34,$46 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	bit $99.b,X		; 34 99 ; Test bits $99.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($50.b),Y		; 31 50 ; AND accumulator with memory ($50.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	clc		; 18 ; Clear carry flag [Flags: C]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	eor ($58.b),Y		; 51 58 ; Exclusive OR accumulator with memory ($58.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $1850.w,Y		; 59 50 18 ; Exclusive OR accumulator with memory $1850.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta [$86.b]		; 87 86 ; Store accumulator (long) [$86.b] [Reads: Direct Page, Accumulator]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $50, $59		; 50 59 ; Branch if overflow clear to $50, $59 [Flow: branch]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	tsb $8F72.w		; 0C 72 8F ; Test and set bits $8F72.w [Reads: Accumulator] [Flags: Z]
	sta ($98.b,X)		; 81 98 ; Store accumulator ($98.b,X) [Reads: Direct Page, Accumulator, X Index]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $82, $86, $50		; 82 86 50 ; Branch always long to $82, $86, $50 [Flow: branch]
	.db $F0, $88		; F0 88 ; Branch if equal to $F0, $88 [Flow: branch]
	sta [$97.b]		; 87 97 ; Store accumulator (long) [$97.b] [Reads: Direct Page, Accumulator]
	ora ($4E.b,S),Y		; 13 4E ; OR accumulator (stack relative indirect indexed) ($4E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $78.b		; C6 78 ; Decrement $78.b [Reads: Direct Page] [Flags: NZ]
	sta [$4F.b],Y		; 97 4F ; Store accumulator (long indexed) [$4F.b],Y [Reads: Direct Page, Y Index, Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	.db $B0, $43		; B0 43 ; Branch if carry set to $B0, $43 [Flow: branch]
	sta [$78.b],Y		; 97 78 ; Store accumulator (long indexed) [$78.b],Y [Reads: Direct Page, Y Index, Accumulator]
	sbc ($4E.b)		; F2 4E ; Subtract with carry (indirect) ($4E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	dec $78.b,X		; D6 78 ; Decrement memory $78.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	adc [$13.b],Y		; 77 13 ; Add with carry (long indexed) [$13.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($52.b),Y		; 31 52 ; AND accumulator with memory ($52.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and [$88.b],Y		; 37 88 ; AND accumulator with memory (long indexed) [$88.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and $C4C636.l		; 2F 36 C6 C4 ; AND accumulator with memory (long) $C4C636.l [Writes: Accumulator] [Flags: NZ]
	.db $80, $77		; 80 77 ; Branch always to $80, $77 [Flow: branch]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	lsr $7713.w		; 4E 13 77 ; Logical shift right $7713.w [Flags: NCZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dec $F0.b		; C6 F0 ; Decrement $F0.b [Reads: Direct Page] [Flags: NZ]
	dec $C6.b,X		; D6 C6 ; Decrement memory $C6.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr $F3C3.w		; 4E C3 F3 ; Logical shift right $F3C3.w [Flags: NCZ]
	ora $7887.w		; 0D 87 78 ; Logical OR $7887.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $C6		; D0 C6 ; Branch if not equal to $D0, $C6 [Flow: branch]
	dec $D0.b		; C6 D0 ; Decrement $D0.b [Reads: Direct Page] [Flags: NZ]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	lsr $57.b,X		; 56 57 ; Logical shift right $57.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	adc [$99.b],Y		; 77 99 ; Add with carry (long indexed) [$99.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($D4.b)		; F2 D4 ; Subtract with carry (indirect) ($D4.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ldy $D5.b,X		; B4 D5 ; Load Y register $D5.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta [$58.b],Y		; 97 58 ; Store accumulator (long indexed) [$58.b],Y [Reads: Direct Page, Y Index, Accumulator]
	ora ($41.b,S),Y		; 13 41 ; OR accumulator (stack relative indirect indexed) ($41.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $2188.w,Y		; 79 88 21 ; Add $2188.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lda ($AD.b)		; B2 AD ; Load accumulator (indirect) ($AD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $7787.w		; AD 87 77 ; Load $7787.w into accumulator [Writes: Accumulator] [Flags: NZ]
	lda ($97.b)		; B2 97 ; Load accumulator (indirect) ($97.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $C0.b		; A5 C0 ; Load $C0.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp $C0C4.w		; 4C C4 C0 ; Jump to $C0C4.w [Flow: jump]
	dec $87.b		; C6 87 ; Decrement $87.b [Reads: Direct Page] [Flags: NZ]
	adc [$A1.b],Y		; 77 A1 ; Add with carry (long indexed) [$A1.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	rep #$C3		; C2 C3 ; Reset processor status bits #$C3 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	adc [$79.b],Y		; 77 79 ; Add with carry (long indexed) [$79.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	lda $7797.w		; AD 97 77 ; Load $7797.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy $45.b,X		; B4 45 ; Load Y register $45.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	bit $97.b		; 24 97 ; Test bits $97.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sta [$C6.b]		; 87 C6 ; Store accumulator (long) [$C6.b] [Reads: Direct Page, Accumulator]
	dec $CF.b		; C6 CF ; Decrement $CF.b [Reads: Direct Page] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	lda $4B97.w		; AD 97 4B ; Load $4B97.w into accumulator [Writes: Accumulator] [Flags: NZ]
	adc [$79.b],Y		; 77 79 ; Add with carry (long indexed) [$79.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $B8F9AD.l		; CF AD F9 B8 ; Compare accumulator (long) $B8F9AD.l [Reads: Accumulator] [Flags: NCZ]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	lda $A7.b		; A5 A7 ; Load $A7.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pei ($87.b)		; D4 87 ; Push effective indirect address ($87.b) [Reads: Direct Page] [Writes: Stack Pointer]
	adc [$C6.b],Y		; 77 C6 ; Add with carry (long indexed) [$C6.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $C3.b,S		; C3 C3 ; Compare accumulator (stack relative) $C3.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	cmp $77.b,S		; C3 77 ; Compare accumulator (stack relative) $77.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	adc [$C4.b],Y		; 77 C4 ; Add with carry (long indexed) [$C4.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $C4.b,S		; C3 C4 ; Compare accumulator (stack relative) $C4.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	.db $B0, $77		; B0 77 ; Branch if carry set to $B0, $77 [Flow: branch]
	adc [$D0.b],Y		; 77 D0 ; Add with carry (long indexed) [$D0.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($1E.b,S),Y		; 13 1E ; OR accumulator (stack relative indirect indexed) ($1E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $78.b		; C6 78 ; Decrement $78.b [Reads: Direct Page] [Flags: NZ]
	sta [$F8.b]		; 87 F8 ; Store accumulator (long) [$F8.b] [Reads: Direct Page, Accumulator]
	lda [$C2.b]		; A7 C2 ; Load accumulator (long) [$C2.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dec $77.b		; C6 77 ; Decrement $77.b [Reads: Direct Page] [Flags: NZ]
	adc [$C6.b],Y		; 77 C6 ; Add with carry (long indexed) [$C6.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	ora $247277.l		; 0F 77 72 24 ; OR accumulator with memory (long) $247277.l [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	pei ($B4.b)		; D4 B4 ; Push effective indirect address ($B4.b) [Reads: Direct Page] [Writes: Stack Pointer]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	adc [$D5.b],Y		; 77 D5 ; Add with carry (long indexed) [$D5.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $2445.w,X		; 9D 45 24 ; Store accumulator to $2445.w,X [Reads: Accumulator, X Index]
	adc [$88.b],Y		; 77 88 ; Add with carry (long indexed) [$88.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	pei ($46.b)		; D4 46 ; Push effective indirect address ($46.b) [Reads: Direct Page] [Writes: Stack Pointer]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	sta [$88.b]		; 87 88 ; Store accumulator (long) [$88.b] [Reads: Direct Page, Accumulator]
	.db $F0, $AD		; F0 AD ; Branch if equal to $F0, $AD [Flow: branch]
	lda #$77C4.w		; A9 C4 77 ; Load #$77C4.w into accumulator [Writes: Accumulator] [Flags: NZ]
	adc [$C6.b],Y		; 77 C6 ; Add with carry (long indexed) [$C6.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $D0, $FA		; D0 FA ; Branch if not equal to $D0, $FA [Flow: branch]
	ora ($77.b)		; 12 77 ; OR accumulator with memory (indirect) ($77.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	lda #$2DC6.w		; A9 C6 2D ; Load #$2DC6.w into accumulator [Writes: Accumulator] [Flags: NZ]
	dec $77.b		; C6 77 ; Decrement $77.b [Reads: Direct Page] [Flags: NZ]
	sta [$DA.b]		; 87 DA ; Store accumulator (long) [$DA.b] [Reads: Direct Page, Accumulator]
	dec $4C.b		; C6 4C ; Decrement $4C.b [Reads: Direct Page] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	adc [$97.b],Y		; 77 97 ; Add with carry (long indexed) [$97.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	rep #$C3		; C2 C3 ; Reset processor status bits #$C3 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr $39DA.w		; 4E DA 39 ; Logical shift right $39DA.w [Flags: NCZ]
	eor $8987.w,X		; 5D 87 89 ; Exclusive OR accumulator with memory $8987.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1C.b,X		; 55 1C ; Exclusive OR accumulator with memory $1C.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lsr $98A3.w		; 4E A3 98 ; Logical shift right $98A3.w [Flags: NCZ]
	sta [$BE.b]		; 87 BE ; Store accumulator (long) [$BE.b] [Reads: Direct Page, Accumulator]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	inc $77.b		; E6 77 ; Increment $77.b [Reads: Direct Page] [Flags: NZ]
	adc [$C2.b],Y		; 77 C2 ; Add with carry (long indexed) [$C2.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr $943E.w,X		; 5E 3E 94 ; Logical shift right $943E.w,X [Reads: X Index] [Flags: NCZ]
	adc $9387.w,Y		; 79 87 93 ; Add $9387.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $18.b,X		; 36 18 ; Rotate left $18.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	lda $8770.w		; AD 70 87 ; Load $8770.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($5B.b,S),Y		; 93 5B ; Store accumulator (stack relative indirect indexed) ($5B.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$8779.w		; A9 79 87 ; Load #$8779.w into accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda #$773D.w		; A9 3D 77 ; Load #$773D.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	inc $605F.w		; EE 5F 60 ; Increment $605F.w [Flags: NZ]
	adc [$99.b],Y		; 77 99 ; Add with carry (long indexed) [$99.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr $9C9A.w		; 4E 9A 9C ; Logical shift right $9C9A.w [Flags: NCZ]
	eor #$7887.w		; 49 87 78 ; Exclusive OR #$7887.w with accumulator [Writes: Accumulator] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	lda $77AD.w		; AD AD 77 ; Load $77AD.w into accumulator [Writes: Accumulator] [Flags: NZ]
	adc [$C4.b],Y		; 77 C4 ; Add with carry (long indexed) [$C4.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($DB.b,S),Y		; 93 DB ; Store accumulator (stack relative indirect indexed) ($DB.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	cmp $77.b,S		; C3 77 ; Compare accumulator (stack relative) $77.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	adc [$C9.b],Y		; 77 C9 ; Add with carry (long indexed) [$C9.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $41.b		; C6 41 ; Decrement $41.b [Reads: Direct Page] [Flags: NZ]
	eor $77.b		; 45 77 ; Exclusive OR $77.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	lsr $4AC3.w		; 4E C3 4A ; Logical shift right $4AC3.w [Flags: NCZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ldy $78D0.w		; AC D0 78 ; Load $78D0.w into Y register [Writes: Y Index] [Flags: NZ]
	adc [$C6.b],Y		; 77 C6 ; Add with carry (long indexed) [$C6.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $CA.b,X		; 36 CA ; Rotate left $CA.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $70, $77		; 70 77 ; Branch if overflow set to $70, $77 [Flow: branch]
	lda [$C6.b]		; A7 C6 ; Load accumulator (long) [$C6.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $62, $A2, $77		; 62 A2 77 ; Push effective relative address $62, $A2, $77 [Writes: Stack Pointer]
	sta [$C6.b],Y		; 97 C6 ; Store accumulator (long indexed) [$C6.b],Y [Reads: Direct Page, Y Index, Accumulator]
	rol $C6.b,X		; 36 C6 ; Rotate left $C6.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	rol $70.b		; 26 70 ; Rotate left $70.b [Reads: Direct Page] [Flags: NCZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	dec $34.b		; C6 34 ; Decrement $34.b [Reads: Direct Page] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	lda $7778.w		; AD 78 77 ; Load $7778.w into accumulator [Writes: Accumulator] [Flags: NZ]
	rol $A7.b,X		; 36 A7 ; Rotate left $A7.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	eor $03.b		; 45 03 ; Exclusive OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$88.b]		; 07 88 ; OR accumulator with memory (long) [$88.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy $45.b,X		; B4 45 ; Load Y register $45.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	ora $9D.b,S		; 03 9D ; OR accumulator with stack relative $9D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sta [$25.b]		; 87 25 ; Store accumulator (long) [$25.b] [Reads: Direct Page, Accumulator]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora ($34.b)		; 12 34 ; OR accumulator with memory (indirect) ($34.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	brk $C4.b		; 00 C4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $64.b		; 65 64 ; Add $64.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ror $09.b		; 66 09 ; Rotate right $09.b [Reads: Direct Page] [Flags: NCZ]
	sta $6563.w,Y		; 99 63 65 ; Store accumulator to $6563.w,Y [Reads: Y Index, Accumulator]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	adc #$9919.w		; 69 19 99 ; Add #$9919.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	bit $63.b,X		; 34 63 ; Test bits $63.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	jmp ($016D.w)		; 6C 6D 01 ; Jump indirect to ($016D.w) [Flow: jump]
	sta $DDCA.w,Y		; 99 CA DD ; Store accumulator to $DDCA.w,Y [Reads: Y Index, Accumulator]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	ror $9900.w		; 6E 00 99 ; Rotate right $9900.w [Flags: NCZ]
	ror $6D.b		; 66 6D ; Rotate right $6D.b [Reads: Direct Page] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sta $C820.w,Y		; 99 20 C8 ; Store accumulator to $C820.w,Y [Reads: Y Index, Accumulator]
	adc ($3F.b,S),Y		; 73 3F ; Add with carry (stack relative indirect indexed) ($3F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $09		; 70 09 ; Branch if overflow set to $70, $09 [Flow: branch]
	and #$6B65.w		; 29 65 6B ; Logical AND #$6B65.w with accumulator [Writes: Accumulator] [Flags: NZ]
	dec $D5.b,X		; D6 D5 ; Decrement memory $D5.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	sta $3433.w,Y		; 99 33 34 ; Store accumulator to $3433.w,Y [Reads: Y Index, Accumulator]
	inc $DD.b		; E6 DD ; Increment $DD.b [Reads: Direct Page] [Flags: NZ]
	lda $00.b,S		; A3 00 ; Load accumulator (stack relative) $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($34.b,S),Y		; 33 34 ; AND accumulator (stack relative indirect indexed) ($34.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $026C34.l		; AF 34 6C 02 ; Load long $026C34.l into accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($CE.b,X)		; 01 CE ; Logical OR ($CE.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $CE.b,X		; 34 CE ; Test bits $CE.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $62.b		; 00 62 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $C9.b,X		; 35 C9 ; Logical AND $C9.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$0012.w		; C9 12 00 ; Compare #$0012.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	bit $8D.b		; 24 8D ; Test bits $8D.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	bit $21.b,X		; 34 21 ; Test bits $21.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cop $6C.b		; 02 6C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $61.b,X		; 94 61 ; Store Y register $61.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	sta $18.b,S		; 83 18 ; Store accumulator (stack relative) $18.b,S [Reads: Stack Pointer, Accumulator]
	ora ($C9.b),Y		; 11 C9 ; OR accumulator with memory ($C9.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	inc $7878.w,X		; FE 78 78 ; Increment memory $7878.w,X [Reads: X Index] [Flags: NZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	.db $50, $2C		; 50 2C ; Branch if overflow clear to $50, $2C [Flow: branch]
	and #$6C12.w		; 29 12 6C ; Logical AND #$6C12.w with accumulator [Writes: Accumulator] [Flags: NZ]
	eor $1164C9.l		; 4F C9 64 11 ; Exclusive OR accumulator with memory (long) $1164C9.l [Writes: Accumulator] [Flags: NZ]
	cop $7B.b		; 02 7B ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc [$20.b],Y		; 77 20 ; Add with carry (long indexed) [$20.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($29.b,X)		; 81 29 ; Store accumulator ($29.b,X) [Reads: Direct Page, Accumulator, X Index]
	and #$8C7E.w		; 29 7E 8C ; Logical AND #$8C7E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sty $22.b		; 84 22 ; Store Y register to $22.b [Reads: Y Index]
	and #$7886.w		; 29 86 78 ; Logical AND #$7886.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sty $9983.w		; 8C 83 99 ; Store Y register to $9983.w [Reads: Y Index]
	and ($7E.b,X)		; 21 7E ; Logical AND ($7E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	stx $88.b		; 86 88 ; Store X register to $88.b [Reads: X Index]
	and #$7822.w		; 29 22 78 ; Logical AND #$7822.w with accumulator [Writes: Accumulator] [Flags: NZ]
	stx $8C7C.w		; 8E 7C 8C ; Store X register to $8C7C.w [Reads: X Index]
	ora $1C92.w,Y		; 19 92 1C ; OR accumulator with memory $1C92.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta ($F2.b,X)		; 81 F2 ; Store accumulator ($F2.b,X) [Reads: Direct Page, Accumulator, X Index]
	sta ($22.b),Y		; 91 22 ; Store accumulator ($22.b),Y [Reads: Direct Page, Y Index, Accumulator]
	ora $7B80.w,Y		; 19 80 7B ; OR accumulator with memory $7B80.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and $7A.b,S		; 23 7A ; AND accumulator with stack relative $7A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and #$7829.w		; 29 29 78 ; Logical AND #$7829.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sty $7873.w		; 8C 73 78 ; Store Y register to $7873.w [Reads: Y Index]
	jsl $837882.l		; 22 82 78 83 ; Jump to subroutine long $837882.l [Writes: Stack Pointer] [Flow: call]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	bit $29.b		; 24 29 ; Test bits $29.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	and ($78.b,X)		; 21 78 ; Logical AND ($78.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $82, $78, $77		; 82 78 77 ; Branch always long to $82, $78, $77 [Flow: branch]
	and #$8529.w		; 29 29 85 ; Logical AND #$8529.w with accumulator [Writes: Accumulator] [Flags: NZ]
	adc $78.b,S		; 63 78 ; Add with carry (stack relative) $78.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sta $2982.w		; 8D 82 29 ; Store accumulator to $2982.w [Reads: Accumulator]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sta $7888.w,Y		; 99 88 78 ; Store accumulator to $7888.w,Y [Reads: Y Index, Accumulator]
	and #$8822.w		; 29 22 88 ; Logical AND #$8822.w with accumulator [Writes: Accumulator] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sta ($29.b,X)		; 81 29 ; Store accumulator ($29.b,X) [Reads: Direct Page, Accumulator, X Index]
	jsl $ED9B9C.l		; 22 9C 9B ED ; Jump to subroutine long $ED9B9C.l [Writes: Stack Pointer] [Flow: call]
	sta ($99.b,X)		; 81 99 ; Store accumulator ($99.b,X) [Reads: Direct Page, Accumulator, X Index]
	ora ($91.b)		; 12 91 ; OR accumulator with memory (indirect) ($91.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $80, $81		; 80 81 ; Branch always to $80, $81 [Flow: branch]
	jmp ($9992.w,X)		; 7C 92 99 ; Jump indirect indexed to ($9992.w,X) [Reads: X Index] [Flow: jump]
	adc $7780.w,X		; 7D 80 77 ; Add $7780.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sty $92.b		; 84 92 ; Store Y register to $92.b [Reads: Y Index]
	sta $8697.w,Y		; 99 97 86 ; Store accumulator to $8697.w,Y [Reads: Y Index, Accumulator]
	sta $78.b,X		; 95 78 ; Store accumulator to $78.b,X [Reads: Accumulator, X Index]
	sta $3092.w,Y		; 99 92 30 ; Store accumulator to $3092.w,Y [Reads: Y Index, Accumulator]
	rol $AE.b,X		; 36 AE ; Rotate left $AE.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc [$20.b]		; E7 20 ; Subtract with carry (long) [$20.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and ($9B.b,X)		; 21 9B ; Logical AND ($9B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta [$A6.b]		; 87 A6 ; Store accumulator (long) [$A6.b] [Reads: Direct Page, Accumulator]
	.db $90, $92		; 90 92 ; Branch if carry clear to $90, $92 [Flow: branch]
	and #$848F.w		; 29 8F 84 ; Logical AND #$848F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta [$89.b]		; 87 89 ; Store accumulator (long) [$89.b] [Reads: Direct Page, Accumulator]
	and #$8022.w		; 29 22 80 ; Logical AND #$8022.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ror $A2.b		; 66 A2 ; Rotate right $A2.b [Reads: Direct Page] [Flags: NCZ]
	.db $80, $21		; 80 21 ; Branch always to $80, $21 [Flow: branch]
	sta ($97.b)		; 92 97 ; Store accumulator (indirect) ($97.b) [Reads: Direct Page, Accumulator]
	ror $81.b,X		; 76 81 ; Rotate right $81.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	sta $9B22.w,Y		; 99 22 9B ; Store accumulator to $9B22.w,Y [Reads: Y Index, Accumulator]
	ora ($13.b)		; 12 13 ; OR accumulator with memory (indirect) ($13.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($93.b,S),Y		; 13 93 ; OR accumulator (stack relative indirect indexed) ($93.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($1D.b,S),Y		; 33 1D ; AND accumulator (stack relative indirect indexed) ($1D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $CDFB.w		; CD FB CD ; Compare $CDFB.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	and ($22.b)		; 32 22 ; AND accumulator with memory (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $D9D9.w		; CD D9 D9 ; Compare $D9D9.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp $2222.w		; CD 22 22 ; Compare $2222.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp $C7CD.w		; CD CD C7 ; Compare $C7CD.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp $2222.w		; CD 22 22 ; Compare $2222.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $25CD.w,X		; 9D CD 25 ; Store accumulator to $25CD.w,X [Reads: Accumulator, X Index]
	and $23.b,S		; 23 23 ; AND accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $25.b		; 25 25 ; Logical AND $25.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $BA.b		; 25 BA ; Logical AND $BA.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($32.b,S),Y		; 33 32 ; AND accumulator (stack relative indirect indexed) ($32.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx $FA.b		; E4 FA ; Compare $FA.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	and $D5.b		; 25 D5 ; Logical AND $D5.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $9DC550.l		; 22 50 C5 9D ; Jump to subroutine long $9DC550.l [Writes: Stack Pointer] [Flow: call]
	sbc $23C8.w,Y		; F9 C8 23 ; Subtract with carry $23C8.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $346DD4.l		; 22 D4 6D 34 ; Jump to subroutine long $346DD4.l [Writes: Stack Pointer] [Flow: call]
	rol $01.b,X		; 36 01 ; Rotate left $01.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $CE.b		; 00 CE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $C7CD.w		; CD CD C7 ; Compare $C7CD.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $E9CD36.l		; 0F 36 CD E9 ; OR accumulator with memory (long) $E9CD36.l [Writes: Accumulator] [Flags: NZ]
	jsr $3A22.w		; 20 22 3A ; Jump to subroutine at $3A22.w [Writes: Stack Pointer] [Flow: call]
	brk $63.b		; 00 63 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $23.b		; 85 23 ; Store accumulator to $23.b [Reads: Accumulator]
	ora ($1C.b,S),Y		; 13 1C ; OR accumulator (stack relative indirect indexed) ($1C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $33.b,X		; 36 33 ; Rotate left $33.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	and $12.b		; 25 12 ; Logical AND $12.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $C4.b		; 25 C4 ; Logical AND $C4.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0034CF.l,X		; 9F CF 34 00 ; Store accumulator (long,X) $0034CF.l,X [Reads: Accumulator, X Index]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc [$E8.b]		; 67 E8 ; Add with carry (long) [$E8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc ($11.b),Y		; 71 11 ; Add with carry ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($76.b),Y		; 11 76 ; OR accumulator with memory ($76.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc [$A3.b]		; 67 A3 ; Add with carry (long) [$A3.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp $11.b,X		; D5 11 ; Compare accumulator $11.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($76D5.w,X)		; 7C D5 76 ; Jump indirect indexed to ($76D5.w,X) [Reads: X Index] [Flow: jump]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $36.b,X		; 34 36 ; Test bits $36.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	rol $36.b,X		; 36 36 ; Rotate left $36.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($11.b)		; 12 11 ; OR accumulator with memory (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $36.b,X		; 34 36 ; Test bits $36.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $71.b,X		; 34 71 ; Test bits $71.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	rol $0303.w		; 2E 03 03 ; Rotate left $0303.w [Flags: NCZ]
	.db $30, $0D		; 30 0D ; Branch if minus to $30, $0D [Flow: branch]
	lda $E7.b,S		; A3 E7 ; Load accumulator (stack relative) $E7.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($01.b)		; 32 01 ; AND accumulator with memory (indirect) ($01.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jmp ($6C6C.w)		; 6C 6C 6C ; Jump indirect to ($6C6C.w) [Flow: jump]
	adc $1111.w		; 6D 11 11 ; Add $1111.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cmp $0330.w,X		; DD 30 03 ; Compare accumulator $0330.w,X [Reads: X Index] [Flags: NCZ]
	bit $F8.b,X		; 34 F8 ; Test bits $F8.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sbc $03FB.w,Y		; F9 FB 03 ; Subtract with carry $03FB.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($B0.b,S),Y		; 33 B0 ; AND accumulator (stack relative indirect indexed) ($B0.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $FD.b,X		; 34 FD ; Test bits $FD.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	inc $3300.w,X		; FE 00 33 ; Increment memory $3300.w,X [Reads: X Index] [Flags: NZ]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $4440.w		; 0D 40 44 ; Logical OR $4440.w with accumulator [Writes: Accumulator] [Flags: NZ]
	bit $4C.b,X		; 34 4C ; Test bits $4C.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora $36.b,X		; 15 36 ; OR accumulator with memory $36.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$40.b]		; 07 40 ; OR accumulator with memory (long) [$40.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpy $A9.b		; C4 A9 ; Compare $A9.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	ora $201034.l		; 0F 34 10 20 ; OR accumulator with memory (long) $201034.l [Writes: Accumulator] [Flags: NZ]
	rol $FD.b,X		; 36 FD ; Rotate left $FD.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	lda $34.b		; A5 34 ; Load $34.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	rol $DC.b,X		; 36 DC ; Rotate left $DC.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $F2E0.w,X		; DE E0 F2 ; Decrement memory $F2E0.w,X [Reads: X Index] [Flags: NZ]
	sbc #$0555.w		; E9 55 05 ; Subtract #$0555.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	nop		; EA ; No operation
	cpx $347F.w		; EC 7F 34 ; Compare $347F.w with X register [Reads: X Index] [Flags: NCZ]
	eor $00.b,X		; 55 00 ; Exclusive OR accumulator with memory $00.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $34.b,X		; 35 34 ; Logical AND $34.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc $93.b,X		; 75 93 ; Add $93.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $93.b		; 00 93 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($D4.b,X)		; 81 D4 ; Store accumulator ($D4.b,X) [Reads: Direct Page, Accumulator, X Index]
	lsr $10E7.w		; 4E E7 10 ; Logical shift right $10E7.w [Flags: NCZ]
	ora ($D6.b),Y		; 11 D6 ; OR accumulator with memory ($D6.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora [$36.b],Y		; 17 36 ; OR accumulator with memory (long indexed) [$36.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$0020.w		; C9 20 00 ; Compare #$0020.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp $3435.w,Y		; D9 35 34 ; Compare accumulator $3435.w,Y [Reads: Y Index] [Flags: NCZ]
	adc $0100.w		; 6D 00 01 ; Add $0100.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	and $AF.b,X		; 35 AF ; Logical AND $AF.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc $0234.w		; 6D 34 02 ; Add $0234.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $A8		; 10 A8 ; Branch if plus to $10, $A8 [Flow: branch]
	bit $F0.b,X		; 34 F0 ; Test bits $F0.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ldy #$1000.w		; A0 00 10 ; Load #$1000.w into Y register [Writes: Y Index] [Flags: NZ]
	lda $A0.b,S		; A3 A0 ; Load accumulator (stack relative) $A0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $A5		; F0 A5 ; Branch if equal to $F0, $A5 [Flow: branch]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $C4.b,X		; F5 C4 ; Subtract $C4.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $17.b,X		; F5 17 ; Subtract $17.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($12.b),Y		; 11 12 ; OR accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $26.b,X		; 16 26 ; Arithmetic shift left $26.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	adc $20B6.w,Y		; 79 B6 20 ; Add $20B6.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	inc $0100.w		; EE 00 01 ; Increment $0100.w [Flags: NZ]
	stx $5B.b		; 86 5B ; Store X register to $5B.b [Reads: X Index]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	stx $11.b		; 86 11 ; Store X register to $11.b [Reads: X Index]
	ora ($A9.b),Y		; 11 A9 ; OR accumulator with memory ($A9.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cpx #$9034.w		; E0 34 90 ; Compare #$9034.w with X register [Reads: X Index] [Flags: NCZ]
	brk $79.b		; 00 79 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $6C.b,X		; 34 6C ; Test bits $6C.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	adc $3110.w,Y		; 79 10 31 ; Add $3110.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp ($7934.w)		; 6C 34 79 ; Jump indirect to ($7934.w) [Flow: jump]
	adc $3130.w,Y		; 79 30 31 ; Add $3130.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $340F.w,Y		; 79 0F 34 ; Add $340F.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	and ($09.b)		; 32 09 ; AND accumulator with memory (indirect) ($09.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $AB.b,X		; 34 AB ; Test bits $AB.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora $22090F.l		; 0F 0F 09 22 ; OR accumulator with memory (long) $22090F.l [Writes: Accumulator] [Flags: NZ]
	ldx $360F.w		; AE 0F 36 ; Load $360F.w into X register [Writes: X Index] [Flags: NZ]
	bit $22.b,X		; 34 22 ; Test bits $22.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $B2.b		; 00 B2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda ($B2.b,S),Y		; B3 B2 ; Load accumulator (stack relative indirect indexed) ($B2.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $B09299.l		; 0F 99 92 B0 ; OR accumulator with memory (long) $B09299.l [Writes: Accumulator] [Flags: NZ]
	rol $B3.b,X		; 36 B3 ; Rotate left $B3.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	bit $20.b,X		; 34 20 ; Test bits $20.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $90, $AB		; 90 AB ; Branch if carry clear to $90, $AB [Flow: branch]
	lda ($AB.b,S),Y		; B3 AB ; Load accumulator (stack relative indirect indexed) ($AB.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $AC9299.l		; 0F 99 92 AC ; OR accumulator with memory (long) $AC9299.l [Writes: Accumulator] [Flags: NZ]
	lda $B2AE.w		; AD AE B2 ; Load $B2AE.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $B399.w,Y		; 99 99 B3 ; Store accumulator to $B399.w,Y [Reads: Y Index, Accumulator]
	lda ($AE.b)		; B2 AE ; Load accumulator (indirect) ($AE.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $99.b		; E6 99 ; Increment $99.b [Reads: Direct Page] [Flags: NZ]
	sta ($EC.b)		; 92 EC ; Store accumulator (indirect) ($EC.b) [Reads: Direct Page, Accumulator]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	bit $C9.b,X		; 34 C9 ; Test bits $C9.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $E1.b		; 85 E1 ; Store accumulator to $E1.b [Reads: Accumulator]
	rol $83.b,X		; 36 83 ; Rotate left $83.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $10, $03		; 10 03 ; Branch if plus to $10, $03 [Flow: branch]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $E1.b,X		; 34 E1 ; Test bits $E1.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$34.b]		; 27 34 ; AND accumulator with memory (long) [$34.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	lda $F60920.l		; AF 20 09 F6 ; Load long $F60920.l into accumulator [Writes: Accumulator] [Flags: NZ]
	inc $F6.b,X		; F6 F6 ; Increment memory $F6.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	inc $55.b,X		; F6 55 ; Increment memory $55.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	eor $AB.b,X		; 55 AB ; Exclusive OR accumulator with memory $AB.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($E1.b,X)		; E1 E1 ; Subtract with carry ($E1.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $90.b,X		; F6 90 ; Increment memory $90.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	ora $F6.b		; 05 F6 ; Logical OR $F6.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $81.b,X		; F6 81 ; Increment memory $81.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	rol $55.b,X		; 36 55 ; Rotate left $55.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	and #$7EB2.w		; 29 B2 7E ; Logical AND #$7EB2.w with accumulator [Writes: Accumulator] [Flags: NZ]
	bit $29.b,X		; 34 29 ; Test bits $29.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $30, $36		; 30 36 ; Branch if minus to $30, $36 [Flow: branch]
	ror $B039.w,X		; 7E 39 B0 ; Rotate right $B039.w,X [Reads: X Index] [Flags: NCZ]
	ora $29.b,S		; 03 29 ; OR accumulator with stack relative $29.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $F6		; B0 F6 ; Branch if carry set to $B0, $F6 [Flow: branch]
	inc $39.b,X		; F6 39 ; Increment memory $39.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	sta $52.b,X		; 95 52 ; Store accumulator to $52.b,X [Reads: Accumulator, X Index]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	inc $34.b,X		; F6 34 ; Increment memory $34.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	brk $50.b		; 00 50 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($9DB3.w,X)		; 7C B3 9D ; Jump indirect indexed to ($9DB3.w,X) [Reads: X Index] [Flow: jump]
	rol $69.b,X		; 36 69 ; Rotate left $69.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	jsr $B3B3.w		; 20 B3 B3 ; Jump to subroutine at $B3B3.w [Writes: Stack Pointer] [Flow: call]
	inc $7C.b,X		; F6 7C ; Increment memory $7C.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	sta $F656.w,Y		; 99 56 F6 ; Store accumulator to $F656.w,Y [Reads: Y Index, Accumulator]
	and [$27.b]		; 27 27 ; AND accumulator with memory (long) [$27.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda ($52.b,S),Y		; B3 52 ; Load accumulator (stack relative indirect indexed) ($52.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and #$8727.w		; 29 27 87 ; Logical AND #$8727.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $2634.w,X		; 9D 34 26 ; Store accumulator to $2634.w,X [Reads: Accumulator, X Index]
	jsr $ADAC.w		; 20 AC AD ; Jump to subroutine at $ADAC.w [Writes: Stack Pointer] [Flow: call]
	lda $9936.w		; AD 36 99 ; Load $9936.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $90, $F2		; 90 F2 ; Branch if carry clear to $90, $F2 [Flow: branch]
	lda ($AA.b,S),Y		; B3 AA ; Load accumulator (stack relative indirect indexed) ($AA.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda ($09.b,S),Y		; B3 09 ; Load accumulator (stack relative indirect indexed) ($09.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $7EB3.w,Y		; 99 B3 7E ; Store accumulator to $7EB3.w,Y [Reads: Y Index, Accumulator]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	ldy $0993.w		; AC 93 09 ; Load $0993.w into Y register [Writes: Y Index] [Flags: NZ]
	lda $ADAD.w		; AD AD AD ; Load $ADAD.w into accumulator [Writes: Accumulator] [Flags: NZ]
	lda ($99.b),Y		; B1 99 ; Load accumulator ($99.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $7F34.w,Y		; 99 34 7F ; Store accumulator to $7F34.w,Y [Reads: Y Index, Accumulator]
	sbc $30FB.w,Y		; F9 FB 30 ; Subtract with carry $30FB.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($76.b,S),Y		; 33 76 ; AND accumulator (stack relative indirect indexed) ($76.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $9577.w,X		; FD 77 95 ; Subtract with carry $9577.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $60.b,S		; 03 60 ; OR accumulator with stack relative $60.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $357F.w		; 0D 7F 35 ; Logical OR $357F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	mvp $00,$00		; 44 00 00 ; Move block positive $00,$00 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	jsr $B413.w		; 20 13 B4 ; Jump to subroutine at $B413.w [Writes: Stack Pointer] [Flow: call]
	ora $39.b,X		; 15 39 ; OR accumulator with memory $39.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $ED40.w,X		; 1D 40 ED ; OR accumulator with memory $ED40.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $2235.w,X		; FE 35 22 ; Increment memory $2235.w,X [Reads: X Index] [Flags: NZ]
	cmp #$D1B8.w		; C9 B8 D1 ; Compare #$D1B8.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cop $20.b		; 02 20 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($ED.b,S),Y		; 53 ED ; XOR accumulator (stack relative indirect indexed) ($ED.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	jmp.w [$0212]		; DC 12 02 ; Jump long indirect [$0212] [Flow: jump]
	ora $3AC5.w,X		; 1D C5 3A ; OR accumulator with memory $3AC5.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $6D2530.l,X		; 3F 30 25 6D ; AND accumulator with memory (long,X) $6D2530.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $34D5.w,X		; 1D D5 34 ; OR accumulator with memory $34D5.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	dec $37E6.w		; CE E6 37 ; Decrement $37E6.w [Flags: NZ]
	jmp $E62102.l		; 5C 02 21 E6 ; Jump long to $E62102.l [Flow: jump]
	sbc $CE33.w		; ED 33 CE ; Subtract $CE33.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	jsl $17B720.l		; 22 20 B7 17 ; Jump to subroutine long $17B720.l [Writes: Stack Pointer] [Flow: call]
	eor $93EB.w,X		; 5D EB 93 ; Exclusive OR accumulator with memory $93EB.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($DB.b),Y		; 11 DB ; OR accumulator with memory ($DB.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $0032.w,X		; FD 32 00 ; Subtract with carry $0032.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $21.b		; 02 21 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $53.b		; C5 53 ; Compare $53.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	and $0161.w,Y		; 39 61 01 ; AND accumulator with memory $0161.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($16.b,X)		; 21 16 ; Logical AND ($16.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	trb $37E8.w		; 1C E8 37 ; Test and reset bits $37E8.w [Reads: Accumulator] [Flags: Z]
	and ($37.b),Y		; 31 37 ; AND accumulator with memory ($37.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $6A.b		; C5 6A ; Compare $6A.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	jsl $531220.l		; 22 20 12 53 ; Jump to subroutine long $531220.l [Writes: Stack Pointer] [Flow: call]
	sbc $DB.b,S		; E3 DB ; Subtract stack-relative $DB.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	jsr $0510.w		; 20 10 05 ; Jump to subroutine at $0510.w [Writes: Stack Pointer] [Flow: call]
	inc $23.b		; E6 23 ; Increment $23.b [Reads: Direct Page] [Flags: NZ]
	cmp ($6A.b,S),Y		; D3 6A ; Compare accumulator (stack relative indirect indexed) ($6A.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	and $01.b,S		; 23 01 ; AND accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $C4.b,X		; 34 C4 ; Test bits $C4.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sbc $01AB.w,Y		; F9 AB 01 ; Subtract with carry $01AB.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cmp $37.b,X		; D5 37 ; Compare accumulator $37.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	jsr $0502.w		; 20 02 05 ; Jump to subroutine at $0502.w [Writes: Stack Pointer] [Flow: call]
	adc $E6E6.w		; 6D E6 E6 ; Add $E6E6.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora ($22.b)		; 12 22 ; OR accumulator with memory (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and [$FE.b]		; 27 FE ; AND accumulator with memory (long) [$FE.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($6A.b)		; 32 6A ; AND accumulator with memory (indirect) ($6A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($21.b)		; 12 21 ; OR accumulator with memory (indirect) ($21.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	sbc ($4F.b)		; F2 4F ; Subtract with carry (indirect) ($4F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and ($91.b)		; 32 91 ; AND accumulator with memory (indirect) ($91.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor [$BD.b],Y		; 57 BD ; Exclusive OR accumulator with memory (long indexed) [$BD.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $67.b		; C5 67 ; Compare $67.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	rol $90.b,X		; 36 90 ; Rotate left $90.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($33.b)		; 12 33 ; OR accumulator with memory (indirect) ($33.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($33.b,S),Y		; 33 33 ; AND accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $22.b		; C5 22 ; Compare $22.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	jsr $D80C.w		; 20 0C D8 ; Jump to subroutine at $D80C.w [Writes: Stack Pointer] [Flow: call]
	jmp ($13C0.w)		; 6C C0 13 ; Jump indirect to ($13C0.w) [Flow: jump]
	ora $6B69.w,Y		; 19 69 6B ; OR accumulator with memory $6B69.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and $233376.l,X		; 3F 76 33 23 ; AND accumulator with memory (long,X) $233376.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ror $34.b,X		; 76 34 ; Rotate right $34.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	nop		; EA ; No operation
	.db $30, $03		; 30 03 ; Branch if minus to $30, $03 [Flow: branch]
	bit $02.b,X		; 34 02 ; Test bits $02.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	rep #$05		; C2 05 ; Reset processor status bits #$05 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	tsb $94.b		; 04 94 ; Test and set bits $94.b [Reads: Accumulator] [Flags: Z]
	cpy $C5.b		; C4 C5 ; Compare $C5.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	cmp $35.b		; C5 35 ; Compare $35.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sta $C794.w,Y		; 99 94 C7 ; Store accumulator to $C794.w,Y [Reads: Y Index, Accumulator]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sta $3493.w,Y		; 99 93 34 ; Store accumulator to $3493.w,Y [Reads: Y Index, Accumulator]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	ora $33.b,S		; 03 33 ; OR accumulator with stack relative $33.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $34BF.w		; CE BF 34 ; Decrement $34BF.w [Flags: NZ]
	sbc [$99.b]		; E7 99 ; Subtract with carry (long) [$99.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $D5.b,S		; 03 D5 ; OR accumulator with stack relative $D5.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $D1.b,X		; 34 D1 ; Test bits $D1.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	jmp.w [$3990]		; DC 90 39 ; Jump long indirect [$3990] [Flow: jump]
	cmp $DAD9.w,X		; DD D9 DA ; Compare accumulator $DAD9.w,X [Reads: X Index] [Flags: NCZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	sta $F099.w,Y		; 99 99 F0 ; Store accumulator to $F099.w,Y [Reads: Y Index, Accumulator]
	jmp.w [$DFDD]		; DC DD DF ; Jump long indirect [$DFDD] [Flow: jump]
	ora #$E199.w		; 09 99 E1 ; Logical OR #$E199.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc ($F0.b,X)		; E1 F0 ; Subtract with carry ($F0.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $99.b,X		; 34 99 ; Test bits $99.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $34.b		; 26 34 ; Rotate left $34.b [Reads: Direct Page] [Flags: NCZ]
	bit $0404.w		; 2C 04 04 ; Test bits $0404.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	cpx $CE.b		; E4 CE ; Compare $CE.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	pei ($93.b)		; D4 93 ; Push effective indirect address ($93.b) [Reads: Direct Page] [Writes: Stack Pointer]
	sta $9D1C.w,Y		; 99 1C 9D ; Store accumulator to $9D1C.w,Y [Reads: Y Index, Accumulator]
	bit $0B.b,X		; 34 0B ; Test bits $0B.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $42, $31		; 42 31 ; Reserved instruction
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sta $11FC.w,X		; 9D FC 11 ; Store accumulator to $11FC.w,X [Reads: Accumulator, X Index]
	and $76.b,S		; 23 76 ; AND accumulator with stack relative $76.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $9D.b,X		; 36 9D ; Rotate left $9D.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	bit $60.b,X		; 34 60 ; Test bits $60.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	jsr $3436.w		; 20 36 34 ; Jump to subroutine at $3436.w [Writes: Stack Pointer] [Flow: call]
	bit $F6.b,X		; 34 F6 ; Test bits $F6.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $35.b		; 00 35 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $3836.w,X		; 9D 36 38 ; Store accumulator to $3836.w,X [Reads: Accumulator, X Index]
	bit $20.b,X		; 34 20 ; Test bits $20.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $30, $34		; 30 34 ; Branch if minus to $30, $34 [Flow: branch]
	bit $0B.b,X		; 34 0B ; Test bits $0B.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $EFED.w		; EC ED EF ; Compare $EFED.w with X register [Reads: X Index] [Flags: NCZ]
	.db $F0, $99		; F0 99 ; Branch if equal to $F0, $99 [Flow: branch]
	sta $EEEC.w,Y		; 99 EC EE ; Store accumulator to $EEEC.w,Y [Reads: Y Index, Accumulator]
	sbc ($F3.b),Y		; F1 F3 ; Subtract with carry ($F3.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $F599.w,Y		; 99 99 F5 ; Store accumulator to $F599.w,Y [Reads: Y Index, Accumulator]
	sbc ($F4.b,S),Y		; F3 F4 ; Subtract with carry (stack relative indirect indexed) ($F4.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc $99.b,X		; F5 99 ; Subtract $99.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $EEFA.w,Y		; 99 FA EE ; Store accumulator to $EEFA.w,Y [Reads: Y Index, Accumulator]
	pea $99FB.w		; F4 FB 99 ; Push absolute address $99FB.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sta $F8F4.w,Y		; 99 F4 F8 ; Store accumulator to $F8F4.w,Y [Reads: Y Index, Accumulator]
	sbc $99F8.w,Y		; F9 F8 99 ; Subtract with carry $99F8.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $F3F5.w,Y		; 99 F5 F3 ; Store accumulator to $F3F5.w,Y [Reads: Y Index, Accumulator]
	sbc $FA.b,X		; F5 FA ; Subtract $FA.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $2499.w,Y		; 99 99 24 ; Store accumulator to $2499.w,Y [Reads: Y Index, Accumulator]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc ($F9.b,S),Y		; F3 F9 ; Subtract with carry (stack relative indirect indexed) ($F9.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $F399.w,Y		; 19 99 F3 ; OR accumulator with memory $F399.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	pea $F8F9.w		; F4 F9 F8 ; Push absolute address $F8F9.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sta $0399.w,Y		; 99 99 03 ; Store accumulator to $0399.w,Y [Reads: Y Index, Accumulator]
	ora $24.b		; 05 24 ; Logical OR $24.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pea $19AA.w		; F4 AA 19 ; Push absolute address $19AA.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	ora [$F5.b]		; 07 F5 ; OR accumulator with memory (long) [$F5.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc ($03.b,S),Y		; F3 03 ; Subtract with carry (stack relative indirect indexed) ($03.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	lda #$0A9A.w		; A9 9A 0A ; Load #$0A9A.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$FE24.w		; 09 24 FE ; Logical OR #$FE24.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ora $F6F5.w,Y		; 19 F5 F6 ; OR accumulator with memory $F6F5.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	inc $0F.b,X		; F6 0F ; Increment memory $0F.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	sta $119A.w,Y		; 99 9A 11 ; Store accumulator to $119A.w,Y [Reads: Y Index, Accumulator]
	inc $13.b,X		; F6 13 ; Increment memory $13.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	lda #$C5A9.w		; A9 A9 C5 ; Load #$C5A9.w into accumulator [Writes: Accumulator] [Flags: NZ]
	inc $FEFE.w,X		; FE FE FE ; Increment memory $FEFE.w,X [Reads: X Index] [Flags: NZ]
	eor $0299.w,Y		; 59 99 02 ; Exclusive OR accumulator with memory $0299.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tsb $09.b		; 04 09 ; Test and set bits $09.b [Reads: Accumulator] [Flags: Z]
	ora $AA.b,S		; 03 AA ; OR accumulator with stack relative $AA.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tsb $FC03.w		; 0C 03 FC ; Test and set bits $FC03.w [Reads: Accumulator] [Flags: Z]
	cop $AA.b		; 02 AA ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	tsb $09.b		; 04 09 ; Test and set bits $09.b [Reads: Accumulator] [Flags: Z]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tsb $FCF6.w		; 0C F6 FC ; Test and set bits $FCF6.w [Reads: Accumulator] [Flags: Z]
	jsr ($99A9.w,X)		; FC A9 99 ; Jump to subroutine indirect indexed ($99A9.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr ($12FE.w,X)		; FC FE 12 ; Jump to subroutine indirect indexed ($12FE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr ($A999.w,X)		; FC 99 A9 ; Jump to subroutine indirect indexed ($A999.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr ($02FB.w,X)		; FC FB 02 ; Jump to subroutine indirect indexed ($02FB.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	tsb $99.b		; 04 99 ; Test and set bits $99.b [Reads: Accumulator] [Flags: Z]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ora $15.b		; 05 15 ; Logical OR $15.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ora [$F6.b],Y		; 17 F6 ; OR accumulator with memory (long indexed) [$F6.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $A904.w,X		; 1D 04 A9 ; OR accumulator with memory $A904.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ora $2321.w,Y		; 19 21 23 ; OR accumulator with memory $2321.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	inc $FE0D.w,X		; FE 0D FE ; Increment memory $FE0D.w,X [Reads: X Index] [Flags: NZ]
	ora ($9A.b),Y		; 11 9A ; OR accumulator with memory ($9A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	inc $F6.b,X		; F6 F6 ; Increment memory $F6.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	inc $A9.b,X		; F6 A9 ; Increment memory $A9.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	sta $FEF6.w,Y		; 99 F6 FE ; Store accumulator to $FEF6.w,Y [Reads: Y Index, Accumulator]
	sbc ($F0.b,S),Y		; F3 F0 ; Subtract with carry (stack relative indirect indexed) ($F0.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sta $0099.w,Y		; 99 99 00 ; Store accumulator to $0099.w,Y [Reads: Y Index, Accumulator]
	inc $F0FE.w,X		; FE FE F0 ; Increment memory $F0FE.w,X [Reads: X Index] [Flags: NZ]
	lda #$F099.w		; A9 99 F0 ; Load #$F099.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	.db $F0, $99		; F0 99 ; Branch if equal to $F0, $99 [Flow: branch]
	sta $2BF6.w,Y		; 99 F6 2B ; Store accumulator to $2BF6.w,Y [Reads: Y Index, Accumulator]
	and $9AFA.w		; 2D FA 9A ; Logical AND $9AFA.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$2F2E.w		; A9 2E 2F ; Load #$2F2E.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $30, $2E		; 30 2E ; Branch if minus to $30, $2E [Flow: branch]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	.db $30, $32		; 30 32 ; Branch if minus to $30, $32 [Flow: branch]
	.db $F0, $2C		; F0 2C ; Branch if equal to $F0, $2C [Flow: branch]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rol $3330.w		; 2E 30 33 ; Rotate left $3330.w [Flags: NCZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	rol $2F33.w		; 2E 33 2F ; Rotate left $2F33.w [Flags: NCZ]
	jsr ($A9AA.w,X)		; FC AA A9 ; Jump to subroutine indirect indexed ($A9AA.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	and ($2F.b,S),Y		; 33 2F ; AND accumulator (stack relative indirect indexed) ($2F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $AA2F.w,X		; FE 2F AA ; Increment memory $AA2F.w,X [Reads: X Index] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	ora $04.b,X		; 15 04 ; OR accumulator with memory $04.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $AAAA2F.l		; 2F 2F AA AA ; AND accumulator with memory (long) $AAAA2F.l [Writes: Accumulator] [Flags: NZ]
	.db $30, $FC		; 30 FC ; Branch if minus to $30, $FC [Flow: branch]
	and $AAA930.l		; 2F 30 A9 AA ; AND accumulator with memory (long) $AAA930.l [Writes: Accumulator] [Flags: NZ]
	inc $0B19.w,X		; FE 19 0B ; Increment memory $0B19.w,X [Reads: X Index] [Flags: NZ]
	tsb $9A.b		; 04 9A ; Test and set bits $9A.b [Reads: Accumulator] [Flags: Z]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	.db $30, $33		; 30 33 ; Branch if minus to $30, $33 [Flow: branch]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $10, $AA		; 10 AA ; Branch if plus to $10, $AA [Flow: branch]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	inc $F6.b,X		; F6 F6 ; Increment memory $F6.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	and $A999FE.l		; 2F FE 99 A9 ; AND accumulator with memory (long) $A999FE.l [Writes: Accumulator] [Flags: NZ]
	inc $12FE.w,X		; FE FE 12 ; Increment memory $12FE.w,X [Reads: X Index] [Flags: NZ]
	and $99.b,X		; 35 99 ; Logical AND $99.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	cmp $16.b		; C5 16 ; Compare $16.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora $5A03.w,Y		; 19 03 5A ; OR accumulator with memory $5A03.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	rol $33.b,X		; 36 33 ; Rotate left $33.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $AAAA.w,Y		; 19 AA AA ; OR accumulator with memory $AAAA.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $F9.b,X		; 36 F9 ; Rotate left $F9.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda #$FCFC.w		; A9 FC FC ; Load #$FCFC.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $03AA.w,Y		; 99 AA 03 ; Store accumulator to $03AA.w,Y [Reads: Y Index, Accumulator]
	ora $36.b,S		; 03 36 ; OR accumulator with stack relative $36.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $AA.b,X		; 36 AA ; Rotate left $AA.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	inc $FDFB.w,X		; FE FB FD ; Increment memory $FDFB.w,X [Reads: X Index] [Flags: NZ]
	sbc $9999.w,X		; FD 99 99 ; Subtract with carry $9999.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $FE07.w,X		; FE 07 FE ; Increment memory $FE07.w,X [Reads: X Index] [Flags: NZ]
	inc $9A.b,X		; F6 9A ; Increment memory $9A.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	sta $1BF6.w,Y		; 99 F6 1B ; Store accumulator to $1BF6.w,Y [Reads: Y Index, Accumulator]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	sta $1BF9.w,Y		; 99 F9 1B ; Store accumulator to $1BF9.w,Y [Reads: Y Index, Accumulator]
	.db $F0, $F6		; F0 F6 ; Branch if equal to $F0, $F6 [Flow: branch]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	sta $1BF6.w,Y		; 99 F6 1B ; Store accumulator to $1BF6.w,Y [Reads: Y Index, Accumulator]
	and $A39A9F.l		; 2F 9F 9A A3 ; AND accumulator with memory (long) $A39A9F.l [Writes: Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	lda $34.b		; A5 34 ; Load $34.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $24.b		; A5 24 ; Load $24.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $70, $34		; 70 34 ; Branch if overflow set to $70, $34 [Flow: branch]
	ora ($10.b),Y		; 11 10 ; OR accumulator with memory ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $35.b		; 24 35 ; Test bits $35.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora $10A5.w		; 0D A5 10 ; Logical OR $10A5.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and ($27.b,X)		; 21 27 ; Logical AND ($27.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $AB11.w		; 0D 11 AB ; Logical OR $AB11.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($30.b,S),Y		; 13 30 ; OR accumulator (stack relative indirect indexed) ($30.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $0E.b		; A5 0E ; Load $0E.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc ($C4.b),Y		; 71 C4 ; Add with carry ($C4.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($01.b)		; 12 01 ; OR accumulator with memory (indirect) ($01.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dec $CE71.w		; CE 71 CE ; Decrement $CE71.w [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	jsr $A320.w		; 20 20 A3 ; Jump to subroutine at $A320.w [Writes: Stack Pointer] [Flow: call]
	bit $3D3D.w,X		; 3C 3D 3D ; Test bits $3D3D.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	sta [$47.b]		; 87 47 ; Store accumulator (long) [$47.b] [Reads: Direct Page, Accumulator]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	inc $4B.b		; E6 4B ; Increment $4B.b [Reads: Direct Page] [Flags: NZ]
	inc $4C.b		; E6 4C ; Increment $4C.b [Reads: Direct Page] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cpx $4E4E.w		; EC 4E 4E ; Compare $4E4E.w with X register [Reads: X Index] [Flags: NCZ]
	lsr $AA2A.w		; 4E 2A AA ; Logical shift right $AA2A.w [Flags: NCZ]
	eor $54.b		; 45 54 ; Exclusive OR $54.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr $4E.b,X		; 56 4E ; Logical shift right $4E.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	inc $59.b		; E6 59 ; Increment $59.b [Reads: Direct Page] [Flags: NZ]
	inc $4C.b		; E6 4C ; Increment $4C.b [Reads: Direct Page] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	adc $48.b		; 65 48 ; Add $48.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	eor $AA.b		; 45 AA ; Exclusive OR $AA.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	cpx $5B4C.w		; EC 4C 5B ; Compare $5B4C.w with X register [Reads: X Index] [Flags: NCZ]
	eor $2A.b		; 45 2A ; Exclusive OR $2A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	inc $6A.b		; E6 6A ; Increment $6A.b [Reads: Direct Page] [Flags: NZ]
	inc $4D.b		; E6 4D ; Increment $4D.b [Reads: Direct Page] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr $4E6D.w		; 4E 6D 4E ; Logical shift right $4E6D.w [Flags: NCZ]
	eor $AA.b		; 45 AA ; Exclusive OR $AA.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	eor $E6.b		; 45 E6 ; Exclusive OR $E6.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	eor $5B.b		; 45 5B ; Exclusive OR $5B.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	eor ($AA.b),Y		; 51 AA ; Exclusive OR accumulator with memory ($AA.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $45.b,X		; 15 45 ; OR accumulator with memory $45.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lsr $4545.w		; 4E 45 45 ; Logical shift right $4545.w [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	eor $AA.b		; 45 AA ; Exclusive OR $AA.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	inc $45.b		; E6 45 ; Increment $45.b [Reads: Direct Page] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	jmp $AA2A.w		; 4C 2A AA ; Jump to $AA2A.w [Flow: jump]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	eor $1A45EC.l		; 4F EC 45 1A ; Exclusive OR accumulator with memory (long) $1A45EC.l [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc $59.b,X		; 75 59 ; Add $59.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $AA45.w		; 6E 45 AA ; Rotate right $AA45.w [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	inc $45.b		; E6 45 ; Increment $45.b [Reads: Direct Page] [Flags: NZ]
	mvn $2A,$6A		; 54 6A 2A ; Move block negative $2A,$6A [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	eor $45.b		; 45 45 ; Exclusive OR $45.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cpx $A2AA.w		; EC AA A2 ; Compare $A2AA.w with X register [Reads: X Index] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sbc $6A77.w		; ED 77 6A ; Subtract $6A77.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ldx #$45AA.w		; A2 AA 45 ; Load #$45AA.w into X register [Writes: X Index] [Flags: NZ]
	eor $45.b		; 45 45 ; Exclusive OR $45.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $AA.b		; 45 AA ; Exclusive OR $AA.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	eor $40.b		; 45 40 ; Exclusive OR $40.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx $AAE6.w		; EC E6 AA ; Compare $AAE6.w with X register [Reads: X Index] [Flags: NCZ]
	jsl $51EC5B.l		; 22 5B EC 51 ; Jump to subroutine long $51EC5B.l [Writes: Stack Pointer] [Flow: call]
	inc $12.b		; E6 12 ; Increment $12.b [Reads: Direct Page] [Flags: NZ]
	ldx #$5C40.w		; A2 40 5C ; Load #$5C40.w into X register [Writes: X Index] [Flags: NZ]
	lsr $AA40.w,X		; 5E 40 AA ; Logical shift right $AA40.w,X [Reads: X Index] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	stz $28.b,X		; 74 28 ; Store zero to $28.b,X [Reads: X Index]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $E6.b		; A5 E6 ; Load $E6.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc ($E6.b,X)		; 61 E6 ; Add with carry ($E6.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $2A.b		; E6 2A ; Increment $2A.b [Reads: Direct Page] [Flags: NZ]
	jsl $E6E6E6.l		; 22 E6 E6 E6 ; Jump to subroutine long $E6E6E6.l [Writes: Stack Pointer] [Flow: call]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	jsl $465F2A.l		; 22 2A 5F 46 ; Jump to subroutine long $465F2A.l [Writes: Stack Pointer] [Flow: call]
	inc $79.b		; E6 79 ; Increment $79.b [Reads: Direct Page] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc $EC79.w,Y		; 79 79 EC ; Add $EC79.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $AA.b		; E6 AA ; Increment $AA.b [Reads: Direct Page] [Flags: NZ]
	jsl $464544.l		; 22 44 45 46 ; Jump to subroutine long $464544.l [Writes: Stack Pointer] [Flow: call]
	jmp ($AAAA.w,X)		; 7C AA AA ; Jump indirect indexed to ($AAAA.w,X) [Reads: X Index] [Flow: jump]
	jmp ($737E.w,X)		; 7C 7E 73 ; Jump indirect indexed to ($737E.w,X) [Reads: X Index] [Flow: jump]
	adc $AAAA.w		; 6D AA AA ; Add $AAAA.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	eor $63.b		; 45 63 ; Exclusive OR $63.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor #$AA81.w		; 49 81 AA ; Exclusive OR #$AA81.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	.db $82, $83, $81		; 82 83 81 ; Branch always long to $82, $83, $81 [Flow: branch]
	rol $AAAA.w,X		; 3E AA AA ; Rotate left $AAAA.w,X [Reads: X Index] [Flags: NCZ]
	bit $7D7B.w,X		; 3C 7B 7D ; Test bits $7D7B.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	mvp $AA,$AA		; 44 AA AA ; Move block positive $AA,$AA [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	lsr $44.b		; 46 44 ; Logical shift right $44.b [Reads: Direct Page] [Flags: NCZ]
	sta $87.b		; 85 87 ; Store accumulator to $87.b [Reads: Accumulator]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	sta ($89.b,X)		; 81 89 ; Store accumulator ($89.b,X) [Reads: Direct Page, Accumulator, X Index]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	sta ($AA.b,X)		; 81 AA ; Store accumulator ($AA.b,X) [Reads: Direct Page, Accumulator, X Index]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	stx $85.b		; 86 85 ; Store X register to $85.b [Reads: X Index]
	inc $45.b		; E6 45 ; Increment $45.b [Reads: Direct Page] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta ($94.b)		; 92 94 ; Store accumulator (indirect) ($94.b) [Reads: Direct Page, Accumulator]
	stx $AA95.w		; 8E 95 AA ; Store X register to $AA95.w [Reads: X Index]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	sta [$8F.b],Y		; 97 8F ; Store accumulator (long indexed) [$8F.b],Y [Reads: Direct Page, Y Index, Accumulator]
	sta ($92.b,S),Y		; 93 92 ; Store accumulator (stack relative indirect indexed) ($92.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	eor $40.b		; 45 40 ; Exclusive OR $40.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor ($9E.b,X)		; 41 9E ; Exclusive OR accumulator with memory ($9E.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	sta $9C9AA0.l,X		; 9F A0 9A 9C ; Store accumulator (long,X) $9C9AA0.l,X [Reads: Accumulator, X Index]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ldy #$A2A1.w		; A0 A1 A2 ; Load #$A2A1.w into Y register [Writes: Y Index] [Flags: NZ]
	eor $AA.b		; 45 AA ; Exclusive OR $AA.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	inc $A3.b		; E6 A3 ; Increment $A3.b [Reads: Direct Page] [Flags: NZ]
	adc [$A6.b],Y		; 77 A6 ; Add with carry (long indexed) [$A6.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda [$A5.b]		; A7 A5 ; Load accumulator (long) [$A5.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldx $77.b		; A6 77 ; Load $77.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $4E.b,S		; A3 4E ; Load accumulator (stack relative) $4E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $AAAAA3.l		; 4F A3 AA AA ; Exclusive OR accumulator with memory (long) $AAAAA3.l [Writes: Accumulator] [Flags: NZ]
	lda $A3.b,S		; A3 A3 ; Load accumulator (stack relative) $A3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $A3.b,S		; A3 A3 ; Load accumulator (stack relative) $A3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $5F.b,S		; A3 5F ; Load accumulator (stack relative) $5F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $67.b,S		; 63 67 ; Add with carry (stack relative) $67.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	and $5F5E5C.l,X		; 3F 5C 5E 5F ; AND accumulator with memory (long,X) $5F5E5C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	.db $50, $52		; 50 52 ; Branch if overflow clear to $50, $52 [Flow: branch]
	lsr $AD.b		; 46 AD ; Logical shift right $AD.b [Reads: Direct Page] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $ADAD.w		; AD AD AD ; Load $ADAD.w into accumulator [Writes: Accumulator] [Flags: NZ]
	mvp $AA,$AA		; 44 AA AA ; Move block positive $AA,$AA [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $62, $44, $46		; 62 44 46 ; Push effective relative address $62, $44, $46 [Writes: Stack Pointer]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $44AD.w		; AD AD 44 ; Load $44AD.w into accumulator [Writes: Accumulator] [Flags: NZ]
	and $40AAAA.l,X		; 3F AA AA 40 ; AND accumulator with memory (long,X) $40AAAA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $7E.b		; 45 7E ; Exclusive OR $7E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	eor $E640.w,X		; 5D 40 E6 ; Exclusive OR accumulator with memory $E640.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $AA.b		; E6 AA ; Increment $AA.b [Reads: Direct Page] [Flags: NZ]
	jsl $40404C.l		; 22 4C 40 40 ; Jump to subroutine long $40404C.l [Writes: Stack Pointer] [Flow: call]
	lsr $AA.b		; 46 AA ; Logical shift right $AA.b [Reads: Direct Page] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $E6.b,S		; A3 E6 ; Load accumulator (stack relative) $E6.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $A3.b		; E6 A3 ; Increment $A3.b [Reads: Direct Page] [Flags: NZ]
	ldx #$AD2A.w		; A2 2A AD ; Load #$AD2A.w into X register [Writes: X Index] [Flags: NZ]
	lda $7FA3.w		; AD A3 7F ; Load $7FA3.w into accumulator [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $A3.b,S		; A3 A3 ; Load accumulator (stack relative) $A3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lsr $77.b		; 46 77 ; Logical shift right $77.b [Reads: Direct Page] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	adc [$E6.b]		; 67 E6 ; Add with carry (long) [$E6.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inc $E6.b		; E6 E6 ; Increment $E6.b [Reads: Direct Page] [Flags: NZ]
	ldx #$4522.w		; A2 22 45 ; Load #$4522.w into X register [Writes: X Index] [Flags: NZ]
	lda $A3.b,S		; A3 A3 ; Load accumulator (stack relative) $A3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lsr $AA.b		; 46 AA ; Logical shift right $AA.b [Reads: Direct Page] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	inc $5F.b		; E6 5F ; Increment $5F.b [Reads: Direct Page] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	mvp $A3,$46		; 44 46 A3 ; Move block positive $A3,$46 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	and $3EA3.w,Y		; 39 A3 3E ; AND accumulator with memory $3EA3.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $5A		; B0 5A ; Branch if carry set to $B0, $5A [Flow: branch]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	lda ($B3.b)		; B2 B3 ; Load accumulator (indirect) ($B3.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpy #$AAB5.w		; C0 B5 AA ; Compare #$AAB5.w with Y register [Reads: Y Index] [Flags: NCZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ldy $FFB7.w,X		; BC B7 FF ; Load Y register $FFB7.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ldy #$C3C1.w		; A0 C1 C3 ; Load #$C3C1.w into Y register [Writes: Y Index] [Flags: NZ]
	cmp $C6.b		; C5 C6 ; Compare $C6.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	bit $14.b,X		; 34 14 ; Test bits $14.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $7F.b,X		; 34 7F ; Test bits $7F.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	lda ($34.b)		; B2 34 ; Load accumulator (indirect) ($34.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpy $A476.w		; CC 76 A4 ; Compare $A476.w with Y register [Reads: Y Index] [Flags: NCZ]
	ldy #$95D0.w		; A0 D0 95 ; Load #$95D0.w into Y register [Writes: Y Index] [Flags: NZ]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ldy #$E700.w		; A0 00 E7 ; Load #$E700.w into Y register [Writes: Y Index] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $C6.b,S		; E3 C6 ; Subtract stack-relative $C6.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	and ($9A.b,S),Y		; 33 9A ; AND accumulator (stack relative indirect indexed) ($9A.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $BA.b,X		; 34 BA ; Test bits $BA.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	inc $FD.b,X		; F6 FD ; Increment memory $FD.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and ($FE.b,S),Y		; 33 FE ; AND accumulator (stack relative indirect indexed) ($FE.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpy #$BDB7.w		; C0 B7 BD ; Compare #$BDB7.w with Y register [Reads: Y Index] [Flags: NCZ]
	and $F6AA.w,Y		; 39 AA F6 ; AND accumulator with memory $F6AA.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	rol $C6.b,X		; 36 C6 ; Rotate left $C6.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	pei ($30.b)		; D4 30 ; Push effective indirect address ($30.b) [Reads: Direct Page] [Writes: Stack Pointer]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	cmp [$F6.b]		; C7 F6 ; Compare accumulator (long) [$F6.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora $36.b,X		; 15 36 ; OR accumulator with memory $36.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lda $40.b,S		; A3 40 ; Load accumulator (stack relative) $40.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $D6.b,X		; 34 D6 ; Test bits $D6.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and ($C6.b,S),Y		; 33 C6 ; AND accumulator (stack relative indirect indexed) ($C6.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	dec $3333.w		; CE 33 33 ; Decrement $3333.w [Flags: NZ]
	sbc ($B0.b,X)		; E1 B0 ; Subtract with carry ($B0.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda ($B3.b)		; B2 B3 ; Load accumulator (indirect) ($B3.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	dec $CE68.w		; CE 68 CE ; Decrement $CE68.w [Flags: NZ]
	lda $B73933.l,X		; BF 33 39 B7 ; Load long $B73933.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $A02C35.l,X		; FF 35 2C A0 ; Subtract with carry (long,X) $A02C35.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $CE.b		; 04 CE ; Test and set bits $CE.b [Reads: Accumulator] [Flags: Z]
	adc ($36.b)		; 72 36 ; Add with carry (indirect) ($36.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda $33.b,X		; B5 33 ; Load $33.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cmp $BFEC.w,Y		; D9 EC BF ; Compare accumulator $BFEC.w,Y [Reads: Y Index] [Flags: NCZ]
	dec $93A0.w		; CE A0 93 ; Decrement $93A0.w [Flags: NZ]
	sta $F0.b,X		; 95 F0 ; Store accumulator to $F0.b,X [Reads: Accumulator, X Index]
	cmp ($C8.b,S),Y		; D3 C8 ; Compare accumulator (stack relative indirect indexed) ($C8.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	brk $93.b		; 00 93 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $BF.b,X		; 34 BF ; Test bits $BF.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc #$D7E8.w		; E9 E8 D7 ; Subtract #$D7E8.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cmp $E1AA30.l,X		; DF 30 AA E1 ; Compare accumulator (long,X) $E1AA30.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	inc $E8.b		; E6 E8 ; Increment $E8.b [Reads: Direct Page] [Flags: NZ]
	lda [$AA.b]		; A7 AA ; Load accumulator (long) [$AA.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $34.b,S		; A3 34 ; Load accumulator (stack relative) $34.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $F6.b,X		; 15 F6 ; OR accumulator with memory $F6.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$5004.w		; C9 04 50 ; Compare #$5004.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	stz $7CA5.w,X		; 9E A5 7C ; Store zero to $7CA5.w,X [Reads: X Index]
	bit $1201.w,X		; 3C 01 12 ; Test bits $1201.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	ldy $343C.w		; AC 3C 34 ; Load $343C.w into Y register [Writes: Y Index] [Flags: NZ]
	bit $02.b,X		; 34 02 ; Test bits $02.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and ($F3.b,S),Y		; 33 F3 ; AND accumulator (stack relative indirect indexed) ($F3.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0C.b,S		; 03 0C ; OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $9A.b,S		; 03 9A ; OR accumulator with stack relative $9A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tsb $0903.w		; 0C 03 09 ; Test and set bits $0903.w [Reads: Accumulator] [Flags: Z]
	asl $AA.b		; 06 AA ; Arithmetic shift left $AA.b [Reads: Direct Page] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	bit $0C.b		; 24 0C ; Test bits $0C.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	adc ($7E.b),Y		; 71 7E ; Add with carry ($7E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$35.b]		; 07 35 ; OR accumulator with memory (long) [$35.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $AA.b,X		; 34 AA ; Test bits $AA.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($7D.b)		; F2 7D ; Subtract with carry (indirect) ($7D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora [$10.b]		; 07 10 ; OR accumulator with memory (long) [$10.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	and $D571.w,Y		; 39 71 D5 ; AND accumulator with memory $D571.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc ($10.b,X)		; 61 10 ; Add with carry ($10.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($11.b,X)		; 21 11 ; Logical AND ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	adc ($78.b),Y		; 71 78 ; Add with carry ($78.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($00.b,X)		; 61 00 ; Add with carry ($00.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $16.b		; 06 16 ; Arithmetic shift left $16.b [Reads: Direct Page] [Flags: NCZ]
	tsb $14.b		; 04 14 ; Test and set bits $14.b [Reads: Accumulator] [Flags: Z]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	tsb $06.b		; 04 06 ; Test and set bits $06.b [Reads: Accumulator] [Flags: Z]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	trb $07.b		; 14 07 ; Test and reset bits $07.b [Reads: Accumulator] [Flags: Z]
	ror $AA71.w,X		; 7E 71 AA ; Rotate right $AA71.w,X [Reads: X Index] [Flags: NCZ]
	.db $30, $34		; 30 34 ; Branch if minus to $30, $34 [Flow: branch]
	.db $82, $82, $7E		; 82 82 7E ; Branch always long to $82, $82, $7E [Flow: branch]
	ora $33.b,S		; 03 33 ; OR accumulator with stack relative $33.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $82, $34, $34		; 82 34 34 ; Branch always long to $82, $34, $34 [Flow: branch]
	bit $30.b,X		; 34 30 ; Test bits $30.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $984F.w,X		; 1E 4F 98 ; Arithmetic shift left $984F.w,X [Reads: X Index] [Flags: NCZ]
	ror $13.b		; 66 13 ; Rotate right $13.b [Reads: Direct Page] [Flags: NCZ]
	and $9F.b		; 25 9F ; Logical AND $9F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $500A.w,X		; 9D 0A 50 ; Store accumulator to $500A.w,X [Reads: Accumulator, X Index]
	and ($0B.b,X)		; 21 0B ; Logical AND ($0B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	sbc $10.b		; E5 10 ; Subtract $10.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($1E.b,X)		; 01 1E ; Logical OR ($1E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	dec $EC.b		; C6 EC ; Decrement $EC.b [Reads: Direct Page] [Flags: NZ]
	cmp [$20.b]		; C7 20 ; Compare accumulator (long) [$20.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ldy #$E5DC.w		; A0 DC E5 ; Load #$E5DC.w into Y register [Writes: Y Index] [Flags: NZ]
	ldy #$02A3.w		; A0 A3 02 ; Load #$02A3.w into Y register [Writes: Y Index] [Flags: NZ]
	.db $30, $E9		; 30 E9 ; Branch if minus to $30, $E9 [Flow: branch]
	adc $11EEC6.l,X		; 7F C6 EE 11 ; Add long $11EEC6.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	dec $CA.b		; C6 CA ; Decrement $CA.b [Reads: Direct Page] [Flags: NZ]
	ror $E5.b,X		; 76 E5 ; Rotate right $E5.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $34		; 90 34 ; Branch if carry clear to $90, $34 [Flow: branch]
	asl $20C6.w,X		; 1E C6 20 ; Arithmetic shift left $20C6.w,X [Reads: X Index] [Flags: NCZ]
	jsr $C4C7.w		; 20 C7 C4 ; Jump to subroutine at $C4C7.w [Writes: Stack Pointer] [Flow: call]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($81.b,X)		; 01 81 ; Logical OR ($81.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	dec $ED.b		; C6 ED ; Decrement $ED.b [Reads: Direct Page] [Flags: NZ]
	dec $70.b		; C6 70 ; Decrement $70.b [Reads: Direct Page] [Flags: NZ]
	ldy #$C6C6.w		; A0 C6 C6 ; Load #$C6C6.w into Y register [Writes: Y Index] [Flags: NZ]
	cmp [$40.b]		; C7 40 ; Compare accumulator (long) [$40.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $CC.b		; C6 CC ; Decrement $CC.b [Reads: Direct Page] [Flags: NZ]
	cmp $050020.l		; CF 20 00 05 ; Compare accumulator (long) $050020.l [Reads: Accumulator] [Flags: NCZ]
	bit $36.b,X		; 34 36 ; Test bits $36.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	dec $40.b		; C6 40 ; Decrement $40.b [Reads: Direct Page] [Flags: NZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$E5D6.w		; 09 D6 E5 ; Logical OR #$E5D6.w with accumulator [Writes: Accumulator] [Flags: NZ]
	dec $12.b		; C6 12 ; Decrement $12.b [Reads: Direct Page] [Flags: NZ]
	.db $10, $05		; 10 05 ; Branch if plus to $10, $05 [Flow: branch]
	cpy $35.b		; C4 35 ; Compare $35.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	sta $11.b		; 85 11 ; Store accumulator to $11.b [Reads: Accumulator]
	ora $49.b,S		; 03 49 ; OR accumulator with stack relative $49.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $90.b		; E6 90 ; Increment $90.b [Reads: Direct Page] [Flags: NZ]
	.db $90, $A2		; 90 A2 ; Branch if carry clear to $90, $A2 [Flow: branch]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	.db $90, $8F		; 90 8F ; Branch if carry clear to $90, $8F [Flow: branch]
	inc $43.b		; E6 43 ; Increment $43.b [Reads: Direct Page] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lda $A3.b,S		; A3 A3 ; Load accumulator (stack relative) $A3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $43.b,S		; A3 43 ; Load accumulator (stack relative) $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	eor $F7.b,S		; 43 F7 ; Exclusive OR accumulator with stack relative $F7.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc [$F7.b],Y		; F7 F7 ; Subtract with carry (long indexed) [$F7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	.db $42, $46		; 42 46 ; Reserved instruction
	inc $A3.b		; E6 A3 ; Increment $A3.b [Reads: Direct Page] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	inc $E6.b		; E6 E6 ; Increment $E6.b [Reads: Direct Page] [Flags: NZ]
	lda $2277.w		; AD 77 22 ; Load $2277.w into accumulator [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	inc $A3.b		; E6 A3 ; Increment $A3.b [Reads: Direct Page] [Flags: NZ]
	inc $5E.b		; E6 5E ; Increment $5E.b [Reads: Direct Page] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	inc $46.b		; E6 46 ; Increment $46.b [Reads: Direct Page] [Flags: NZ]
	inc $A3.b		; E6 A3 ; Increment $A3.b [Reads: Direct Page] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	inc $EC.b		; E6 EC ; Increment $EC.b [Reads: Direct Page] [Flags: NZ]
	lda $2277.w		; AD 77 22 ; Load $2277.w into accumulator [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	inc $A3.b		; E6 A3 ; Increment $A3.b [Reads: Direct Page] [Flags: NZ]
	inc $E6.b		; E6 E6 ; Increment $E6.b [Reads: Direct Page] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	jsl $E645E6.l		; 22 E6 45 E6 ; Jump to subroutine long $E645E6.l [Writes: Stack Pointer] [Flow: call]
	eor $2A.b,S		; 43 2A ; Exclusive OR accumulator with stack relative $2A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lda $A3.b,S		; A3 A3 ; Load accumulator (stack relative) $A3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $A3.b,S		; 43 A3 ; Exclusive OR accumulator with stack relative $A3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $43.b,S		; A3 43 ; Load accumulator (stack relative) $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $E6.b		; E6 E6 ; Increment $E6.b [Reads: Direct Page] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	jsl $E6E6E6.l		; 22 E6 E6 E6 ; Jump to subroutine long $E6E6E6.l [Writes: Stack Pointer] [Flow: call]
	cpx $2222.w		; EC 22 22 ; Compare $2222.w with X register [Reads: X Index] [Flags: NCZ]
	inc $6D.b		; E6 6D ; Increment $6D.b [Reads: Direct Page] [Flags: NZ]
	eor $4E.b		; 45 4E ; Exclusive OR $4E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	sbc $F9F9.w,Y		; F9 F9 F9 ; Subtract with carry $F9F9.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $66.b,X		; 16 66 ; Arithmetic shift left $66.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	lda $71A5.w		; AD A5 71 ; Load $71A5.w into accumulator [Writes: Accumulator] [Flags: NZ]
	brk $A5.b		; 00 A5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $73.b		; E6 73 ; Increment $73.b [Reads: Direct Page] [Flags: NZ]
	cpx $A206.w		; EC 06 A2 ; Compare $A206.w with X register [Reads: X Index] [Flags: NCZ]
	eor $AD.b,S		; 43 AD ; Exclusive OR accumulator with stack relative $AD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $4D.b,S		; 43 4D ; Exclusive OR accumulator with stack relative $4D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	lda $62.b,S		; A3 62 ; Load accumulator (stack relative) $62.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lda $E6.b,S		; A3 E6 ; Load accumulator (stack relative) $E6.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $43.b		; E6 43 ; Increment $43.b [Reads: Direct Page] [Flags: NZ]
	ldx $2A.b		; A6 2A ; Load $2A.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	lda $E843.w		; AD 43 E8 ; Load $E843.w into accumulator [Writes: Accumulator] [Flags: NZ]
	bit $AA.b,X		; 34 AA ; Test bits $AA.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $62, $1A, $AD		; 62 1A AD ; Push effective relative address $62, $1A, $AD [Writes: Stack Pointer]
	lda $A3.b,S		; A3 A3 ; Load accumulator (stack relative) $A3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	inc $43.b		; E6 43 ; Increment $43.b [Reads: Direct Page] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	eor $6A.b,X		; 55 6A ; Exclusive OR accumulator with memory $6A.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc $6A.b,S		; 63 6A ; Add with carry (stack relative) $6A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	lda $A3.b,S		; A3 A3 ; Load accumulator (stack relative) $A3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$1A.b]		; 07 1A ; OR accumulator with memory (long) [$1A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda [$F9.b]		; A7 F9 ; Load accumulator (long) [$F9.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $F9F9.w,Y		; F9 F9 F9 ; Subtract with carry $F9F9.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $66.b		; 66 66 ; Rotate right $66.b [Reads: Direct Page] [Flags: NCZ]
	sbc $F9F9.w,Y		; F9 F9 F9 ; Subtract with carry $F9F9.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	ror $66.b		; 66 66 ; Rotate right $66.b [Reads: Direct Page] [Flags: NCZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lda $AD.b,S		; A3 AD ; Load accumulator (stack relative) $AD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $A01A.w		; AD 1A A0 ; Load $A01A.w into accumulator [Writes: Accumulator] [Flags: NZ]
	lda $34.b		; A5 34 ; Load $34.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc [$C2.b],Y		; 77 C2 ; Add with carry (long indexed) [$C2.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $A1.b		; 00 A1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $06.b,X		; 34 06 ; Test bits $06.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ror $B1.b		; 66 B1 ; Rotate right $B1.b [Reads: Direct Page] [Flags: NCZ]
	and ($12.b,X)		; 21 12 ; Logical AND ($12.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda $E6.b,S		; A3 E6 ; Load accumulator (stack relative) $E6.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	mvp $AA,$A2		; 44 A2 AA ; Move block positive $AA,$A2 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	eor $3F.b		; 45 3F ; Exclusive OR $3F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor ($48.b,X)		; 41 48 ; Exclusive OR accumulator with memory ($48.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	cpy $EC.b		; C4 EC ; Compare $EC.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	lda $25.b		; A5 25 ; Load $25.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $17.b		; 02 17 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $A5.b		; A5 A5 ; Load $A5.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $74.b		; 45 74 ; Exclusive OR $74.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($AA.b),Y		; 11 AA ; OR accumulator with memory ($AA.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $46.b		; 45 46 ; Exclusive OR $46.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc [$F8.b],Y		; 77 F8 ; Add with carry (long indexed) [$F8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ldx $FA.b		; A6 FA ; Load $FA.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	adc $77A6.w,Y		; 79 A6 77 ; Add $77A6.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($07.b,X)		; 61 07 ; Add with carry ($07.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp ($6A45.w,X)		; 7C 45 6A ; Jump indirect indexed to ($6A45.w,X) [Reads: X Index] [Flow: jump]
	ror $AA7A.w		; 6E 7A AA ; Rotate right $AA7A.w [Flags: NCZ]
	eor $4C.b		; 45 4C ; Exclusive OR $4C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr $F9.b		; 46 F9 ; Logical shift right $F9.b [Reads: Direct Page] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ldx $9E.b		; A6 9E ; Load $9E.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	eor #$A534.w		; 49 34 A5 ; Exclusive OR #$A534.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora ($73.b,X)		; 01 73 ; Logical OR ($73.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jmp $E874.w		; 4C 74 E8 ; Jump to $E874.w [Flow: jump]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	ldx $A3.b		; A6 A3 ; Load $A3.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	lda $A5.b		; A5 A5 ; Load $A5.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	lda ($13.b,X)		; A1 13 ; Load accumulator ($13.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cpy $08.b		; C4 08 ; Compare $08.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	adc [$E8.b]		; 67 E8 ; Add with carry (long) [$E8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora [$A6.b],Y		; 17 A6 ; OR accumulator with memory (long indexed) [$A6.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda $A4.b,S		; A3 A4 ; Load accumulator (stack relative) $A4.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $77.b,X		; 34 77 ; Test bits $77.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ldy #$A507.w		; A0 07 A5 ; Load #$A507.w into Y register [Writes: Y Index] [Flags: NZ]
	adc $A395.w,Y		; 79 95 A3 ; Add $A395.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $A5.b		; 45 A5 ; Exclusive OR $A5.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $EF.b		; 65 EF ; Add $EF.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ldy #$3431.w		; A0 31 34 ; Load #$3431.w into Y register [Writes: Y Index] [Flags: NZ]
	lda #$7D4C.w		; A9 4C 7D ; Load #$7D4C.w into accumulator [Writes: Accumulator] [Flags: NZ]
	brk $A1.b		; 00 A1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $A5.b		; A5 A5 ; Load $A5.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jmp ($11E4.w)		; 6C E4 11 ; Jump indirect to ($11E4.w) [Flow: jump]
	ror $E6.b,X		; 76 E6 ; Rotate right $E6.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	ror $2A21.w		; 6E 21 2A ; Rotate right $2A21.w [Flags: NCZ]
	adc [$08.b],Y		; 77 08 ; Add with carry (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $A6.b,X		; 34 A6 ; Test bits $A6.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cpy $70.b		; C4 70 ; Compare $70.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	ora ($34.b,X)		; 01 34 ; Logical OR ($34.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp $FD.b,X		; D5 FD ; Compare accumulator $FD.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sta $01.b		; 85 01 ; Store accumulator to $01.b [Reads: Accumulator]
	lda $AA.b,S		; A3 AA ; Load accumulator (stack relative) $AA.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $40.b		; 85 40 ; Store accumulator to $40.b [Reads: Accumulator]
	trb $6203.w		; 1C 03 62 ; Test and reset bits $6203.w [Reads: Accumulator] [Flags: Z]
	sbc $F240C4.l,X		; FF C4 40 F2 ; Subtract with carry (long,X) $F240C4.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $60		; 10 60 ; Branch if plus to $10, $60 [Flow: branch]
	rol $34.b,X		; 36 34 ; Rotate left $34.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	bit $B6.b,X		; 34 B6 ; Test bits $B6.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($34.b),Y		; 71 34 ; Add with carry ($34.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $396A.w		; EC 6A 39 ; Compare $396A.w with X register [Reads: X Index] [Flags: NCZ]
	rol $26.b,X		; 36 26 ; Rotate left $26.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	jsr $38F4.w		; 20 F4 38 ; Jump to subroutine at $38F4.w [Writes: Stack Pointer] [Flow: call]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and $33.b,S		; 23 33 ; AND accumulator with stack relative $33.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc [$A7.b]		; E7 A7 ; Subtract with carry (long) [$A7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $1334.w,X		; 9D 34 13 ; Store accumulator to $1334.w,X [Reads: Accumulator, X Index]
	jsr $D834.w		; 20 34 D8 ; Jump to subroutine at $D834.w [Writes: Stack Pointer] [Flow: call]
	jmp ($0034.w,X)		; 7C 34 00 ; Jump indirect indexed to ($0034.w,X) [Reads: X Index] [Flow: jump]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $3434.w,Y		; 39 34 34 ; AND accumulator with memory $3434.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $856D.w,Y		; 39 6D 85 ; AND accumulator with memory $856D.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$1011.w		; C9 11 10 ; Compare #$1011.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ror $3B7E.w,X		; 7E 7E 3B ; Rotate right $3B7E.w,X [Reads: X Index] [Flags: NCZ]
	adc $2133.w		; 6D 33 21 ; Add $2133.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	sbc $34FA.w,Y		; F9 FA 34 ; Subtract with carry $34FA.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($30.b,S),Y		; 13 30 ; OR accumulator (stack relative indirect indexed) ($30.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($FE.b,S),Y		; 33 FE ; AND accumulator (stack relative indirect indexed) ($FE.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $FB		; F0 FB ; Branch if equal to $F0, $FB [Flow: branch]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	brk $D9.b		; 00 D9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($6C.b)		; F2 6C ; Subtract with carry (indirect) ($6C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jmp ($1100.w)		; 6C 00 11 ; Jump indirect to ($1100.w) [Flow: jump]
	dec $34.b,X		; D6 34 ; Decrement memory $34.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	bit $A8.b,X		; 34 A8 ; Test bits $A8.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($7F34.w,X)		; 7C 34 7F ; Jump indirect indexed to ($7F34.w,X) [Reads: X Index] [Flow: jump]
	adc ($00.b),Y		; 71 00 ; Add with carry ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($5A.b,X)		; E1 5A ; Subtract with carry ($5A.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $007C.w,Y		; 79 7C 00 ; Add $007C.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $5A.b		; 00 5A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $26.b,X		; 34 26 ; Test bits $26.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora $0100.w		; 0D 00 01 ; Logical OR $0100.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc ($35.b,X)		; E1 35 ; Subtract with carry ($35.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx $78.b,Y		; B6 78 ; Load X register $78.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $E2.b,X		; 35 E2 ; Logical AND $E2.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	bit $A8.b,X		; 34 A8 ; Test bits $A8.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $D93535.l		; AF 35 35 D9 ; Load long $D93535.l into accumulator [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $95.b,X		; 34 95 ; Test bits $95.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp $5D3332.l		; 5C 32 33 5D ; Jump long to $5D3332.l [Flow: jump]
	ora ($21.b)		; 12 21 ; OR accumulator with memory (indirect) ($21.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($34.b)		; 32 34 ; AND accumulator with memory (indirect) ($34.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $34.b,X		; 35 34 ; Logical AND $34.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	jsr $7C20.w		; 20 20 7C ; Jump to subroutine at $7C20.w [Writes: Stack Pointer] [Flow: call]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	jmp ($0034.w)		; 6C 34 00 ; Jump indirect to ($0034.w) [Flow: jump]
	.db $10, $77		; 10 77 ; Branch if plus to $10, $77 [Flow: branch]
	lda $AC.b		; A5 AC ; Load $AC.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $0121.w,X		; 5D 21 01 ; Exclusive OR accumulator with memory $0121.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $A4		; F0 A4 ; Branch if equal to $F0, $A4 [Flow: branch]
	ldy $0011.w		; AC 11 00 ; Load $0011.w into Y register [Writes: Y Index] [Flags: NZ]
	eor $745E.w,X		; 5D 5E 74 ; Exclusive OR accumulator with memory $745E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc ($11.b)		; 72 11 ; Add with carry (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($5E.b),Y		; 11 5E ; OR accumulator with memory ($5E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr $795E.w,X		; 5E 5E 79 ; Logical shift right $795E.w,X [Reads: X Index] [Flags: NCZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $85, $AA		; 62 85 AA ; Push effective relative address $62, $85, $AA [Writes: Stack Pointer]
.INDEX 8
	sep #$13		; E2 13
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $35.b,X		; 34 35 ; Test bits $35.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sbc ($10.b,X)		; E1 10 ; Subtract with carry ($10.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $AD.b		; 00 AD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $A9		; F0 A9 ; Branch if equal to $F0, $A9 [Flow: branch]
	lsr $0101.w,X		; 5E 01 01 ; Logical shift right $0101.w,X [Reads: X Index] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpy $C6.b		; C4 C6 ; Compare $C6.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	and [$11.b]		; 27 11 ; AND accumulator with memory (long) [$11.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($34.b,X)		; 01 34 ; Logical OR ($34.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	and [$F8.b],Y		; 37 F8 ; AND accumulator with memory (long indexed) [$F8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($20.b,X)		; 01 20 ; Logical OR ($20.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sed		; F8 ; Set decimal flag [Flags: D]
	bit $62.b,X		; 34 62 ; Test bits $62.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cop $30.b		; 02 30 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	and ($02.b,S),Y		; 33 02 ; AND accumulator (stack relative indirect indexed) ($02.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc ($71.b),Y		; 71 71 ; Add with carry ($71.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	brk $6A.b		; 00 6A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $FF.b		; C6 FF ; Decrement $FF.b [Reads: Direct Page] [Flags: NZ]
	rol $10.b,X		; 36 10 ; Rotate left $10.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $10, $34		; 10 34 ; Branch if plus to $10, $34 [Flow: branch]
	rol $34.b,X		; 36 34 ; Rotate left $34.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $00.b,X		; 15 00 ; OR accumulator with memory $00.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $20.b		; 04 20 ; Test and set bits $20.b [Reads: Accumulator] [Flags: Z]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	lda #$20F8.w		; A9 F8 20 ; Load #$20F8.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cop $6C.b		; 02 6C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($7F6C.w)		; 6C 6C 7F ; Jump indirect to ($7F6C.w) [Flow: jump]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	dec $36.b		; C6 36 ; Decrement $36.b [Reads: Direct Page] [Flags: NZ]
	sbc $E3.b,S		; E3 E3 ; Subtract stack-relative $E3.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda #$CC79.w		; A9 79 CC ; Load #$CC79.w into accumulator [Writes: Accumulator] [Flags: NZ]
	dec $01.b		; C6 01 ; Decrement $01.b [Reads: Direct Page] [Flags: NZ]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $C6.b		; A5 C6 ; Load $C6.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	stz $10.b,X		; 74 10 ; Store zero to $10.b,X [Reads: X Index]
	ora ($72.b,X)		; 01 72 ; Logical OR ($72.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor $1134AD.l,X		; 5F AD 34 11 ; Exclusive OR accumulator with memory (long,X) $1134AD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $C6.b		; 00 C6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($A5.b,S),Y		; 13 A5 ; OR accumulator (stack relative indirect indexed) ($A5.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	cop $10.b		; 02 10 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $A4.b		; C6 A4 ; Decrement $A4.b [Reads: Direct Page] [Flags: NZ]
	lda $A4.b		; A5 A4 ; Load $A4.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $03.b		; A5 03 ; Load $03.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	cmp ($0B.b,S),Y		; D3 0B ; Compare accumulator (stack relative indirect indexed) ($0B.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	jsl $D306A5.l		; 22 A5 06 D3 ; Jump to subroutine long $D306A5.l [Writes: Stack Pointer] [Flow: call]
	sbc $211B.w,X		; FD 1B 21 ; Subtract with carry $211B.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $2D.b,X		; 16 2D ; Arithmetic shift left $2D.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	eor ($06.b,X)		; 41 06 ; Exclusive OR accumulator with memory ($06.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and ($1B.b,X)		; 21 1B ; Logical AND ($1B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp #$393F.w		; C9 3F 39 ; Compare #$393F.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	bit $22.b,X		; 34 22 ; Test bits $22.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $10, $4B		; 10 4B ; Branch if plus to $10, $4B [Flow: branch]
	lsr $24.b,X		; 56 24 ; Logical shift right $24.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	dec $1211.w		; CE 11 12 ; Decrement $1211.w [Flags: NZ]
	bit $1B.b		; 24 1B ; Test bits $1B.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cmp $CD.b		; C5 CD ; Compare $CD.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora ($22.b)		; 12 22 ; OR accumulator with memory (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	dec $A2.b		; C6 A2 ; Decrement $A2.b [Reads: Direct Page] [Flags: NZ]
	jsl $1CA526.l		; 22 26 A5 1C ; Jump to subroutine long $1CA526.l [Writes: Stack Pointer] [Flow: call]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	and ($32.b),Y		; 31 32 ; AND accumulator with memory ($32.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $0B1D.w		; CD 1D 0B ; Compare $0B1D.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	sec		; 38 ; Set carry flag [Flags: C]
	and ($13.b,X)		; 21 13 ; Logical AND ($13.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda $7C.b		; A5 7C ; Load $7C.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc ($A4.b,S),Y		; F3 A4 ; Subtract with carry (stack relative indirect indexed) ($A4.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora ($10.b),Y		; 11 10 ; OR accumulator with memory ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ldx $18.b		; A6 18 ; Load $18.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	lda $A4.b		; A5 A4 ; Load $A4.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $10.b		; 02 10 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	and $D1.b,X		; 35 D1 ; Logical AND $D1.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ror $00.b		; 66 00 ; Rotate right $00.b [Reads: Direct Page] [Flags: NCZ]
	cmp $8620.w,X		; DD 20 86 ; Compare accumulator $8620.w,X [Reads: X Index] [Flags: NCZ]
	jmp ($1105.w,X)		; 7C 05 11 ; Jump indirect indexed to ($1105.w,X) [Reads: X Index] [Flow: jump]
	sbc ($DB.b,X)		; E1 DB ; Subtract with carry ($DB.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0000A3.l,X		; 9F A3 00 00 ; Store accumulator (long,X) $0000A3.l,X [Reads: Accumulator, X Index]
	ldy $AFA8.w		; AC A8 AF ; Load $AFA8.w into Y register [Writes: Y Index] [Flags: NZ]
	adc $AD0000.l,X		; 7F 00 00 AD ; Add long $AD0000.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $AF.b,X		; 76 AF ; Rotate right $AF.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sta $00.b,X		; 95 00 ; Store accumulator to $00.b,X [Reads: Accumulator, X Index]
	brk $76.b		; 00 76 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($13.b),Y		; 11 13 ; OR accumulator with memory ($13.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $5695.w,X		; 7E 95 56 ; Rotate right $5695.w,X [Reads: X Index] [Flags: NCZ]
	and ($01.b,S),Y		; 33 01 ; AND accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lsr $4E4E.w		; 4E 4E 4E ; Logical shift right $4E4E.w [Flags: NCZ]
	bit $11.b,X		; 34 11 ; Test bits $11.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	cpx $C4.b		; E4 C4 ; Compare $C4.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	dec $0252.w		; CE 52 02 ; Decrement $0252.w [Flags: NZ]
	bit $06.b		; 24 06 ; Test bits $06.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	adc $66.b		; 65 66 ; Add $66.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	dec $7E24.w		; CE 24 7E ; Decrement $7E24.w [Flags: NZ]
	ora $21.b		; 05 21 ; Logical OR $21.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($06.b),Y		; 31 06 ; AND accumulator with memory ($06.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($AA.b,S),Y		; 33 AA ; AND accumulator (stack relative indirect indexed) ($AA.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $82, $17, $63		; 82 17 63 ; Branch always long to $82, $17, $63 [Flow: branch]
	lda $2466.w		; AD 66 24 ; Load $2466.w into accumulator [Writes: Accumulator] [Flags: NZ]
	adc $61.b		; 65 61 ; Add $61.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($85.b),Y		; 11 85 ; OR accumulator with memory ($85.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and #$C6A5.w		; 29 A5 C6 ; Logical AND #$C6A5.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and ($10.b,S),Y		; 33 10 ; AND accumulator (stack relative indirect indexed) ($10.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $42, $6D		; 42 6D ; Reserved instruction
	tsb $57EE.w		; 0C EE 57 ; Test and set bits $57EE.w [Reads: Accumulator] [Flags: Z]
	ora ($DB.b),Y		; 11 DB ; OR accumulator with memory ($DB.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $E6.b		; E5 E6 ; Subtract $E6.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	cop $21.b		; 02 21 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $6AE6.w		; EE E6 6A ; Increment $6AE6.w [Flags: NZ]
	inc $12.b		; E6 12 ; Increment $12.b [Reads: Direct Page] [Flags: NZ]
	ora ($9C.b)		; 12 9C ; OR accumulator with memory (indirect) ($9C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $82, $FD, $51		; 82 FD 51 ; Branch always long to $82, $FD, $51 [Flow: branch]
	and ($9E.b)		; 32 9E ; AND accumulator with memory (indirect) ($9E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	bit $FD.b,X		; 34 FD ; Test bits $FD.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	eor ($02.b),Y		; 51 02 ; Exclusive OR accumulator with memory ($02.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	inc $D1D0.w,X		; FE D0 D1 ; Increment memory $D1D0.w,X [Reads: X Index] [Flags: NZ]
	sta ($00.b)		; 92 00 ; Store accumulator (indirect) ($00.b) [Reads: Direct Page, Accumulator]
	cmp ($9E.b),Y		; D1 9E ; Compare accumulator ($9E.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	lda $F1.b		; A5 F1 ; Load $F1.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	cmp #$D2CA.w		; C9 CA D2 ; Compare #$D2CA.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	cmp [$C9.b]		; C7 C9 ; Compare accumulator (long) [$C9.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	inc $78.b		; E6 78 ; Increment $78.b [Reads: Direct Page] [Flags: NZ]
	brk $27.b		; 00 27 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp [$58.b]		; C7 58 ; Compare accumulator (long) [$58.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($C6.b,X)		; 21 C6 ; Logical AND ($C6.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	dec $E6.b		; C6 E6 ; Decrement $E6.b [Reads: Direct Page] [Flags: NZ]
	and ($00.b,X)		; 21 00 ; Logical AND ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and [$E4.b]		; 27 E4 ; AND accumulator with memory (long) [$E4.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $A5.b		; A5 A5 ; Load $A5.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $A5.b		; A5 A5 ; Load $A5.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $6A.b		; A5 6A ; Load $6A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $01		; 10 01 ; Branch if plus to $10, $01 [Flow: branch]
	ora $1B1834.l		; 0F 34 18 1B ; OR accumulator with memory (long) $1B1834.l [Writes: Accumulator] [Flags: NZ]
	jsr $1B22.w		; 20 22 1B ; Jump to subroutine at $1B22.w [Writes: Stack Pointer] [Flow: call]
	ora $B1.b		; 05 B1 ; Logical OR $B1.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $2221.w		; 20 21 22 ; Jump to subroutine at $2221.w [Writes: Stack Pointer] [Flow: call]
	ora #$587E.w		; 09 7E 58 ; Logical OR #$587E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	adc $1717.w,X		; 7D 17 17 ; Add $1717.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $71.b		; 06 71 ; Arithmetic shift left $71.b [Reads: Direct Page] [Flags: NCZ]
	ror $11C6.w,X		; 7E C6 11 ; Rotate right $11C6.w,X [Reads: X Index] [Flags: NCZ]
	.db $70, $7D		; 70 7D ; Branch if overflow set to $70, $7D [Flow: branch]
	cmp $57.b,X		; D5 57 ; Compare accumulator $57.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cmp #$2070.w		; C9 70 20 ; Compare #$2070.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	asl $1C53.w		; 0E 53 1C ; Arithmetic shift left $1C53.w [Flags: NCZ]
	dec $B1.b		; C6 B1 ; Decrement $B1.b [Reads: Direct Page] [Flags: NZ]
	jsr $C70F.w		; 20 0F C7 ; Jump to subroutine at $C70F.w [Writes: Stack Pointer] [Flow: call]
	ora ($0F.b,S),Y		; 13 0F ; OR accumulator (stack relative indirect indexed) ($0F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda ($BB.b)		; B2 BB ; Load accumulator (indirect) ($BB.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$1816.w		; 29 16 18 ; Logical AND #$1816.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp [$3B.b]		; C7 3B ; Compare accumulator (long) [$3B.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	lda ($C7.b)		; B2 C7 ; Load accumulator (indirect) ($C7.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp [$16.b]		; C7 16 ; Compare accumulator (long) [$16.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp [$22.b]		; C7 22 ; Compare accumulator (long) [$22.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	lda ($29.b)		; B2 29 ; Load accumulator (indirect) ($29.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $3BC723.l		; 22 23 C7 3B ; Jump to subroutine long $3BC723.l [Writes: Stack Pointer] [Flow: call]
	lda ($C7.b)		; B2 C7 ; Load accumulator (indirect) ($C7.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp [$C7.b]		; C7 C7 ; Compare accumulator (long) [$C7.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp [$22.b]		; C7 22 ; Compare accumulator (long) [$22.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	jsl $AB302E.l		; 22 2E 30 AB ; Jump to subroutine long $AB302E.l [Writes: Stack Pointer] [Flow: call]
	cmp [$BB.b]		; C7 BB ; Compare accumulator (long) [$BB.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	.db $82, $33, $35		; 82 33 35 ; Branch always long to $82, $33, $35 [Flow: branch]
	.db $42, $CD		; 42 CD ; Reserved instruction
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	eor ($C7.b)		; 52 C7 ; Exclusive OR accumulator with memory (indirect) ($C7.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $2BC7.w,X		; 3D C7 2B ; AND accumulator with memory $2BC7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda ($3F.b)		; B2 3F ; Load accumulator (indirect) ($3F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp [$41.b]		; C7 41 ; Compare accumulator (long) [$41.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	lsr $B2.b		; 46 B2 ; Logical shift right $B2.b [Reads: Direct Page] [Flags: NCZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	dec $49.b		; C6 49 ; Decrement $49.b [Reads: Direct Page] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	eor $BB2B.w		; 4D 2B BB ; Exclusive OR $BB2B.w with accumulator [Writes: Accumulator] [Flags: NZ]
	eor $2071C7.l		; 4F C7 71 20 ; Exclusive OR accumulator with memory (long) $2071C7.l [Writes: Accumulator] [Flags: NZ]
	lda ($13.b)		; B2 13 ; Load accumulator (indirect) ($13.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr $D7.b		; 46 D7 ; Logical shift right $D7.b [Reads: Direct Page] [Flags: NCZ]
	cmp $B2C7.w,Y		; D9 C7 B2 ; Compare accumulator $B2C7.w,Y [Reads: Y Index] [Flags: NCZ]
	jsl $595856.l		; 22 56 58 59 ; Jump to subroutine long $595856.l [Writes: Stack Pointer] [Flow: call]
	eor $BB.b,X		; 55 BB ; Exclusive OR accumulator with memory $BB.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	jsr $C712.w		; 20 12 C7 ; Jump to subroutine at $C712.w [Writes: Stack Pointer] [Flow: call]
	lsr $3B.b,X		; 56 3B ; Logical shift right $3B.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	eor $C67F5E.l,X		; 5F 5E 7F C6 ; Exclusive OR accumulator with memory (long,X) $C67F5E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	.db $70, $E8		; 70 E8 ; Branch if overflow set to $70, $E8 [Flow: branch]
	stz $65.b		; 64 65 ; Store zero to $65.b
	adc $6B.b		; 65 6B ; Add $6B.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	adc [$71.b]		; 67 71 ; Add with carry (long) [$71.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc $73B129.l,X		; 7F 29 B1 73 ; Add long $73B129.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor [$29.b]		; 47 29 ; Exclusive OR accumulator with memory (long) [$29.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $2BBB72.l		; EF 72 BB 2B ; Subtract with carry (long) $2BBB72.l [Writes: Accumulator] [Flags: NCVZ]
	inc $29.b,X		; F6 29 ; Increment memory $29.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	dec $17.b		; C6 17 ; Decrement $17.b [Reads: Direct Page] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	and $20.b,S		; 23 20 ; AND accumulator with stack relative $20.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $20.b,X		; 15 20 ; OR accumulator with memory $20.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cmp [$2B.b],Y		; D7 2B ; Compare accumulator (long indexed) [$2B.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	lda ($72.b)		; B2 72 ; Load accumulator (indirect) ($72.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dec $FE.b		; C6 FE ; Decrement $FE.b [Reads: Direct Page] [Flags: NZ]
	and #$23B2.w		; 29 B2 23 ; Logical AND #$23B2.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($77.b)		; 12 77 ; OR accumulator with memory (indirect) ($77.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp [$EE.b]		; C7 EE ; Compare accumulator (long) [$EE.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	jsl $C7FA20.l		; 22 20 FA C7 ; Jump to subroutine long $C7FA20.l [Writes: Stack Pointer] [Flow: call]
	cmp [$26.b]		; C7 26 ; Compare accumulator (long) [$26.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	jsl $1340C7.l		; 22 C7 40 13 ; Jump to subroutine long $1340C7.l [Writes: Stack Pointer] [Flow: call]
	inc $B22B.w		; EE 2B B2 ; Increment $B22B.w [Flags: NZ]
	cmp $7974.w		; CD 74 79 ; Compare $7974.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ldx #$2B.b		; A2 2B ; Load #$2B.b into X register [Writes: X Index] [Flags: NZ]
	ldx $D2.b,Y		; B6 D2 ; Load X register $D2.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	stz $74.b,X		; 74 74 ; Store zero to $74.b,X [Reads: X Index]
	cmp $B22B.w,Y		; D9 2B B2 ; Compare accumulator $B22B.w,Y [Reads: Y Index] [Flags: NCZ]
	cmp [$74.b]		; C7 74 ; Compare accumulator (long) [$74.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp $2B74.w		; CD 74 2B ; Compare $2B74.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	sta $EE13.w,X		; 9D 13 EE ; Store accumulator to $EE13.w,X [Reads: Accumulator, X Index]
	cmp $223B.w,Y		; D9 3B 22 ; Compare accumulator $223B.w,Y [Reads: Y Index] [Flags: NCZ]
	cmp [$47.b]		; C7 47 ; Compare accumulator (long) [$47.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	and $401A4F.l,X		; 3F 4F 1A 40 ; AND accumulator with memory (long,X) $401A4F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda $3B.b,X		; B5 3B ; Load $3B.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	jmp ($11C7.w,X)		; 7C C7 11 ; Jump indirect indexed to ($11C7.w,X) [Reads: X Index] [Flow: jump]
	inc $B2.b		; E6 B2 ; Increment $B2.b [Reads: Direct Page] [Flags: NZ]
	lda ($E6.b)		; B2 E6 ; Load accumulator (indirect) ($E6.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$81C7.w		; 29 C7 81 ; Logical AND #$81C7.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $2B.b,S		; 23 2B ; AND accumulator with stack relative $2B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp [$C9.b]		; C7 C9 ; Compare accumulator (long) [$C9.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp [$CD.b],Y		; D7 CD ; Compare accumulator (long indexed) [$CD.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	jsr $C722.w		; 20 22 C7 ; Jump to subroutine at $C722.w [Writes: Stack Pointer] [Flow: call]
	.db $10, $12		; 10 12 ; Branch if plus to $10, $12 [Flow: branch]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	cmp [$71.b]		; C7 71 ; Compare accumulator (long) [$71.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp $71.b		; C5 71 ; Compare $71.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	brk $5D.b		; 00 5D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $11D435.l,X		; 5F 35 D4 11 ; Exclusive OR accumulator with memory (long,X) $11D435.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $E3.b		; 00 E3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C2.b		; 00 C2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $01.b		; 65 01 ; Add $01.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($D1.b),Y		; 11 D1 ; OR accumulator with memory ($D1.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ror $EE53.w,X		; 7E 53 EE ; Rotate right $EE53.w,X [Reads: X Index] [Flags: NCZ]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	adc $3434.w,X		; 7D 34 34 ; Add $3434.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $0330.w,X		; 7E 30 03 ; Rotate right $0330.w,X [Reads: X Index] [Flags: NCZ]
	ror $C6C4.w,X		; 7E C4 C6 ; Rotate right $C6C4.w,X [Reads: X Index] [Flags: NCZ]
	sta ($31.b,X)		; 81 31 ; Store accumulator ($31.b,X) [Reads: Direct Page, Accumulator, X Index]
	asl $7E.b		; 06 7E ; Arithmetic shift left $7E.b [Reads: Direct Page] [Flags: NCZ]
	ror $C634.w,X		; 7E 34 C6 ; Rotate right $C634.w,X [Reads: X Index] [Flags: NCZ]
	and ($00.b,S),Y		; 33 00 ; AND accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $6A.b		; C6 6A ; Decrement $6A.b [Reads: Direct Page] [Flags: NZ]
	ror $017E.w,X		; 7E 7E 01 ; Rotate right $017E.w,X [Reads: X Index] [Flags: NCZ]
	and ($81.b,S),Y		; 33 81 ; AND accumulator (stack relative indirect indexed) ($81.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $EA.b,S		; 03 EA ; OR accumulator with stack relative $EA.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $AC206B.l,X		; 9F 6B 20 AC ; Store accumulator (long,X) $AC206B.l,X [Reads: Accumulator, X Index]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	ora $EA.b,S		; 03 EA ; OR accumulator with stack relative $EA.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($B2.b,X)		; 01 B2 ; Logical OR ($B2.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	nop		; EA ; No operation
	nop		; EA ; No operation
	cmp [$C7.b]		; C7 C7 ; Compare accumulator (long) [$C7.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	jsl $7D1C22.l		; 22 22 1C 7D ; Jump to subroutine long $7D1C22.l [Writes: Stack Pointer] [Flow: call]
	sbc $2223CD.l		; EF CD 23 22 ; Subtract with carry (long) $2223CD.l [Writes: Accumulator] [Flags: NCVZ]
	dec $CD.b,X		; D6 CD ; Decrement memory $CD.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	jsl $A26000.l		; 22 00 60 A2 ; Jump to subroutine long $A26000.l [Writes: Stack Pointer] [Flow: call]
	sbc $16E4.w,Y		; F9 E4 16 ; Subtract with carry $16E4.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $D4F9CD.l		; 22 CD F9 D4 ; Jump to subroutine long $D4F9CD.l [Writes: Stack Pointer] [Flow: call]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	jsl $CDF911.l		; 22 11 F9 CD ; Jump to subroutine long $CDF911.l [Writes: Stack Pointer] [Flow: call]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	jsl $E40711.l		; 22 11 07 E4 ; Jump to subroutine long $E40711.l [Writes: Stack Pointer] [Flow: call]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	cmp [$B2.b]		; C7 B2 ; Compare accumulator (long) [$B2.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	jsl $DBDB34.l		; 22 34 DB DB ; Jump to subroutine long $DBDB34.l [Writes: Stack Pointer] [Flow: call]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	jsl $038A1B.l		; 22 1B 8A 03 ; Jump to subroutine long $038A1B.l [Writes: Stack Pointer] [Flow: call]
	cmp [$C8.b]		; C7 C8 ; Compare accumulator (long) [$C8.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	jsl $348C78.l		; 22 78 8C 34 ; Jump to subroutine long $348C78.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $6B		; 90 6B ; Branch if carry clear to $90, $6B [Flow: branch]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $E9.b		; 05 E9 ; Logical OR $E9.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $88.b,X		; 34 88 ; Test bits $88.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	lda ($06.b)		; B2 06 ; Load accumulator (indirect) ($06.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $34C6.w		; 8D C6 34 ; Store accumulator to $34C6.w [Reads: Accumulator]
	sta $60.b,S		; 83 60 ; Store accumulator (stack relative) $60.b,S [Reads: Stack Pointer, Accumulator]
	ora $34.b,S		; 03 34 ; OR accumulator with stack relative $34.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $82, $86, $7E		; 82 86 7E ; Branch always long to $82, $86, $7E [Flow: branch]
	ora $B3.b,S		; 03 B3 ; OR accumulator with stack relative $B3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta ($89.b,S),Y		; 93 89 ; Store accumulator (stack relative indirect indexed) ($89.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	dec $FA.b		; C6 FA ; Decrement $FA.b [Reads: Direct Page] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ora ($D1.b,X)		; 01 D1 ; Logical OR ($D1.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp ($D1.b),Y		; D1 D1 ; Compare accumulator ($D1.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	eor ($00.b,S),Y		; 53 00 ; XOR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($20.b,X)		; 01 20 ; Logical OR ($20.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta $D2.b		; 85 D2 ; Store accumulator to $D2.b [Reads: Accumulator]
	bit #$0B57.w		; 89 57 0B ; Test bits #$0B57.w with accumulator [Reads: Accumulator] [Flags: Z]
	adc $837E.w,X		; 7D 7E 83 ; Add $837E.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp ($33.b)		; D2 33 ; Compare accumulator (indirect) ($33.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	.db $30, $EA		; 30 EA ; Branch if minus to $30, $EA [Flow: branch]
	nop		; EA ; No operation
	rol $83.b,X		; 36 83 ; Rotate left $83.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	jsl $DA9503.l		; 22 03 95 DA ; Jump to subroutine long $DA9503.l [Writes: Stack Pointer] [Flow: call]
	cmp [$7E.b]		; C7 7E ; Compare accumulator (long) [$7E.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	lda ($23.b)		; B2 23 ; Load accumulator (indirect) ($23.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror $7EDF.w,X		; 7E DF 7E ; Rotate right $7EDF.w,X [Reads: X Index] [Flags: NCZ]
	ror $3332.w,X		; 7E 32 33 ; Rotate right $3332.w,X [Reads: X Index] [Flags: NCZ]
	.db $82, $C6, $83		; 82 C6 83 ; Branch always long to $82, $C6, $83 [Flow: branch]
	sbc #$3232.w		; E9 32 32 ; Subtract #$3232.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	nop		; EA ; No operation
	sta [$82.b],Y		; 97 82 ; Store accumulator (long indexed) [$82.b],Y [Reads: Direct Page, Y Index, Accumulator]
	.db $62, $2B, $31		; 62 2B 31 ; Push effective relative address $62, $2B, $31 [Writes: Stack Pointer]
	ora [$CD.b]		; 07 CD ; OR accumulator with memory (long) [$CD.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror $127B.w,X		; 7E 7B 12 ; Rotate right $127B.w,X [Reads: X Index] [Flags: NCZ]
	rol $7E.b,X		; 36 7E ; Rotate left $7E.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cmp ($7C.b,S),Y		; D3 7C ; Compare accumulator (stack relative indirect indexed) ($7C.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	cmp ($32.b,S),Y		; D3 32 ; Compare accumulator (stack relative indirect indexed) ($32.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	.db $62, $34, $07		; 62 34 07 ; Push effective relative address $62, $34, $07 [Writes: Stack Pointer]
	sta ($DD.b,X)		; 81 DD ; Store accumulator ($DD.b,X) [Reads: Direct Page, Accumulator, X Index]
	ora ($72.b,X)		; 01 72 ; Logical OR ($72.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp [$7E.b]		; C7 7E ; Compare accumulator (long) [$7E.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	nop		; EA ; No operation
	cmp ($23.b,S),Y		; D3 23 ; Compare accumulator (stack relative indirect indexed) ($23.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	jsl $C6D387.l		; 22 87 D3 C6 ; Jump to subroutine long $C6D387.l [Writes: Stack Pointer] [Flow: call]
	cmp $62.b		; C5 62 ; Compare $62.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	brk $DB.b		; 00 DB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $82, $22, $23		; 82 22 23 ; Branch always long to $82, $22, $23 [Flow: branch]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ror $B322.w,X		; 7E 22 B3 ; Rotate right $B322.w,X [Reads: X Index] [Flags: NCZ]
	ror $7D7E.w,X		; 7E 7E 7D ; Rotate right $7D7E.w,X [Reads: X Index] [Flags: NCZ]
	ror $3333.w,X		; 7E 33 33 ; Rotate right $3333.w,X [Reads: X Index] [Flags: NCZ]
	ror $CE7E.w,X		; 7E 7E CE ; Rotate right $CE7E.w,X [Reads: X Index] [Flags: NCZ]
	sbc #$0133.w		; E9 33 01 ; Subtract #$0133.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta [$89.b]		; 87 89 ; Store accumulator (long) [$89.b] [Reads: Direct Page, Accumulator]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($BB.b)		; F2 BB ; Subtract with carry (indirect) ($BB.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $B0, $4F		; B0 4F ; Branch if carry set to $B0, $4F [Flow: branch]
	jmp.w [$6A7E]		; DC 7E 6A ; Jump long indirect [$6A7E] [Flow: jump]
	ora ($71.b)		; 12 71 ; OR accumulator with memory (indirect) ($71.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $FA6A.w		; CD 6A FA ; Compare $FA6A.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and ($07.b,X)		; 21 07 ; Logical AND ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $9ECDFB.l		; 0F FB CD 9E ; OR accumulator with memory (long) $9ECDFB.l [Writes: Accumulator] [Flags: NZ]
	and ($23.b)		; 32 23 ; AND accumulator with memory (indirect) ($23.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $D29E.w		; CD 9E D2 ; Compare $D29E.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp $2223.w		; CD 23 22 ; Compare $2223.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	dec $C7.b		; C6 C7 ; Decrement $C7.b [Reads: Direct Page] [Flags: NZ]
	inc $E7.b,X		; F6 E7 ; Increment memory $E7.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	jsl $5BD921.l		; 22 21 D9 5B ; Jump to subroutine long $5BD921.l [Writes: Stack Pointer] [Flow: call]
	cmp [$C7.b]		; C7 C7 ; Compare accumulator (long) [$C7.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	and ($22.b,X)		; 21 22 ; Logical AND ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $DD.b,X		; 34 DD ; Test bits $DD.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cmp #$02D2.w		; C9 D2 02 ; Compare #$02D2.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cop $9F.b		; 02 9F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp [$D2.b],Y		; D7 D2 ; Compare accumulator (long indexed) [$D2.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	ror $B2.b,X		; 76 B2 ; Rotate right $B2.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	and ($CD.b,X)		; 21 CD ; Logical AND ($CD.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp $DDCD.w,X		; DD CD DD ; Compare accumulator $DDCD.w,X [Reads: X Index] [Flags: NCZ]
	jsl $A09E22.l		; 22 22 9E A0 ; Jump to subroutine long $A09E22.l [Writes: Stack Pointer] [Flow: call]
	cmp [$D9.b]		; C7 D9 ; Compare accumulator (long) [$D9.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	jsl $A89ED2.l		; 22 D2 9E A8 ; Jump to subroutine long $A89ED2.l [Writes: Stack Pointer] [Flow: call]
	lda #$BB2B.w		; A9 2B BB ; Load #$BB2B.w into accumulator [Writes: Accumulator] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	lda [$9F.b]		; A7 9F ; Load accumulator (long) [$9F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	stz $BBBB.w,X		; 9E BB BB ; Store zero to $BBBB.w,X [Reads: X Index]
	lda $A5D2.w		; AD D2 A5 ; Load $A5D2.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $B0, $B2		; B0 B2 ; Branch if carry set to $B0, $B2 [Flow: branch]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	lda ($B1.b),Y		; B1 B1 ; Load accumulator ($B1.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda ($B1.b),Y		; B1 B1 ; Load accumulator ($B1.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	lda ($B3.b),Y		; B1 B3 ; Load accumulator ($B3.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ldy #$C7.b		; A0 C7 ; Load #$C7.b into Y register [Writes: Y Index] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	lda ($C6.b)		; B2 C6 ; Load accumulator (indirect) ($C6.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $B7B6.w,X		; BD B6 B7 ; Load $B7B6.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	lda [$B8.b],Y		; B7 B8 ; Load accumulator (long indexed) [$B8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda $BBBBB7.l,X		; BF B7 BB BB ; Load long $BBBBB7.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda ($BC.b,S),Y		; B3 BC ; Load accumulator (stack relative indirect indexed) ($BC.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldx #$DF.b		; A2 DF ; Load #$DF.b into X register [Writes: X Index] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	.db $62, $AC, $B7		; 62 AC B7 ; Push effective relative address $62, $AC, $B7 [Writes: Stack Pointer]
	cpy $C5.b		; C4 C5 ; Compare $C5.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	lda [$B3.b],Y		; B7 B3 ; Load accumulator (long indexed) [$B3.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp [$C5.b]		; C7 C5 ; Compare accumulator (long) [$C5.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	jsr $B6C6.w		; 20 C6 B6 ; Jump to subroutine at $B6C6.w [Writes: Stack Pointer] [Flow: call]
	cmp $C5.b		; C5 C5 ; Compare $C5.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	wai		; CB ; Wait for interrupt
	cmp $CFC5.w		; CD C5 CF ; Compare $CFC5.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	lda ($DD.b,S),Y		; B3 DD ; Load accumulator (stack relative indirect indexed) ($DD.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $2BB2D4.l,X		; DF D4 B2 2B ; Compare accumulator (long,X) $2BB2D4.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	ldx $B3.b,Y		; B6 B3 ; Load X register $B3.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	lda #$BBAF.w		; A9 AF BB ; Load #$BBAF.w into accumulator [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	dec $A6.b,X		; D6 A6 ; Decrement memory $A6.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	lda #$BBC9.w		; A9 C9 BB ; Load #$BBC9.w into accumulator [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	lda ($A7.b,S),Y		; B3 A7 ; Load accumulator (stack relative indirect indexed) ($A7.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $AC.b		; C6 AC ; Decrement $AC.b [Reads: Direct Page] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	lda ($DA.b,S),Y		; B3 DA ; Load accumulator (stack relative indirect indexed) ($DA.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda #$BBA9.w		; A9 A9 BB ; Load #$BBA9.w into accumulator [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	lda #$CDBC.w		; A9 BC CD ; Load #$CDBC.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	and ($DC.b,X)		; 21 DC ; Logical AND ($DC.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp $5BCA.w,X		; DD CA 5B ; Compare accumulator $5BCA.w,X [Reads: X Index] [Flags: NCZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $E5.b,S		; E3 E5 ; Subtract stack-relative $E5.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	.db $82, $6A, $00		; 82 6A 00 ; Branch always long to $82, $6A, $00 [Flow: branch]
	and ($34.b),Y		; 31 34 ; AND accumulator with memory ($34.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	stx $87.b		; 86 87 ; Store X register to $87.b [Reads: X Index]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	.db $B0, $6C		; B0 6C ; Branch if carry set to $B0, $6C [Flow: branch]
	bit $92.b,X		; 34 92 ; Test bits $92.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sty $10.b,X		; 94 10 ; Store Y register $10.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	tyx		; [PATTERN: Memory clearing operation] BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	stz $6AAB.w,X		; 9E AB 6A ; Store zero to $6AAB.w,X [Reads: X Index]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $10, $95		; 10 95 ; Branch if plus to $10, $95 [Flow: branch]
	stz $75C6.w,X		; 9E C6 75 ; Store zero to $75C6.w,X [Reads: X Index]
	.db $B0, $01		; B0 01 ; Branch if carry set to $B0, $01 [Flow: branch]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lda $87.b,S		; A3 87 ; Load accumulator (stack relative) $87.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr $7220.w		; 20 20 72 ; Jump to subroutine at $7220.w [Writes: Stack Pointer] [Flow: call]
	and $5B5A.w		; 2D 5A 5B ; Logical AND $5B5A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	inc $1117.w		; EE 17 11 ; Increment $1117.w [Flags: NZ]
	sbc $E070E6.l,X		; FF E6 70 E0 ; Subtract with carry (long,X) $E070E6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $E6D572.l		; 22 72 D5 E6 ; Jump to subroutine long $E6D572.l [Writes: Stack Pointer] [Flow: call]
	jmp $7222FC.l		; 5C FC 22 72 ; Jump long to $7222FC.l [Flow: jump]
	bit #$2DFE.w		; 89 FE 2D ; Test bits #$2DFE.w with accumulator [Reads: Accumulator] [Flags: Z]
	and $571572.l,X		; 3F 72 15 57 ; AND accumulator with memory (long,X) $571572.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $3A63.w,X		; 1E 63 3A ; Arithmetic shift left $3A63.w,X [Reads: X Index] [Flags: NCZ]
	and $12.b,S		; 23 12 ; AND accumulator with stack relative $12.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $E2.b		; 05 E2 ; Logical OR $E2.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sty $328D.w		; 8C 8D 32 ; Store Y register to $328D.w [Reads: Y Index]
	adc [$BA.b],Y		; 77 BA ; Add with carry (long indexed) [$BA.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $E605.w		; CD 05 E6 ; Compare $E605.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsl $CDE252.l		; 22 52 E2 CD ; Jump to subroutine long $CDE252.l [Writes: Stack Pointer] [Flow: call]
	cmp $B2DF.w		; CD DF B2 ; Compare $B2DF.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsl $E685CD.l		; 22 CD 85 E6 ; Jump to subroutine long $E685CD.l [Writes: Stack Pointer] [Flow: call]
	dec $23.b		; C6 23 ; Decrement $23.b [Reads: Direct Page] [Flags: NZ]
	jsr $C73E.w		; 20 3E C7 ; Jump to subroutine at $C73E.w [Writes: Stack Pointer] [Flow: call]
	inc $85.b		; E6 85 ; Increment $85.b [Reads: Direct Page] [Flags: NZ]
	lda ($23.b)		; B2 23 ; Load accumulator (indirect) ($23.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp [$45.b]		; C7 45 ; Compare accumulator (long) [$45.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp [$5F.b],Y		; D7 5F ; Compare accumulator (long indexed) [$5F.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	and #$F627.w		; 29 27 F6 ; Logical AND #$F627.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp $22DD41.l,X		; DF 41 DD 22 ; Compare accumulator (long,X) $22DD41.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	lda ($29.b)		; B2 29 ; Load accumulator (indirect) ($29.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $15.b		; 25 15 ; Logical AND $15.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx $37.b		; E4 37 ; Compare $37.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	dec $E6.b		; C6 E6 ; Decrement $E6.b [Reads: Direct Page] [Flags: NZ]
	ora ($C7.b)		; 12 C7 ; OR accumulator with memory (indirect) ($C7.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $B2.b		; 02 B2 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp [$44.b]		; C7 44 ; Compare accumulator (long) [$44.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp [$75.b]		; C7 75 ; Compare accumulator (long) [$75.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	and #$EF21.w		; 29 21 EF ; Logical AND #$EF21.w with accumulator [Writes: Accumulator] [Flags: NZ]
	inc $D915.w		; EE 15 D9 ; Increment $D915.w [Flags: NZ]
	and ($B2.b,X)		; 21 B2 ; Logical AND ($B2.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp [$C7.b]		; C7 C7 ; Compare accumulator (long) [$C7.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	inc $C7.b		; E6 C7 ; Increment $C7.b [Reads: Direct Page] [Flags: NZ]
	jsl $EAC722.l		; 22 22 C7 EA ; Jump to subroutine long $EAC722.l [Writes: Stack Pointer] [Flow: call]
	trb $2B34.w		; 1C 34 2B ; Test and reset bits $2B34.w [Reads: Accumulator] [Flags: Z]
	jsl $C7681A.l		; 22 1A 68 C7 ; Jump to subroutine long $C7681A.l [Writes: Stack Pointer] [Flow: call]
	bit $3B.b,X		; 34 3B ; Test bits $3B.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	jsl $68E6EC.l		; 22 EC E6 68 ; Jump to subroutine long $68E6EC.l [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	lda ($BB.b)		; B2 BB ; Load accumulator (indirect) ($BB.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $1A.b,X		; 34 1A ; Test bits $1A.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	inc $96.b		; E6 96 ; Increment $96.b [Reads: Direct Page] [Flags: NZ]
	and $25.b,S		; 23 25 ; AND accumulator with stack relative $25.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $C6.b,X		; 34 C6 ; Test bits $C6.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	adc $20.b		; 65 20 ; Add $20.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($3E.b,X)		; 01 3E ; Logical OR ($3E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp [$C7.b]		; C7 C7 ; Compare accumulator (long) [$C7.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	stx $B2.b,Y		; 96 B2 ; Store X register $B2.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	and $97.b		; 25 97 ; Logical AND $97.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	stz $67C6.w		; 9C C6 67 ; Store zero to $67C6.w
	eor $0B.b,X		; 55 0B ; Exclusive OR accumulator with memory $0B.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cmp [$67.b]		; C7 67 ; Compare accumulator (long) [$67.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sbc [$E6.b]		; E7 E6 ; Subtract with carry (long) [$E6.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	lda ($C5.b)		; B2 C5 ; Load accumulator (indirect) ($C5.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	stz $0F.b,X		; 74 0F ; Store zero to $0F.b,X [Reads: X Index]
	rol $0B.b,X		; 36 0B ; Rotate left $0B.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	and $B7E620.l,X		; 3F 20 E6 B7 ; AND accumulator with memory (long,X) $B7E620.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	asl $13.b,X		; 16 13 ; Arithmetic shift left $13.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($C7.b)		; 12 C7 ; OR accumulator with memory (indirect) ($C7.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $22BB.w		; CD BB 22 ; Compare $22BB.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp [$C6.b]		; C7 C6 ; Compare accumulator (long) [$C6.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	jsr $20C7.w		; 20 C7 20 ; Jump to subroutine at $20C7.w [Writes: Stack Pointer] [Flow: call]
	jsl $EEC885.l		; 22 85 C8 EE ; Jump to subroutine long $EEC885.l [Writes: Stack Pointer] [Flow: call]
	cmp [$30.b]		; C7 30 ; Compare accumulator (long) [$30.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	jsl $1410EE.l		; 22 EE 10 14 ; Jump to subroutine long $1410EE.l [Writes: Stack Pointer] [Flow: call]
	and $BBBB.w,Y		; 39 BB BB ; AND accumulator with memory $BBBB.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp [$EE.b]		; C7 EE ; Compare accumulator (long) [$EE.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cpx $36.b		; E4 36 ; Compare $36.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	eor $C7.b		; 45 C7 ; Exclusive OR $C7.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $74.b,X		; F6 74 ; Increment memory $74.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	sta ($2B.b)		; 92 2B ; Store accumulator (indirect) ($2B.b) [Reads: Direct Page, Accumulator]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cmp $C7.b		; C5 C7 ; Compare $C7.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	and $C72B00.l,X		; 3F 00 2B C7 ; AND accumulator with memory (long,X) $C72B00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp [$74.b]		; C7 74 ; Compare accumulator (long) [$74.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	inc $B222.w,X		; FE 22 B2 ; Increment memory $B222.w,X [Reads: X Index] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	and $B2BBC7.l,X		; 3F C7 BB B2 ; AND accumulator with memory (long,X) $B2BBC7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc ($69.b),Y		; 71 69 ; Add with carry ($69.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr $68.b		; 46 68 ; Logical shift right $68.b [Reads: Direct Page] [Flags: NCZ]
	ldx $BB.b,Y		; B6 BB ; Load X register $BB.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	adc ($97.b),Y		; 71 97 ; Add with carry ($97.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $11.b,X		; B5 11 ; Load $11.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sta [$97.b],Y		; 97 97 ; Store accumulator (long indexed) [$97.b],Y [Reads: Direct Page, Y Index, Accumulator]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	dec $55.b		; C6 55 ; Decrement $55.b [Reads: Direct Page] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	inc $00C6.w		; EE C6 00 ; Increment $00C6.w [Flags: NZ]
	.db $10, $C6		; 10 C6 ; Branch if plus to $10, $C6 [Flow: branch]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	dec $1B.b		; C6 1B ; Decrement $1B.b [Reads: Direct Page] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	bit $E1.b,X		; 34 E1 ; Test bits $E1.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora ($00.b)		; 12 00 ; OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $AD.b		; 05 AD ; Logical OR $AD.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	and ($60.b,X)		; 21 60 ; Logical AND ($60.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	dec $88.b		; C6 88 ; Decrement $88.b [Reads: Direct Page] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sty $0B.b		; 84 0B ; Store Y register to $0B.b [Reads: Y Index]
	ora ($7E.b,S),Y		; 13 7E ; OR accumulator (stack relative indirect indexed) ($7E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda #$5BFF.w		; A9 FF 5B ; Load #$5BFF.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $30, $11		; 30 11 ; Branch if minus to $30, $11 [Flow: branch]
	.db $10, $03		; 10 03 ; Branch if plus to $10, $03 [Flow: branch]
	bit $03.b,X		; 34 03 ; Test bits $03.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tsb $DA.b		; 04 DA ; Test and set bits $DA.b [Reads: Accumulator] [Flags: Z]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	cmp $22B2.w,X		; DD B2 22 ; Compare accumulator $22B2.w,X [Reads: X Index] [Flags: NCZ]
	ora [$E9.b]		; 07 E9 ; OR accumulator with memory (long) [$E9.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dec $34.b		; C6 34 ; Decrement $34.b [Reads: Direct Page] [Flags: NZ]
	lda ($00.b)		; B2 00 ; Load accumulator (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp [$E9.b]		; C7 E9 ; Compare accumulator (long) [$E9.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sbc $BB22F1.l		; EF F1 22 BB ; Subtract with carry (long) $BB22F1.l [Writes: Accumulator] [Flags: NCVZ]
	sta $05.b,S		; 83 05 ; Store accumulator (stack relative) $05.b,S [Reads: Stack Pointer, Accumulator]
	cmp $3BDF.w,X		; DD DF 3B ; Compare accumulator $3BDF.w,X [Reads: X Index] [Flags: NCZ]
	jsl $82F8F3.l		; 22 F3 F8 82 ; Jump to subroutine long $82F8F3.l [Writes: Stack Pointer] [Flow: call]
	ror $33BB.w,X		; 7E BB 33 ; Rotate right $33BB.w,X [Reads: X Index] [Flags: NCZ]
	asl $DB.b		; 06 DB ; Arithmetic shift left $DB.b [Reads: Direct Page] [Flags: NCZ]
	sbc $B2FF.w,X		; FD FF B2 ; Subtract with carry $B2FF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ora $DF.b		; 05 DF ; Logical OR $DF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $05.b,X		; 34 05 ; Test bits $05.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	lda ($0B.b)		; B2 0B ; Load accumulator (indirect) ($0B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $2C.b		; 05 2C ; Logical OR $2C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	wai		; CB ; Wait for interrupt
	cmp ($9A.b)		; D2 9A ; Compare accumulator (indirect) ($9A.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora [$2B.b]		; 07 2B ; OR accumulator with memory (long) [$2B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy $3409.w,X		; BC 09 34 ; Load Y register $3409.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror $61C0.w,X		; 7E C0 61 ; Rotate right $61C0.w,X [Reads: X Index] [Flags: NCZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	rep #$C2		; C2 C2 ; Reset processor status bits #$C2 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	and ($11.b),Y		; 31 11 ; AND accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ldy $AAAA.w		; AC AA AA ; Load $AAAA.w into Y register [Writes: Y Index] [Flags: NZ]
	sta $66.b,S		; 83 66 ; Store accumulator (stack relative) $66.b,S [Reads: Stack Pointer, Accumulator]
	adc $04.b,S		; 63 04 ; Add with carry (stack relative) $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $62, $7E, $4B		; 62 7E 4B ; Push effective relative address $62, $7E, $4B [Writes: Stack Pointer]
	lda ($31.b),Y		; B1 31 ; Load accumulator ($31.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ror $0B86.w,X		; 7E 86 0B ; Rotate right $0B86.w,X [Reads: X Index] [Flags: NCZ]
	and $3B.b,X		; 35 3B ; Logical AND $3B.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$EC.b		; C0 EC ; Compare #$EC.b with Y register [Reads: Y Index] [Flags: NCZ]
	ror $5334.w,X		; 7E 34 53 ; Rotate right $5334.w,X [Reads: X Index] [Flags: NCZ]
	ora ($01.b,S),Y		; 13 01 ; OR accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $7E7E.w		; EE 7E 7E ; Increment $7E7E.w [Flags: NZ]
	bit $23.b,X		; 34 23 ; Test bits $23.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $30, $EE		; 30 EE ; Branch if minus to $30, $EE [Flow: branch]
	inc $85.b		; E6 85 ; Increment $85.b [Reads: Direct Page] [Flags: NZ]
	stx $12.b		; 86 12 ; Store X register to $12.b [Reads: X Index]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ora $7195.w		; 0D 95 71 ; Logical OR $7195.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cpx $02CB.w		; EC CB 02 ; Compare $02CB.w with X register [Reads: X Index] [Flags: NCZ]
	and $42.b,X		; 35 42 ; Logical AND $42.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0534.w		; 8D 34 05 ; Store accumulator to $0534.w [Reads: Accumulator]
	.db $70, $71		; 70 71 ; Branch if overflow set to $70, $71 [Flow: branch]
	sta $000E79.l,X		; 9F 79 0E 00 ; Store accumulator (long,X) $000E79.l,X [Reads: Accumulator, X Index]
	jmp ($A157.w,X)		; 7C 57 A1 ; Jump indirect indexed to ($A157.w,X) [Reads: X Index] [Flow: jump]
	sta $072087.l,X		; 9F 87 20 07 ; Store accumulator (long,X) $072087.l,X [Reads: Accumulator, X Index]
	inc $F1.b		; E6 F1 ; Increment $F1.b [Reads: Direct Page] [Flags: NZ]
	mvn $62,$75		; 54 75 62 ; Move block negative $62,$75 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	and [$75.b]		; 27 75 ; AND accumulator with memory (long) [$75.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	adc $E6.b,X		; 75 E6 ; Add $E6.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc [$72.b],Y		; 77 72 ; Add with carry (long indexed) [$72.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $E627.w		; EE 27 E6 ; Increment $E627.w [Flags: NZ]
	inc $21.b		; E6 21 ; Increment $21.b [Reads: Direct Page] [Flags: NZ]
	jsl $F2EDE6.l		; 22 E6 ED F2 ; Jump to subroutine long $F2EDE6.l [Writes: Stack Pointer] [Flow: call]
	sta [$22.b],Y		; 97 22 ; Store accumulator (long indexed) [$22.b],Y [Reads: Direct Page, Y Index, Accumulator]
	ora $D5.b,X		; 15 D5 ; OR accumulator with memory $D5.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	ror $16.b		; 66 16 ; Rotate right $16.b [Reads: Direct Page] [Flags: NCZ]
	ora ($20.b),Y		; 11 20 ; OR accumulator with memory ($20.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	dec $31.b		; C6 31 ; Decrement $31.b [Reads: Direct Page] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	ora ($66.b),Y		; 11 66 ; OR accumulator with memory ($66.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	cld		; D8 ; Clear decimal flag [Flags: D]
	cmp [$12.b],Y		; D7 12 ; Compare accumulator (long indexed) [$12.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	jsl $E6DA15.l		; 22 15 DA E6 ; Jump to subroutine long $E6DA15.l [Writes: Stack Pointer] [Flow: call]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	lda ($22.b)		; B2 22 ; Load accumulator (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc ($47.b),Y		; 71 47 ; Add with carry ($47.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta [$42.b]		; 87 42 ; Store accumulator (long) [$42.b] [Reads: Direct Page, Accumulator]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	and $E6.b,X		; 35 E6 ; Logical AND $E6.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cmp [$0F.b]		; C7 0F ; Compare accumulator (long) [$0F.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	.db $10, $22		; 10 22 ; Branch if plus to $10, $22 [Flow: branch]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ora $EE.b,X		; 15 EE ; OR accumulator with memory $EE.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sbc $C712B1.l		; EF B1 12 C7 ; Subtract with carry (long) $C712B1.l [Writes: Accumulator] [Flags: NCVZ]
	inc $E6.b		; E6 E6 ; Increment $E6.b [Reads: Direct Page] [Flags: NZ]
	adc $2B22.w,Y		; 79 22 2B ; Add $2B22.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta [$50.b],Y		; 97 50 ; Store accumulator (long indexed) [$50.b],Y [Reads: Direct Page, Y Index, Accumulator]
	eor $775750.l		; 4F 50 57 77 ; Exclusive OR accumulator with memory (long) $775750.l [Writes: Accumulator] [Flags: NZ]
	eor ($C6.b),Y		; 51 C6 ; Exclusive OR accumulator with memory ($C6.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $C6.b		; 65 C6 ; Add $C6.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $12		; 70 12 ; Branch if overflow set to $70, $12 [Flow: branch]
	ldx $B1.b,Y		; B6 B1 ; Load X register $B1.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	trb $BA.b		; 14 BA ; Test and reset bits $BA.b [Reads: Accumulator] [Flags: Z]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	wai		; CB ; Wait for interrupt
	lda ($16.b),Y		; B1 16 ; Load accumulator ($16.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $22BCCD.l		; EF CD BC 22 ; Subtract with carry (long) $22BCCD.l [Writes: Accumulator] [Flags: NCVZ]
	cmp ($C8.b,S),Y		; D3 C8 ; Compare accumulator (stack relative indirect indexed) ($C8.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	ora $BB1B.w,Y		; 19 1B BB ; OR accumulator with memory $BB1B.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cpy $B3C8.w		; CC C8 B3 ; Compare $B3C8.w with Y register [Reads: Y Index] [Flags: NCZ]
	ldy #$CD.b		; A0 CD ; Load #$CD.b into Y register [Writes: Y Index] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	lda ($DF.b)		; B2 DF ; Load accumulator (indirect) ($DF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy $D8.b,X		; B4 D8 ; Load Y register $D8.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	ldx $2B.b		; A6 2B ; Load $2B.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	pei ($A9.b)		; D4 A9 ; Push effective indirect address ($A9.b) [Reads: Direct Page] [Writes: Stack Pointer]
.ACCU 16
.INDEX 16
	rep #$B5		; C2 B5
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	stz $EFB4.w,X		; 9E B4 EF ; Store zero to $EFB4.w,X [Reads: X Index]
	cmp $22BB.w,X		; DD BB 22 ; Compare accumulator $22BB.w,X [Reads: X Index] [Flags: NCZ]
	cmp [$D7.b]		; C7 D7 ; Compare accumulator (long) [$D7.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	lda $B4.b,S		; A3 B4 ; Load accumulator (stack relative) $B4.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	cmp [$C7.b]		; C7 C7 ; Compare accumulator (long) [$C7.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ldy $C7.b,X		; B4 C7 ; Load Y register $C7.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	jsl $9EA0B2.l		; 22 B2 A0 9E ; Jump to subroutine long $9EA0B2.l [Writes: Stack Pointer] [Flow: call]
	ldy $BBC7.w		; AC C7 BB ; Load $BBC7.w into Y register [Writes: Y Index] [Flags: NZ]
	lda ($AC.b)		; B2 AC ; Load accumulator (indirect) ($AC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy $CDC7.w		; AC C7 CD ; Load $CDC7.w into Y register [Writes: Y Index] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	jsl $F6A2C7.l		; 22 C7 A2 F6 ; Jump to subroutine long $F6A2C7.l [Writes: Stack Pointer] [Flow: call]
	inc $2B.b,X		; F6 2B ; Increment memory $2B.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	jsl $B5C7DF.l		; 22 DF C7 B5 ; Jump to subroutine long $B5C7DF.l [Writes: Stack Pointer] [Flow: call]
	ldx #$BB22.w		; A2 22 BB ; Load #$BB22.w into X register [Writes: X Index] [Flags: NZ]
	cpx $C7.b		; E4 C7 ; Compare $C7.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	cmp ($C7.b)		; D2 C7 ; Compare accumulator (indirect) ($C7.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	jsl $D9B522.l		; 22 22 B5 D9 ; Jump to subroutine long $D9B522.l [Writes: Stack Pointer] [Flow: call]
	cmp $B2CD.w		; CD CD B2 ; Compare $B2CD.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsl $D79EDF.l		; 22 DF 9E D7 ; Jump to subroutine long $D79EDF.l [Writes: Stack Pointer] [Flow: call]
	cmp $B5222B.l,X		; DF 2B 22 B5 ; Compare accumulator (long,X) $B5222B.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	ldy #$EFC7.w		; A0 C7 EF ; Load #$EFC7.w into Y register [Writes: Y Index] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	jsl $EFF6D6.l		; 22 D6 F6 EF ; Jump to subroutine long $EFF6D6.l [Writes: Stack Pointer] [Flow: call]
	stz $2322.w,X		; 9E 22 23 ; Store zero to $2322.w,X [Reads: X Index]
	eor $8D8CFF.l		; 4F FF 8C 8D ; Exclusive OR accumulator with memory (long) $8D8CFF.l [Writes: Accumulator] [Flags: NZ]
	adc ($77.b)		; 72 77 ; Add with carry (indirect) ($77.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($7B.b,S),Y		; 33 7B ; AND accumulator (stack relative indirect indexed) ($7B.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor ($77.b),Y		; 51 77 ; Exclusive OR accumulator with memory ($77.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($51.b,X)		; E1 51 ; Subtract with carry ($51.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($F7.b),Y		; 51 F7 ; Exclusive OR accumulator with memory ($F7.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda [$72.b],Y		; B7 72 ; Load accumulator (long indexed) [$72.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $24.b		; 65 24 ; Add $24.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	ora $B7231C.l		; 0F 1C 23 B7 ; OR accumulator with memory (long) $B7231C.l [Writes: Accumulator] [Flags: NZ]
	sta $CE31.w		; 8D 31 CE ; Store accumulator to $CE31.w [Reads: Accumulator]
	and [$12.b]		; 27 12 ; AND accumulator with memory (long) [$12.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jmp $E6B8.w		; 4C B8 E6 ; Jump to $E6B8.w [Flow: jump]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	and $2020.w,Y		; 39 20 20 ; AND accumulator with memory $2020.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	dec $1E.b		; C6 1E ; Decrement $1E.b [Reads: Direct Page] [Flags: NZ]
	cmp ($50.b),Y		; D1 50 ; Compare accumulator ($50.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	.db $30, $96		; 30 96 ; Branch if minus to $30, $96 [Flow: branch]
	sbc $32054F.l,X		; FF 4F 05 32 ; Subtract with carry (long,X) $32054F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($02.b),Y		; 71 02 ; Add with carry ($02.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($90.b,X)		; E1 90 ; Subtract with carry ($90.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $2132.w		; 2D 32 21 ; Logical AND $2132.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $FAE6.w,X		; FD E6 FA ; Subtract with carry $FAE6.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta [$22.b]		; 87 22 ; Store accumulator (long) [$22.b] [Reads: Direct Page, Accumulator]
	adc [$E4.b]		; 67 E4 ; Add with carry (long) [$E4.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
.ACCU 8
	sep #$E6		; E2 E6
	inc $62.b		; E6 62 ; Increment $62.b [Reads: Direct Page] [Flags: NZ]
	rol $C6.b		; 26 C6 ; Rotate left $C6.b [Reads: Direct Page] [Flags: NCZ]
	jmp $07E6E4.l		; 5C E4 E6 07 ; Jump long to $07E6E4.l [Flow: jump]
	.db $62, $E6, $66		; 62 E6 66 ; Push effective relative address $62, $E6, $66 [Writes: Stack Pointer]
	dec $26.b		; C6 26 ; Decrement $26.b [Reads: Direct Page] [Flags: NZ]
	and ($0C.b,X)		; 21 0C ; Logical AND ($0C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $2F26.w		; 2D 26 2F ; Logical AND $2F26.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and ($CC.b),Y		; 31 CC ; AND accumulator with memory ($CC.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpy $3332.w		; CC 32 33 ; Compare $3332.w with Y register [Reads: Y Index] [Flags: NCZ]
	bit $26.b,X		; 34 26 ; Test bits $26.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cpy $3ECC.w		; CC CC 3E ; Compare $3ECC.w with Y register [Reads: Y Index] [Flags: NCZ]
	and ($35.b),Y		; 31 35 ; AND accumulator with memory ($35.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	rol $CC.b		; 26 CC ; Rotate left $CC.b [Reads: Direct Page] [Flags: NCZ]
	cpy $2626.w		; CC 26 26 ; Compare $2626.w with Y register [Reads: Y Index] [Flags: NCZ]
	rol $48.b		; 26 48 ; Rotate left $48.b [Reads: Direct Page] [Flags: NCZ]
	cpy $26CC.w		; CC CC 26 ; Compare $26CC.w with Y register [Reads: Y Index] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	jmp $CC26.w		; 4C 26 CC ; Jump to $CC26.w [Flow: jump]
	cpy $4726.w		; CC 26 47 ; Compare $4726.w with Y register [Reads: Y Index] [Flags: NCZ]
	bit $CC54.w		; 2C 54 CC ; Test bits $CC54.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	cpy $5B56.w		; CC 56 5B ; Compare $5B56.w with Y register [Reads: Y Index] [Flags: NCZ]
	eor $CC59.w,X		; 5D 59 CC ; Exclusive OR accumulator with memory $CC59.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy $6356.w		; CC 56 63 ; Compare $6356.w with Y register [Reads: Y Index] [Flags: NCZ]
	adc $63.b		; 65 63 ; Add $63.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cpy $67CC.w		; CC CC 67 ; Compare $67CC.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
.ACCU 16
	rep #$2C		; C2 2C
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	.db $70, $C2		; 70 C2 ; Branch if overflow set to $70, $C2 [Flow: branch]
	jsl $706869.l		; 22 69 68 70 ; Jump to subroutine long $706869.l [Writes: Stack Pointer] [Flow: call]
	.db $70, $CC		; 70 CC ; Branch if overflow set to $70, $CC [Flow: branch]
	jsl $686969.l		; 22 69 69 68 ; Jump to subroutine long $686969.l [Writes: Stack Pointer] [Flow: call]
	.db $70, $CC		; 70 CC ; Branch if overflow set to $70, $CC [Flow: branch]
.ACCU 16
.INDEX 16
	rep #$70		; C2 70
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $70, $68		; 70 68 ; Branch if overflow set to $70, $68 [Flow: branch]
	bit $6B2C.w		; 2C 2C 6B ; Test bits $6B2C.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	.db $70, $6C		; 70 6C ; Branch if overflow set to $70, $6C [Flow: branch]
	.db $70, $C2		; 70 C2 ; Branch if overflow set to $70, $C2 [Flow: branch]
.ACCU 16
.INDEX 16
	rep #$70		; C2 70
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	.db $70, $22		; 70 22 ; Branch if overflow set to $70, $22 [Flow: branch]
	jsl $706970.l		; 22 70 69 70 ; Jump to subroutine long $706970.l [Writes: Stack Pointer] [Flow: call]
	.db $70, $2C		; 70 2C ; Branch if overflow set to $70, $2C [Flow: branch]
	jsl $687070.l		; 22 70 70 68 ; Jump to subroutine long $687070.l [Writes: Stack Pointer] [Flow: call]
	adc #$CC22.w		; 69 22 CC ; Add #$CC22.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $70, $69		; 70 69 ; Branch if overflow set to $70, $69 [Flow: branch]
	.db $70, $C2		; 70 C2 ; Branch if overflow set to $70, $C2 [Flow: branch]
.ACCU 16
	rep #$69		; C2 69
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	cpy $6A22.w		; CC 22 6A ; Compare $6A22.w with Y register [Reads: Y Index] [Flags: NCZ]
	adc #$7070.w		; 69 70 70 ; Add #$7070.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cpy $7022.w		; CC 22 70 ; Compare $7022.w with Y register [Reads: Y Index] [Flags: NCZ]
	adc #$706A.w		; 69 6A 70 ; Add #$706A.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	bit $69C2.w		; 2C C2 69 ; Test bits $69C2.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	adc $CC70.w		; 6D 70 CC ; Add $CC70.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
.ACCU 16
	rep #$6B		; C2 6B
	.db $70, $6D		; 70 6D ; Branch if overflow set to $70, $6D [Flow: branch]
	adc #$CCC2.w		; 69 C2 CC ; Add #$CCC2.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	adc #$7068.w		; 69 68 70 ; Add #$7068.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $CC		; 70 CC ; Branch if overflow set to $70, $CC [Flow: branch]
	jsl $69706D.l		; 22 6D 70 69 ; Jump to subroutine long $69706D.l [Writes: Stack Pointer] [Flow: call]
	adc #$CCC2.w		; 69 C2 CC ; Add #$CCC2.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	jsl $706A22.l		; 22 22 6A 70 ; Jump to subroutine long $706A22.l [Writes: Stack Pointer] [Flow: call]
	adc #$C270.w		; 69 70 C2 ; Add #$C270.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
.ACCU 16
.INDEX 16
	rep #$70		; C2 70
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	jsl $696C2C.l		; 22 2C 6C 69 ; Jump to subroutine long $696C2C.l [Writes: Stack Pointer] [Flow: call]
	.db $70, $69		; 70 69 ; Branch if overflow set to $70, $69 [Flow: branch]
	cpy $6B2C.w		; CC 2C 6B ; Compare $6B2C.w with Y register [Reads: Y Index] [Flags: NCZ]
	jmp ($706F.w)		; 6C 6F 70 ; Jump indirect to ($706F.w) [Flow: jump]
	cpy $76CC.w		; CC CC 76 ; Compare $76CC.w with Y register [Reads: Y Index] [Flags: NCZ]
	adc ($53.b)		; 72 53 ; Add with carry (indirect) ($53.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc $CC.b,X		; 75 CC ; Add $CC.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	trb $75E3.w		; 1C E3 75 ; Test and reset bits $75E3.w [Reads: Accumulator] [Flags: Z]
	ror $7C.b,X		; 76 7C ; Rotate right $7C.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tsb $79CC.w		; 0C CC 79 ; Test and set bits $79CC.w [Reads: Accumulator] [Flags: Z]
	cmp #$7F6D.w		; C9 6D 7F ; Compare #$7F6D.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cpy #$801C.w		; C0 1C 80 ; Compare #$801C.w with Y register [Reads: Y Index] [Flags: NCZ]
	bit $7F.b,X		; 34 7F ; Test bits $7F.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cpy #$83C1.w		; C0 C1 83 ; Compare #$83C1.w with Y register [Reads: Y Index] [Flags: NCZ]
	jmp ($3434.w,X)		; 7C 34 34 ; Jump indirect indexed to ($3434.w,X) [Reads: X Index] [Flow: jump]
	cpy $1F00.w		; CC 00 1F ; Compare $1F00.w with Y register [Reads: Y Index] [Flags: NCZ]
	bit $8D.b,X		; 34 8D ; Test bits $8D.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sta [$50.b]		; 87 50 ; Store accumulator (long) [$50.b] [Reads: Direct Page, Accumulator]
	cpy $908F.w		; CC 8F 90 ; Compare $908F.w with Y register [Reads: Y Index] [Flags: NCZ]
	sta ($92.b),Y		; 91 92 ; Store accumulator ($92.b),Y [Reads: Direct Page, Y Index, Accumulator]
	cpy $9ECC.w		; CC CC 9E ; Compare $9ECC.w with Y register [Reads: Y Index] [Flags: NCZ]
	cmp $8783.w		; CD 83 87 ; Compare $8783.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	and ($CC.b)		; 32 CC ; AND accumulator with memory (indirect) ($CC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $90, $9E		; 90 9E ; Branch if carry clear to $90, $9E [Flow: branch]
	ldy #$CC91.w		; A0 91 CC ; Load #$CC91.w into Y register [Writes: Y Index] [Flags: NZ]
	cpy $A3A1.w		; CC A1 A3 ; Compare $A3A1.w with Y register [Reads: Y Index] [Flags: NCZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	cmp $22CC.w		; CD CC 22 ; Compare $22CC.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	lda $AC.b		; A5 AC ; Load $AC.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $90, $90		; 90 90 ; Branch if carry clear to $90, $90 [Flow: branch]
	cpy $ADCC.w		; CC CC AD ; Compare $ADCC.w with Y register [Reads: Y Index] [Flags: NCZ]
	lda ($AF.b,X)		; A1 AF ; Load accumulator ($AF.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and ($CC.b,X)		; 21 CC ; Logical AND ($CC.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp $B9.b		; C5 B9 ; Compare $B9.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	.db $B0, $BB		; B0 BB ; Branch if carry set to $B0, $BB [Flow: branch]
	ldy $CCCC.w,X		; BC CC CC ; Load Y register $CCCC.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda [$A1.b],Y		; B7 A1 ; Load accumulator (long indexed) [$A1.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ldx $CCCC.w,Y		; BE CC CC ; Load X register $CCCC.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	adc $4F.b		; 65 4F ; Add $4F.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp $83.b,S		; C3 83 ; Compare accumulator (stack relative) $83.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	ora [$CC.b],Y		; 17 CC ; OR accumulator with memory (long indexed) [$CC.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta [$34.b]		; 87 34 ; Store accumulator (long) [$34.b] [Reads: Direct Page, Accumulator]
	cpy $51.b		; C4 51 ; Compare $51.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	cpy #$AAC7.w		; C0 C7 AA ; Compare #$AAC7.w with Y register [Reads: Y Index] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ror $66.b		; 66 66 ; Rotate right $66.b [Reads: Direct Page] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	cmp [$71.b]		; C7 71 ; Compare accumulator (long) [$71.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jmp ($34CC.w)		; 6C CC 34 ; Jump indirect to ($34CC.w) [Flow: jump]
	cmp #$CBC9.w		; C9 C9 CB ; Compare #$CBC9.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	tsb $CBCC.w		; 0C CC CB ; Test and set bits $CBCC.w [Reads: Accumulator] [Flags: Z]
	cmp ($B9.b,X)		; C1 B9 ; Compare accumulator ($B9.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	lda $CC.b		; A5 CC ; Load $CC.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp ($A1.b,X)		; C1 A1 ; Compare accumulator ($A1.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	cmp $CC86D3.l		; CF D3 86 CC ; Compare accumulator (long) $CC86D3.l [Reads: Accumulator] [Flags: NCZ]
	cpy $A1C4.w		; CC C4 A1 ; Compare $A1C4.w with Y register [Reads: Y Index] [Flags: NCZ]
	cmp #$1CCC.w		; C9 CC 1C ; Compare #$1CCC.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cpy $C2D7.w		; CC D7 C2 ; Compare $C2D7.w with Y register [Reads: Y Index] [Flags: NCZ]
	cmp #$CCD9.w		; C9 D9 CC ; Compare #$CCD9.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cpy $70CB.w		; CC CB 70 ; Compare $70CB.w with Y register [Reads: Y Index] [Flags: NCZ]
	sta $B9.b		; 85 B9 ; Store accumulator to $B9.b [Reads: Accumulator]
	cpy $A9CC.w		; CC CC A9 ; Compare $A9CC.w with Y register [Reads: Y Index] [Flags: NCZ]
	pei ($71.b)		; D4 71 ; Push effective indirect address ($71.b) [Reads: Direct Page] [Writes: Stack Pointer]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	tsb $A5CC.w		; 0C CC A5 ; Test and set bits $A5CC.w [Reads: Accumulator] [Flags: Z]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	pei ($E0.b)		; D4 E0 ; Push effective indirect address ($E0.b) [Reads: Direct Page] [Writes: Stack Pointer]
	cpy $E1CC.w		; CC CC E1 ; Compare $E1CC.w with Y register [Reads: Y Index] [Flags: NCZ]
	jmp.w [$DEDE]		; DC DE DE ; Jump long indirect [$DEDE] [Flow: jump]
	cpy $DDCC.w		; CC CC DD ; Compare $DDCC.w with Y register [Reads: Y Index] [Flags: NCZ]
	sta $CBC9.w,X		; 9D C9 CB ; Store accumulator to $CBC9.w,X [Reads: Accumulator, X Index]
	cpy $E5CC.w		; CC CC E5 ; Compare $E5CC.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpx $C0C3.w		; EC C3 C0 ; Compare $C0C3.w with X register [Reads: X Index] [Flags: NCZ]
	cpy $EDCC.w		; CC CC ED ; Compare $EDCC.w with Y register [Reads: Y Index] [Flags: NCZ]
	sbc $CCD0F1.l		; EF F1 D0 CC ; Subtract with carry (long) $CCD0F1.l [Writes: Accumulator] [Flags: NCVZ]
	cpy $C9A4.w		; CC A4 C9 ; Compare $C9A4.w with Y register [Reads: Y Index] [Flags: NCZ]
	wai		; CB ; Wait for interrupt
	sbc ($CC.b)		; F2 CC ; Subtract with carry (indirect) ($CC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cpy $78F4.w		; CC F4 78 ; Compare $78F4.w with Y register [Reads: Y Index] [Flags: NCZ]
	sbc [$7C.b],Y		; F7 7C ; Subtract with carry (long indexed) [$7C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy $34CC.w		; CC CC 34 ; Compare $34CC.w with Y register [Reads: Y Index] [Flags: NCZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	jmp ($0CFD.w,X)		; 7C FD 0C ; Jump indirect indexed to ($0CFD.w,X) [Reads: X Index] [Flow: jump]
	cpy $FEC7.w		; CC C7 FE ; Compare $FEC7.w with Y register [Reads: Y Index] [Flags: NCZ]
	jsr ($2CC7.w,X)		; FC C7 2C ; Jump to subroutine indirect indexed ($2CC7.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
.ACCU 16
.INDEX 16
	rep #$FD		; C2 FD
	inc $C034.w,X		; FE 34 C0 ; Increment memory $C034.w,X [Reads: X Index] [Flags: NZ]
	cpy $C20C.w		; CC 0C C2 ; Compare $C20C.w with Y register [Reads: Y Index] [Flags: NCZ]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	sbc $03DCCD.l,X		; FF CD DC 03 ; Subtract with carry (long,X) $03DCCD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $CD25.w		; CD 25 CD ; Compare $CD25.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp ($32.b)		; D2 32 ; Compare accumulator (indirect) ($32.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora $C7.b		; 05 C7 ; Logical OR $C7.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $D2FD.w,X		; FE FD D2 ; Increment memory $D2FD.w,X [Reads: X Index] [Flags: NZ]
	cpy $C0CD.w		; CC CD C0 ; Compare $C0CD.w with Y register [Reads: Y Index] [Flags: NCZ]
	stx $2CFF.w		; 8E FF 2C ; Store X register to $2CFF.w [Reads: X Index]
	cpy $FC0B.w		; CC 0B FC ; Compare $FC0B.w with Y register [Reads: Y Index] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cmp $D2DC.w		; CD DC D2 ; Compare $D2DC.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp $0CFE.w		; CD FE 0C ; Compare $0CFE.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp ($2C.b,S),Y		; D3 2C ; Compare accumulator (stack relative indirect indexed) ($2C.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	jmp.w [$3478]		; DC 78 34 ; Jump long indirect [$3478] [Flow: jump]
	and ($E7.b)		; 32 E7 ; AND accumulator with memory (indirect) ($E7.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpy #$CD21.w		; C0 21 CD ; Compare #$CD21.w with Y register [Reads: Y Index] [Flags: NCZ]
	cmp [$0C.b],Y		; D7 0C ; Compare accumulator (long indexed) [$0C.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cmp [$22.b]		; C7 22 ; Compare accumulator (long) [$22.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp ($C0.b)		; D2 C0 ; Compare accumulator (indirect) ($C0.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
.ACCU 16
.INDEX 16
	rep #$78		; C2 78
	cmp [$CC.b]		; C7 CC ; Compare accumulator (long) [$CC.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	.db $62, $08, $C7		; 62 08 C7 ; Push effective relative address $62, $08, $C7 [Writes: Stack Pointer]
	cmp [$08.b]		; C7 08 ; Compare accumulator (long) [$08.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp ($2D.b)		; D2 2D ; Compare accumulator (indirect) ($2D.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	asl $36.b		; 06 36 ; Arithmetic shift left $36.b [Reads: Direct Page] [Flags: NCZ]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $DD		; D0 DD ; Branch if not equal to $D0, $DD [Flow: branch]
	ora $0ACD35.l,X		; 1F 35 CD 0A ; Logical OR long $0ACD35.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $2D		; B0 2D ; Branch if carry set to $B0, $2D [Flow: branch]
	cmp $CDCD.w		; CD CD CD ; Compare $CDCD.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	bit $22.b,X		; 34 22 ; Test bits $22.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	jsr $2534.w		; 20 34 25 ; Jump to subroutine at $2534.w [Writes: Stack Pointer] [Flow: call]
	and $26.b		; 25 26 ; Logical AND $26.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $33.b,S		; 23 33 ; AND accumulator with stack relative $33.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp [$78.b],Y		; D7 78 ; Compare accumulator (long indexed) [$78.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cmp [$33.b]		; C7 33 ; Compare accumulator (long) [$33.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	rol $22.b		; 26 22 ; Rotate left $22.b [Reads: Direct Page] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	bit $78.b,X		; 34 78 ; Test bits $78.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cmp [$22.b]		; C7 22 ; Compare accumulator (long) [$22.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	.db $62, $0D, $C2		; 62 0D C2 ; Push effective relative address $62, $0D, $C2 [Writes: Stack Pointer]
	jmp.w [$DCB9]		; DC B9 DC ; Jump long indirect [$DCB9] [Flow: jump]
	cpy $F834.w		; CC 34 F8 ; Compare $F834.w with Y register [Reads: Y Index] [Flags: NCZ]
	sbc $22DF.w		; ED DF 22 ; Subtract $22DF.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ora ($CF.b)		; 12 CF ; OR accumulator with memory (indirect) ($CF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $D379.w		; 6D 79 D3 ; Add $D379.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	and ($CC.b,X)		; 21 CC ; Logical AND ($CC.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpy #$C111.w		; C0 11 C1 ; Compare #$C111.w with Y register [Reads: Y Index] [Flags: NCZ]
	bit $CD.b,X		; 34 CD ; Test bits $CD.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	rep #$C5		; C2 C5 ; Reset processor status bits #$C5 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	cmp $226D0A.l,X		; DF 0A 6D 22 ; Compare accumulator (long,X) $226D0A.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	cmp ($72.b),Y		; D1 72 ; Compare accumulator ($72.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	adc $CCB9DA.l		; 6F DA B9 CC ; Add with carry (long) $CCB9DA.l [Writes: Accumulator] [Flags: NCVZ]
	cpy $C736.w		; CC 36 C7 ; Compare $C736.w with Y register [Reads: Y Index] [Flags: NCZ]
	cmp ($F4.b,X)		; C1 F4 ; Compare accumulator ($F4.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	jsl $ED78CC.l		; 22 CC 78 ED ; Jump to subroutine long $ED78CC.l [Writes: Stack Pointer] [Flow: call]
	jmp ($C178.w,X)		; 7C 78 C1 ; Jump indirect indexed to ($C178.w,X) [Reads: X Index] [Flow: jump]
	dec $ED.b		; C6 ED ; Decrement $ED.b [Reads: Direct Page] [Flags: NZ]
	cmp $FC.b		; C5 FC ; Compare $FC.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	jsr ($CC12.w,X)		; FC 12 CC ; Jump to subroutine indirect indexed ($CC12.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora $CD.b,S		; 03 CD ; OR accumulator with stack relative $CD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	cmp ($DD.b)		; D2 DD ; Compare accumulator (indirect) ($DD.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp $C7D1.w		; CD D1 C7 ; Compare $C7D1.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp [$22.b]		; C7 22 ; Compare accumulator (long) [$22.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	jsl $C7D7C7.l		; 22 C7 D7 C7 ; Jump to subroutine long $C7D7C7.l [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsl $010B2D.l		; 22 2D 0B 01 ; Jump to subroutine long $010B2D.l [Writes: Stack Pointer] [Flow: call]
	cmp [$0A.b]		; C7 0A ; Compare accumulator (long) [$0A.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp $C72D.w,X		; DD 2D C7 ; Compare accumulator $C72D.w,X [Reads: X Index] [Flags: NCZ]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	tsb $2D.b		; 04 2D ; Test and set bits $2D.b [Reads: Accumulator] [Flags: Z]
	cmp $05CD.w,X		; DD CD 05 ; Compare accumulator $05CD.w,X [Reads: X Index] [Flags: NCZ]
	cmp [$C7.b]		; C7 C7 ; Compare accumulator (long) [$C7.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	and $C622.w		; 2D 22 C6 ; Logical AND $C622.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp [$C7.b]		; C7 C7 ; Compare accumulator (long) [$C7.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	and $CD0B.w		; 2D 0B CD ; Logical AND $CD0B.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp [$CD.b]		; C7 CD ; Compare accumulator (long) [$CD.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp ($22.b)		; D2 22 ; Compare accumulator (indirect) ($22.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cmp [$DD.b]		; C7 DD ; Compare accumulator (long) [$DD.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp ($03.b)		; D2 03 ; Compare accumulator (indirect) ($03.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	tsb $0A.b		; 04 0A ; Test and set bits $0A.b [Reads: Accumulator] [Flags: Z]
	cmp [$DD.b]		; C7 DD ; Compare accumulator (long) [$DD.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp ($F8.b)		; D2 F8 ; Compare accumulator (indirect) ($F8.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp $CD28.w		; CD 28 CD ; Compare $CD28.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsl $C7CD32.l		; 22 32 CD C7 ; Jump to subroutine long $C7CD32.l [Writes: Stack Pointer] [Flow: call]
	ora $32.b,S		; 03 32 ; OR accumulator with stack relative $32.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $719BD2.l		; 22 D2 9B 71 ; Jump to subroutine long $719BD2.l [Writes: Stack Pointer] [Flow: call]
	ora ($13.b)		; 12 13 ; OR accumulator with memory (indirect) ($13.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpy #$1433.w		; C0 33 14 ; Compare #$1433.w with Y register [Reads: Y Index] [Flags: NCZ]
	tsb $9B.b		; 04 9B ; Test and set bits $9B.b [Reads: Accumulator] [Flags: Z]
	ora $C2CD3D.l		; 0F 3D CD C2 ; OR accumulator with memory (long) $C2CD3D.l [Writes: Accumulator] [Flags: NZ]
	adc ($F8.b),Y		; 71 F8 ; Add with carry ($F8.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $03C0.w,X		; 1D C0 03 ; OR accumulator with memory $03C0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$110F.w		; C0 0F 11 ; Compare #$110F.w with Y register [Reads: Y Index] [Flags: NCZ]
	eor ($2D.b,S),Y		; 53 2D ; XOR accumulator (stack relative indirect indexed) ($2D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp ($CD.b),Y		; D1 CD ; Compare accumulator ($CD.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	and $DEB9.w		; 2D B9 DE ; Logical AND $DEB9.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and ($CC.b,X)		; 21 CC ; Logical AND ($CC.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$DDC2.w		; C0 C2 DD ; Compare #$DDC2.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpy $7116.w		; CC 16 71 ; Compare $7116.w with Y register [Reads: Y Index] [Flags: NCZ]
	dec $08.b		; C6 08 ; Decrement $08.b [Reads: Direct Page] [Flags: NZ]
	.db $D0, $2D		; D0 2D ; Branch if not equal to $D0, $2D [Flow: branch]
	cmp ($18.b,X)		; C1 18 ; Compare accumulator ($18.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	ora ($C0.b),Y		; 11 C0 ; OR accumulator with memory ($C0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $10DC.w		; CD DC 10 ; Compare $10DC.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	stz $B9B9.w		; 9C B9 B9 ; Store zero to $B9B9.w
	jmp.w [$99CC]		; DC CC 99 ; Jump long indirect [$99CC] [Flow: jump]
	and $26.b		; 25 26 ; Logical AND $26.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $33.b		; 05 33 ; Logical OR $33.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $DAD7.w,X		; 3D D7 DA ; AND accumulator with memory $DAD7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	bit $F8.b,X		; 34 F8 ; Test bits $F8.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $7222.w		; 2C 22 72 ; Test bits $7222.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	adc ($C1.b)		; 72 C1 ; Add with carry (indirect) ($C1.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	asl $CDCC.w		; 0E CC CD ; Arithmetic shift left $CDCC.w [Flags: NCZ]
	sbc #$B9DE.w		; E9 DE B9 ; Subtract #$B9DE.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	adc $C4CC.w		; 6D CC C4 ; Add $C4CC.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	adc $DAF9.w,Y		; 79 F9 DA ; Add $DAF9.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy $CC.b		; A4 CC ; Load $CC.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	cpy $18A4.w		; CC A4 18 ; Compare $18A4.w with Y register [Reads: Y Index] [Flags: NCZ]
	cmp ($B9.b,X)		; C1 B9 ; Compare accumulator ($B9.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	cmp $08CC.w		; CD CC 08 ; Compare $08CC.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	bit $E2.b,X		; 34 E2 ; Test bits $E2.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	adc $110CD0.l		; 6F D0 0C 11 ; Add with carry (long) $110CD0.l [Writes: Accumulator] [Flags: NCVZ]
	adc ($F4.b),Y		; 71 F4 ; Add with carry ($F4.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc [$DC.b],Y		; 77 DC ; Add with carry (long indexed) [$DC.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy $7871.w		; CC 71 78 ; Compare $7871.w with Y register [Reads: Y Index] [Flags: NCZ]
	sbc [$FF.b]		; E7 FF ; Subtract with carry (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cpy $9B12.w		; CC 12 9B ; Compare $9B12.w with Y register [Reads: Y Index] [Flags: NCZ]
	jmp.w [$11DC]		; DC DC 11 ; Jump long indirect [$11DC] [Flow: jump]
	cpy $71CD.w		; CC CD 71 ; Compare $71CD.w with Y register [Reads: Y Index] [Flags: NCZ]
	ror $1A.b,X		; 76 1A ; Rotate right $1A.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cpy $E7DD.w		; CC DD E7 ; Compare $E7DD.w with Y register [Reads: Y Index] [Flags: NCZ]
	eor ($D2.b,S),Y		; 53 D2 ; XOR accumulator (stack relative indirect indexed) ($D2.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($2D.b),Y		; 11 2D ; OR accumulator with memory ($2D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $D30F.w		; 2D 0F D3 ; Logical AND $D30F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cpy #$CC1D.w		; C0 1D CC ; Compare #$CC1D.w with Y register [Reads: Y Index] [Flags: NCZ]
	trb $767C.w		; 1C 7C 76 ; Test and reset bits $767C.w [Reads: Accumulator] [Flags: Z]
	jmp ($11DC.w)		; 6C DC 11 ; Jump indirect to ($11DC.w) [Flow: jump]
	adc $7C79.w,X		; 7D 79 7C ; Add $7C79.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp ($CC.b)		; D2 CC ; Compare accumulator (indirect) ($CC.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	rep #$08		; C2 08 ; Reset processor status bits #$08 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	cmp $6C.b,X		; D5 6C ; Compare accumulator $6C.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	adc $11D2.w		; 6D D2 11 ; Add $11D2.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	ror $7C.b,X		; 76 7C ; Rotate right $7C.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cpy $7C1D.w		; CC 1D 7C ; Compare $7C1D.w with Y register [Reads: Y Index] [Flags: NCZ]
	dec $C7.b		; C6 C7 ; Decrement $C7.b [Reads: Direct Page] [Flags: NZ]
	ora $0A2BC2.l,X		; 1F C2 2B 0A ; Logical OR long $0A2BC2.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	cmp $1BDD.w,X		; DD DD 1B ; Compare accumulator $1BDD.w,X [Reads: X Index] [Flags: NCZ]
	rep #$C7		; C2 C7 ; Reset processor status bits #$C7 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	sta $23DC.w,Y		; 99 DC 23 ; Store accumulator to $23DC.w,Y [Reads: Y Index, Accumulator]
	and $F8.b		; 25 F8 ; Logical AND $F8.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $FA.b,S		; 83 FA ; Store accumulator (stack relative) $FA.b,S [Reads: Stack Pointer, Accumulator]
	and ($CC.b)		; 32 CC ; AND accumulator with memory (indirect) ($CC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp [$DA.b]		; C7 DA ; Compare accumulator (long) [$DA.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	and $F8.b,X		; 35 F8 ; Logical AND $F8.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	jsr $7122.w		; 20 22 71 ; Jump to subroutine at $7122.w [Writes: Stack Pointer] [Flow: call]
	stx $C6.b		; 86 C6 ; Store X register to $C6.b [Reads: X Index]
	cmp [$CC.b]		; C7 CC ; Compare accumulator (long) [$CC.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	jsl $3576DB.l		; 22 DB 76 35 ; Jump to subroutine long $3576DB.l [Writes: Stack Pointer] [Flow: call]
	stz $0C01.w		; 9C 01 0C ; Store zero to $0C01.w
	adc ($C2.b),Y		; 71 C2 ; Add with carry ($C2.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and $CE.b,X		; 35 CE ; Logical AND $CE.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cpy $7D00.w		; CC 00 7D ; Compare $7D00.w with Y register [Reads: Y Index] [Flags: NCZ]
	adc [$A4.b],Y		; 77 A4 ; Add with carry (long indexed) [$A4.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($CC.b),Y		; 11 CC ; OR accumulator with memory ($CC.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $2031.w		; CD 31 20 ; Compare $2031.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ldy $1D21.w,X		; BC 21 1D ; Load Y register $1D21.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	and $A437.w		; 2D 37 A4 ; Logical AND $A437.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($6F.b),Y		; 11 6F ; OR accumulator with memory ($6F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $12DC.w		; 2C DC 12 ; Test bits $12DC.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	ldy $12.b		; A4 12 ; Load $12.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	adc ($DC.b),Y		; 71 DC ; Add with carry ($DC.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp.w [$C111]		; DC 11 C1 ; Jump long indirect [$C111] [Flow: jump]
	lda $DC72.w,Y		; B9 72 DC ; Load $DC72.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cpy $1172.w		; CC 72 11 ; Compare $1172.w with Y register [Reads: Y Index] [Flags: NCZ]
	ror $F3.b,X		; 76 F3 ; Rotate right $F3.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cmp $F4CC.w		; CD CC F4 ; Compare $F4CC.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	sbc $F6.b,X		; F5 F6 ; Subtract $F6.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc [$CC.b],Y		; 77 CC ; Add with carry (long indexed) [$CC.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy $D576.w		; CC 76 D5 ; Compare $D576.w with Y register [Reads: Y Index] [Flags: NCZ]
	sbc [$7C.b],Y		; F7 7C ; Subtract with carry (long indexed) [$7C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	rep #$CC		; C2 CC ; Reset processor status bits #$CC [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	and $FB.b,S		; 23 FB ; AND accumulator with stack relative $FB.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $DD.b,X		; 34 DD ; Test bits $DD.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cpy #$7D1A.w		; C0 1A 7D ; Compare #$7D1A.w with Y register [Reads: Y Index] [Flags: NCZ]
	dec $34.b		; C6 34 ; Decrement $34.b [Reads: Direct Page] [Flags: NZ]
	jmp.w [$7320]		; DC 20 73 ; Jump long indirect [$7320] [Flow: jump]
	ldx $C7D1.w		; AE D1 C7 ; Load $C7D1.w into X register [Writes: X Index] [Flags: NZ]
	jsl $B99C22.l		; 22 22 9C B9 ; Jump to subroutine long $B99C22.l [Writes: Stack Pointer] [Flow: call]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	bit $CC.b,X		; 34 CC ; Test bits $CC.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $10, $FC		; 10 FC ; Branch if plus to $10, $FC [Flow: branch]
	cmp [$C7.b],Y		; D7 C7 ; Compare accumulator (long indexed) [$C7.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cpy #$2CC2.w		; C0 C2 2C ; Compare #$2CC2.w with Y register [Reads: Y Index] [Flags: NCZ]
	sta ($34.b,S),Y		; 93 34 ; Store accumulator (stack relative indirect indexed) ($34.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	.db $D0, $FC		; D0 FC ; Branch if not equal to $D0, $FC [Flow: branch]
	cmp $2C.b,S		; C3 2C ; Compare accumulator (stack relative) $2C.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	sbc $04C7.w,X		; FD C7 04 ; Subtract with carry $04C7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $C2.b		; 05 C2 ; Logical OR $C2.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $0503.w,X		; DD 03 05 ; Compare accumulator $0503.w,X [Reads: X Index] [Flags: NCZ]
	ror $7C.b,X		; 76 7C ; Rotate right $7C.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cmp $31CC.w,X		; DD CC 31 ; Compare accumulator $31CC.w,X [Reads: X Index] [Flags: NCZ]
	cmp $7CFF.w		; CD FF 7C ; Compare $7CFF.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora ($2C.b)		; 12 2C ; OR accumulator with memory (indirect) ($2C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $1331.w		; 6D 31 13 ; Add $1331.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	ora ($11.b,S),Y		; 13 11 ; OR accumulator (stack relative indirect indexed) ($11.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($34.b,S),Y		; 33 34 ; AND accumulator (stack relative indirect indexed) ($34.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($13.b),Y		; 31 13 ; AND accumulator with memory ($13.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,S),Y		; 13 01 ; OR accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($7C.b,S),Y		; 33 7C ; AND accumulator (stack relative indirect indexed) ($7C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $C275A9.l		; AF A9 75 C2 ; Load long $C275A9.l into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($C0.b),Y		; 91 C0 ; Store accumulator ($C0.b),Y [Reads: Direct Page, Y Index, Accumulator]
	jmp ($53EB.w)		; 6C EB 53 ; Jump indirect to ($53EB.w) [Flow: jump]
	and ($11.b,X)		; 21 11 ; Logical AND ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp $0AC7.w		; CD C7 0A ; Compare $0AC7.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	jsl $FDC7DD.l		; 22 DD C7 FD ; Jump to subroutine long $FDC7DD.l [Writes: Stack Pointer] [Flow: call]
	cmp [$04.b],Y		; D7 04 ; Compare accumulator (long indexed) [$04.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	bit $352D.w		; 2C 2D 35 ; Test bits $352D.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	and $DE.b,X		; 35 DE ; Logical AND $DE.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lda $CC22.w,Y		; B9 22 CC ; Load $CC22.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	.db $10, $2C		; 10 2C ; Branch if plus to $10, $2C [Flow: branch]
	rol $DDCD.w		; 2E CD DD ; Rotate left $DDCD.w [Flags: NCZ]
	bit $3634.w		; 2C 34 36 ; Test bits $3634.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	sec		; 38 ; Set carry flag [Flags: C]
	cmp $34DD.w,X		; DD DD 34 ; Compare accumulator $34DD.w,X [Reads: X Index] [Flags: NCZ]
	and $353B.w,Y		; 39 3B 35 ; AND accumulator with memory $353B.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $38DD.w,X		; DD DD 38 ; Compare accumulator $38DD.w,X [Reads: X Index] [Flags: NCZ]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $DDDD.w,X		; 3C DD DD ; Test bits $DDDD.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	and $3F3F.w,X		; 3D 3F 3F ; AND accumulator with memory $3F3F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	bit $DD.b,X		; 34 DD ; Test bits $DD.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $D0, $40		; D0 40 ; Branch if not equal to $D0, $40 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	eor [$49.b]		; 47 49 ; Exclusive OR accumulator with memory (long) [$49.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $43DD.w,X		; DD DD 43 ; Compare accumulator $43DD.w,X [Reads: X Index] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	jmp $DDDD.w		; 4C DD DD ; Jump to $DDDD.w [Flow: jump]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	eor ($50.b)		; 52 50 ; Exclusive OR accumulator with memory (indirect) ($50.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $4CD8.w,X		; DD D8 4C ; Compare accumulator $4CD8.w,X [Reads: X Index] [Flags: NCZ]
	eor ($50.b,X)		; 41 50 ; Exclusive OR accumulator with memory ($50.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	cmp $4D88.w,X		; DD 88 4D ; Compare accumulator $4D88.w,X [Reads: X Index] [Flags: NCZ]
	.db $50, $4B		; 50 4B ; Branch if overflow clear to $50, $4B [Flow: branch]
	mvn $D8,$D8		; 54 D8 D8 ; Move block negative $D8,$D8 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	eor $8D.b,X		; 55 8D ; Exclusive OR accumulator with memory $8D.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	eor $5065.w,Y		; 59 65 50 ; Exclusive OR accumulator with memory $5065.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $50, $88		; 50 88 ; Branch if overflow clear to $50, $88 [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	eor $5955.w,Y		; 59 55 59 ; Exclusive OR accumulator with memory $5955.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	cmp $5BDD.w,X		; DD DD 5B ; Compare accumulator $5BDD.w,X [Reads: X Index] [Flags: NCZ]
	eor $5F67.w,X		; 5D 67 5F ; Exclusive OR accumulator with memory $5F67.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $5EDD.w,X		; DD DD 5E ; Compare accumulator $5EDD.w,X [Reads: X Index] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cmp $5FDD.w,X		; DD DD 5F ; Compare accumulator $5FDD.w,X [Reads: X Index] [Flags: NCZ]
	eor $DD616C.l,X		; 5F 6C 61 DD ; Exclusive OR accumulator with memory (long,X) $DD616C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $5F5D.w,X		; DD 5D 5F ; Compare accumulator $5F5D.w,X [Reads: X Index] [Flags: NCZ]
	adc ($75.b,S),Y		; 73 75 ; Add with carry (stack relative indirect indexed) ($75.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cmp $77DD.w,X		; DD DD 77 ; Compare accumulator $77DD.w,X [Reads: X Index] [Flags: NCZ]
	eor $DD685F.l,X		; 5F 5F 68 DD ; Exclusive OR accumulator with memory (long,X) $DD685F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $6B69.w,X		; DD 69 6B ; Compare accumulator $6B69.w,X [Reads: X Index] [Flags: NCZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $5FDD.w,X		; DD DD 5F ; Compare accumulator $5FDD.w,X [Reads: X Index] [Flags: NCZ]
	bit #$8C8A.w		; 89 8A 8C ; Test bits #$8C8A.w with accumulator [Reads: Accumulator] [Flags: Z]
	cmp $8DDD.w,X		; DD DD 8D ; Compare accumulator $8DDD.w,X [Reads: X Index] [Flags: NCZ]
	stx $9290.w		; 8E 90 92 ; Store X register to $9290.w [Reads: X Index]
	cmp $93DD.w,X		; DD DD 93 ; Compare accumulator $93DD.w,X [Reads: X Index] [Flags: NCZ]
	sta ($93.b,S),Y		; 93 93 ; Store accumulator (stack relative indirect indexed) ($93.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	sta $DDDD.w,X		; 9D DD DD ; Store accumulator to $DDDD.w,X [Reads: Accumulator, X Index]
	sta $9C9F.w,Y		; 99 9F 9C ; Store accumulator to $9C9F.w,Y [Reads: Y Index, Accumulator]
	lda ($DD.b,X)		; A1 DD ; Load accumulator ($DD.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $9E99.w,X		; DD 99 9E ; Compare accumulator $9E99.w,X [Reads: X Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $FF00.w,X		; DD 00 FF ; Compare accumulator $FF00.w,X [Reads: X Index] [Flags: NCZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $0BFFFF.l,X		; FF FF FF 0B ; Subtract with carry (long,X) $0BFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tsb $000E.w		; 0C 0E 00 ; Test and set bits $000E.w [Reads: Accumulator] [Flags: Z]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $12		; 10 12 ; Branch if plus to $10, $12 [Flow: branch]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1E1C.w,X		; 1D 1C 1E ; OR accumulator with memory $1E1C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $21.b		; 04 21 ; Test and set bits $21.b [Reads: Accumulator] [Flags: Z]
	and $25.b,S		; 23 25 ; AND accumulator with stack relative $25.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $0E.b		; 24 0E ; Test bits $0E.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora ($04.b,S),Y		; 13 04 ; OR accumulator (stack relative indirect indexed) ($04.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $302F.w		; 1C 2F 30 ; Test and reset bits $302F.w [Reads: Accumulator] [Flags: Z]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $38.b		; 04 38 ; Test and set bits $38.b [Reads: Accumulator] [Flags: Z]
	and ($00.b,S),Y		; 33 00 ; AND accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $3A.b,X		; 34 3A ; Test bits $3A.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	rol $00.b,X		; 36 00 ; Rotate left $00.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $3A.b		; 00 3A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $21.b		; 04 21 ; Test and set bits $21.b [Reads: Accumulator] [Flags: Z]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $47.b		; 45 47 ; Exclusive OR $47.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor #$0000.w		; 49 00 00 ; Exclusive OR #$0000.w with accumulator [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	jmp $0047.w		; 4C 47 00 ; Jump to $0047.w [Flow: jump]
	brk $5B.b		; 00 5B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $5F5E.w,X		; 5D 5E 5F ; Exclusive OR accumulator with memory $5F5E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $5604.w		; 2D 04 56 ; Logical AND $5604.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($33.b,S),Y		; 13 33 ; OR accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $66.b		; 00 66 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	tsb $0F.b		; 04 0F ; Test and set bits $0F.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	bit $0A.b		; 24 0A ; Test bits $0A.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $56.b		; 46 56 ; Logical shift right $56.b [Reads: Direct Page] [Flags: NCZ]
	eor [$34.b]		; 47 34 ; Exclusive OR accumulator with memory (long) [$34.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($6E30.w)		; 6C 30 6E ; Jump indirect to ($6E30.w) [Flow: jump]
	adc #$0000.w		; 69 00 00 ; Add #$0000.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	jsr $1C4C.w		; 20 4C 1C ; Jump to subroutine at $1C4C.w [Writes: Stack Pointer] [Flow: call]
	ora $710000.l,X		; 1F 00 00 71 ; Logical OR long $710000.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $003441.l		; 6F 41 34 00 ; Add with carry (long) $003441.l [Writes: Accumulator] [Flags: NCVZ]
	brk $67.b		; 00 67 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc #$3913.w		; 69 13 39 ; Add #$3913.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($34.b,S),Y		; 73 34 ; Add with carry (stack relative indirect indexed) ($34.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	jsr $0033.w		; 20 33 00 ; Jump to subroutine at $0033.w [Writes: Stack Pointer] [Flow: call]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	rol $0048.w		; 2E 48 00 ; Rotate left $0048.w [Flags: NCZ]
	brk $4A.b		; 00 4A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $4047.w		; 20 47 40 ; Jump to subroutine at $4047.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $2D.b		; 04 2D ; Test and set bits $2D.b [Reads: Accumulator] [Flags: Z]
	bit $5E.b,X		; 34 5E ; Test bits $5E.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $125414.l,X		; 5F 14 54 12 ; Exclusive OR accumulator with memory (long,X) $125414.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $41.b		; 04 41 ; Test and set bits $41.b [Reads: Accumulator] [Flags: Z]
	lsr $005F.w,X		; 5E 5F 00 ; Logical shift right $005F.w,X [Reads: X Index] [Flags: NCZ]
	brk $4E.b		; 00 4E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($04.b)		; 32 04 ; AND accumulator with memory (indirect) ($04.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $00.b		; 45 00 ; Exclusive OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $33.b		; 00 33 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $0430.w		; 6D 30 04 ; Add $0430.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $34.b		; 04 34 ; Test and set bits $34.b [Reads: Accumulator] [Flags: Z]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	ror $00.b		; 66 00 ; Rotate right $00.b [Reads: Direct Page] [Flags: NCZ]
	brk $6D.b		; 00 6D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $12.b		; 64 12 ; Store zero to $12.b
	ora ($00.b,S),Y		; 13 00 ; OR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($69.b,S),Y		; 33 69 ; AND accumulator (stack relative indirect indexed) ($69.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $800000.l,X		; 7F 00 00 80 ; Add long $800000.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($11.b,X)		; 81 11 ; Store accumulator ($11.b,X) [Reads: Direct Page, Accumulator, X Index]
	ora $0000.w		; 0D 00 00 ; Logical OR $0000.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $30.b,S		; 83 30 ; Store accumulator (stack relative) $30.b,S [Reads: Stack Pointer, Accumulator]
	.db $62, $30, $00		; 62 30 00 ; Push effective relative address $62, $30, $00 [Writes: Stack Pointer]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $64.b,S		; 83 64 ; Store accumulator (stack relative) $64.b,S [Reads: Stack Pointer, Accumulator]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $76.b		; 00 76 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $1C.b,X		; 34 1C ; Test bits $1C.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora ($00.b,S),Y		; 13 00 ; OR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $95.b		; 00 95 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $97.b,X		; 34 97 ; Test bits $97.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $99.b,X		; 34 99 ; Test bits $99.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	sta $0000.w,X		; 9D 00 00 ; Store accumulator to $0000.w,X [Reads: Accumulator, X Index]
	stz $A29B.w		; 9C 9B A2 ; Store zero to $A29B.w
	and $00.b,X		; 35 00 ; Logical AND $00.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $9E.b		; 00 9E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00A6A4.l,X		; 9F A4 A6 00 ; Store accumulator (long,X) $00A6A4.l,X [Reads: Accumulator, X Index]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($2D.b),Y		; 71 2D ; Add with carry ($2D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $0000.w		; 2E 00 00 ; Rotate left $0000.w [Flags: NCZ]
	bit $35.b,X		; 34 35 ; Test bits $35.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $AD.b,X		; 34 AD ; Test bits $AD.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx $34.b		; A6 34 ; Load $34.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	ldx $007E.w		; AE 7E 00 ; Load $007E.w into X register [Writes: X Index] [Flags: NZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sta $0000.w		; 8D 00 00 ; Store accumulator to $0000.w [Reads: Accumulator]
	bit $AE.b,X		; 34 AE ; Test bits $AE.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ror $00AF.w,X		; 7E AF 00 ; Rotate right $00AF.w,X [Reads: X Index] [Flags: NCZ]
	brk $B2.b		; 00 B2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $2D.b		; 45 2D ; Exclusive OR $2D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0000.w,Y		; 19 00 00 ; OR accumulator with memory $0000.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $33.b		; 24 33 ; Test bits $33.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	and $040F.w		; 2D 0F 04 ; Logical AND $040F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $96B86E.l		; 2F 6E B8 96 ; AND accumulator with memory (long) $96B86E.l [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $11.b,X		; 34 11 ; Test bits $11.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora ($BB.b)		; 12 BB ; OR accumulator with memory (indirect) ($BB.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora ($34.b)		; 12 34 ; OR accumulator with memory (indirect) ($34.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0000.w		; 8D 00 00 ; Store accumulator to $0000.w [Reads: Accumulator]
	cpy #$2F0B.w		; C0 0B 2F ; Compare #$2F0B.w with Y register [Reads: Y Index] [Flags: NCZ]
	stz $00.b		; 64 00 ; Store zero to $00.b
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $3F36.w		; 8C 36 3F ; Store Y register to $3F36.w [Reads: Y Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	stz $2D.b,X		; 74 2D ; Store zero to $2D.b,X [Reads: X Index]
	adc ($00.b)		; 72 00 ; Add with carry (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	brk $69.b		; 00 69 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $34.b,X		; 36 34 ; Rotate left $34.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	lsr $0000.w,X		; 5E 00 00 ; Logical shift right $0000.w,X [Reads: X Index] [Flags: NCZ]
	bit $6E.b,X		; 34 6E ; Test bits $6E.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	jsl $00000B.l		; 22 0B 00 00 ; Jump to subroutine long $00000B.l [Writes: Stack Pointer] [Flow: call]
	and $45AE30.l		; 2F 30 AE 45 ; AND accumulator with memory (long) $45AE30.l [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $45.b,S		; 23 45 ; AND accumulator with stack relative $45.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $6A.b		; 04 6A ; Test and set bits $6A.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $892D.w		; 2D 2D 89 ; Logical AND $892D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	adc $0000.w		; 6D 00 00 ; Add $0000.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	adc ($63.b,X)		; 61 63 ; Add with carry ($63.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $000060.l		; 0F 60 00 00 ; OR accumulator with memory (long) $000060.l [Writes: Accumulator] [Flags: NZ]
	ora ($9A.b)		; 12 9A ; OR accumulator with memory (indirect) ($9A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc #$1323.w		; 69 23 13 ; Add #$1323.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cpy $00.b		; C4 00 ; Compare $00.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	brk $C6.b		; 00 C6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp [$CC.b]		; C7 CC ; Compare accumulator (long) [$CC.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $82, $C4, $C6		; 82 C4 C6 ; Branch always long to $82, $C4, $C6 [Flow: branch]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $CA.b		; 00 CA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp #$D0C9.w		; C9 C9 D0 ; Compare #$D0C9.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $D5.b		; C6 D5 ; Decrement $D5.b [Reads: Direct Page] [Flags: NZ]
	stz $00DE.w		; 9C DE 00 ; Store zero to $00DE.w
	brk $94.b		; 00 94 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	cmp #$0000.w		; C9 00 00 ; Compare #$0000.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cpx #$CAC9.w		; E0 C9 CA ; Compare #$CAC9.w with X register [Reads: X Index] [Flags: NCZ]
	.db $D0, $00		; D0 00 ; Branch if not equal to $D0, $00 [Flow: branch]
	brk $D5.b		; 00 D5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$44.b]		; E7 44 ; Subtract with carry (long) [$44.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $34.b,X		; 36 34 ; Rotate left $34.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy $D5.b		; C4 D5 ; Compare $D5.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	bit $89.b,X		; 34 89 ; Test bits $89.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sbc $00EE.w		; ED EE 00 ; Subtract $00EE.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $C4.b,X		; 34 C4 ; Test bits $C4.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $9A.b		; 00 9A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($13.b),Y		; 11 13 ; OR accumulator with memory ($13.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($00.b)		; F2 00 ; Subtract with carry (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	brk $ED.b		; 00 ED ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $34F0.w		; EE F0 34 ; Increment $34F0.w [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $83.b,X		; 36 83 ; Rotate left $83.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $82, $34, $00		; 82 34 00 ; Branch always long to $82, $34, $00 [Flow: branch]
	brk $DA.b		; 00 DA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FDFB.w,Y		; F9 FB FD ; Subtract with carry $FDFB.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $15B000.l,X		; FF 00 B0 15 ; Subtract with carry (long,X) $15B000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $08.b,X		; 34 08 ; Test bits $08.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $34.b,X		; D5 34 ; Compare accumulator $34.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $F1.b,X		; 34 F1 ; Test bits $F1.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	eor $000034.l		; 4F 34 00 00 ; Exclusive OR accumulator with memory (long) $000034.l [Writes: Accumulator] [Flags: NZ]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	dec $00C5.w		; CE C5 00 ; Decrement $00C5.w [Flags: NZ]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $B0.b		; 06 B0 ; Arithmetic shift left $B0.b [Reads: Direct Page] [Flags: NCZ]
	bit $11.b,X		; 34 11 ; Test bits $11.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	asl $0005.w		; 0E 05 00 ; Arithmetic shift left $0005.w [Flags: NCZ]
	ora ($07.b),Y		; 11 07 ; OR accumulator with memory ($07.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpy $C6.b		; C4 C6 ; Compare $C6.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	sbc ($10.b),Y		; F1 10 ; Subtract with carry ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $A8.b		; 14 A8 ; Test and reset bits $A8.b [Reads: Accumulator] [Flags: Z]
	ora #$0100.w		; 09 00 01 ; Logical OR #$0100.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp $34.b,X		; D5 34 ; Compare accumulator $34.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	bit $4E.b,X		; 34 4E ; Test bits $4E.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $C605.w,Y		; D9 05 C6 ; Compare accumulator $C605.w,Y [Reads: Y Index] [Flags: NCZ]
	sbc ($01.b,X)		; E1 01 ; Subtract with carry ($01.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $98.b		; 00 98 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $CE.b		; 00 CE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $DA.b		; C5 DA ; Compare $DA.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cpy $00.b		; C4 00 ; Compare $00.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	brk $76.b		; 00 76 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $DA.b,X		; 34 DA ; Test bits $DA.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	dec $0000.w		; CE 00 00 ; Decrement $0000.w [Flags: NZ]
	.db $10, $11		; 10 11 ; Branch if plus to $10, $11 [Flow: branch]
	ora [$18.b],Y		; 17 18 ; OR accumulator with memory (long indexed) [$18.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $17.b,X		; 16 17 ; Arithmetic shift left $17.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	asl $11.b,X		; 16 11 ; Arithmetic shift left $11.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($17.b),Y		; 11 17 ; OR accumulator with memory ($17.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($14.b)		; 12 14 ; OR accumulator with memory (indirect) ($14.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($1B.b)		; 12 1B ; OR accumulator with memory (indirect) ($1B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $111124.l		; 22 24 11 11 ; Jump to subroutine long $111124.l [Writes: Stack Pointer] [Flow: call]
	bit $26.b,X		; 34 26 ; Test bits $26.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and $34.b		; 25 34 ; Logical AND $34.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	ora ($10.b)		; 12 10 ; OR accumulator with memory (indirect) ($10.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $11		; 10 11 ; Branch if plus to $10, $11 [Flow: branch]
	ora ($2A.b),Y		; 11 2A ; OR accumulator with memory ($2A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $2C		; 10 2C ; Branch if plus to $10, $2C [Flow: branch]
	bit $11.b		; 24 11 ; Test bits $11.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora ($2F.b),Y		; 11 2F ; OR accumulator with memory ($2F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $10.b,X		; 34 10 ; Test bits $10.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora ($34.b),Y		; 11 34 ; OR accumulator with memory ($34.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $36.b,X		; 35 36 ; Logical AND $36.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and [$01.b],Y		; 37 01 ; AND accumulator with memory (long indexed) [$01.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($38.b),Y		; 11 38 ; OR accumulator with memory ($38.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	bit $1140.w		; 2C 40 11 ; Test bits $1140.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	ora ($39.b),Y		; 11 39 ; OR accumulator with memory ($39.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $43.b,X		; 34 43 ; Test bits $43.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	eor $10.b		; 45 10 ; Exclusive OR $10.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($47.b),Y		; 11 47 ; OR accumulator with memory ($47.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	lsr $114E.w		; 4E 4E 11 ; Logical shift right $114E.w [Flags: NCZ]
	ora ($4F.b),Y		; 11 4F ; OR accumulator with memory ($4F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor ($12.b),Y		; 51 12 ; Exclusive OR accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $11		; 10 11 ; Branch if plus to $10, $11 [Flow: branch]
	ora ($1A.b),Y		; 11 1A ; OR accumulator with memory ($1A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($C9.b)		; 12 C9 ; OR accumulator with memory (indirect) ($C9.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$0011.w		; C9 11 00 ; Compare #$0011.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	eor ($55.b,S),Y		; 53 55 ; XOR accumulator (stack relative indirect indexed) ($55.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr $1113.w		; 20 13 11 ; Jump to subroutine at $1113.w [Writes: Stack Pointer] [Flow: call]
	ora ($12.b),Y		; 11 12 ; OR accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and #$1A10.w		; 29 10 1A ; Logical AND #$1A10.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor [$57.b],Y		; 57 57 ; Exclusive OR accumulator with memory (long indexed) [$57.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $12.b,X		; 55 12 ; Exclusive OR accumulator with memory $12.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($16.b),Y		; 11 16 ; OR accumulator with memory ($16.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $111D.w,X		; 1D 1D 11 ; OR accumulator with memory $111D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($58.b),Y		; 11 58 ; OR accumulator with memory ($58.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and #$5A10.w		; 29 10 5A ; Logical AND #$5A10.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	ora ($1C.b)		; 12 1C ; OR accumulator with memory (indirect) ($1C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $5B.b,X		; 34 5B ; Test bits $5B.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and ($12.b),Y		; 31 12 ; AND accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $5C39.w		; 2D 39 5C ; Logical AND $5C39.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lsr $1111.w,X		; 5E 11 11 ; Logical shift right $1111.w,X [Reads: X Index] [Flags: NCZ]
	eor $6A5B34.l,X		; 5F 34 5B 6A ; Exclusive OR accumulator with memory (long,X) $6A5B34.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $11		; 10 11 ; Branch if plus to $10, $11 [Flow: branch]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	adc ($6C.b,X)		; 61 6C ; Add with carry ($6C.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $01.b,X		; 34 01 ; Test bits $01.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $10, $63		; 10 63 ; Branch if plus to $10, $63 [Flow: branch]
	adc $117271.l		; 6F 71 72 11 ; Add with carry (long) $117271.l [Writes: Accumulator] [Flags: NCVZ]
	ora ($73.b),Y		; 11 73 ; OR accumulator with memory ($73.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $75.b		; 06 75 ; Arithmetic shift left $75.b [Reads: Direct Page] [Flags: NCZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	sbc $76.b,S		; E3 76 ; Subtract stack-relative $76.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	adc [$00.b],Y		; 77 00 ; Add with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($34.b),Y		; 11 34 ; OR accumulator with memory ($34.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda #$C6C6.w		; A9 C6 C6 ; Load #$C6C6.w into accumulator [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $53.b		; C6 53 ; Decrement $53.b [Reads: Direct Page] [Flags: NZ]
	adc $11016B.l,X		; 7F 6B 01 11 ; Add long $11016B.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($41.b,X)		; 81 41 ; Store accumulator ($41.b,X) [Reads: Direct Page, Accumulator, X Index]
	bit $CE.b,X		; 34 CE ; Test bits $CE.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $7B		; D0 7B ; Branch if not equal to $D0, $7B [Flow: branch]
	ror $01C9.w,X		; 7E C9 01 ; Rotate right $01C9.w,X [Reads: X Index] [Flags: NCZ]
	.db $10, $DC		; 10 DC ; Branch if plus to $10, $DC [Flow: branch]
	sta $C8.b		; 85 C8 ; Store accumulator to $C8.b [Reads: Accumulator]
	eor ($01.b,X)		; 41 01 ; Exclusive OR accumulator with memory ($01.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($DB.b,X)		; 01 DB ; Logical OR ($DB.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor ($C9.b,S),Y		; 53 C9 ; XOR accumulator (stack relative indirect indexed) ($C9.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	eor ($34.b,S),Y		; 53 34 ; XOR accumulator (stack relative indirect indexed) ($34.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $52.b,X		; 34 52 ; Test bits $52.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $82, $52, $01		; 82 52 01 ; Branch always long to $82, $52, $01 [Flow: branch]
	ora ($6C.b),Y		; 11 6C ; OR accumulator with memory ($6C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor ($17.b)		; 52 17 ; Exclusive OR accumulator with memory (indirect) ($17.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sty $96.b,X		; 94 96 ; Store Y register $96.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	sta [$98.b],Y		; 97 98 ; Store accumulator (long indexed) [$98.b],Y [Reads: Direct Page, Y Index, Accumulator]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $1791.w,Y		; 99 91 17 ; Store accumulator to $1791.w,Y [Reads: Y Index, Accumulator]
	jmp $1111.w		; 4C 11 11 ; Jump to $1111.w [Flow: jump]
	.db $10, $1A		; 10 1A ; Branch if plus to $10, $1A [Flow: branch]
	ora $23.b,X		; 15 23 ; OR accumulator with memory $23.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $9F.b		; 25 9F ; Logical AND $9F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda ($A3.b,X)		; A1 A3 ; Load accumulator ($A3.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $11		; 10 11 ; Branch if plus to $10, $11 [Flow: branch]
	lda ($A2.b,X)		; A1 A2 ; Load accumulator ($A2.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lda ($91.b,X)		; A1 91 ; Load accumulator ($91.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jmp ($131E.w,X)		; 7C 1E 13 ; Jump indirect indexed to ($131E.w,X) [Reads: X Index] [Flow: jump]
	and ($11.b,S),Y		; 33 11 ; AND accumulator (stack relative indirect indexed) ($11.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($37.b),Y		; 11 37 ; OR accumulator with memory ($37.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	rol $35.b,X		; 36 35 ; Rotate left $35.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	lda $11.b		; A5 11 ; Load $11.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($89.b),Y		; 11 89 ; OR accumulator with memory ($89.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	sta $118D.w		; 8D 8D 11 ; Store accumulator to $118D.w [Reads: Accumulator]
	ora ($8D.b),Y		; 11 8D ; OR accumulator with memory ($8D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	.db $90, $79		; 90 79 ; Branch if carry clear to $90, $79 [Flow: branch]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $1D.b,X		; 34 1D ; Test bits $1D.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora ($01.b)		; 12 01 ; OR accumulator with memory (indirect) ($01.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($B1.b),Y		; 11 B1 ; OR accumulator with memory ($B1.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda ($35.b,S),Y		; B3 35 ; Load accumulator (stack relative indirect indexed) ($35.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ldx $9C.b,Y		; B6 9C ; Load X register $9C.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	lda $119C.w,Y		; B9 9C 11 ; Load $119C.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($B6.b),Y		; 11 B6 ; OR accumulator with memory ($B6.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	rol $12.b		; 26 12 ; Rotate left $12.b [Reads: Direct Page] [Flags: NCZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $34.b,S		; C3 34 ; Compare accumulator (stack relative) $34.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	cpy $C6.b		; C4 C6 ; Compare $C6.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	.db $10, $11		; 10 11 ; Branch if plus to $10, $11 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cpy $11CE.w		; CC CE 11 ; Compare $11CE.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora ($D0.b),Y		; 11 D0 ; OR accumulator with memory ($D0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($79.b)		; D2 79 ; Compare accumulator (indirect) ($79.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	pei ($11.b)		; D4 11 ; Push effective indirect address ($11.b) [Reads: Direct Page] [Writes: Stack Pointer]
	ora ($D5.b),Y		; 11 D5 ; OR accumulator with memory ($D5.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $25.b,X		; 16 25 ; Arithmetic shift left $25.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	lda #$1011.w		; A9 11 10 ; Load #$1011.w into accumulator [Writes: Accumulator] [Flags: NZ]
	dec $DFE0.w,X		; DE E0 DF ; Decrement memory $DFE0.w,X [Reads: X Index] [Flags: NZ]
	cpy $1111.w		; CC 11 11 ; Compare $1111.w with Y register [Reads: Y Index] [Flags: NCZ]
	dec $79E3.w,X		; DE E3 79 ; Decrement memory $79E3.w,X [Reads: X Index] [Flags: NZ]
	cpy $11.b		; C4 11 ; Compare $11.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	ora ($A5.b),Y		; 11 A5 ; OR accumulator with memory ($A5.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda $AC.b		; A5 AC ; Load $AC.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $4E.b		; 00 4E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $34.b		; E6 34 ; Increment $34.b [Reads: Direct Page] [Flags: NZ]
	sbc [$11.b]		; E7 11 ; Subtract with carry (long) [$11.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($C9.b,X)		; 01 C9 ; Logical OR ($C9.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp #$CAEC.w		; C9 EC CA ; Compare #$CAEC.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $EE.b		; C5 EE ; Compare $EE.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	.db $F0, $A0		; F0 A0 ; Branch if equal to $F0, $A0 [Flow: branch]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $C5.b,X		; 34 C5 ; Test bits $C5.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sbc [$F9.b],Y		; F7 F9 ; Subtract with carry (long indexed) [$F9.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc [$E7.b]		; 67 E7 ; Add with carry (long) [$E7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ldy $A7.b		; A4 A7 ; Load $A7.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	sbc $00C4.w,X		; FD C4 00 ; Subtract with carry $00C4.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpy $34.b		; C4 34 ; Compare $34.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	lda #$0020.w		; A9 20 00 ; Load #$0020.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	eor ($34.b,S),Y		; 53 34 ; XOR accumulator (stack relative indirect indexed) ($34.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $0111.w,X		; 7D 11 01 ; Add $0111.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $08.b,X		; 34 08 ; Test bits $08.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $21.b		; 02 21 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $CE.b,X		; 34 CE ; Test bits $CE.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cpy $F5.b		; C4 F5 ; Compare $F5.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $3475.w,X		; 7E 75 34 ; Rotate right $3475.w,X [Reads: X Index] [Flags: NCZ]
	adc $0111.w,Y		; 79 11 01 ; Add $0111.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $A9.b,X		; 34 A9 ; Test bits $A9.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $04.b,X		; 34 04 ; Test bits $04.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$34.b]		; 07 34 ; OR accumulator with memory (long) [$34.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $70, $42		; 70 42 ; Branch if overflow set to $70, $42 [Flow: branch]
	.db $10, $11		; 10 11 ; Branch if plus to $10, $11 [Flow: branch]
	bit $15.b,X		; 34 15 ; Test bits $15.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $C4.b,X		; 34 C4 ; Test bits $C4.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy $10.b		; C4 10 ; Compare $10.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	sbc $1002A1.l,X		; FF A1 02 10 ; Subtract with carry (long,X) $1002A1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $D00EA3.l		; EF A3 0E D0 ; Subtract with carry (long) $D00EA3.l [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	cmp ($4F.b),Y		; D1 4F ; Compare accumulator ($4F.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	eor ($34.b,X)		; 41 34 ; Exclusive OR accumulator with memory ($34.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$A6.b],Y		; 17 A6 ; OR accumulator with memory (long indexed) [$A6.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	jsr $CA00.w		; 20 00 CA ; Jump to subroutine at $CA00.w [Writes: Stack Pointer] [Flow: call]
	.db $82, $53, $6B		; 82 53 6B ; Branch always long to $82, $53, $6B [Flow: branch]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	ora ($10.b,S),Y		; 13 10 ; OR accumulator (stack relative indirect indexed) ($10.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $2B1101.l,X		; 1F 01 11 2B ; Logical OR long $2B1101.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $12		; 10 12 ; Branch if plus to $10, $12 [Flow: branch]
	ora ($11.b)		; 12 11 ; OR accumulator with memory (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($12.b),Y		; 11 12 ; OR accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($12.b,S),Y		; 13 12 ; OR accumulator (stack relative indirect indexed) ($12.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $1111.w,Y		; 59 11 11 ; Exclusive OR accumulator with memory $1111.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $1F		; 10 1F ; Branch if plus to $10, $1F [Flow: branch]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora ($11.b)		; 12 11 ; OR accumulator with memory (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($1A.b),Y		; 11 1A ; OR accumulator with memory ($1A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora ($14.b,S),Y		; 13 14 ; OR accumulator (stack relative indirect indexed) ($14.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	ora $11111E.l,X		; 1F 1E 11 11 ; Logical OR long $11111E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($12.b)		; 12 12 ; OR accumulator with memory (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $1F.b		; 14 1F ; Test and reset bits $1F.b [Reads: Accumulator] [Flags: Z]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	and ($13.b,X)		; 21 13 ; Logical AND ($13.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($19.b),Y		; 11 19 ; OR accumulator with memory ($19.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $10, $22		; 10 22 ; Branch if plus to $10, $22 [Flow: branch]
	ora ($12.b),Y		; 11 12 ; OR accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc ($58.b),Y		; 71 58 ; Add with carry ($58.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $11.b,X		; 34 11 ; Test bits $11.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $10, $34		; 10 34 ; Branch if plus to $10, $34 [Flow: branch]
	and [$32.b]		; 27 32 ; AND accumulator with memory (long) [$32.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $01.b		; 14 01 ; Test and reset bits $01.b [Reads: Accumulator] [Flags: Z]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $1B		; 30 1B ; Branch if minus to $30, $1B [Flow: branch]
	asl $2211.w,X		; 1E 11 22 ; Arithmetic shift left $2211.w,X [Reads: X Index] [Flags: NCZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $0110.w,X		; 3C 10 01 ; Test bits $0110.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	and $3E3D.w,X		; 3D 3D 3E ; AND accumulator with memory $3E3D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $1111.w,X		; 3D 11 11 ; AND accumulator with memory $1111.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	bit $1B30.w,X		; 3C 30 1B ; Test bits $1B30.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	jsr $2211.w		; 20 11 22 ; Jump to subroutine at $2211.w [Writes: Stack Pointer] [Flow: call]
	and $34.b,X		; 35 34 ; Logical AND $34.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and [$32.b]		; 27 32 ; AND accumulator with memory (long) [$32.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	.db $10, $12		; 10 12 ; Branch if plus to $10, $12 [Flow: branch]
	and $1111.w		; 2D 11 11 ; Logical AND $1111.w with accumulator [Writes: Accumulator] [Flags: NZ]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	jsr $004E.w		; 20 4E 00 ; Jump to subroutine at $004E.w [Writes: Stack Pointer] [Flow: call]
	and ($52.b,X)		; 21 52 ; Logical AND ($52.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor $3F.b,X		; 55 3F ; Exclusive OR accumulator with memory $3F.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($11.b,X)		; 41 11 ; Exclusive OR accumulator with memory ($11.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($06.b),Y		; 11 06 ; OR accumulator with memory ($06.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $56.b,S		; 83 56 ; Store accumulator (stack relative) $56.b,S [Reads: Stack Pointer, Accumulator]
	lsr $11.b,X		; 56 11 ; Logical shift right $11.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($20.b),Y		; 11 20 ; OR accumulator with memory ($20.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($19.b,X)		; 21 19 ; Logical AND ($19.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor #$1111.w		; 49 11 11 ; Exclusive OR #$1111.w with accumulator [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cmp $23.b		; C5 23 ; Compare $23.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($12.b)		; 12 12 ; OR accumulator with memory (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $1110.w		; 20 10 11 ; Jump to subroutine at $1110.w [Writes: Stack Pointer] [Flow: call]
	ora ($4D.b),Y		; 11 4D ; OR accumulator with memory ($4D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	and $12.b,S		; 23 12 ; AND accumulator with stack relative $12.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $10, $21		; 10 21 ; Branch if plus to $10, $21 [Flow: branch]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	.db $10, $33		; 10 33 ; Branch if plus to $10, $33 [Flow: branch]
	bit $1111.w		; 2C 11 11 ; Test bits $1111.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	.db $10, $12		; 10 12 ; Branch if plus to $10, $12 [Flow: branch]
	dec $11.b		; C6 11 ; Decrement $11.b [Reads: Direct Page] [Flags: NZ]
	.db $10, $C6		; 10 C6 ; Branch if plus to $10, $C6 [Flow: branch]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	dec $00.b		; C6 00 ; Decrement $00.b [Reads: Direct Page] [Flags: NZ]
	brk $C6.b		; 00 C6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	dec $00.b		; C6 00 ; Decrement $00.b [Reads: Direct Page] [Flags: NZ]
	brk $C6.b		; 00 C6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	dec $00.b		; C6 00 ; Decrement $00.b [Reads: Direct Page] [Flags: NZ]
	brk $D1.b		; 00 D1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($2A.b)		; D2 2A ; Compare accumulator (indirect) ($2A.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora [$00.b],Y		; 17 00 ; OR accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($17.b),Y		; 11 17 ; OR accumulator with memory ($17.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora ($2B.b)		; 12 2B ; OR accumulator with memory (indirect) ($2B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($22.b,S),Y		; 13 22 ; OR accumulator (stack relative indirect indexed) ($22.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $3B.b		; 24 3B ; Test bits $3B.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($16.b)		; 12 16 ; OR accumulator with memory (indirect) ($16.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($1A.b)		; 12 1A ; OR accumulator with memory (indirect) ($1A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $3134.w		; 2C 34 31 ; Test bits $3134.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	bit $1110.w		; 2C 10 11 ; Test bits $1110.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	bit $12.b		; 24 12 ; Test bits $12.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora ($2B.b)		; 12 2B ; OR accumulator with memory (indirect) ($2B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $52C849.l,X		; 1F 49 C8 52 ; Logical OR long $52C849.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b),Y		; 11 01 ; OR accumulator with memory ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $1B1C.w		; 2C 1C 1B ; Test bits $1B1C.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	bit $11.b		; 24 11 ; Test bits $11.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora ($56.b)		; 12 56 ; OR accumulator with memory (indirect) ($56.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $1A00.w		; 1C 00 1A ; Test and reset bits $1A00.w [Reads: Accumulator] [Flags: Z]
	ora ($12.b),Y		; 11 12 ; OR accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
.INDEX 16
	rep #$17		; C2 17
	jmp $1159.w		; 4C 59 11 ; Jump to $1159.w [Flow: jump]
	ora ($1A.b),Y		; 11 1A ; OR accumulator with memory ($1A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $65.b,X		; 34 65 ; Test bits $65.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	adc $10.b		; 65 10 ; Add $10.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($34.b),Y		; 11 34 ; OR accumulator with memory ($34.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $14.b,X		; 34 14 ; Test bits $14.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $10, $D4		; 10 D4 ; Branch if plus to $10, $D4 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cmp ($17.b),Y		; D1 17 ; Compare accumulator ($17.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $3434.w		; 1C 34 34 ; Test and reset bits $3434.w [Reads: Accumulator] [Flags: Z]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	cmp $65DCC9.l,X		; DF C9 DC 65 ; Compare accumulator (long,X) $65DCC9.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $34.b		; 66 34 ; Rotate right $34.b [Reads: Direct Page] [Flags: NCZ]
	bit $29.b,X		; 34 29 ; Test bits $29.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $10, $02		; 10 02 ; Branch if plus to $10, $02 [Flow: branch]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	jmp.w [$001C]		; DC 1C 00 ; Jump long indirect [$001C] [Flow: jump]
	cop $2B.b		; 02 2B ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $83.b,S		; 83 83 ; Store accumulator (stack relative) $83.b,S [Reads: Stack Pointer, Accumulator]
	jmp.w [$1021]		; DC 21 10 ; Jump long indirect [$1021] [Flow: jump]
	cmp $83DC.w,X		; DD DC 83 ; Compare accumulator $83DC.w,X [Reads: X Index] [Flags: NCZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jmp.w [$E3E4]		; DC E4 E3 ; Jump long indirect [$E3E4] [Flow: jump]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	cpx $6B.b		; E4 6B ; Compare $6B.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	jmp.w [$012C]		; DC 2C 01 ; Jump long indirect [$012C] [Flow: jump]
	cop $78.b		; 02 78 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	jmp.w [$2012]		; DC 12 20 ; Jump long indirect [$2012] [Flow: jump]
	jmp.w [$61DC]		; DC DC 61 ; Jump long indirect [$61DC] [Flow: jump]
	cmp $1000.w,X		; DD 00 10 ; Compare accumulator $1000.w,X [Reads: X Index] [Flags: NCZ]
	jmp $1110.w		; 4C 10 11 ; Jump to $1110.w [Flow: jump]
	ora $121111.l,X		; 1F 11 11 12 ; Logical OR long $121111.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $10, $2F		; 10 2F ; Branch if plus to $10, $2F [Flow: branch]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $29.b,X		; 34 29 ; Test bits $29.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lsr $3134.w,X		; 5E 34 31 ; Logical shift right $3134.w,X [Reads: X Index] [Flags: NCZ]
	trb $10.b		; 14 10 ; Test and reset bits $10.b [Reads: Accumulator] [Flags: Z]
	ora ($66.b),Y		; 11 66 ; OR accumulator with memory ($66.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	and ($34.b)		; 32 34 ; AND accumulator with memory (indirect) ($34.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($20.b)		; 12 20 ; OR accumulator with memory (indirect) ($20.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $36.b,X		; 34 36 ; Test bits $36.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	adc [$2F.b]		; 67 2F ; Add with carry (long) [$2F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cop $11.b		; 02 11 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $6A.b,S		; 83 6A ; Store accumulator (stack relative) $6A.b,S [Reads: Stack Pointer, Accumulator]
	dec $1134.w		; CE 34 11 ; Decrement $1134.w [Flags: NZ]
	brk $ED.b		; 00 ED ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $EE.b,X		; 34 EE ; Test bits $EE.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	eor $1110.w,Y		; 59 10 11 ; Exclusive OR accumulator with memory $1110.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	stx $34.b		; 86 34 ; Store X register to $34.b [Reads: X Index]
	dec $1011.w		; CE 11 10 ; Decrement $1011.w [Flags: NZ]
	bit $ED.b,X		; 34 ED ; Test bits $ED.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	rol $0134.w		; 2E 34 01 ; Rotate left $0134.w [Flags: NCZ]
	.db $10, $38		; 10 38 ; Branch if plus to $10, $38 [Flow: branch]
	jmp $8610.w		; 4C 10 86 ; Jump to $8610.w [Flow: jump]
	and ($11.b,X)		; 21 11 ; Logical AND ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $6D.b,X		; 34 6D ; Test bits $6D.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $EB.b,X		; 34 EB ; Test bits $EB.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $12.b,X		; 34 12 ; Test bits $12.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	eor ($01.b,X)		; 41 01 ; Exclusive OR accumulator with memory ($01.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($34.b,X)		; 01 34 ; Logical OR ($34.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	jmp ($00EB.w)		; 6C EB 00 ; Jump indirect to ($00EB.w) [Flow: jump]
	ora ($86.b),Y		; 11 86 ; OR accumulator with memory ($86.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $2734.w,Y		; 39 34 27 ; AND accumulator with memory $2734.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b)		; 12 01 ; OR accumulator with memory (indirect) ($01.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor #$E341.w		; 49 41 E3 ; Exclusive OR #$E341.w with accumulator [Writes: Accumulator] [Flags: NZ]
	stx $11.b		; 86 11 ; Store X register to $11.b [Reads: X Index]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $3E.b,X		; 34 3E ; Test bits $3E.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	eor $592110.l		; 4F 10 21 59 ; Exclusive OR accumulator with memory (long) $592110.l [Writes: Accumulator] [Flags: NZ]
	eor #$273F.w		; 49 3F 27 ; Exclusive OR #$273F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($21.b),Y		; 11 21 ; OR accumulator with memory ($21.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($15.b)		; 32 15 ; AND accumulator with memory (indirect) ($15.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($49.b)		; 12 49 ; OR accumulator with memory (indirect) ($49.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cmp #$5053.w		; C9 53 50 ; Compare #$5053.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($1B.b)		; 32 1B ; AND accumulator with memory (indirect) ($1B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $2A		; 10 2A ; Branch if plus to $10, $2A [Flow: branch]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$1254.w		; C9 54 12 ; Compare #$1254.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jmp $202B.w		; 4C 2B 20 ; Jump to $202B.w [Flow: jump]
	jmp $1011.w		; 4C 11 10 ; Jump to $1011.w [Flow: jump]
	eor ($34.b,X)		; 41 34 ; Exclusive OR accumulator with memory ($34.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $33.b		; 04 33 ; Test and set bits $33.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($33.b),Y		; 91 33 ; Store accumulator ($33.b),Y [Reads: Direct Page, Y Index, Accumulator]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $8D.b,X		; 34 8D ; Test bits $8D.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $30, $64		; 30 64 ; Branch if minus to $30, $64 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	bit $0F.b,X		; 34 0F ; Test bits $0F.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $47B2.w,X		; 5E B2 47 ; Logical shift right $47B2.w,X [Reads: X Index] [Flags: NCZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $5E045E.l		; 22 5E 04 5E ; Jump to subroutine long $5E045E.l [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($20.b)		; 12 20 ; OR accumulator with memory (indirect) ($20.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $00005E.l		; 2F 5E 00 00 ; AND accumulator with memory (long) $00005E.l [Writes: Accumulator] [Flags: NZ]
	and ($66.b,S),Y		; 33 66 ; AND accumulator (stack relative indirect indexed) ($66.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $0030.w,X		; 7D 30 00 ; Add $0030.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $71.b		; 00 71 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $40.b,X		; 34 40 ; Test bits $40.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	lsr $2000.w,X		; 5E 00 20 ; Logical shift right $2000.w,X [Reads: X Index] [Flags: NCZ]
	jsl $7F2345.l		; 22 45 23 7F ; Jump to subroutine long $7F2345.l [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	rol $3433.w		; 2E 33 34 ; Rotate left $3433.w [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $B0, $4B		; B0 4B ; Branch if carry set to $B0, $4B [Flow: branch]
	lsr $0033.w,X		; 5E 33 00 ; Logical shift right $0033.w,X [Reads: X Index] [Flags: NCZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $10.b		; 04 10 ; Test and set bits $10.b [Reads: Accumulator] [Flags: Z]
	ora ($00.b)		; 12 00 ; OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $70.b		; 46 70 ; Logical shift right $70.b [Reads: Direct Page] [Flags: NCZ]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $0430.w		; 6E 30 04 ; Rotate right $0430.w [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ror $40.b,X		; 76 40 ; Rotate right $40.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $AF7F.w		; 2C 7F AF ; Test bits $AF7F.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $24.b		; 45 24 ; Exclusive OR $24.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $7F.b,S		; 23 7F ; AND accumulator with stack relative $7F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $811C46.l		; AF 46 1C 81 ; Load long $811C46.l into accumulator [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $4B.b,X		; 36 4B ; Rotate left $4B.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	lda $8D0000.l		; AF 00 00 8D ; Load long $8D0000.l into accumulator [Writes: Accumulator] [Flags: NZ]
	bit $45.b,X		; 34 45 ; Test bits $45.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sta ($00.b,X)		; 81 00 ; Store accumulator ($00.b,X) [Reads: Direct Page, Accumulator, X Index]
	jsr $9535.w		; 20 35 95 ; Jump to subroutine at $9535.w [Writes: Stack Pointer] [Flow: call]
	adc ($04.b),Y		; 71 04 ; Add with carry ($04.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $26B5.w,Y		; 79 B5 26 ; Add $26B5.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $0010.w,Y		; 79 10 00 ; Add $0010.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $5C.b		; 04 5C ; Test and set bits $5C.b [Reads: Accumulator] [Flags: Z]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	brk $5A.b		; 00 5A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	ror $00AC.w		; 6E AC 00 ; Rotate right $00AC.w [Flags: NCZ]
	brk $BE.b		; 00 BE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $7C.b		; 02 7C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $0000.w		; AD 00 00 ; Load $0000.w into accumulator [Writes: Accumulator] [Flags: NZ]
	bit $1B.b,X		; 34 1B ; Test bits $1B.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora $AD.b,S		; 03 AD ; OR accumulator with stack relative $AD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $151614.l,X		; 3F 14 16 15 ; AND accumulator with memory (long,X) $151614.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $16.b		; 14 16 ; Test and reset bits $16.b [Reads: Accumulator] [Flags: Z]
	stz $64.b		; 64 64 ; Store zero to $64.b
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor #$0804.w		; 49 04 08 ; Exclusive OR #$0804.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and ($20.b),Y		; 31 20 ; AND accumulator with memory ($20.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $4E.b		; 00 4E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $0433.w		; 4D 33 04 ; Exclusive OR $0433.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $6E.b		; 04 6E ; Test and set bits $6E.b [Reads: Accumulator] [Flags: Z]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $300000.l		; 2F 00 00 30 ; AND accumulator with memory (long) $300000.l [Writes: Accumulator] [Flags: NZ]
	bit $AE.b,X		; 34 AE ; Test bits $AE.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	eor $00.b		; 45 00 ; Exclusive OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $2F.b		; 00 2F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $04.b,X		; 34 04 ; Test bits $04.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $717240.l		; 2F 40 72 71 ; AND accumulator with memory (long) $717240.l [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($34.b),Y		; 11 34 ; OR accumulator with memory ($34.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	rol $00.b,X		; 36 00 ; Rotate left $00.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp $4734.w		; 4C 34 47 ; Jump to $4734.w [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($B2.b),Y		; 11 B2 ; OR accumulator with memory ($B2.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $23.b		; 45 23 ; Exclusive OR $23.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda ($7E.b)		; B2 7E ; Load accumulator (indirect) ($7E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldx $0089.w		; AE 89 00 ; Load $0089.w into X register [Writes: X Index] [Flags: NZ]
	brk $51.b		; 00 51 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $22C8E5.l		; 22 E5 C8 22 ; Jump to subroutine long $22C8E5.l [Writes: Stack Pointer] [Flow: call]
	brk $E5.b		; 00 E5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($2C.b,X)		; 01 2C ; Logical OR ($2C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $01.b,S		; E3 01 ; Subtract stack-relative $01.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	jsr $75DC.w		; 20 DC 75 ; Jump to subroutine at $75DC.w [Writes: Stack Pointer] [Flow: call]
	sta $C9.b,S		; 83 C9 ; Store accumulator (stack relative) $C9.b,S [Reads: Stack Pointer, Accumulator]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ror $6C.b,X		; 76 6C ; Rotate right $6C.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	eor ($C9.b)		; 52 C9 ; Exclusive OR accumulator with memory (indirect) ($C9.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($20.b),Y		; 11 20 ; OR accumulator with memory ($20.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and [$EB.b],Y		; 37 EB ; AND accumulator with memory (long indexed) [$EB.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $78.b,S		; E3 78 ; Subtract stack-relative $78.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	and ($01.b,X)		; 21 01 ; Logical AND ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	stx $35.b		; 86 35 ; Store X register to $35.b [Reads: X Index]
	and [$6A.b],Y		; 37 6A ; AND accumulator with memory (long indexed) [$6A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $21		; 10 21 ; Branch if plus to $10, $21 [Flow: branch]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor ($CF.b)		; 52 CF ; Exclusive OR accumulator with memory (indirect) ($CF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	jmp ($0110.w)		; 6C 10 01 ; Jump indirect to ($0110.w) [Flow: jump]
	.db $50, $78		; 50 78 ; Branch if overflow clear to $50, $78 [Flow: branch]
	jmp.w [$11C8]		; DC C8 11 ; Jump long indirect [$11C8] [Flow: jump]
	brk $E3.b		; 00 E3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $7C9F.w,Y		; 39 9F 7C ; AND accumulator with memory $7C9F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor [$C9.b],Y		; 57 C9 ; Exclusive OR accumulator with memory (long indexed) [$C9.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc ($58.b,X)		; 61 58 ; Add with carry ($58.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr $5A12.w		; 20 12 5A ; Jump to subroutine at $5A12.w [Writes: Stack Pointer] [Flow: call]
	stx $FD.b		; 86 FD ; Store X register to $FD.b [Reads: X Index]
	ldy $1021.w		; AC 21 10 ; Load $1021.w into Y register [Writes: Y Index] [Flags: NZ]
	jsr ($5C4B.w,X)		; FC 4B 5C ; Jump to subroutine indirect indexed ($5C4B.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	stz $11.b		; 64 11 ; Store zero to $11.b
	jsl $616564.l		; 22 64 65 61 ; Jump to subroutine long $616564.l [Writes: Stack Pointer] [Flow: call]
	ror $22.b		; 66 22 ; Rotate right $22.b [Reads: Direct Page] [Flags: NCZ]
	ora ($A5.b)		; 12 A5 ; OR accumulator with memory (indirect) ($A5.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr $6850.w		; 4E 50 68 ; Logical shift right $6850.w [Flags: NCZ]
	ora ($12.b,X)		; 01 12 ; Logical OR ($12.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	adc #$706F.w		; 69 6F 70 ; Add #$706F.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	adc #$2222.w		; 69 22 22 ; Add #$2222.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	adc $5D.b		; 65 5D ; Add $5D.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp #$2263.w		; C9 63 22 ; Compare #$2263.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cop $E5.b		; 02 E5 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$34.b]		; E7 34 ; Subtract with carry (long) [$34.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ror $01.b,X		; 76 01 ; Rotate right $01.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cop $34.b		; 02 34 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $75.b,X		; 34 75 ; Test bits $75.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	jsr $3434.w		; 20 34 34 ; Jump to subroutine at $3434.w [Writes: Stack Pointer] [Flow: call]
	ora $21006B.l		; 0F 6B 00 21 ; OR accumulator with memory (long) $21006B.l [Writes: Accumulator] [Flags: NZ]
	ora $C86D34.l		; 0F 34 6D C8 ; OR accumulator with memory (long) $C86D34.l [Writes: Accumulator] [Flags: NZ]
	jsr $6D10.w		; 20 10 6D ; Jump to subroutine at $6D10.w [Writes: Stack Pointer] [Flow: call]
	eor ($C9.b,S),Y		; 53 C9 ; XOR accumulator (stack relative indirect indexed) ($C9.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora ($02.b),Y		; 11 02 ; OR accumulator with memory ($02.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $5E5C.w,X		; 5D 5C 5E ; Exclusive OR accumulator with memory $5E5C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	jsl $787A22.l		; 22 22 7A 78 ; Jump to subroutine long $787A22.l [Writes: Stack Pointer] [Flow: call]
	lsr $226E.w,X		; 5E 6E 22 ; Logical shift right $226E.w,X [Reads: X Index] [Flags: NCZ]
	jsl $64785D.l		; 22 5D 78 64 ; Jump to subroutine long $64785D.l [Writes: Stack Pointer] [Flow: call]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jsl $788122.l		; 22 22 81 78 ; Jump to subroutine long $788122.l [Writes: Stack Pointer] [Flow: call]
	adc $2278.w,X		; 7D 78 22 ; Add $2278.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $C88483.l		; 22 83 84 C8 ; Jump to subroutine long $C88483.l [Writes: Stack Pointer] [Flow: call]
	sta $22.b		; 85 22 ; Store accumulator to $22.b [Reads: Accumulator]
	cop $78.b		; 02 78 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sty $7F.b		; 84 7F ; Store Y register to $7F.b [Reads: Y Index]
	jsl $877821.l		; 22 21 78 87 ; Jump to subroutine long $877821.l [Writes: Stack Pointer] [Flow: call]
	bit #$225E.w		; 89 5E 22 ; Test bits #$225E.w with accumulator [Reads: Accumulator] [Flags: Z]
	jsl $C6837F.l		; 22 7F 83 C6 ; Jump to subroutine long $C6837F.l [Writes: Stack Pointer] [Flow: call]
	and $12.b,S		; 23 12 ; AND accumulator with stack relative $12.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $6E.b		; 02 6E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $91		; 90 91 ; Branch if carry clear to $90, $91 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jsl $C96522.l		; 22 22 65 C9 ; Jump to subroutine long $C96522.l [Writes: Stack Pointer] [Flow: call]
	adc $78.b,S		; 63 78 ; Add with carry (stack relative) $78.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	jsr $6E22.w		; 20 22 6E ; Jump to subroutine at $6E22.w [Writes: Stack Pointer] [Flow: call]
	jmp.w [$2734]		; DC 34 27 ; Jump long indirect [$2734] [Flow: jump]
	jsr $8501.w		; 20 01 85 ; Jump to subroutine at $8501.w [Writes: Stack Pointer] [Flow: call]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	stz $78.b		; 64 78 ; Store zero to $78.b
	jsl $836B22.l		; 22 22 6B 83 ; Jump to subroutine long $836B22.l [Writes: Stack Pointer] [Flow: call]
	and $2E.b		; 25 2E ; Logical AND $2E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $933611.l		; 22 11 36 93 ; Jump to subroutine long $933611.l [Writes: Stack Pointer] [Flow: call]
	sta ($36.b,S),Y		; 93 36 ; Store accumulator (stack relative indirect indexed) ($36.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	ora ($21.b)		; 12 21 ; OR accumulator with memory (indirect) ($21.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $95.b,X		; 95 95 ; Store accumulator to $95.b,X [Reads: Accumulator, X Index]
	rol $35.b,X		; 36 35 ; Rotate left $35.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	jsl $973411.l		; 22 11 34 97 ; Jump to subroutine long $973411.l [Writes: Stack Pointer] [Flow: call]
	sta [$9C.b],Y		; 97 9C ; Store accumulator (long indexed) [$9C.b],Y [Reads: Direct Page, Y Index, Accumulator]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	stz $2234.w		; 9C 34 22 ; Store zero to $2234.w
	jsr $0A34.w		; 20 34 0A ; Jump to subroutine at $0A34.w [Writes: Stack Pointer] [Flow: call]
	mvp $01,$A2		; 44 A2 01 ; Move block positive $01,$A2 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora ($A2.b)		; 12 A2 ; OR accumulator with memory (indirect) ($A2.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldx #$7878.w		; A2 78 78 ; Load #$7878.w into X register [Writes: X Index] [Flags: NZ]
	jsl $4BB322.l		; 22 22 B3 4B ; Jump to subroutine long $4BB322.l [Writes: Stack Pointer] [Flow: call]
	and [$78.b]		; 27 78 ; AND accumulator with memory (long) [$78.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($12.b),Y		; 11 12 ; OR accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jmp ($847E.w,X)		; 7C 7E 84 ; Jump indirect indexed to ($847E.w,X) [Reads: X Index] [Flow: jump]
	eor ($22.b,X)		; 41 22 ; Exclusive OR accumulator with memory ($22.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and ($A4.b,X)		; 21 A4 ; Logical AND ($A4.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	bit #$2222.w		; 89 22 22 ; Test bits #$2222.w with accumulator [Reads: Accumulator] [Flags: Z]
	eor $7880.w,X		; 5D 80 78 ; Exclusive OR accumulator with memory $7880.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	stx $22.b		; 86 22 ; Store X register to $22.b [Reads: X Index]
	jsl $897878.l		; 22 78 78 89 ; Jump to subroutine long $897878.l [Writes: Stack Pointer] [Flow: call]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jsl $877822.l		; 22 22 78 87 ; Jump to subroutine long $877822.l [Writes: Stack Pointer] [Flow: call]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cmp $22.b		; C5 22 ; Compare $22.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	jsr $0765.w		; 20 65 07 ; Jump to subroutine at $0765.w [Writes: Stack Pointer] [Flow: call]
	jmp ($1179.w)		; 6C 79 11 ; Jump indirect to ($1179.w) [Flow: jump]
	jsl $32787B.l		; 22 7B 78 32 ; Jump to subroutine long $32787B.l [Writes: Stack Pointer] [Flow: call]
	and $22.b,S		; 23 22 ; AND accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $7F5E78.l		; 22 78 5E 7F ; Jump to subroutine long $7F5E78.l [Writes: Stack Pointer] [Flow: call]
	.db $80, $22		; 80 22 ; Branch always to $80, $22 [Flow: branch]
	jsl $78787A.l		; 22 7A 78 78 ; Jump to subroutine long $78787A.l [Writes: Stack Pointer] [Flow: call]
	sty $2222.w		; 8C 22 22 ; Store Y register to $2222.w [Reads: Y Index]
	ror $63.b,X		; 76 63 ; Rotate right $63.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora ($22.b)		; 12 22 ; OR accumulator with memory (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $63.b		; 65 63 ; Add $63.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jsl $DCA722.l		; 22 22 A7 DC ; Jump to subroutine long $DCA722.l [Writes: Stack Pointer] [Flow: call]
	lsr $2053.w		; 4E 53 20 ; Logical shift right $2053.w [Flags: NCZ]
	ora ($A9.b),Y		; 11 A9 ; OR accumulator with memory ($A9.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpy $E3AA.w		; CC AA E3 ; Compare $E3AA.w with Y register [Reads: Y Index] [Flags: NCZ]
	jsr $3420.w		; 20 20 34 ; Jump to subroutine at $3420.w [Writes: Stack Pointer] [Flow: call]
	eor $0134A5.l		; 4F A5 34 01 ; Exclusive OR accumulator with memory (long) $0134A5.l [Writes: Accumulator] [Flags: NZ]
	brk $CE.b		; 00 CE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lda $016D.w		; AD 6D 01 ; Load $016D.w into accumulator [Writes: Accumulator] [Flags: NZ]
	and ($AB.b,X)		; 21 AB ; Logical AND ($AB.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ldx $D5C8.w		; AE C8 D5 ; Load $D5C8.w into X register [Writes: X Index] [Flags: NZ]
	jsl $B0B101.l		; 22 01 B1 B0 ; Jump to subroutine long $B0B101.l [Writes: Stack Pointer] [Flow: call]
	cmp #$226D.w		; C9 6D 22 ; Compare #$226D.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora ($82.b,X)		; 01 82 ; Logical OR ($82.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda $1234EC.l		; AF EC 34 12 ; Load long $1234EC.l into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $10, $CF		; 10 CF ; Branch if plus to $10, $CF [Flow: branch]
	cmp ($35.b),Y		; D1 35 ; Compare accumulator ($35.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda ($34.b)		; B2 34 ; Load accumulator (indirect) ($34.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc ($B3.b),Y		; 71 B3 ; Add with carry ($B3.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr $B402.w		; 20 02 B4 ; Jump to subroutine at $B402.w [Writes: Stack Pointer] [Flow: call]
	adc $DC.b,S		; 63 DC ; Add with carry (stack relative) $DC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sta ($21.b)		; 92 21 ; Store accumulator (indirect) ($21.b) [Reads: Direct Page, Accumulator]
	cop $1C.b		; 02 1C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $2725.w,X		; 1D 25 27 ; OR accumulator with memory $2725.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta ($78.b,X)		; 81 78 ; Store accumulator ($78.b,X) [Reads: Direct Page, Accumulator, X Index]
	bit #$224E.w		; 89 4E 22 ; Test bits #$224E.w with accumulator [Reads: Accumulator] [Flags: Z]
	and ($4B.b,X)		; 21 4B ; Logical AND ($4B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $50, $34		; 50 34 ; Branch if overflow clear to $50, $34 [Flow: branch]
	sta $11.b		; 85 11 ; Store accumulator to $11.b [Reads: Accumulator]
	cop $86.b		; 02 86 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	adc $50.b		; 65 50 ; Add $50.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jsl $8B8C21.l		; 22 21 8C 8B ; Jump to subroutine long $8B8C21.l [Writes: Stack Pointer] [Flow: call]
	adc $2278.w,Y		; 79 78 22 ; Add $2278.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $798FD0.l		; 22 D0 8F 79 ; Jump to subroutine long $798FD0.l [Writes: Stack Pointer] [Flow: call]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	cop $21.b		; 02 21 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $B8B8.w,X		; BD B8 B8 ; Load $B8B8.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$2222.w		; C0 22 22 ; Compare #$2222.w with Y register [Reads: Y Index] [Flags: NCZ]
	ror $3175.w,X		; 7E 75 31 ; Rotate right $3175.w,X [Reads: X Index] [Flags: NCZ]
	cmp ($11.b,X)		; C1 11 ; Compare accumulator ($11.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	ora ($C2.b)		; 12 C2 ; OR accumulator with memory (indirect) ($C2.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $CA78.w		; 2D 78 CA ; Logical AND $CA78.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and ($12.b,X)		; 21 12 ; Logical AND ($12.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpy $51CF.w		; CC CF 51 ; Compare $51CF.w with Y register [Reads: Y Index] [Flags: NCZ]
	dec $20.b		; C6 20 ; Decrement $20.b [Reads: Direct Page] [Flags: NZ]
	ora ($C9.b)		; 12 C9 ; OR accumulator with memory (indirect) ($C9.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dec $D4C5.w		; CE C5 D4 ; Decrement $D4C5.w [Flags: NZ]
	jsr $C822.w		; 20 22 C8 ; Jump to subroutine at $C822.w [Writes: Stack Pointer] [Flow: call]
	cmp ($C7.b),Y		; D1 C7 ; Compare accumulator ($C7.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	and ($06.b,X)		; 21 06 ; Logical AND ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	dec $D0.b		; C6 D0 ; Decrement $D0.b [Reads: Direct Page] [Flags: NZ]
	cmp $2210.w		; CD 10 22 ; Compare $2210.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp [$D4.b],Y		; D7 D4 ; Compare accumulator (long indexed) [$D4.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cmp ($22.b)		; D2 22 ; Compare accumulator (indirect) ($22.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cop $C7.b		; 02 C7 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $31D2.w		; CE D2 31 ; Decrement $31D2.w [Flags: NZ]
	jsr $C601.w		; 20 01 C6 ; Jump to subroutine at $C601.w [Writes: Stack Pointer] [Flow: call]
	cmp [$D7.b]		; C7 D7 ; Compare accumulator (long) [$D7.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	pei ($22.b)		; D4 22 ; Push effective indirect address ($22.b) [Reads: Direct Page] [Writes: Stack Pointer]
	jsl $C9C8D1.l		; 22 D1 C8 C9 ; Jump to subroutine long $C9C8D1.l [Writes: Stack Pointer] [Flow: call]
	bit $22.b,X		; 34 22 ; Test bits $22.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	jsr $C8CE.w		; 20 CE C8 ; Jump to subroutine at $C8CE.w [Writes: Stack Pointer] [Flow: call]
	cmp $00C7.w		; CD C7 00 ; Compare $00C7.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsl $34DBC8.l		; 22 C8 DB 34 ; Jump to subroutine long $34DBC8.l [Writes: Stack Pointer] [Flow: call]
	cpx #$0222.w		; E0 22 02 ; Compare #$0222.w with X register [Reads: X Index] [Flags: NCZ]
	sbc ($E3.b,X)		; E1 E3 ; Subtract with carry ($E3.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $0222C6.l		; CF C6 22 02 ; Compare accumulator (long) $0222C6.l [Reads: Accumulator] [Flags: NCZ]
	cmp [$DA.b]		; C7 DA ; Compare accumulator (long) [$DA.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	nop		; EA ; No operation
	and $22.b,X		; 35 22 ; Logical AND $22.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	jsr $EDE5.w		; 20 E5 ED ; Jump to subroutine at $EDE5.w [Writes: Stack Pointer] [Flow: call]
	inc $C8.b		; E6 C8 ; Increment $C8.b [Reads: Direct Page] [Flags: NZ]
	jsl $CD3A20.l		; 22 20 3A CD ; Jump to subroutine long $CD3A20.l [Writes: Stack Pointer] [Flow: call]
	inc $CD.b,X		; F6 CD ; Increment memory $CD.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	jsl $F6F622.l		; 22 22 F6 F6 ; Jump to subroutine long $F6F622.l [Writes: Stack Pointer] [Flow: call]
	sbc #$2234.w		; E9 34 22 ; Subtract #$2234.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	jsr $85C8.w		; 20 C8 85 ; Jump to subroutine at $85C8.w [Writes: Stack Pointer] [Flow: call]
	sbc ($E6.b),Y		; F1 E6 ; Subtract with carry ($E6.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cpy $58.b		; C4 58 ; Compare $58.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	sbc [$00.b],Y		; F7 00 ; Subtract with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($CD.b)		; 12 CD ; OR accumulator with memory (indirect) ($CD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $FBCD.w		; CD CD FB ; Compare $FBCD.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsl $D3D222.l		; 22 22 D2 D3 ; Jump to subroutine long $D3D222.l [Writes: Stack Pointer] [Flow: call]
	bit $FC.b,X		; 34 FC ; Test bits $FC.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	jsl $3AE602.l		; 22 02 E6 3A ; Jump to subroutine long $3AE602.l [Writes: Stack Pointer] [Flow: call]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cmp $22.b		; C5 22 ; Compare $22.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cop $CD.b		; 02 CD ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $01FF.w		; CD FF 01 ; Compare $01FF.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsl $685E23.l		; 22 23 5E 68 ; Jump to subroutine long $685E23.l [Writes: Stack Pointer] [Flow: call]
	.db $62, $02, $11		; 62 02 11 ; Push effective relative address $62, $02, $11 [Writes: Stack Pointer]
	ora ($E6.b,S),Y		; 13 E6 ; OR accumulator (stack relative indirect indexed) ($E6.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $0803.w,X		; FE 03 08 ; Increment memory $0803.w,X [Reads: X Index] [Flags: NZ]
	jsl $FF0A33.l		; 22 33 0A FF ; Jump to subroutine long $FF0A33.l [Writes: Stack Pointer] [Flow: call]
	adc $07.b,S		; 63 07 ; Add with carry (stack relative) $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	and ($13.b)		; 32 13 ; AND accumulator with memory (indirect) ($13.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $E1.b		; E6 E1 ; Increment $E1.b [Reads: Direct Page] [Flags: NZ]
	sbc ($02.b,X)		; E1 02 ; Subtract with carry ($02.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $EDE623.l		; 22 23 E6 ED ; Jump to subroutine long $EDE623.l [Writes: Stack Pointer] [Flow: call]
	ora ($13.b)		; 12 13 ; OR accumulator with memory (indirect) ($13.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $FD1433.l		; 22 33 14 FD ; Jump to subroutine long $FD1433.l [Writes: Stack Pointer] [Flow: call]
	inc $E6.b		; E6 E6 ; Increment $E6.b [Reads: Direct Page] [Flags: NZ]
	and ($22.b)		; 32 22 ; AND accumulator with memory (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $F5.b		; E6 F5 ; Increment $F5.b [Reads: Direct Page] [Flags: NZ]
	ora $22C0.w,X		; 1D C0 22 ; OR accumulator with memory $22C0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($61.b)		; 32 61 ; AND accumulator with memory (indirect) ($61.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $1F.b,X		; 16 1F ; Arithmetic shift left $1F.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ror $13.b		; 66 13 ; Rotate right $13.b [Reads: Direct Page] [Flags: NCZ]
	and ($1A.b),Y		; 31 1A ; AND accumulator with memory ($1A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	inc $21.b		; E6 21 ; Increment $21.b [Reads: Direct Page] [Flags: NZ]
	sbc $32.b,X		; F5 32 ; Subtract $32.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($31.b)		; 32 31 ; AND accumulator with memory (indirect) ($31.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx $D5.b		; E4 D5 ; Compare $D5.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	adc ($12.b,X)		; 61 12 ; Add with carry ($12.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($D5.b,X)		; 21 D5 ; Logical AND ($D5.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	ror $E6.b		; 66 E6 ; Rotate right $E6.b [Reads: Direct Page] [Flags: NCZ]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	inc $D0D0.w,X		; FE D0 D0 ; Increment memory $D0D0.w,X [Reads: X Index] [Flags: NZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $26.b		; 24 26 ; Test bits $26.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cmp $CA.b,X		; D5 CA ; Compare accumulator $CA.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	and ($20.b,S),Y		; 33 20 ; AND accumulator (stack relative indirect indexed) ($20.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $E6.b		; C6 E6 ; Decrement $E6.b [Reads: Direct Page] [Flags: NZ]
	ora $C5.b,S		; 03 C5 ; OR accumulator with stack relative $C5.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $30.b		; 02 30 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $F83432.l,X		; FF 32 34 F8 ; Subtract with carry (long,X) $F83432.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $37E622.l		; 22 22 E6 37 ; Jump to subroutine long $37E622.l [Writes: Stack Pointer] [Flow: call]
	rol $2230.w		; 2E 30 22 ; Rotate left $2230.w [Flags: NCZ]
	and ($0D.b,S),Y		; 33 0D ; AND accumulator (stack relative indirect indexed) ($0D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit #$9AA9.w		; 89 A9 9A ; Test bits #$9AA9.w with accumulator [Reads: Accumulator] [Flags: Z]
	jsr $3400.w		; 20 00 34 ; Jump to subroutine at $3400.w [Writes: Stack Pointer] [Flow: call]
	ldx $3471.w		; AE 71 34 ; Load $3471.w into X register [Writes: X Index] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $AF9A.w,X		; DE 9A AF ; Decrement memory $AF9A.w,X [Reads: X Index] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $34.b,X		; 95 34 ; Store accumulator to $34.b,X [Reads: Accumulator, X Index]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and $34.b,X		; 35 34 ; Logical AND $34.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $36.b,X		; 95 36 ; Store accumulator to $36.b,X [Reads: Accumulator, X Index]
	rol $B1.b,X		; 36 B1 ; Rotate left $B1.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc ($34.b)		; F2 34 ; Subtract with carry (indirect) ($34.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	.db $30, $01		; 30 01 ; Branch if minus to $30, $01 [Flow: branch]
	bit #$343D.w		; 89 3D 34 ; Test bits #$343D.w with accumulator [Reads: Accumulator] [Flags: Z]
	sbc ($02.b)		; F2 02 ; Subtract with carry (indirect) ($02.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	brk $B9.b		; 00 B9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($7F.b)		; 12 7F ; OR accumulator with memory (indirect) ($7F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $DC0000.l		; AF 00 00 DC ; Load long $DC0000.l into accumulator [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $42, $03		; 42 03 ; Reserved instruction
	and ($44.b,S),Y		; 33 44 ; AND accumulator (stack relative indirect indexed) ($44.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $334E6A.l,X		; 3F 6A 4E 33 ; AND accumulator with memory (long,X) $334E6A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($50.b,S),Y		; 13 50 ; OR accumulator (stack relative indirect indexed) ($50.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor ($54.b)		; 52 54 ; Exclusive OR accumulator with memory (indirect) ($54.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and ($31.b,S),Y		; 33 31 ; AND accumulator (stack relative indirect indexed) ($31.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $646061.l,X		; 5F 61 60 64 ; Exclusive OR accumulator with memory (long,X) $646061.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($33.b,S),Y		; 33 33 ; AND accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc $67.b		; 65 67 ; Add $67.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda #$3013.w		; A9 13 30 ; Load #$3013.w into accumulator [Writes: Accumulator] [Flags: NZ]
	adc $9A.b		; 65 9A ; Add $9A.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ror $0330.w		; 6E 30 03 ; Rotate right $0330.w [Flags: NCZ]
	adc $6FA971.l		; 6F 71 A9 6F ; Add with carry (long) $6FA971.l [Writes: Accumulator] [Flags: NCVZ]
	and ($03.b,S),Y		; 33 03 ; AND accumulator (stack relative indirect indexed) ($03.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
.ACCU 8
	sep #$28		; E2 28
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	stz $0000.w		; 9C 00 00 ; Store zero to $0000.w
	lda #$9A.b		; A9 9A ; Load #$9A.b into accumulator [Writes: Accumulator] [Flags: NZ]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($34.b,X)		; E1 34 ; Subtract with carry ($34.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	brk $33.b		; 00 33 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $3634.w,X		; 7E 34 36 ; Rotate right $3634.w,X [Reads: X Index] [Flags: NCZ]
	rol $30.b,X		; 36 30 ; Rotate left $30.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $9E.b		; 00 9E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $34.b,X		; 36 34 ; Rotate left $34.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ror $0300.w,X		; 7E 00 03 ; Rotate right $0300.w,X [Reads: X Index] [Flags: NCZ]
	ror $A934.w,X		; 7E 34 A9 ; Rotate right $A934.w,X [Reads: X Index] [Flags: NCZ]
	rol $30.b,X		; 36 30 ; Rotate left $30.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $83.b,X		; 34 83 ; Test bits $83.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $30.b,X		; 34 30 ; Test bits $30.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $30, $73		; 30 73 ; Branch if minus to $30, $73 [Flow: branch]
	adc ($A9.b,S),Y		; 73 A9 ; Add with carry (stack relative indirect indexed) ($A9.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	adc $7E0333.l,X		; 7F 33 03 7E ; Add long $7E0333.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	lda $30.b,S		; A3 30 ; Load accumulator (stack relative) $30.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	jmp ($0100.w,X)		; 7C 00 01 ; Jump indirect indexed to ($0100.w,X) [Reads: X Index] [Flow: jump]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	lda $A5.b		; A5 A5 ; Load $A5.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	lda $AB.b		; A5 AB ; Load $AB.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy $01.b		; A4 01 ; Load $01.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	brk $A6.b		; 00 A6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $A5.b		; A5 A5 ; Load $A5.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($A5.b),Y		; 11 A5 ; OR accumulator with memory ($A5.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr $4E4E.w		; 4E 4E 4E ; Logical shift right $4E4E.w [Flags: NCZ]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jmp.w [$ABCB]		; DC CB AB ; Jump long indirect [$ABCB] [Flow: jump]
	sta $20.b		; 85 20 ; Store accumulator to $20.b [Reads: Accumulator]
	ora $11.b,S		; 03 11 ; OR accumulator with stack relative $11.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $DB83.w		; CE 83 DB ; Decrement $DB83.w [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $3478C9.l,X		; DF C9 78 34 ; Compare accumulator (long,X) $3478C9.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $E6F5.w,X		; 9D F5 E6 ; Store accumulator to $E6F5.w,X [Reads: Accumulator, X Index]
	inc $02.b		; E6 02 ; Increment $02.b [Reads: Direct Page] [Flags: NZ]
	jsl $350F6A.l		; 22 6A 0F 35 ; Jump to subroutine long $350F6A.l [Writes: Stack Pointer] [Flow: call]
	rol $12.b,X		; 36 12 ; Rotate left $12.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $C8.b		; 00 C8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp #$86.b		; C9 86 ; Compare #$86.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	adc ($00.b,S),Y		; 73 00 ; Add with carry (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora ($34.b,S),Y		; 13 34 ; OR accumulator (stack relative indirect indexed) ($34.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $34.b,X		; 36 34 ; Rotate left $34.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sta $350300.l		; 8F 00 03 35 ; Store accumulator (long) $350300.l [Reads: Accumulator]
	adc ($8C.b,S),Y		; 73 8C ; Add with carry (stack relative indirect indexed) ($8C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($03.b,X)		; E1 03 ; Subtract with carry ($03.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $34		; 30 34 ; Branch if minus to $30, $34 [Flow: branch]
	bit $73.b,X		; 34 73 ; Test bits $73.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $30, $35		; 30 35 ; Branch if minus to $30, $35 [Flow: branch]
	sta $0DDA.w		; 8D DA 0D ; Store accumulator to $0DDA.w [Reads: Accumulator]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $90, $DA		; 90 DA ; Branch if carry clear to $90, $DA [Flow: branch]
	adc ($E1.b,S),Y		; 73 E1 ; Add with carry (stack relative indirect indexed) ($E1.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	sbc ($7E.b,X)		; E1 7E ; Subtract with carry ($7E.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $0334.w,Y		; 39 34 03 ; AND accumulator with memory $0334.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	jsr $7DDA.w		; 20 DA 7D ; Jump to subroutine at $7DDA.w [Writes: Stack Pointer] [Flow: call]
	sty $037E.w		; 8C 7E 03 ; Store Y register to $037E.w [Reads: Y Index]
	and ($8C.b,S),Y		; 33 8C ; AND accumulator (stack relative indirect indexed) ($8C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $90, $8C		; 90 8C ; Branch if carry clear to $90, $8C [Flow: branch]
	sty $33.b		; 84 33 ; Store Y register to $33.b [Reads: Y Index]
	and ($90.b,S),Y		; 33 90 ; AND accumulator (stack relative indirect indexed) ($90.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $0F7E.w,X		; 7D 7E 0F ; Add $0F7E.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($32.b,S),Y		; 33 32 ; AND accumulator (stack relative indirect indexed) ($32.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sty $9090.w		; 8C 90 90 ; Store Y register to $9090.w [Reads: Y Index]
	.db $90, $33		; 90 33 ; Branch if carry clear to $90, $33 [Flow: branch]
	and ($34.b,S),Y		; 33 34 ; AND accumulator (stack relative indirect indexed) ($34.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	bit $35.b,X		; 34 35 ; Test bits $35.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $7E		; 90 7E ; Branch if carry clear to $90, $7E [Flow: branch]
	sta $36.b,S		; 83 36 ; Store accumulator (stack relative) $36.b,S [Reads: Stack Pointer, Accumulator]
	and ($30.b,S),Y		; 33 30 ; AND accumulator (stack relative indirect indexed) ($30.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $90, $8C		; 90 8C ; Branch if carry clear to $90, $8C [Flow: branch]
	sty $338E.w		; 8C 8E 33 ; Store Y register to $338E.w [Reads: Y Index]
	and ($90.b,S),Y		; 33 90 ; AND accumulator (stack relative indirect indexed) ($90.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ror $397F.w,X		; 7E 7F 39 ; Rotate right $397F.w,X [Reads: X Index] [Flags: NCZ]
	and ($32.b,S),Y		; 33 32 ; AND accumulator (stack relative indirect indexed) ($32.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc ($8E.b,S),Y		; 73 8E ; Add with carry (stack relative indirect indexed) ($8E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	.db $90, $33		; 90 33 ; Branch if carry clear to $90, $33 [Flow: branch]
	ora $90.b,S		; 03 90 ; OR accumulator with stack relative $90.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda #$F5.b		; A9 F5 ; Load #$F5.b into accumulator [Writes: Accumulator] [Flags: NZ]
	adc ($30.b,S),Y		; 73 30 ; Add with carry (stack relative indirect indexed) ($30.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora ($73.b,S),Y		; 13 73 ; OR accumulator (stack relative indirect indexed) ($73.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $7F0F.w,Y		; 39 0F 7F ; AND accumulator with memory $7F0F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($23.b)		; 32 23 ; AND accumulator with memory (indirect) ($23.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $80, $92		; 80 92 ; Branch always to $80, $92 [Flow: branch]
	adc ($82.b,S),Y		; 73 82 ; Add with carry (stack relative indirect indexed) ($82.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	and ($33.b,S),Y		; 33 33 ; AND accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $A5.b		; A5 A5 ; Load $A5.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy $A5.b		; A4 A5 ; Load $A5.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpy $A5.b		; C4 A5 ; Compare $A5.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	lsr $104E.w		; 4E 4E 10 ; Logical shift right $104E.w [Flags: NCZ]
	ora ($38.b),Y		; 11 38 ; OR accumulator with memory ($38.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	lda [$33.b],Y		; B7 33 ; Load accumulator (long indexed) [$33.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($B7.b)		; 12 B7 ; OR accumulator with memory (indirect) ($B7.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpy $83.b		; C4 83 ; Compare $83.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	jsr $C510.w		; 20 10 C5 ; Jump to subroutine at $C510.w [Writes: Stack Pointer] [Flow: call]
	dec $D1CA.w		; CE CA D1 ; Decrement $D1CA.w [Flags: NZ]
	jsl $0FCD02.l		; 22 02 CD 0F ; Jump to subroutine long $0FCD02.l [Writes: Stack Pointer] [Flow: call]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	eor ($22.b,S),Y		; 53 22 ; XOR accumulator (stack relative indirect indexed) ($22.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($E4.b,X)		; 21 E4 ; Logical AND ($E4.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp $D0CD.w		; CD CD D0 ; Compare $D0CD.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsl $ABD522.l		; 22 22 D5 AB ; Jump to subroutine long $ABD522.l [Writes: Stack Pointer] [Flow: call]
	cmp $CD.b		; C5 CD ; Compare $CD.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	jsl $24E422.l		; 22 22 E4 24 ; Jump to subroutine long $24E422.l [Writes: Stack Pointer] [Flow: call]
	and $25.b		; 25 25 ; Logical AND $25.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $33.b,S		; 23 33 ; AND accumulator with stack relative $33.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $25.b		; 25 25 ; Logical AND $25.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($EB.b,S),Y		; 93 EB ; Store accumulator (stack relative indirect indexed) ($EB.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	and ($31.b,S),Y		; 33 31 ; AND accumulator (stack relative indirect indexed) ($31.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($95.b,S),Y		; 33 95 ; AND accumulator (stack relative indirect indexed) ($95.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($34.b)		; 32 34 ; AND accumulator with memory (indirect) ($34.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $20.b,S		; 23 20 ; AND accumulator with stack relative $20.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $7E.b,X		; 34 7E ; Test bits $7E.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ror $0331.w,X		; 7E 31 03 ; Rotate right $0331.w,X [Reads: X Index] [Flags: NCZ]
	and ($CD.b),Y		; 31 CD ; AND accumulator with memory ($CD.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $2DCD.w		; CD CD 2D ; Compare $2DCD.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsl $347121.l		; 22 21 71 34 ; Jump to subroutine long $347121.l [Writes: Stack Pointer] [Flow: call]
	cmp $00CD.w		; CD CD 00 ; Compare $00CD.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsl $416CCF.l		; 22 CF 6C 41 ; Jump to subroutine long $416CCF.l [Writes: Stack Pointer] [Flow: call]
	ror $1321.w,X		; 7E 21 13 ; Rotate right $1321.w,X [Reads: X Index] [Flags: NCZ]
	asl $25F7.w,X		; 1E F7 25 ; Arithmetic shift left $25F7.w,X [Reads: X Index] [Flags: NCZ]
	rol $12.b		; 26 12 ; Rotate left $12.b [Reads: Direct Page] [Flags: NCZ]
	and ($CD.b,S),Y		; 33 CD ; AND accumulator (stack relative indirect indexed) ($CD.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lsr $C8.b,X		; 56 C8 ; Logical shift right $C8.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	adc $0121.w,Y		; 79 21 01 ; Add $0121.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	cmp $32CE.w		; CD CE 32 ; Compare $32CE.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsl $34A59C.l		; 22 9C A5 34 ; Jump to subroutine long $34A59C.l [Writes: Stack Pointer] [Flow: call]
	bit $30.b,X		; 34 30 ; Test bits $30.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $37CE.w		; CD CE 37 ; Compare $37CE.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsl $B03522.l		; 22 22 35 B0 ; Jump to subroutine long $B03522.l [Writes: Stack Pointer] [Flow: call]
	lda #$B0.b		; A9 B0 ; Load #$B0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $31.b,S		; 83 31 ; Store accumulator (stack relative) $31.b,S [Reads: Stack Pointer, Accumulator]
	cmp $31CD.w		; CD CD 31 ; Compare $31CD.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsl $F124CE.l		; 22 CE 24 F1 ; Jump to subroutine long $F124CE.l [Writes: Stack Pointer] [Flow: call]
	lda #$21.b		; A9 21 ; Load #$21.b into accumulator [Writes: Accumulator] [Flags: NZ]
	brk $F1.b		; 00 F1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($D6.b),Y		; 31 D6 ; AND accumulator with memory ($D6.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	and $1C.b,S		; 23 1C ; AND accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $33.b		; 00 33 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($11.b,X)		; 61 11 ; Add with carry ($11.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($39.b,X)		; 21 39 ; Logical AND ($39.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $A9.b,X		; 34 A9 ; Test bits $A9.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $10.b,X		; 34 10 ; Test bits $10.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($04.b),Y		; 31 04 ; AND accumulator with memory ($04.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $3131.w		; 1C 31 31 ; Test and reset bits $3131.w [Reads: Accumulator] [Flags: Z]
	dec $3437.w		; CE 37 34 ; Decrement $3437.w [Flags: NZ]
	bit $02.b		; 24 02 ; Test bits $02.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora ($34.b,X)		; 01 34 ; Logical OR ($34.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $B753.w		; 2D 53 B7 ; Logical AND $B753.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($12.b,X)		; 01 12 ; Logical OR ($12.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp $13D1.w		; CD D1 13 ; Compare $13D1.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp #$20.b		; C9 20 ; Compare #$20.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $30, $B7		; 30 B7 ; Branch if minus to $30, $B7 [Flow: branch]
	jmp.w [$C9B7]		; DC B7 C9 ; Jump long indirect [$C9B7] [Flow: jump]
	jsr $CD20.w		; 20 20 CD ; Jump to subroutine at $CD20.w [Writes: Stack Pointer] [Flow: call]
	cmp $56B7.w		; CD B7 56 ; Compare $56B7.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsl $DC1D21.l		; 22 21 1D DC ; Jump to subroutine long $DC1D21.l [Writes: Stack Pointer] [Flow: call]
	bit $CD.b		; 24 CD ; Test bits $CD.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	and ($32.b)		; 32 32 ; AND accumulator with memory (indirect) ($32.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $27FF.w		; CD FF 27 ; Compare $27FF.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	and [$22.b]		; 27 22 ; AND accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($A0.b,S),Y		; 33 A0 ; AND accumulator (stack relative indirect indexed) ($A0.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda ($A3.b,X)		; A1 A3 ; Load accumulator ($A3.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and ($33.b,S),Y		; 33 33 ; AND accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($CD.b)		; 32 CD ; AND accumulator with memory (indirect) ($CD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $33.b,X		; 34 33 ; Test bits $33.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $20.b,X		; 34 20 ; Test bits $20.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	jsr $C5ED.w		; 20 ED C5 ; Jump to subroutine at $C5ED.w [Writes: Stack Pointer] [Flow: call]
	rep #$C2		; C2 C2 ; Reset processor status bits #$C2 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	ora ($11.b)		; 12 11 ; OR accumulator with memory (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $9A.b,X		; 34 9A ; Test bits $9A.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	lda [$34.b]		; A7 34 ; Load accumulator (long) [$34.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $32.b		; 00 32 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$32.b]		; 27 32 ; AND accumulator with memory (long) [$32.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($33.b)		; 32 33 ; AND accumulator with memory (indirect) ($33.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($22.b)		; 32 22 ; AND accumulator with memory (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $34.b,X		; 36 34 ; Rotate left $34.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora $30.b,S		; 03 30 ; OR accumulator with stack relative $30.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	jmp $1000AF.l		; 5C AF 00 10 ; Jump long to $1000AF.l [Flow: jump]
	ror $ABA9.w,X		; 7E A9 AB ; Rotate right $ABA9.w,X [Reads: X Index] [Flags: NCZ]
	adc #$03.b		; 69 03 ; Add #$03.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	and ($6B.b,S),Y		; 33 6B ; AND accumulator (stack relative indirect indexed) ($6B.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $37.b,X		; 36 37 ; Rotate left $37.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	lda $3330.w		; AD 30 33 ; Load $3330.w into accumulator [Writes: Accumulator] [Flags: NZ]
	lda ($B4.b)		; B2 B4 ; Load accumulator (indirect) ($B4.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror $78.b,X		; 76 78 ; Rotate right $78.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	and ($33.b,S),Y		; 33 33 ; AND accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $9D.b,X		; 36 9D ; Rotate left $9D.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	adc $CE.b,X		; 75 CE ; Add $CE.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $30.b		; 02 30 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	jsr ($3634.w,X)		; FC 34 36 ; Jump to subroutine indirect indexed ($3634.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	bit $CE.b,X		; 34 CE ; Test bits $CE.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $33.b,X		; 34 33 ; Test bits $33.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $C1.b		; 00 C1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $18.b,X		; 34 18 ; Test bits $18.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	dec $2030.w		; CE 30 20 ; Decrement $2030.w [Flags: NZ]
	bit $58.b,X		; 34 58 ; Test bits $58.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	rep #$04		; C2 04 ; Reset processor status bits #$04 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and ($CE.b)		; 32 CE ; AND accumulator with memory (indirect) ($CE.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $9A.b,X		; 34 9A ; Test bits $9A.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	jsr $3420.w		; 20 20 34 ; Jump to subroutine at $3420.w [Writes: Stack Pointer] [Flow: call]
	and ($00.b)		; 32 00 ; AND accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rep #$02		; C2 02 ; Reset processor status bits #$02 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	ora ($36.b),Y		; 11 36 ; OR accumulator with memory ($36.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($33.b,S),Y		; 33 33 ; AND accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jmp $E02122.l		; 5C 22 21 E0 ; Jump long to $E02122.l [Flow: jump]
	bit $D5.b,X		; 34 D5 ; Test bits $D5.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and ($22.b)		; 32 22 ; AND accumulator with memory (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($06.b)		; 12 06 ; OR accumulator with memory (indirect) ($06.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc ($E0.b),Y		; 71 E0 ; Add with carry ($E0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $30.b		; E6 30 ; Increment $30.b [Reads: Direct Page] [Flags: NZ]
	jsl $713534.l		; 22 34 35 71 ; Jump to subroutine long $713534.l [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($C2.b,X)		; 01 C2 ; Logical OR ($C2.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	inc $06.b		; E6 06 ; Increment $06.b [Reads: Direct Page] [Flags: NZ]
	inc $32.b		; E6 32 ; Increment $32.b [Reads: Direct Page] [Flags: NZ]
	and ($7C.b)		; 32 7C ; AND accumulator with memory (indirect) ($7C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cpy $3313.w		; CC 13 33 ; Compare $3313.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpy $CACA.w		; CC CA CA ; Compare $CACA.w with Y register [Reads: Y Index] [Flags: NCZ]
	sbc ($33.b)		; F2 33 ; Subtract with carry (indirect) ($33.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $A5		; 30 A5 ; Branch if minus to $30, $A5 [Flow: branch]
	ldy $34CE.w		; AC CE 34 ; Load $34CE.w into Y register [Writes: Y Index] [Flags: NZ]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $C9.b,X		; 34 C9 ; Test bits $C9.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	dec $03D6.w		; CE D6 03 ; Decrement $03D6.w [Flags: NZ]
	and ($D5.b,S),Y		; 33 D5 ; AND accumulator (stack relative indirect indexed) ($D5.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jmp ($C93F.w)		; 6C 3F C9 ; Jump indirect to ($C93F.w) [Flow: jump]
	and ($23.b),Y		; 31 23 ; AND accumulator with memory ($23.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	cmp $E3A3.w,X		; DD A3 E3 ; Compare accumulator $E3A3.w,X [Reads: X Index] [Flags: NCZ]
	and ($30.b,S),Y		; 33 30 ; AND accumulator (stack relative indirect indexed) ($30.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx #$E293.w		; E0 93 E2 ; Compare #$E293.w with X register [Reads: X Index] [Flags: NCZ]
	sbc $33.b		; E5 33 ; Subtract $33.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and ($34.b,S),Y		; 33 34 ; AND accumulator (stack relative indirect indexed) ($34.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc #$E9.b		; E9 E9 ; Subtract #$E9.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	and ($34.b,S),Y		; 33 34 ; AND accumulator (stack relative indirect indexed) ($34.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc ($D0.b,S),Y		; F3 D0 ; Subtract with carry (stack relative indirect indexed) ($D0.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $D0, $33		; D0 33 ; Branch if not equal to $D0, $33 [Flow: branch]
	and ($F5.b,S),Y		; 33 F5 ; AND accumulator (stack relative indirect indexed) ($F5.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $F2		; F0 F2 ; Branch if equal to $F0, $F2 [Flow: branch]
	sbc ($33.b,S),Y		; F3 33 ; Subtract with carry (stack relative indirect indexed) ($33.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	and ($34.b,S),Y		; 33 34 ; AND accumulator (stack relative indirect indexed) ($34.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $03FB.w,Y		; F9 FB 03 ; Subtract with carry $03FB.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($F6.b,S),Y		; 33 F6 ; AND accumulator (stack relative indirect indexed) ($F6.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	and ($33.b,S),Y		; 33 33 ; AND accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	dec $03.b		; C6 03 ; Decrement $03.b [Reads: Direct Page] [Flags: NZ]
	and ($34.b,S),Y		; 33 34 ; AND accumulator (stack relative indirect indexed) ($34.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $06.b		; 04 06 ; Test and set bits $06.b [Reads: Accumulator] [Flags: Z]
	rol $D2.b,X		; 36 D2 ; Rotate left $D2.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	mvp $08,$03		; 44 03 08 ; Move block positive $08,$03 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora #$CA.b		; 09 CA ; Logical OR #$CA.b with accumulator [Writes: Accumulator] [Flags: NZ]
	mvp $CC,$43		; 44 43 CC ; Move block positive $CC,$43 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cmp $FA34.w		; CD 34 FA ; Compare $FA34.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	and ($00.b,S),Y		; 33 00 ; AND accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr ($E7FE.w,X)		; FC FE E7 ; Jump to subroutine indirect indexed ($E7FE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	bit $11.b,X		; 34 11 ; Test bits $11.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora ($CE.b)		; 12 CE ; OR accumulator with memory (indirect) ($CE.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $44.b,X		; 34 44 ; Test bits $44.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $30, $34		; 30 34 ; Branch if minus to $30, $34 [Flow: branch]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $CA.b		; 00 CA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	ora $3433.w,X		; 1D 33 34 ; OR accumulator with memory $3433.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($E1.b),Y		; D1 E1 ; Compare accumulator ($E1.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	nop		; EA ; No operation
	jsl $CA3430.l		; 22 30 34 CA ; Jump to subroutine long $CA3430.l [Writes: Stack Pointer] [Flow: call]
	and $34.b,S		; 23 34 ; AND accumulator with stack relative $34.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $34.b		; 24 34 ; Test bits $34.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	tsb $26.b		; 04 26 ; Test and set bits $26.b [Reads: Accumulator] [Flags: Z]
	rol $CB.b		; 26 CB ; Rotate left $CB.b [Reads: Direct Page] [Flags: NCZ]
	cmp $3344.w		; CD 44 33 ; Compare $3344.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp ($34.b)		; D2 34 ; Compare accumulator (indirect) ($34.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	inc $D0.b,X		; F6 D0 ; Increment memory $D0.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	cmp ($A9.b),Y		; D1 A9 ; Compare accumulator ($A9.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	and ($30.b,S),Y		; 33 30 ; AND accumulator (stack relative indirect indexed) ($30.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $4E.b,X		; 34 4E ; Test bits $4E.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	dec $07.b,X		; D6 07 ; Decrement memory $07.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$AD.b		; 09 AD ; Logical OR #$AD.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc ($AF.b,X)		; E1 AF ; Subtract with carry ($AF.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $000134.l,X		; 7F 34 01 00 ; Add long $000134.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $1487.w		; CE 87 14 ; Decrement $1487.w [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $30, $03		; 30 03 ; Branch if minus to $30, $03 [Flow: branch]
	sbc $F6FB.w,Y		; F9 FB F6 ; Subtract with carry $F6FB.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $3433.w		; 2C 33 34 ; Test bits $3433.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	and $34C6F6.l		; 2F F6 C6 34 ; AND accumulator with memory (long) $34C6F6.l [Writes: Accumulator] [Flags: NZ]
	and ($CE.b,S),Y		; 33 CE ; AND accumulator (stack relative indirect indexed) ($CE.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp #$C9.b		; C9 C9 ; Compare #$C9.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	and ($30.b,S),Y		; 33 30 ; AND accumulator (stack relative indirect indexed) ($30.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $E2.b		; 04 E2 ; Test and set bits $E2.b [Reads: Accumulator] [Flags: Z]
	and $35.b,X		; 35 35 ; Logical AND $35.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	nop		; EA ; No operation
	bit $43.b,X		; 34 43 ; Test bits $43.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	dec $00DC.w		; CE DC 00 ; Decrement $00DC.w [Flags: NZ]
	and ($1C.b)		; 32 1C ; AND accumulator with memory (indirect) ($1C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $40.b,X		; 34 40 ; Test bits $40.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $30, $E7		; 30 E7 ; Branch if minus to $30, $E7 [Flow: branch]
	sbc ($F8.b)		; F2 F8 ; Subtract with carry (indirect) ($F8.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($11.b)		; F2 11 ; Subtract with carry (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and ($C6.b,X)		; 21 C6 ; Logical AND ($C6.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	bit $31.b,X		; 34 31 ; Test bits $31.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and ($01.b,S),Y		; 33 01 ; AND accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	wai		; CB ; Wait for interrupt
	cpy $CACA.w		; CC CA CA ; Compare $CACA.w with Y register [Reads: Y Index] [Flags: NCZ]
	and ($33.b,S),Y		; 33 33 ; AND accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $CA.b		; 26 CA ; Rotate left $CA.b [Reads: Direct Page] [Flags: NCZ]
	dec $43D0.w		; CE D0 43 ; Decrement $43D0.w [Flags: NZ]
	and ($D0.b,S),Y		; 33 D0 ; AND accumulator (stack relative indirect indexed) ($D0.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp #$1B.b		; C9 1B ; Compare #$1B.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	rol $33.b,X		; 36 33 ; Rotate left $33.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	jsr $C934.w		; 20 34 C9 ; Jump to subroutine at $C934.w [Writes: Stack Pointer] [Flow: call]
	cmp [$C9.b]		; C7 C9 ; Compare accumulator (long) [$C9.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora $33.b,S		; 03 33 ; OR accumulator with stack relative $33.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp #$34.b		; C9 34 ; Compare #$34.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $30, $14		; 30 14 ; Branch if minus to $30, $14 [Flow: branch]
	bit $C9.b,X		; 34 C9 ; Test bits $C9.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cmp #$34.b		; C9 34 ; Compare #$34.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora $30.b,S		; 03 30 ; OR accumulator with stack relative $30.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $3F		; D0 3F ; Branch if not equal to $D0, $3F [Flow: branch]
	bit $C9.b,X		; 34 C9 ; Test bits $C9.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $03.b		; 24 03 ; Test bits $03.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cmp #$9D.b		; C9 9D ; Compare #$9D.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	and ($CD.b),Y		; 31 CD ; AND accumulator with memory ($CD.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($12.b)		; 32 12 ; AND accumulator with memory (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cmp #$9D.b		; C9 9D ; Compare #$9D.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	brk $32.b		; 00 32 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $34C9D0.l		; CF D0 C9 34 ; Compare accumulator (long) $34C9D0.l [Reads: Accumulator] [Flags: NCZ]
	and ($33.b,S),Y		; 33 33 ; AND accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp #$07.b		; C9 07 ; Compare #$07.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp $3034.w,Y		; D9 34 30 ; Compare accumulator $3034.w,Y [Reads: Y Index] [Flags: NCZ]
	brk $88.b		; 00 88 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $27.b,X		; 34 27 ; Test bits $27.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $10, $34		; 10 34 ; Branch if plus to $10, $34 [Flow: branch]
	ldx $270F.w		; AE 0F 27 ; Load $270F.w into X register [Writes: X Index] [Flags: NZ]
	brk $21.b		; 00 21 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$87.b],Y		; 17 87 ; OR accumulator with memory (long indexed) [$87.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	stx $AE.b		; 86 AE ; Store X register to $AE.b [Reads: X Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit #$27.b		; 89 27 ; Test bits #$27.b with accumulator [Reads: Accumulator] [Flags: Z]
	cmp $0144.w		; CD 44 01 ; Compare $0144.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	bit $9A.b		; 24 9A ; Test bits $9A.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	and [$C9.b]		; 27 C9 ; AND accumulator with memory (long) [$C9.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx $2734.w		; AE 34 27 ; Load $2734.w into X register [Writes: X Index] [Flags: NZ]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $10, $27		; 10 27 ; Branch if plus to $10, $27 [Flow: branch]
	cmp $342D.w		; CD 2D 34 ; Compare $342D.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora ($10.b)		; 12 10 ; OR accumulator with memory (indirect) ($10.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldx $78.b,Y		; B6 78 ; Load X register $78.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	adc [$D8.b],Y		; 77 D8 ; Add with carry (long indexed) [$D8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$01.b]		; 27 01 ; AND accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jmp ($101E.w,X)		; 7C 1E 10 ; Jump indirect indexed to ($101E.w,X) [Reads: X Index] [Flow: jump]
	ora ($F7.b,X)		; 01 F7 ; Logical OR ($F7.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	dec $9024.w		; CE 24 90 ; Decrement $9024.w [Flags: NZ]
	jsl $F16112.l		; 22 12 61 F1 ; Jump to subroutine long $F16112.l [Writes: Stack Pointer] [Flow: call]
	bit $95.b,X		; 34 95 ; Test bits $95.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	and $B5.b,X		; 35 B5 ; Logical AND $B5.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ldx $78.b,Y		; B6 78 ; Load X register $78.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $9C.b,X		; 34 9C ; Test bits $9C.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	rol $AB.b,X		; 36 AB ; Rotate left $AB.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $1548.w		; CE 48 15 ; Decrement $1548.w [Flags: NZ]
	trb $24.b		; 14 24 ; Test and reset bits $24.b [Reads: Accumulator] [Flags: Z]
	brk $49.b		; 00 49 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp $254D.w		; 4C 4D 25 ; Jump to $254D.w [Flow: jump]
	mvp $25,$43		; 44 43 25 ; Move block positive $25,$43 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	lsr $5756.w		; 4E 56 57 ; Logical shift right $5756.w [Flags: NCZ]
	bit $44.b,X		; 34 44 ; Test bits $44.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	eor $57.b,X		; 55 57 ; Exclusive OR accumulator with memory $57.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor [$44.b],Y		; 57 44 ; Exclusive OR accumulator with memory (long indexed) [$44.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	mvp $4E,$33		; 44 33 4E ; Move block positive $4E,$33 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	mvn $24,$54		; 54 54 24 ; Move block negative $24,$54 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	mvp $68,$66		; 44 66 68 ; Move block positive $68,$66 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	mvn $44,$44		; 54 44 44 ; Move block negative $44,$44 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	stz $54.b		; 64 54 ; Store zero to $54.b
	jmp ($44F2.w)		; 6C F2 44 ; Jump indirect to ($44F2.w) [Flow: jump]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	bit #$4E.b		; 89 4E ; Test bits #$4E.b with accumulator [Reads: Accumulator] [Flags: Z]
	adc $440470.l		; 6F 70 04 44 ; Add with carry (long) $440470.l [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $79		; 70 79 ; Branch if overflow set to $70, $79 [Flow: branch]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jmp $5E4444.l		; 5C 44 44 5E ; Jump long to $5E4444.l [Flow: jump]
	sbc ($4E.b)		; F2 4E ; Subtract with carry (indirect) ($4E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $40		; 70 40 ; Branch if overflow set to $70, $40 [Flow: branch]
	mvp $71,$82		; 44 82 71 ; Move block positive $71,$82 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	.db $70, $73		; 70 73 ; Branch if overflow set to $70, $73 [Flow: branch]
	mvp $6E,$44		; 44 44 6E ; Move block positive $6E,$44 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sta $449257.l		; 8F 57 92 44 ; Store accumulator (long) $449257.l [Reads: Accumulator]
	mvp $6F,$59		; 44 59 6F ; Move block positive $6F,$59 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sty $9A.b,X		; 94 9A ; Store Y register $9A.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	mvp $6E,$44		; 44 44 6E ; Move block positive $6E,$44 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sta $449C9C.l		; 8F 9C 9C 44 ; Store accumulator (long) $449C9C.l [Reads: Accumulator]
	mvp $88,$6B		; 44 6B 88 ; Move block positive $88,$6B [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cpx $44.b		; E4 44 ; Compare $44.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $42, $08		; 42 08 ; Reserved instruction
	ror $4EF0.w		; 6E F0 4E ; Rotate right $4EF0.w [Flags: NCZ]
	trb $04.b		; 14 04 ; Test and reset bits $04.b [Reads: Accumulator] [Flags: Z]
	stz $518B.w,X		; 9E 8B 51 ; Store zero to $518B.w,X [Reads: X Index]
	eor ($44.b)		; 52 44 ; Exclusive OR accumulator with memory (indirect) ($44.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	mvp $63,$A0		; 44 A0 63 ; Move block positive $63,$A0 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	adc $3178.w,X		; 7D 78 31 ; Add $3178.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $7B.b,X		; 34 7B ; Test bits $7B.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	lsr $2590.w,X		; 5E 90 25 ; Logical shift right $2590.w,X [Reads: X Index] [Flags: NCZ]
	mvp $7E,$21		; 44 21 7E ; Move block positive $7E,$21 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	bit $82.b,X		; 34 82 ; Test bits $82.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $30.b,X		; 34 30 ; Test bits $30.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	lda $70.b		; A5 70 ; Load $70.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy $44AD.w		; AC AD 44 ; Load $44AD.w into Y register [Writes: Y Index] [Flags: NZ]
	mvp $82,$AF		; 44 AF 82 ; Move block positive $82,$AF [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	lda ($AD.b),Y		; B1 AD ; Load accumulator ($AD.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $44.b,S		; 43 44 ; Exclusive OR accumulator with stack relative $44.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $B9B84E.l		; AF 4E B8 B9 ; Load long $B9B84E.l into accumulator [Writes: Accumulator] [Flags: NZ]
	mvp $9D,$44		; 44 44 9D ; Move block positive $9D,$44 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	bit $BC.b,X		; 34 BC ; Test bits $BC.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	dec $40.b,X		; D6 40 ; Decrement memory $40.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	.db $42, $F2		; 42 F2 ; Reserved instruction
	lsr $349D.w		; 4E 9D 34 ; Logical shift right $349D.w [Flags: NCZ]
	tsb $40.b		; 04 40 ; Test and set bits $40.b [Reads: Accumulator] [Flags: Z]
	lda $CD34.w,X		; BD 34 CD ; Load $CD34.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($40.b)		; F2 40 ; Subtract with carry (indirect) ($40.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jsr $BF85.w		; 20 85 BF ; Jump to subroutine at $BF85.w [Writes: Stack Pointer] [Flow: call]
	sta $44BD.w,X		; 9D BD 44 ; Store accumulator to $44BD.w,X [Reads: Accumulator, X Index]
	mvp $6E,$34		; 44 34 6E ; Move block positive $6E,$34 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cmp $6E.b,S		; C3 6E ; Compare accumulator (stack relative) $6E.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	tsb $44.b		; 04 44 ; Test and set bits $44.b [Reads: Accumulator] [Flags: Z]
	.db $F0, $34		; F0 34 ; Branch if equal to $F0, $34 [Flow: branch]
	cmp #$90.b		; C9 90 ; Compare #$90.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	bit $99.b,X		; 34 99 ; Test bits $99.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and $42.b		; 25 42 ; Logical AND $42.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($25.b,S),Y		; 33 25 ; AND accumulator (stack relative indirect indexed) ($25.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $54CD.w		; CD CD 54 ; Compare $54CD.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	and ($24.b)		; 32 24 ; AND accumulator with memory (indirect) ($24.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	mvn $F0,$C6		; 54 C6 F0 ; Move block negative $F0,$C6 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	mvp $A1,$40		; 44 40 A1 ; Move block positive $A1,$40 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sbc [$CD.b],Y		; F7 CD ; Subtract with carry (long indexed) [$CD.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	and ($24.b)		; 32 24 ; AND accumulator with memory (indirect) ($24.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	jmp ($8FC3.w,X)		; 7C C3 8F ; Jump indirect indexed to ($8FC3.w,X) [Reads: X Index] [Flow: jump]
	mvp $F0,$44		; 44 44 F0 ; Move block positive $F0,$44 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sta $8171.w,X		; 9D 71 81 ; Store accumulator to $8171.w,X [Reads: Accumulator, X Index]
	cop $44.b		; 02 44 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $70.b,S		; 83 70 ; Store accumulator (stack relative) $70.b,S [Reads: Stack Pointer, Accumulator]
	sta $44D5.w,X		; 9D D5 44 ; Store accumulator to $44D5.w,X [Reads: Accumulator, X Index]
	bit $8F.b		; 24 8F ; Test bits $8F.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	eor [$C0.b],Y		; 57 C0 ; Exclusive OR accumulator with memory (long indexed) [$C0.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $44		; F0 44 ; Branch if equal to $F0, $44 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	dec $D8.b,X		; D6 D8 ; Decrement memory $D8.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	sta $448B.w,X		; 9D 8B 44 ; Store accumulator to $448B.w,X [Reads: Accumulator, X Index]
	bit $8C.b		; 24 8C ; Test bits $8C.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	stz $9B6B.w		; 9C 6B 9B ; Store zero to $9B6B.w
	mvp $C5,$44		; 44 44 C5 ; Move block positive $C5,$44 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cmp $9DDF.w,X		; DD DF 9D ; Compare accumulator $9DDF.w,X [Reads: X Index] [Flags: NCZ]
	mvp $52,$42		; 44 42 52 ; Move block positive $52,$42 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sty $9F.b		; 84 9F ; Store Y register to $9F.b [Reads: Y Index]
	cpx $44.b		; E4 44 ; Compare $44.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	mvp $E2,$4E		; 44 4E E2 ; Move block positive $E2,$4E [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	bit $0B.b,X		; 34 0B ; Test bits $0B.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	mvp $CD,$01		; 44 01 CD ; Move block positive $CD,$01 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	bit $44.b		; 24 44 ; Test bits $44.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sbc #$F0.b		; E9 F0 ; Subtract #$F0.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	adc $40E2.w,X		; 7D E2 40 ; Add $40E2.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $9D.b,X		; 34 9D ; Test bits $9D.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $CD		; D0 CD ; Branch if not equal to $D0, $CD [Flow: branch]
	and ($22.b,X)		; 21 22 ; Logical AND ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	nop		; EA ; No operation
	cpx $A2A3.w		; EC A3 A2 ; Compare $A2A3.w with X register [Reads: X Index] [Flags: NCZ]
	mvp $0B,$44		; 44 44 0B ; Move block positive $0B,$44 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	rol $4E.b,X		; 36 4E ; Rotate left $4E.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	and ($10.b),Y		; 31 10 ; AND accumulator with memory ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor ($F3.b,X)		; 41 F3 ; Exclusive OR accumulator with memory ($F3.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $449DF5.l		; EF F5 9D 44 ; Subtract with carry (long) $449DF5.l [Writes: Accumulator] [Flags: NCVZ]
	.db $42, $D8		; 42 D8 ; Reserved instruction
	sbc ($EF.b,S),Y		; F3 EF ; Subtract with carry (stack relative indirect indexed) ($EF.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc $24.b,X		; F5 24 ; Subtract $24.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	mvp $9D,$E2		; 44 E2 9D ; Move block positive $9D,$E2 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	lda [$6F.b],Y		; B7 6F ; Load accumulator (long indexed) [$6F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $42, $44		; 42 44 ; Reserved instruction
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	.db $F0, $36		; F0 36 ; Branch if equal to $F0, $36 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	tsb $70.b		; 04 70 ; Test and set bits $70.b [Reads: Accumulator] [Flags: Z]
	cmp $FBF9.w		; CD F9 FB ; Compare $FBF9.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $42, $44		; 42 44 ; Reserved instruction
	lda ($84.b),Y		; B1 84 ; Load accumulator ($84.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	stx $9F.b		; 86 9F ; Store X register to $9F.b [Reads: X Index]
	mvp $9D,$44		; 44 44 9D ; Move block positive $9D,$44 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sbc $B1FB.w,Y		; F9 FB B1 ; Subtract with carry $B1FB.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $44.b		; 24 44 ; Test bits $44.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	.db $62, $C2, $36		; 62 C2 36 ; Push effective relative address $62, $C2, $36 [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	mvp $36,$04		; 44 04 36 ; Move block positive $36,$04 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	lsr $349D.w		; 4E 9D 34 ; Logical shift right $349D.w [Flags: NCZ]
	tsb $40.b		; 04 40 ; Test and set bits $40.b [Reads: Accumulator] [Flags: Z]
	ora $3471.w		; 0D 71 34 ; Logical OR $3471.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ldy $20.b		; A4 20 ; Load $20.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	brk $DA.b		; 00 DA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	and ($34.b),Y		; 31 34 ; AND accumulator with memory ($34.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $4F79.w		; 0D 79 4F ; Logical OR $4F79.w with accumulator [Writes: Accumulator] [Flags: NZ]
	rol $21.b,X		; 36 21 ; Rotate left $21.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $10, $36		; 10 36 ; Branch if plus to $10, $36 [Flow: branch]
	dec $CD79.w		; CE 79 CD ; Decrement $CD79.w [Flags: NZ]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $10.b		; 14 10 ; Test and reset bits $10.b [Reads: Accumulator] [Flags: Z]
	sbc $11027C.l,X		; FF 7C 02 11 ; Subtract with carry (long,X) $11027C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $0A.b		; 05 0A ; Logical OR $0A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $534E.w		; 2D 4E 53 ; Logical AND $534E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $10, $D4		; 10 D4 ; Branch if plus to $10, $D4 [Flow: branch]
	dec $AB.b		; C6 AB ; Decrement $AB.b [Reads: Direct Page] [Flags: NZ]
	tsb $0500.w		; 0C 00 05 ; Test and set bits $0500.w [Reads: Accumulator] [Flags: Z]
	ora $0C0C.w		; 0D 0C 0C ; Logical OR $0C0C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	bit $55.b,X		; 34 55 ; Test bits $55.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $50, $01		; 50 01 ; Branch if overflow clear to $50, $01 [Flow: branch]
	bit $3A.b,X		; 34 3A ; Test bits $3A.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and [$10.b],Y		; 37 10 ; AND accumulator with memory (long indexed) [$10.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $A4C6A9.l		; 22 A9 C6 A4 ; Jump to subroutine long $A4C6A9.l [Writes: Stack Pointer] [Flow: call]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $11.b		; 05 11 ; Logical OR $11.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $51CE35.l,X		; FF 35 CE 51 ; Subtract with carry (long,X) $51CE35.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $A4.b		; 02 A4 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $19.b,X		; 34 19 ; Test bits $19.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	brk $55.b		; 00 55 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $79AD.w,X		; 1D AD 79 ; OR accumulator with memory $79AD.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $01.b,X		; 55 01 ; Exclusive OR accumulator with memory $01.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	bit $31.b,X		; 34 31 ; Test bits $31.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	stz $019E.w,X		; 9E 9E 01 ; Store zero to $019E.w,X [Reads: X Index]
	and ($A5.b,S),Y		; 33 A5 ; AND accumulator (stack relative indirect indexed) ($A5.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $CD.b,X		; 34 CD ; Test bits $CD.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	dec $2000.w		; CE 00 20 ; Decrement $2000.w [Flags: NZ]
	lsr $D0ED.w		; 4E ED D0 ; Logical shift right $D0ED.w [Flags: NCZ]
	cmp $2211.w		; CD 11 22 ; Compare $2211.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsr $2084.w		; 20 84 20 ; Jump to subroutine at $2084.w [Writes: Stack Pointer] [Flow: call]
	eor ($51.b,S),Y		; 53 51 ; XOR accumulator (stack relative indirect indexed) ($51.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor ($04.b),Y		; 51 04 ; Exclusive OR accumulator with memory ($04.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $15DCF9.l		; 22 F9 DC 15 ; Jump to subroutine long $15DCF9.l [Writes: Stack Pointer] [Flow: call]
	jsl $0EDC96.l		; 22 96 DC 0E ; Jump to subroutine long $0EDC96.l [Writes: Stack Pointer] [Flow: call]
	sbc $A53232.l,X		; FF 32 32 A5 ; Subtract with carry (long,X) $A53232.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $3131.w,X		; 1D 31 31 ; OR accumulator with memory $3131.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora $00FE.w,X		; 1D FE 00 ; OR accumulator with memory $00FE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($FD.b)		; 12 FD ; OR accumulator with memory (indirect) ($FD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	and [$20.b]		; 27 20 ; AND accumulator with memory (long) [$20.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $87.b		; 05 87 ; Logical OR $87.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$EC.b		; 29 EC ; Logical AND #$EC.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc $33.b		; E6 33 ; Increment $33.b [Reads: Direct Page] [Flags: NZ]
	jsl $2AE6EC.l		; 22 EC E6 2A ; Jump to subroutine long $2AE6EC.l [Writes: Stack Pointer] [Flow: call]
	sta [$22.b]		; 87 22 ; Store accumulator (long) [$22.b] [Reads: Direct Page, Accumulator]
	eor ($E6.b,S),Y		; 53 E6 ; XOR accumulator (stack relative indirect indexed) ($E6.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cmp #$C9.b		; C9 C9 ; Compare #$C9.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$C9.b		; C9 C9 ; Compare #$C9.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	and ($33.b,S),Y		; 33 33 ; AND accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $55.b		; 00 55 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and $28.b,X		; 35 28 ; Logical AND $28.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	eor $55.b,X		; 55 55 ; Exclusive OR accumulator with memory $55.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cpx $38E6.w		; EC E6 38 ; Compare $38E6.w with X register [Reads: X Index] [Flags: NCZ]
	sec		; 38 ; Set carry flag [Flags: C]
	jsl $E53955.l		; 22 55 39 E5 ; Jump to subroutine long $E53955.l [Writes: Stack Pointer] [Flow: call]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and [$52.b],Y		; 37 52 ; AND accumulator with memory (long indexed) [$52.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $EC.b,X		; 55 EC ; Exclusive OR accumulator with memory $EC.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $253A.w		; ED 3A 25 ; Subtract $253A.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	and $E6.b		; 25 E6 ; Logical AND $E6.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $3D3C.w,Y		; 39 3C 3D ; AND accumulator with memory $3D3C.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and $55.b		; 25 55 ; Logical AND $55.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and [$33.b],Y		; 37 33 ; AND accumulator with memory (long indexed) [$33.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$ED.b		; C9 ED ; Compare #$ED.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	eor $02.b,X		; 55 02 ; Exclusive OR accumulator with memory $02.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sta [$E6.b]		; 87 E6 ; Store accumulator (long) [$E6.b] [Reads: Direct Page, Accumulator]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	eor $32.b		; 45 32 ; Exclusive OR $32.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $45.b,X		; 55 45 ; Exclusive OR accumulator with memory $45.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $4747.w,Y		; 39 47 47 ; AND accumulator with memory $4747.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $55.b,X		; 55 55 ; Exclusive OR accumulator with memory $55.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	inc $35.b		; E6 35 ; Increment $35.b [Reads: Direct Page] [Flags: NZ]
	eor ($3A.b)		; 52 3A ; Exclusive OR accumulator with memory (indirect) ($3A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $55.b		; 25 55 ; Logical AND $55.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	eor ($55.b,S),Y		; 53 55 ; XOR accumulator (stack relative indirect indexed) ($55.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lsr $55.b,X		; 56 55 ; Logical shift right $55.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	eor $32.b,X		; 55 32 ; Exclusive OR accumulator with memory $32.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $5957.w,Y		; 39 57 59 ; AND accumulator with memory $5957.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $55.b,X		; 55 55 ; Exclusive OR accumulator with memory $55.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	and ($52.b)		; 32 52 ; AND accumulator with memory (indirect) ($52.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $605555.l,X		; 5F 55 55 60 ; Exclusive OR accumulator with memory (long,X) $605555.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc ($5D.b,X)		; 61 5D ; Add with carry ($5D.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $5555.w,Y		; 39 55 55 ; AND accumulator with memory $5555.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $E5.b		; E5 E5 ; Subtract $E5.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and ($67.b)		; 32 67 ; AND accumulator with memory (indirect) ($67.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $676855.l		; 22 55 68 67 ; Jump to subroutine long $676855.l [Writes: Stack Pointer] [Flow: call]
	eor $5569.w,X		; 5D 69 55 ; Exclusive OR accumulator with memory $5569.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $37.b,X		; 55 37 ; Exclusive OR accumulator with memory $37.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	eor $55.b,X		; 55 55 ; Exclusive OR accumulator with memory $55.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor $6D.b,X		; 55 6D ; Exclusive OR accumulator with memory $6D.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc ($70.b),Y		; 71 70 ; Add with carry ($70.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and $5555.w,Y		; 39 55 55 ; AND accumulator with memory $5555.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and [$E6.b],Y		; 37 E6 ; AND accumulator with memory (long indexed) [$E6.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	inc $2A.b		; E6 2A ; Increment $2A.b [Reads: Direct Page] [Flags: NZ]
	eor ($25.b)		; 52 25 ; Exclusive OR accumulator with memory (indirect) ($25.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $4F4F4F.l		; 4F 4F 4F 4F ; Exclusive OR accumulator with memory (long) $4F4F4F.l [Writes: Accumulator] [Flags: NZ]
	eor $55.b,X		; 55 55 ; Exclusive OR accumulator with memory $55.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc ($2A.b)		; 72 2A ; Add with carry (indirect) ($2A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	bit $553A.w		; 2C 3A 55 ; Test bits $553A.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	eor $3B.b,X		; 55 3B ; Exclusive OR accumulator with memory $3B.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cpx $3A3A.w		; EC 3A 3A ; Compare $3A3A.w with X register [Reads: X Index] [Flags: NCZ]
	eor ($55.b)		; 52 55 ; Exclusive OR accumulator with memory (indirect) ($55.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	eor $553A50.l		; 4F 50 3A 55 ; Exclusive OR accumulator with memory (long) $553A50.l [Writes: Accumulator] [Flags: NZ]
	eor $17.b,X		; 55 17 ; Exclusive OR accumulator with memory $17.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor $35ED51.l		; 4F 51 ED 35 ; Exclusive OR accumulator with memory (long) $35ED51.l [Writes: Accumulator] [Flags: NZ]
	eor ($E6.b)		; 52 E6 ; Exclusive OR accumulator with memory (indirect) ($E6.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $3A29.w		; ED 29 3A ; Subtract $3A29.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	jsl $C6FE35.l		; 22 35 FE C6 ; Jump to subroutine long $C6FE35.l [Writes: Stack Pointer] [Flow: call]
	and #$5B.b		; 29 5B ; Logical AND #$5B.b with accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $C931.w		; 20 31 C9 ; Jump to subroutine at $C931.w [Writes: Stack Pointer] [Flow: call]
	cmp #$40.b		; C9 40 ; Compare #$40.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	brk $55.b		; 00 55 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $42D1.w		; EE D1 42 ; Increment $42D1.w [Flags: NZ]
	cpy $20.b		; C4 20 ; Compare $20.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	.db $50, $DC		; 50 DC ; Branch if overflow clear to $50, $DC [Flow: branch]
	rol $7F.b,X		; 36 7F ; Rotate left $7F.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $80, $05		; 80 05 ; Branch always to $80, $05 [Flow: branch]
	eor $7F.b,X		; 55 7F ; Exclusive OR accumulator with memory $7F.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $5255FE.l,X		; 7F FE 55 52 ; Add long $5255FE.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $39.b		; E6 39 ; Increment $39.b [Reads: Direct Page] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $5525.w		; 6D 25 55 ; Add $5525.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	inc $8C8D.w,X		; FE 8D 8C ; Increment memory $8C8D.w,X [Reads: X Index] [Flags: NZ]
	stx $5525.w		; 8E 25 55 ; Store X register to $5525.w [Reads: X Index]
	sta $E6FE8D.l		; 8F 8D FE E6 ; Store accumulator (long) $E6FE8D.l [Reads: Accumulator]
	eor $22.b,X		; 55 22 ; Exclusive OR accumulator with memory $22.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $6DFE.w,Y		; 39 FE 6D ; AND accumulator with memory $6DFE.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $5552.w		; 6D 52 55 ; Add $5552.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	adc $956D.w		; 6D 6D 95 ; Add $956D.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	inc $5255.w,X		; FE 55 52 ; Increment memory $5255.w,X [Reads: X Index] [Flags: NZ]
	stz $A09E.w		; 9C 9E A0 ; Store zero to $A09E.w
	adc ($55.b,S),Y		; 73 55 ; Add with carry (stack relative indirect indexed) ($55.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	eor $6D.b,X		; 55 6D ; Exclusive OR accumulator with memory $6D.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc $6D9A.w		; 6D 9A 6D ; Add $6D9A.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	eor $55.b,X		; 55 55 ; Exclusive OR accumulator with memory $55.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $6D		; 30 6D ; Branch if minus to $30, $6D [Flow: branch]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	adc $5555.w		; 6D 55 55 ; Add $5555.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	inc $2A79.w,X		; FE 79 2A ; Increment memory $2A79.w,X [Reads: X Index] [Flags: NZ]
	adc $5525.w		; 6D 25 55 ; Add $5525.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	adc $6D6D.w		; 6D 6D 6D ; Add $6D6D.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	adc $5555.w		; 6D 55 55 ; Add $5555.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	adc $3CC9.w		; 6D C9 3C ; Add $3CC9.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	lda $50.b,S		; A3 50 ; Load accumulator (stack relative) $50.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $A4.b,X		; 55 A4 ; Exclusive OR accumulator with memory $A4.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	bit $A76D.w		; 2C 6D A7 ; Test bits $A76D.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	eor $55.b,X		; 55 55 ; Exclusive OR accumulator with memory $55.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc $79A6.w		; 6D A6 79 ; Add $79A6.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	bit $55.b,X		; 34 55 ; Test bits $55.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	eor $6D.b,X		; 55 6D ; Exclusive OR accumulator with memory $6D.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $55C9C9.l,X		; 3F C9 C9 55 ; AND accumulator with memory (long,X) $55C9C9.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp #$C9.b		; C9 C9 ; Compare #$C9.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp #$50.b		; C9 50 ; Compare #$50.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	brk $E6.b		; 00 E6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $306D.w		; 6D 6D 30 ; Add $306D.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	and $55.b		; 25 55 ; Logical AND $55.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $C484.w		; 6D 84 C4 ; Add $C484.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	inc $55.b		; E6 55 ; Increment $55.b [Reads: Direct Page] [Flags: NZ]
	cop $E6.b		; 02 E6 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $C4.b		; 84 C4 ; Store Y register to $C4.b [Reads: Y Index]
	inc $25.b		; E6 25 ; Increment $25.b [Reads: Direct Page] [Flags: NZ]
	cop $3F.b		; 02 3F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp #$34.b		; C9 34 ; Compare #$34.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	eor $50.b,S		; 43 50 ; Exclusive OR accumulator with stack relative $50.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $43.b,X		; 55 43 ; Exclusive OR accumulator with memory $43.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	rol $34.b		; 26 34 ; Rotate left $34.b [Reads: Direct Page] [Flags: NCZ]
	inc $55.b		; E6 55 ; Increment $55.b [Reads: Direct Page] [Flags: NZ]
	eor ($FE.b)		; 52 FE ; Exclusive OR accumulator with memory (indirect) ($FE.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pea $E62C.w		; F4 2C E6 ; Push absolute address $E62C.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	jsl $3A3A52.l		; 22 52 3A 3A ; Jump to subroutine long $3A3A52.l [Writes: Stack Pointer] [Flow: call]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	inc $55.b		; E6 55 ; Increment $55.b [Reads: Direct Page] [Flags: NZ]
	eor ($29.b)		; 52 29 ; Exclusive OR accumulator with memory (indirect) ($29.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $34.b		; E6 34 ; Increment $34.b [Reads: Direct Page] [Flags: NZ]
	inc $32.b		; E6 32 ; Increment $32.b [Reads: Direct Page] [Flags: NZ]
	eor ($E6.b)		; 52 E6 ; Exclusive OR accumulator with memory (indirect) ($E6.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$E6.b		; 29 E6 ; Logical AND #$E6.b with accumulator [Writes: Accumulator] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	and $25.b,S		; 23 25 ; AND accumulator with stack relative $25.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpy $E6.b		; C4 E6 ; Compare $E6.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	bit $C4.b,X		; 34 C4 ; Test bits $C4.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cop $50.b		; 02 50 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $3326.w		; EC 26 33 ; Compare $3326.w with X register [Reads: X Index] [Flags: NCZ]
	and ($25.b,S),Y		; 33 25 ; AND accumulator (stack relative indirect indexed) ($25.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $E6.b,X		; 55 E6 ; Exclusive OR accumulator with memory $E6.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	inc $FE.b		; E6 FE ; Increment $FE.b [Reads: Direct Page] [Flags: NZ]
	inc $22.b		; E6 22 ; Increment $22.b [Reads: Direct Page] [Flags: NZ]
	jsl $E63829.l		; 22 29 38 E6 ; Jump to subroutine long $E63829.l [Writes: Stack Pointer] [Flow: call]
	rol $35.b,X		; 36 35 ; Rotate left $35.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	jsr $D2F6.w		; 20 F6 D2 ; Jump to subroutine at $D2F6.w [Writes: Stack Pointer] [Flow: call]
	cmp ($CE.b)		; D2 CE ; Compare accumulator (indirect) ($CE.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	and ($33.b,S),Y		; 33 33 ; AND accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp ($D0.b),Y		; D1 D0 ; Compare accumulator ($D0.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	sbc $AD.b,X		; F5 AD ; Subtract $AD.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($35.b,S),Y		; 33 35 ; AND accumulator (stack relative indirect indexed) ($35.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldx $34B0.w		; AE B0 34 ; Load $34B0.w into X register [Writes: X Index] [Flags: NZ]
	ldx $55.b,Y		; B6 55 ; Load X register $55.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	ora $B3.b		; 05 B3 ; Logical OR $B3.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $EF.b,X		; B5 EF ; Load $EF.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	inc $55.b,X		; F6 55 ; Increment memory $55.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	ora $27.b,S		; 03 27 ; OR accumulator with stack relative $27.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $42.b,X		; 34 42 ; Test bits $42.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	eor $40.b,S		; 43 40 ; Exclusive OR accumulator with stack relative $40.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	mvp $C0,$BE		; 44 BE C0 ; Move block positive $C0,$BE [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cmp ($C3.b,X)		; C1 C3 ; Compare accumulator ($C3.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	eor $55.b,X		; 55 55 ; Exclusive OR accumulator with memory $55.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	inc $C6.b,X		; F6 C6 ; Increment memory $C6.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	and ($33.b,S),Y		; 33 33 ; AND accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $34.b		; C6 34 ; Decrement $34.b [Reads: Direct Page] [Flags: NZ]
	ora $34.b,X		; 15 34 ; OR accumulator with memory $34.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $40		; 30 40 ; Branch if minus to $30, $40 [Flow: branch]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cmp $3300D1.l		; CF D1 00 33 ; Compare accumulator (long) $3300D1.l [Reads: Accumulator] [Flags: NCZ]
	cpy $ECCC.w		; CC CC EC ; Compare $ECCC.w with Y register [Reads: Y Index] [Flags: NCZ]
	sbc #$33.b		; E9 33 ; Subtract #$33.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	and ($E9.b,S),Y		; 33 E9 ; AND accumulator (stack relative indirect indexed) ($E9.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpy $C6.b		; C4 C6 ; Compare $C6.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	rol $35.b,X		; 36 35 ; Rotate left $35.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $50, $36		; 50 36 ; Branch if overflow clear to $50, $36 [Flow: branch]
	sbc ($9F.b,S),Y		; F3 9F ; Subtract with carry (stack relative indirect indexed) ($9F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	jmp ($0103.w,X)		; 7C 03 01 ; Jump indirect indexed to ($0103.w,X) [Reads: X Index] [Flow: jump]
	inc $E7EF.w		; EE EF E7 ; Increment $E7EF.w [Flags: NZ]
	sbc #$00.b		; E9 00 ; Subtract #$00.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $EA		; 30 EA ; Branch if minus to $30, $EA [Flow: branch]
	cpx $79C6.w		; EC C6 79 ; Compare $79C6.w with X register [Reads: X Index] [Flags: NCZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	cmp $F3.b,S		; C3 F3 ; Compare accumulator (stack relative) $F3.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	pea $0005.w		; F4 05 00 ; Push absolute address $0005.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	.db $F0, $B6		; F0 B6 ; Branch if equal to $F0, $B6 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $36.b		; 00 36 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $01.b,X		; 15 01 ; OR accumulator with memory $01.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	jsr $E9E9.w		; 20 E9 E9 ; Jump to subroutine at $E9E9.w [Writes: Stack Pointer] [Flow: call]
	sbc #$C6.b		; E9 C6 ; Subtract #$C6.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	and ($30.b,S),Y		; 33 30 ; AND accumulator (stack relative indirect indexed) ($30.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $1C.b		; C6 1C ; Decrement $1C.b [Reads: Direct Page] [Flags: NZ]
	and $0226.w,Y		; 39 26 02 ; AND accumulator with memory $0226.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $09		; 30 09 ; Branch if minus to $30, $09 [Flow: branch]
	rol $B6.b		; 26 B6 ; Rotate left $B6.b [Reads: Direct Page] [Flags: NCZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $B6.b		; 26 B6 ; Rotate left $B6.b [Reads: Direct Page] [Flags: NCZ]
	dec $1C.b		; C6 1C ; Decrement $1C.b [Reads: Direct Page] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $D2.b		; 45 D2 ; Exclusive OR $D2.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp ($CA.b)		; D2 CA ; Compare accumulator (indirect) ($CA.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	and ($33.b,S),Y		; 33 33 ; AND accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cmp ($CF.b)		; D2 CF ; Compare accumulator (indirect) ($CF.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp #$33.b		; C9 33 ; Compare #$33.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	and ($CE.b,S),Y		; 33 CE ; AND accumulator (stack relative indirect indexed) ($CE.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cmp #$33.b		; C9 33 ; Compare #$33.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	and ($36.b,S),Y		; 33 36 ; AND accumulator (stack relative indirect indexed) ($36.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldy $AFAE.w		; AC AE AF ; Load $AFAE.w into Y register [Writes: Y Index] [Flags: NZ]
	ora $55.b		; 05 55 ; Logical OR $55.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx $D0B1.w		; EC B1 D0 ; Compare $D0B1.w with X register [Reads: X Index] [Flags: NCZ]
	cmp ($05.b)		; D2 05 ; Compare accumulator (indirect) ($05.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	eor $F0.b,X		; 55 F0 ; Exclusive OR accumulator with memory $F0.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$36.b		; C9 36 ; Compare #$36.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	.db $F0, $BD		; F0 BD ; Branch if equal to $F0, $BD [Flow: branch]
	eor $05.b,X		; 55 05 ; Exclusive OR accumulator with memory $05.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lda $F9F0BE.l,X		; BF BE F0 F9 ; Load long $F9F0BE.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $00.b,X		; 55 00 ; Exclusive OR accumulator with memory $00.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc $36FF.w,X		; FD FF 36 ; Subtract with carry $36FF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $36.b		; 14 36 ; Test and reset bits $36.b [Reads: Accumulator] [Flags: Z]
	rol $0A.b,X		; 36 0A ; Rotate left $0A.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	ora ($31.b,X)		; 01 31 ; Logical OR ($31.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $42, $1F		; 42 1F ; Reserved instruction
	and [$14.b]		; 27 14 ; AND accumulator with memory (long) [$14.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	mvp $C9,$C9		; 44 C9 C9 ; Move block positive $C9,$C9 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	and ($33.b,S),Y		; 33 33 ; AND accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $CA.b		; C6 CA ; Decrement $CA.b [Reads: Direct Page] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	dec $33.b		; C6 33 ; Decrement $33.b [Reads: Direct Page] [Flags: NZ]
	and ($C6.b,S),Y		; 33 C6 ; AND accumulator (stack relative indirect indexed) ($C6.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	wai		; CB ; Wait for interrupt
	cmp $3333.w		; CD 33 33 ; Compare $3333.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	rol $CA.b		; 26 CA ; Rotate left $CA.b [Reads: Direct Page] [Flags: NCZ]
	rol $CA.b		; 26 CA ; Rotate left $CA.b [Reads: Direct Page] [Flags: NCZ]
	eor $43.b,S		; 43 43 ; Exclusive OR accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	rol $34.b,X		; 36 34 ; Rotate left $34.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	lda $0530.w		; AD 30 05 ; Load $0530.w into accumulator [Writes: Accumulator] [Flags: NZ]
	pei ($B0.b)		; D4 B0 ; Push effective indirect address ($B0.b) [Reads: Direct Page] [Writes: Stack Pointer]
	bit $C9.b,X		; 34 C9 ; Test bits $C9.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	eor $03.b,X		; 55 03 ; Exclusive OR accumulator with memory $03.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ldx $01C9.w		; AE C9 01 ; Load $01C9.w into X register [Writes: X Index] [Flags: NZ]
	ora $1103.w,X		; 1D 03 11 ; OR accumulator with memory $1103.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc [$B2.b]		; E7 B2 ; Subtract with carry (long) [$B2.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda ($B5.b,S),Y		; B3 B5 ; Load accumulator (stack relative indirect indexed) ($B5.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $55.b,X		; 35 55 ; Logical AND $55.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	bit $C9.b,X		; 34 C9 ; Test bits $C9.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit #$C9.b		; 89 C9 ; Test bits #$C9.b with accumulator [Reads: Accumulator] [Flags: Z]
	and ($03.b,S),Y		; 33 03 ; AND accumulator (stack relative indirect indexed) ($03.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $F6.b		; C6 F6 ; Decrement $F6.b [Reads: Direct Page] [Flags: NZ]
	cmp [$9A.b],Y		; D7 9A ; Compare accumulator (long indexed) [$9A.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	and ($50.b,S),Y		; 33 50 ; AND accumulator (stack relative indirect indexed) ($50.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp #$34.b		; C9 34 ; Compare #$34.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	cpy #$30CA.w		; C0 CA 30 ; Compare #$30CA.w with Y register [Reads: Y Index] [Flags: NCZ]
	eor ($B6.b,S),Y		; 53 B6 ; XOR accumulator (stack relative indirect indexed) ($B6.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	bit $E9.b,X		; 34 E9 ; Test bits $E9.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc #$E9.b		; E9 E9 ; Subtract #$E9.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sbc #$E1.b		; E9 E1 ; Subtract #$E1.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	and ($35.b,S),Y		; 33 35 ; AND accumulator (stack relative indirect indexed) ($35.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $E5.b,S		; E3 E5 ; Subtract stack-relative $E5.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	.db $B0, $79		; B0 79 ; Branch if carry set to $B0, $79 [Flow: branch]
	eor $00.b,X		; 55 00 ; Exclusive OR accumulator with memory $00.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	stz $26B5.w,X		; 9E B5 26 ; Store zero to $26B5.w,X [Reads: X Index]
	ldx $0000.w,Y		; BE 00 00 ; Load X register $0000.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	bit $27.b		; 24 27 ; Test bits $27.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sta $1127.w,X		; 9D 27 11 ; Store accumulator to $1127.w,X [Reads: Accumulator, X Index]
	ora ($ED.b,X)		; 01 ED ; Logical OR ($ED.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $F0, $9C		; F0 9C ; Branch if equal to $F0, $9C [Flow: branch]
	sbc ($05.b,S),Y		; F3 05 ; Subtract with carry (stack relative indirect indexed) ($05.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $F5		; 30 F5 ; Branch if minus to $30, $F5 [Flow: branch]
	pea $F52E.w		; F4 2E F5 ; Push absolute address $F52E.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $45.b		; 00 45 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $14.b,X		; 34 14 ; Test bits $14.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $23.b,X		; 34 23 ; Test bits $23.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	cpy $A3F7.w		; CC F7 A3 ; Compare $A3F7.w with Y register [Reads: Y Index] [Flags: NCZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ora $30.b		; 05 30 ; Logical OR $30.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $F6.b,X		; F5 F6 ; Subtract $F6.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $4B.b,X		; 34 4B ; Test bits $4B.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	eor $31.b,X		; 55 31 ; Exclusive OR accumulator with memory $31.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cpy $24CE.w		; CC CE 24 ; Compare $24CE.w with Y register [Reads: Y Index] [Flags: NCZ]
	bit #$02.b		; 89 02 ; Test bits #$02.b with accumulator [Reads: Accumulator] [Flags: Z]
	.db $10, $34		; 10 34 ; Branch if plus to $10, $34 [Flow: branch]
	cmp #$E0.b		; C9 E0 ; Compare #$E0.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp #$00.b		; C9 00 ; Compare #$00.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	brk $CD.b		; 00 CD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $9D.b,S		; 63 9D ; Add with carry (stack relative) $9D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	bit $21.b,X		; 34 21 ; Test bits $21.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and $A3.b,S		; 23 A3 ; AND accumulator with stack relative $A3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jmp ($26E4.w,X)		; 7C E4 26 ; Jump indirect indexed to ($26E4.w,X) [Reads: X Index] [Flow: jump]
	ora ($31.b,X)		; 01 31 ; Logical OR ($31.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta $A5A59F.l,X		; 9F 9F A5 A5 ; Store accumulator (long,X) $A5A59F.l,X [Reads: Accumulator, X Index]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $A334.w		; AC 34 A3 ; Load $A334.w into Y register [Writes: Y Index] [Flags: NZ]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $A5.b		; 00 A5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda [$34.b]		; A7 34 ; Load accumulator (long) [$34.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sep #$00		; E2 00 ; Set processor status bits #$00 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $71.b,X		; 34 71 ; Test bits $71.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	adc ($26.b),Y		; 71 26 ; Add with carry ($26.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	ldx $36.b,Y		; B6 36 ; Load X register $36.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	bit $B6.b,X		; 34 B6 ; Test bits $B6.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	rol $34.b		; 26 34 ; Rotate left $34.b [Reads: Direct Page] [Flags: NCZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx $09.b,Y		; B6 09 ; Load X register $09.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	ldx $78.b,Y		; B6 78 ; Load X register $78.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $34.b		; 26 34 ; Rotate left $34.b [Reads: Direct Page] [Flags: NCZ]
	bit $B3.b,X		; 34 B3 ; Test bits $B3.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $FBFA.w		; 6E FA FB ; Rotate right $FBFA.w [Flags: NCZ]
	sbc $5545.w,X		; FD 45 55 ; Subtract with carry $5545.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $8F7070.l		; 6F 70 70 8F ; Add with carry (long) $8F7070.l [Writes: Accumulator] [Flags: NCVZ]
	mvp $00,$44		; 44 44 00 ; Move block positive $00,$44 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora ($73.b,X)		; 01 73 ; Logical OR ($73.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor [$66.b],Y		; 57 66 ; Exclusive OR accumulator with memory (long indexed) [$66.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	mvp $6E,$57		; 44 57 6E ; Move block positive $6E,$57 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sta $464407.l		; 8F 07 44 46 ; Store accumulator (long) $464407.l [Reads: Accumulator]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	mvn $64,$84		; 54 84 64 ; Move block negative $64,$84 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	mvp $FD,$9F		; 44 9F FD ; Move block positive $FD,$9F [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	lda $4245E4.l		; AF E4 45 42 ; Load long $4245E4.l into accumulator [Writes: Accumulator] [Flags: NZ]
	bit $61.b,X		; 34 61 ; Test bits $61.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sbc $04F5.w,X		; FD F5 04 ; Subtract with carry $04F5.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $E1.b,X		; 55 E1 ; Exclusive OR accumulator with memory $E1.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	rol $36.b,X		; 36 36 ; Rotate left $36.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $C8AF.w		; AD AF C8 ; Load $C8AF.w into accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $40.b		; 04 40 ; Test and set bits $40.b [Reads: Accumulator] [Flags: Z]
	jmp ($0F6C.w)		; 6C 6C 0F ; Jump indirect to ($0F6C.w) [Flow: jump]
	ora $E46611.l		; 0F 11 66 E4 ; OR accumulator with memory (long) $E46611.l [Writes: Accumulator] [Flags: NZ]
	and $12.b		; 25 12 ; Logical AND $12.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $23.b		; 14 23 ; Test and reset bits $23.b [Reads: Accumulator] [Flags: Z]
	ror $36.b		; 66 36 ; Rotate right $36.b [Reads: Direct Page] [Flags: NCZ]
	rol $34.b,X		; 36 34 ; Rotate left $34.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ror $0300.w,X		; 7E 00 03 ; Rotate right $0300.w,X [Reads: X Index] [Flags: NCZ]
	ror $78B6.w,X		; 7E B6 78 ; Rotate right $78B6.w,X [Reads: X Index] [Flags: NCZ]
	rol $30.b		; 26 30 ; Rotate left $30.b [Reads: Direct Page] [Flags: NCZ]
	brk $B6.b		; 00 B6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $B6.b		; 26 B6 ; Rotate left $B6.b [Reads: Direct Page] [Flags: NCZ]
	ora #$00.b		; 09 00 ; Logical OR #$00.b with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
.INDEX 8
	sep #$9D		; E2 9D
	ora $44.b,X		; 15 44 ; OR accumulator with memory $44.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	rol $B3.b		; 26 B3 ; Rotate left $B3.b [Reads: Direct Page] [Flags: NCZ]
	asl $B5.b,X		; 16 B5 ; Arithmetic shift left $B5.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($46.b,X)		; 01 46 ; Logical OR ($46.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	mvp $01,$D6		; 44 D6 01 ; Move block positive $01,$D6 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $706426.l		; 6F 26 64 70 ; Add with carry (long) $706426.l [Writes: Accumulator] [Flags: NCVZ]
	sta $441CF2.l		; 8F F2 1C 44 ; Store accumulator (long) $441CF2.l [Reads: Accumulator]
	asl $90.b,X		; 16 90 ; Arithmetic shift left $90.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	rol $90.b		; 26 90 ; Rotate left $90.b [Reads: Direct Page] [Flags: NCZ]
	lsr $12.b		; 46 12 ; Logical shift right $12.b [Reads: Direct Page] [Flags: NCZ]
	.db $90, $15		; 90 15 ; Branch if carry clear to $90, $15 [Flow: branch]
	lsr $269B.w		; 4E 9B 26 ; Logical shift right $269B.w [Flags: NCZ]
	mvp $6E,$54		; 44 54 6E ; Move block positive $6E,$54 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	bit $15.b,X		; 34 15 ; Test bits $15.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	eor $06.b,S		; 43 06 ; Exclusive OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jmp $4436C3.l		; 5C C3 36 44 ; Jump long to $4436C3.l [Flow: jump]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sep #$0B		; E2 0B ; Set processor status bits #$0B [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	lsr $41E2.w		; 4E E2 41 ; Logical shift right $41E2.w [Flags: NCZ]
	trb $E2.b		; 14 E2 ; Test and reset bits $E2.b [Reads: Accumulator] [Flags: Z]
.ACCU 8
	sep #$E2		; E2 E2
	sep #$44		; E2 44 ; Set processor status bits #$44 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	mvp $E2,$E2		; 44 E2 E2 ; Move block positive $E2,$E2 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	bit $1F.b,X		; 34 1F ; Test bits $1F.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	mvp $50,$06		; 44 06 50 ; Move block positive $50,$06 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	.db $10, $6C		; 10 6C ; Branch if plus to $10, $6C [Flow: branch]
	.db $50, $16		; 50 16 ; Branch if overflow clear to $50, $16 [Flow: branch]
	ora ($D0.b),Y		; 11 D0 ; OR accumulator with memory ($D0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $CD		; 10 CD ; Branch if plus to $10, $CD [Flow: branch]
	ora ($26.b,S),Y		; 13 26 ; OR accumulator (stack relative indirect indexed) ($26.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $A2.b		; 26 A2 ; Rotate left $A2.b [Reads: Direct Page] [Flags: NCZ]
	ldy $A0.b		; A4 A0 ; Load $A0.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	sta $9F0033.l,X		; 9F 33 00 9F ; Store accumulator (long,X) $9F0033.l,X [Reads: Accumulator, X Index]
	jmp ($3437.w,X)		; 7C 37 34 ; Jump indirect indexed to ($3437.w,X) [Reads: X Index] [Flow: jump]
	ora ($32.b,X)		; 01 32 ; Logical OR ($32.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	rol $B6.b		; 26 B6 ; Rotate left $B6.b [Reads: Direct Page] [Flags: NCZ]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $36.b		; 00 36 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $370F.w,Y		; 79 0F 37 ; Add $370F.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and ($35.b),Y		; 31 35 ; AND accumulator with memory ($35.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpy $FF.b		; C4 FF ; Compare $FF.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	.db $10, $11		; 10 11 ; Branch if plus to $10, $11 [Flow: branch]
	adc $EE3B.w,Y		; 79 3B EE ; Add $EE3B.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp.w [$2015]		; DC 15 20 ; Jump long indirect [$2015] [Flow: jump]
	.db $42, $E6		; 42 E6 ; Reserved instruction
	lda [$3A.b]		; A7 3A ; Load accumulator (long) [$3A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor ($55.b)		; 52 55 ; Exclusive OR accumulator with memory (indirect) ($55.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and [$E6.b]		; 27 E6 ; AND accumulator with memory (long) [$E6.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx $523A.w		; EC 3A 52 ; Compare $523A.w with X register [Reads: X Index] [Flags: NCZ]
	and $E6.b		; 25 E6 ; Logical AND $E6.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $29.b		; E6 29 ; Increment $29.b [Reads: Direct Page] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	jsl $3AEC35.l		; 22 35 EC 3A ; Jump to subroutine long $3AEC35.l [Writes: Stack Pointer] [Flow: call]
	lda #$29.b		; A9 29 ; Load #$29.b into accumulator [Writes: Accumulator] [Flags: NZ]
	and $53.b		; 25 53 ; Logical AND $53.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $A7.b		; E6 A7 ; Increment $A7.b [Reads: Direct Page] [Flags: NZ]
	and #$E6.b		; 29 E6 ; Logical AND #$E6.b with accumulator [Writes: Accumulator] [Flags: NZ]
	and $32.b		; 25 32 ; Logical AND $32.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $29.b		; E6 29 ; Increment $29.b [Reads: Direct Page] [Flags: NZ]
	rol $23F4.w		; 2E F4 23 ; Rotate left $23F4.w [Flags: NCZ]
	eor ($2C.b)		; 52 2C ; Exclusive OR accumulator with memory (indirect) ($2C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $30, $2C		; 30 2C ; Branch if minus to $30, $2C [Flow: branch]
	rol $5555.w		; 2E 55 55 ; Rotate left $5555.w [Flags: NCZ]
	and $30F4.w		; 2D F4 30 ; Logical AND $30F4.w with accumulator [Writes: Accumulator] [Flags: NZ]
	bit $5552.w		; 2C 52 55 ; Test bits $5552.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	and #$30.b		; 29 30 ; Logical AND #$30.b with accumulator [Writes: Accumulator] [Flags: NZ]
	jmp.w [$3587]		; DC 87 35 ; Jump long indirect [$3587] [Flow: jump]
	ora $87.b,S		; 03 87 ; OR accumulator with stack relative $87.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $42, $3A		; 42 3A ; Reserved instruction
	bit $5535.w		; 2C 35 55 ; Test bits $5535.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	sbc $E3.b,S		; E3 E3 ; Subtract stack-relative $E3.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	inc $00.b		; E6 00 ; Increment $00.b [Reads: Direct Page] [Flags: NZ]
	eor ($3A.b)		; 52 3A ; Exclusive OR accumulator with memory (indirect) ($3A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $5B.b		; E6 5B ; Increment $5B.b [Reads: Direct Page] [Flags: NZ]
	rol $52.b		; 26 52 ; Rotate left $52.b [Reads: Direct Page] [Flags: NCZ]
	asl $28.b,X		; 16 28 ; Arithmetic shift left $28.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	rol $23.b		; 26 23 ; Rotate left $23.b [Reads: Direct Page] [Flags: NCZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ror $65.b		; 66 65 ; Rotate right $65.b [Reads: Direct Page] [Flags: NCZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	and [$24.b]		; 27 24 ; AND accumulator with memory (long) [$24.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($55.b)		; 32 55 ; AND accumulator with memory (indirect) ($55.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror $34.b		; 66 34 ; Rotate right $34.b [Reads: Direct Page] [Flags: NCZ]
	and ($23.b)		; 32 23 ; AND accumulator with memory (indirect) ($23.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ror $61.b		; 66 61 ; Rotate right $61.b [Reads: Direct Page] [Flags: NCZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	rol $28.b		; 26 28 ; Rotate left $28.b [Reads: Direct Page] [Flags: NCZ]
	rol $16.b		; 26 16 ; Rotate left $16.b [Reads: Direct Page] [Flags: NCZ]
	ror $23.b		; 66 23 ; Rotate right $23.b [Reads: Direct Page] [Flags: NCZ]
	bit $F4F2.w,X		; 3C F2 F4 ; Test bits $F4F2.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	adc $22.b		; 65 22 ; Add $22.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and $6A2E.w		; 2D 2E 6A ; Logical AND $6A2E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	eor $11.b,X		; 55 11 ; Exclusive OR accumulator with memory $11.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $E3.b,X		; 35 E3 ; Logical AND $E3.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sty $E3.b		; 84 E3 ; Store Y register to $E3.b [Reads: Y Index]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stx $5B.b		; 86 5B ; Store X register to $5B.b [Reads: X Index]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $11.b,X		; 34 11 ; Test bits $11.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	jsr $3434.w		; 20 34 34 ; Jump to subroutine at $3434.w [Writes: Stack Pointer] [Flow: call]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
.ACCU 16
.INDEX 16
	rep #$34		; C2 34
	rol $58.b,X		; 36 58 ; Rotate left $58.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $10, $21		; 10 21 ; Branch if plus to $10, $21 [Flow: branch]
	adc $25.b		; 65 25 ; Add $25.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	asl $34.b		; 06 34 ; Arithmetic shift left $34.b [Reads: Direct Page] [Flags: NCZ]
	ora ($10.b)		; 12 10 ; OR accumulator with memory (indirect) ($10.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	and #$6300.w		; 29 00 63 ; Logical AND #$6300.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $C9C9E6.l,X		; 3F E6 C9 C9 ; AND accumulator with memory (long,X) $C9C9E6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($00.b)		; 52 00 ; Exclusive OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$C929.w		; C9 29 C9 ; Compare #$C929.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	and #$0505.w		; 29 05 05 ; Logical AND #$0505.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $332A.w,Y		; 39 2A 33 ; AND accumulator with memory $332A.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	inc $55.b		; E6 55 ; Increment $55.b [Reads: Direct Page] [Flags: NZ]
	eor ($41.b)		; 52 41 ; Exclusive OR accumulator with memory (indirect) ($41.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $37.b,S		; 23 37 ; AND accumulator with stack relative $37.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ror $55.b		; 66 55 ; Rotate right $55.b [Reads: Direct Page] [Flags: NCZ]
	and $2AC4.w,Y		; 39 C4 2A ; AND accumulator with memory $2AC4.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $50, $55		; 50 55 ; Branch if overflow clear to $50, $55 [Flow: branch]
	bit $413D.w		; 2C 3D 41 ; Test bits $413D.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	and $55.b,S		; 23 55 ; AND accumulator with stack relative $55.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ror $E5.b		; 66 E5 ; Rotate right $E5.b [Reads: Direct Page] [Flags: NCZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	and [$34.b]		; 27 34 ; AND accumulator with memory (long) [$34.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $50.b		; 25 50 ; Logical AND $50.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and [$26.b],Y		; 37 26 ; AND accumulator with memory (long indexed) [$26.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	bit $55.b,X		; 34 55 ; Test bits $55.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $10, $65		; 10 65 ; Branch if plus to $10, $65 [Flow: branch]
	and $6A.b,S		; 23 6A ; AND accumulator with stack relative $6A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $36.b,X		; 35 36 ; Logical AND $36.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $69		; 10 69 ; Branch if plus to $10, $69 [Flow: branch]
	adc $333223.l		; 6F 23 32 33 ; Add with carry (long) $333223.l [Writes: Accumulator] [Flags: NCVZ]
	adc $6A.b		; 65 6A ; Add $6A.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and $48.b,X		; 35 48 ; Logical AND $48.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $10, $66		; 10 66 ; Branch if plus to $10, $66 [Flow: branch]
	eor #$764B.w		; 49 4B 76 ; Exclusive OR #$764B.w with accumulator [Writes: Accumulator] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	ror $30.b		; 66 30 ; Rotate right $30.b [Reads: Direct Page] [Flags: NCZ]
	and $34.b,S		; 23 34 ; AND accumulator with stack relative $34.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ror $53.b		; 66 53 ; Rotate right $53.b [Reads: Direct Page] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rol $52.b,X		; 36 52 ; Rotate left $52.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	lsr $35.b,X		; 56 35 ; Logical shift right $35.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ror $05.b		; 66 05 ; Rotate right $05.b [Reads: Direct Page] [Flags: NCZ]
	adc $34.b		; 65 34 ; Add $34.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $5C		; 70 5C ; Branch if overflow set to $70, $5C [Flow: branch]
	.db $30, $36		; 30 36 ; Branch if minus to $30, $36 [Flow: branch]
	bit $23.b,X		; 34 23 ; Test bits $23.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	eor [$E1.b],Y		; 57 E1 ; Exclusive OR accumulator with memory (long indexed) [$E1.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $52.b		; 06 52 ; Arithmetic shift left $52.b [Reads: Direct Page] [Flags: NCZ]
	adc [$76.b],Y		; 77 76 ; Add with carry (long indexed) [$76.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $365563.l		; 6F 63 55 36 ; Add with carry (long) $365563.l [Writes: Accumulator] [Flags: NCVZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	stz $2D.b		; 64 2D ; Store zero to $2D.b
	rol $5566.w		; 2E 66 55 ; Rotate left $5566.w [Flags: NCZ]
	and $2D2D2F.l		; 2F 2F 2D 2D ; AND accumulator with memory (long) $2D2D2F.l [Writes: Accumulator] [Flags: NZ]
	eor $55.b,X		; 55 55 ; Exclusive OR accumulator with memory $55.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	sbc [$66.b]		; E7 66 ; Subtract with carry (long) [$66.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $33.b,X		; 34 33 ; Test bits $33.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	rol $C2.b,X		; 36 C2 ; Rotate left $C2.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $51.b		; 05 51 ; Logical OR $51.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
.ACCU 16
.INDEX 16
	rep #$34		; C2 34
	bit $CE.b,X		; 34 CE ; Test bits $CE.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	asl $65.b		; 06 65 ; Arithmetic shift left $65.b [Reads: Direct Page] [Flags: NCZ]
	adc $C6.b		; 65 C6 ; Add $C6.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($10.b),Y		; 11 10 ; OR accumulator with memory ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	dec $02.b		; C6 02 ; Decrement $02.b [Reads: Direct Page] [Flags: NZ]
	inc $0268.w,X		; FE 68 02 ; Increment memory $0268.w,X [Reads: X Index] [Flags: NZ]
	rol $EC.b		; 26 EC ; Rotate left $EC.b [Reads: Direct Page] [Flags: NCZ]
	eor ($58.b,S),Y		; 53 58 ; XOR accumulator (stack relative indirect indexed) ($58.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $20.b,X		; 35 20 ; Logical AND $20.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $39.b,X		; 15 39 ; OR accumulator with memory $39.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and #$3038.w		; 29 38 30 ; Logical AND #$3038.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and ($08.b,S),Y		; 33 08 ; AND accumulator (stack relative indirect indexed) ($08.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	lda $110B.w		; AD 0B 11 ; Load $110B.w into accumulator [Writes: Accumulator] [Flags: NZ]
	and ($83.b),Y		; 31 83 ; AND accumulator with memory ($83.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and #$AD0A.w		; 29 0A AD ; Logical AND #$AD0A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($13.b,S),Y		; 13 13 ; OR accumulator (stack relative indirect indexed) ($13.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $0A38.w		; 6D 38 0A ; Add $0A38.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	ldx $1043.w,Y		; BE 43 10 ; Load X register $1043.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	.db $42, $8B		; 42 8B ; Reserved instruction
	sbc ($AD.b)		; F2 AD ; Subtract with carry (indirect) ($AD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	eor ($03.b,S),Y		; 53 03 ; XOR accumulator (stack relative indirect indexed) ($03.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $9D.b,X		; 34 9D ; Test bits $9D.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sbc ($0B.b)		; F2 0B ; Subtract with carry (indirect) ($0B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora ($31.b),Y		; 11 31 ; OR accumulator with memory ($31.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $38.b,X		; 34 38 ; Test bits $38.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $08.b,X		; 34 08 ; Test bits $08.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and ($31.b,S),Y		; 33 31 ; AND accumulator (stack relative indirect indexed) ($31.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	bit $9D.b,X		; 34 9D ; Test bits $9D.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sbc ($10.b),Y		; F1 10 ; Subtract with carry ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr $388B.w		; 20 8B 38 ; Jump to subroutine at $388B.w [Writes: Stack Pointer] [Flow: call]
	sec		; 38 ; Set carry flag [Flags: C]
	bit $33.b,X		; 34 33 ; Test bits $33.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $30, $0B		; 30 0B ; Branch if minus to $30, $0B [Flow: branch]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	bit $35.b,X		; 34 35 ; Test bits $35.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora ($03.b),Y		; 11 03 ; OR accumulator with memory ($03.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	rol $36.b,X		; 36 36 ; Rotate left $36.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	inc $00.b,X		; F6 00 ; Increment memory $00.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	ora $F6.b		; 05 F6 ; Logical OR $F6.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	bit $37.b,X		; 34 37 ; Test bits $37.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	eor ($03.b),Y		; 51 03 ; Exclusive OR accumulator with memory ($03.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $FC.b,X		; 34 FC ; Test bits $FC.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	inc $03FE.w,X		; FE FE 03 ; Increment memory $03FE.w,X [Reads: X Index] [Flags: NZ]
	and ($FE.b,S),Y		; 33 FE ; AND accumulator (stack relative indirect indexed) ($FE.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $02.b,X		; 36 02 ; Rotate left $02.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tsb $30.b		; 04 30 ; Test and set bits $30.b [Reads: Accumulator] [Flags: Z]
	mvp $54,$04		; 44 04 54 ; Move block positive $54,$04 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	stx $36.b		; 86 36 ; Store X register to $36.b [Reads: X Index]
	.db $42, $10		; 42 10 ; Reserved instruction
	sbc $35FB.w,Y		; F9 FB 35 ; Subtract with carry $35FB.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $00.b		; C6 00 ; Decrement $00.b [Reads: Direct Page] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	jmp ($6C6C.w)		; 6C 6C 6C ; Jump indirect to ($6C6C.w) [Flow: jump]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jmp ($716C.w)		; 6C 6C 71 ; Jump indirect to ($716C.w) [Flow: jump]
.INDEX 16
	rep #$11		; C2 11
	ora ($C2.b),Y		; 11 C2 ; OR accumulator with memory ($C2.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $C6.b		; 65 C6 ; Add $C6.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	dec $11.b		; C6 11 ; Decrement $11.b [Reads: Direct Page] [Flags: NZ]
	brk $A3.b		; 00 A3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $AD.b,X		; 34 AD ; Test bits $AD.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $AC.b		; 00 AC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($4F.b),Y		; F1 4F ; Subtract with carry ($4F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$20.b],Y		; F7 20 ; Subtract with carry (long indexed) [$20.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $F9.b,S		; 03 F9 ; OR accumulator with stack relative $F9.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	cpx $3334.w		; EC 34 33 ; Compare $3334.w with X register [Reads: X Index] [Flags: NCZ]
	brk $74.b		; 00 74 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $C9.b,X		; 34 C9 ; Test bits $C9.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cmp #$0020.w		; C9 20 00 ; Compare #$0020.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp #$730A.w		; C9 0A 73 ; Compare #$730A.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tsb $64.b		; 04 64 ; Test and set bits $64.b [Reads: Accumulator] [Flags: Z]
	.db $F0, $77		; F0 77 ; Branch if equal to $F0, $77 [Flow: branch]
	sbc $1002B0.l,X		; FF B0 02 10 ; Subtract with carry (long,X) $1002B0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $14.b,X		; 15 14 ; OR accumulator with memory $14.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	rol $14.b,X		; 36 14 ; Rotate left $14.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$6C.b]		; E7 6C ; Subtract with carry (long) [$6C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ldy $11F1.w		; AC F1 11 ; Load $11F1.w into Y register [Writes: Y Index] [Flags: NZ]
	brk $C9.b		; 00 C9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $C9.b		; 85 C9 ; Store accumulator to $C9.b [Reads: Accumulator]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $7E.b,X		; 34 7E ; Test bits $7E.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ror $03B0.w,X		; 7E B0 03 ; Rotate right $03B0.w,X [Reads: X Index] [Flags: NCZ]
	.db $30, $6D		; 30 6D ; Branch if minus to $30, $6D [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $13FB.w,Y		; F9 FB 13 ; Subtract with carry $13FB.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($F1.b,S),Y		; 33 F1 ; AND accumulator (stack relative indirect indexed) ($F1.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $34.b,X		; 36 34 ; Rotate left $34.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	inc $0300.w,X		; FE 00 03 ; Increment memory $0300.w,X [Reads: X Index] [Flags: NZ]
	ror $F0.b,X		; 76 F0 ; Rotate right $F0.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	rol $36.b,X		; 36 36 ; Rotate left $36.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $30, $34		; 30 34 ; Branch if minus to $30, $34 [Flow: branch]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	jmp ($006C.w)		; 6C 6C 00 ; Jump indirect to ($006C.w) [Flow: jump]
	ora ($81.b),Y		; 11 81 ; OR accumulator with memory ($81.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jmp ($FDFB.w)		; 6C FB FD ; Jump indirect to ($FDFB.w) [Flow: jump]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $343473.l,X		; FF 73 34 34 ; Subtract with carry (long,X) $343473.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $07.b,X		; 34 07 ; Test bits $07.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	lda $1C.b		; A5 1C ; Load $1C.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($12.b,X)		; 01 12 ; Logical OR ($12.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	cmp $37.b,X		; D5 37 ; Compare accumulator $37.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	pei ($20.b)		; D4 20 ; Push effective indirect address ($20.b) [Reads: Direct Page] [Writes: Stack Pointer]
	adc $5620.w,X		; 7D 20 56 ; Add $5620.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $C47A.w,X		; 7E 7A C4 ; Rotate right $C47A.w,X [Reads: X Index] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ror $10.b		; 66 10 ; Rotate right $10.b [Reads: Direct Page] [Flags: NCZ]
	sta ($80.b,X)		; 81 80 ; Store accumulator ($80.b,X) [Reads: Direct Page, Accumulator, X Index]
	bit $20.b,X		; 34 20 ; Test bits $20.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ror $05.b		; 66 05 ; Rotate right $05.b [Reads: Direct Page] [Flags: NCZ]
	bit #$85BC.w		; 89 BC 85 ; Test bits #$85BC.w with accumulator [Reads: Accumulator] [Flags: Z]
	inc $6162.w,X		; FE 62 61 ; Increment memory $6162.w,X [Reads: X Index] [Flags: NZ]
	dec $9F.b		; C6 9F ; Decrement $9F.b [Reads: Direct Page] [Flags: NZ]
	sta $00009F.l,X		; 9F 9F 00 00 ; Store accumulator (long,X) $00009F.l,X [Reads: Accumulator, X Index]
	sta $619F9F.l,X		; 9F 9F 9F 61 ; Store accumulator (long,X) $619F9F.l,X [Reads: Accumulator, X Index]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $358E.w,Y		; 39 8E 35 ; AND accumulator with memory $358E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $06.b,X		; 16 06 ; Arithmetic shift left $06.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	bit $7C.b,X		; 34 7C ; Test bits $7C.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $06.b,X		; 34 06 ; Test bits $06.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stx $34.b		; 86 34 ; Store X register to $34.b [Reads: X Index]
	sta [$96.b]		; 87 96 ; Store accumulator (long) [$96.b] [Reads: Direct Page, Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ror $98.b		; 66 98 ; Rotate right $98.b [Reads: Direct Page] [Flags: NCZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	and $216656.l,X		; 3F 56 66 21 ; AND accumulator with memory (long,X) $216656.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	stx $98.b,Y		; 96 98 ; Store X register $98.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	lsr $66.b,X		; 56 66 ; Logical shift right $66.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	adc ($F9.b,X)		; 61 F9 ; Add with carry ($F9.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $A09B.w		; CD 9B A0 ; Compare $A09B.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsl $D9CD66.l		; 22 66 CD D9 ; Jump to subroutine long $D9CD66.l [Writes: Stack Pointer] [Flow: call]
	ldy #$22D2.w		; A0 D2 22 ; Load #$22D2.w into Y register [Writes: Y Index] [Flags: NZ]
	.db $62, $DD, $96		; 62 DD 96 ; Push effective relative address $62, $DD, $96 [Writes: Stack Pointer]
	and [$28.b]		; 27 28 ; AND accumulator with memory (long) [$28.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $33.b		; 26 33 ; Rotate left $33.b [Reads: Direct Page] [Flags: NCZ]
	inc $F6.b,X		; F6 F6 ; Increment memory $F6.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	dec $9E.b,X		; D6 9E ; Decrement memory $9E.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	jsl $7C9F20.l		; 22 20 9F 7C ; Jump to subroutine long $7C9F20.l [Writes: Stack Pointer] [Flow: call]
	ora $011E.w,X		; 1D 1E 01 ; OR accumulator with memory $011E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($C6.b),Y		; 11 C6 ; OR accumulator with memory ($C6.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ldy $A7.b		; A4 A7 ; Load $A7.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $7CC6.w		; AD C6 7C ; Load $7CC6.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp $00.b,X		; D5 00 ; Compare accumulator $00.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($AA.b),Y		; 11 AA ; OR accumulator with memory ($AA.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ldy $85AD.w		; AC AD 85 ; Load $85AD.w into Y register [Writes: Y Index] [Flags: NZ]
	ror $63.b		; 66 63 ; Rotate right $63.b [Reads: Direct Page] [Flags: NCZ]
	ror $79.b		; 66 79 ; Rotate right $79.b [Reads: Direct Page] [Flags: NCZ]
	adc $C6.b		; 65 C6 ; Add $C6.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($10.b),Y		; 11 10 ; OR accumulator with memory ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	dec $AE.b		; C6 AE ; Decrement $AE.b [Reads: Direct Page] [Flags: NZ]
	ldx $06D1.w		; AE D1 06 ; Load $06D1.w into X register [Writes: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cmp ($83.b),Y		; D1 83 ; Compare accumulator ($83.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	lda $620157.l		; AF 57 01 62 ; Load long $620157.l into accumulator [Writes: Accumulator] [Flags: NZ]
	ldx $83AE.w		; AE AE 83 ; Load $83AE.w into X register [Writes: X Index] [Flags: NZ]
	lda $66.b,X		; B5 66 ; Load $66.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	asl $E0.b,X		; 16 E0 ; Arithmetic shift left $E0.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cmp #$CCC9.w		; C9 C9 CC ; Compare #$CCC9.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stx $0F.b		; 86 0F ; Store X register to $0F.b [Reads: X Index]
	bit $A3.b,X		; 34 A3 ; Test bits $A3.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora ($00.b)		; 12 00 ; OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldx $5778.w		; AE 78 57 ; Load $5778.w into X register [Writes: X Index] [Flags: NZ]
	inc $61.b		; E6 61 ; Increment $61.b [Reads: Direct Page] [Flags: NZ]
	and ($B7.b,X)		; 21 B7 ; Logical AND ($B7.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $5E5D.w,X		; 1E 5D 5E ; Arithmetic shift left $5E5D.w,X [Reads: X Index] [Flags: NCZ]
	.db $62, $11, $60		; 62 11 60 ; Push effective relative address $62, $11, $60 [Writes: Stack Pointer]
	ldx $AE20.w		; AE 20 AE ; Load $AE20.w into X register [Writes: X Index] [Flags: NZ]
	asl $26.b,X		; 16 26 ; Arithmetic shift left $26.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	lda $FF20.w,X		; BD 20 FF ; Load $FF20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ror $21.b		; 66 21 ; Rotate right $21.b [Reads: Direct Page] [Flags: NCZ]
	.db $62, $BF, $C1		; 62 BF C1 ; Push effective relative address $62, $BF, $C1 [Writes: Stack Pointer]
	ror $16.b		; 66 16 ; Rotate right $16.b [Reads: Direct Page] [Flags: NCZ]
	adc ($A9.b,X)		; 61 A9 ; Add with carry ($A9.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	wai		; CB ; Wait for interrupt
	cmp $0620.w		; CD 20 06 ; Compare $0620.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $62, $D5, $CF		; 62 D5 CF ; Push effective relative address $62, $D5, $CF [Writes: Stack Pointer]
	cmp ($1C.b),Y		; D1 1C ; Compare accumulator ($1C.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	asl $62.b		; 06 62 ; Arithmetic shift left $62.b [Reads: Direct Page] [Flags: NCZ]
	ldx $C8D4.w		; AE D4 C8 ; Load $C8D4.w into X register [Writes: X Index] [Flags: NZ]
	cmp $570666.l,X		; DF 66 06 57 ; Compare accumulator (long,X) $570666.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	ror $C9E0.w,X		; 7E E0 C9 ; Rotate right $C9E0.w,X [Reads: X Index] [Flags: NCZ]
	and ($60.b,X)		; 21 60 ; Logical AND ($60.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp $C8D153.l,X		; DF 53 D1 C8 ; Compare accumulator (long,X) $C8D153.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	adc ($00.b,X)		; 61 00 ; Add with carry ($00.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp #$E4B4.w		; C9 B4 E4 ; Compare #$E4B4.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ldx $6606.w		; AE 06 66 ; Load $6606.w into X register [Writes: X Index] [Flags: NZ]
	ldx $DF7E.w		; AE 7E DF ; Load $DF7E.w into X register [Writes: X Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	adc ($60.b,X)		; 61 60 ; Add with carry ($60.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta [$E7.b]		; 87 E7 ; Store accumulator (long) [$E7.b] [Reads: Direct Page, Accumulator]
	ldx $36E7.w		; AE E7 36 ; Load $36E7.w into X register [Writes: X Index] [Flags: NZ]
	ror $E7.b		; 66 E7 ; Rotate right $E7.b [Reads: Direct Page] [Flags: NCZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sbc $66E7.w		; ED E7 66 ; Subtract $66E7.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ror $E7.b		; 66 E7 ; Rotate right $E7.b [Reads: Direct Page] [Flags: NCZ]
	sbc [$F0.b]		; E7 F0 ; Subtract with carry (long) [$F0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	ror $60.b		; 66 60 ; Rotate right $60.b [Reads: Direct Page] [Flags: NCZ]
	ror $FCFB.w,X		; 7E FB FC ; Rotate right $FCFB.w,X [Reads: X Index] [Flags: NCZ]
	sbc $6616.w,X		; FD 16 66 ; Subtract with carry $6616.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F8E7FC.l,X		; FF FC E7 F8 ; Subtract with carry (long,X) $F8E7FC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $66.b		; 66 66 ; Rotate right $66.b [Reads: Direct Page] [Flags: NCZ]
	ror $1CD1.w,X		; 7E D1 1C ; Rotate right $1CD1.w,X [Reads: X Index] [Flags: NCZ]
	sbc [$10.b]		; E7 10 ; Subtract with carry (long) [$10.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	rol $02.b		; 26 02 ; Rotate left $02.b [Reads: Direct Page] [Flags: NCZ]
	ora $F8.b,S		; 03 F8 ; OR accumulator with stack relative $F8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ror $6177.w,X		; 7E 77 61 ; Rotate right $6177.w,X [Reads: X Index] [Flags: NCZ]
	ror $1E.b		; 66 1E ; Rotate right $1E.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc [$12.b]		; E7 12 ; Subtract with carry (long) [$12.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ror $06.b,X		; 76 06 ; Rotate right $06.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora #$AEEE.w		; 09 EE AE ; Logical OR #$AEEE.w with accumulator [Writes: Accumulator] [Flags: NZ]
	adc [$16.b],Y		; 77 16 ; Add with carry (long indexed) [$16.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $E6.b		; 66 E6 ; Rotate right $E6.b [Reads: Direct Page] [Flags: NCZ]
	ora $16E7.w		; 0D E7 16 ; Logical OR $16E7.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ror $AE.b,X		; 76 AE ; Rotate right $AE.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	trb $AEE6.w		; 1C E6 AE ; Test and reset bits $AEE6.w [Reads: Accumulator] [Flags: Z]
	.db $62, $66, $1C		; 62 66 1C ; Push effective relative address $62, $66, $1C [Writes: Stack Pointer]
	ldx $141C.w		; AE 1C 14 ; Load $141C.w into X register [Writes: X Index] [Flags: NZ]
	rol $27.b		; 26 27 ; Rotate left $27.b [Reads: Direct Page] [Flags: NCZ]
	trb $1615.w		; 1C 15 16 ; Test and reset bits $1615.w [Reads: Accumulator] [Flags: Z]
	ora [$27.b],Y		; 17 27 ; OR accumulator with memory (long indexed) [$27.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc [$18.b],Y		; 77 18 ; Add with carry (long indexed) [$18.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $E7.b,X		; 16 E7 ; Arithmetic shift left $E7.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ldx $6677.w		; AE 77 66 ; Load $6677.w into X register [Writes: X Index] [Flags: NZ]
	cmp ($83.b)		; D2 83 ; Compare accumulator (indirect) ($83.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp ($7C.b)		; D2 7C ; Compare accumulator (indirect) ($7C.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	trb $C8E9.w		; 1C E9 C8 ; Test and reset bits $C8E9.w [Reads: Accumulator] [Flags: Z]
	cop $60.b		; 02 60 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $C59E.w,Y		; 79 9E C5 ; Add $C59E.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp ($10.b,S),Y		; D3 10 ; Compare accumulator (stack relative indirect indexed) ($10.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	brk $AE.b		; 00 AE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx $FEE5.w		; AE E5 FE ; Load $FEE5.w into X register [Writes: X Index] [Flags: NZ]
	ror $12.b		; 66 12 ; Rotate right $12.b [Reads: Direct Page] [Flags: NCZ]
	ldx $6506.w		; AE 06 65 ; Load $6506.w into X register [Writes: X Index] [Flags: NZ]
	adc $61.b		; 65 61 ; Add $61.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($AE.b),Y		; 11 AE ; OR accumulator with memory ($AE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $E7.b,S		; 83 E7 ; Store accumulator (stack relative) $E7.b,S [Reads: Stack Pointer, Accumulator]
	sbc [$61.b]		; E7 61 ; Subtract with carry (long) [$61.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ror $AE.b		; 66 AE ; Rotate right $AE.b [Reads: Direct Page] [Flags: NCZ]
	sbc #$3FE7.w		; E9 E7 3F ; Subtract #$3FE7.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ror $65.b		; 66 65 ; Rotate right $65.b [Reads: Direct Page] [Flags: NCZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cmp ($D1.b),Y		; D1 D1 ; Compare accumulator ($D1.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	cmp ($D2.b),Y		; D1 D2 ; Compare accumulator ($D2.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	sta $7E.b		; 85 7E ; Store accumulator to $7E.b [Reads: Accumulator]
	brk $31.b		; 00 31 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$C8.b]		; 27 C8 ; AND accumulator with memory (long) [$C8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp ($DC.b),Y		; D1 DC ; Compare accumulator ($DC.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	cmp $E7C8.w,X		; DD C8 E7 ; Compare accumulator $E7C8.w,X [Reads: X Index] [Flags: NCZ]
	ora $6700.w,X		; 1D 00 67 ; OR accumulator with memory $6700.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta [$89.b]		; 87 89 ; Store accumulator (long) [$89.b] [Reads: Direct Page, Accumulator]
	sbc [$1C.b]		; E7 1C ; Subtract with carry (long) [$1C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and ($67.b,S),Y		; 33 67 ; AND accumulator (stack relative indirect indexed) ($67.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $C5D3.w		; 2E D3 C5 ; Rotate left $C5D3.w [Flags: NCZ]
	sbc [$70.b]		; E7 70 ; Subtract with carry (long) [$70.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	asl $AE.b		; 06 AE ; Arithmetic shift left $AE.b [Reads: Direct Page] [Flags: NCZ]
	nop		; EA ; No operation
	nop		; EA ; No operation
	ora $66.b,S		; 03 66 ; OR accumulator with stack relative $66.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $E7.b,S		; 63 E7 ; Add with carry (stack relative) $E7.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cmp $E7.b		; C5 E7 ; Compare $E7.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp [$60.b],Y		; D7 60 ; Compare accumulator (long indexed) [$60.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ldx $19D5.w,Y		; BE D5 19 ; Load X register $19D5.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $70, $F8		; 70 F8 ; Branch if overflow set to $70, $F8 [Flow: branch]
	.db $10, $C6		; 10 C6 ; Branch if plus to $10, $C6 [Flow: branch]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	bit $36.b,X		; 34 36 ; Test bits $36.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cpy $C6.b		; C4 C6 ; Compare $C6.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $9FA39F.l,X		; 9F 9F A3 9F ; Store accumulator (long,X) $9FA39F.l,X [Reads: Accumulator, X Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($669F.w,X)		; 7C 9F 66 ; Jump indirect indexed to ($669F.w,X) [Reads: X Index] [Flow: jump]
	adc [$10.b]		; 67 10 ; Add with carry (long) [$10.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($34.b),Y		; 11 34 ; OR accumulator with memory ($34.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $17.b,X		; 34 17 ; Test bits $17.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $A5A5.w		; 20 A5 A5 ; Jump to subroutine at $A5A5.w [Writes: Stack Pointer] [Flow: call]
	dec $86.b		; C6 86 ; Decrement $86.b [Reads: Direct Page] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $0C.b,S		; 83 0C ; Store accumulator (stack relative) $0C.b,S [Reads: Stack Pointer, Accumulator]
	sbc ($06.b,X)		; E1 06 ; Subtract with carry ($06.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($23.b,S),Y		; 13 23 ; OR accumulator (stack relative indirect indexed) ($23.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	and $83.b,X		; 35 83 ; Logical AND $83.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $10, $13		; 10 13 ; Branch if plus to $10, $13 [Flow: branch]
	.db $42, $2A		; 42 2A ; Reserved instruction
	inc $06.b		; E6 06 ; Increment $06.b [Reads: Direct Page] [Flags: NZ]
	eor [$23.b],Y		; 57 23 ; Exclusive OR accumulator with memory (long indexed) [$23.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
.ACCU 16
	rep #$29		; C2 29
	ora [$06.b],Y		; 17 06 ; OR accumulator with memory (long indexed) [$06.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($31.b,S),Y		; 13 31 ; OR accumulator (stack relative indirect indexed) ($31.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and #$C606.w		; 29 06 C6 ; Logical AND #$C606.w with accumulator [Writes: Accumulator] [Flags: NZ]
	inc $31.b		; E6 31 ; Increment $31.b [Reads: Direct Page] [Flags: NZ]
	cop $17.b		; 02 17 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($20.b),Y		; 71 20 ; Add with carry ($20.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora #$3131.w		; 09 31 31 ; Logical OR #$3131.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lda $7130.w		; AD 30 71 ; Load $7130.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	adc [$11.b]		; 67 11 ; Add with carry (long) [$11.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ldy $6565.w		; AC 65 65 ; Load $6565.w into Y register [Writes: Y Index] [Flags: NZ]
	adc $61.b		; 65 61 ; Add $61.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($65.b),Y		; 11 65 ; OR accumulator with memory ($65.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	.db $30, $71		; 30 71 ; Branch if minus to $30, $71 [Flow: branch]
	ora ($71.b),Y		; 11 71 ; OR accumulator with memory ($71.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $C6.b		; 25 C6 ; Logical AND $C6.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $C5.b,X		; D5 C5 ; Compare accumulator $C5.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	jsr $2000.w		; 20 00 20 ; Jump to subroutine at $2000.w [Writes: Stack Pointer] [Flow: call]
	dec $AA.b		; C6 AA ; Decrement $AA.b [Reads: Direct Page] [Flags: NZ]
	jsr $0520.w		; 20 20 05 ; Jump to subroutine at $0520.w [Writes: Stack Pointer] [Flow: call]
	cmp $DCDC34.l,X		; DF 34 DC DC ; Compare accumulator (long,X) $DCDC34.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpy $7978.w		; CC 78 79 ; Compare $7978.w with Y register [Reads: Y Index] [Flags: NCZ]
	bit $01.b,X		; 34 01 ; Test bits $01.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $10, $AC		; 10 AC ; Branch if plus to $10, $AC [Flow: branch]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cpy $0000.w		; CC 00 00 ; Compare $0000.w with Y register [Reads: Y Index] [Flags: NCZ]
	ror $34E1.w,X		; 7E E1 34 ; Rotate right $34E1.w,X [Reads: X Index] [Flags: NCZ]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $10, $03		; 10 03 ; Branch if plus to $10, $03 [Flow: branch]
	bit $50.b,X		; 34 50 ; Test bits $50.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	jsr $016C.w		; 20 6C 01 ; Jump to subroutine at $016C.w [Writes: Stack Pointer] [Flow: call]
	eor ($80.b),Y		; 51 80 ; Exclusive OR accumulator with memory ($80.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jmp ($1C50.w)		; 6C 50 1C ; Jump indirect to ($1C50.w) [Flow: jump]
	ora ($12.b),Y		; 11 12 ; OR accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $403E.w,X		; 3C 3E 40 ; Test bits $403E.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	.db $F0, $77		; F0 77 ; Branch if equal to $F0, $77 [Flow: branch]
	.db $70, $33		; 70 33 ; Branch if overflow set to $70, $33 [Flow: branch]
	sbc [$56.b]		; E7 56 ; Subtract with carry (long) [$56.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sty $31.b,X		; 94 31 ; Store Y register $31.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	ora ($56.b,S),Y		; 13 56 ; OR accumulator (stack relative indirect indexed) ($56.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp [$1C.b]		; C7 1C ; Compare accumulator (long) [$1C.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sbc ($12.b),Y		; F1 12 ; Subtract with carry ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and $49.b		; 25 49 ; Logical AND $49.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	sbc $0177E7.l,X		; FF E7 77 01 ; Subtract with carry (long,X) $0177E7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $D0, $CD		; D0 CD ; Branch if not equal to $D0, $CD [Flow: branch]
	cmp $22CD.w		; CD CD 22 ; Compare $22CD.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsl $34DFCD.l		; 22 CD DF 34 ; Jump to subroutine long $34DFCD.l [Writes: Stack Pointer] [Flow: call]
	bit $22.b,X		; 34 22 ; Test bits $22.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $F6D6.w,Y		; D9 D6 F6 ; Compare accumulator $F6D6.w,Y [Reads: Y Index] [Flags: NCZ]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($67.b),Y		; 71 67 ; Add with carry ($67.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $ED.b,X		; 34 ED ; Test bits $ED.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora ($01.b),Y		; 11 01 ; OR accumulator with memory ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp [$FF.b]		; C7 FF ; Compare accumulator (long) [$FF.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ldy $2267.w		; AC 67 22 ; Load $2267.w into Y register [Writes: Y Index] [Flags: NZ]
	adc ($54.b,X)		; 61 54 ; Add with carry ($54.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $22ECE0.l,X		; FF E0 EC 22 ; Subtract with carry (long,X) $22ECE0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $F70CED.l		; 22 ED 0C F7 ; Jump to subroutine long $F70CED.l [Writes: Stack Pointer] [Flow: call]
	jsr $2223.w		; 20 23 22 ; Jump to subroutine at $2223.w [Writes: Stack Pointer] [Flow: call]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and [$DF.b]		; 27 DF ; AND accumulator with memory (long) [$DF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $E52211.l		; EF 11 22 E5 ; Subtract with carry (long) $E52211.l [Writes: Accumulator] [Flags: NCVZ]
	sbc $5731.w		; ED 31 57 ; Subtract $5731.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	jsl $1EFA12.l		; 22 12 FA 1E ; Jump to subroutine long $1EFA12.l [Writes: Stack Pointer] [Flow: call]
	cmp $11C8.w		; CD C8 11 ; Compare $11C8.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsr $D0F4.w		; 20 F4 D0 ; Jump to subroutine at $D0F4.w [Writes: Stack Pointer] [Flow: call]
	ror $2234.w,X		; 7E 34 22 ; Rotate right $2234.w,X [Reads: X Index] [Flags: NCZ]
	.db $10, $21		; 10 21 ; Branch if plus to $10, $21 [Flow: branch]
	cmp #$D7C9.w		; C9 C9 D7 ; Compare #$D7C9.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsr $CD02.w		; 20 02 CD ; Jump to subroutine at $CD02.w [Writes: Stack Pointer] [Flow: call]
	inc $C7ED.w		; EE ED C7 ; Increment $C7ED.w [Flags: NZ]
	and ($12.b,X)		; 21 12 ; Logical AND ($12.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp [$C7.b]		; C7 C7 ; Compare accumulator (long) [$C7.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp [$C7.b]		; C7 C7 ; Compare accumulator (long) [$C7.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	jsl $CECD22.l		; 22 22 CD CE ; Jump to subroutine long $CECD22.l [Writes: Stack Pointer] [Flow: call]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	trb $0220.w		; 1C 20 02 ; Test and reset bits $0220.w [Reads: Accumulator] [Flags: Z]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	eor ($D0.b,S),Y		; 53 D0 ; XOR accumulator (stack relative indirect indexed) ($D0.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpy $0001.w		; CC 01 00 ; Compare $0001.w with Y register [Reads: Y Index] [Flags: NCZ]
	sta $C7.b,S		; 83 C7 ; Store accumulator (stack relative) $C7.b,S [Reads: Stack Pointer, Accumulator]
	eor [$FF.b],Y		; 57 FF ; Exclusive OR accumulator with memory (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $22		; 10 22 ; Branch if plus to $10, $22 [Flow: branch]
	bit $D0.b,X		; 34 D0 ; Test bits $D0.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cmp [$02.b],Y		; D7 02 ; Compare accumulator (long indexed) [$02.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cop $E9.b		; 02 E9 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp [$CD.b]		; C7 CD ; Compare accumulator (long) [$CD.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	ora ($22.b)		; 12 22 ; OR accumulator with memory (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cmp $CFC8.w		; CD C8 CF ; Compare $CFC8.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($CD.b,S),Y		; D3 CD ; Compare accumulator (stack relative indirect indexed) ($CD.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	pei ($E6.b)		; D4 E6 ; Push effective indirect address ($E6.b) [Reads: Direct Page] [Writes: Stack Pointer]
	cop $20.b		; 02 20 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy $4F.b		; C4 4F ; Compare $4F.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpy $07.b		; C4 07 ; Compare $07.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	jsr $6505.w		; 20 05 65 ; Jump to subroutine at $6505.w [Writes: Stack Pointer] [Flow: call]
	adc $58.b		; 65 58 ; Add $58.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpy $AB.b		; C4 AB ; Compare $AB.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	and $710058.l		; 2F 58 00 71 ; AND accumulator with memory (long) $710058.l [Writes: Accumulator] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	ror $1CE0.w,X		; 7E E0 1C ; Rotate right $1CE0.w,X [Reads: X Index] [Flags: NCZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and ($D5.b),Y		; 31 D5 ; AND accumulator with memory ($D5.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	and ($10.b),Y		; 31 10 ; AND accumulator with memory ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($D5.b,X)		; 01 D5 ; Logical OR ($D5.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpx $34.b		; E4 34 ; Compare $34.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	and ($02.b),Y		; 31 02 ; AND accumulator with memory ($02.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($E6.b,X)		; 01 E6 ; Logical OR ($E6.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp $CD.b,X		; D5 CD ; Compare accumulator $CD.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ldx $2600.w		; AE 00 26 ; Load $2600.w into X register [Writes: X Index] [Flags: NZ]
	ldx $D257.w		; AE 57 D2 ; Load $D257.w into X register [Writes: X Index] [Flags: NZ]
	eor $0767.w,Y		; 59 67 07 ; Exclusive OR accumulator with memory $0767.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sta $5C.b,S		; 83 5C ; Store accumulator (stack relative) $5C.b,S [Reads: Stack Pointer, Accumulator]
	adc $17.b		; 65 17 ; Add $17.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	trb $5EC8.w		; 1C C8 5E ; Test and reset bits $5EC8.w [Reads: Accumulator] [Flags: Z]
	pea $7220.w		; F4 20 72 ; Push absolute address $7220.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	eor ($1C.b,S),Y		; 53 1C ; XOR accumulator (stack relative indirect indexed) ($1C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	trb $7212.w		; 1C 12 72 ; Test and reset bits $7212.w [Reads: Accumulator] [Flags: Z]
	adc ($2A.b,X)		; 61 2A ; Add with carry ($2A.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $5F.b		; 05 5F ; Logical OR $5F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx $E905.w		; AE 05 E9 ; Load $E905.w into X register [Writes: X Index] [Flags: NZ]
	sta $67.b,S		; 83 67 ; Store accumulator (stack relative) $67.b,S [Reads: Stack Pointer, Accumulator]
	adc ($5B.b,X)		; 61 5B ; Add with carry ($5B.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc #$2020.w		; E9 20 20 ; Subtract #$2020.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	asl $23.b,X		; 16 23 ; Arithmetic shift left $23.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc [$09.b]		; E7 09 ; Subtract with carry (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	and ($67.b,S),Y		; 33 67 ; AND accumulator (stack relative indirect indexed) ($67.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc ($33.b)		; 72 33 ; Add with carry (indirect) ($33.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jsr $3465.w		; 20 65 34 ; Jump to subroutine at $3465.w [Writes: Stack Pointer] [Flow: call]
	and $70.b,S		; 23 70 ; AND accumulator with stack relative $70.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr $9E9C.w		; 20 9C 9E ; Jump to subroutine at $9E9C.w [Writes: Stack Pointer] [Flow: call]
	stz $5535.w,X		; 9E 35 55 ; Store zero to $5535.w,X [Reads: X Index]
	adc ($67.b),Y		; 71 67 ; Add with carry ($67.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $69.b,X		; 34 69 ; Test bits $69.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora ($06.b),Y		; 11 06 ; OR accumulator with memory ($06.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta [$9C.b],Y		; 97 9C ; Store accumulator (long indexed) [$9C.b],Y [Reads: Direct Page, Y Index, Accumulator]
	asl $AE.b		; 06 AE ; Arithmetic shift left $AE.b [Reads: Direct Page] [Flags: NCZ]
	eor $16.b,X		; 55 16 ; Exclusive OR accumulator with memory $16.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ldx $6565.w		; AE 65 65 ; Load $6565.w into X register [Writes: X Index] [Flags: NZ]
	adc $61.b		; 65 61 ; Add $61.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($65.b),Y		; 11 65 ; OR accumulator with memory ($65.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $AE.b		; 65 AE ; Add $AE.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta [$11.b],Y		; 97 11 ; Store accumulator (long indexed) [$11.b],Y [Reads: Direct Page, Y Index, Accumulator]
	adc $1F.b		; 65 1F ; Add $1F.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora [$9C.b]		; 07 9C ; OR accumulator with memory (long) [$9C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $31.b		; 06 31 ; Arithmetic shift left $31.b [Reads: Direct Page] [Flags: NCZ]
	eor ($F1.b),Y		; 51 F1 ; Exclusive OR accumulator with memory ($F1.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc #$C4B7.w		; 69 B7 C4 ; Add #$C4B7.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	ora [$60.b],Y		; 17 60 ; OR accumulator with memory (long indexed) [$60.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ldx $6BAE.w		; AE AE 6B ; Load $6BAE.w into X register [Writes: X Index] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ror $77.b		; 66 77 ; Rotate right $77.b [Reads: Direct Page] [Flags: NCZ]
	cmp $21C8D2.l		; CF D2 C8 21 ; Compare accumulator (long) $21C8D2.l [Reads: Accumulator] [Flags: NCZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $C8.b,X		; 56 C8 ; Logical shift right $C8.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ldx $705F.w		; AE 5F 70 ; Load $705F.w into X register [Writes: X Index] [Flags: NZ]
	adc [$E7.b]		; 67 E7 ; Add with carry (long) [$E7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	stz $6E.b		; 64 6E ; Store zero to $6E.b
	ldx $7667.w		; AE 67 76 ; Load $7667.w into X register [Writes: X Index] [Flags: NZ]
	sbc [$F8.b]		; E7 F8 ; Subtract with carry (long) [$F8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$D1.b]		; E7 D1 ; Subtract with carry (long) [$D1.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ror $60.b		; 66 60 ; Rotate right $60.b [Reads: Direct Page] [Flags: NCZ]
	cmp ($61.b),Y		; D1 61 ; Compare accumulator ($61.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $70, $07		; 70 07 ; Branch if overflow set to $70, $07 [Flow: branch]
	adc [$AE.b],Y		; 77 AE ; Add with carry (long indexed) [$AE.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $E7FA.w,Y		; F9 FA E7 ; Subtract with carry $E7FA.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $66.b		; 66 66 ; Rotate right $66.b [Reads: Direct Page] [Flags: NCZ]
	stz $1C.b,X		; 74 1C ; Store zero to $1C.b,X [Reads: X Index]
	sbc [$70.b]		; E7 70 ; Subtract with carry (long) [$70.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc [$67.b],Y		; 77 67 ; Add with carry (long indexed) [$67.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx $6EAE.w		; AE AE 6E ; Load $6EAE.w into X register [Writes: X Index] [Flags: NZ]
	sbc $7666.w,Y		; F9 66 76 ; Subtract with carry $7666.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$E7.b]		; E7 E7 ; Subtract with carry (long) [$E7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$5C.b]		; E7 5C ; Subtract with carry (long) [$5C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ror $67.b		; 66 67 ; Rotate right $67.b [Reads: Direct Page] [Flags: NCZ]
	cpx $78.b		; E4 78 ; Compare $78.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	adc $676E.w,Y		; 79 6E 67 ; Add $676E.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc [$09.b],Y		; 77 09 ; Add with carry (long indexed) [$09.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx $65.b		; E4 65 ; Compare $65.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc [$76.b]		; E7 76 ; Subtract with carry (long) [$76.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ror $7B.b,X		; 76 7B ; Rotate right $7B.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	cpx $7C.b		; E4 7C ; Compare $7C.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	adc [$67.b],Y		; 77 67 ; Add with carry (long indexed) [$67.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sbc [$09.b]		; E7 09 ; Subtract with carry (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc ($66.b),Y		; 71 66 ; Add with carry ($66.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc [$96.b],Y		; 77 96 ; Add with carry (long indexed) [$96.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($97.b),Y		; 71 97 ; Add with carry ($97.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta [$51.b],Y		; 97 51 ; Store accumulator (long indexed) [$51.b],Y [Reads: Direct Page, Y Index, Accumulator]
	eor $97.b,X		; 55 97 ; Exclusive OR accumulator with memory $97.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sta [$05.b],Y		; 97 05 ; Store accumulator (long indexed) [$05.b],Y [Reads: Direct Page, Y Index, Accumulator]
	adc $55.b		; 65 55 ; Add $55.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($1F.b),Y		; 11 1F ; OR accumulator with memory ($1F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $07.b		; 65 07 ; Add $07.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	nop		; EA ; No operation
	and ($11.b,X)		; 21 11 ; Logical AND ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	adc $AE.b		; 65 AE ; Add $AE.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp [$85.b]		; C7 85 ; Compare accumulator (long) [$85.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	asl $03.b,X		; 16 03 ; Arithmetic shift left $03.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ror $D0C9.w,X		; 7E C9 D0 ; Rotate right $D0C9.w,X [Reads: X Index] [Flags: NCZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	ror $AEEE.w,X		; 7E EE AE ; Rotate right $AEEE.w,X [Reads: X Index] [Flags: NCZ]
	ora ($16.b,X)		; 01 16 ; Logical OR ($16.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ldx $C507.w		; AE 07 C5 ; Load $C507.w into X register [Writes: X Index] [Flags: NZ]
	ldx $0662.w		; AE 62 06 ; Load $0662.w into X register [Writes: X Index] [Flags: NZ]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cmp ($AE.b,S),Y		; D3 AE ; Compare accumulator (stack relative indirect indexed) ($AE.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sep #$C5		; E2 C5 ; Set processor status bits #$C5 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ror $7700.w,X		; 7E 00 77 ; Rotate right $7700.w,X [Reads: X Index] [Flags: NCZ]
	ldx $DA79.w		; AE 79 DA ; Load $DA79.w into X register [Writes: X Index] [Flags: NZ]
	bit $61.b,X		; 34 61 ; Test bits $61.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $F2.b		; 00 F2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $86C8.w,X		; 7E C8 86 ; Rotate right $86C8.w,X [Reads: X Index] [Flags: NCZ]
	ora [$01.b],Y		; 17 01 ; OR accumulator with memory (long indexed) [$01.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $AE.b,X		; 34 AE ; Test bits $AE.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora ($20.b,X)		; 01 20 ; Logical OR ($20.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: NCZ]
	adc ($67.b),Y		; 71 67 ; Add with carry ($67.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($34.b,X)		; 01 34 ; Logical OR ($34.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($20.b,X)		; 01 20 ; Logical OR ($20.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $74AE.w		; 0C AE 74 ; Test and set bits $74AE.w [Reads: Accumulator] [Flags: Z]
	bit $26.b,X		; 34 26 ; Test bits $26.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $30, $78		; 30 78 ; Branch if minus to $30, $78 [Flow: branch]
	adc $1135AE.l,X		; 7F AE 35 11 ; Add long $1135AE.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	bit $53.b,X		; 34 53 ; Test bits $53.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	inc $5C.b		; E6 5C ; Increment $5C.b [Reads: Direct Page] [Flags: NZ]
	ora ($27.b,X)		; 01 27 ; Logical OR ($27.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $AE.b		; 06 AE ; Arithmetic shift left $AE.b [Reads: Direct Page] [Flags: NCZ]
	stz $16AA.w		; 9C AA 16 ; Store zero to $16AA.w
	lsr $58.b,X		; 56 58 ; Logical shift right $58.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	bit $CE.b,X		; 34 CE ; Test bits $CE.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	adc $66.b		; 65 66 ; Add $66.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	sta [$11.b],Y		; 97 11 ; Store accumulator (long indexed) [$11.b],Y [Reads: Direct Page, Y Index, Accumulator]
	ora $9C.b		; 05 9C ; Logical OR $9C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldx $AEDB.w		; AE DB AE ; Load $AEDB.w into X register [Writes: X Index] [Flags: NZ]
	lsr $06.b,X		; 56 06 ; Logical shift right $06.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ldx $C2C2.w		; AE C2 C2 ; Load $C2C2.w into X register [Writes: X Index] [Flags: NZ]
	ldx $1661.w		; AE 61 16 ; Load $1661.w into X register [Writes: X Index] [Flags: NZ]
	ldx $AEAE.w		; AE AE AE ; Load $AEAE.w into X register [Writes: X Index] [Flags: NZ]
	and [$66.b]		; 27 66 ; AND accumulator with memory (long) [$66.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc ($DA.b,X)		; 61 DA ; Add with carry ($DA.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $717F.w		; CD 7F 71 ; Compare $717F.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsl $F7A971.l		; 22 71 A9 F7 ; Jump to subroutine long $F7A971.l [Writes: Stack Pointer] [Flow: call]
	cmp $2262C7.l,X		; DF C7 62 22 ; Compare accumulator (long,X) $2262C7.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	cmp [$CD.b]		; C7 CD ; Compare accumulator (long) [$CD.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	adc $712265.l,X		; 7F 65 22 71 ; Add long $712265.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	dec $DA.b		; C6 DA ; Decrement $DA.b [Reads: Direct Page] [Flags: NZ]
	asl $12.b		; 06 12 ; Arithmetic shift left $12.b [Reads: Direct Page] [Flags: NCZ]
	and ($66.b,X)		; 21 66 ; Logical AND ($66.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	dec $CD.b		; C6 CD ; Decrement $CD.b [Reads: Direct Page] [Flags: NZ]
	sta $10.b,S		; 83 10 ; Store accumulator (stack relative) $10.b,S [Reads: Stack Pointer, Accumulator]
	and ($C6.b,X)		; 21 C6 ; Logical AND ($C6.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp [$A2.b]		; C7 A2 ; Compare accumulator (long) [$A2.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	eor [$02.b],Y		; 57 02 ; Exclusive OR accumulator with memory (long indexed) [$02.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $C6, $D1		; 62 C6 D1 ; Push effective relative address $62, $C6, $D1 [Writes: Stack Pointer]
	cmp ($D2.b),Y		; D1 D2 ; Compare accumulator ($D2.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $A2.b		; C6 A2 ; Decrement $A2.b [Reads: Direct Page] [Flags: NZ]
	dec $87.b		; C6 87 ; Decrement $87.b [Reads: Direct Page] [Flags: NZ]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: NCZ]
	sta [$C8.b]		; 87 C8 ; Store accumulator (long) [$C8.b] [Reads: Direct Page, Accumulator]
	and $1C.b,X		; 35 1C ; Logical AND $1C.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $52		; 30 52 ; Branch if minus to $30, $52 [Flow: branch]
	.db $42, $84		; 42 84 ; Reserved instruction
	sbc $CD.b,X		; F5 CD ; Subtract $CD.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor [$22.b],Y		; 57 22 ; Exclusive OR accumulator with memory (long indexed) [$22.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $86.b,X		; 35 86 ; Logical AND $86.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	bit $20.b,X		; 34 20 ; Test bits $20.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	eor ($05.b),Y		; 51 05 ; Exclusive OR accumulator with memory ($05.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor ($42.b,S),Y		; 53 42 ; XOR accumulator (stack relative indirect indexed) ($42.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $A3.b,X		; 35 A3 ; Logical AND $A3.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $50.b,X		; 15 50 ; OR accumulator with memory $50.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$E6.b]		; 07 E6 ; OR accumulator with memory (long) [$E6.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp [$72.b]		; C7 72 ; Compare accumulator (long) [$72.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	and ($5C.b)		; 32 5C ; AND accumulator with memory (indirect) ($5C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx $7C.b		; E4 7C ; Compare $7C.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	inc $76.b		; E6 76 ; Increment $76.b [Reads: Direct Page] [Flags: NZ]
	adc ($89.b)		; 72 89 ; Add with carry (indirect) ($89.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp $A08A.w		; CD 8A A0 ; Compare $A08A.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	adc ($73.b)		; 72 73 ; Add with carry (indirect) ($73.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	inc $E6.b		; E6 E6 ; Increment $E6.b [Reads: Direct Page] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $E1E127.l		; 22 27 E1 E1 ; Jump to subroutine long $E1E127.l [Writes: Stack Pointer] [Flow: call]
	inc $06.b		; E6 06 ; Increment $06.b [Reads: Direct Page] [Flags: NZ]
	jsl $E1A523.l		; 22 23 A5 E1 ; Jump to subroutine long $E1A523.l [Writes: Stack Pointer] [Flow: call]
	sta [$97.b],Y		; 97 97 ; Store accumulator (long indexed) [$97.b],Y [Reads: Direct Page, Y Index, Accumulator]
	and ($55.b)		; 32 55 ; AND accumulator with memory (indirect) ($55.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $E6.b		; E6 E6 ; Increment $E6.b [Reads: Direct Page] [Flags: NZ]
	inc $06.b		; E6 06 ; Increment $06.b [Reads: Direct Page] [Flags: NZ]
	jsl $696621.l		; 22 21 66 69 ; Jump to subroutine long $696621.l [Writes: Stack Pointer] [Flow: call]
	sta $1669.w,X		; 9D 69 16 ; Store accumulator to $1669.w,X [Reads: Accumulator, X Index]
	lsr $97.b,X		; 56 97 ; Logical shift right $97.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	dec $84.b		; C6 84 ; Decrement $84.b [Reads: Direct Page] [Flags: NZ]
	cmp #$1050.w		; C9 50 10 ; Compare #$1050.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	dec $D5.b,X		; D6 D5 ; Decrement memory $D5.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	cmp $20D0.w,Y		; D9 D0 20 ; Compare accumulator $20D0.w,Y [Reads: Y Index] [Flags: NCZ]
	jsr $CDC7.w		; 20 C7 CD ; Jump to subroutine at $CDC7.w [Writes: Stack Pointer] [Flow: call]
	cmp $22C7.w		; CD C7 22 ; Compare $22C7.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsl $A2DFF6.l		; 22 F6 DF A2 ; Jump to subroutine long $A2DFF6.l [Writes: Stack Pointer] [Flow: call]
	cmp $D26022.l		; CF 22 60 D2 ; Compare accumulator (long) $D26022.l [Reads: Accumulator] [Flags: NCZ]
	cmp $CDC7.w		; CD C7 CD ; Compare $CDC7.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $A2.b		; C6 A2 ; Decrement $A2.b [Reads: Direct Page] [Flags: NZ]
	cmp ($C7.b)		; D2 C7 ; Compare accumulator (indirect) ($C7.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	rol $22.b		; 26 22 ; Rotate left $22.b [Reads: Direct Page] [Flags: NCZ]
	eor $E10563.l		; 4F 63 05 E1 ; Exclusive OR accumulator with memory (long) $E10563.l [Writes: Accumulator] [Flags: NZ]
	adc ($32.b),Y		; 71 32 ; Add with carry ($32.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $63.b		; 06 63 ; Arithmetic shift left $63.b [Reads: Direct Page] [Flags: NCZ]
	ora [$E6.b]		; 07 E6 ; OR accumulator with memory (long) [$E6.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($32.b),Y		; 31 32 ; AND accumulator with memory ($32.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $8F6A.w,X		; FD 6A 8F ; Subtract with carry $8F6A.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $7726.w		; 8D 26 77 ; Store accumulator to $7726.w [Reads: Accumulator]
	inc $E1.b		; E6 E1 ; Increment $E1.b [Reads: Direct Page] [Flags: NZ]
	sbc ($E2.b,X)		; E1 E2 ; Subtract with carry ($E2.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $F49022.l		; 22 22 90 F4 ; Jump to subroutine long $F49022.l [Writes: Stack Pointer] [Flow: call]
	inc $2A.b		; E6 2A ; Increment $2A.b [Reads: Direct Page] [Flags: NZ]
	adc ($27.b)		; 72 27 ; Add with carry (indirect) ($27.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $E6E6.w		; 8D E6 E6 ; Store accumulator to $E6E6.w [Reads: Accumulator]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	adc ($20.b)		; 72 20 ; Add with carry (indirect) ($20.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc ($AB.b),Y		; 71 AB ; Add with carry ($AB.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	stz $109D.w,X		; 9E 9D 10 ; Store zero to $109D.w,X [Reads: X Index]
	adc [$9F.b],Y		; 77 9F ; Add with carry (long indexed) [$9F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lda ($97.b,X)		; A1 97 ; Load accumulator ($97.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ldy $77.b		; A4 77 ; Load $77.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	adc [$A6.b],Y		; 77 A6 ; Add with carry (long indexed) [$A6.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $A7.b		; A5 A7 ; Load $A7.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $77		; B0 77 ; Branch if carry set to $B0, $77 [Flow: branch]
	adc [$AF.b],Y		; 77 AF ; Add with carry (long indexed) [$AF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lda ($AD.b),Y		; B1 AD ; Load accumulator ($AD.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda $7777.w		; AD 77 77 ; Load $7777.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy $B6.b,X		; B4 B6 ; Load Y register $B6.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	lda $A1.b,X		; B5 A1 ; Load $A1.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $C2AFAD.l,X		; BF AD AF C2 ; Load long $C2AFAD.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $C3.b,S		; C3 C3 ; Compare accumulator (stack relative) $C3.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	lda $77C2.w		; AD C2 77 ; Load $77C2.w into accumulator [Writes: Accumulator] [Flags: NZ]
	adc [$C3.b],Y		; 77 C3 ; Add with carry (long indexed) [$C3.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy #$ADA2.w		; A0 A2 AD ; Load #$ADA2.w into Y register [Writes: Y Index] [Flags: NZ]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $C6.b		; C5 C6 ; Compare $C6.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	lda ($AD.b)		; B2 AD ; Load accumulator (indirect) ($AD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp ($D3.b)		; D2 D3 ; Compare accumulator (indirect) ($D3.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	pei ($D6.b)		; D4 D6 ; Push effective indirect address ($D6.b) [Reads: Direct Page] [Writes: Stack Pointer]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	.db $D0, $D0		; D0 D0 ; Branch if not equal to $D0, $D0 [Flow: branch]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $A7.b,X		; D6 A7 ; Decrement memory $A7.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	cpy #$77E8.w		; C0 E8 77 ; Compare #$77E8.w with Y register [Reads: Y Index] [Flags: NCZ]
	adc [$EA.b],Y		; 77 EA ; Add with carry (long indexed) [$EA.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx $EFEE.w		; EC EE EF ; Compare $EFEE.w with X register [Reads: X Index] [Flags: NCZ]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta [$D8.b],Y		; 97 D8 ; Store accumulator (long indexed) [$D8.b],Y [Reads: Direct Page, Y Index, Accumulator]
	sta [$A5.b],Y		; 97 A5 ; Store accumulator (long indexed) [$A5.b],Y [Reads: Direct Page, Y Index, Accumulator]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lda [$97.b]		; A7 97 ; Load accumulator (long) [$97.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $FC.b		; C5 FC ; Compare $FC.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $0F00.w,X		; FE 00 0F ; Increment memory $0F00.w,X [Reads: X Index] [Flags: NZ]
	lda $78.b,S		; A3 78 ; Load accumulator (stack relative) $78.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and [$BE.b]		; 27 BE ; AND accumulator with memory (long) [$BE.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta [$B5.b],Y		; 97 B5 ; Store accumulator (long indexed) [$B5.b],Y [Reads: Direct Page, Y Index, Accumulator]
	sta $7777.w,X		; 9D 77 77 ; Store accumulator to $7777.w,X [Reads: Accumulator, X Index]
	cmp $AD.b,X		; D5 AD ; Compare accumulator $AD.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cmp $C6.b		; C5 C6 ; Compare $C6.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora #$0F07.w		; 09 07 0F ; Logical OR #$0F07.w with accumulator [Writes: Accumulator] [Flags: NZ]
	rep #$88		; C2 88 ; Reset processor status bits #$88 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	and [$C6.b]		; 27 C6 ; AND accumulator with memory (long) [$C6.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	lda $77DB.w		; AD DB 77 ; Load $77DB.w into accumulator [Writes: Accumulator] [Flags: NZ]
	adc [$AF.b],Y		; 77 AF ; Add with carry (long indexed) [$AF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $C5		; F0 C5 ; Branch if equal to $F0, $C5 [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	adc [$70.b],Y		; 77 70 ; Add with carry (long indexed) [$70.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $0D.b		; C6 0D ; Decrement $0D.b [Reads: Direct Page] [Flags: NZ]
	sbc ($C6.b,S),Y		; F3 C6 ; Subtract with carry (stack relative indirect indexed) ($C6.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	adc [$10.b],Y		; 77 10 ; Add with carry (long indexed) [$10.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($D5.b)		; 12 D5 ; OR accumulator with memory (indirect) ($D5.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dec $88.b		; C6 88 ; Decrement $88.b [Reads: Direct Page] [Flags: NZ]
	adc [$14.b],Y		; 77 14 ; Add with carry (long indexed) [$14.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $D0, $C5		; D0 C5 ; Branch if not equal to $D0, $C5 [Flow: branch]
	dec $87.b		; C6 87 ; Decrement $87.b [Reads: Direct Page] [Flags: NZ]
	adc [$B3.b],Y		; 77 B3 ; Add with carry (long indexed) [$B3.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	stz $D7B2.w,X		; 9E B2 D7 ; Store zero to $D7B2.w,X [Reads: X Index]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $D6AD.w,Y		; D9 AD D6 ; Compare accumulator $D6AD.w,Y [Reads: Y Index] [Flags: NCZ]
	lda $7777.w		; AD 77 77 ; Load $7777.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp ($C6.b,X)		; C1 C6 ; Compare accumulator ($C6.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	cmp [$D9.b],Y		; D7 D9 ; Compare accumulator (long indexed) [$D9.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
.ACCU 8
	sep #$A6		; E2 A6
	sta [$77.b],Y		; 97 77 ; Store accumulator (long indexed) [$77.b],Y [Reads: Direct Page, Y Index, Accumulator]
	adc [$D1.b],Y		; 77 D1 ; Add with carry (long indexed) [$D1.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc $78B8.w,Y		; F9 B8 78 ; Subtract with carry $78B8.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc [$D4.b],Y		; 77 D4 ; Add with carry (long indexed) [$D4.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $C8.b		; C5 C8 ; Compare $C8.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp $77.b,S		; C3 77 ; Compare accumulator (stack relative) $77.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	adc [$97.b],Y		; 77 97 ; Add with carry (long indexed) [$97.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta [$AF.b],Y		; 97 AF ; Store accumulator (long indexed) [$AF.b],Y [Reads: Direct Page, Y Index, Accumulator]
	dec $77.b		; C6 77 ; Decrement $77.b [Reads: Direct Page] [Flags: NZ]
	adc [$1E.b],Y		; 77 1E ; Add with carry (long indexed) [$1E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $88C611.l		; 0F 11 C6 88 ; OR accumulator with memory (long) $88C611.l [Writes: Accumulator] [Flags: NZ]
	sta [$C8.b]		; 87 C8 ; Store accumulator (long) [$C8.b] [Reads: Direct Page, Accumulator]
	cpy $A6.b		; C4 A6 ; Compare $A6.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	lda [$77.b]		; A7 77 ; Load accumulator (long) [$77.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc [$C6.b],Y		; 77 C6 ; Add with carry (long indexed) [$C6.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $23.b		; C5 23 ; Compare $23.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	adc [$87.b],Y		; 77 87 ; Add with carry (long indexed) [$87.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and $27.b		; 25 27 ; Logical AND $27.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $B6.b		; 26 B6 ; Rotate left $B6.b [Reads: Direct Page] [Flags: NCZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta [$C4.b]		; 87 C4 ; Store accumulator (long) [$C4.b] [Reads: Direct Page, Accumulator]
	lda $C61A.w		; AD 1A C6 ; Load $C61A.w into accumulator [Writes: Accumulator] [Flags: NZ]
	adc [$87.b],Y		; 77 87 ; Add with carry (long indexed) [$87.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	lda $7777A7.l		; AF A7 77 77 ; Load long $7777A7.l into accumulator [Writes: Accumulator] [Flags: NZ]
	and ($34.b)		; 32 34 ; AND accumulator with memory (indirect) ($34.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($C6.b,S),Y		; 33 C6 ; AND accumulator (stack relative indirect indexed) ($C6.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta [$36.b]		; 87 36 ; Store accumulator (long) [$36.b] [Reads: Direct Page, Accumulator]
	sec		; 38 ; Set carry flag [Flags: C]
	and [$36.b],Y		; 37 36 ; AND accumulator with memory (long indexed) [$36.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp [$39.b]		; C7 39 ; Compare accumulator (long) [$39.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sta $A48087.l,X		; 9F 87 80 A4 ; Store accumulator (long,X) $A48087.l,X [Reads: Accumulator, X Index]
	dec $C1.b		; C6 C1 ; Decrement $C1.b [Reads: Direct Page] [Flags: NZ]
	lda ($07.b)		; B2 07 ; Load accumulator (indirect) ($07.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc [$C6.b],Y		; 77 C6 ; Add with carry (long indexed) [$C6.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp [$2E.b]		; C7 2E ; Compare accumulator (long) [$2E.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	dec $77.b		; C6 77 ; Decrement $77.b [Reads: Direct Page] [Flags: NZ]
	sta [$C6.b]		; 87 C6 ; Store accumulator (long) [$C6.b] [Reads: Direct Page, Accumulator]
	and $7840C6.l,X		; 3F C6 40 78 ; AND accumulator with memory (long,X) $7840C6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	bit $A3.b		; 24 A3 ; Test bits $A3.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	lda $C6.b		; A5 C6 ; Load $C6.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta [$77.b]		; 87 77 ; Store accumulator (long) [$77.b] [Reads: Direct Page, Accumulator]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	dec $40.b		; C6 40 ; Decrement $40.b [Reads: Direct Page] [Flags: NZ]
	adc [$78.b],Y		; 77 78 ; Add with carry (long indexed) [$78.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $41.b		; 24 41 ; Test bits $41.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	eor $D4.b		; 45 D4 ; Exclusive OR $D4.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta [$C1.b]		; 87 C1 ; Store accumulator (long) [$C1.b] [Reads: Direct Page, Accumulator]
	lsr $B5.b		; 46 B5 ; Logical shift right $B5.b [Reads: Direct Page] [Flags: NCZ]
	sbc ($78.b,S),Y		; F3 78 ; Subtract with carry (stack relative indirect indexed) ($78.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	adc [$C6.b],Y		; 77 C6 ; Add with carry (long indexed) [$C6.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $DAD0.w		; 0D D0 DA ; Logical OR $DAD0.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	adc [$C1.b],Y		; 77 C1 ; Add with carry (long indexed) [$C1.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $46.b,S		; A3 46 ; Load accumulator (stack relative) $46.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc ($77.b,S),Y		; F3 77 ; Subtract with carry (stack relative indirect indexed) ($77.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sta [$4A.b]		; 87 4A ; Store accumulator (long) [$4A.b] [Reads: Direct Page, Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	lda [$A6.b]		; A7 A6 ; Load accumulator (long) [$A6.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta [$77.b]		; 87 77 ; Store accumulator (long) [$77.b] [Reads: Direct Page, Accumulator]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	sbc ($F8.b),Y		; F1 F8 ; Subtract with carry ($F8.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($87.b,S),Y		; F3 87 ; Subtract with carry (stack relative indirect indexed) ($87.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	adc [$42.b],Y		; 77 42 ; Add with carry (long indexed) [$42.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $B3C4.w,X		; 1E C4 B3 ; Arithmetic shift left $B3C4.w,X [Reads: X Index] [Flags: NCZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	adc [$C2.b],Y		; 77 C2 ; Add with carry (long indexed) [$C2.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy $B4.b		; C4 B4 ; Compare $B4.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	dec $77.b		; C6 77 ; Decrement $77.b [Reads: Direct Page] [Flags: NZ]
	adc [$C6.b],Y		; 77 C6 ; Add with carry (long indexed) [$C6.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $C1.b		; C6 C1 ; Decrement $C1.b [Reads: Direct Page] [Flags: NZ]
.ACCU 16
.INDEX 16
	rep #$77		; C2 77
	adc [$C6.b],Y		; 77 C6 ; Add with carry (long indexed) [$C6.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	dec $D7.b,X		; D6 D7 ; Decrement memory $D7.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $F3.b,S		; A3 F3 ; Load accumulator (stack relative) $F3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $4E.b		; C6 4E ; Decrement $4E.b [Reads: Direct Page] [Flags: NZ]
	adc [$78.b],Y		; 77 78 ; Add with carry (long indexed) [$78.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp [$B3.b],Y		; D7 B3 ; Compare accumulator (long indexed) [$B3.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	stz $77C2.w,X		; 9E C2 77 ; Store zero to $77C2.w,X [Reads: X Index]
	adc [$F3.b],Y		; 77 F3 ; Add with carry (long indexed) [$F3.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $40.b		; C6 40 ; Decrement $40.b [Reads: Direct Page] [Flags: NZ]
	ora $77.b,S		; 03 77 ; OR accumulator with stack relative $77.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ldy $D4.b,X		; B4 D4 ; Load Y register $D4.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	lsr $EF.b		; 46 EF ; Logical shift right $EF.b [Reads: Direct Page] [Flags: NCZ]
	adc [$87.b],Y		; 77 87 ; Add with carry (long indexed) [$87.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	cmp ($EF.b,X)		; C1 EF ; Compare accumulator ($EF.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	lsr $7877.w		; 4E 77 78 ; Logical shift right $7877.w [Flags: NCZ]
	lda $F1.b,S		; A3 F1 ; Load accumulator (stack relative) $F1.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $0F.b,S		; C3 0F ; Compare accumulator (stack relative) $0F.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	adc [$78.b],Y		; 77 78 ; Add with carry (long indexed) [$78.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	ldy $77.b,X		; B4 77 ; Load Y register $77.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	adc [$4F.b],Y		; 77 4F ; Add with carry (long indexed) [$4F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $F2.b,X		; D5 F2 ; Compare accumulator $F2.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc ($80.b,S),Y		; F3 80 ; Subtract with carry (stack relative indirect indexed) ($80.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	brk $F2.b		; 00 F2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1434.w		; 0D 34 14 ; Logical OR $1434.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $08.b,X		; 34 08 ; Test bits $08.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $DA.b		; 00 DA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor [$51.b],Y		; 57 51 ; Exclusive OR accumulator with memory (long indexed) [$51.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora [$53.b],Y		; 17 53 ; OR accumulator with memory (long indexed) [$53.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	eor $57.b,X		; 55 57 ; Exclusive OR accumulator with memory $57.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lsr $8888.w,X		; 5E 88 88 ; Logical shift right $8888.w,X [Reads: X Index] [Flags: NCZ]
	ora [$5F.b],Y		; 17 5F ; OR accumulator with memory (long indexed) [$5F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	eor ($18.b,S),Y		; 53 18 ; XOR accumulator (stack relative indirect indexed) ($18.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	adc ($63.b,X)		; 61 63 ; Add with carry ($63.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp $888864.l		; 5C 64 88 88 ; Jump long to $888864.l [Flow: jump]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	bit $1E.b		; 24 1E ; Test bits $1E.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	eor ($81.b)		; 52 81 ; Exclusive OR accumulator with memory (indirect) ($81.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	lsr $2825.w,X		; 5E 25 28 ; Logical shift right $2825.w,X [Reads: X Index] [Flags: NCZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	sta ($18.b,X)		; 81 18 ; Store accumulator ($18.b,X) [Reads: Direct Page, Accumulator, X Index]
	eor [$57.b],Y		; 57 57 ; Exclusive OR accumulator with memory (long indexed) [$57.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jmp ($8857.w)		; 6C 57 88 ; Jump indirect to ($8857.w) [Flow: jump]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	adc $383873.l		; 6F 73 38 38 ; Add with carry (long) $383873.l [Writes: Accumulator] [Flags: NCVZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ora ($38.b),Y		; 11 38 ; OR accumulator with memory ($38.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	adc $88117A.l		; 6F 7A 11 88 ; Add with carry (long) $88117A.l [Writes: Accumulator] [Flags: NCVZ]
	jmp ($7D7D.w,X)		; 7C 7D 7D ; Jump indirect indexed to ($7D7D.w,X) [Reads: X Index] [Flow: jump]
	ror $8888.w		; 6E 88 88 ; Rotate right $8888.w [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	eor ($60.b,S),Y		; 53 60 ; XOR accumulator (stack relative indirect indexed) ($60.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	eor $57.b,X		; 55 57 ; Exclusive OR accumulator with memory $57.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ror $8858.w		; 6E 58 88 ; Rotate right $8858.w [Flags: NCZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cmp #$53C9.w		; C9 C9 53 ; Compare #$53C9.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	stx $00.b		; 86 00 ; Store X register to $00.b [Reads: X Index]
	clc		; 18 ; Clear carry flag [Flags: C]
	sta [$80.b]		; 87 80 ; Store accumulator (long) [$80.b] [Reads: Direct Page, Accumulator]
	eor ($52.b),Y		; 51 52 ; Exclusive OR accumulator with memory ($52.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	eor [$6E.b],Y		; 57 6E ; Exclusive OR accumulator with memory (long indexed) [$6E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sty $868C.w		; 8C 8C 86 ; Store Y register to $868C.w [Reads: Y Index]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	adc ($52.b)		; 72 52 ; Add with carry (indirect) ($52.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lsr $881D.w,X		; 5E 1D 88 ; Logical shift right $881D.w,X [Reads: X Index] [Flags: NCZ]
	sta ($6B.b,X)		; 81 6B ; Store accumulator ($6B.b,X) [Reads: Direct Page, Accumulator, X Index]
	eor [$8F.b],Y		; 57 8F ; Exclusive OR accumulator with memory (long indexed) [$8F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $50, $88		; 50 88 ; Branch if overflow clear to $50, $88 [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $50, $58		; 50 58 ; Branch if overflow clear to $50, $58 [Flow: branch]
	trb $8891.w		; 1C 91 88 ; Test and reset bits $8891.w [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	eor ($58.b)		; 52 58 ; Exclusive OR accumulator with memory (indirect) ($58.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $8188.w		; 2D 88 81 ; Logical AND $8188.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jmp ($C8CC.w)		; 6C CC C8 ; Jump indirect to ($C8CC.w) [Flow: jump]
	eor [$10.b],Y		; 57 10 ; Exclusive OR accumulator with memory (long indexed) [$10.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cop $AC.b		; 02 AC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy $A5.b		; C4 A5 ; Compare $A5.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($A5.b),Y		; 11 A5 ; OR accumulator with memory ($A5.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta ($41.b)		; 92 41 ; Store accumulator (indirect) ($41.b) [Reads: Direct Page, Accumulator]
	lda #$1018.w		; A9 18 10 ; Load #$1018.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $34A5A5.l,X		; FF A5 A5 34 ; Subtract with carry (long,X) $34A5A5.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($10.b),Y		; 11 10 ; OR accumulator with memory ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda $8585.w		; AD 85 85 ; Load $8585.w into accumulator [Writes: Accumulator] [Flags: NZ]
	eor ($08.b),Y		; 51 08 ; Exclusive OR accumulator with memory ($08.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	bit $A5.b		; 24 A5 ; Test bits $A5.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ldy #$18A0.w		; A0 A0 18 ; Load #$18A0.w into Y register [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ldy #$A099.w		; A0 99 A0 ; Load #$A099.w into Y register [Writes: Y Index] [Flags: NZ]
	ldy #$8888.w		; A0 88 88 ; Load #$8888.w into Y register [Writes: Y Index] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda #$71A4.w		; A9 A4 71 ; Load #$71A4.w into accumulator [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	bit #$9558.w		; 89 58 95 ; Test bits #$9558.w with accumulator [Reads: Accumulator] [Flags: Z]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	trb $B1B8.w		; 1C B8 B1 ; Test and reset bits $B1B8.w [Reads: Accumulator] [Flags: Z]
	ldy #$8818.w		; A0 18 88 ; Load #$8818.w into Y register [Writes: Y Index] [Flags: NZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ldy #$8888.w		; A0 88 88 ; Load #$8888.w into Y register [Writes: Y Index] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $7134.w,X		; BD 34 71 ; Load $7134.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	eor [$72.b],Y		; 57 72 ; Exclusive OR accumulator with memory (long indexed) [$72.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	cmp #$1888.w		; C9 88 18 ; Compare #$1888.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	adc ($CB.b,S),Y		; 73 CB ; Add with carry (stack relative indirect indexed) ($CB.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cmp $88CE.w		; CD CE 88 ; Compare $88CE.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cmp $B3CFD1.l		; CF D1 CF B3 ; Compare accumulator (long) $B3CFD1.l [Reads: Accumulator] [Flags: NCZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dec $D4.b		; C6 D4 ; Decrement $D4.b [Reads: Direct Page] [Flags: NZ]
	bit $5F.b,X		; 34 5F ; Test bits $5F.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	adc $73E3.w,X		; 7D E3 73 ; Add $73E3.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sbc $D8.b		; E5 D8 ; Subtract $D8.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$E8.b]		; E7 E8 ; Subtract with carry (long) [$E8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sbc #$E8E8.w		; E9 E8 E8 ; Subtract #$E8E8.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cpx #$8888.w		; E0 88 88 ; Compare #$8888.w with X register [Reads: X Index] [Flags: NCZ]
	cpx $5834.w		; EC 34 58 ; Compare $5834.w with X register [Reads: X Index] [Flags: NCZ]
	cmp $80.b,S		; C3 80 ; Compare accumulator (stack relative) $80.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	sta ($34.b,X)		; 81 34 ; Store accumulator ($34.b,X) [Reads: Direct Page, Accumulator, X Index]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	cmp $C2.b		; C5 C2 ; Compare $C2.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsr ($C5C2.w,X)		; FC C2 C5 ; Jump to subroutine indirect indexed ($C5C2.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc [$88.b],Y		; F7 88 ; Subtract with carry (long indexed) [$88.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc $345E00.l,X		; FF 00 5E 34 ; Subtract with carry (long,X) $345E00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($80.b,X)		; 81 80 ; Store accumulator ($80.b,X) [Reads: Direct Page, Accumulator, X Index]
	asl $08.b		; 06 08 ; Arithmetic shift left $08.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sta $0999.w,Y		; 99 99 09 ; Store accumulator to $0999.w,Y [Reads: Y Index, Accumulator]
	sbc $EC34.w,Y		; F9 34 EC ; Subtract with carry $EC34.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($C5.b,X)		; 01 C5 ; Logical OR ($C5.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ldy $AC.b		; A4 AC ; Load $AC.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	ora ($C8.b,X)		; 01 C8 ; Logical OR ($C8.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $A5.b,X		; 34 A5 ; Test bits $A5.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $10, $36		; 10 36 ; Branch if plus to $10, $36 [Flow: branch]
	adc $3434.w,Y		; 79 34 34 ; Add $3434.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $EF.b,X		; 15 EF ; OR accumulator with memory $EF.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sta ($0E.b,S),Y		; 93 0E ; Store accumulator (stack relative indirect indexed) ($0E.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	and ($82.b,X)		; 21 82 ; Logical AND ($82.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor ($A6.b,X)		; 41 A6 ; Exclusive OR accumulator with memory ($A6.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sta $52.b		; 85 52 ; Store accumulator to $52.b [Reads: Accumulator]
	.db $10, $88		; 10 88 ; Branch if plus to $10, $88 [Flow: branch]
	sta ($67.b,X)		; 81 67 ; Store accumulator ($67.b,X) [Reads: Direct Page, Accumulator, X Index]
	adc $8850.w		; 6D 50 88 ; Add $8850.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	jmp $5C5C5C.l		; 5C 5C 5C 5C ; Jump long to $5C5C5C.l [Flow: jump]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $50, $50		; 50 50 ; Branch if overflow clear to $50, $50 [Flow: branch]
	eor ($58.b)		; 52 58 ; Exclusive OR accumulator with memory (indirect) ($58.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	.db $50, $55		; 50 55 ; Branch if overflow clear to $50, $55 [Flow: branch]
	eor $88.b,X		; 55 88 ; Exclusive OR accumulator with memory $88.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	adc ($67.b,X)		; 61 67 ; Add with carry ($67.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp ($885C.w)		; 6C 5C 88 ; Jump indirect to ($885C.w) [Flow: jump]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	adc $64.b,S		; 63 64 ; Add with carry (stack relative) $64.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $50, $8B		; 50 8B ; Branch if overflow clear to $50, $8B [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	eor ($58.b)		; 52 58 ; Exclusive OR accumulator with memory (indirect) ($58.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $12		; 10 12 ; Branch if plus to $10, $12 [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta $5053.w,Y		; 99 53 50 ; Store accumulator to $5053.w,Y [Reads: Y Index, Accumulator]
	.db $50, $63		; 50 63 ; Branch if overflow clear to $50, $63 [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $50, $50		; 50 50 ; Branch if overflow clear to $50, $50 [Flow: branch]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	asl $8188.w,X		; 1E 88 81 ; Arithmetic shift left $8188.w,X [Reads: X Index] [Flags: NCZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	ror $53.b		; 66 53 ; Rotate right $53.b [Reads: Direct Page] [Flags: NCZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ora $696367.l		; 0F 67 63 69 ; OR accumulator with memory (long) $696367.l [Writes: Accumulator] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	eor ($51.b),Y		; 51 51 ; Exclusive OR accumulator with memory ($51.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor ($5F.b)		; 52 5F ; Exclusive OR accumulator with memory (indirect) ($5F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	.db $50, $50		; 50 50 ; Branch if overflow clear to $50, $50 [Flow: branch]
	adc $88.b		; 65 88 ; Add $88.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $50, $50		; 50 50 ; Branch if overflow clear to $50, $50 [Flow: branch]
	eor ($1C.b),Y		; 51 1C ; Exclusive OR accumulator with memory ($1C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($27.b,X)		; 81 27 ; Store accumulator ($27.b,X) [Reads: Direct Page, Accumulator, X Index]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $50, $2D		; 50 2D ; Branch if overflow clear to $50, $2D [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	sta ($70.b,X)		; 81 70 ; Store accumulator ($70.b,X) [Reads: Direct Page, Accumulator, X Index]
	adc $77.b,X		; 75 77 ; Add $77.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc [$88.b],Y		; 77 88 ; Add with carry (long indexed) [$88.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ror $70.b,X		; 76 70 ; Rotate right $70.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	jsr $8827.w		; 20 27 88 ; Jump to subroutine at $8827.w [Writes: Stack Pointer] [Flow: call]
	and ($71.b,X)		; 21 71 ; Logical AND ($71.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $50, $0A		; 50 0A ; Branch if overflow clear to $50, $0A [Flow: branch]
	eor $9888.w,X		; 5D 88 98 ; Exclusive OR accumulator with memory $9888.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $50, $51		; 50 51 ; Branch if overflow clear to $50, $51 [Flow: branch]
	and $8834.w		; 2D 34 88 ; Logical AND $8834.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $10, $85		; 10 85 ; Branch if plus to $10, $85 [Flow: branch]
	stx $0D.b		; 86 0D ; Store X register to $0D.b [Reads: X Index]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and $8B6950.l,X		; 3F 50 69 8B ; AND accumulator with memory (long,X) $8B6950.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ror $5858.w,X		; 7E 58 58 ; Rotate right $5858.w,X [Reads: X Index] [Flags: NCZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $50, $84		; 50 84 ; Branch if overflow clear to $50, $84 [Flow: branch]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	.db $80, $88		; 80 88 ; Branch always to $80, $88 [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $50, $51		; 50 51 ; Branch if overflow clear to $50, $51 [Flow: branch]
	.db $50, $5C		; 50 5C ; Branch if overflow clear to $50, $5C [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	stz $50.b		; 64 50 ; Store zero to $50.b
	adc $888880.l		; 6F 80 88 88 ; Add with carry (long) $888880.l [Writes: Accumulator] [Flags: NCVZ]
	ror $6788.w		; 6E 88 67 ; Rotate right $6788.w [Flags: NCZ]
	sta $88.b,X		; 95 88 ; Store accumulator to $88.b,X [Reads: Accumulator, X Index]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	dec $80.b		; C6 80 ; Decrement $80.b [Reads: Direct Page] [Flags: NZ]
	brk $C6.b		; 00 C6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	dec $00.b		; C6 00 ; Decrement $00.b [Reads: Direct Page] [Flags: NZ]
	brk $C6.b		; 00 C6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $87.b		; C6 87 ; Decrement $87.b [Reads: Direct Page] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $88.b		; 00 88 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $50, $51		; 50 51 ; Branch if overflow clear to $50, $51 [Flow: branch]
	ora [$17.b],Y		; 17 17 ; OR accumulator with memory (long indexed) [$17.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ora ($5F.b),Y		; 11 5F ; OR accumulator with memory ($5F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $57		; 10 57 ; Branch if plus to $10, $57 [Flow: branch]
	adc $8889.w		; 6D 89 88 ; Add $8889.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	eor ($51.b)		; 52 51 ; Exclusive OR accumulator with memory (indirect) ($51.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $50, $8B		; 50 8B ; Branch if overflow clear to $50, $8B [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	eor ($6A.b),Y		; 51 6A ; Exclusive OR accumulator with memory ($6A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $8988.w,Y		; 19 88 89 ; OR accumulator with memory $8988.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	eor ($5E.b,S),Y		; 53 5E ; XOR accumulator (stack relative indirect indexed) ($5E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ror $8818.w		; 6E 18 88 ; Rotate right $8818.w [Flags: NCZ]
	adc $586F34.l		; 6F 34 6F 58 ; Add with carry (long) $586F34.l [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $88		; 80 88 ; Branch always to $80, $88 [Flow: branch]
	eor ($80.b)		; 52 80 ; Exclusive OR accumulator with memory (indirect) ($80.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $887E.w		; 0D 7E 88 ; Logical OR $887E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $6F.b		; 85 6F ; Store accumulator to $6F.b [Reads: Accumulator]
	ror $89.b		; 66 89 ; Rotate right $89.b [Reads: Direct Page] [Flags: NCZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cmp #$1C53.w		; C9 53 1C ; Compare #$1C53.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora [$01.b],Y		; 17 01 ; OR accumulator with memory (long indexed) [$01.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($17.b),Y		; 11 17 ; OR accumulator with memory ($17.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $186E89.l,X		; 7F 89 6E 18 ; Add long $186E89.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	stx $86.b		; 86 86 ; Store X register to $86.b [Reads: X Index]
	eor ($57.b,S),Y		; 53 57 ; XOR accumulator (stack relative indirect indexed) ($57.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ora $1717.w,X		; 1D 17 17 ; OR accumulator with memory $1717.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	trb $1191.w		; 1C 91 11 ; Test and reset bits $1191.w [Reads: Accumulator] [Flags: Z]
	bit $2B.b,X		; 34 2B ; Test bits $2B.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $02DC.w		; 2C DC 02 ; Test bits $02DC.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	jsr $8530.w		; 20 30 85 ; Jump to subroutine at $8530.w [Writes: Stack Pointer] [Flow: call]
	eor ($57.b,S),Y		; 53 57 ; XOR accumulator (stack relative indirect indexed) ($57.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $10, $12		; 10 12 ; Branch if plus to $10, $12 [Flow: branch]
	ora ($1F.b),Y		; 11 1F ; OR accumulator with memory ($1F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $1F99.w,Y		; 99 99 1F ; Store accumulator to $1F99.w,Y [Reads: Y Index, Accumulator]
	eor ($53.b),Y		; 51 53 ; Exclusive OR accumulator with memory ($53.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $208998.l,X		; 1F 98 89 20 ; Logical OR long $208998.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	ora [$98.b],Y		; 17 98 ; OR accumulator with memory (long indexed) [$98.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta ($51.b,X)		; 81 51 ; Store accumulator ($51.b,X) [Reads: Direct Page, Accumulator, X Index]
	lsr $5F50.w,X		; 5E 50 5F ; Logical shift right $5F50.w,X [Reads: X Index] [Flags: NCZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	eor ($50.b,S),Y		; 53 50 ; XOR accumulator (stack relative indirect indexed) ($50.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $34.b,X		; 95 34 ; Store accumulator to $34.b,X [Reads: Accumulator, X Index]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $80, $39		; 80 39 ; Branch always to $80, $39 [Flow: branch]
	bit $6B.b,X		; 34 6B ; Test bits $6B.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $50, $20		; 50 20 ; Branch if overflow clear to $50, $20 [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	bit $53.b		; 24 53 ; Test bits $53.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($90.b)		; 12 90 ; OR accumulator with memory (indirect) ($90.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc ($34.b)		; F2 34 ; Subtract with carry (indirect) ($34.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	bit $21.b		; 24 21 ; Test bits $21.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora ($5B.b,X)		; 01 5B ; Logical OR ($5B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $89.b,X		; 34 89 ; Test bits $89.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and [$10.b],Y		; 37 10 ; AND accumulator with memory (long indexed) [$10.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $82, $28, $5B		; 82 28 5B ; Branch always long to $82, $28, $5B [Flow: branch]
	adc $89910C.l,X		; 7F 0C 91 89 ; Add long $89910C.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $2C.b,X		; 34 2C ; Test bits $2C.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	ora #$3118.w		; 09 18 31 ; Logical OR #$3118.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and ($34.b,S),Y		; 33 34 ; AND accumulator (stack relative indirect indexed) ($34.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $99.b,X		; 36 99 ; Rotate left $99.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sta $3278.w,Y		; 99 78 32 ; Store accumulator to $3278.w,Y [Reads: Y Index, Accumulator]
	bit $71.b,X		; 34 71 ; Test bits $71.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora $7E08.w,Y		; 19 08 7E ; OR accumulator with memory $7E08.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	eor $80.b,S		; 43 80 ; Exclusive OR accumulator with stack relative $80.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora #$8645.w		; 09 45 86 ; Logical OR #$8645.w with accumulator [Writes: Accumulator] [Flags: NZ]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sta ($00.b),Y		; 91 00 ; Store accumulator ($00.b),Y [Reads: Direct Page, Y Index, Accumulator]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $89.b,X		; 34 89 ; Test bits $89.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($95.b),Y		; 71 95 ; Add with carry ($95.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	ror $8888.w,X		; 7E 88 88 ; Rotate right $8888.w,X [Reads: X Index] [Flags: NCZ]
	adc ($66.b),Y		; 71 66 ; Add with carry ($66.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $50.b,X		; 55 50 ; Exclusive OR accumulator with memory $50.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ror $588A.w		; 6E 8A 58 ; Rotate right $588A.w [Flags: NCZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl $8050.w		; 0E 50 80 ; Arithmetic shift left $8050.w [Flags: NCZ]
	sta $8B88.w,Y		; 99 88 8B ; Store accumulator to $8B88.w,Y [Reads: Y Index, Accumulator]
	adc $888280.l,X		; 7F 80 82 88 ; Add long $888280.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta $87.b,S		; 83 87 ; Store accumulator (stack relative) $87.b,S [Reads: Stack Pointer, Accumulator]
	.db $50, $DB		; 50 DB ; Branch if overflow clear to $50, $DB [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta [$D6.b]		; 87 D6 ; Store accumulator (long) [$D6.b] [Reads: Direct Page, Accumulator]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	dec $77.b		; C6 77 ; Decrement $77.b [Reads: Direct Page] [Flags: NZ]
	adc [$50.b],Y		; 77 50 ; Add with carry (long indexed) [$50.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta [$1A.b],Y		; 97 1A ; Store accumulator (long indexed) [$1A.b],Y [Reads: Direct Page, Y Index, Accumulator]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	sta [$87.b],Y		; 97 87 ; Store accumulator (long indexed) [$87.b],Y [Reads: Direct Page, Y Index, Accumulator]
	lda $4646.w		; AD 46 46 ; Load $4646.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $78		; D0 78 ; Branch if not equal to $D0, $78 [Flow: branch]
	sta [$C6.b]		; 87 C6 ; Store accumulator (long) [$C6.b] [Reads: Direct Page, Accumulator]
	sec		; 38 ; Set carry flag [Flags: C]
	eor ($32.b,S),Y		; 53 32 ; XOR accumulator (stack relative indirect indexed) ($32.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $EEC6.w,Y		; F9 C6 EE ; Subtract with carry $EEC6.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr $7877.w		; 4E 77 78 ; Logical shift right $7877.w [Flags: NCZ]
	jmp $4E4E.w		; 4C 4E 4E ; Jump to $4E4E.w [Flow: jump]
	dec $88.b		; C6 88 ; Decrement $88.b [Reads: Direct Page] [Flags: NZ]
	sta [$C6.b]		; 87 C6 ; Store accumulator (long) [$C6.b] [Reads: Direct Page, Accumulator]
	sta [$D1.b],Y		; 97 D1 ; Store accumulator (long indexed) [$D1.b],Y [Reads: Direct Page, Y Index, Accumulator]
	dec $77.b		; C6 77 ; Decrement $77.b [Reads: Direct Page] [Flags: NZ]
	adc [$C2.b],Y		; 77 C2 ; Add with carry (long indexed) [$C2.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $C6.b,S		; C3 C6 ; Compare accumulator (stack relative) $C6.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	.db $D0, $77		; D0 77 ; Branch if not equal to $D0, $77 [Flow: branch]
	adc [$D7.b],Y		; 77 D7 ; Add with carry (long indexed) [$D7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $CF.b		; C6 CF ; Decrement $CF.b [Reads: Direct Page] [Flags: NZ]
	cmp ($77.b),Y		; D1 77 ; Compare accumulator ($77.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	adc [$4A.b],Y		; 77 4A ; Add with carry (long indexed) [$4A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $A5F3.w		; EE F3 A5 ; Increment $A5F3.w [Flags: NZ]
	sta [$77.b]		; 87 77 ; Store accumulator (long) [$77.b] [Reads: Direct Page, Accumulator]
	cmp [$45.b],Y		; D7 45 ; Compare accumulator (long indexed) [$45.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	ora $97.b,S		; 03 97 ; OR accumulator with stack relative $97.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sta [$D6.b]		; 87 D6 ; Store accumulator (long) [$D6.b] [Reads: Direct Page, Accumulator]
	cmp [$40.b],Y		; D7 40 ; Compare accumulator (long indexed) [$40.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	stz $8777.w,X		; 9E 77 87 ; Store zero to $8777.w,X [Reads: X Index]
	cmp [$97.b],Y		; D7 97 ; Compare accumulator (long indexed) [$97.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cmp [$EF.b],Y		; D7 EF ; Compare accumulator (long indexed) [$EF.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta [$D7.b],Y		; 97 D7 ; Store accumulator (long indexed) [$D7.b],Y [Reads: Direct Page, Y Index, Accumulator]
	ldx $DB.b		; A6 DB ; Load $DB.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
.INDEX 16
	rep #$D7		; C2 D7
	cmp $0F.b		; C5 0F ; Compare $0F.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	adc [$78.b],Y		; 77 78 ; Add with carry (long indexed) [$78.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($C3.b,X)		; 21 C3 ; Logical AND ($C3.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp #$874A.w		; C9 4A 87 ; Compare #$874A.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	dec $4E.b		; C6 4E ; Decrement $4E.b [Reads: Direct Page] [Flags: NZ]
	cmp [$B3.b],Y		; D7 B3 ; Compare accumulator (long indexed) [$B3.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	adc $D477.w,Y		; 79 77 D4 ; Add $D477.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy $25.b,X		; B4 25 ; Load Y register $25.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	cmp $77.b		; C5 77 ; Compare $77.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sta [$C6.b]		; 87 C6 ; Store accumulator (long) [$C6.b] [Reads: Direct Page, Accumulator]
	dec $43.b		; C6 43 ; Decrement $43.b [Reads: Direct Page] [Flags: NZ]
	lda #$8777.w		; A9 77 87 ; Load #$8777.w into accumulator [Writes: Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	cmp [$C5.b],Y		; D7 C5 ; Compare accumulator (long indexed) [$C5.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda $7777.w		; AD 77 77 ; Load $7777.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy $A6.b		; A4 A6 ; Load $A6.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	lda $D5.b		; A5 D5 ; Load $D5.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cmp $C3.b,S		; C3 C3 ; Compare accumulator (stack relative) $C3.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	cmp #$7777.w		; C9 77 77 ; Compare #$7777.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	rep #$C3		; C2 C3 ; Reset processor status bits #$C3 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	cop $1A.b		; 02 1A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc [$88.b],Y		; 77 88 ; Add with carry (long indexed) [$88.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $D0, $0D		; D0 0D ; Branch if not equal to $D0, $0D [Flow: branch]
	sbc ($EE.b,S),Y		; F3 EE ; Subtract with carry (stack relative indirect indexed) ($EE.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	adc [$97.b],Y		; 77 97 ; Add with carry (long indexed) [$97.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($F3.b)		; F2 F3 ; Subtract with carry (indirect) ($F3.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	adc [$79.b],Y		; 77 79 ; Add with carry (long indexed) [$79.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	rol $CA.b,X		; 36 CA ; Rotate left $CA.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sta [$07.b]		; 87 07 ; Store accumulator (long) [$07.b] [Reads: Direct Page, Accumulator]
	and $41.b		; 25 41 ; Logical AND $41.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $D4.b		; 45 D4 ; Exclusive OR $D4.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta [$B5.b]		; 87 B5 ; Store accumulator (long) [$B5.b] [Reads: Direct Page, Accumulator]
	ora $B4.b,S		; 03 B4 ; OR accumulator with stack relative $B4.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $78.b		; 25 78 ; Logical AND $78.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	eor ($D5.b,X)		; 41 D5 ; Exclusive OR accumulator with memory ($D5.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lda ($AF.b,S),Y		; B3 AF ; Load accumulator (stack relative indirect indexed) ($AF.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta [$77.b]		; 87 77 ; Store accumulator (long) [$77.b] [Reads: Direct Page, Accumulator]
	lsr $C1.b		; 46 C1 ; Logical shift right $C1.b [Reads: Direct Page] [Flags: NCZ]
	sep #$C2		; E2 C2 ; Set processor status bits #$C2 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	sta [$77.b]		; 87 77 ; Store accumulator (long) [$77.b] [Reads: Direct Page, Accumulator]
	rol $DA.b,X		; 36 DA ; Rotate left $DA.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	bit $07C5.w		; 2C C5 07 ; Test bits $07C5.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	sta [$3D.b]		; 87 3D ; Store accumulator (long) [$3D.b] [Reads: Direct Page, Accumulator]
	dec $2E.b		; C6 2E ; Decrement $2E.b [Reads: Direct Page] [Flags: NZ]
	ora $8887.w		; 0D 87 88 ; Logical OR $8887.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp $F8.b		; C5 F8 ; Compare $F8.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	eor $77C2.w		; 4D C2 77 ; Exclusive OR $77C2.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta [$C3.b],Y		; 97 C3 ; Store accumulator (long indexed) [$C3.b],Y [Reads: Direct Page, Y Index, Accumulator]
	sbc ($0F.b,S),Y		; F3 0F ; Subtract with carry (stack relative indirect indexed) ($0F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	dec $77.b		; C6 77 ; Decrement $77.b [Reads: Direct Page] [Flags: NZ]
	and [$4E.b]		; 27 4E ; AND accumulator with memory (long) [$4E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	sta $098954.l,X		; 9F 54 89 09 ; Store accumulator (long,X) $098954.l,X [Reads: Accumulator, X Index]
	jmp.w [$4E1D]		; DC 1D 4E ; Jump long indirect [$4E1D] [Flow: jump]
	lda $8778.w,X		; BD 78 87 ; Load $8778.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	sta $E7E5.w,Y		; 99 E5 E7 ; Store accumulator to $E7E5.w,Y [Reads: Y Index, Accumulator]
	sta [$77.b]		; 87 77 ; Store accumulator (long) [$77.b] [Reads: Direct Page, Accumulator]
	cmp #$5917.w		; C9 17 59 ; Compare #$5917.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	sta $72.b,X		; 95 72 ; Store accumulator to $72.b,X [Reads: Accumulator, X Index]
	sta [$20.b],Y		; 97 20 ; Store accumulator (long indexed) [$20.b],Y [Reads: Direct Page, Y Index, Accumulator]
	ora [$C6.b],Y		; 17 C6 ; OR accumulator with memory (long indexed) [$C6.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ldx $7788.w		; AE 88 77 ; Load $7788.w into X register [Writes: X Index] [Flags: NZ]
	stx $17.b,Y		; 96 17 ; Store X register $17.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	cmp $7778AA.l		; CF AA 78 77 ; Compare accumulator (long) $7778AA.l [Reads: Accumulator] [Flags: NCZ]
	lda #$AAA8.w		; A9 A8 AA ; Load #$AAA8.w into accumulator [Writes: Accumulator] [Flags: NZ]
	dec $77.b		; C6 77 ; Decrement $77.b [Reads: Direct Page] [Flags: NZ]
	adc [$C4.b],Y		; 77 C4 ; Add with carry (long indexed) [$C4.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy $BB.b		; C4 BB ; Compare $BB.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	lda $7777.w		; AD 77 77 ; Load $7777.w into accumulator [Writes: Accumulator] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda [$F9.b],Y		; B7 F9 ; Load accumulator (long indexed) [$F9.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta [$77.b],Y		; 97 77 ; Store accumulator (long indexed) [$77.b],Y [Reads: Direct Page, Y Index, Accumulator]
	eor #$4EC5.w		; 49 C5 4E ; Exclusive OR #$4EC5.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp $87.b		; C5 87 ; Compare $87.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sta [$AE.b]		; 87 AE ; Store accumulator (long) [$AE.b] [Reads: Direct Page, Accumulator]
	wai		; CB ; Wait for interrupt
	rep #$C3		; C2 C3 ; Reset processor status bits #$C3 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $40.b		; C6 40 ; Decrement $40.b [Reads: Direct Page] [Flags: NZ]
	ora $B4.b,S		; 03 B4 ; OR accumulator with stack relative $B4.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sta [$AD.b]		; 87 AD ; Store accumulator (long) [$AD.b] [Reads: Direct Page, Accumulator]
.ACCU 16
.INDEX 16
	rep #$F3		; C2 F3
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
.INDEX 16
	rep #$13		; C2 13
	adc [$78.b],Y		; 77 78 ; Add with carry (long indexed) [$78.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($C6.b),Y		; 51 C6 ; Exclusive OR accumulator with memory ($C6.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	dec $F1.b		; C6 F1 ; Decrement $F1.b [Reads: Direct Page] [Flags: NZ]
	sta [$77.b],Y		; 97 77 ; Store accumulator (long indexed) [$77.b],Y [Reads: Direct Page, Y Index, Accumulator]
	ora $C5A535.l,X		; 1F 35 A5 C5 ; Logical OR long $C5A535.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	adc [$C6.b],Y		; 77 C6 ; Add with carry (long indexed) [$C6.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $33.b,X		; 36 33 ; Rotate left $33.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	adc $70.b,S		; 63 70 ; Add with carry (stack relative) $70.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	bit #$C640.w		; 89 40 C6 ; Test bits #$C640.w with accumulator [Reads: Accumulator] [Flags: Z]
	lda $87DB.w		; AD DB 87 ; Load $87DB.w into accumulator [Writes: Accumulator] [Flags: NZ]
	adc [$C6.b],Y		; 77 C6 ; Add with carry (long indexed) [$C6.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $B4.b		; A5 B4 ; Load $B4.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $77.b		; 45 77 ; Exclusive OR $77.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora $B4.b,S		; 03 B4 ; OR accumulator with stack relative $B4.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $24.b		; 45 24 ; Exclusive OR $24.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta [$88.b]		; 87 88 ; Store accumulator (long) [$88.b] [Reads: Direct Page, Accumulator]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	eor ($13.b),Y		; 51 13 ; Exclusive OR accumulator with memory ($13.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $89.b,X		; 34 89 ; Test bits $89.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $64.b		; 00 64 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy $66.b		; C4 66 ; Compare $66.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	ror $90.b		; 66 90 ; Rotate right $90.b [Reads: Direct Page] [Flags: NCZ]
	sta $CF67.w,Y		; 99 67 CF ; Store accumulator to $CF67.w,Y [Reads: Y Index, Accumulator]
	adc #$906A.w		; 69 6A 90 ; Add #$906A.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $6EDA.w,Y		; 99 DA 6E ; Store accumulator to $6EDA.w,Y [Reads: Y Index, Accumulator]
	ror $C8.b		; 66 C8 ; Rotate right $C8.b [Reads: Direct Page] [Flags: NCZ]
	ora ($90.b,X)		; 01 90 ; Logical OR ($90.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp $6AC8.w,X		; DD C8 6A ; Compare accumulator $6AC8.w,X [Reads: X Index] [Flags: NCZ]
	adc $669900.l		; 6F 00 99 66 ; Add with carry (long) $669900.l [Writes: Accumulator] [Flags: NCVZ]
	lda #$D3C8.w		; A9 C8 D3 ; Load #$D3C8.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($00.b)		; 92 00 ; Store accumulator (indirect) ($00.b) [Reads: Direct Page, Accumulator]
	adc ($74.b,X)		; 61 74 ; Add with carry ($74.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $291972.l,X		; 3F 72 19 29 ; AND accumulator with memory (long,X) $291972.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy $CA.b		; C4 CA ; Compare $CA.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	cmp [$D8.b],Y		; D7 D8 ; Compare accumulator (long indexed) [$D8.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	brk $33.b		; 00 33 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $A2C4.w		; AC C4 A2 ; Load $A2C4.w into Y register [Writes: Y Index] [Flags: NZ]
	cmp $343320.l,X		; DF 20 33 34 ; Compare accumulator (long,X) $343320.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	ror $DB.b,X		; 76 DB ; Rotate right $DB.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	pei ($01.b)		; D4 01 ; Push effective indirect address ($01.b) [Reads: Direct Page] [Writes: Stack Pointer]
	brk $2A.b		; 00 2A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $37.b,X		; 34 37 ; Test bits $37.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $30.b,X		; 34 30 ; Test bits $30.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	jsr $3432.w		; 20 32 34 ; Jump to subroutine at $3432.w [Writes: Stack Pointer] [Flow: call]
	cmp #$2024.w		; C9 24 20 ; Compare #$2024.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora [$C9.b]		; 07 C9 ; OR accumulator with memory (long) [$C9.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	stx $854B.w		; 8E 4B 85 ; Store X register to $854B.w [Reads: X Index]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	jmp ($9250.w)		; 6C 50 92 ; Jump indirect to ($9250.w) [Flow: jump]
	cmp #$8011.w		; C9 11 80 ; Compare #$8011.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	adc ($AC.b,X)		; 61 AC ; Add with carry ($AC.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc [$78.b],Y		; 77 78 ; Add with carry (long indexed) [$78.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $92		; 10 92 ; Branch if plus to $10, $92 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cmp #$2292.w		; C9 92 22 ; Compare #$2292.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sty $92.b,X		; 94 92 ; Store Y register $92.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	cmp #$8880.w		; C9 80 88 ; Compare #$8880.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cop $7D.b		; 02 7D ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jsr $9282.w		; 20 82 92 ; Jump to subroutine at $9282.w [Writes: Stack Pointer] [Flow: call]
	and #$8383.w		; 29 83 83 ; Logical AND #$8383.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sta $92.b,S		; 83 92 ; Store accumulator (stack relative) $92.b,S [Reads: Stack Pointer, Accumulator]
	and #$7978.w		; 29 78 79 ; Logical AND #$7978.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sty $7F.b		; 84 7F ; Store Y register to $7F.b [Reads: Y Index]
	and #$7821.w		; 29 21 78 ; Logical AND #$7821.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sta [$89.b]		; 87 89 ; Store accumulator (long) [$89.b] [Reads: Direct Page, Accumulator]
	jsl $7B7F22.l		; 22 22 7F 7B ; Jump to subroutine long $7B7F22.l [Writes: Stack Pointer] [Flow: call]
	stx $83.b		; 86 83 ; Store X register to $83.b [Reads: X Index]
	ora $2392.w,Y		; 19 92 23 ; OR accumulator with memory $2392.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	bit #$9291.w		; 89 91 92 ; Test bits #$9291.w with accumulator [Reads: Accumulator] [Flags: Z]
	jsl $899329.l		; 22 29 93 89 ; Jump to subroutine long $899329.l [Writes: Stack Pointer] [Flow: call]
	sta ($78.b,X)		; 81 78 ; Store accumulator ($78.b,X) [Reads: Direct Page, Accumulator, X Index]
	sta ($22.b)		; 92 22 ; Store accumulator (indirect) ($22.b) [Reads: Direct Page, Accumulator]
	sta $83.b,X		; 95 83 ; Store accumulator to $83.b,X [Reads: Accumulator, X Index]
	and [$78.b]		; 27 78 ; AND accumulator with memory (long) [$78.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($12.b)		; 92 12 ; Store accumulator (indirect) ($12.b) [Reads: Direct Page, Accumulator]
	sty $78.b		; 84 78 ; Store Y register to $78.b [Reads: Y Index]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	adc ($92.b,S),Y		; 73 92 ; Add with carry (stack relative indirect indexed) ($92.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	sta ($78.b,X)		; 81 78 ; Store accumulator ($78.b,X) [Reads: Direct Page, Accumulator, X Index]
	adc $9286.w,X		; 7D 86 92 ; Add $9286.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $8050.w,Y		; 99 50 80 ; Store accumulator to $8050.w,Y [Reads: Y Index, Accumulator]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $82, $12, $29		; 82 12 29 ; Branch always long to $82, $12, $29 [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	stx $92.b		; 86 92 ; Store X register to $92.b [Reads: X Index]
	jsl $78787B.l		; 22 7B 78 78 ; Jump to subroutine long $78787B.l [Writes: Stack Pointer] [Flow: call]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	sta ($29.b)		; 92 29 ; Store accumulator (indirect) ($29.b) [Reads: Direct Page, Accumulator]
	adc $239D.w,Y		; 79 9D 23 ; Add $239D.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	and #$8229.w		; 29 29 82 ; Logical AND #$8229.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ror $9278.w,X		; 7E 78 92 ; Rotate right $9278.w,X [Reads: X Index] [Flags: NCZ]
	sta ($79.b)		; 92 79 ; Store accumulator (indirect) ($79.b) [Reads: Direct Page, Accumulator]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sta $832929.l,X		; 9F 29 29 83 ; Store accumulator (long,X) $832929.l,X [Reads: Accumulator, X Index]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ldy #$9276.w		; A0 76 92 ; Load #$9276.w into Y register [Writes: Y Index] [Flags: NZ]
	sta $34DC.w,Y		; 99 DC 34 ; Store accumulator to $34DC.w,Y [Reads: Y Index, Accumulator]
	adc $0094.w		; 6D 94 00 ; Add $0094.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	stx $87.b		; 86 87 ; Store X register to $87.b [Reads: X Index]
	adc $7C.b,S		; 63 7C ; Add with carry (stack relative) $7C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	jsl $868119.l		; 22 19 81 86 ; Jump to subroutine long $868119.l [Writes: Stack Pointer] [Flow: call]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	adc $22.b		; 65 22 ; Add $22.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jsl $898D8C.l		; 22 8C 8D 89 ; Jump to subroutine long $898D8C.l [Writes: Stack Pointer] [Flow: call]
	adc $2222.w,Y		; 79 22 22 ; Add $2222.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $8C.b,S		; 83 8C ; Store accumulator (stack relative) $8C.b,S [Reads: Stack Pointer, Accumulator]
	adc $927B.w,Y		; 79 7B 92 ; Add $927B.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $13137F.l		; 22 7F 13 13 ; Jump to subroutine long $13137F.l [Writes: Stack Pointer] [Flow: call]
	trb $23.b		; 14 23 ; Test and reset bits $23.b [Reads: Accumulator] [Flags: Z]
	and ($1D.b,S),Y		; 33 1D ; AND accumulator (stack relative indirect indexed) ($1D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	cmp $32E4.w		; CD E4 32 ; Compare $32E4.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsl $D9D9D9.l		; 22 D9 D9 D9 ; Jump to subroutine long $D9D9D9.l [Writes: Stack Pointer] [Flow: call]
	cmp $2222.w		; CD 22 22 ; Compare $2222.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp $DAC6.w		; CD C6 DA ; Compare $DAC6.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp $2222.w		; CD 22 22 ; Compare $2222.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cpy $9D.b		; C4 9D ; Compare $9D.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	bit $25.b		; 24 25 ; Test bits $25.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora $33.b,S		; 03 33 ; OR accumulator with stack relative $33.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $25.b		; 25 25 ; Logical AND $25.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $FB.b		; 25 FB ; Logical AND $FB.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($32.b,S),Y		; 33 32 ; AND accumulator (stack relative indirect indexed) ($32.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	lda $C4.b,S		; A3 C4 ; Load accumulator (stack relative) $C4.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $9DF990.l		; 22 90 F9 9D ; Jump to subroutine long $9DF990.l [Writes: Stack Pointer] [Flow: call]
	cmp $23C9.w		; CD C9 23 ; Compare $23C9.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsl $393476.l		; 22 76 34 39 ; Jump to subroutine long $393476.l [Writes: Stack Pointer] [Flow: call]
	bit $10.b,X		; 34 10 ; Test bits $10.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	jsr $CDC4.w		; 20 C4 CD ; Jump to subroutine at $CDC4.w [Writes: Stack Pointer] [Flow: call]
	dec $D3.b		; C6 D3 ; Decrement $D3.b [Reads: Direct Page] [Flags: NZ]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $36.b,X		; 34 36 ; Test bits $36.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cmp $2200EB.l,X		; DF EB 00 22 ; Compare accumulator (long,X) $2200EB.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	sta $C61C01.l,X		; 9F 01 1C C6 ; Store accumulator (long,X) $C61C01.l,X [Reads: Accumulator, X Index]
	and ($10.b,S),Y		; 33 10 ; AND accumulator (stack relative indirect indexed) ($10.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $33.b		; 25 33 ; Logical AND $33.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($1C.b,S),Y		; 33 1C ; AND accumulator (stack relative indirect indexed) ($1C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($21.b)		; 12 21 ; OR accumulator with memory (indirect) ($21.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $7C.b		; 24 7C ; Test bits $7C.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	adc ($62.b,X)		; 61 62 ; Add with carry ($62.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ror $60.b		; 66 60 ; Rotate right $60.b [Reads: Direct Page] [Flags: NCZ]
	cmp $66.b,X		; D5 66 ; Compare accumulator $66.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($01.b),Y		; 11 01 ; OR accumulator with memory ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	dec $A59E.w		; CE 9E A5 ; Decrement $A59E.w [Flags: NZ]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $5CE4.w,Y		; 19 E4 5C ; OR accumulator with memory $5CE4.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and [$71.b],Y		; 37 71 ; AND accumulator with memory (long indexed) [$71.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc [$20.b]		; 67 20 ; Add with carry (long) [$20.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	rol $36.b,X		; 36 36 ; Rotate left $36.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	rol $36.b,X		; 36 36 ; Rotate left $36.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($12.b,S),Y		; 13 12 ; OR accumulator (stack relative indirect indexed) ($12.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $34.b,X		; 36 34 ; Rotate left $34.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $34.b,X		; 36 34 ; Rotate left $34.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $F2.b,X		; 34 F2 ; Test bits $F2.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and $002F.w		; 2D 2F 00 ; Logical AND $002F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and ($0A.b,S),Y		; 33 0A ; AND accumulator (stack relative indirect indexed) ($0A.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $6CFF.w,Y		; 79 FF 6C ; Add $6CFF.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jmp ($6C6C.w)		; 6C 6C 6C ; Jump indirect to ($6C6C.w) [Flow: jump]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cmp #$0AA6.w		; C9 A6 0A ; Compare #$0AA6.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $10, $90		; 10 90 ; Branch if plus to $10, $90 [Flow: branch]
	sbc [$F9.b],Y		; F7 F9 ; Subtract with carry (long indexed) [$F9.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	cpx $3033.w		; EC 33 30 ; Compare $3033.w with X register [Reads: X Index] [Flags: NCZ]
	trb $FC.b		; 14 FC ; Test and reset bits $FC.b [Reads: Accumulator] [Flags: Z]
	inc $03FF.w,X		; FE FF 03 ; Increment memory $03FF.w,X [Reads: X Index] [Flags: NZ]
	and ($F0.b,S),Y		; 33 F0 ; AND accumulator (stack relative indirect indexed) ($F0.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tsb $040B.w		; 0C 0B 04 ; Test and set bits $040B.w [Reads: Accumulator] [Flags: Z]
	mvp $14,$36		; 44 36 14 ; Move block positive $14,$36 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	jmp $0434.w		; 4C 34 04 ; Jump to $0434.w [Flow: jump]
	.db $70, $FF		; 70 FF ; Branch if overflow set to $70, $FF [Flow: branch]
	sbc $11340F.l,X		; FF 0F 34 11 ; Subtract with carry (long,X) $11340F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr $1736.w		; 20 36 17 ; Jump to subroutine at $1736.w [Writes: Stack Pointer] [Flow: call]
	cpy $0A.b		; C4 0A ; Compare $0A.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	cop $11.b		; 02 11 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $36.b,X		; 34 36 ; Test bits $36.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	cmp $5500.w,X		; DD 00 55 ; Compare accumulator $5500.w,X [Reads: X Index] [Flags: NCZ]
	cmp $EAE834.l,X		; DF 34 E8 EA ; Compare accumulator (long,X) $EAE834.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	.db $50, $55		; 50 55 ; Branch if overflow clear to $50, $55 [Flow: branch]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and $50.b,X		; 35 50 ; Logical AND $50.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $71.b		; 00 71 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($34.b),Y		; 71 34 ; Add with carry ($34.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	ora ($98.b,X)		; 01 98 ; Logical OR ($98.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ror $39.b,X		; 76 39 ; Rotate right $39.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	adc ($31.b,S),Y		; 73 31 ; Add with carry (stack relative indirect indexed) ($31.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora ($CD.b)		; 12 CD ; OR accumulator with memory (indirect) ($CD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	stx $36.b		; 86 36 ; Store X register to $36.b [Reads: X Index]
	cmp #$0020.w		; C9 20 00 ; Compare #$0020.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	rol $34.b,X		; 36 34 ; Rotate left $34.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ldy $0034.w		; AC 34 00 ; Load $0034.w into Y register [Writes: Y Index] [Flags: NZ]
	jsr $C934.w		; 20 34 C9 ; Jump to subroutine at $C934.w [Writes: Stack Pointer] [Flow: call]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $EF.b,X		; 36 EF ; Rotate left $EF.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sta $0101F3.l,X		; 9F F3 01 01 ; Store accumulator (long,X) $0101F3.l,X [Reads: Accumulator, X Index]
	sbc $A5A3A1.l,X		; FF A1 A3 A5 ; Subtract with carry (long,X) $A5A3A1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $01		; 10 01 ; Branch if plus to $10, $01 [Flow: branch]
	inc $A5.b,X		; F6 A5 ; Increment memory $A5.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	pea $11A5.w		; F4 A5 11 ; Push absolute address $11A5.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	.db $10, $A5		; 10 A5 ; Branch if plus to $10, $A5 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	bit $26.b,X		; 34 26 ; Test bits $26.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	adc $2779.w,Y		; 79 79 27 ; Add $2779.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $D0, $00		; D0 00 ; Branch if not equal to $D0, $00 [Flow: branch]
	ora ($55.b)		; 12 55 ; OR accumulator with memory (indirect) ($55.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc $E7.b,X		; 75 E7 ; Add $E7.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($11.b),Y		; 31 11 ; AND accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cmp $10A953.l,X		; DF 53 A9 10 ; Compare accumulator (long,X) $10A953.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	.db $10, $34		; 10 34 ; Branch if plus to $10, $34 [Flow: branch]
	and $A9.b,X		; 35 A9 ; Logical AND $A9.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc #$0300.w		; 69 00 03 ; Add #$0300.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	bit $76.b,X		; 34 76 ; Test bits $76.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	lda #$0376.w		; A9 76 03 ; Load #$0376.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $34.b,S		; 03 34 ; OR accumulator with stack relative $34.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $AA.b,X		; 34 AA ; Test bits $AA.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $90, $AA		; 90 AA ; Branch if carry clear to $90, $AA [Flow: branch]
	bit $0F.b,X		; 34 0F ; Test bits $0F.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	lda $2290.w		; AD 90 22 ; Load $2290.w into accumulator [Writes: Accumulator] [Flags: NZ]
	jmp ($3634.w)		; 6C 34 36 ; Jump indirect to ($3634.w) [Flow: jump]
	lda ($10.b),Y		; B1 10 ; Load accumulator ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora #$B1B3.w		; 09 B3 B1 ; Logical OR #$B1B3.w with accumulator [Writes: Accumulator] [Flags: NZ]
	bit $7E.b,X		; 34 7E ; Test bits $7E.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sta $E303.w,Y		; 99 03 E3 ; Store accumulator to $E303.w,Y [Reads: Y Index, Accumulator]
	lda ($36.b,S),Y		; B3 36 ; Load accumulator (stack relative indirect indexed) ($36.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ora #$B309.w		; 09 09 B3 ; Logical OR #$B309.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sta $AD00.w,Y		; 99 00 AD ; Store accumulator to $AD00.w,Y [Reads: Y Index, Accumulator]
	lda $B3B1.w		; AD B1 B3 ; Load $B3B1.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $B199.w,Y		; 99 99 B1 ; Store accumulator to $B199.w,Y [Reads: Y Index, Accumulator]
	ldy $ED34.w		; AC 34 ED ; Load $ED34.w into Y register [Writes: Y Index] [Flags: NZ]
	sta $E602.w,Y		; 99 02 E6 ; Store accumulator to $E602.w,Y [Reads: Y Index, Accumulator]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and $2184.w,Y		; 39 84 21 ; AND accumulator with memory $2184.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($C9.b,X)		; 21 C9 ; Logical AND ($C9.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc ($7E.b,X)		; E1 7E ; Subtract with carry ($7E.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $30, $34		; 30 34 ; Branch if minus to $30, $34 [Flow: branch]
	bit $36.b,X		; 34 36 ; Test bits $36.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	cop $E1.b		; 02 E1 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($E1.b)		; F2 E1 ; Subtract with carry (indirect) ($E1.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $B0, $00		; B0 00 ; Branch if carry set to $B0, $00 [Flow: branch]
	ora #$F6F6.w		; 09 F6 F6 ; Logical OR #$F6F6.w with accumulator [Writes: Accumulator] [Flags: NZ]
	inc $AA.b,X		; F6 AA ; Increment memory $AA.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	eor $59.b,X		; 55 59 ; Exclusive OR accumulator with memory $59.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	rol $E1.b,X		; 36 E1 ; Rotate left $E1.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc ($F6.b,X)		; E1 F6 ; Subtract with carry ($F6.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $80.b,X		; F6 80 ; Increment memory $80.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	ror $5628.w,X		; 7E 28 56 ; Rotate right $5628.w,X [Reads: X Index] [Flags: NCZ]
	and ($B3.b)		; 32 B3 ; AND accumulator with memory (indirect) ($B3.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sty $34.b		; 84 34 ; Store Y register to $34.b [Reads: Y Index]
	bit $93.b,X		; 34 93 ; Test bits $93.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $AF.b,X		; F6 AF ; Increment memory $AF.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	lda $F69905.l		; AF 05 99 F6 ; Load long $F69905.l into accumulator [Writes: Accumulator] [Flags: NZ]
	inc $F6.b,X		; F6 F6 ; Increment memory $F6.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	bit $55.b,X		; 34 55 ; Test bits $55.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $50, $DA		; 50 DA ; Branch if overflow clear to $50, $DA [Flow: branch]
	inc $34.b,X		; F6 34 ; Increment memory $34.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda ($34.b,S),Y		; B3 34 ; Load accumulator (stack relative indirect indexed) ($34.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $36.b,S		; 83 36 ; Store accumulator (stack relative) $36.b,S [Reads: Stack Pointer, Accumulator]
	.db $90, $30		; 90 30 ; Branch if carry clear to $90, $30 [Flow: branch]
	lda ($B3.b,S),Y		; B3 B3 ; Load accumulator (stack relative indirect indexed) ($B3.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $99.b,X		; F6 99 ; Increment memory $99.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	adc $26.b		; 65 26 ; Add $26.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	rol $B3.b		; 26 B3 ; Rotate left $B3.b [Reads: Direct Page] [Flags: NCZ]
	rol $22.b		; 26 22 ; Rotate left $22.b [Reads: Direct Page] [Flags: NCZ]
	sta ($86.b)		; 92 86 ; Store accumulator (indirect) ($86.b) [Reads: Direct Page, Accumulator]
	lda ($7E.b,S),Y		; B3 7E ; Load accumulator (stack relative indirect indexed) ($7E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	adc #$AD33.w		; 69 33 AD ; Add #$AD33.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	lda $86AE.w		; AD AE 86 ; Load $86AE.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $B396.w,Y		; 99 96 B3 ; Store accumulator to $B396.w,Y [Reads: Y Index, Accumulator]
	lda ($AB.b,S),Y		; B3 AB ; Load accumulator (stack relative indirect indexed) ($AB.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda ($99.b,S),Y		; B3 99 ; Load accumulator (stack relative indirect indexed) ($99.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $34B3.w,Y		; 99 B3 34 ; Store accumulator to $34B3.w,Y [Reads: Y Index, Accumulator]
	sbc $AD.b,X		; F5 AD ; Subtract $AD.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $90, $19		; 90 19 ; Branch if carry clear to $90, $19 [Flow: branch]
	lda $AEAD.w		; AD AD AE ; Load $AEAD.w into accumulator [Writes: Accumulator] [Flags: NZ]
	lda ($99.b)		; B2 99 ; Load accumulator (indirect) ($99.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $F782.w,Y		; 99 82 F7 ; Store accumulator to $F782.w,Y [Reads: Y Index, Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	cpx $3033.w		; EC 33 30 ; Compare $3033.w with X register [Reads: X Index] [Flags: NCZ]
	jsr ($FF6F.w,X)		; FC 6F FF ; Jump to subroutine indirect indexed ($FF6F.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rol $34.b,X		; 36 34 ; Rotate left $34.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tsb $340B.w		; 0C 0B 34 ; Test and set bits $340B.w [Reads: Accumulator] [Flags: Z]
	bit $44.b,X		; 34 44 ; Test bits $44.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $C2.b		; 00 C2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($20.b,S),Y		; 13 20 ; OR accumulator (stack relative indirect indexed) ($20.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	ora ($52.b,S),Y		; 13 52 ; OR accumulator (stack relative indirect indexed) ($52.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $EDE6.w,X		; 1D E6 ED ; OR accumulator with memory $EDE6.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and [$32.b],Y		; 37 32 ; AND accumulator with memory (long indexed) [$32.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $E4C9B8.l		; 22 B8 C9 E4 ; Jump to subroutine long $E4C9B8.l [Writes: Stack Pointer] [Flow: call]
	jsr $2520.w		; 20 20 25 ; Jump to subroutine at $2520.w [Writes: Stack Pointer] [Flow: call]
	.db $42, $E6		; 42 E6 ; Reserved instruction
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	ora $0352.w,X		; 1D 52 03 ; OR accumulator with memory $0352.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$FDC7]		; DC C7 FD ; Jump long indirect [$FDC7] [Flow: jump]
	ror $20.b,X		; 76 20 ; Rotate right $20.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	and ($34.b,X)		; 21 34 ; Logical AND ($34.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $26B6.w,X		; 1D B6 26 ; OR accumulator with memory $26B6.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($91.b,X)		; 01 91 ; Logical OR ($91.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $71FE.w,X		; FD FE 71 ; Subtract with carry $71FE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $62, $22, $01		; 62 22 01 ; Push effective relative address $62, $22, $01 [Writes: Stack Pointer]
	sbc $35E6.w		; ED E6 35 ; Subtract $35E6.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sbc $2222.w,X		; FD 22 22 ; Subtract with carry $2222.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $FE.b		; E6 FE ; Increment $FE.b [Reads: Direct Page] [Flags: NZ]
	eor $112275.l,X		; 5F 75 22 11 ; Exclusive OR accumulator with memory (long,X) $112275.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	inc $35.b		; E6 35 ; Increment $35.b [Reads: Direct Page] [Flags: NZ]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	and ($1C.b,X)		; 21 1C ; Logical AND ($1C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jmp.w [$1ED4]		; DC D4 1E ; Jump long indirect [$1ED4] [Flow: jump]
	jsr $6A03.w		; 20 03 6A ; Jump to subroutine at $6A03.w [Writes: Stack Pointer] [Flow: call]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	lda $63C4.w,Y		; B9 C4 63 ; Load $63C4.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $90, $04		; 90 04 ; Branch if carry clear to $90, $04 [Flow: branch]
	trb $78ED.w		; 1C ED 78 ; Test and reset bits $78ED.w [Reads: Accumulator] [Flags: Z]
	ora ($11.b)		; 12 11 ; OR accumulator with memory (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $E3.b,S		; E3 E3 ; Subtract stack-relative $E3.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $87.b		; E6 87 ; Increment $87.b [Reads: Direct Page] [Flags: NZ]
	cpy $ED.b		; C4 ED ; Compare $ED.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	and $01.b,S		; 23 01 ; AND accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $10, $BA		; 10 BA ; Branch if plus to $10, $BA [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	ora [$29.b]		; 07 29 ; OR accumulator with memory (long) [$29.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc [$C4.b]		; 67 C4 ; Add with carry (long) [$C4.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	ror $00.b,X		; 76 00 ; Rotate right $00.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($AD.b,X)		; 01 AD ; Logical OR ($AD.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	inc $EE.b		; E6 EE ; Increment $EE.b [Reads: Direct Page] [Flags: NZ]
	and [$02.b],Y		; 37 02 ; AND accumulator with memory (long indexed) [$02.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $352429.l		; 22 29 24 35 ; Jump to subroutine long $352429.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	and ($21.b),Y		; 31 21 ; AND accumulator with memory ($21.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ldy $4F31.w,X		; BC 31 4F ; Load Y register $4F31.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	adc $97.b,S		; 63 97 ; Add with carry (stack relative) $97.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	eor ($BE.b),Y		; 51 BE ; Exclusive OR accumulator with memory ($BE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	dec $68.b		; C6 68 ; Decrement $68.b [Reads: Direct Page] [Flags: NZ]
	and ($90.b,S),Y		; 33 90 ; AND accumulator (stack relative indirect indexed) ($90.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($33.b)		; 12 33 ; OR accumulator with memory (indirect) ($33.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($33.b,S),Y		; 33 33 ; AND accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora #$2122.w		; 09 22 21 ; Logical OR #$2122.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and ($6C.b,S),Y		; 33 6C ; AND accumulator (stack relative indirect indexed) ($6C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	rol $71.b,X		; 36 71 ; Rotate left $71.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $30, $6A		; 30 6A ; Branch if minus to $30, $6A [Flow: branch]
	jmp ($7793.w)		; 6C 93 77 ; Jump indirect to ($7793.w) [Flow: jump]
	and ($33.b,S),Y		; 33 33 ; AND accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $BF98.w,Y		; 79 98 BF ; Add $BF98.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $30, $93		; 30 93 ; Branch if minus to $30, $93 [Flow: branch]
	inc $03.b,X		; F6 03 ; Increment memory $03.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	cmp $06.b,S		; C3 06 ; Compare accumulator (stack relative) $06.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	bit $94.b,X		; 34 94 ; Test bits $94.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cmp $C5.b		; C5 C5 ; Compare $C5.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	dec $C3.b		; C6 C3 ; Decrement $C3.b [Reads: Direct Page] [Flags: NZ]
	sta $C895.w,Y		; 99 95 C8 ; Store accumulator to $C895.w,Y [Reads: Y Index, Accumulator]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cmp #$99CA.w		; C9 CA 99 ; Compare #$99CA.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	sta ($35.b,S),Y		; 93 35 ; Store accumulator (stack relative indirect indexed) ($35.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	ora $33.b,S		; 03 33 ; OR accumulator with stack relative $33.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $D434D3.l		; CF D3 34 D4 ; Compare accumulator (long) $D434D3.l [Reads: Accumulator] [Flags: NCZ]
	sta $D609.w,Y		; 99 09 D6 ; Store accumulator to $D609.w,Y [Reads: Y Index, Accumulator]
	trb $DD1C.w		; 1C 1C DD ; Test and reset bits $DD1C.w [Reads: Accumulator] [Flags: Z]
	sty $49.b,X		; 94 49 ; Store Y register $49.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	dec $DADA.w,X		; DE DA DA ; Decrement memory $DADA.w,X [Reads: X Index] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	sta $F699.w,Y		; 99 99 F6 ; Store accumulator to $F699.w,Y [Reads: Y Index, Accumulator]
	cmp $E0DE.w,X		; DD DE E0 ; Compare accumulator $E0DE.w,X [Reads: X Index] [Flags: NCZ]
	and $E099.w,Y		; 39 99 E0 ; AND accumulator with memory $E099.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
.ACCU 8
	sep #$EA		; E2 EA
	bit $99.b,X		; 34 99 ; Test bits $99.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $30, $34		; 30 34 ; Branch if minus to $30, $34 [Flow: branch]
	wai		; CB ; Wait for interrupt
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	eor $E5.b,S		; 43 E5 ; Exclusive OR accumulator with stack relative $E5.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $E9.b,S		; E3 E9 ; Subtract stack-relative $E9.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	pei ($99.b)		; D4 99 ; Push effective indirect address ($99.b) [Reads: Direct Page] [Writes: Stack Pointer]
	sta $6B34.w,Y		; 99 34 6B ; Store accumulator to $6B34.w,Y [Reads: Y Index, Accumulator]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	asl $11.b		; 06 11 ; Arithmetic shift left $11.b [Reads: Direct Page] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	and [$34.b]		; 27 34 ; AND accumulator with memory (long) [$34.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror $0611.w		; 6E 11 06 ; Rotate right $0611.w [Flags: NCZ]
	brk $27.b		; 00 27 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $36.b,X		; 34 36 ; Test bits $36.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	eor ($30.b,X)		; 41 30 ; Exclusive OR accumulator with memory ($30.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and [$34.b]		; 27 34 ; AND accumulator with memory (long) [$34.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and [$F6.b]		; 27 F6 ; AND accumulator with memory (long) [$F6.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($15.b,S),Y		; 13 15 ; OR accumulator (stack relative indirect indexed) ($15.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rol $38.b,X		; 36 38 ; Rotate left $38.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	bit $60.b,X		; 34 60 ; Test bits $60.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $30, $34		; 30 34 ; Branch if minus to $30, $34 [Flow: branch]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	ora ($12.b,X)		; 01 12 ; Logical OR ($12.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpx $F0EE.w		; EC EE F0 ; Compare $F0EE.w with X register [Reads: X Index] [Flags: NCZ]
	.db $F0, $99		; F0 99 ; Branch if equal to $F0, $99 [Flow: branch]
	sta $EFED.w,Y		; 99 ED EF ; Store accumulator to $EFED.w,Y [Reads: Y Index, Accumulator]
	sbc ($F4.b)		; F2 F4 ; Subtract with carry (indirect) ($F4.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $F699.w,Y		; 99 99 F6 ; Store accumulator to $F699.w,Y [Reads: Y Index, Accumulator]
	pea $F9F8.w		; F4 F8 F9 ; Push absolute address $F9F8.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sta $FA99.w,Y		; 99 99 FA ; Store accumulator to $FA99.w,Y [Reads: Y Index, Accumulator]
	sbc ($F5.b,S),Y		; F3 F5 ; Subtract with carry (stack relative indirect indexed) ($F5.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($99.b,S),Y		; F3 99 ; Subtract with carry (stack relative indirect indexed) ($99.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sta $F5F4.w,Y		; 99 F4 F5 ; Store accumulator to $F5F4.w,Y [Reads: Y Index, Accumulator]
	jsr ($99F3.w,X)		; FC F3 99 ; Jump to subroutine indirect indexed ($99F3.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sta $F4F6.w,Y		; 99 F6 F4 ; Store accumulator to $F4F6.w,Y [Reads: Y Index, Accumulator]
	sbc $99FA.w,Y		; F9 FA 99 ; Subtract with carry $99FA.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $F8F4.w,Y		; 99 F4 F8 ; Store accumulator to $F8F4.w,Y [Reads: Y Index, Accumulator]
	sbc $F8.b,X		; F5 F8 ; Subtract $F8.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $F399.w,Y		; 99 99 F3 ; Store accumulator to $F399.w,Y [Reads: Y Index, Accumulator]
	sbc $FC.b,X		; F5 FC ; Subtract $FC.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $99.b		; 02 99 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	tsb $06.b		; 04 06 ; Test and set bits $06.b [Reads: Accumulator] [Flags: Z]
	sbc ($F4.b,S),Y		; F3 F4 ; Subtract with carry (stack relative indirect indexed) ($F4.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	sta $F9F4.w,Y		; 99 F4 F9 ; Store accumulator to $F9F4.w,Y [Reads: Y Index, Accumulator]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $0BAA.w,Y		; 99 AA 0B ; Store accumulator to $0BAA.w,Y [Reads: Y Index, Accumulator]
	asl $F8.b		; 06 F8 ; Arithmetic shift left $F8.b [Reads: Direct Page] [Flags: NCZ]
	sbc ($AA.b,S),Y		; F3 AA ; Subtract with carry (stack relative indirect indexed) ($AA.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sta $FEFB.w,Y		; 99 FB FE ; Store accumulator to $FEFB.w,Y [Reads: Y Index, Accumulator]
	sbc [$10.b],Y		; F7 10 ; Subtract with carry (long indexed) [$10.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $FA9A.w,Y		; 99 9A FA ; Store accumulator to $FA9A.w,Y [Reads: Y Index, Accumulator]
	sed		; F8 ; Set decimal flag [Flags: D]
	cmp $FD.b		; C5 FD ; Compare $FD.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sta $F659.w,Y		; 99 59 F6 ; Store accumulator to $F659.w,Y [Reads: Y Index, Accumulator]
	inc $F6.b,X		; F6 F6 ; Increment memory $F6.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	pea $9999.w		; F4 99 99 ; Push absolute address $9999.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	ora $16.b,S		; 03 16 ; OR accumulator with stack relative $16.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $AA04.w,Y		; 19 04 AA ; OR accumulator with memory $AA04.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	trb $04.b		; 14 04 ; Test and reset bits $04.b [Reads: Accumulator] [Flags: Z]
	sbc ($03.b,S),Y		; F3 03 ; Subtract with carry (stack relative indirect indexed) ($03.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	ora $19.b,S		; 03 19 ; OR accumulator with stack relative $19.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	trb $F8.b		; 14 F8 ; Test and reset bits $F8.b [Reads: Accumulator] [Flags: Z]
	sbc $A9F9.w,Y		; F9 F9 A9 ; Subtract with carry $A9F9.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $07F6.w,Y		; 99 F6 07 ; Store accumulator to $07F6.w,Y [Reads: Y Index, Accumulator]
	sbc $9AF9.w,Y		; F9 F9 9A ; Subtract with carry $9AF9.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $F4F9.w,Y		; 99 F9 F4 ; Store accumulator to $F4F9.w,Y [Reads: Y Index, Accumulator]
	ora $16.b,S		; 03 16 ; OR accumulator with stack relative $16.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $06AA.w,Y		; 99 AA 06 ; Store accumulator to $06AA.w,Y [Reads: Y Index, Accumulator]
	asl $16.b,X		; 16 16 ; Arithmetic shift left $16.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	asl $AA.b,X		; 16 AA ; Arithmetic shift left $AA.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	pea $161C.w		; F4 1C 16 ; Push absolute address $161C.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	lda #$AA.b		; A9 AA ; Load #$AA.b into accumulator [Writes: Accumulator] [Flags: NZ]
	asl $22.b,X		; 16 22 ; Arithmetic shift left $22.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	bit $16.b		; 24 16 ; Test bits $16.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	inc $0E.b,X		; F6 0E ; Increment memory $0E.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	inc $FC.b,X		; F6 FC ; Increment memory $FC.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	sta $FEFE.w,Y		; 99 FE FE ; Store accumulator to $FEFE.w,Y [Reads: Y Index, Accumulator]
	inc $FE.b,X		; F6 FE ; Increment memory $FE.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	sta $FE99.w,Y		; 99 99 FE ; Store accumulator to $FE99.w,Y [Reads: Y Index, Accumulator]
	inc $F0FF.w,X		; FE FF F0 ; Increment memory $F0FF.w,X [Reads: X Index] [Flags: NZ]
	sta $F699.w,Y		; 99 99 F6 ; Store accumulator to $F699.w,Y [Reads: Y Index, Accumulator]
	inc $1B.b,X		; F6 1B ; Increment memory $1B.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	.db $F0, $99		; F0 99 ; Branch if equal to $F0, $99 [Flow: branch]
	lda #$F0.b		; A9 F0 ; Load #$F0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	brk $99.b		; 00 99 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	inc $EC2C.w,X		; FE 2C EC ; Increment memory $EC2C.w,X [Reads: X Index] [Flags: NZ]
	jsr ($999A.w,X)		; FC 9A 99 ; Jump to subroutine indirect indexed ($999A.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	and ($2F.b,S),Y		; 33 2F ; AND accumulator (stack relative indirect indexed) ($2F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $AA2F.w,X		; FD 2F AA ; Subtract with carry $AA2F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	and ($F0.b),Y		; 31 F0 ; AND accumulator with memory ($F0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	and $AAA9.w		; 2D A9 AA ; Logical AND $AAA9.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jsr ($302F.w,X)		; FC 2F 30 ; Jump to subroutine indirect indexed ($302F.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora ($9A.b)		; 12 9A ; OR accumulator with memory (indirect) ($9A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	.db $30, $33		; 30 33 ; Branch if minus to $30, $33 [Flow: branch]
	sbc $AA2E.w,Y		; F9 2E AA ; Subtract with carry $AA2E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	and $302E30.l		; 2F 30 2E 30 ; AND accumulator with memory (long) $302E30.l [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ora $36.b,S		; 03 36 ; OR accumulator with stack relative $36.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $AA2F.w,X		; FD 2F AA ; Subtract with carry $AA2F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	sbc $302E.w,Y		; F9 2E 30 ; Subtract with carry $302E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($9A.b,S),Y		; 33 9A ; AND accumulator (stack relative indirect indexed) ($9A.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	rol $030A.w		; 2E 0A 03 ; Rotate left $030A.w [Flags: NCZ]
	rol $AA.b,X		; 36 AA ; Rotate left $AA.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ora ($FE.b)		; 12 FE ; OR accumulator with memory (indirect) ($FE.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $A9A9FE.l		; 0F FE A9 A9 ; OR accumulator with memory (long) $A9A9FE.l [Writes: Accumulator] [Flags: NZ]
	inc $F6F6.w,X		; FE F6 F6 ; Increment memory $F6F6.w,X [Reads: X Index] [Flags: NZ]
	inc $99.b,X		; F6 99 ; Increment memory $99.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	sta $07F9.w,Y		; 99 F9 07 ; Store accumulator to $07F9.w,Y [Reads: Y Index, Accumulator]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	and ($9A.b,S),Y		; 33 9A ; AND accumulator (stack relative indirect indexed) ($9A.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	rol $0809.w		; 2E 09 08 ; Rotate left $0809.w [Flags: NCZ]
	tsb $AA.b		; 04 AA ; Test and set bits $AA.b [Reads: Accumulator] [Flags: Z]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	.db $30, $F9		; 30 F9 ; Branch if minus to $30, $F9 [Flow: branch]
	ora #$16.b		; 09 16 ; Logical OR #$16.b with accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$AA.b		; A9 AA ; Load #$AA.b into accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	sbc $AAF9.w,Y		; F9 F9 AA ; Subtract with carry $AAF9.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $F9F9.w,Y		; 99 F9 F9 ; Store accumulator to $F9F9.w,Y [Reads: Y Index, Accumulator]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	sta $04AA.w,Y		; 99 AA 04 ; Store accumulator to $04AA.w,Y [Reads: Y Index, Accumulator]
	tsb $33.b		; 04 33 ; Test and set bits $33.b [Reads: Accumulator] [Flags: Z]
	.db $30, $AA		; 30 AA ; Branch if minus to $30, $AA [Flow: branch]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	inc $F6.b,X		; F6 F6 ; Increment memory $F6.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sta $F699.w,Y		; 99 99 F6 ; Store accumulator to $F699.w,Y [Reads: Y Index, Accumulator]
	inc $2E.b,X		; F6 2E ; Increment memory $2E.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	inc $A999.w,X		; FE 99 A9 ; Increment memory $A999.w,X [Reads: X Index] [Flags: NZ]
	inc $F0F0.w,X		; FE F0 F0 ; Increment memory $F0F0.w,X [Reads: X Index] [Flags: NZ]
	brk $99.b		; 00 99 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	inc $00F0.w,X		; FE F0 00 ; Increment memory $00F0.w,X [Reads: X Index] [Flags: NZ]
	inc $A999.w,X		; FE 99 A9 ; Increment memory $A999.w,X [Reads: X Index] [Flags: NZ]
	inc $2F35.w,X		; FE 35 2F ; Increment memory $2F35.w,X [Reads: X Index] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	ldy #$CEDA.w		; A0 DA CE ; Load #$CEDA.w into Y register [Writes: Y Index] [Flags: NZ]
	adc $0034.w,Y		; 79 34 00 ; Add $0034.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $79		; 10 79 ; Branch if plus to $10, $79 [Flow: branch]
	bit $FF.b,X		; 34 FF ; Test bits $FF.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	adc ($10.b),Y		; 71 10 ; Add with carry ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $34		; 10 34 ; Branch if plus to $10, $34 [Flow: branch]
	pei ($A5.b)		; D4 A5 ; Push effective indirect address ($A5.b) [Reads: Direct Page] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	asl $A539.w		; 0E 39 A5 ; Arithmetic shift left $A539.w [Flags: NCZ]
	lda $A1.b,S		; A3 A1 ; Load accumulator (stack relative) $A1.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $34.b,X		; 15 34 ; OR accumulator with memory $34.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $A4.b,X		; 35 A4 ; Logical AND $A4.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	jsr $3B00.w		; 20 00 3B ; Jump to subroutine at $3B00.w [Writes: Stack Pointer] [Flow: call]
	bit $2D.b,X		; 34 2D ; Test bits $2D.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cmp #$A0.b		; C9 A0 ; Compare #$A0.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $10, $A5		; 10 A5 ; Branch if plus to $10, $A5 [Flow: branch]
	and $3E3D.w,X		; 3D 3D 3E ; AND accumulator with memory $3E3D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	bit $4848.w,X		; 3C 48 48 ; Test bits $4848.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	eor #$AA.b		; 49 AA ; Exclusive OR #$AA.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	inc $44.b		; E6 44 ; Increment $44.b [Reads: Direct Page] [Flags: NZ]
	lsr $A2.b		; 46 A2 ; Logical shift right $A2.b [Reads: Direct Page] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	eor $4E4E.w		; 4D 4E 4E ; Exclusive OR $4E4E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	eor ($AA.b,S),Y		; 53 AA ; XOR accumulator (stack relative indirect indexed) ($AA.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	eor $55.b		; 45 55 ; Exclusive OR $55.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor [$4F.b],Y		; 57 4F ; Exclusive OR accumulator with memory (long indexed) [$4F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	mvp $AA,$63		; 44 63 AA ; Move block positive $AA,$63 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	stz $66.b		; 64 66 ; Store zero to $66.b
	adc [$46.b]		; 67 46 ; Add with carry (long) [$46.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	mvp $6C,$54		; 44 54 6C ; Move block positive $6C,$54 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	lsr $AA.b		; 46 AA ; Logical shift right $AA.b [Reads: Direct Page] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	sbc $AA4E.w		; ED 4E AA ; Subtract $AA4E.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	eor ($54.b,S),Y		; 53 54 ; XOR accumulator (stack relative indirect indexed) ($54.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor ($63.b,S),Y		; 53 63 ; XOR accumulator (stack relative indirect indexed) ($63.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	jmp ($4446.w)		; 6C 46 44 ; Jump indirect to ($4446.w) [Flow: jump]
	ror $AAAA.w		; 6E AA AA ; Rotate right $AAAA.w [Flags: NCZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc $6F.b,S		; 63 6F ; Add with carry (stack relative) $6F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	eor ($AA.b,X)		; 41 AA ; Exclusive OR accumulator with memory ($AA.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	eor $6A.b		; 45 6A ; Exclusive OR $6A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $AA6E.w,Y		; 59 6E AA ; Exclusive OR accumulator with memory $AA6E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	eor $E629.w,Y		; 59 29 E6 ; Exclusive OR accumulator with memory $E629.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	and ($54.b)		; 32 54 ; AND accumulator with memory (indirect) ($54.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor ($6A.b,S),Y		; 53 6A ; XOR accumulator (stack relative indirect indexed) ($6A.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ror $AAAA.w		; 6E AA AA ; Rotate right $AAAA.w [Flags: NCZ]
	eor $71.b		; 45 71 ; Exclusive OR $71.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr $AA.b		; 46 AA ; Logical shift right $AA.b [Reads: Direct Page] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	mvp $5F,$5B		; 44 5B 5F ; Move block positive $5F,$5B [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	lsr $AA.b		; 46 AA ; Logical shift right $AA.b [Reads: Direct Page] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	inc $44.b		; E6 44 ; Increment $44.b [Reads: Direct Page] [Flags: NZ]
	ror $AAA2.w		; 6E A2 AA ; Rotate right $AAA2.w [Flags: NCZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr $AA.b		; 46 AA ; Logical shift right $AA.b [Reads: Direct Page] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	mvp $4F,$46		; 44 46 4F ; Move block positive $4F,$46 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	eor $AA.b		; 45 AA ; Exclusive OR $AA.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	eor $6A.b		; 45 6A ; Exclusive OR $6A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $40AAAA.l,X		; 3F AA AA 40 ; AND accumulator with memory (long,X) $40AAAA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	mvp $6E,$44		; 44 44 6E ; Move block positive $6E,$44 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	eor $6A.b		; 45 6A ; Exclusive OR $6A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $45.b		; 45 45 ; Exclusive OR $45.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	eor $AAE6E6.l,X		; 5F E6 E6 AA ; Exclusive OR accumulator with memory (long,X) $AAE6E6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $525070.l		; 22 70 50 52 ; Jump to subroutine long $525070.l [Writes: Stack Pointer] [Flow: call]
	and $40AAAA.l,X		; 3F AA AA 40 ; AND accumulator with memory (long,X) $40AAAA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $4040.w,X		; 5D 40 40 ; Exclusive OR accumulator with memory $4040.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	eor ($54.b,X)		; 41 54 ; Exclusive OR accumulator with memory ($54.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cpx $A2AA.w		; EC AA A2 ; Compare $A2AA.w with X register [Reads: X Index] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $62, $E6, $E6		; 62 E6 E6 ; Push effective relative address $62, $E6, $E6 [Writes: Stack Pointer]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	jsl $47E6EC.l		; 22 EC E6 47 ; Jump to subroutine long $47E6EC.l [Writes: Stack Pointer] [Flow: call]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	jsl $E645AA.l		; 22 AA 45 E6 ; Jump to subroutine long $E645AA.l [Writes: Stack Pointer] [Flow: call]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	adc $AAA2.w,Y		; 79 A2 AA ; Add $AAA2.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $ED7A.w,Y		; 79 7A ED ; Add $ED7A.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx $22AA.w		; EC AA 22 ; Compare $22AA.w with X register [Reads: X Index] [Flags: NCZ]
	eor $45.b		; 45 45 ; Exclusive OR $45.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jmp ($AAAA.w,X)		; 7C AA AA ; Jump indirect indexed to ($AAAA.w,X) [Reads: X Index] [Flow: jump]
	adc $6D7F.w,X		; 7D 7F 6D ; Add $6D7F.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp $AAAA.w		; 4C AA AA ; Jump to $AAAA.w [Flow: jump]
	eor $48.b		; 45 48 ; Exclusive OR $48.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $80, $81		; 80 81 ; Branch always to $80, $81 [Flow: branch]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	jmp ($8481.w,X)		; 7C 81 84 ; Jump indirect indexed to ($8481.w,X) [Reads: X Index] [Flow: jump]
	sta [$AA.b]		; 87 AA ; Store accumulator (long) [$AA.b] [Reads: Direct Page, Accumulator]
	lda $3E.b,S		; A3 3E ; Load accumulator (stack relative) $3E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jmp ($45FE.w,X)		; 7C FE 45 ; Jump indirect indexed to ($45FE.w,X) [Reads: X Index] [Flow: jump]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	inc $46.b		; E6 46 ; Increment $46.b [Reads: Direct Page] [Flags: NZ]
	stx $80.b		; 86 80 ; Store X register to $80.b [Reads: X Index]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sty $AA84.w		; 8C 84 AA ; Store Y register to $AA84.w [Reads: Y Index]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	sta [$FE.b]		; 87 FE ; Store accumulator (long) [$FE.b] [Reads: Direct Page, Accumulator]
	mvp $A2,$46		; 44 46 A2 ; Move block positive $A2,$46 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	sta ($90.b,S),Y		; 93 90 ; Store accumulator (stack relative indirect indexed) ($90.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	sta $AAAA96.l		; 8F 96 AA AA ; Store accumulator (long) $AAAA96.l [Reads: Accumulator]
	stx $9490.w		; 8E 90 94 ; Store X register to $9490.w [Reads: X Index]
	inc $A2AA.w,X		; FE AA A2 ; Increment memory $A2AA.w,X [Reads: X Index] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	inc $9F.b		; E6 9F ; Increment $9F.b [Reads: Direct Page] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	stz $9BA0.w		; 9C A0 9B ; Store zero to $9BA0.w
	ldy #$AAAA.w		; A0 AA AA ; Load #$AAAA.w into Y register [Writes: Y Index] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	sta $AA46FE.l,X		; 9F FE 46 AA ; Store accumulator (long,X) $AA46FE.l,X [Reads: Accumulator, X Index]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	inc $A3.b		; E6 A3 ; Increment $A3.b [Reads: Direct Page] [Flags: NZ]
	lda $A6.b		; A5 A6 ; Load $A6.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ldy $A6.b		; A4 A6 ; Load $A6.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	lda [$A3.b]		; A7 A3 ; Load accumulator (long) [$A3.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	inc $E655.w,X		; FE 55 E6 ; Increment memory $E655.w,X [Reads: X Index] [Flags: NZ]
	lda $2A.b,S		; A3 2A ; Load accumulator (stack relative) $2A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lda $A3.b,S		; A3 A3 ; Load accumulator (stack relative) $A3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $A3.b,S		; A3 A3 ; Load accumulator (stack relative) $A3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $45.b,S		; A3 45 ; Load accumulator (stack relative) $45.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	stz $45.b		; 64 45 ; Store zero to $45.b
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	eor $AC40.w,X		; 5D 40 AC ; Exclusive OR accumulator with memory $AC40.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	eor ($E6.b),Y		; 51 E6 ; Exclusive OR accumulator with memory ($E6.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda $A3.b,S		; A3 A3 ; Load accumulator (stack relative) $A3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldx #$A3AA.w		; A2 AA A3 ; Load #$A3AA.w into X register [Writes: X Index] [Flags: NZ]
	lda $A3.b,S		; A3 A3 ; Load accumulator (stack relative) $A3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldy $AAAA.w		; AC AA AA ; Load $AAAA.w into Y register [Writes: Y Index] [Flags: NZ]
	adc ($E6.b,X)		; 61 E6 ; Add with carry ($E6.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp $A2A3.w		; 4C A3 A2 ; Jump to $A2A3.w [Flow: jump]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $A3.b,S		; A3 A3 ; Load accumulator (stack relative) $A3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldy $AA40.w		; AC 40 AA ; Load $AA40.w into Y register [Writes: Y Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	adc ($4C.b,S),Y		; 73 4C ; Add with carry (stack relative indirect indexed) ($4C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	jmp $5EAAAA.l		; 5C AA AA 5E ; Jump long to $5EAAAA.l [Flow: jump]
	ldx $A3E6.w		; AE E6 A3 ; Load $A3E6.w into X register [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	eor $A2AAE6.l,X		; 5F E6 AA A2 ; Exclusive OR accumulator with memory (long,X) $A2AAE6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda $FE.b,S		; A3 FE ; Load accumulator (stack relative) $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $A3.b,S		; A3 A3 ; Load accumulator (stack relative) $A3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldx #$77AA.w		; A2 AA 77 ; Load #$77AA.w into X register [Writes: X Index] [Flags: NZ]
	lda $A3.b,S		; A3 A3 ; Load accumulator (stack relative) $A3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lsr $AA.b		; 46 AA ; Logical shift right $AA.b [Reads: Direct Page] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $A344.w		; AD 44 A3 ; Load $A344.w into accumulator [Writes: Accumulator] [Flags: NZ]
	adc [$AA.b],Y		; 77 AA ; Add with carry (long indexed) [$AA.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	adc $A3E6.w		; 6D E6 A3 ; Add $A3E6.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	inc $A2.b		; E6 A2 ; Increment $A2.b [Reads: Direct Page] [Flags: NZ]
	ldx #$AD46.w		; A2 46 AD ; Load #$AD46.w into X register [Writes: X Index] [Flags: NZ]
	mvp $AA,$E6		; 44 E6 AA ; Move block positive $AA,$E6 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ldx #$4CFE.w		; A2 FE 4C ; Load #$4CFE.w into X register [Writes: X Index] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ldx $E645.w		; AE 45 E6 ; Load $E645.w into X register [Writes: X Index] [Flags: NZ]
	inc $AA.b		; E6 AA ; Increment $AA.b [Reads: Direct Page] [Flags: NZ]
	jsl $FEE6FE.l		; 22 FE E6 FE ; Jump to subroutine long $FEE6FE.l [Writes: Stack Pointer] [Flow: call]
	lda ($22.b),Y		; B1 22 ; Load accumulator ($22.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	bit $B4.b,X		; 34 B4 ; Test bits $B4.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cpy #$0AB6.w		; C0 B6 0A ; Compare #$0AB6.w with Y register [Reads: Y Index] [Flags: NCZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	lda [$BD.b],Y		; B7 BD ; Load accumulator (long indexed) [$BD.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	inc $AA.b,X		; F6 AA ; Increment memory $AA.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	lda $C2.b,S		; A3 C2 ; Load accumulator (stack relative) $C2.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpy $0E.b		; C4 0E ; Compare $0E.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	cmp [$AA.b]		; C7 AA ; Compare accumulator (long) [$AA.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	bit $15.b,X		; 34 15 ; Test bits $15.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $CA.b,X		; 34 CA ; Test bits $CA.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	tsb $0A.b		; 04 0A ; Test and set bits $0A.b [Reads: Accumulator] [Flags: Z]
	bit $CB.b,X		; 34 CB ; Test bits $CB.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cmp $CF.b,S		; C3 CF ; Compare accumulator (stack relative) $CF.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	.db $F0, $34		; F0 34 ; Branch if equal to $F0, $34 [Flow: branch]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	lda ($33.b)		; B2 33 ; Load accumulator (indirect) ($33.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $FCEC.w,Y		; B9 EC FC ; Load $FCEC.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	inc $33A0.w,X		; FE A0 33 ; Increment memory $33A0.w,X [Reads: X Index] [Flags: NZ]
	sbc $34B7D3.l,X		; FF D3 B7 34 ; Subtract with carry (long,X) $34B7D3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ldy #$D10A.w		; A0 0A D1 ; Load #$D10A.w into Y register [Writes: Y Index] [Flags: NZ]
	lda ($B9.b)		; B2 B9 ; Load accumulator (indirect) ($B9.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	sbc $363634.l,X		; FF 34 36 36 ; Subtract with carry (long,X) $363634.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $34.b,X		; D5 34 ; Compare accumulator $34.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	ldy #$C633.w		; A0 33 C6 ; Load #$C633.w into Y register [Writes: Y Index] [Flags: NZ]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	sbc $33.b,S		; E3 33 ; Subtract stack-relative $33.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	and $B1CA.w,Y		; 39 CA B1 ; AND accumulator with memory $B1CA.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	rol $B4.b,X		; 36 B4 ; Rotate left $B4.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc $C9.b		; 65 C9 ; Add $C9.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$C0.b]		; E7 C0 ; Subtract with carry (long) [$C0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and ($39.b,S),Y		; 33 39 ; AND accumulator (stack relative indirect indexed) ($39.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	bit $2B.b,X		; 34 2B ; Test bits $2B.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $A0.b,X		; 34 A0 ; Test bits $A0.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	adc $D834C9.l		; 6F C9 34 D8 ; Add with carry (long) $D834C9.l [Writes: Accumulator] [Flags: NCVZ]
	and ($0A.b,S),Y		; 33 0A ; AND accumulator (stack relative indirect indexed) ($0A.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	bit $98.b,X		; 34 98 ; Test bits $98.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	ldy #$C900.w		; A0 00 C9 ; Load #$C900.w into Y register [Writes: Y Index] [Flags: NZ]
	lda $3934C7.l,X		; BF C7 34 39 ; Load long $3934C7.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $35		; 30 35 ; Branch if minus to $30, $35 [Flow: branch]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $E9.b		; 00 E9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $DF.b,X		; B5 DF ; Load $DF.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$AA3A.w		; E0 3A AA ; Compare #$AA3A.w with X register [Reads: X Index] [Flags: NCZ]
	.db $F0, $E7		; F0 E7 ; Branch if equal to $F0, $E7 [Flow: branch]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	bit $0A.b,X		; 34 0A ; Test bits $0A.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	trb $34.b		; 14 34 ; Test and reset bits $34.b [Reads: Accumulator] [Flags: Z]
	bit $C9.b,X		; 34 C9 ; Test bits $C9.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $A3.b		; 00 A3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($A93B.w,X)		; 7C 3B A9 ; Jump indirect indexed to ($A93B.w,X) [Reads: X Index] [Flow: jump]
	ora ($20.b,X)		; 01 20 ; Logical OR ($20.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $20.b,X		; 34 20 ; Test bits $20.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and ($02.b,S),Y		; 33 02 ; AND accumulator (stack relative indirect indexed) ($02.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $14.b		; 04 14 ; Test and set bits $14.b [Reads: Accumulator] [Flags: Z]
	tsb $AA.b		; 04 AA ; Test and set bits $AA.b [Reads: Accumulator] [Flags: Z]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	trb $04.b		; 14 04 ; Test and reset bits $04.b [Reads: Accumulator] [Flags: Z]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	cop $14.b		; 02 14 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $AA7E.w,X		; 7E 7E AA ; Rotate right $AA7E.w,X [Reads: X Index] [Flags: NCZ]
	and ($E9.b,S),Y		; 33 E9 ; AND accumulator (stack relative indirect indexed) ($E9.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc #$DA.b		; E9 DA ; Subtract #$DA.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ror $03AA.w,X		; 7E AA 03 ; Rotate right $03AA.w,X [Reads: X Index] [Flags: NCZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc ($7E.b,X)		; E1 7E ; Subtract with carry ($7E.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc #$30.b		; E9 30 ; Subtract #$30.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sbc ($7D.b)		; F2 7D ; Subtract with carry (indirect) ($7D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($03.b,S),Y		; 93 03 ; Store accumulator (stack relative indirect indexed) ($03.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	ora $EA.b,S		; 03 EA ; OR accumulator with stack relative $EA.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $A0B636.l,X		; 9F 36 B6 A0 ; Store accumulator (long,X) $A0B636.l,X [Reads: Accumulator, X Index]
	brk $19.b		; 00 19 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0C.b,S		; 03 0C ; OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $AA.b,S		; 03 AA ; OR accumulator with stack relative $AA.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $19.b,X		; 36 19 ; Rotate left $19.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tsb $34E9.w		; 0C E9 34 ; Test and set bits $34E9.w [Reads: Accumulator] [Flags: Z]
	bit $AA.b,X		; 34 AA ; Test bits $AA.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $7E34.w,X		; 9D 34 7E ; Store accumulator to $7E34.w,X [Reads: Accumulator, X Index]
	and ($03.b)		; 32 03 ; AND accumulator with memory (indirect) ($03.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $0A.b,X		; 34 0A ; Test bits $0A.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $84.b,X		; 34 84 ; Test bits $84.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $50, $50		; 50 50 ; Branch if overflow clear to $50, $50 [Flow: branch]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora ($F2.b),Y		; 11 F2 ; OR accumulator with memory ($F2.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ldy #$0B26.w		; A0 26 0B ; Load #$0B26.w into Y register [Writes: Y Index] [Flags: NZ]
	.db $10, $11		; 10 11 ; Branch if plus to $10, $11 [Flow: branch]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	dec $EC.b		; C6 EC ; Decrement $EC.b [Reads: Direct Page] [Flags: NZ]
	asl $0A.b,X		; 16 0A ; Arithmetic shift left $0A.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	dec $E5.b		; C6 E5 ; Decrement $E5.b [Reads: Direct Page] [Flags: NZ]
	asl $01C8.w,X		; 1E C8 01 ; Arithmetic shift left $01C8.w,X [Reads: X Index] [Flags: NCZ]
	jsr $3FC8.w		; 20 C8 3F ; Jump to subroutine at $3FC8.w [Writes: Stack Pointer] [Flow: call]
	tsb $C6.b		; 04 C6 ; Test and set bits $C6.b [Reads: Accumulator] [Flags: Z]
	ora $30.b		; 05 30 ; Logical OR $30.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $E9C6.w		; EE C6 E9 ; Increment $E9C6.w [Flags: NZ]
	adc $C611A0.l,X		; 7F A0 11 C6 ; Add long $C611A0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	adc $00E6.w		; 6D E6 00 ; Add $00E6.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	ora ($1C.b)		; 12 1C ; OR accumulator with memory (indirect) ($1C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda #$C6.b		; A9 C6 ; Load #$C6.b into accumulator [Writes: Accumulator] [Flags: NZ]
	dec $10.b		; C6 10 ; Decrement $10.b [Reads: Direct Page] [Flags: NZ]
	brk $D3.b		; 00 D3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$F1.b],Y		; 37 F1 ; AND accumulator with memory (long indexed) [$F1.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $02.b,X		; 34 02 ; Test bits $02.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	jsr $81ED.w		; 20 ED 81 ; Jump to subroutine at $81ED.w [Writes: Stack Pointer] [Flow: call]
	adc $70A7D5.l,X		; 7F D5 A7 70 ; Add long $70A7D5.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $85.b		; 85 85 ; Store accumulator to $85.b [Reads: Accumulator]
	cpy $33C6.w		; CC C6 33 ; Compare $33C6.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $C7.b		; 00 C7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor [$76.b],Y		; 57 76 ; Exclusive OR accumulator with memory (long indexed) [$76.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc ($02.b,X)		; 61 02 ; Add with carry ($02.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($A9.b),Y		; 11 A9 ; OR accumulator with memory ($A9.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda #$C6.b		; A9 C6 ; Load #$C6.b into accumulator [Writes: Accumulator] [Flags: NZ]
	dec $00.b		; C6 00 ; Decrement $00.b [Reads: Direct Page] [Flags: NZ]
	brk $D5.b		; 00 D5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $0CEC.w		; CE EC 0C ; Decrement $0CEC.w [Flags: NZ]
	cop $A1.b		; 02 A1 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($C6.b)		; 32 C6 ; AND accumulator with memory (indirect) ($C6.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $C6.b,X		; 36 C6 ; Rotate left $C6.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	jsr $E600.w		; 20 00 E6 ; Jump to subroutine at $E600.w [Writes: Stack Pointer] [Flow: call]
	sta $F3F2.w		; 8D F2 F3 ; Store accumulator to $F3F2.w [Reads: Accumulator]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	stx $428D.w		; 8E 8D 42 ; Store X register to $428D.w [Reads: X Index]
	lda $AA.b,S		; A3 AA ; Load accumulator (stack relative) $AA.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $42.b,S		; A3 42 ; Load accumulator (stack relative) $42.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $42.b,S		; A3 42 ; Load accumulator (stack relative) $42.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	inc $F8.b		; E6 F8 ; Increment $F8.b [Reads: Direct Page] [Flags: NZ]
	inc $E6.b		; E6 E6 ; Increment $E6.b [Reads: Direct Page] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	jsl $A3E643.l		; 22 43 E6 A3 ; Jump to subroutine long $A3E643.l [Writes: Stack Pointer] [Flow: call]
	cpx $A2A2.w		; EC A2 A2 ; Compare $A2A2.w with X register [Reads: X Index] [Flags: NCZ]
	adc [$AD.b],Y		; 77 AD ; Add with carry (long indexed) [$AD.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $E6.b		; E6 E6 ; Increment $E6.b [Reads: Direct Page] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	jsl $44E6A3.l		; 22 A3 E6 44 ; Jump to subroutine long $44E6A3.l [Writes: Stack Pointer] [Flow: call]
	eor $E6AAA2.l,X		; 5F A2 AA E6 ; Exclusive OR accumulator with memory (long,X) $E6AAA2.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpx $E6A3.w		; EC A3 E6 ; Compare $E6A3.w with X register [Reads: X Index] [Flags: NCZ]
	jsl $AD77A2.l		; 22 A2 77 AD ; Jump to subroutine long $AD77A2.l [Writes: Stack Pointer] [Flow: call]
	inc $E6.b		; E6 E6 ; Increment $E6.b [Reads: Direct Page] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	jsl $A3E6A3.l		; 22 A3 E6 A3 ; Jump to subroutine long $A3E6A3.l [Writes: Stack Pointer] [Flow: call]
	mvp $AA,$A2		; 44 A2 AA ; Move block positive $AA,$A2 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	eor $4246.w		; 4D 46 42 ; Exclusive OR $4246.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lda $AA.b,S		; A3 AA ; Load accumulator (stack relative) $AA.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $42.b,S		; A3 42 ; Load accumulator (stack relative) $42.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $A3.b,S		; A3 A3 ; Load accumulator (stack relative) $A3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	.db $42, $EC		; 42 EC ; Reserved instruction
	lda $44.b,S		; A3 44 ; Load accumulator (stack relative) $44.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldx #$E6AA.w		; A2 AA E6 ; Load #$E6AA.w into X register [Writes: X Index] [Flags: NZ]
	inc $E6.b		; E6 E6 ; Increment $E6.b [Reads: Direct Page] [Flags: NZ]
	inc $22.b		; E6 22 ; Increment $22.b [Reads: Direct Page] [Flags: NZ]
	jsl $5446E6.l		; 22 E6 46 54 ; Jump to subroutine long $5446E6.l [Writes: Stack Pointer] [Flow: call]
	eor ($2A.b,S),Y		; 53 2A ; XOR accumulator (stack relative indirect indexed) ($2A.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	jsr $F9F9.w		; 20 F9 F9 ; Jump to subroutine at $F9F9.w [Writes: Stack Pointer] [Flow: call]
	sbc $6626.w,Y		; F9 26 66 ; Subtract with carry $6626.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $6A.b		; E6 6A ; Increment $6A.b [Reads: Direct Page] [Flags: NZ]
	lda $A5.b		; A5 A5 ; Load $A5.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($00.b,X)		; 21 00 ; Logical AND ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda $44.b		; A5 44 ; Load $44.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr $42.b		; 46 42 ; Logical shift right $42.b [Reads: Direct Page] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $E642.w		; AD 42 E6 ; Load $E642.w into accumulator [Writes: Accumulator] [Flags: NZ]
	eor ($AA.b,S),Y		; 53 AA ; XOR accumulator (stack relative indirect indexed) ($AA.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lda $58.b		; A5 58 ; Load $58.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $A3.b,S		; A3 A3 ; Load accumulator (stack relative) $A3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($AA.b),Y		; 11 AA ; OR accumulator with memory ($AA.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $44.b,X		; 34 44 ; Test bits $44.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $42, $AD		; 42 AD ; Reserved instruction
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	.db $42, $E6		; 42 E6 ; Reserved instruction
	ldy $25.b		; A4 25 ; Load $25.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	ldx #$A302.w		; A2 02 A3 ; Load #$A302.w into X register [Writes: X Index] [Flags: NZ]
	lda $34AD.w		; AD AD 34 ; Load $34AD.w into accumulator [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ldy #$E63F.w		; A0 3F E6 ; Load #$E63F.w into Y register [Writes: Y Index] [Flags: NZ]
	adc $A25B.w,Y		; 79 5B A2 ; Add $A25B.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($AD.b),Y		; 11 AD ; OR accumulator with memory ($AD.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda $34.b,S		; A3 34 ; Load accumulator (stack relative) $34.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $06AA.w,Y		; F9 AA 06 ; Subtract with carry $06AA.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F9F9.w,Y		; F9 F9 F9 ; Subtract with carry $F9F9.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $6666.w,Y		; F9 66 66 ; Subtract with carry $6666.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F9F9.w,Y		; F9 F9 F9 ; Subtract with carry $F9F9.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $6166.w,Y		; 79 66 61 ; Add $6166.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $A3.b,S		; A3 A3 ; Load accumulator (stack relative) $A3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $A5.b,S		; A3 A5 ; Load accumulator (stack relative) $A5.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ldy #$77AC.w		; A0 AC 77 ; Load #$77AC.w into Y register [Writes: Y Index] [Flags: NZ]
	bit $18.b,X		; 34 18 ; Test bits $18.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cop $25.b		; 02 25 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $25.b		; 65 25 ; Add $25.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	asl $21.b		; 06 21 ; Arithmetic shift left $21.b [Reads: Direct Page] [Flags: NCZ]
	and ($E6.b,X)		; 21 E6 ; Logical AND ($E6.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $2A4541.l,X		; 3F 41 45 2A ; AND accumulator with memory (long,X) $2A4541.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ldy $E640.w		; AC 40 E6 ; Load $E640.w into Y register [Writes: Y Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cmp $E6.b		; C5 E6 ; Compare $E6.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora [$A5.b]		; 07 A5 ; OR accumulator with memory (long) [$A5.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $71.b		; 02 71 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $D5.b		; A5 D5 ; Load $D5.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	eor $10.b		; 45 10 ; Exclusive OR $10.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	adc ($77.b),Y		; 71 77 ; Add with carry ($77.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and $A6AAF9.l,X		; 3F F9 AA A6 ; AND accumulator with memory (long,X) $A6AAF9.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda $AD.b		; A5 AD ; Load $AD.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$E4.b],Y		; 17 E4 ; OR accumulator with memory (long indexed) [$E4.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $26		; 10 26 ; Branch if plus to $10, $26 [Flow: branch]
	cmp $71.b,X		; D5 71 ; Compare accumulator $71.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	eor $45.b		; 45 45 ; Exclusive OR $45.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	eor $F845.w,Y		; 59 45 F8 ; Exclusive OR accumulator with memory $F845.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $66AA.w,Y		; F9 AA 66 ; Subtract with carry $66AA.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $E8.b,S		; A3 E8 ; Load accumulator (stack relative) $E8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $E3.b		; 02 E3 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $26.b		; 06 26 ; Arithmetic shift left $26.b [Reads: Direct Page] [Flags: NCZ]
	mvp $46,$AC		; 44 AC 46 ; Move block positive $46,$AC [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	lda $AA.b,S		; A3 AA ; Load accumulator (stack relative) $AA.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $A5.b,S		; A3 A5 ; Load accumulator (stack relative) $A5.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $A110.w,Y		; 79 10 A1 ; Add $A110.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($14.b)		; 12 14 ; OR accumulator with memory (indirect) ($14.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor [$AC.b]		; 47 AC ; Exclusive OR accumulator with memory (long) [$AC.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $7A.b		; A5 7A ; Load $7A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda ($A5.b,X)		; A1 A5 ; Load accumulator ($A5.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ldy $7C35.w		; AC 35 7C ; Load $7C35.w into Y register [Writes: Y Index] [Flags: NZ]
	.db $10, $07		; 10 07 ; Branch if plus to $10, $07 [Flow: branch]
	lda $48.b		; A5 48 ; Load $48.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	lda $16.b		; A5 16 ; Load $16.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($AC.b),Y		; 11 AC ; OR accumulator with memory ($AC.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ldy $A166.w		; AC 66 A1 ; Load $A166.w into Y register [Writes: Y Index] [Flags: NZ]
	ldy #$3430.w		; A0 30 34 ; Load #$3430.w into Y register [Writes: Y Index] [Flags: NZ]
	lda $AC.b		; A5 AC ; Load $AC.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda ($A5.b,X)		; A1 A5 ; Load accumulator ($A5.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lda $E4.b		; A5 E4 ; Load $E4.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jmp ($6711.w,X)		; 7C 11 67 ; Jump indirect indexed to ($6711.w,X) [Reads: X Index] [Flow: jump]
	and $F974AE.l,X		; 3F AE 74 F9 ; AND accumulator with memory (long,X) $F974AE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ror $D5.b,X		; 76 D5 ; Rotate right $D5.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	bit $A7.b,X		; 34 A7 ; Test bits $A7.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cmp $00.b,X		; D5 00 ; Compare accumulator $00.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $CE.b		; 00 CE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($C6C5.w,X)		; FC C5 C6 ; Jump to subroutine indirect indexed ($C6C5.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $C6.b		; 00 C6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $AB.b		; C6 AB ; Decrement $AB.b [Reads: Direct Page] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $C6C5.w		; CE C5 C6 ; Decrement $C6C5.w [Flags: NZ]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $B5.b,X		; 34 B5 ; Test bits $B5.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $F23634.l		; 0F 34 36 F2 ; OR accumulator with memory (long) $F23634.l [Writes: Accumulator] [Flags: NZ]
	jsr $ED00.w		; 20 00 ED ; Jump to subroutine at $ED00.w [Writes: Stack Pointer] [Flow: call]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	sbc ($F1.b)		; F2 F1 ; Subtract with carry (indirect) ($F1.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	pea $0838.w		; F4 38 08 ; Push absolute address $0838.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	bit $23.b,X		; 34 23 ; Test bits $23.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora ($EB.b,S),Y		; 13 EB ; OR accumulator (stack relative indirect indexed) ($EB.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $F1.b,X		; 34 F1 ; Test bits $F1.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $10.b,X		; 34 10 ; Test bits $10.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $34.b,X		; D6 34 ; Decrement memory $34.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	sbc [$00.b]		; E7 00 ; Subtract with carry (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($B0.b,X)		; 01 B0 ; Logical OR ($B0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $39.b,X		; 34 39 ; Test bits $39.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	brk $21.b		; 00 21 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($39.b),Y		; F1 39 ; Subtract with carry ($39.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp #$C9.b		; C9 C9 ; Compare #$C9.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $3C82.w,X		; 7E 82 3C ; Rotate right $3C82.w,X [Reads: X Index] [Flags: NCZ]
	lda $2033.w		; AD 33 20 ; Load $2033.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ror $FBF9.w,X		; 7E F9 FB ; Rotate right $FBF9.w,X [Reads: X Index] [Flags: NCZ]
	bit $33.b,X		; 34 33 ; Test bits $33.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $30, $34		; 30 34 ; Branch if minus to $30, $34 [Flow: branch]
	sbc $3AFC34.l,X		; FF 34 FC 3A ; Subtract with carry (long,X) $3AFC34.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jmp ($066C.w)		; 6C 6C 06 ; Jump indirect to ($066C.w) [Flow: jump]
	ora ($D7.b),Y		; 11 D7 ; OR accumulator with memory ($D7.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ldx $34B0.w,Y		; BE B0 34 ; Load X register $34B0.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx $3435.w		; AE 35 34 ; Load $3435.w into X register [Writes: X Index] [Flags: NZ]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $89.b		; 00 89 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($E1.b,X)		; E1 E1 ; Subtract with carry ($E1.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sbc ($34.b),Y		; F1 34 ; Subtract with carry ($34.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	lda $78.b,X		; B5 78 ; Load $78.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($34.b,X)		; E1 34 ; Subtract with carry ($34.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $79.b		; 26 79 ; Rotate left $79.b [Reads: Direct Page] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($BE.b),Y		; 71 BE ; Add with carry ($BE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $AE.b,X		; 34 AE ; Test bits $AE.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $B534.w,X		; 7E 34 B5 ; Rotate right $B534.w,X [Reads: X Index] [Flags: NCZ]
	bit #$00.b		; 89 00 ; Test bits #$00.b with accumulator [Reads: Accumulator] [Flags: Z]
	brk $71.b		; 00 71 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx $349A.w,Y		; BE 9A 34 ; Load X register $349A.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $33, $33		; 62 33 33 ; Push effective relative address $62, $33, $33 [Writes: Stack Pointer]
	stz $12.b,X		; 74 12 ; Store zero to $12.b,X [Reads: X Index]
	and ($35.b,X)		; 21 35 ; Logical AND ($35.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	adc ($71.b),Y		; 71 71 ; Add with carry ($71.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and $20.b,X		; 35 20 ; Logical AND $20.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $98.b		; 00 98 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	jmp ($009E.w)		; 6C 9E 00 ; Jump indirect to ($009E.w) [Flow: jump]
	.db $10, $71		; 10 71 ; Branch if plus to $10, $71 [Flow: branch]
	ldy $5C.b		; A4 5C ; Load $5C.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	lsr $1100.w,X		; 5E 00 11 ; Logical shift right $1100.w,X [Reads: X Index] [Flags: NCZ]
	ldy #$A57D.w		; A0 7D A5 ; Load #$A57D.w into Y register [Writes: Y Index] [Flags: NZ]
	jmp $5E0101.l		; 5C 01 01 5E ; Jump long to $5E0101.l [Flow: jump]
	lsr $5E06.w,X		; 5E 06 5E ; Logical shift right $5E06.w,X [Reads: X Index] [Flags: NCZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr $5E5E.w,X		; 5E 5E 5E ; Logical shift right $5E5E.w,X [Reads: X Index] [Flags: NCZ]
	bit $11.b,X		; 34 11 ; Test bits $11.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $10, $06		; 10 06 ; Branch if plus to $10, $06 [Flow: branch]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	stz $0010.w,X		; 9E 10 00 ; Store zero to $0010.w,X [Reads: X Index]
	jmp ($E134.w,X)		; 7C 34 E1 ; Jump indirect indexed to ($E134.w,X) [Reads: X Index] [Flow: jump]
	bit $10.b,X		; 34 10 ; Test bits $10.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $C4.b		; 00 C4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($5FC6.w,X)		; 7C C6 5F ; Jump indirect indexed to ($5FC6.w,X) [Reads: X Index] [Flow: jump]
	ora ($01.b),Y		; 11 01 ; OR accumulator with memory ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda $79C6.w		; AD C6 79 ; Load $79C6.w into accumulator [Writes: Accumulator] [Flags: NZ]
	and ($00.b),Y		; 31 00 ; AND accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($62.b),Y		; 11 62 ; OR accumulator with memory ($62.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda $F7F2.w		; AD F2 F7 ; Load $F7F2.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $10, $03		; 10 03 ; Branch if plus to $10, $03 [Flow: branch]
	sbc $3269.w,Y		; F9 69 32 ; Subtract with carry $3269.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and ($21.b),Y		; 31 21 ; AND accumulator with memory ($21.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($36.b,S),Y		; 33 36 ; AND accumulator (stack relative indirect indexed) ($36.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc $4123.w		; ED 23 41 ; Subtract $4123.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ora $00C6.w		; 0D C6 00 ; Logical OR $00C6.w with accumulator [Writes: Accumulator] [Flags: NZ]
	rol $20.b,X		; 36 20 ; Rotate left $20.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	jsr $3636.w		; 20 36 36 ; Jump to subroutine at $3636.w [Writes: Stack Pointer] [Flow: call]
	trb $34.b		; 14 34 ; Test and reset bits $34.b [Reads: Accumulator] [Flags: Z]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	adc $CDA4.w,Y		; 79 A4 CD ; Add $CDA4.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	stz $6C.b,X		; 74 6C ; Store zero to $6C.b,X [Reads: X Index]
	jmp ($21C6.w)		; 6C C6 21 ; Jump indirect to ($21C6.w) [Flow: jump]
	.db $10, $FF		; 10 FF ; Branch if plus to $10, $FF [Flow: branch]
	bit $E3.b,X		; 34 E3 ; Test bits $E3.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	adc [$10.b],Y		; 77 10 ; Add with carry (long indexed) [$10.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $C6.b		; 02 C6 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $B0, $57		; B0 57 ; Branch if carry set to $B0, $57 [Flow: branch]
	sbc $362102.l,X		; FF 02 21 36 ; Subtract with carry (long,X) $362102.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy $A4.b		; C4 A4 ; Compare $A4.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	ora ($5E.b,X)		; 01 5E ; Logical OR ($5E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ldy $1100.w		; AC 00 11 ; Load $1100.w into Y register [Writes: Y Index] [Flags: NZ]
	ora ($AB.b,X)		; 01 AB ; Logical OR ($AB.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda $AB.b		; A5 AB ; Load $AB.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($A5.b,X)		; 01 A5 ; Logical OR ($A5.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp $A5.b,X		; D5 A5 ; Compare accumulator $A5.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	lda $10.b		; A5 10 ; Load $10.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $A5		; 10 A5 ; Branch if plus to $10, $A5 [Flow: branch]
	tsb $C7.b		; 04 C7 ; Test and set bits $C7.b [Reads: Accumulator] [Flags: Z]
	bit $0B.b,X		; 34 0B ; Test bits $0B.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	jsr $07AA.w		; 20 AA 07 ; Jump to subroutine at $07AA.w [Writes: Stack Pointer] [Flow: call]
	bit $FE.b,X		; 34 FE ; Test bits $FE.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora ($A5.b,X)		; 01 A5 ; Logical OR ($A5.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	adc ($39.b,X)		; 61 39 ; Add with carry ($39.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	ora ($12.b),Y		; 11 12 ; OR accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($41.b,X)		; E1 41 ; Subtract with carry ($41.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $01F2.w,X		; 9D F2 01 ; Store accumulator to $01F2.w,X [Reads: Accumulator, X Index]
	jsr $3A4F.w		; 20 4F 3A ; Jump to subroutine at $3A4F.w [Writes: Stack Pointer] [Flow: call]
	sta $122D.w,X		; 9D 2D 12 ; Store accumulator to $122D.w,X [Reads: Accumulator, X Index]
	and ($9D.b,X)		; 21 9D ; Logical AND ($9D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc ($E4.b)		; F2 E4 ; Subtract with carry (indirect) ($E4.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $2220.w,Y		; F9 20 22 ; Subtract with carry $2220.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	sbc ($C7.b)		; F2 C7 ; Subtract with carry (indirect) ($C7.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp $2220.w		; CD 20 22 ; Compare $2220.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	adc $9D.b,S		; 63 9D ; Add with carry (stack relative) $9D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	cmp $3212.w		; CD 12 32 ; Compare $3212.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp $0B34.w		; CD 34 0B ; Compare $0B34.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	bit $23.b,X		; 34 23 ; Test bits $23.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora ($FF.b,S),Y		; 13 FF ; OR accumulator (stack relative indirect indexed) ($FF.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $11A5F4.l		; EF F4 A5 11 ; Subtract with carry (long) $11A5F4.l [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $A7		; 10 A7 ; Branch if plus to $10, $A7 [Flow: branch]
	bit $A5.b,X		; 34 A5 ; Test bits $A5.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ldy $1000.w		; AC 00 10 ; Load $1000.w into Y register [Writes: Y Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ror $0AE7.w,X		; 7E E7 0A ; Rotate right $0AE7.w,X [Reads: X Index] [Flags: NCZ]
	adc [$1B.b]		; 67 1B ; Add with carry (long) [$1B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp $9E53.w,X		; DD 53 9E ; Compare accumulator $9E53.w,X [Reads: X Index] [Flags: NCZ]
	bit $01.b,X		; 34 01 ; Test bits $01.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $E1.b		; 00 E1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $9F.b,S		; E3 9F ; Subtract stack-relative $9F.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	ldy $00.b		; A4 00 ; Load $00.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	brk $B0.b		; 00 B0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx $347E.w		; AE 7E 34 ; Load $347E.w into X register [Writes: X Index] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $B0.b		; A5 B0 ; Load $B0.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror $00F1.w,X		; 7E F1 00 ; Rotate right $00F1.w,X [Reads: X Index] [Flags: NCZ]
	brk $B9.b		; 00 B9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($CB.b)		; 12 CB ; OR accumulator with memory (indirect) ($CB.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	ora $7E.b,S		; 03 7E ; OR accumulator with stack relative $7E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $E7.b,S		; 83 E7 ; Store accumulator (stack relative) $E7.b,S [Reads: Stack Pointer, Accumulator]
	lsr $33.b,X		; 56 33 ; Logical shift right $33.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($4E.b,X)		; 01 4E ; Logical OR ($4E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lsr $CE4E.w		; 4E 4E CE ; Logical shift right $CE4E.w [Flags: NCZ]
	ora ($10.b),Y		; 11 10 ; OR accumulator with memory ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsr $C4D6.w		; 20 D6 C4 ; Jump to subroutine at $C4D6.w [Writes: Stack Pointer] [Flow: call]
	cpy $52.b		; C4 52 ; Compare $52.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $65.b		; 65 65 ; Add $65.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$31.b],Y		; F7 31 ; Subtract with carry (long indexed) [$31.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($C4.b)		; 12 C4 ; OR accumulator with memory (indirect) ($C4.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror $0500.w,X		; 7E 00 05 ; Rotate right $0500.w,X [Reads: X Index] [Flags: NCZ]
	ora $11.b,S		; 03 11 ; OR accumulator with stack relative $11.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$AA.b]		; 07 AA ; OR accumulator with memory (long) [$AA.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	dec $6016.w		; CE 16 60 ; Decrement $6016.w [Flags: NZ]
	tsb $8258.w		; 0C 58 82 ; Test and set bits $8258.w [Reads: Accumulator] [Flags: Z]
	adc $11.b		; 65 11 ; Add $11.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and ($7E.b),Y		; 31 7E ; AND accumulator with memory ($7E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $D5.b		; E5 D5 ; Subtract $D5.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora #$16.b		; 09 16 ; Logical OR #$16.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($72.b,X)		; 01 72 ; Logical OR ($72.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp $06.b,X		; D5 06 ; Compare accumulator $06.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $70, $11		; 70 11 ; Branch if overflow set to $70, $11 [Flow: branch]
	cmp ($E6.b,S),Y		; D3 E6 ; Compare accumulator (stack relative indirect indexed) ($E6.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	inc $025B.w		; EE 5B 02 ; Increment $025B.w [Flags: NZ]
	and ($86.b,X)		; 21 86 ; Logical AND ($86.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	inc $9683.w,X		; FE 83 96 ; Increment memory $9683.w,X [Reads: X Index] [Flags: NZ]
	ora ($35.b)		; 12 35 ; OR accumulator with memory (indirect) ($35.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $7E.b		; 05 7E ; Logical OR $7E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $E6.b,X		; 35 E6 ; Logical AND $E6.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,S),Y		; 13 02 ; OR accumulator (stack relative indirect indexed) ($02.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda ($34.b),Y		; B1 34 ; Load accumulator ($34.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
.ACCU 8
	sep #$E6		; E2 E6
	jsr $2202.w		; 20 02 22 ; Jump to subroutine at $2202.w [Writes: Stack Pointer] [Flow: call]
	cmp $30D1D1.l		; CF D1 D1 30 ; Compare accumulator (long) $30D1D1.l [Reads: Accumulator] [Flags: NCZ]
	brk $D1.b		; 00 D1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $E9.b,S		; A3 E9 ; Load accumulator (stack relative) $E9.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $00.b,X		; F5 00 ; Subtract $00.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($E6.b)		; 12 E6 ; OR accumulator with memory (indirect) ($E6.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$C8.b		; C9 C8 ; Compare #$C8.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	dec $20.b		; C6 20 ; Decrement $20.b [Reads: Direct Page] [Flags: NZ]
	brk $C8.b		; 00 C8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	inc $A5.b		; E6 A5 ; Increment $A5.b [Reads: Direct Page] [Flags: NZ]
	ora [$21.b]		; 07 21 ; OR accumulator with memory (long) [$21.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	bit $AB.b,X		; 34 AB ; Test bits $AB.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda $5B.b		; A5 5B ; Load $5B.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $671705.l		; EF 05 17 67 ; Subtract with carry (long) $671705.l [Writes: Accumulator] [Flags: NCVZ]
	sbc $C4.b		; E5 C4 ; Subtract $C4.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda $A5.b		; A5 A5 ; Load $A5.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ldy $A5.b		; A4 A5 ; Load $A5.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	asl $000F.w		; 0E 0F 00 ; Arithmetic shift left $000F.w [Flags: NCZ]
	jsl $343434.l		; 22 34 34 34 ; Jump to subroutine long $343434.l [Writes: Stack Pointer] [Flow: call]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $06.b,X		; 34 06 ; Test bits $06.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	asl $71.b		; 06 71 ; Arithmetic shift left $71.b [Reads: Direct Page] [Flags: NCZ]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $587D.w		; 0C 7D 58 ; Test and set bits $587D.w [Reads: Accumulator] [Flags: Z]
	adc ($17.b),Y		; 71 17 ; Add with carry ($17.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($07.b),Y		; 11 07 ; OR accumulator with memory ($07.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ror $7D.b		; 66 7D ; Rotate right $7D.b [Reads: Direct Page] [Flags: NCZ]
	ora #$11.b		; 09 11 ; Logical OR #$11.b with accumulator [Writes: Accumulator] [Flags: NZ]
	adc ($C6.b),Y		; 71 C6 ; Add with carry ($C6.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $C6.b		; C5 C6 ; Compare $C6.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp #$00.b		; C9 00 ; Compare #$00.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta [$5B.b]		; 87 5B ; Store accumulator (long) [$5B.b] [Reads: Direct Page, Accumulator]
	trb $1213.w		; 1C 13 12 ; Test and reset bits $1213.w [Reads: Accumulator] [Flags: Z]
	ora ($C7.b)		; 12 C7 ; OR accumulator with memory (indirect) ($C7.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($12.b),Y		; 11 12 ; OR accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda ($BB.b)		; B2 BB ; Load accumulator (indirect) ($BB.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $17.b,X		; 15 17 ; OR accumulator with memory $17.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $BBC7.w,Y		; 19 C7 BB ; OR accumulator with memory $BBC7.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lda ($C7.b)		; B2 C7 ; Load accumulator (indirect) ($C7.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp [$17.b]		; C7 17 ; Compare accumulator (long) [$17.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp [$22.b]		; C7 22 ; Compare accumulator (long) [$22.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	lda ($15.b)		; B2 15 ; Load accumulator (indirect) ($15.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $24.b,S		; 23 24 ; AND accumulator with stack relative $24.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	trb $BB.b		; 14 BB ; Test and reset bits $BB.b [Reads: Accumulator] [Flags: Z]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	cmp [$C7.b]		; C7 C7 ; Compare accumulator (long) [$C7.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp [$C7.b]		; C7 C7 ; Compare accumulator (long) [$C7.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	jsl $312F22.l		; 22 22 2F 31 ; Jump to subroutine long $312F22.l [Writes: Stack Pointer] [Flow: call]
	lda [$32.b],Y		; B7 32 ; Load accumulator (long indexed) [$32.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	bit $C7.b,X		; 34 C7 ; Test bits $C7.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora $D2.b,X		; 15 D2 ; OR accumulator with memory $D2.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lda ($B2.b)		; B2 B2 ; Load accumulator (indirect) ($B2.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	bit $3EC7.w,X		; 3C C7 3E ; Test bits $3EC7.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	cmp [$40.b]		; C7 40 ; Compare accumulator (long) [$40.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp [$47.b],Y		; D7 47 ; Compare accumulator (long indexed) [$47.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	jmp $BB4E.w		; 4C 4E BB ; Jump to $BB4E.w [Flow: jump]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	cmp [$50.b]		; C7 50 ; Compare accumulator (long) [$50.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ror $1A.b		; 66 1A ; Rotate right $1A.b [Reads: Direct Page] [Flags: NCZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	ora ($47.b,S),Y		; 13 47 ; OR accumulator (stack relative indirect indexed) ($47.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $51D2.w,Y		; D9 D2 51 ; Compare accumulator $51D2.w,Y [Reads: Y Index] [Flags: NCZ]
	lda ($2B.b)		; B2 2B ; Load accumulator (indirect) ($2B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor [$58.b],Y		; 57 58 ; Exclusive OR accumulator with memory (long indexed) [$58.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	cmp [$BB.b]		; C7 BB ; Compare accumulator (long) [$BB.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	lda ($0F.b)		; B2 0F ; Load accumulator (indirect) ($0F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp [$51.b]		; C7 51 ; Compare accumulator (long) [$51.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	lda ($BB.b)		; B2 BB ; Load accumulator (indirect) ($BB.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	asl $BBE6.w,X		; 1E E6 BB ; Arithmetic shift left $BBE6.w,X [Reads: X Index] [Flags: NCZ]
	rol $1C.b		; 26 1C ; Rotate left $1C.b [Reads: Direct Page] [Flags: NCZ]
	adc $65.b		; 65 65 ; Add $65.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ror $2B.b		; 66 2B ; Rotate right $2B.b [Reads: Direct Page] [Flags: NCZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	ror $E6.b		; 66 E6 ; Rotate right $E6.b [Reads: Direct Page] [Flags: NCZ]
	lsr $B1.b		; 46 B1 ; Logical shift right $B1.b [Reads: Direct Page] [Flags: NCZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cmp [$2A.b]		; C7 2A ; Compare accumulator (long) [$2A.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	inc $73.b,X		; F6 73 ; Increment memory $73.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	cmp $18742A.l,X		; DF 2A 74 18 ; Compare accumulator (long,X) $18742A.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	lda ($E6.b,S),Y		; B3 E6 ; Load accumulator (stack relative indirect indexed) ($E6.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp [$21.b]		; C7 21 ; Compare accumulator (long) [$21.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp $B262.w,Y		; D9 62 B2 ; Compare accumulator $B262.w,Y [Reads: Y Index] [Flags: NCZ]
	adc ($74.b,S),Y		; 73 74 ; Add with carry (stack relative indirect indexed) ($74.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc $0F.b		; E5 0F ; Subtract $0F.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	cmp [$78.b]		; C7 78 ; Compare accumulator (long) [$78.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	stz $C8.b,X		; 74 C8 ; Store zero to $C8.b,X [Reads: X Index]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	.db $B0, $07		; B0 07 ; Branch if carry set to $B0, $07 [Flow: branch]
	trb $C7C7.w		; 1C C7 C7 ; Test and reset bits $C7C7.w [Reads: Accumulator] [Flags: Z]
	adc ($22.b)		; 72 22 ; Add with carry (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp [$3F.b]		; C7 3F ; Compare accumulator (long) [$3F.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	.db $10, $D3		; 10 D3 ; Branch if plus to $10, $D3 [Flow: branch]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	.db $B0, $DF		; B0 DF ; Branch if carry set to $B0, $DF [Flow: branch]
	stx $05.b,Y		; 96 05 ; Store X register $05.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	cmp $1225.w		; CD 25 12 ; Compare $1225.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp [$FE.b]		; C7 FE ; Compare accumulator (long) [$FE.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	inc $22D2.w,X		; FE D2 22 ; Increment memory $22D2.w,X [Reads: X Index] [Flags: NZ]
	jsl $C63FC7.l		; 22 C7 3F C6 ; Jump to subroutine long $C63FC7.l [Writes: Stack Pointer] [Flow: call]
	inc $25.b		; E6 25 ; Increment $25.b [Reads: Direct Page] [Flags: NZ]
	jsl $8711CD.l		; 22 CD 11 87 ; Jump to subroutine long $8711CD.l [Writes: Stack Pointer] [Flow: call]
	cmp ($2B.b)		; D2 2B ; Compare accumulator (indirect) ($2B.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	and ($74.b)		; 32 74 ; AND accumulator with memory (indirect) ($74.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp [$C7.b]		; C7 C7 ; Compare accumulator (long) [$C7.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	mvp $29,$B2		; 44 B2 29 ; Move block positive $29,$B2 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	stz $19.b,X		; 74 19 ; Store zero to $19.b,X [Reads: X Index]
	ora $41.b,X		; 15 41 ; OR accumulator with memory $41.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lda ($BB.b,S),Y		; B3 BB ; Load accumulator (stack relative indirect indexed) ($BB.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $E613.w,X		; 7D 13 E6 ; Add $E613.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $22BB.w		; EE BB 22 ; Increment $22BB.w [Flags: NZ]
	and $15.b,X		; 35 15 ; Logical AND $15.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cmp [$82.b]		; C7 82 ; Compare accumulator (long) [$82.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	ora ($53.b,S),Y		; 13 53 ; OR accumulator (stack relative indirect indexed) ($53.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $B19E.w		; CD 9E B1 ; Compare $B19E.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	and $C7.b,S		; 23 C7 ; AND accumulator with stack relative $C7.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $10, $C7		; 10 C7 ; Branch if plus to $10, $C7 [Flow: branch]
	cmp [$2B.b]		; C7 2B ; Compare accumulator (long) [$2B.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	jsl $859667.l		; 22 67 96 85 ; Jump to subroutine long $859667.l [Writes: Stack Pointer] [Flow: call]
	jmp $5E31B5.l		; 5C B5 31 5E ; Jump long to $5E31B5.l [Flow: jump]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	bit $D0.b,X		; 34 D0 ; Test bits $D0.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	stx $04.b		; 86 04 ; Store X register to $04.b [Reads: X Index]
.ACCU 16
	rep #$65		; C2 65
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($83.b),Y		; D1 83 ; Compare accumulator ($83.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	sbc $86.b,S		; E3 86 ; Subtract stack-relative $86.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ror $D47E.w,X		; 7E 7E D4 ; Rotate right $D47E.w,X [Reads: X Index] [Flags: NCZ]
	.db $80, $33		; 80 33 ; Branch always to $80, $33 [Flow: branch]
	asl $83.b		; 06 83 ; Arithmetic shift left $83.b [Reads: Direct Page] [Flags: NCZ]
	ldy $79.b		; A4 79 ; Load $79.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	ror $1330.w,X		; 7E 30 13 ; Rotate right $1330.w,X [Reads: X Index] [Flags: NCZ]
	.db $80, $1B		; 80 1B ; Branch always to $80, $1B [Flow: branch]
	cop $C6.b		; 02 C6 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $20, $14		; 62 20 14 ; Push effective relative address $62, $20, $14 [Writes: Stack Pointer]
	.db $80, $7E		; 80 7E ; Branch always to $80, $7E [Flow: branch]
	ror $3326.w,X		; 7E 26 33 ; Rotate right $3326.w,X [Reads: X Index] [Flags: NCZ]
	bit $EA.b,X		; 34 EA ; Test bits $EA.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	nop		; EA ; No operation
	sta $342002.l,X		; 9F 02 20 34 ; Store accumulator (long,X) $342002.l,X [Reads: Accumulator, X Index]
	.db $82, $EA, $EA		; 82 EA EA ; Branch always long to $82, $EA, $EA [Flow: branch]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	nop		; EA ; No operation
	tsb $C7.b		; 04 C7 ; Test and set bits $C7.b [Reads: Accumulator] [Flags: Z]
	cmp $222B.w,X		; DD 2B 22 ; Compare accumulator $222B.w,X [Reads: X Index] [Flags: NCZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $CD.b		; 05 CD ; Logical OR $CD.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $221B.w		; CD 1B 22 ; Compare $221B.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp $34D6.w		; CD D6 34 ; Compare $34D6.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	bit $22.b,X		; 34 22 ; Test bits $22.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $CDCD.w		; CD CD CD ; Compare $CDCD.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	lda ($22.b)		; B2 22 ; Load accumulator (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $19CD.w		; CD CD 19 ; Compare $19CD.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora $22.b		; 05 22 ; Logical OR $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	cmp $6AF9.w		; CD F9 6A ; Compare $6AF9.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: NCZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	cmp [$D2.b],Y		; D7 D2 ; Compare accumulator (long indexed) [$D2.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cmp [$C7.b]		; C7 C7 ; Compare accumulator (long) [$C7.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	jsl $DB0622.l		; 22 22 06 DB ; Jump to subroutine long $DB0622.l [Writes: Stack Pointer] [Flow: call]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	lda ($22.b)		; B2 22 ; Load accumulator (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	sty $89.b		; 84 89 ; Store Y register to $89.b [Reads: Y Index]
	jsl $04823B.l		; 22 3B 82 04 ; Jump to subroutine long $04823B.l [Writes: Stack Pointer] [Flow: call]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	cmp #$223B.w		; C9 3B 22 ; Compare #$223B.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	sta $8D.b		; 85 8D ; Store accumulator to $8D.b [Reads: Accumulator]
	bit $B6.b,X		; 34 B6 ; Test bits $B6.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $B0, $DD		; B0 DD ; Branch if carry set to $B0, $DD [Flow: branch]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	bit $8E.b,X		; 34 8E ; Test bits $8E.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	jsl $1C3406.l		; 22 06 34 1C ; Jump to subroutine long $1C3406.l [Writes: Stack Pointer] [Flow: call]
	adc $0234.w,X		; 7D 34 02 ; Add $0234.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $7D		; 30 7D ; Branch if minus to $30, $7D [Flow: branch]
	sta $86.b		; 85 86 ; Store accumulator to $86.b [Reads: Accumulator]
	ror $B33B.w,X		; 7E 3B B3 ; Rotate right $B33B.w,X [Reads: X Index] [Flags: NCZ]
	bit #$C689.w		; 89 89 C6 ; Test bits #$C689.w with accumulator [Reads: Accumulator] [Flags: Z]
	and $BB.b,X		; 35 BB ; Logical AND $BB.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $D1.b		; 00 D1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($83.b),Y		; D1 83 ; Compare accumulator ($83.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	stx $00.b		; 86 00 ; Store X register to $00.b [Reads: X Index]
	ora ($53.b),Y		; 11 53 ; OR accumulator with memory ($53.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	stx $C7.b		; 86 C7 ; Store X register to $C7.b [Reads: X Index]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$0B.b],Y		; 17 0B ; OR accumulator with memory (long indexed) [$0B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ror $DB7E.w,X		; 7E 7E DB ; Rotate right $DB7E.w,X [Reads: X Index] [Flags: NCZ]
	cmp $33.b,X		; D5 33 ; Compare accumulator $33.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $EA.b		; 00 EA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $7E		; F0 7E ; Branch if equal to $F0, $7E [Flow: branch]
	sta $3B22.w		; 8D 22 3B ; Store accumulator to $3B22.w [Reads: Accumulator]
	stx $DD.b,Y		; 96 DD ; Store X register $DD.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	cmp ($7E.b,S),Y		; D3 7E ; Compare accumulator (stack relative indirect indexed) ($7E.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	lda ($23.b)		; B2 23 ; Load accumulator (indirect) ($23.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dec $7ED3.w		; CE D3 7E ; Decrement $7ED3.w [Flags: NZ]
	sta $02.b,S		; 83 02 ; Store accumulator (stack relative) $02.b,S [Reads: Stack Pointer, Accumulator]
	and ($84.b,S),Y		; 33 84 ; AND accumulator (stack relative indirect indexed) ($84.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp ($05.b,S),Y		; D3 05 ; Compare accumulator (stack relative indirect indexed) ($05.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	nop		; EA ; No operation
	and ($B2.b)		; 32 B2 ; AND accumulator with memory (indirect) ($B2.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	nop		; EA ; No operation
	ror $065C.w,X		; 7E 5C 06 ; Rotate right $065C.w,X [Reads: X Index] [Flags: NCZ]
	and $11.b,S		; 23 11 ; AND accumulator with stack relative $11.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $E4.b,X		; D5 E4 ; Compare accumulator $E4.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ror $027C.w,X		; 7E 7C 02 ; Rotate right $027C.w,X [Reads: X Index] [Flags: NCZ]
	rol $05.b,X		; 36 05 ; Rotate left $05.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $84.b		; 05 84 ; Logical OR $84.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldx $B3.b,Y		; B6 B3 ; Load X register $B3.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	jmp $C706E5.l		; 5C E5 06 C7 ; Jump long to $C706E5.l [Flow: jump]
	ora ($12.b),Y		; 11 12 ; OR accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($03.b,S),Y		; D3 03 ; Compare accumulator (stack relative indirect indexed) ($03.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	.db $F0, $86		; F0 86 ; Branch if equal to $F0, $86 [Flow: branch]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	rol $05.b		; 26 05 ; Rotate left $05.b [Reads: Direct Page] [Flags: NCZ]
	adc $C6D5.w,X		; 7D D5 C6 ; Add $C6D5.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda ($00.b,S),Y		; B3 00 ; Load accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $BB2B.w,Y		; 99 2B BB ; Store accumulator to $BB2B.w,Y [Reads: Y Index, Accumulator]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	ror $22D4.w,X		; 7E D4 22 ; Rotate right $22D4.w,X [Reads: X Index] [Flags: NCZ]
	.db $30, $7E		; 30 7E ; Branch if minus to $30, $7E [Flow: branch]
	ror $367E.w,X		; 7E 7E 36 ; Rotate right $367E.w,X [Reads: X Index] [Flags: NCZ]
	and ($30.b,S),Y		; 33 30 ; AND accumulator (stack relative indirect indexed) ($30.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $83.b,X		; 36 83 ; Rotate left $83.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cmp $D0.b		; C5 D0 ; Compare $D0.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ror $7E89.w,X		; 7E 89 7E ; Rotate right $7E89.w,X [Reads: X Index] [Flags: NCZ]
	bit $3B.b,X		; 34 3B ; Test bits $3B.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $30, $50		; 30 50 ; Branch if minus to $30, $50 [Flow: branch]
	ora $15ED1C.l,X		; 1F 1C ED 15 ; Logical OR long $15ED1C.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsr $F9CD.w		; 20 CD F9 ; Jump to subroutine at $F9CD.w [Writes: Stack Pointer] [Flow: call]
	eor #$20FD.w		; 49 FD 20 ; Exclusive OR #$20FD.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $70, $10		; 70 10 ; Branch if overflow set to $70, $10 [Flow: branch]
	cmp $CDCD.w		; CD CD CD ; Compare $CDCD.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	and ($22.b)		; 32 22 ; AND accumulator with memory (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	stz $DACD.w,X		; 9E CD DA ; Store zero to $DACD.w,X [Reads: X Index]
	sta $2332.w,X		; 9D 32 23 ; Store accumulator to $2332.w,X [Reads: Accumulator, X Index]
	cmp [$DD.b]		; C7 DD ; Compare accumulator (long) [$DD.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp $2274.w		; CD 74 22 ; Compare $2274.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsl $C79D9E.l		; 22 9E 9D C7 ; Jump to subroutine long $C79D9E.l [Writes: Stack Pointer] [Flow: call]
	cmp [$3B.b]		; C7 3B ; Compare accumulator (long) [$3B.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	jsl $D0C771.l		; 22 71 C7 D0 ; Jump to subroutine long $D0C771.l [Writes: Stack Pointer] [Flow: call]
	stz $0B02.w,X		; 9E 02 0B ; Store zero to $0B02.w,X [Reads: X Index]
	ldy #$DDD6.w		; A0 D6 DD ; Load #$DDD6.w into Y register [Writes: Y Index] [Flags: NZ]
	cmp $DF20B2.l		; CF B2 20 DF ; Compare accumulator (long) $DF20B2.l [Reads: Accumulator] [Flags: NCZ]
	sbc $22C7D2.l		; EF D2 C7 22 ; Subtract with carry (long) $22C7D2.l [Writes: Accumulator] [Flags: NCVZ]
	jsl $C7C7A4.l		; 22 A4 C7 C7 ; Jump to subroutine long $C7C7A4.l [Writes: Stack Pointer] [Flow: call]
	cmp $22B2.w		; CD B2 22 ; Compare $22B2.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp [$A5.b]		; C7 A5 ; Compare accumulator (long) [$A5.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	lda $AA.b		; A5 AA ; Load $AA.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	lda #$A0A4.w		; A9 A4 A0 ; Load #$A0A4.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy $BBBB.w		; AC BB BB ; Load $BBBB.w into Y register [Writes: Y Index] [Flags: NZ]
	ldy #$AF9E.w		; A0 9E AF ; Load #$AF9E.w into Y register [Writes: Y Index] [Flags: NZ]
	lda ($BB.b),Y		; B1 BB ; Load accumulator ($BB.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	lda ($B1.b),Y		; B1 B1 ; Load accumulator ($B1.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda ($B1.b),Y		; B1 B1 ; Load accumulator ($B1.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	lda ($A8.b)		; B2 A8 ; Load accumulator (indirect) ($A8.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $BBEF.w,X		; DD EF BB ; Compare accumulator $BBEF.w,X [Reads: X Index] [Flags: NCZ]
	jsl $B7AFC7.l		; 22 C7 AF B7 ; Jump to subroutine long $B7AFC7.l [Writes: Stack Pointer] [Flow: call]
	lda [$2B.b],Y		; B7 2B ; Load accumulator (long indexed) [$2B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	lda [$BE.b],Y		; B7 BE ; Load accumulator (long indexed) [$BE.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda [$BB.b],Y		; B7 BB ; Load accumulator (long indexed) [$BB.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	lda #$CDC7.w		; A9 C7 CD ; Load #$CDC7.w into accumulator [Writes: Accumulator] [Flags: NZ]
	stz $2BB2.w,X		; 9E B2 2B ; Store zero to $2BB2.w,X [Reads: X Index]
	lda $C6C5BE.l		; AF BE C5 C6 ; Load long $C6C5BE.l into accumulator [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ldx $A2BC.w,Y		; BE BC A2 ; Load X register $A2BC.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	cmp $BB.b,X		; D5 BB ; Compare accumulator $BB.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cmp [$C4.b]		; C7 C4 ; Compare accumulator (long) [$C4.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp $C5.b		; C5 C5 ; Compare $C5.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	cpy $C5CE.w		; CC CE C5 ; Compare $C5CE.w with Y register [Reads: Y Index] [Flags: NCZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ldy $BDD7.w,X		; BC D7 BD ; Load Y register $BDD7.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $BBBBB2.l		; AF B2 BB BB ; Load long $BBBBB2.l into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$D5A9.w		; A9 A9 D5 ; Load #$D5A9.w into accumulator [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	lda ($A9.b,S),Y		; B3 A9 ; Load accumulator (stack relative indirect indexed) ($A9.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $BBBBBB.l		; AF BB BB BB ; Load long $BBBBBB.l into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$9EA0.w		; A9 A0 9E ; Load #$9EA0.w into accumulator [Writes: Accumulator] [Flags: NZ]
	lda $D9BBBB.l		; AF BB BB D9 ; Load long $D9BBBB.l into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$A9A9.w		; A9 A9 A9 ; Load #$A9A9.w into accumulator [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	lda $20CDEF.l		; AF EF CD 20 ; Load long $20CDEF.l into accumulator [Writes: Accumulator] [Flags: NZ]
	lda ($25.b)		; B2 25 ; Load accumulator (indirect) ($25.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $E6DC.w,X		; DD DC E6 ; Compare accumulator $E6DC.w,X [Reads: X Index] [Flags: NCZ]
	jsl $E40200.l		; 22 00 02 E4 ; Jump to subroutine long $E40200.l [Writes: Stack Pointer] [Flow: call]
	sbc $34.b,S		; E3 34 ; Subtract stack-relative $34.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $86.b		; 85 86 ; Store accumulator to $86.b [Reads: Accumulator]
	bit $D3.b,X		; 34 D3 ; Test bits $D3.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	brk $6C.b		; 00 6C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($89.b,S),Y		; 93 89 ; Store accumulator (stack relative indirect indexed) ($89.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	bit $1B.b,X		; 34 1B ; Test bits $1B.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $B0, $D5		; B0 D5 ; Branch if carry set to $B0, $D5 [Flow: branch]
	trb $8DDC.w		; 1C DC 8D ; Test and reset bits $8DDC.w [Reads: Accumulator] [Flags: Z]
	cop $BB.b		; 02 BB ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stx $A3.b,Y		; 96 A3 ; Store X register $A3.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	cmp $EE.b,X		; D5 EE ; Compare accumulator $EE.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $B0, $01		; B0 01 ; Branch if carry set to $B0, $01 [Flow: branch]
	dec $C687.w,X		; DE 87 C6 ; Decrement memory $C687.w,X [Reads: X Index] [Flags: NZ]
	sta $B7.b,S		; 83 B7 ; Store accumulator (stack relative) $B7.b,S [Reads: Stack Pointer, Accumulator]
	ora ($DF.b,X)		; 01 DF ; Logical OR ($DF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	dec $5B.b		; C6 5B ; Decrement $5B.b [Reads: Direct Page] [Flags: NZ]
	.db $D0, $B0		; D0 B0 ; Branch if not equal to $D0, $B0 [Flow: branch]
	ora ($00.b)		; 12 00 ; OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$C26D.w		; 09 6D C2 ; Logical OR #$C26D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and [$73.b],Y		; 37 73 ; AND accumulator with memory (long indexed) [$73.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	inc $5A.b		; E6 5A ; Increment $5A.b [Reads: Direct Page] [Flags: NZ]
	asl $02.b,X		; 16 02 ; Arithmetic shift left $02.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	adc ($31.b,S),Y		; 73 31 ; Add with carry (stack relative indirect indexed) ($31.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cpy $FC.b		; C4 FC ; Compare $FC.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	adc ($16.b),Y		; 71 16 ; Add with carry ($16.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $FD.b		; 02 FD ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($32.b,S),Y		; 13 32 ; OR accumulator (stack relative indirect indexed) ($32.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc ($02.b,X)		; E1 02 ; Subtract with carry ($02.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $23E0.w		; 8D E0 23 ; Store accumulator to $23E0.w [Reads: Accumulator]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	ora ($E1.b),Y		; 11 E1 ; OR accumulator with memory ($E1.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $CDE63B.l		; 22 3B E6 CD ; Jump to subroutine long $CDE63B.l [Writes: Stack Pointer] [Flow: call]
	cmp $22C7.w		; CD C7 22 ; Compare $22C7.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsl $601CCD.l		; 22 CD 1C 60 ; Jump to subroutine long $601CCD.l [Writes: Stack Pointer] [Flow: call]
	trb $7222.w		; 1C 22 72 ; Test and reset bits $7222.w [Reads: Accumulator] [Flags: Z]
	and $1C6114.l,X		; 3F 14 61 1C ; AND accumulator with memory (long,X) $1C6114.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	adc ($3E.b)		; 72 3E ; Add with carry (indirect) ($3E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and $05D2.w,Y		; 39 D2 05 ; AND accumulator with memory $05D2.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	and [$F6.b]		; 27 F6 ; AND accumulator with memory (long) [$F6.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cmp [$C7.b]		; C7 C7 ; Compare accumulator (long) [$C7.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	jsl $A2C65F.l		; 22 5F C6 A2 ; Jump to subroutine long $A2C65F.l [Writes: Stack Pointer] [Flow: call]
	sbc $70.b		; E5 70 ; Subtract $70.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	trb $EF0F.w		; 1C 0F EF ; Test and reset bits $EF0F.w [Reads: Accumulator] [Flags: Z]
	cmp $222B.w,X		; DD 2B 22 ; Compare accumulator $222B.w,X [Reads: X Index] [Flags: NCZ]
	sec		; 38 ; Set carry flag [Flags: C]
	and $BB83C7.l,X		; 3F C7 83 BB ; AND accumulator with memory (long,X) $BB83C7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($CD.b,X)		; 21 CD ; Logical AND ($CD.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $42, $C7		; 42 C7 ; Reserved instruction
	cmp $2225.w,Y		; D9 25 22 ; Compare accumulator $2225.w,Y [Reads: Y Index] [Flags: NCZ]
	sbc [$E8.b]		; E7 E8 ; Subtract with carry (long) [$E8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $C7.b,X		; 15 C7 ; OR accumulator with memory $C7.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	lda ($C7.b)		; B2 C7 ; Load accumulator (indirect) ($C7.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp [$6A.b]		; C7 6A ; Compare accumulator (long) [$6A.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	jsr $1322.w		; 20 22 13 ; Jump to subroutine at $1322.w [Writes: Stack Pointer] [Flow: call]
	lsr $68.b		; 46 68 ; Logical shift right $68.b [Reads: Direct Page] [Flags: NCZ]
	cmp [$20.b]		; C7 20 ; Compare accumulator (long) [$20.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	and $71.b,S		; 23 71 ; AND accumulator with stack relative $71.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lsr $68.b		; 46 68 ; Logical shift right $68.b [Reads: Direct Page] [Flags: NCZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	jsr $E6E6.w		; 20 E6 E6 ; Jump to subroutine at $E6E6.w [Writes: Stack Pointer] [Flow: call]
	stz $2532.w		; 9C 32 25 ; Store zero to $2532.w
	adc #$71AA.w		; 69 AA 71 ; Add #$71AA.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	adc $60.b		; 65 60 ; Add $60.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($3F.b),Y		; 11 3F ; OR accumulator with memory ($3F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	stz $97.b,X		; 74 97 ; Store zero to $97.b,X [Reads: X Index]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	lda $97.b,X		; B5 97 ; Load $97.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $85.b		; 05 85 ; Logical OR $85.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc ($51.b),Y		; 71 51 ; Add with carry ($51.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp [$68.b]		; C7 68 ; Compare accumulator (long) [$68.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp [$E6.b]		; C7 E6 ; Compare accumulator (long) [$E6.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	jsl $12E6AB.l		; 22 AB E6 12 ; Jump to subroutine long $12E6AB.l [Writes: Stack Pointer] [Flow: call]
	mvp $B9,$02		; 44 02 B9 ; Move block positive $B9,$02 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sbc [$21.b]		; E7 21 ; Subtract with carry (long) [$21.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda [$1D.b],Y		; B7 1D ; Load accumulator (long indexed) [$1D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	.db $62, $10, $C7		; 62 10 C7 ; Push effective relative address $62, $10, $C7 [Writes: Stack Pointer]
	sbc $22B2C6.l		; EF C6 B2 22 ; Subtract with carry (long) $22B2C6.l [Writes: Accumulator] [Flags: NCVZ]
	cmp [$1C.b]		; C7 1C ; Compare accumulator (long) [$1C.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	dec $74.b		; C6 74 ; Decrement $74.b [Reads: Direct Page] [Flags: NZ]
	jsl $C8E90B.l		; 22 0B E9 C8 ; Jump to subroutine long $C8E90B.l [Writes: Stack Pointer] [Flow: call]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cmp [$10.b]		; C7 10 ; Compare accumulator (long) [$10.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cop $10.b		; 02 10 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($C7.b),Y		; 11 C7 ; OR accumulator with memory ($C7.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp [$BB.b]		; C7 BB ; Compare accumulator (long) [$BB.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	jsl $E911C7.l		; 22 C7 11 E9 ; Jump to subroutine long $E911C7.l [Writes: Stack Pointer] [Flow: call]
	mvp $B9,$2B		; 44 2B B9 ; Move block positive $B9,$2B [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	and $DFC7.w,Y		; 39 C7 DF ; AND accumulator with memory $DFC7.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	inc $B2.b		; E6 B2 ; Increment $B2.b [Reads: Direct Page] [Flags: NZ]
	jsl $EBC6E6.l		; 22 E6 C6 EB ; Jump to subroutine long $EBC6E6.l [Writes: Stack Pointer] [Flow: call]
	cmp [$00.b]		; C7 00 ; Compare accumulator (long) [$00.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	lda ($C7.b)		; B2 C7 ; Load accumulator (indirect) ($C7.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp [$E6.b],Y		; D7 E6 ; Compare accumulator (long indexed) [$E6.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cpy $22.b		; C4 22 ; Compare $22.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	jsr $4547.w		; 20 47 45 ; Jump to subroutine at $4547.w [Writes: Stack Pointer] [Flow: call]
	sbc [$EC.b]		; E7 EC ; Subtract with carry (long) [$EC.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda $E6BB.w,Y		; B9 BB E6 ; Load $E6BB.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	adc ($26.b),Y		; 71 26 ; Add with carry ($26.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	stx $79.b,Y		; 96 79 ; Store X register $79.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	asl $C6.b		; 06 C6 ; Arithmetic shift left $C6.b [Reads: Direct Page] [Flags: NCZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	.db $10, $97		; 10 97 ; Branch if plus to $10, $97 [Flow: branch]
	sta [$C6.b],Y		; 97 C6 ; Store accumulator (long indexed) [$C6.b],Y [Reads: Direct Page, Y Index, Accumulator]
	sta $55.b		; 85 55 ; Store accumulator to $55.b [Reads: Accumulator]
	ora $AB.b,S		; 03 AB ; OR accumulator with stack relative $AB.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ror $C657.w,X		; 7E 57 C6 ; Rotate right $C657.w,X [Reads: X Index] [Flags: NCZ]
	ora ($20.b,X)		; 01 20 ; Logical OR ($20.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$AD.b]		; 07 AD ; OR accumulator with memory (long) [$AD.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $20A9.w,Y		; 79 A9 20 ; Add $20A9.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $EE		; 10 EE ; Branch if plus to $10, $EE [Flow: branch]
	lda #$34E1.w		; A9 E1 34 ; Load #$34E1.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	stz $0CAA.w,X		; 9E AA 0C ; Store zero to $0CAA.w,X [Reads: X Index]
	dec $06.b		; C6 06 ; Decrement $06.b [Reads: Direct Page] [Flags: NZ]
	.db $10, $AB		; 10 AB ; Branch if plus to $10, $AB [Flow: branch]
	bit #$7EFA.w		; 89 FA 7E ; Test bits #$7EFA.w with accumulator [Reads: Accumulator] [Flags: Z]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora ($7E.b,S),Y		; 13 7E ; OR accumulator (stack relative indirect indexed) ($7E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $7C.b		; C6 7C ; Decrement $7C.b [Reads: Direct Page] [Flags: NZ]
	inc $1130.w		; EE 30 11 ; Increment $1130.w [Flags: NZ]
	cpy $EA.b		; C4 EA ; Compare $EA.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	stz $12EA.w,X		; 9E EA 12 ; Store zero to $12EA.w,X [Reads: X Index]
	cop $C7.b		; 02 C7 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ora [$C8.b]		; 07 C8 ; OR accumulator with memory (long) [$C8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $EBDAB2.l		; 22 B2 DA EB ; Jump to subroutine long $EBDAB2.l [Writes: Stack Pointer] [Flow: call]
	trb $2205.w		; 1C 05 22 ; Test and reset bits $2205.w [Reads: Accumulator] [Flags: Z]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	cmp [$F0.b]		; C7 F0 ; Compare accumulator (long) [$F0.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	.db $F0, $F2		; F0 F2 ; Branch if equal to $F0, $F2 [Flow: branch]
	jsl $DA05BB.l		; 22 BB 05 DA ; Jump to subroutine long $DA05BB.l [Writes: Stack Pointer] [Flow: call]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	sbc $F722B2.l		; EF B2 22 F7 ; Subtract with carry (long) $F722B2.l [Writes: Accumulator] [Flags: NCVZ]
	inc $05.b,X		; F6 05 ; Increment memory $05.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	sta $BB.b,S		; 83 BB ; Store accumulator (stack relative) $BB.b,S [Reads: Stack Pointer, Accumulator]
	lda ($DB.b,S),Y		; B3 DB ; Load accumulator (stack relative indirect indexed) ($DB.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$FE.b]		; 07 FE ; OR accumulator with memory (long) [$FE.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $2B.b		; 00 2B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $D3EF.w,X		; BC EF D3 ; Load Y register $D3EF.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	bit $C7.b,X		; 34 C7 ; Test bits $C7.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	jsl $04C802.l		; 22 02 C8 04 ; Jump to subroutine long $04C802.l [Writes: Stack Pointer] [Flow: call]
	ora ($D7.b,X)		; 01 D7 ; Logical OR ($D7.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $D3C2.w		; 2C C2 D3 ; Test bits $D3C2.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	ror $2208.w,X		; 7E 08 22 ; Rotate right $2208.w,X [Reads: X Index] [Flags: NCZ]
	bit $9907.w,X		; 3C 07 99 ; Test bits $9907.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	jmp ($CB83.w,X)		; 7C 83 CB ; Jump indirect indexed to ($CB83.w,X) [Reads: X Index] [Flow: jump]
	adc ($82.b,X)		; 61 82 ; Add with carry ($82.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	rep #$C2		; C2 C2 ; Reset processor status bits #$C2 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
.ACCU 16
.INDEX 16
	rep #$31		; C2 31
	ora ($30.b),Y		; 11 30 ; OR accumulator with memory ($30.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda ($7D.b),Y		; B1 7D ; Load accumulator ($7D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ror $23.b,X		; 76 23 ; Rotate right $23.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cmp ($06.b,S),Y		; D3 06 ; Compare accumulator (stack relative indirect indexed) ($06.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	sta $214E.w,Y		; 99 4E 21 ; Store accumulator to $214E.w,Y [Reads: Y Index, Accumulator]
	lda ($34.b),Y		; B1 34 ; Load accumulator ($34.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	stx $34.b		; 86 34 ; Store X register to $34.b [Reads: X Index]
	bit $0B.b,X		; 34 0B ; Test bits $0B.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($34.b,S),Y		; 93 34 ; Store accumulator (stack relative indirect indexed) ($34.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	.db $42, $CB		; 42 CB ; Reserved instruction
	ora $D3.b		; 05 D3 ; Logical OR $D3.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror $340D.w,X		; 7E 0D 34 ; Rotate right $340D.w,X [Reads: X Index] [Flags: NCZ]
	ora $C0.b,S		; 03 C0 ; OR accumulator with stack relative $C0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $42, $3F		; 42 3F ; Reserved instruction
	stx $87.b		; 86 87 ; Store X register to $87.b [Reads: X Index]
	eor $BB.b,X		; 55 BB ; Exclusive OR accumulator with memory $BB.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sta $90.b,X		; 95 90 ; Store accumulator to $90.b,X [Reads: Accumulator, X Index]
	ldy $BBE6.w		; AC E6 BB ; Load $BBE6.w into Y register [Writes: Y Index] [Flags: NZ]
	jsl $8DE634.l		; 22 34 E6 8D ; Jump to subroutine long $8DE634.l [Writes: Stack Pointer] [Flow: call]
	sbc [$02.b]		; E7 02 ; Subtract with carry (long) [$02.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc ($FB.b),Y		; 71 FB ; Add with carry ($FB.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $E6.b,S		; A3 E6 ; Load accumulator (stack relative) $E6.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $2210.w		; EE 10 22 ; Increment $2210.w [Flags: NZ]
	inc $9E.b,X		; F6 9E ; Increment memory $9E.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	lda $87.b,S		; A3 87 ; Load accumulator (stack relative) $87.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $10, $07		; 10 07 ; Branch if plus to $10, $07 [Flow: branch]
	inc $F4.b		; E6 F4 ; Increment $F4.b [Reads: Direct Page] [Flags: NZ]
	jsr $2270.w		; 20 70 22 ; Jump to subroutine at $2270.w [Writes: Stack Pointer] [Flow: call]
	and [$64.b]		; 27 64 ; AND accumulator with memory (long) [$64.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc [$76.b],Y		; 77 76 ; Add with carry (long indexed) [$76.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $77.b		; E6 77 ; Increment $77.b [Reads: Direct Page] [Flags: NZ]
	adc ($87.b)		; 72 87 ; Add with carry (indirect) ($87.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and #$E6E6.w		; 29 E6 E6 ; Logical AND #$E6E6.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and ($22.b,S),Y		; 33 22 ; AND accumulator (stack relative indirect indexed) ($22.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $20ED.w		; ED ED 20 ; Subtract $20ED.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	jsl $ABD536.l		; 22 36 D5 AB ; Jump to subroutine long $ABD536.l [Writes: Stack Pointer] [Flow: call]
	adc #$1625.w		; 69 25 16 ; Add #$1625.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	.db $62, $65, $40		; 62 65 40 ; Push effective relative address $62, $65, $40 [Writes: Stack Pointer]
	cmp $9B.b		; C5 9B ; Compare $9B.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	asl $2B.b,X		; 16 2B ; Arithmetic shift left $2B.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc [$CD.b],Y		; F7 CD ; Subtract with carry (long indexed) [$CD.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $22CD.w		; CD CD 22 ; Compare $22CD.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsl $46C7C7.l		; 22 C7 C7 46 ; Jump to subroutine long $46C7C7.l [Writes: Stack Pointer] [Flow: call]
	cmp [$22.b]		; C7 22 ; Compare accumulator (long) [$22.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	lda ($46.b)		; B2 46 ; Load accumulator (indirect) ($46.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp [$C8.b],Y		; D7 C8 ; Compare accumulator (long indexed) [$C8.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	and $B2.b,X		; 35 B2 ; Logical AND $B2.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $E6.b		; 05 E6 ; Logical OR $E6.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldx #$1110.w		; A2 10 11 ; Load #$1110.w into X register [Writes: X Index] [Flags: NZ]
	rol $BB.b		; 26 BB ; Rotate left $BB.b [Reads: Direct Page] [Flags: NCZ]
	cmp $5142.w,X		; DD 42 51 ; Compare accumulator $5142.w,X [Reads: X Index] [Flags: NCZ]
	cmp $1225.w		; CD 25 12 ; Compare $1225.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	sbc $9D888A.l		; EF 8A 88 9D ; Subtract with carry (long) $9D888A.l [Writes: Accumulator] [Flags: NCVZ]
	and $75.b,S		; 23 75 ; AND accumulator with stack relative $75.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $04AB.w,Y		; 79 AB 04 ; Add $04AB.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($B6.b),Y		; 51 B6 ; Exclusive OR accumulator with memory ($B6.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and [$51.b],Y		; 37 51 ; AND accumulator with memory (long indexed) [$51.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $65.b		; 65 65 ; Add $65.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	stz $1B71.w,X		; 9E 71 1B ; Store zero to $1B71.w,X [Reads: X Index]
	ora ($B1.b,S),Y		; 13 B1 ; OR accumulator (stack relative indirect indexed) ($B1.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $CB15.w,Y		; B9 15 CB ; Load $CB15.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ldy $BBB1.w,X		; BC B1 BB ; Load Y register $BBB1.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	cmp $BBD8.w		; CD D8 BB ; Compare $BBD8.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsl $1AC8C8.l		; 22 C8 C8 1A ; Jump to subroutine long $1AC8C8.l [Writes: Stack Pointer] [Flow: call]
	trb $CCBB.w		; 1C BB CC ; Test and reset bits $CCBB.w [Reads: Accumulator] [Flags: Z]
	.db $D0, $A8		; D0 A8 ; Branch if not equal to $D0, $A8 [Flow: branch]
	cmp [$FF.b],Y		; D7 FF ; Compare accumulator (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	jsl $D4B5C7.l		; 22 C7 B5 D4 ; Jump to subroutine long $D4B5C7.l [Writes: Stack Pointer] [Flow: call]
	lda #$BB2B.w		; A9 2B BB ; Load #$BB2B.w into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$20D9.w		; A9 D9 20 ; Load #$20D9.w into accumulator [Writes: Accumulator] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	wai		; CB ; Wait for interrupt
	ldy #$FFA3.w		; A0 A3 FF ; Load #$FFA3.w into Y register [Writes: Y Index] [Flags: NZ]
	cmp [$BB.b]		; C7 BB ; Compare accumulator (long) [$BB.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	jsl $C71DC7.l		; 22 C7 1D C7 ; Jump to subroutine long $C71DC7.l [Writes: Stack Pointer] [Flow: call]
	ora ($2C.b)		; 12 2C ; OR accumulator with memory (indirect) ($2C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $C7DD.w		; 2C DD C7 ; Test bits $C7DD.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	ora ($D7.b)		; 12 D7 ; OR accumulator with memory (indirect) ($D7.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $A4C7C2.l		; 22 C2 C7 A4 ; Jump to subroutine long $A4C7C2.l [Writes: Stack Pointer] [Flow: call]
	ldy $2B9E.w,X		; BC 9E 2B ; Load Y register $2B9E.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda #$CEEF.w		; A9 EF CE ; Load #$CEEF.w into accumulator [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	jsl $F6A3D7.l		; 22 D7 A3 F6 ; Jump to subroutine long $F6A3D7.l [Writes: Stack Pointer] [Flow: call]
	inc $BB.b,X		; F6 BB ; Increment memory $BB.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	jsl $C2D7C7.l		; 22 C7 D7 C2 ; Jump to subroutine long $C2D7C7.l [Writes: Stack Pointer] [Flow: call]
	ora ($2B.b)		; 12 2B ; OR accumulator with memory (indirect) ($2B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy $C7D4.w,X		; BC D4 C7 ; Load Y register $C7D4.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	cmp [$D7.b],Y		; D7 D7 ; Compare accumulator (long indexed) [$D7.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	jsl $CDBC2B.l		; 22 2B BC CD ; Jump to subroutine long $CDBC2B.l [Writes: Stack Pointer] [Flow: call]
	cmp $B2CD.w,Y		; D9 CD B2 ; Compare accumulator $B2CD.w,Y [Reads: Y Index] [Flags: NCZ]
	jsl $D4A0EF.l		; 22 EF A0 D4 ; Jump to subroutine long $D4A0EF.l [Writes: Stack Pointer] [Flow: call]
	lda ($2B.b,X)		; A1 2B ; Load accumulator ($2B.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	ldy $D7.b		; A4 D7 ; Load $D7.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	cmp [$DF.b]		; C7 DF ; Compare accumulator (long) [$DF.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	lda ($22.b)		; B2 22 ; Load accumulator (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $CDDF.w		; CD DF CD ; Compare $CDDF.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cpx $22.b		; E4 22 ; Compare $22.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	jsl $8D044F.l		; 22 4F 04 8D ; Jump to subroutine long $8D044F.l [Writes: Stack Pointer] [Flow: call]
	sta $7773.w		; 8D 73 77 ; Store accumulator to $7773.w [Reads: Accumulator]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $AA.b		; 05 AA ; Logical OR $AA.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc #$6651.w		; 69 51 66 ; Add #$6651.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $5251.w		; 8D 51 52 ; Store accumulator to $5251.w [Reads: Accumulator]
	eor $657777.l		; 4F 77 77 65 ; Exclusive OR accumulator with memory (long) $657777.l [Writes: Accumulator] [Flags: NZ]
	and $FB.b		; 25 FB ; Logical AND $FB.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$251C.w		; 09 1C 25 ; Logical OR #$251C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lda $C52A.w,Y		; B9 2A C5 ; Load $C52A.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and $2127.w		; 2D 27 21 ; Logical AND $2127.w with accumulator [Writes: Accumulator] [Flags: NZ]
	inc $FE16.w		; EE 16 FE ; Increment $FE16.w [Flags: NZ]
	jsr $2513.w		; 20 13 25 ; Jump to subroutine at $2513.w [Writes: Stack Pointer] [Flow: call]
	adc ($C6.b,X)		; 61 C6 ; Add with carry ($C6.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $83.b		; E6 83 ; Increment $83.b [Reads: Direct Page] [Flags: NZ]
	.db $10, $21		; 10 21 ; Branch if plus to $10, $21 [Flow: branch]
	sta [$4F.b],Y		; 97 4F ; Store accumulator (long indexed) [$4F.b],Y [Reads: Direct Page, Y Index, Accumulator]
	tsb $63.b		; 04 63 ; Test and set bits $63.b [Reads: Accumulator] [Flags: Z]
	and [$31.b],Y		; 37 31 ; AND accumulator with memory (long indexed) [$31.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	inc $E2.b		; E6 E2 ; Increment $E2.b [Reads: Direct Page] [Flags: NZ]
	.db $90, $C4		; 90 C4 ; Branch if carry clear to $90, $C4 [Flow: branch]
	jsl $F80720.l		; 22 20 07 F8 ; Jump to subroutine long $F80720.l [Writes: Stack Pointer] [Flow: call]
	sta [$77.b]		; 87 77 ; Store accumulator (long) [$77.b] [Reads: Direct Page, Accumulator]
	rol $77.b,X		; 36 77 ; Rotate left $77.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	jmp ($E890.w,X)		; 7C 90 E8 ; Jump indirect indexed to ($E890.w,X) [Reads: X Index] [Flow: jump]
	inc $72.b		; E6 72 ; Increment $72.b [Reads: Direct Page] [Flags: NZ]
	.db $62, $D5, $E4		; 62 D5 E4 ; Push effective relative address $62, $D5, $E4 [Writes: Stack Pointer]
	jmp ($06E6.w,X)		; 7C E6 06 ; Jump indirect indexed to ($06E6.w,X) [Reads: X Index] [Flow: jump]
	adc ($E6.b)		; 72 E6 ; Add with carry (indirect) ($E6.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and $C6.b		; 25 C6 ; Logical AND $C6.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $0C22.w		; 2C 22 0C ; Test bits $0C22.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	rol $2E.b		; 26 2E ; Rotate left $2E.b [Reads: Direct Page] [Flags: NCZ]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	cpy $2BCC.w		; CC CC 2B ; Compare $2BCC.w with Y register [Reads: Y Index] [Flags: NCZ]
	bit $35.b,X		; 34 35 ; Test bits $35.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	rol $CC.b,X		; 36 CC ; Rotate left $CC.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cpy $3F30.w		; CC 30 3F ; Compare $3F30.w with Y register [Reads: Y Index] [Flags: NCZ]
	rol $26.b		; 26 26 ; Rotate left $26.b [Reads: Direct Page] [Flags: NCZ]
	cpy $26CC.w		; CC CC 26 ; Compare $26CC.w with Y register [Reads: Y Index] [Flags: NCZ]
	rol $47.b		; 26 47 ; Rotate left $47.b [Reads: Direct Page] [Flags: NCZ]
	eor #$CCCC.w		; 49 CC CC ; Exclusive OR #$CCCC.w with accumulator [Writes: Accumulator] [Flags: NZ]
	rol $4B.b		; 26 4B ; Rotate left $4B.b [Reads: Direct Page] [Flags: NCZ]
	and $CC26.w		; 2D 26 CC ; Logical AND $CC26.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cpy $5226.w		; CC 26 52 ; Compare $5226.w with Y register [Reads: Y Index] [Flags: NCZ]
	eor ($55.b,S),Y		; 53 55 ; XOR accumulator (stack relative indirect indexed) ($55.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpy $56CC.w		; CC CC 56 ; Compare $56CC.w with Y register [Reads: Y Index] [Flags: NCZ]
	jmp $CC625A.l		; 5C 5A 62 CC ; Jump long to $CC625A.l [Flow: jump]
	cpy $6456.w		; CC 56 64 ; Compare $6456.w with Y register [Reads: Y Index] [Flags: NCZ]
	adc ($64.b,X)		; 61 64 ; Add with carry ($64.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy $56CC.w		; CC CC 56 ; Compare $56CC.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $70, $69		; 70 69 ; Branch if overflow set to $70, $69 [Flow: branch]
	.db $70, $C2		; 70 C2 ; Branch if overflow set to $70, $C2 [Flow: branch]
.ACCU 16
.INDEX 16
	rep #$70		; C2 70
	.db $70, $68		; 70 68 ; Branch if overflow set to $70, $68 [Flow: branch]
	.db $70, $22		; 70 22 ; Branch if overflow set to $70, $22 [Flow: branch]
.ACCU 16
.INDEX 16
	rep #$70		; C2 70
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	.db $70, $22		; 70 22 ; Branch if overflow set to $70, $22 [Flow: branch]
	jsl $697068.l		; 22 68 70 69 ; Jump to subroutine long $697068.l [Writes: Stack Pointer] [Flow: call]
	.db $70, $C2		; 70 C2 ; Branch if overflow set to $70, $C2 [Flow: branch]
.ACCU 16
.INDEX 16
	rep #$70		; C2 70
	adc #$7068.w		; 69 68 70 ; Add #$7068.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	bit $70C2.w		; 2C C2 70 ; Test bits $70C2.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	.db $70, $68		; 70 68 ; Branch if overflow set to $70, $68 [Flow: branch]
	.db $70, $22		; 70 22 ; Branch if overflow set to $70, $22 [Flow: branch]
.ACCU 16
.INDEX 16
	rep #$70		; C2 70
	adc #$7070.w		; 69 70 70 ; Add #$7070.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	bit $7022.w		; 2C 22 70 ; Test bits $7022.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	adc #$7069.w		; 69 69 70 ; Add #$7069.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	bit $6AC2.w		; 2C C2 6A ; Test bits $6AC2.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	.db $70, $69		; 70 69 ; Branch if overflow set to $70, $69 [Flow: branch]
	adc #$CCC2.w		; 69 C2 CC ; Add #$CCC2.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $6A		; 70 6A ; Branch if overflow set to $70, $6A [Flow: branch]
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	bit $6922.w		; 2C 22 69 ; Test bits $6922.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	adc $7070.w		; 6D 70 70 ; Add $7070.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cpy $6922.w		; CC 22 69 ; Compare $6922.w with Y register [Reads: Y Index] [Flags: NCZ]
	adc $6968.w		; 6D 68 69 ; Add $6968.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cpy $6ECC.w		; CC CC 6E ; Compare $6ECC.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	.db $70, $C2		; 70 C2 ; Branch if overflow set to $70, $C2 [Flow: branch]
	jsl $697069.l		; 22 69 70 69 ; Jump to subroutine long $697069.l [Writes: Stack Pointer] [Flow: call]
	adc #$CCC2.w		; 69 C2 CC ; Add #$CCC2.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	.db $70, $68		; 70 68 ; Branch if overflow set to $70, $68 [Flow: branch]
	jsl $70682C.l		; 22 2C 68 70 ; Jump to subroutine long $70682C.l [Writes: Stack Pointer] [Flow: call]
	adc #$C26A.w		; 69 6A C2 ; Add #$C26A.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cpy $7070.w		; CC 70 70 ; Compare $7070.w with Y register [Reads: Y Index] [Flags: NCZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	jsl $6870CC.l		; 22 CC 70 68 ; Jump to subroutine long $6870CC.l [Writes: Stack Pointer] [Flow: call]
	.db $70, $6B		; 70 6B ; Branch if overflow set to $70, $6B [Flow: branch]
	bit $6C2C.w		; 2C 2C 6C ; Test bits $6C2C.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	adc #$6968.w		; 69 68 69 ; Add #$6968.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cpy $6CCC.w		; CC CC 6C ; Compare $6CCC.w with Y register [Reads: Y Index] [Flags: NCZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc #$CC70.w		; 69 70 CC ; Add #$CC70.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
.ACCU 16
.INDEX 16
	rep #$70		; C2 70
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	jsl $70702C.l		; 22 2C 70 70 ; Jump to subroutine long $70702C.l [Writes: Stack Pointer] [Flow: call]
	adc $CC2271.l		; 6F 71 22 CC ; Add with carry (long) $CC2271.l [Writes: Accumulator] [Flags: NCVZ]
	adc [$73.b],Y		; 77 73 ; Add with carry (long indexed) [$73.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	stz $E3.b,X		; 74 E3 ; Store zero to $E3.b,X [Reads: X Index]
	cpy $74C0.w		; CC C0 74 ; Compare $74C0.w with Y register [Reads: Y Index] [Flags: NCZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	adc $CCC0.w,X		; 7D C0 CC ; Add $CCC0.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc [$76.b],Y		; 77 76 ; Add with carry (long indexed) [$76.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $C134.w,X		; 7E 34 C1 ; Rotate right $C134.w,X [Reads: X Index] [Flags: NCZ]
	cpy #$7E81.w		; C0 81 7E ; Compare #$7E81.w with Y register [Reads: Y Index] [Flags: NCZ]
	sbc [$C9.b]		; E7 C9 ; Subtract with carry (long) [$C9.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cpy $8410.w		; CC 10 84 ; Compare $8410.w with Y register [Reads: Y Index] [Flags: NCZ]
	sbc ($E2.b,X)		; E1 E2 ; Subtract with carry ($E2.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $0CC0.w,X		; 7D C0 0C ; Add $0CC0.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $34.b,X		; D5 34 ; Compare accumulator $34.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	stx $2088.w		; 8E 88 20 ; Store X register to $2088.w [Reads: X Index]
	cpy $9190.w		; CC 90 91 ; Compare $9190.w with Y register [Reads: Y Index] [Flags: NCZ]
	sta ($8B.b),Y		; 91 8B ; Store accumulator ($8B.b),Y [Reads: Direct Page, Y Index, Accumulator]
	cpy $F9CC.w		; CC CC F9 ; Compare $F9CC.w with Y register [Reads: Y Index] [Flags: NCZ]
	ldy #$9584.w		; A0 84 95 ; Load #$9584.w into Y register [Writes: Y Index] [Flags: NZ]
	rol $CC.b		; 26 CC ; Rotate left $CC.b [Reads: Direct Page] [Flags: NCZ]
	.db $90, $9F		; 90 9F ; Branch if carry clear to $90, $9F [Flow: branch]
	.db $90, $9A		; 90 9A ; Branch if carry clear to $90, $9A [Flow: branch]
	cpy $A2CC.w		; CC CC A2 ; Compare $A2CC.w with Y register [Reads: Y Index] [Flags: NCZ]
	ldy $CD.b		; A4 CD ; Load $CD.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	ldy #$26CC.w		; A0 CC 26 ; Load #$26CC.w into Y register [Writes: Y Index] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	.db $90, $90		; 90 90 ; Branch if carry clear to $90, $90 [Flow: branch]
	.db $90, $CC		; 90 CC ; Branch if carry clear to $90, $CC [Flow: branch]
	cpy $79AE.w		; CC AE 79 ; Compare $79AE.w with Y register [Reads: Y Index] [Flags: NCZ]
	ldy $0E.b		; A4 0E ; Load $0E.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	cpy $34C3.w		; CC C3 34 ; Compare $34C3.w with Y register [Reads: Y Index] [Flags: NCZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	ldy $0CBD.w,X		; BC BD 0C ; Load Y register $0CBD.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	cpy $A934.w		; CC 34 A9 ; Compare $A934.w with Y register [Reads: Y Index] [Flags: NCZ]
	ldy $BF.b		; A4 BF ; Load $BF.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	tsb $66CC.w		; 0C CC 66 ; Test and set bits $66CC.w [Reads: Accumulator] [Flags: Z]
	eor $1784C0.l		; 4F C0 84 17 ; Exclusive OR accumulator with memory (long) $1784C0.l [Writes: Accumulator] [Flags: NZ]
	cpy $7DE2.w		; CC E2 7D ; Compare $7DE2.w with Y register [Reads: Y Index] [Flags: NCZ]
	cmp $51.b		; C5 51 ; Compare $51.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	tsb $AAC7.w		; 0C C7 AA ; Test and set bits $AAC7.w [Reads: Accumulator] [Flags: Z]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ror $66.b		; 66 66 ; Rotate right $66.b [Reads: Direct Page] [Flags: NCZ]
	dec $51.b		; C6 51 ; Decrement $51.b [Reads: Direct Page] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	jmp ($CCC7.w,X)		; 7C C7 CC ; Jump indirect indexed to ($CCC7.w,X) [Reads: X Index] [Flow: jump]
	bit $C9.b,X		; 34 C9 ; Test bits $C9.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cmp $0CCB.w		; CD CB 0C ; Compare $0CCB.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cpy $C2CB.w		; CC CB C2 ; Compare $C2CB.w with Y register [Reads: Y Index] [Flags: NCZ]
	bit $79.b,X		; 34 79 ; Test bits $79.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cpy $CE01.w		; CC 01 CE ; Compare $CE01.w with Y register [Reads: Y Index] [Flags: NCZ]
	ldy $85.b		; A4 85 ; Load $85.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	lda $CCCC.w,Y		; B9 CC CC ; Load $CCCC.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lda $A9.b		; A5 A9 ; Load $A9.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pei ($C9.b)		; D4 C9 ; Push effective indirect address ($C9.b) [Reads: Direct Page] [Writes: Stack Pointer]
	trb $C1CC.w		; 1C CC C1 ; Test and reset bits $C1CC.w [Reads: Accumulator] [Flags: Z]
	lda $CBD8.w,Y		; B9 D8 CB ; Load $CBD8.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cpy $C9CC.w		; CC CC C9 ; Compare $C9CC.w with Y register [Reads: Y Index] [Flags: NCZ]
	adc ($86.b),Y		; 71 86 ; Add with carry ($86.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $CC.b,X		; 34 CC ; Test bits $CC.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cpy #$CBAB.w		; C0 AB CB ; Compare #$CBAB.w with Y register [Reads: Y Index] [Flags: NCZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	tsb $34CC.w		; 0C CC 34 ; Test and set bits $34CC.w [Reads: Accumulator] [Flags: Z]
	dec $C0CB.w		; CE CB C0 ; Decrement $C0CB.w [Flags: NZ]
	tsb $E2CC.w		; 0C CC E2 ; Test and set bits $E2CC.w [Reads: Accumulator] [Flags: Z]
	cmp $E3DE.w,X		; DD DE E3 ; Compare accumulator $E3DE.w,X [Reads: X Index] [Flags: NCZ]
	cpy $9CCC.w		; CC CC 9C ; Compare $9CCC.w with Y register [Reads: Y Index] [Flags: NCZ]
	cmp ($E4.b,S),Y		; D3 E4 ; Compare accumulator (stack relative indirect indexed) ($E4.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	wai		; CB ; Wait for interrupt
	cpy $C9CC.w		; CC CC C9 ; Compare $C9CC.w with Y register [Reads: Y Index] [Flags: NCZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	cmp $D3.b,S		; C3 D3 ; Compare accumulator (stack relative) $D3.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	cpy $EECC.w		; CC CC EE ; Compare $EECC.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $F0, $D3		; F0 D3 ; Branch if equal to $F0, $D3 [Flow: branch]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	cpy $C3CC.w		; CC CC C3 ; Compare $C3CC.w with Y register [Reads: Y Index] [Flags: NCZ]
	cmp $CCC9E5.l,X		; DF E5 C9 CC ; Compare accumulator (long,X) $CCC9E5.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	cpy $F6F5.w		; CC F5 F6 ; Compare $F6F5.w with Y register [Reads: Y Index] [Flags: NCZ]
	adc [$FB.b],Y		; 77 FB ; Add with carry (long indexed) [$FB.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy $34CC.w		; CC CC 34 ; Compare $34CC.w with Y register [Reads: Y Index] [Flags: NCZ]
	adc $1F78.w,X		; 7D 78 1F ; Add $1F78.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $C76B.w		; 0C 6B C7 ; Test and set bits $C76B.w [Reads: Accumulator] [Flags: Z]
	jsr ($FEFD.w,X)		; FC FD FE ; Jump to subroutine indirect indexed ($FEFD.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	bit $C7CC.w		; 2C CC C7 ; Test bits $C7CC.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cmp ($26.b,X)		; C1 26 ; Compare accumulator ($26.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	jmp ($C7B9.w)		; 6C B9 C7 ; Jump indirect to ($C7B9.w) [Flow: jump]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	rep #$0D		; C2 0D ; Reset processor status bits #$0D [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	cmp $2624.w		; CD 24 26 ; Compare $2624.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp $3223.w		; CD 23 32 ; Compare $3223.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp [$C7.b]		; C7 C7 ; Compare accumulator (long) [$C7.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	jsr ($22C7.w,X)		; FC C7 22 ; Jump to subroutine indirect indexed ($22C7.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	rep #$CD		; C2 CD ; Reset processor status bits #$CD [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	sta $00B9.w		; 8D B9 00 ; Store accumulator to $00B9.w [Reads: Accumulator]
	bit $FECD.w		; 2C CD FE ; Test bits $FECD.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	sbc $CDFF.w,X		; FD FF CD ; Subtract with carry $CDFF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy $C622.w		; CC 22 C6 ; Compare $C622.w with Y register [Reads: Y Index] [Flags: NCZ]
	sbc $76C7.w,X		; FD C7 76 ; Subtract with carry $76C7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $872C.w		; 2C 2C 87 ; Test bits $872C.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	bit $35.b,X		; 34 35 ; Test bits $35.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cpy #$0C21.w		; C0 21 0C ; Compare #$0C21.w with Y register [Reads: Y Index] [Flags: NCZ]
	cmp $0BC7.w		; CD C7 0B ; Compare $0BC7.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp ($2D.b)		; D2 2D ; Compare accumulator (indirect) ($2D.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp ($B9.b,X)		; C1 B9 ; Compare accumulator ($B9.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	sbc $CCC7.w,X		; FD C7 CC ; Subtract with carry $CCC7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rep #$CD		; C2 CD ; Reset processor status bits #$CD [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	cmp [$C7.b]		; C7 C7 ; Compare accumulator (long) [$C7.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp $2222.w		; CD 22 22 ; Compare $2222.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp [$ED.b]		; C7 ED ; Compare accumulator (long) [$ED.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	and ($DD.b,X)		; 21 DD ; Logical AND ($DD.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp [$ED.b]		; C7 ED ; Compare accumulator (long) [$ED.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora $0A.b		; 05 0A ; Logical OR $0A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($DD.b,X)		; 21 DD ; Logical AND ($DD.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	cmp $DD36.w		; CD 36 DD ; Compare $DD36.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsl $2525F7.l		; 22 F7 25 25 ; Jump to subroutine long $2525F7.l [Writes: Stack Pointer] [Flow: call]
	dec $23.b		; C6 23 ; Decrement $23.b [Reads: Direct Page] [Flags: NZ]
	and ($0A.b)		; 32 0A ; AND accumulator with memory (indirect) ($0A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $331F.w,X		; FD 1F 33 ; Subtract with carry $331F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp.w [$C6B2]		; DC B2 C6 ; Jump long indirect [$C6B2] [Flow: jump]
	adc [$FD.b]		; 67 FD ; Add with carry (long) [$FD.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	and ($CD.b,X)		; 21 CD ; Logical AND ($CD.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	stz $0E9C.w		; 9C 9C 0E ; Store zero to $0E9C.w
	rol $CC.b,X		; 36 CC ; Rotate left $CC.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cmp ($F7.b)		; D2 F7 ; Compare accumulator (indirect) ($F7.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp $1F31.w		; CD 31 1F ; Compare $1F31.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsl $7D761B.l		; 22 1B 76 7D ; Jump to subroutine long $7D761B.l [Writes: Stack Pointer] [Flow: call]
	adc [$A4.b],Y		; 77 A4 ; Add with carry (long indexed) [$A4.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	trb $A4CC.w		; 1C CC A4 ; Test and reset bits $A4CC.w [Reads: Accumulator] [Flags: Z]
	cpy #$9AC2.w		; C0 C2 9A ; Compare #$9AC2.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpy $CDC3.w		; CC C3 CD ; Compare $CDC3.w with Y register [Reads: Y Index] [Flags: NCZ]
	cmp [$0A.b]		; C7 0A ; Compare accumulator (long) [$0A.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	adc $DC22.w,X		; 7D 22 DC ; Add $DC22.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($6F.b,S),Y		; 73 6F ; Add with carry (stack relative indirect indexed) ($6F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$CC9B.w		; C0 9B CC ; Compare #$CC9B.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpy $D734.w		; CC 34 D7 ; Compare $D734.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora $DC2277.l		; 0F 77 22 DC ; OR accumulator with memory (long) $DC2277.l [Writes: Accumulator] [Flags: NZ]
	dec $7DB6.w		; CE B6 7D ; Decrement $7DB6.w [Flags: NZ]
	and $C102.w		; 2D 02 C1 ; Logical AND $C102.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and ($CD.b),Y		; 31 CD ; AND accumulator with memory ($CD.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsr ($12FD.w,X)		; FC FD 12 ; Jump to subroutine indirect indexed ($12FD.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpy $042D.w		; CC 2D 04 ; Compare $042D.w with Y register [Reads: Y Index] [Flags: NCZ]
	tsb $CD.b		; 04 CD ; Test and set bits $CD.b [Reads: Accumulator] [Flags: Z]
	ora $D5D2.w,X		; 1D D2 D5 ; OR accumulator with memory $D5D2.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $C7.b		; 05 C7 ; Logical OR $C7.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $2D.b,S		; 03 2D ; OR accumulator with stack relative $2D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $0AC7.w		; 2D C7 0A ; Logical AND $0AC7.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $B22DCD.l,X		; 1F CD 2D B2 ; Logical OR long $B22DCD.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp [$00.b]		; C7 00 ; Compare accumulator (long) [$00.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp [$CD.b]		; C7 CD ; Compare accumulator (long) [$CD.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	and $0822.w		; 2D 22 08 ; Logical AND $0822.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	tsb $DD.b		; 04 DD ; Test and set bits $DD.b [Reads: Accumulator] [Flags: Z]
	cmp $FECD.w,X		; DD CD FE ; Compare accumulator $FECD.w,X [Reads: X Index] [Flags: NCZ]
	cmp [$1F.b]		; C7 1F ; Compare accumulator (long) [$1F.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	bit $C72B.w		; 2C 2B C7 ; Test bits $C72B.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cmp [$04.b],Y		; D7 04 ; Compare accumulator (long indexed) [$04.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	and $032D.w		; 2D 2D 03 ; Logical AND $032D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp ($03.b)		; D2 03 ; Compare accumulator (indirect) ($03.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	dec $D2.b		; C6 D2 ; Decrement $D2.b [Reads: Direct Page] [Flags: NZ]
	cmp ($C7.b)		; D2 C7 ; Compare accumulator (indirect) ($C7.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tsb $2D08.w		; 0C 08 2D ; Test and set bits $2D08.w [Reads: Accumulator] [Flags: Z]
	cmp $04CD.w,X		; DD CD 04 ; Compare accumulator $04CD.w,X [Reads: X Index] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cmp [$2D.b]		; C7 2D ; Compare accumulator (long) [$2D.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp ($CD.b)		; D2 CD ; Compare accumulator (indirect) ($CD.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sbc $2204F8.l,X		; FF F8 04 22 ; Subtract with carry (long,X) $2204F8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $C7CD.w		; 2D CD C7 ; Logical AND $C7CD.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp $2235.w		; CD 35 22 ; Compare $2235.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	jsl $1336B9.l		; 22 B9 36 13 ; Jump to subroutine long $1336B9.l [Writes: Stack Pointer] [Flow: call]
	ora ($C2.b,S),Y		; 13 C2 ; OR accumulator (stack relative indirect indexed) ($C2.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($2D.b,S),Y		; 33 2D ; AND accumulator (stack relative indirect indexed) ($2D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $C19C.w		; CD 9C C1 ; Compare $C19C.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora ($CC.b)		; 12 CC ; OR accumulator with memory (indirect) ($CC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $0E34.w,Y		; B9 34 0E ; Load $0E34.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cpy $12C0.w		; CC C0 12 ; Compare $12C0.w with Y register [Reads: Y Index] [Flags: NCZ]
	and $11A4.w		; 2D A4 11 ; Logical AND $11A4.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$D91C.w		; A9 1C D9 ; Load #$D91C.w into accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	stz $CCD3.w		; 9C D3 CC ; Store zero to $CCD3.w
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($B9.b,X)		; C1 B9 ; Compare accumulator ($B9.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	cmp $B0CC.w,X		; DD CC B0 ; Compare accumulator $B0CC.w,X [Reads: X Index] [Flags: NCZ]
	sbc $CEC7.w		; ED C7 CE ; Subtract $CEC7.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	and ($22.b,X)		; 21 22 ; Logical AND ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	clc		; 18 ; Clear carry flag [Flags: C]
	ldy $11.b		; A4 11 ; Load $11.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	.db $10, $DC		; 10 DC ; Branch if plus to $10, $DC [Flow: branch]
	cmp $C2C2.w,X		; DD C2 C2 ; Compare accumulator $C2C2.w,X [Reads: X Index] [Flags: NCZ]
	sbc $CC36.w		; ED 36 CC ; Subtract $CC36.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ora ($25.b)		; 12 25 ; OR accumulator with memory (indirect) ($25.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $CD.b		; 25 CD ; Logical AND $CD.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $33.b,S		; 03 33 ; OR accumulator with stack relative $33.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $19CD.w		; 2D CD 19 ; Logical AND $19CD.w with accumulator [Writes: Accumulator] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	ora $2D.b		; 05 2D ; Logical OR $2D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $7171.w,X		; 3D 71 71 ; AND accumulator with memory $7171.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$CC17]		; DC 17 CC ; Jump long indirect [$CC17] [Flow: jump]
	cmp $DEC2.w		; CD C2 DE ; Compare $DEC2.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	rol $34.b,X		; 36 34 ; Rotate left $34.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cpy $F823.w		; CC 23 F8 ; Compare $F823.w with Y register [Reads: Y Index] [Flags: NCZ]
	adc $C0C0.w,Y		; 79 C0 C0 ; Add $C0C0.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy $C0CC.w		; CC CC C0 ; Compare $C0CC.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $10, $C2		; 10 C2 ; Branch if plus to $10, $C2 [Flow: branch]
	sbc $C1CD.w		; ED CD C1 ; Subtract $C1CD.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	dec $34E1.w		; CE E1 34 ; Decrement $34E1.w [Flags: NZ]
	.db $70, $20		; 70 20 ; Branch if overflow set to $70, $20 [Flow: branch]
	tsb $1B11.w		; 0C 11 1B ; Test and set bits $1B11.w [Reads: Accumulator] [Flags: Z]
	pea $DD72.w		; F4 72 DD ; Push absolute address $DD72.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	cpy $7C76.w		; CC 76 7C ; Compare $7C76.w with Y register [Reads: Y Index] [Flags: NCZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	tsb $CC.b		; 04 CC ; Test and set bits $CC.b [Reads: Accumulator] [Flags: Z]
	ora ($9C.b,S),Y		; 13 9C ; OR accumulator (stack relative indirect indexed) ($9C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc #$190E.w		; E9 0E 19 ; Subtract #$190E.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cpy $D3DD.w		; CC DD D3 ; Compare $D3DD.w with Y register [Reads: Y Index] [Flags: NCZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	adc $DCCC.w,Y		; 79 CC DC ; Add $DCCC.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $13		; D0 13 ; Branch if not equal to $D0, $13 [Flow: branch]
	dec $D212.w		; CE 12 D2 ; Decrement $D212.w [Flags: NZ]
	and [$D3.b],Y		; 37 D3 ; AND accumulator with memory (long indexed) [$D3.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ldy $A4.b		; A4 A4 ; Load $A4.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	bit $71CC.w		; 2C CC 71 ; Test bits $71CC.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	sbc [$6C.b]		; E7 6C ; Subtract with carry (long) [$6C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cmp ($11.b,X)		; C1 11 ; Compare accumulator ($11.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	cmp [$CC.b]		; C7 CC ; Compare accumulator (long) [$CC.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cop $D4.b		; 02 D4 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	jmp ($207D.w)		; 6C 7D 20 ; Jump indirect to ($207D.w) [Flow: jump]
	trb $E778.w		; 1C 78 E7 ; Test and reset bits $E778.w [Reads: Accumulator] [Flags: Z]
	eor ($0A.b),Y		; 51 0A ; Exclusive OR accumulator with memory ($0A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($1D.b,X)		; C1 1D ; Compare accumulator ($1D.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	sbc $C7C7.w		; ED C7 C7 ; Subtract $C7C7.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cmp [$12.b],Y		; D7 12 ; Compare accumulator (long indexed) [$12.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	jsl $DFCD0A.l		; 22 0A CD DF ; Jump to subroutine long $DFCD0A.l [Writes: Stack Pointer] [Flow: call]
	tsb $D2.b		; 04 D2 ; Test and set bits $D2.b [Reads: Accumulator] [Flags: Z]
	and $87C1.w		; 2D C1 87 ; Logical AND $87C1.w with accumulator [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $CC.b		; 25 CC ; Logical AND $CC.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp ($A0.b,S),Y		; D3 A0 ; Compare accumulator (stack relative indirect indexed) ($A0.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	cmp $328784.l,X		; DF 84 87 32 ; Compare accumulator (long,X) $328784.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	cpy $3601.w		; CC 01 36 ; Compare $3601.w with Y register [Reads: Y Index] [Flags: NCZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	tsb $D2.b		; 04 D2 ; Test and set bits $D2.b [Reads: Accumulator] [Flags: Z]
	cmp $7C85.w		; CD 85 7C ; Compare $7C85.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$CC.b]		; 07 CC ; OR accumulator with memory (long) [$CC.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $6DC8.w,X		; DD C8 6D ; Compare accumulator $6DC8.w,X [Reads: X Index] [Flags: NCZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ora $C1CD01.l		; 0F 01 CD C1 ; OR accumulator with memory (long) $C1CD01.l [Writes: Accumulator] [Flags: NZ]
	jmp ($375C.w,X)		; 7C 5C 37 ; Jump indirect indexed to ($375C.w,X) [Reads: X Index] [Flow: jump]
	cpy $7912.w		; CC 12 79 ; Compare $7912.w with Y register [Reads: Y Index] [Flags: NCZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $CD12.w,Y		; 19 12 CD ; OR accumulator with memory $CD12.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $BC1F.w,X		; DD 1F BC ; Compare accumulator $BC1F.w,X [Reads: X Index] [Flags: NCZ]
	ldy $D2CE.w,X		; BC CE D2 ; Load Y register $D2CE.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	jsr $119B.w		; 20 9B 11 ; Jump to subroutine at $119B.w [Writes: Stack Pointer] [Flow: call]
	ora ($6F.b)		; 12 6F ; OR accumulator with memory (indirect) ($6F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $DADC.w		; CD DC DA ; Compare $DADC.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora ($DA.b),Y		; 11 DA ; OR accumulator with memory ($DA.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc ($CD.b)		; 72 CD ; Add with carry (indirect) ($CD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cpy $C2C0.w		; CC C0 C2 ; Compare $C2C0.w with Y register [Reads: Y Index] [Flags: NCZ]
	sbc $CC71.w		; ED 71 CC ; Subtract $CC71.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	trb $7111.w		; 1C 11 71 ; Test and reset bits $7111.w [Reads: Accumulator] [Flags: Z]
	sbc ($77.b,S),Y		; F3 77 ; Subtract with carry (stack relative indirect indexed) ($77.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	jmp.w [$F3CC]		; DC CC F3 ; Jump long indirect [$F3CC] [Flow: jump]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sbc [$F4.b],Y		; F7 F4 ; Subtract with carry (long indexed) [$F4.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy $C2CC.w		; CC CC C2 ; Compare $C2CC.w with Y register [Reads: Y Index] [Flags: NCZ]
	inc $78.b		; E6 78 ; Increment $78.b [Reads: Direct Page] [Flags: NZ]
	adc $CCC0.w,X		; 7D C0 CC ; Add $CCC0.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp ($3424.w,X)		; 7C 24 34 ; Jump indirect indexed to ($3424.w,X) [Reads: X Index] [Flow: jump]
	adc $0CCD.w,X		; 7D CD 0C ; Add $0CCD.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp ($C77C.w,X)		; 7C 7C C7 ; Jump indirect indexed to ($C77C.w,X) [Reads: X Index] [Flow: jump]
	bit $CC.b,X		; 34 CC ; Test bits $CC.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	jsr $6CAD.w		; 20 AD 6C ; Jump to subroutine at $6CAD.w [Writes: Stack Pointer] [Flow: call]
	tsb $21C7.w		; 0C C7 21 ; Test and set bits $21C7.w [Reads: Accumulator] [Flags: Z]
	cmp ($C2.b)		; D2 C2 ; Compare accumulator (indirect) ($C2.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	bit $E7.b,X		; 34 E7 ; Test bits $E7.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cpy #$FD16.w		; C0 16 FD ; Compare #$FD16.w with Y register [Reads: Y Index] [Flags: NCZ]
	tsb $D31F.w		; 0C 1F D3 ; Test and set bits $D31F.w [Reads: Accumulator] [Flags: Z]
	cmp $34BC.w		; CD BC 34 ; Compare $34BC.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	sbc [$25.b]		; E7 25 ; Subtract with carry (long) [$25.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($DC31.w,X)		; FC 31 DC ; Jump to subroutine indirect indexed ($DC31.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $0403.w,X		; FE 03 04 ; Increment memory $0403.w,X [Reads: X Index] [Flags: NZ]
	ora $04DBCD.l,X		; 1F CD DB 04 ; Logical OR long $04DBCD.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sbc $C1DD.w		; ED DD C1 ; Subtract $C1DD.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cmp $04.b		; C5 04 ; Compare $04.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	brk $AC.b		; 00 AC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $ED32.w		; 2D 32 ED ; Logical AND $ED32.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($13.b)		; 12 13 ; OR accumulator with memory (indirect) ($13.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $13.b		; 14 13 ; Test and reset bits $13.b [Reads: Accumulator] [Flags: Z]
	and ($ED.b,S),Y		; 33 ED ; AND accumulator (stack relative indirect indexed) ($ED.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($13.b)		; 12 13 ; OR accumulator with memory (indirect) ($13.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($13.b,S),Y		; 13 13 ; OR accumulator (stack relative indirect indexed) ($13.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($34.b,S),Y		; 33 34 ; AND accumulator (stack relative indirect indexed) ($34.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor ($BD.b,S),Y		; 53 BD ; XOR accumulator (stack relative indirect indexed) ($BD.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $2201.w,X		; BD 01 22 ; Load $2201.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy $6C.b		; C4 6C ; Compare $6C.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	eor ($D0.b),Y		; 51 D0 ; Exclusive OR accumulator with memory ($D0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($12.b,X)		; 01 12 ; Logical OR ($12.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp ($0B.b)		; D2 0B ; Compare accumulator (indirect) ($0B.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cmp ($2D.b)		; D2 2D ; Compare accumulator (indirect) ($2D.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp ($FE.b)		; D2 FE ; Compare accumulator (indirect) ($FE.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp [$0A.b]		; C7 0A ; Compare accumulator (long) [$0A.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sbc $DBD2C2.l,X		; FF C2 D2 DB ; Subtract with carry (long,X) $DBD2C2.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $0C9B.w,Y		; B9 9B 0C ; Load $0C9B.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cpy $109C.w		; CC 9C 10 ; Compare $109C.w with Y register [Reads: Y Index] [Flags: NCZ]
	and $CD2F.w		; 2D 2F CD ; Logical AND $CD2F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp $352D.w,X		; DD 2D 35 ; Compare accumulator $352D.w,X [Reads: X Index] [Flags: NCZ]
	and [$34.b],Y		; 37 34 ; AND accumulator with memory (long indexed) [$34.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $34DD.w,X		; DD DD 34 ; Compare accumulator $34DD.w,X [Reads: X Index] [Flags: NCZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	bit $38.b,X		; 34 38 ; Test bits $38.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cmp $34DD.w,X		; DD DD 34 ; Compare accumulator $34DD.w,X [Reads: X Index] [Flags: NCZ]
	sec		; 38 ; Set carry flag [Flags: C]
	and $DD34.w,Y		; 39 34 DD ; AND accumulator with memory $DD34.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $3F3E.w,X		; DD 3E 3F ; Compare accumulator $3F3E.w,X [Reads: X Index] [Flags: NCZ]
	and $D0DD34.l,X		; 3F 34 DD D0 ; AND accumulator with memory (long,X) $D0DD34.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	eor ($48.b,X)		; 41 48 ; Exclusive OR accumulator with memory ($48.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cmp $40DD.w,X		; DD DD 40 ; Compare accumulator $40DD.w,X [Reads: X Index] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $50, $40		; 50 40 ; Branch if overflow clear to $50, $40 [Flow: branch]
	cmp $4A8D.w,X		; DD 8D 4A ; Compare accumulator $4A8D.w,X [Reads: X Index] [Flags: NCZ]
	eor ($52.b)		; 52 52 ; Exclusive OR accumulator with memory (indirect) ($52.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $50, $DD		; 50 DD ; Branch if overflow clear to $50, $DD [Flow: branch]
	cld		; D8 ; Clear decimal flag [Flags: D]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	eor ($49.b,S),Y		; 53 49 ; XOR accumulator (stack relative indirect indexed) ($49.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $50, $DD		; 50 DD ; Branch if overflow clear to $50, $DD [Flow: branch]
	cld		; D8 ; Clear decimal flag [Flags: D]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	.db $50, $50		; 50 50 ; Branch if overflow clear to $50, $50 [Flow: branch]
	eor $D8.b,X		; 55 D8 ; Exclusive OR accumulator with memory $D8.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $50, $40		; 50 40 ; Branch if overflow clear to $50, $40 [Flow: branch]
	eor $55.b,X		; 55 55 ; Exclusive OR accumulator with memory $55.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sta $5AD8.w		; 8D D8 5A ; Store accumulator to $5AD8.w [Reads: Accumulator]
	mvn $50,$50		; 54 50 50 ; Move block negative $50,$50 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	eor $40.b,X		; 55 40 ; Exclusive OR accumulator with memory $40.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	cmp $5CDD.w,X		; DD DD 5C ; Compare accumulator $5CDD.w,X [Reads: X Index] [Flags: NCZ]
	lsr $675F.w,X		; 5E 5F 67 ; Logical shift right $675F.w,X [Reads: X Index] [Flags: NCZ]
	cmp $5DDD.w,X		; DD DD 5D ; Compare accumulator $5DDD.w,X [Reads: X Index] [Flags: NCZ]
	adc ($69.b,X)		; 61 69 ; Add with carry ($69.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $5FDDDD.l,X		; 5F DD DD 5F ; Exclusive OR accumulator with memory (long,X) $5FDDDD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc $DD66.w		; 6D 66 DD ; Add $DD66.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp $5D5F.w,X		; DD 5F 5D ; Compare accumulator $5D5F.w,X [Reads: X Index] [Flags: NCZ]
	stz $76.b,X		; 74 76 ; Store zero to $76.b,X [Reads: X Index]
	cmp $78DD.w,X		; DD DD 78 ; Compare accumulator $78DD.w,X [Reads: X Index] [Flags: NCZ]
	eor $DD795F.l,X		; 5F 5F 79 DD ; Exclusive OR accumulator with memory (long,X) $DD795F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $6C6A.w,X		; DD 6A 6C ; Compare accumulator $6C6A.w,X [Reads: X Index] [Flags: NCZ]
	adc $DD7C.w		; 6D 7C DD ; Add $DD7C.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp $895F.w,X		; DD 5F 89 ; Compare accumulator $895F.w,X [Reads: X Index] [Flags: NCZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $8EDD.w,X		; DD DD 8E ; Compare accumulator $8EDD.w,X [Reads: X Index] [Flags: NCZ]
	sta $DD9091.l		; 8F 91 90 DD ; Store accumulator (long) $DD9091.l [Reads: Accumulator]
	cmp $9393.w,X		; DD 93 93 ; Compare accumulator $9393.w,X [Reads: X Index] [Flags: NCZ]
	stz $DD99.w		; 9C 99 DD ; Store zero to $DD99.w
	cmp $939E.w,X		; DD 9E 93 ; Compare accumulator $939E.w,X [Reads: X Index] [Flags: NCZ]
	sta $DD99.w,X		; 9D 99 DD ; Store accumulator to $DD99.w,X [Reads: Accumulator, X Index]
	cmp $9FA2.w,X		; DD A2 9F ; Compare accumulator $9FA2.w,X [Reads: X Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $FF00.w,X		; DD 00 FF ; Compare accumulator $FF00.w,X [Reads: X Index] [Flags: NCZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $00FFFF.l,X		; FF FF FF 00 ; Subtract with carry (long,X) $00FFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $15.b		; 00 15 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $19.b		; 00 19 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $25.b		; 00 25 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2E.b		; 00 2E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $31.b		; 00 31 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $35.b		; 00 35 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3B.b		; 00 3B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $41.b		; 00 41 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $47.b		; 00 47 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $4A.b		; 00 4A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $4D.b		; 00 4D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $50.b		; 00 50 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $53.b		; 00 53 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $56.b		; 00 56 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $59.b		; 00 59 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $5C.b		; 00 5C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $5F.b		; 00 5F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $61.b		; 00 61 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $64.b		; 00 64 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $67.b		; 00 67 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $6A.b		; 00 6A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $6D.b		; 00 6D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $73.b		; 00 73 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $75.b		; 00 75 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7B.b		; 00 7B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $86.b		; 00 86 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $88.b		; 00 88 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8B.b		; 00 8B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8E.b		; 00 8E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $93.b		; 00 93 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $95.b		; 00 95 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $98.b		; 00 98 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9B.b		; 00 9B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9D.b		; 00 9D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9F.b		; 00 9F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A2.b		; 00 A2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A4.b		; 00 A4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A7.b		; 00 A7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A9.b		; 00 A9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $AB.b		; 00 AB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $AE.b		; 00 AE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B0.b		; 00 B0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B2.b		; 00 B2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B5.b		; 00 B5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B7.b		; 00 B7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B9.b		; 00 B9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BB.b		; 00 BB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BD.b		; 00 BD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BF.b		; 00 BF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C1.b		; 00 C1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C3.b		; 00 C3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C5.b		; 00 C5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C7.b		; 00 C7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C9.b		; 00 C9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CB.b		; 00 CB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CD.b		; 00 CD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CF.b		; 00 CF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D1.b		; 00 D1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D3.b		; 00 D3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D4.b		; 00 D4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D6.b		; 00 D6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D8.b		; 00 D8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D9.b		; 00 D9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DB.b		; 00 DB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DD.b		; 00 DD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DE.b		; 00 DE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E1.b		; 00 E1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E3.b		; 00 E3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E4.b		; 00 E4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E6.b		; 00 E6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E7.b		; 00 E7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EA.b		; 00 EA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EB.b		; 00 EB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EC.b		; 00 EC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $ED.b		; 00 ED ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EE.b		; 00 EE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F1.b		; 00 F1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F2.b		; 00 F2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F3.b		; 00 F3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F5.b		; 00 F5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F6.b		; 00 F6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F9.b		; 00 F9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F9.b		; 00 F9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F9.b		; 00 F9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F9.b		; 00 F9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F6.b		; 00 F6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F5.b		; 00 F5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F3.b		; 00 F3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F2.b		; 00 F2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F1.b		; 00 F1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EE.b		; 00 EE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $ED.b		; 00 ED ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EC.b		; 00 EC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EB.b		; 00 EB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EA.b		; 00 EA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E7.b		; 00 E7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E6.b		; 00 E6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E4.b		; 00 E4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E3.b		; 00 E3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E1.b		; 00 E1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DE.b		; 00 DE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DD.b		; 00 DD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DB.b		; 00 DB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D9.b		; 00 D9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D8.b		; 00 D8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D6.b		; 00 D6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D4.b		; 00 D4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D3.b		; 00 D3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D1.b		; 00 D1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CF.b		; 00 CF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CD.b		; 00 CD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CB.b		; 00 CB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C9.b		; 00 C9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C7.b		; 00 C7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C5.b		; 00 C5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C3.b		; 00 C3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C1.b		; 00 C1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BF.b		; 00 BF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BD.b		; 00 BD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BB.b		; 00 BB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B9.b		; 00 B9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B7.b		; 00 B7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B5.b		; 00 B5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B2.b		; 00 B2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B0.b		; 00 B0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $AE.b		; 00 AE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $AB.b		; 00 AB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A9.b		; 00 A9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A7.b		; 00 A7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A4.b		; 00 A4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A2.b		; 00 A2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9F.b		; 00 9F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9D.b		; 00 9D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9B.b		; 00 9B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $98.b		; 00 98 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $95.b		; 00 95 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $93.b		; 00 93 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8E.b		; 00 8E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8B.b		; 00 8B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $88.b		; 00 88 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $86.b		; 00 86 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7B.b		; 00 7B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $75.b		; 00 75 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $73.b		; 00 73 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $6D.b		; 00 6D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $6A.b		; 00 6A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $67.b		; 00 67 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $64.b		; 00 64 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $61.b		; 00 61 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $5F.b		; 00 5F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $5C.b		; 00 5C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $59.b		; 00 59 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $56.b		; 00 56 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $53.b		; 00 53 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $50.b		; 00 50 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $4D.b		; 00 4D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $4A.b		; 00 4A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $47.b		; 00 47 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $41.b		; 00 41 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3B.b		; 00 3B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $35.b		; 00 35 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $31.b		; 00 31 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2E.b		; 00 2E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2B.b		; 00 2B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $25.b		; 00 25 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $19.b		; 00 19 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $15.b		; 00 15 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $A60003.l,X		; FF 03 00 A6 ; Subtract with carry (long,X) $A60003.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A7.b		; 00 A7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $FB.b		; 02 FB ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $A60003.l,X		; FF 03 00 A6 ; Subtract with carry (long,X) $A60003.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A7.b		; 00 A7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $FB.b		; 02 FB ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $AB0003.l,X		; FF 03 00 AB ; Subtract with carry (long,X) $AB0003.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A7.b		; 00 A7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $FB.b		; 02 FB ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $A60003.l,X		; FF 03 00 A6 ; Subtract with carry (long,X) $A60003.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A7.b		; 00 A7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F5.b		; 00 F5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $00008A.l,X		; FF 8A 00 00 ; Subtract with carry (long,X) $00008A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $FB.b		; 02 FB ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $AB0003.l,X		; FF 03 00 AB ; Subtract with carry (long,X) $AB0003.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $88.b		; 00 88 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $FB.b		; 02 FB ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $A60003.l,X		; FF 03 00 A6 ; Subtract with carry (long,X) $A60003.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $8B.b		; 02 8B ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	lda #$8504.w		; A9 04 85 ; Load #$8504.w into accumulator [Writes: Accumulator] [Flags: NZ]
	asl $64.b		; 06 64 ; Arithmetic shift left $64.b [Reads: Direct Page] [Flags: NCZ]
	ora [$BD.b]		; 07 BD ; OR accumulator with memory (long) [$BD.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpy #$0A0D.w		; C0 0D 0A ; Compare #$0A0D.w with Y register [Reads: Y Index] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc #$8500.w		; 69 00 85 ; Add #$8500.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	lda #$69EA.w		; A9 EA 69 ; Load #$69EA.w into accumulator [Writes: Accumulator] [Flags: NZ]
	brk $85.b		; 00 85 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$7522.w		; 09 22 75 ; Logical OR #$7522.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp $6BAB05.l,X		; DF 05 AB 6B ; Compare accumulator (long,X) $6BAB05.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	lda $0301.w		; AD 01 03 ; Load $0301.w into accumulator [Writes: Accumulator] [Flags: NZ]
	and #$F00A.w		; 29 0A F0 ; Logical AND #$F00A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($A5.b,S),Y		; 13 A5 ; OR accumulator (stack relative indirect indexed) ($A5.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	mvp $80,$C9		; 44 C9 80 ; Move block positive $80,$C9 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	.db $F0, $0D		; F0 0D ; Branch if equal to $F0, $0D [Flow: branch]
	jsl $06F57E.l		; 22 7E F5 06 ; Jump to subroutine long $06F57E.l [Writes: Stack Pointer] [Flow: call]
	jsl $0683EA.l		; 22 EA 83 06 ; Jump to subroutine long $0683EA.l [Writes: Stack Pointer] [Flow: call]
	jsl $0683E6.l		; 22 E6 83 06 ; Jump to subroutine long $0683E6.l [Writes: Stack Pointer] [Flow: call]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	clc		; 18 ; Clear carry flag [Flags: C]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $F2.b		; A5 F2 ; Load $F2.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$D010.w		; 29 10 D0 ; Logical AND #$D010.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $4C.b,S		; 03 4C ; OR accumulator with stack relative $4C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and #$C2EB.w		; 29 EB C2 ; Logical AND #$C2EB.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $D9AF.w		; 20 AF D9 ; Jump to subroutine at $D9AF.w [Writes: Stack Pointer] [Flow: call]
	ora $70.b,S		; 03 70 ; OR accumulator with stack relative $70.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp #$0001.w		; C9 01 00 ; Compare #$0001.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $78		; D0 78 ; Branch if not equal to $D0, $78 [Flow: branch]
	lda $7003DB.l		; AF DB 03 70 ; Load long $7003DB.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$0000.w		; C9 00 00 ; Compare #$0000.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $6F		; D0 6F ; Branch if not equal to $D0, $6F [Flow: branch]
	lda $7003DD.l		; AF DD 03 70 ; Load long $7003DD.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$0006.w		; C9 06 00 ; Compare #$0006.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $66		; D0 66 ; Branch if not equal to $D0, $66 [Flow: branch]
	lda $7003DF.l		; AF DF 03 70 ; Load long $7003DF.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$0004.w		; C9 04 00 ; Compare #$0004.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $5D		; D0 5D ; Branch if not equal to $D0, $5D [Flow: branch]
.ACCU 8
	sep #$20		; E2 20
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF37B.l		; 8F 7B F3 7E ; Store accumulator (long) $7EF37B.l [Reads: Accumulator]
	lda $F6.b		; A5 F6 ; Load $F6.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $04EB33.l		; 22 33 EB 04 ; Jump to subroutine long $04EB33.l [Writes: Stack Pointer] [Flow: call]
	lda $7EF359.l		; AF 59 F3 7E ; Load long $7EF359.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$04.b		; C9 04 ; Compare #$04.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $0B		; D0 0B ; Branch if not equal to $D0, $0B [Flow: branch]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF35A.l		; 8F 5A F3 7E ; Store accumulator (long) $7EF35A.l [Reads: Accumulator]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $7EF35B.l		; 8F 5B F3 7E ; Store accumulator (long) $7EF35B.l [Reads: Accumulator]
	lda $F4.b		; A5 F4 ; Load $F4.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $08		; 10 08 ; Branch if plus to $10, $08 [Flow: branch]
	lda $037F.w		; AD 7F 03 ; Load $037F.w into accumulator [Writes: Accumulator] [Flags: NZ]
	eor #$01.b		; 49 01 ; Exclusive OR #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $037F.w		; 8D 7F 03 ; Store accumulator to $037F.w [Reads: Accumulator]
	bit $F4.b		; 24 F4 ; Test bits $F4.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	.db $50, $2B		; 50 2B ; Branch if overflow clear to $50, $2B [Flow: branch]
	lda #$FF.b		; A9 FF ; Load #$FF.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF372.l		; 8F 72 F3 7E ; Store accumulator (long) $7EF372.l [Reads: Accumulator]
	sta $7EF373.l		; 8F 73 F3 7E ; Store accumulator (long) $7EF373.l [Reads: Accumulator]
	sta $7EF375.l		; 8F 75 F3 7E ; Store accumulator (long) $7EF375.l [Reads: Accumulator]
	sta $7EF376.l		; 8F 76 F3 7E ; Store accumulator (long) $7EF376.l [Reads: Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $7EF360.l		; 6F 60 F3 7E ; Add with carry (long) $7EF360.l [Writes: Accumulator] [Flags: NCVZ]
	sta $7EF360.l		; 8F 60 F3 7E ; Store accumulator (long) $7EF360.l [Reads: Accumulator]
	lda $7EF361.l		; AF 61 F3 7E ; Load long $7EF361.l into accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $7EF361.l		; 8F 61 F3 7E ; Store accumulator (long) $7EF361.l [Reads: Accumulator]
	lda #$09.b		; A9 09 ; Load #$09.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF36F.l		; 8F 6F F3 7E ; Store accumulator (long) $7EF36F.l [Reads: Accumulator]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

.ACCU 8
	sep #$20		; E2 20
	lda $F3.b		; A5 F3 ; Load $F3.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$10.b		; 29 10 ; Logical AND #$10.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $31		; F0 31 ; Branch if equal to $F0, $31 [Flow: branch]
	lda $F7.b		; A5 F7 ; Load $F7.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $2D		; 10 2D ; Branch if plus to $10, $2D [Flow: branch]
	lda $7EF359.l		; AF 59 F3 7E ; Load long $7EF359.l into accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cmp #$05.b		; C9 05 ; Compare #$05.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $02		; 90 02 ; Branch if carry clear to $90, $02 [Flow: branch]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF359.l		; 8F 59 F3 7E ; Store accumulator (long) $7EF359.l [Reads: Accumulator]
	lda $7EF35B.l		; AF 5B F3 7E ; Load long $7EF35B.l into accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $02		; D0 02 ; Branch if not equal to $D0, $02 [Flow: branch]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF35B.l		; 8F 5B F3 7E ; Store accumulator (long) $7EF35B.l [Reads: Accumulator]
	lda $7EF35A.l		; AF 5A F3 7E ; Load long $7EF35A.l into accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cmp #$04.b		; C9 04 ; Compare #$04.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $02		; D0 02 ; Branch if not equal to $D0, $02 [Flow: branch]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF35A.l		; 8F 5A F3 7E ; Store accumulator (long) $7EF35A.l [Reads: Accumulator]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ldx #$BD00.w		; A2 00 BD ; Load #$BD00.w into X register [Writes: X Index] [Flags: NZ]
	.db $10, $0D		; 10 0D ; Branch if plus to $10, $0D [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda $0D30.w,X		; BD 30 0D ; Load $0D30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda $0D20.w,X		; BD 20 0D ; Load $0D20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D10.w,X		; 9D 10 0D ; Store accumulator to $0D10.w,X [Reads: Accumulator, X Index]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D30.w,X		; 9D 30 0D ; Store accumulator to $0D30.w,X [Reads: Accumulator, X Index]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D00.w,X		; 9D 00 0D ; Store accumulator to $0D00.w,X [Reads: Accumulator, X Index]
	lda $03.b		; A5 03 ; Load $03.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D20.w,X		; 9D 20 0D ; Store accumulator to $0D20.w,X [Reads: Accumulator, X Index]
	stz $0F70.w,X		; 9E 70 0F ; Store zero to $0F70.w,X [Reads: X Index]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $06EA1A.l		; 22 1A EA 06 ; Jump to subroutine long $06EA1A.l [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $0F70.w,X		; 9D 70 0F ; Store accumulator to $0F70.w,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $0D20.w,X		; 9D 20 0D ; Store accumulator to $0D20.w,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $0D00.w,X		; 9D 00 0D ; Store accumulator to $0D00.w,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $0D30.w,X		; 9D 30 0D ; Store accumulator to $0D30.w,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $0D10.w,X		; 9D 10 0D ; Store accumulator to $0D10.w,X [Reads: Accumulator, X Index]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsl $06EA1A.l		; 22 1A EA 06 ; Jump to subroutine long $06EA1A.l [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	inc $FF.b,X		; F6 FF ; Increment memory $FF.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	asl $C000.w		; 0E 00 C0 ; Arithmetic shift left $C000.w [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $FB.b		; 02 FB ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $C00010.l,X		; FF 10 00 C0 ; Subtract with carry (long,X) $C00010.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $12FF.w,X		; FE FF 12 ; Increment memory $12FF.w,X [Reads: X Index] [Flags: NZ]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	cpy #$0000.w		; C0 00 00 ; Compare #$0000.w with Y register [Reads: Y Index] [Flags: NCZ]
	cop $0A.b		; 02 0A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $44.b		; 04 44 ; Test and set bits $44.b [Reads: Accumulator] [Flags: Z]
	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $EBE3.w,Y		; B9 E3 EB ; Load $EBE3.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda $0B89.w,X		; BD 89 0B ; Load $0B89.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$F0.b		; 29 F0 ; Logical AND #$F0.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0B89.w,X		; 9D 89 0B ; Store accumulator to $0B89.w,X [Reads: Accumulator, X Index]
	jsl $0DBA88.l		; 22 88 BA 0D ; Jump to subroutine long $0DBA88.l [Writes: Stack Pointer] [Flow: call]
.ACCU 16
	rep #$20		; C2 20
	lda #$EBB3.w		; A9 B3 EB ; Load #$EBB3.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	lda #$06.b		; A9 06 ; Load #$06.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $05DF6C.l		; 22 6C DF 05 ; Jump to subroutine long $05DF6C.l [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $04EC.w,Y		; F9 EC 04 ; Subtract with carry $04EC.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and $ED.b		; 25 ED ; Logical AND $ED.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $4E.b		; 04 4E ; Test and set bits $4E.b [Reads: Accumulator] [Flags: Z]
	sbc $7704.w		; ED 04 77 ; Subtract $7704.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sbc $A004.w		; ED 04 A0 ; Subtract $A004.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sbc $C904.w		; ED 04 C9 ; Subtract $C904.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sbc $CE04.w		; ED 04 CE ; Subtract $CE04.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sbc $0304.w		; ED 04 03 ; Subtract $0304.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	inc $3804.w		; EE 04 38 ; Increment $3804.w [Flags: NZ]
	inc $4904.w		; EE 04 49 ; Increment $4904.w [Flags: NZ]
	inc $5A04.w		; EE 04 5A ; Increment $5A04.w [Flags: NZ]
	inc $6204.w		; EE 04 62 ; Increment $6204.w [Flags: NZ]
	inc $6A04.w		; EE 04 6A ; Increment $6A04.w [Flags: NZ]
	inc $9004.w		; EE 04 90 ; Increment $9004.w [Flags: NZ]
	inc $B604.w		; EE 04 B6 ; Increment $B604.w [Flags: NZ]
	inc $D304.w		; EE 04 D3 ; Increment $D304.w [Flags: NZ]
	inc $F004.w		; EE 04 F0 ; Increment $F004.w [Flags: NZ]
	inc $0404.w		; EE 04 04 ; Increment $0404.w [Flags: NZ]
	sbc $EF1804.l		; EF 04 18 EF ; Subtract with carry (long) $EF1804.l [Writes: Accumulator] [Flags: NCVZ]
	tsb $AC.b		; 04 AC ; Test and set bits $AC.b [Reads: Accumulator] [Flags: Z]
	sec		; 38 ; Set carry flag [Flags: C]
	ldy $BC.b		; A4 BC ; Load $BC.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	.db $50, $A4		; 50 A4 ; Branch if overflow clear to $50, $A4 [Flow: branch]
	.db $B0, $70		; B0 70 ; Branch if carry set to $B0, $70 [Flow: branch]
	ldy $C8.b		; A4 C8 ; Load $C8.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	.db $70, $A4		; 70 A4 ; Branch if overflow set to $70, $A4 [Flow: branch]
	sty $90.b,X		; 94 90 ; Store Y register $90.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	ldy $B0.b		; A4 B0 ; Load $B0.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	.db $90, $A4		; 90 A4 ; Branch if carry clear to $90, $A4 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $90, $A4		; 90 A4 ; Branch if carry clear to $90, $A4 [Flow: branch]
	sty $A8.b,X		; 94 A8 ; Store Y register $A8.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	ldy $DC.b		; A4 DC ; Load $DC.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	ldy $B8.b		; A4 B8 ; Load $B8.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	ldy $A0.b		; A4 A0 ; Load $A0.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	.db $D0, $A4		; D0 A4 ; Branch if not equal to $D0, $A4 [Flow: branch]
	.db $D0, $D0		; D0 D0 ; Branch if not equal to $D0, $D0 [Flow: branch]
	ldy $A4.b		; A4 A4 ; Load $A4.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	ldy $A0.b		; A4 A0 ; Load $A0.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	.db $70, $A4		; 70 A4 ; Branch if overflow set to $70, $A4 [Flow: branch]
	sbc $5858FF.l,X		; FF FF 58 58 ; Subtract with carry (long,X) $5858FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy $A8.b		; A4 A8 ; Load $A8.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	ldy $C8.b		; A4 C8 ; Load $C8.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	ldy $C8.b		; A4 C8 ; Load $C8.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	ldy #$D8A4.w		; A0 A4 D8 ; Load #$D8A4.w into Y register [Writes: Y Index] [Flags: NZ]
	.db $B0, $A4		; B0 A4 ; Branch if carry set to $B0, $A4 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cpy #$30A4.w		; C0 A4 30 ; Compare #$30A4.w with Y register [Reads: Y Index] [Flags: NCZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	ldy $48.b		; A4 48 ; Load $48.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	ldy $A0.b		; A4 A0 ; Load $A0.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ldy $B8.b		; A4 B8 ; Load $B8.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	.db $80, $C7		; 80 C7 ; Branch always to $80, $C7 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $B0, $C7		; B0 C7 ; Branch if carry set to $B0, $C7 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	cmp [$A0.b]		; C7 A0 ; Compare accumulator (long) [$A0.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	cmp [$FF.b]		; C7 FF ; Compare accumulator (long) [$FF.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sbc $A480B8.l,X		; FF B8 80 A4 ; Subtract with carry (long,X) $A480B8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $B0, $A4		; B0 A4 ; Branch if carry set to $B0, $A4 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	ldy $A0.b		; A4 A0 ; Load $A0.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	ldy $30.b		; A4 30 ; Load $30.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	cmp [$48.b]		; C7 48 ; Compare accumulator (long) [$48.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	cmp [$A0.b]		; C7 A0 ; Compare accumulator (long) [$A0.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cmp [$C8.b]		; C7 C8 ; Compare accumulator (long) [$C8.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ldy #$D8C7.w		; A0 C7 D8 ; Load #$D8C7.w into Y register [Writes: Y Index] [Flags: NZ]
	.db $B0, $C7		; B0 C7 ; Branch if carry set to $B0, $C7 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cpy #$58C7.w		; C0 C7 58 ; Compare #$58C7.w with Y register [Reads: Y Index] [Flags: NCZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	cmp [$A8.b]		; C7 A8 ; Compare accumulator (long) [$A8.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	cmp [$C8.b]		; C7 C8 ; Compare accumulator (long) [$C8.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	cmp [$FF.b]		; C7 FF ; Compare accumulator (long) [$FF.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sbc $A438B8.l,X		; FF B8 38 A4 ; Subtract with carry (long,X) $A438B8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $50, $A4		; 50 A4 ; Branch if overflow clear to $50, $A4 [Flow: branch]
	cld		; D8 ; Clear decimal flag [Flags: D]
	.db $50, $A4		; 50 A4 ; Branch if overflow clear to $50, $A4 [Flow: branch]
	clv		; B8 ; Clear overflow flag [Flags: V]
	ldy #$20A4.w		; A0 A4 20 ; Load #$20A4.w into Y register [Writes: Y Index] [Flags: NZ]
	ldy #$30A4.w		; A0 A4 30 ; Load #$30A4.w into Y register [Writes: Y Index] [Flags: NZ]
	.db $B0, $A4		; B0 A4 ; Branch if carry set to $B0, $A4 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $B0, $A4		; B0 A4 ; Branch if carry set to $B0, $A4 [Flow: branch]
	.db $50, $A0		; 50 A0 ; Branch if overflow clear to $50, $A0 [Flow: branch]
	ldy $A0.b		; A4 A0 ; Load $A0.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	.db $70, $C7		; 70 C7 ; Branch if overflow set to $70, $C7 [Flow: branch]
	clv		; B8 ; Clear overflow flag [Flags: V]
	.db $70, $C7		; 70 C7 ; Branch if overflow set to $70, $C7 [Flow: branch]
	.db $D0, $70		; D0 70 ; Branch if not equal to $D0, $70 [Flow: branch]
	cmp [$A0.b]		; C7 A0 ; Compare accumulator (long) [$A0.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	.db $B0, $C7		; B0 C7 ; Branch if carry set to $B0, $C7 [Flow: branch]
	.db $D0, $B0		; D0 B0 ; Branch if not equal to $D0, $B0 [Flow: branch]
	cmp [$FF.b]		; C7 FF ; Compare accumulator (long) [$FF.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sbc $A470A0.l,X		; FF A0 70 A4 ; Subtract with carry (long,X) $A470A0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	.db $70, $A4		; 70 A4 ; Branch if overflow set to $70, $A4 [Flow: branch]
	.db $D0, $70		; D0 70 ; Branch if not equal to $D0, $70 [Flow: branch]
	ldy $A0.b		; A4 A0 ; Load $A0.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	.db $B0, $A4		; B0 A4 ; Branch if carry set to $B0, $A4 [Flow: branch]
	.db $D0, $B0		; D0 B0 ; Branch if not equal to $D0, $B0 [Flow: branch]
	ldy $20.b		; A4 20 ; Load $20.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	ldy #$30C7.w		; A0 C7 30 ; Load #$30C7.w into Y register [Writes: Y Index] [Flags: NZ]
	.db $B0, $C7		; B0 C7 ; Branch if carry set to $B0, $C7 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $B0, $C7		; B0 C7 ; Branch if carry set to $B0, $C7 [Flow: branch]
	.db $50, $A0		; 50 A0 ; Branch if overflow clear to $50, $A0 [Flow: branch]
	cmp [$B8.b]		; C7 B8 ; Compare accumulator (long) [$B8.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sec		; 38 ; Set carry flag [Flags: C]
	cmp [$98.b]		; C7 98 ; Compare accumulator (long) [$98.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	.db $50, $C7		; 50 C7 ; Branch if overflow clear to $50, $C7 [Flow: branch]
	cld		; D8 ; Clear decimal flag [Flags: D]
	.db $50, $C7		; 50 C7 ; Branch if overflow clear to $50, $C7 [Flow: branch]
	clv		; B8 ; Clear overflow flag [Flags: V]
	ldy #$FFC7.w		; A0 C7 FF ; Load #$FFC7.w into Y register [Writes: Y Index] [Flags: NZ]
	sbc $A47878.l,X		; FF 78 78 A4 ; Subtract with carry (long,X) $A47878.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $9C28FF.l,X		; FF FF 28 9C ; Subtract with carry (long,X) $9C28FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy $38.b		; A4 38 ; Load $38.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	stz $38A4.w		; 9C A4 38 ; Store zero to $38A4.w
	ldy $18A4.w		; AC A4 18 ; Load $18A4.w into Y register [Writes: Y Index] [Flags: NZ]
	ldy $18A4.w		; AC A4 18 ; Load $18A4.w into Y register [Writes: Y Index] [Flags: NZ]
	ldy $18A4.w,X		; BC A4 18 ; Load Y register $18A4.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	cpy $38A4.w		; CC A4 38 ; Compare $38A4.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpy $48A4.w		; CC A4 48 ; Compare $48A4.w with Y register [Reads: Y Index] [Flags: NCZ]
	ldy $58A4.w,X		; BC A4 58 ; Load Y register $58A4.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ldy $58A4.w		; AC A4 58 ; Load $58A4.w into Y register [Writes: Y Index] [Flags: NZ]
	cpy $28A4.w		; CC A4 28 ; Compare $28A4.w with Y register [Reads: Y Index] [Flags: NCZ]
	ldy $28C7.w		; AC C7 28 ; Load $28C7.w into Y register [Writes: Y Index] [Flags: NZ]
	ldy $28C7.w,X		; BC C7 28 ; Load Y register $28C7.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	cpy $28C7.w		; CC C7 28 ; Compare $28C7.w with Y register [Reads: Y Index] [Flags: NCZ]
	jmp.w [$48C7]		; DC C7 48 ; Jump long indirect [$48C7] [Flow: jump]
	cpy $48C7.w		; CC C7 48 ; Compare $48C7.w with Y register [Reads: Y Index] [Flags: NCZ]
	jmp.w [$48C7]		; DC C7 48 ; Jump long indirect [$48C7] [Flow: jump]
	stz $FFC7.w		; 9C C7 FF ; Store zero to $FFC7.w
	sbc $A4AC28.l,X		; FF 28 AC A4 ; Subtract with carry (long,X) $A4AC28.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	ldy $28A4.w,X		; BC A4 28 ; Load Y register $28A4.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	cpy $28A4.w		; CC A4 28 ; Compare $28A4.w with Y register [Reads: Y Index] [Flags: NCZ]
	jmp.w [$48A4]		; DC A4 48 ; Jump long indirect [$48A4] [Flow: jump]
	cpy $48A4.w		; CC A4 48 ; Compare $48A4.w with Y register [Reads: Y Index] [Flags: NCZ]
	jmp.w [$48A4]		; DC A4 48 ; Jump long indirect [$48A4] [Flow: jump]
	stz $18A4.w		; [PATTERN: Memory clearing operation] 9C A4 18 ; Store zero to $18A4.w
	ldy $18C7.w		; AC C7 18 ; Load $18C7.w into Y register [Writes: Y Index] [Flags: NZ]
	ldy $18C7.w,X		; BC C7 18 ; Load Y register $18C7.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	cpy $28C7.w		; CC C7 28 ; Compare $28C7.w with Y register [Reads: Y Index] [Flags: NCZ]
	stz $38C7.w		; 9C C7 38 ; Store zero to $38C7.w
	stz $38C7.w		; 9C C7 38 ; Store zero to $38C7.w
	ldy $38C7.w		; AC C7 38 ; Load $38C7.w into Y register [Writes: Y Index] [Flags: NZ]
	cpy $48C7.w		; CC C7 48 ; Compare $48C7.w with Y register [Reads: Y Index] [Flags: NCZ]
	ldy $58C7.w,X		; BC C7 58 ; Load Y register $58C7.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ldy $58C7.w		; AC C7 58 ; Load $58C7.w into Y register [Writes: Y Index] [Flags: NZ]
	cpy $FFC7.w		; CC C7 FF ; Compare $FFC7.w with Y register [Reads: Y Index] [Flags: NCZ]
	sbc $A46830.l,X		; FF 30 68 A4 ; Subtract with carry (long,X) $A46830.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $A0		; 30 A0 ; Branch if minus to $30, $A0 [Flow: branch]
	ldy $30.b		; A4 30 ; Load $30.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cmp [$30.b]		; C7 30 ; Compare accumulator (long) [$30.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	.db $90, $C7		; 90 C7 ; Branch if carry clear to $90, $C7 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	cmp [$FF.b]		; C7 FF ; Compare accumulator (long) [$FF.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sbc $A47830.l,X		; FF 30 78 A4 ; Subtract with carry (long,X) $A47830.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $90		; 30 90 ; Branch if minus to $30, $90 [Flow: branch]
	ldy $78.b		; A4 78 ; Load $78.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	ldy $30.b		; A4 30 ; Load $30.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	cmp [$30.b]		; C7 30 ; Compare accumulator (long) [$30.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ldy #$FFC7.w		; A0 C7 FF ; Load #$FFC7.w into Y register [Writes: Y Index] [Flags: NZ]
	sbc $A45878.l,X		; FF 78 58 A4 ; Subtract with carry (long,X) $A45878.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sec		; 38 ; Set carry flag [Flags: C]
	cmp [$FF.b]		; C7 FF ; Compare accumulator (long) [$FF.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sbc $A43878.l,X		; FF 78 38 A4 ; Subtract with carry (long,X) $A43878.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	cmp [$FF.b]		; C7 FF ; Compare accumulator (long) [$FF.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sbc $A4B028.l,X		; FF 28 B0 A4 ; Subtract with carry (long,X) $A4B028.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sec		; 38 ; Set carry flag [Flags: C]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ldy $40.b		; A4 40 ; Load $40.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	.db $B0, $C7		; B0 C7 ; Branch if carry set to $B0, $C7 [Flow: branch]
	.db $50, $D0		; 50 D0 ; Branch if overflow clear to $50, $D0 [Flow: branch]
	cmp [$1C.b]		; C7 1C ; Compare accumulator (long) [$1C.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	ldy $58.b		; A4 58 ; Load $58.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	ldy $78.b		; A4 78 ; Load $78.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	ldy $A0.b		; A4 A0 ; Load $A0.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	ldy $38.b		; A4 38 ; Load $38.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	cmp [$58.b]		; C7 58 ; Compare accumulator (long) [$58.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	cmp [$B0.b]		; C7 B0 ; Compare accumulator (long) [$B0.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sec		; 38 ; Set carry flag [Flags: C]
	cmp [$D0.b]		; C7 D0 ; Compare accumulator (long) [$D0.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	cmp [$FF.b]		; C7 FF ; Compare accumulator (long) [$FF.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sbc $A4B040.l,X		; FF 40 B0 A4 ; Subtract with carry (long,X) $A4B040.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $50, $D0		; 50 D0 ; Branch if overflow clear to $50, $D0 [Flow: branch]
	ldy $28.b		; A4 28 ; Load $28.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	.db $B0, $C7		; B0 C7 ; Branch if carry set to $B0, $C7 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cmp [$38.b]		; C7 38 ; Compare accumulator (long) [$38.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sec		; 38 ; Set carry flag [Flags: C]
	ldy $58.b		; A4 58 ; Load $58.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	ldy $B0.b		; A4 B0 ; Load $B0.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	ldy $D0.b		; A4 D0 ; Load $D0.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	ldy $1C.b		; A4 1C ; Load $1C.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	cmp [$58.b]		; C7 58 ; Compare accumulator (long) [$58.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sec		; 38 ; Set carry flag [Flags: C]
	cmp [$78.b]		; C7 78 ; Compare accumulator (long) [$78.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	cmp [$A0.b]		; C7 A0 ; Compare accumulator (long) [$A0.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sec		; 38 ; Set carry flag [Flags: C]
	cmp [$FF.b]		; C7 FF ; Compare accumulator (long) [$FF.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sbc $A44830.l,X		; FF 30 48 A4 ; Subtract with carry (long,X) $A44830.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	ldy $50.b		; A4 50 ; Load $50.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	ldy $A0.b		; A4 A0 ; Load $A0.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	ldy $B8.b		; A4 B8 ; Load $B8.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	ldy $68.b		; A4 68 ; Load $68.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	cmp [$78.b]		; C7 78 ; Compare accumulator (long) [$78.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sec		; 38 ; Set carry flag [Flags: C]
	cmp [$88.b]		; C7 88 ; Compare accumulator (long) [$88.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sec		; 38 ; Set carry flag [Flags: C]
	cmp [$B8.b]		; C7 B8 ; Compare accumulator (long) [$B8.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sec		; 38 ; Set carry flag [Flags: C]
	cmp [$FF.b]		; C7 FF ; Compare accumulator (long) [$FF.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sbc $A43868.l,X		; FF 68 38 A4 ; Subtract with carry (long,X) $A43868.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sec		; 38 ; Set carry flag [Flags: C]
	ldy $88.b		; A4 88 ; Load $88.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	ldy $B8.b		; A4 B8 ; Load $B8.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	ldy $30.b		; A4 30 ; Load $30.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	cmp [$40.b]		; C7 40 ; Compare accumulator (long) [$40.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	cmp [$50.b]		; C7 50 ; Compare accumulator (long) [$50.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	cmp [$A0.b]		; C7 A0 ; Compare accumulator (long) [$A0.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	cmp [$B8.b]		; C7 B8 ; Compare accumulator (long) [$B8.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	cmp [$FF.b]		; C7 FF ; Compare accumulator (long) [$FF.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sbc $A43098.l,X		; FF 98 30 A4 ; Subtract with carry (long,X) $A43098.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	ldy $A0.b		; A4 A0 ; Load $A0.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	ldy #$B0C7.w		; A0 C7 B0 ; Load #$B0C7.w into Y register [Writes: Y Index] [Flags: NZ]
	ldy #$C8C7.w		; A0 C7 C8 ; Load #$C8C7.w into Y register [Writes: Y Index] [Flags: NZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	cmp [$D8.b]		; C7 D8 ; Compare accumulator (long) [$D8.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	cmp [$FF.b]		; C7 FF ; Compare accumulator (long) [$FF.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sbc $C73098.l,X		; FF 98 30 C7 ; Subtract with carry (long,X) $C73098.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	cmp [$A0.b]		; C7 A0 ; Compare accumulator (long) [$A0.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ldy #$B0A4.w		; A0 A4 B0 ; Load #$B0A4.w into Y register [Writes: Y Index] [Flags: NZ]
	ldy #$C8A4.w		; A0 A4 C8 ; Load #$C8A4.w into Y register [Writes: Y Index] [Flags: NZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	ldy $D8.b		; A4 D8 ; Load $D8.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	ldy $FF.b		; A4 FF ; Load $FF.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	sbc $A42020.l,X		; FF 20 20 A4 ; Subtract with carry (long,X) $A42020.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $50, $A4		; 50 A4 ; Branch if overflow clear to $50, $A4 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	ldy $38.b		; A4 38 ; Load $38.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	ldy $50.b		; A4 50 ; Load $50.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	jsr $50A4.w		; 20 A4 50 ; Jump to subroutine at $50A4.w [Writes: Stack Pointer] [Flow: call]
	sec		; 38 ; Set carry flag [Flags: C]
	ldy $58.b		; A4 58 ; Load $58.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	.db $50, $A4		; 50 A4 ; Branch if overflow clear to $50, $A4 [Flow: branch]
	sbc $EF47FF.l,X		; FF FF 47 EF ; Subtract with carry (long,X) $EF47FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $AF.b		; 04 AF ; Test and set bits $AF.b [Reads: Accumulator] [Flags: Z]
	sbc $EFF004.l		; EF 04 F0 EF ; Subtract with carry (long) $EFF004.l [Writes: Accumulator] [Flags: NCVZ]
	tsb $4C.b		; 04 4C ; Test and set bits $4C.b [Reads: Accumulator] [Flags: Z]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	cpx $04F0.w		; EC F0 04 ; Compare $04F0.w with X register [Reads: X Index] [Flags: NCZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	sbc ($04.b),Y		; F1 04 ; Subtract with carry ($04.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy $F1.b		; A4 F1 ; Load $F1.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	tsb $18.b		; 04 18 ; Test and set bits $18.b [Reads: Accumulator] [Flags: Z]
	.db $10, $01		; 10 01 ; Branch if plus to $10, $01 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $90, $01		; 90 01 ; Branch if carry clear to $90, $01 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	cop $18.b		; 02 18 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc ($88.b,X)		; 61 88 ; Add with carry ($88.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc ($68.b,X)		; 61 68 ; Add with carry ($68.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $62, $E8, $18		; 62 E8 18 ; Push effective relative address $62, $E8, $18 [Writes: Stack Pointer]
	.db $62, $00, $00		; 62 00 00 ; Push effective relative address $62, $00, $00 [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $88.b		; 00 88 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sed		; F8 ; Set decimal flag [Flags: D]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($0021.w,X)		; FC 21 00 ; Jump to subroutine indirect indexed ($0021.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $0021.w,X		; FE 21 00 ; Increment memory $0021.w,X [Reads: X Index] [Flags: NZ]
	jsr ($0029.w,X)		; FC 29 00 ; Jump to subroutine indirect indexed ($0029.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $0029.w,X		; FE 29 00 ; Increment memory $0029.w,X [Reads: X Index] [Flags: NZ]
	jsr ($8126.w,X)		; FC 26 81 ; Jump to subroutine indirect indexed ($8126.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $8126.w,X		; FE 26 81 ; Increment memory $8126.w,X [Reads: X Index] [Flags: NZ]
	jsr ($812E.w,X)		; FC 2E 81 ; Jump to subroutine indirect indexed ($812E.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $812E.w,X		; FE 2E 81 ; Increment memory $812E.w,X [Reads: X Index] [Flags: NZ]
	sbc $02A1.w,X		; FD A1 02 ; Subtract with carry $02A1.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FD02A1.l,X		; FF A1 02 FD ; Subtract with carry (long,X) $FD02A1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $FD02A9.l,X		; FF A9 02 FD ; Subtract with carry (long,X) $FD02A9.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx $83.b		; A6 83 ; Load $83.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	sbc $FD83A6.l,X		; FF A6 83 FD ; Subtract with carry (long,X) $FD83A6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx $FF83.w		; AE 83 FF ; Load $FF83.w into X register [Writes: X Index] [Flags: NZ]
	ldx $FF83.w		; AE 83 FF ; Load $FF83.w into X register [Writes: X Index] [Flags: NZ]
	sbc $011018.l,X		; FF 18 10 01 ; Subtract with carry (long,X) $011018.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc ($88.b,X)		; 61 88 ; Add with carry ($88.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc ($68.b,X)		; 61 68 ; Add with carry ($68.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $62, $E8, $18		; 62 E8 18 ; Push effective relative address $62, $E8, $18 [Writes: Stack Pointer]
	.db $62, $00, $00		; 62 00 00 ; Push effective relative address $62, $00, $00 [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sed		; F8 ; Set decimal flag [Flags: D]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($0021.w,X)		; FC 21 00 ; Jump to subroutine indirect indexed ($0021.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $0021.w,X		; FE 21 00 ; Increment memory $0021.w,X [Reads: X Index] [Flags: NZ]
	jsr ($812E.w,X)		; FC 2E 81 ; Jump to subroutine indirect indexed ($812E.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $812E.w,X		; FE 2E 81 ; Increment memory $812E.w,X [Reads: X Index] [Flags: NZ]
	sbc $02A1.w,X		; FD A1 02 ; Subtract with carry $02A1.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FD02A1.l,X		; FF A1 02 FD ; Subtract with carry (long,X) $FD02A1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx $FF83.w		; AE 83 FF ; Load $FF83.w into X register [Writes: X Index] [Flags: NZ]
	ldx $FF83.w		; AE 83 FF ; Load $FF83.w into X register [Writes: X Index] [Flags: NZ]
	sbc $011018.l,X		; FF 18 10 01 ; Subtract with carry (long,X) $011018.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta ($01.b)		; 92 01 ; Store accumulator (indirect) ($01.b) [Reads: Direct Page, Accumulator]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cop $18.b		; 02 18 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc ($88.b,X)		; 61 88 ; Add with carry ($88.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc ($68.b,X)		; 61 68 ; Add with carry ($68.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $62, $E8, $18		; 62 E8 18 ; Push effective relative address $62, $E8, $18 [Writes: Stack Pointer]
	.db $62, $00, $00		; 62 00 00 ; Push effective relative address $62, $00, $00 [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $82, $00, $0B		; 82 00 0B ; Branch always long to $82, $00, $0B [Flow: branch]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sed		; F8 ; Set decimal flag [Flags: D]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($0021.w,X)		; FC 21 00 ; Jump to subroutine indirect indexed ($0021.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $0021.w,X		; FE 21 00 ; Increment memory $0021.w,X [Reads: X Index] [Flags: NZ]
	jsr ($0029.w,X)		; FC 29 00 ; Jump to subroutine indirect indexed ($0029.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr ($8126.w,X)		; FC 26 81 ; Jump to subroutine indirect indexed ($8126.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $812E.w,X		; FE 2E 81 ; Increment memory $812E.w,X [Reads: X Index] [Flags: NZ]
	jsr ($812E.w,X)		; FC 2E 81 ; Jump to subroutine indirect indexed ($812E.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $02A1.w,X		; FD A1 02 ; Subtract with carry $02A1.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FD02A1.l,X		; FF A1 02 FD ; Subtract with carry (long,X) $FD02A1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $83A6.w,X		; FD A6 83 ; Subtract with carry $83A6.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FD83AE.l,X		; FF AE 83 FD ; Subtract with carry (long,X) $FD83AE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx $FF83.w		; AE 83 FF ; Load $FF83.w into X register [Writes: X Index] [Flags: NZ]
	sbc $011018.l,X		; FF 18 10 01 ; Subtract with carry (long,X) $011018.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	sta ($01.b)		; 92 01 ; Store accumulator (indirect) ($01.b) [Reads: Direct Page, Accumulator]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cop $18.b		; 02 18 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc ($88.b,X)		; 61 88 ; Add with carry ($88.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc ($68.b,X)		; 61 68 ; Add with carry ($68.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $62, $E8, $18		; 62 E8 18 ; Push effective relative address $62, $E8, $18 [Writes: Stack Pointer]
	.db $62, $00, $00		; 62 00 00 ; Push effective relative address $62, $00, $00 [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $8B.b		; 00 8B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	brk $8B.b		; 00 8B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $82, $00, $8B		; 82 00 8B ; Branch always long to $82, $00, $8B [Flow: branch]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sed		; F8 ; Set decimal flag [Flags: D]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($0021.w,X)		; FC 21 00 ; Jump to subroutine indirect indexed ($0021.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $0021.w,X		; FE 21 00 ; Increment memory $0021.w,X [Reads: X Index] [Flags: NZ]
	inc $0029.w,X		; FE 29 00 ; Increment memory $0029.w,X [Reads: X Index] [Flags: NZ]
	inc $8126.w,X		; FE 26 81 ; Increment memory $8126.w,X [Reads: X Index] [Flags: NZ]
	jsr ($812E.w,X)		; FC 2E 81 ; Jump to subroutine indirect indexed ($812E.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $812E.w,X		; FE 2E 81 ; Increment memory $812E.w,X [Reads: X Index] [Flags: NZ]
	sbc $02A1.w,X		; FD A1 02 ; Subtract with carry $02A1.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FF02A1.l,X		; FF A1 02 FF ; Subtract with carry (long,X) $FF02A1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $FD83A6.l,X		; FF A6 83 FD ; Subtract with carry (long,X) $FD83A6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx $FF83.w		; AE 83 FF ; Load $FF83.w into X register [Writes: X Index] [Flags: NZ]
	ldx $FF83.w		; AE 83 FF ; Load $FF83.w into X register [Writes: X Index] [Flags: NZ]
	sbc $011018.l,X		; FF 18 10 01 ; Subtract with carry (long,X) $011018.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $90, $01		; 90 01 ; Branch if carry clear to $90, $01 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	cop $18.b		; 02 18 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc ($E8.b,X)		; 61 E8 ; Add with carry ($E8.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $62, $00, $00		; 62 00 00 ; Push effective relative address $62, $00, $00 [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $88.b		; 00 88 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($0021.w,X)		; FC 21 00 ; Jump to subroutine indirect indexed ($0021.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr ($0029.w,X)		; FC 29 00 ; Jump to subroutine indirect indexed ($0029.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr ($8126.w,X)		; FC 26 81 ; Jump to subroutine indirect indexed ($8126.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr ($812E.w,X)		; FC 2E 81 ; Jump to subroutine indirect indexed ($812E.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $FF02A1.l,X		; FF A1 02 FF ; Subtract with carry (long,X) $FF02A1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $FF83A6.l,X		; FF A6 83 FF ; Subtract with carry (long,X) $FF83A6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx $FF83.w		; AE 83 FF ; Load $FF83.w into X register [Writes: X Index] [Flags: NZ]
	sbc $011018.l,X		; FF 18 10 01 ; Subtract with carry (long,X) $011018.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $90, $01		; 90 01 ; Branch if carry clear to $90, $01 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	cop $18.b		; 02 18 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc ($8A.b,X)		; 61 8A ; Add with carry ($8A.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	adc ($6A.b,X)		; 61 6A ; Add with carry ($6A.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $62, $E8, $18		; 62 E8 18 ; Push effective relative address $62, $E8, $18 [Writes: Stack Pointer]
	.db $62, $00, $00		; 62 00 00 ; Push effective relative address $62, $00, $00 [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $88.b		; 00 88 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($60.b),Y		; 11 60 ; OR accumulator with memory ($60.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $11.b,S		; 83 11 ; Store accumulator (stack relative) $11.b,S [Reads: Stack Pointer, Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sed		; F8 ; Set decimal flag [Flags: D]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($0021.w,X)		; FC 21 00 ; Jump to subroutine indirect indexed ($0021.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $0021.w,X		; FE 21 00 ; Increment memory $0021.w,X [Reads: X Index] [Flags: NZ]
	jsr ($0029.w,X)		; FC 29 00 ; Jump to subroutine indirect indexed ($0029.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr ($8126.w,X)		; FC 26 81 ; Jump to subroutine indirect indexed ($8126.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $8126.w,X		; FE 26 81 ; Increment memory $8126.w,X [Reads: X Index] [Flags: NZ]
	jsr ($812E.w,X)		; FC 2E 81 ; Jump to subroutine indirect indexed ($812E.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $02A1.w,X		; FD A1 02 ; Subtract with carry $02A1.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FF02A1.l,X		; FF A1 02 FF ; Subtract with carry (long,X) $FF02A1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $83A6.w,X		; FD A6 83 ; Subtract with carry $83A6.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FF83A6.l,X		; FF A6 83 FF ; Subtract with carry (long,X) $FF83A6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx $FF83.w		; AE 83 FF ; Load $FF83.w into X register [Writes: X Index] [Flags: NZ]
	sbc $011018.l,X		; FF 18 10 01 ; Subtract with carry (long,X) $011018.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $90, $01		; 90 01 ; Branch if carry clear to $90, $01 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	cop $18.b		; 02 18 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc ($8A.b,X)		; 61 8A ; Add with carry ($8A.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	adc ($6A.b,X)		; 61 6A ; Add with carry ($6A.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	.db $62, $E8, $18		; 62 E8 18 ; Push effective relative address $62, $E8, $18 [Writes: Stack Pointer]
	.db $62, $00, $00		; 62 00 00 ; Push effective relative address $62, $00, $00 [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $88.b		; 00 88 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($60.b),Y		; 91 60 ; Store accumulator ($60.b),Y [Reads: Direct Page, Y Index, Accumulator]
	sta $91.b,S		; 83 91 ; Store accumulator (stack relative) $91.b,S [Reads: Stack Pointer, Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sed		; F8 ; Set decimal flag [Flags: D]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($0021.w,X)		; FC 21 00 ; Jump to subroutine indirect indexed ($0021.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr ($0029.w,X)		; FC 29 00 ; Jump to subroutine indirect indexed ($0029.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $0029.w,X		; FE 29 00 ; Increment memory $0029.w,X [Reads: X Index] [Flags: NZ]
	jsr ($8126.w,X)		; FC 26 81 ; Jump to subroutine indirect indexed ($8126.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr ($812E.w,X)		; FC 2E 81 ; Jump to subroutine indirect indexed ($812E.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $812E.w,X		; FE 2E 81 ; Increment memory $812E.w,X [Reads: X Index] [Flags: NZ]
	sbc $FD02A1.l,X		; FF A1 02 FD ; Subtract with carry (long,X) $FD02A1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $FF02A9.l,X		; FF A9 02 FF ; Subtract with carry (long,X) $FF02A9.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx $83.b		; A6 83 ; Load $83.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	sbc $83AE.w,X		; FD AE 83 ; Subtract with carry $83AE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FF83AE.l,X		; FF AE 83 FF ; Subtract with carry (long,X) $FF83AE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $011018.l,X		; FF 18 10 01 ; Subtract with carry (long,X) $011018.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc ($E8.b,X)		; 61 E8 ; Add with carry ($E8.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $62, $00, $00		; 62 00 00 ; Push effective relative address $62, $00, $00 [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($0021.w,X)		; FC 21 00 ; Jump to subroutine indirect indexed ($0021.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr ($812E.w,X)		; FC 2E 81 ; Jump to subroutine indirect indexed ($812E.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $FF02A1.l,X		; FF A1 02 FF ; Subtract with carry (long,X) $FF02A1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx $FF83.w		; AE 83 FF ; Load $FF83.w into X register [Writes: X Index] [Flags: NZ]
	sbc $C9A11B.l,X		; FF 1B A1 C9 ; Subtract with carry (long,X) $C9A11B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($A1.b),Y		; 51 A1 ; Exclusive OR accumulator with memory ($A1.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$92.b		; C9 92 ; Compare #$92.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	lda ($C9.b,X)		; A1 C9 ; Load accumulator ($C9.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lda ($33.b,X)		; A1 33 ; Load accumulator ($33.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$A1.b		; C9 A1 ; Compare #$A1.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	adc ($C9.b)		; 72 C9 ; Add with carry (indirect) ($C9.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $010BFF.l,X		; FF FF 0B 01 ; Subtract with carry (long,X) $010BFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora $010B.w,Y		; 19 0B 01 ; OR accumulator with memory $010B.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	rol $A819.w,X		; 3E 19 A8 ; Rotate left $A819.w,X [Reads: X Index] [Flags: NCZ]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $63.b,X		; 36 63 ; Rotate left $63.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $2A.b		; 00 2A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $83.b,X		; 16 83 ; Arithmetic shift left $83.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $CA.b,X		; 15 CA ; OR accumulator with memory $CA.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $B2.b		; 00 B2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $CA.b,X		; 56 CA ; Logical shift right $CA.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $BA.b		; 00 BA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $34.b,X		; 56 34 ; Logical shift right $34.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor [$34.b],Y		; 57 34 ; Exclusive OR accumulator with memory (long indexed) [$34.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $2A.b		; 00 2A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor [$34.b],Y		; 57 34 ; Exclusive OR accumulator with memory (long indexed) [$34.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $26.b		; 00 26 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	rol $59.b		; 26 59 ; Rotate left $59.b [Reads: Direct Page] [Flags: NCZ]
	mvn $2A,$00		; 54 00 2A ; Move block negative $2A,$00 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	mvn $4A,$00		; 54 00 4A ; Move block negative $4A,$00 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	mvn $2A,$00		; 54 00 2A ; Move block negative $2A,$00 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	mvn $00,$66		; 54 66 00 ; Move block negative $00,$66 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	bit $1138.w,X		; 3C 38 11 ; Test bits $1138.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	brk $5E.b		; 00 5E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $2C.b		; 46 2C ; Logical shift right $2C.b [Reads: Direct Page] [Flags: NCZ]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($0B.b,S),Y		; 13 0B ; OR accumulator (stack relative indirect indexed) ($0B.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($42.b,X)		; 01 42 ; Logical OR ($42.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $001F.w,Y		; 19 1F 00 ; OR accumulator with memory $001F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor ($5B.b)		; 52 5B ; Exclusive OR accumulator with memory (indirect) ($5B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0C00.w,Y		; 19 00 0C ; OR accumulator with memory $0C00.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $0D		; 10 0D ; Branch if plus to $10, $0D [Flow: branch]
	ora ($18.b,X)		; 01 18 ; Logical OR ($18.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor [$0D.b]		; 47 0D ; Exclusive OR accumulator with memory (long) [$0D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor [$0D.b]		; 47 0D ; Exclusive OR accumulator with memory (long) [$0D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($18.b,X)		; 01 18 ; Logical OR ($18.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor #$0D.b		; 49 0D ; Exclusive OR #$0D.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($1C.b,X)		; 01 1C ; Logical OR ($1C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor #$0D.b		; 49 0D ; Exclusive OR #$0D.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor #$0D.b		; 49 0D ; Exclusive OR #$0D.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($18.b,X)		; 01 18 ; Logical OR ($18.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $2001.w		; 0D 01 20 ; Logical OR $2001.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl $5E00.w,X		; 1E 00 5E ; Arithmetic shift left $5E00.w,X [Reads: X Index] [Flags: NCZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	stz $A400.w,X		; [PATTERN: Memory clearing operation] 9E 00 A4 ; Store zero to $A400.w,X [Reads: X Index]
	ora ($9E.b,S),Y		; 13 9E ; OR accumulator (stack relative indirect indexed) ($9E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $58.b		; 00 58 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	stz $9C00.w,X		; 9E 00 9C ; Store zero to $9C00.w,X [Reads: X Index]
	ora [$9E.b],Y		; 17 9E ; OR accumulator with memory (long indexed) [$9E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $A4.b		; 00 A4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $0097.w		; 1C 97 00 ; Test and reset bits $0097.w [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	mvn $00,$97		; 54 97 00 ; Move block negative $00,$97 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	bit $54.b		; 24 54 ; Test bits $54.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sta [$00.b],Y		; 97 00 ; Store accumulator (long indexed) [$00.b],Y [Reads: Direct Page, Y Index, Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta [$00.b],Y		; 97 00 ; Store accumulator (long indexed) [$00.b],Y [Reads: Direct Page, Y Index, Accumulator]
	bit $4A.b		; 24 4A ; Test bits $4A.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sta [$00.b],Y		; 97 00 ; Store accumulator (long indexed) [$00.b],Y [Reads: Direct Page, Y Index, Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	sta [$00.b],Y		; 97 00 ; Store accumulator (long indexed) [$00.b],Y [Reads: Direct Page, Y Index, Accumulator]
	bit $4B.b		; 24 4B ; Test bits $4B.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sta [$00.b],Y		; 97 00 ; Store accumulator (long indexed) [$00.b],Y [Reads: Direct Page, Y Index, Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	jmp $0097.w		; 4C 97 00 ; Jump to $0097.w [Flow: jump]
	bit $4C.b		; 24 4C ; Test bits $4C.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	rol $01.b		; 26 01 ; Rotate left $01.b [Reads: Direct Page] [Flags: NCZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	ora $5A5200.l,X		; 1F 00 52 5A ; Logical OR long $5A5200.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $EE00.w		; 8D 00 EE ; Store accumulator to $EE00.w [Reads: Accumulator]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	lsr $0B5A.w,X		; 5E 5A 0B ; Logical shift right $0B5A.w,X [Reads: X Index] [Flags: NCZ]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor [$4B.b],Y		; 57 4B ; Exclusive OR accumulator with memory (long indexed) [$4B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor #$F8.b		; 49 F8 ; Exclusive OR #$F8.b with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $F8.b		; 45 F8 ; Exclusive OR $F8.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $9E.b		; 00 9E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $00,$F8		; 44 F8 00 ; Move block positive $00,$F8 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	asl $F84B.w,X		; 1E 4B F8 ; Arithmetic shift left $F84B.w,X [Reads: X Index] [Flags: NCZ]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $EE.b		; 00 EE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $E6.b		; 00 E6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $EA.b		; 00 EA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $EE.b		; 00 EE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp $0046.w		; 4C 46 00 ; Jump to $0046.w [Flow: jump]
	bit $06.b		; 24 06 ; Test bits $06.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cpy #$1000.w		; C0 00 10 ; Compare #$1000.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora [$D0.b]		; 07 D0 ; OR accumulator with memory (long) [$D0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $16.b		; 00 16 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $007D.w		; 1C 7D 00 ; Test and reset bits $007D.w [Reads: Accumulator] [Flags: Z]
	sec		; 38 ; Set carry flag [Flags: C]
	ora #$B2.b		; 09 B2 ; Logical OR #$B2.b with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $5E.b		; 00 5E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$FF.b],Y		; 17 FF ; OR accumulator with memory (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	stz $6400.w,X		; 9E 00 64 ; Store zero to $6400.w,X [Reads: X Index]
	eor [$8B.b],Y		; 57 8B ; Exclusive OR accumulator with memory (long indexed) [$8B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ldx $00.b,Y		; B6 00 ; Load X register $00.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	stx $0A.b,Y		; 96 0A ; Store X register $0A.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	sta $1800.w		; 8D 00 18 ; Store accumulator to $1800.w [Reads: Accumulator]
	eor [$6B.b],Y		; 57 6B ; Exclusive OR accumulator with memory (long indexed) [$6B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $9D.b		; 06 9D ; Arithmetic shift left $9D.b [Reads: Direct Page] [Flags: NCZ]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor #$8C.b		; 49 8C ; Exclusive OR #$8C.b with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvn $00,$B6		; 54 B6 00 ; Move block negative $00,$B6 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ldx $0A.b		; A6 0A ; Load $0A.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	sta $2000.w		; 8D 00 20 ; Store accumulator to $2000.w [Reads: Accumulator]
	eor [$8D.b],Y		; 57 8D ; Exclusive OR accumulator with memory (long indexed) [$8D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	sta $1800.w		; 8D 00 18 ; Store accumulator to $1800.w [Reads: Accumulator]
	eor $008D.w,Y		; 59 8D 00 ; Exclusive OR accumulator with memory $008D.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	jsr $3A59.w		; 20 59 3A ; Jump to subroutine at $3A59.w [Writes: Stack Pointer] [Flow: call]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $011D.w		; 4E 1D 01 ; Logical shift right $011D.w [Flags: NCZ]
	bit $1D58.w,X		; 3C 58 1D ; Test bits $1D58.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	ora ($40.b,X)		; 01 40 ; Logical OR ($40.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	ora $3401.w,X		; 1D 01 34 ; OR accumulator with memory $3401.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	ora $3801.w,X		; 1D 01 38 ; OR accumulator with memory $3801.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	ora $3C01.w,X		; 1D 01 3C ; OR accumulator with memory $3C01.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	ora $4401.w,X		; 1D 01 44 ; OR accumulator with memory $4401.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	ora $4801.w,X		; 1D 01 48 ; OR accumulator with memory $4801.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	ora $4001.w,X		; 1D 01 40 ; OR accumulator with memory $4001.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	ora $4401.w,X		; 1D 01 44 ; OR accumulator with memory $4401.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	sta [$00.b],Y		; 97 00 ; Store accumulator (long indexed) [$00.b],Y [Reads: Direct Page, Y Index, Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	eor $97.b,X		; 55 97 ; Exclusive OR accumulator with memory $97.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $97.b,X		; 55 97 ; Exclusive OR accumulator with memory $97.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $97.b,X		; 56 97 ; Logical shift right $97.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $26.b,X		; 56 26 ; Logical shift right $26.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($60.b,X)		; 01 60 ; Logical OR ($60.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	mvn $01,$26		; 54 26 01 ; Move block negative $01,$26 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	mvn $01,$26		; 54 26 01 ; Move block negative $01,$26 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	jmp $012655.l		; 5C 55 26 01 ; Jump long to $012655.l [Flow: jump]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	rol $01.b		; 26 01 ; Rotate left $01.b [Reads: Direct Page] [Flags: NCZ]
	jmp ($2655.w)		; 6C 55 26 ; Jump indirect to ($2655.w) [Flow: jump]
	ora ($60.b,X)		; 01 60 ; Logical OR ($60.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lsr $26.b,X		; 56 26 ; Logical shift right $26.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($68.b,X)		; 01 68 ; Logical OR ($68.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lsr $26.b,X		; 56 26 ; Logical shift right $26.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($70.b,X)		; 01 70 ; Logical OR ($70.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lsr $26.b,X		; 56 26 ; Logical shift right $26.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($5C.b,X)		; 01 5C ; Logical OR ($5C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor [$4D.b],Y		; 57 4D ; Exclusive OR accumulator with memory (long indexed) [$4D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	eor $B000.w		; 4D 00 B0 ; Exclusive OR $B000.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	eor $A800.w		; 4D 00 A8 ; Exclusive OR $A800.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jmp $AA0043.l		; 5C 43 00 AA ; Jump long to $AA0043.l [Flow: jump]
	ora $B6.b,S		; 03 B6 ; OR accumulator with stack relative $B6.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $AA.b,S		; 03 AA ; OR accumulator with stack relative $AA.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora #$B6.b		; 09 B6 ; Logical OR #$B6.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$FF.b		; 09 FF ; Logical OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $B200CA.l,X		; FF CA 00 B2 ; Subtract with carry (long,X) $B200CA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	trb $AA.b		; 14 AA ; Test and reset bits $AA.b [Reads: Accumulator] [Flags: Z]
	asl $B2.b,X		; 16 B2 ; Arithmetic shift left $B2.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc $0099FF.l,X		; FF FF 99 00 ; Subtract with carry (long,X) $0099FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx $AA13.w,Y		; BE 13 AA ; Load X register $AA13.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	trb $1CD2.w		; 1C D2 1C ; Test and reset bits $1CD2.w [Reads: Accumulator] [Flags: Z]
	sbc $0000FF.l,X		; FF FF 00 00 ; Subtract with carry (long,X) $0000FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sty $8CF2.w		; 8C F2 8C ; Store Y register to $8CF2.w [Reads: Y Index]
	sbc $0074FF.l,X		; FF FF 74 00 ; Subtract with carry (long,X) $0074FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	ora [$C4.b]		; 07 C4 ; OR accumulator with memory (long) [$C4.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$FF.b]		; 07 FF ; OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $70008D.l,X		; FF 8D 00 70 ; Subtract with carry (long,X) $70008D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $72.b		; 04 72 ; Test and set bits $72.b [Reads: Accumulator] [Flags: Z]
	asl $1970.w		; 0E 70 19 ; Arithmetic shift left $1970.w [Flags: NCZ]
	jmp $FF1B.w		; 4C 1B FF ; Jump to $FF1B.w [Flow: jump]
	sbc $920021.l,X		; FF 21 00 92 ; Subtract with carry (long,X) $920021.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $0CEA.w		; 0C EA 0C ; Test and set bits $0CEA.w [Reads: Accumulator] [Flags: Z]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($8A.b,S),Y		; 13 8A ; OR accumulator (stack relative indirect indexed) ($8A.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	trb $FFFF.w		; 1C FF FF ; Test and reset bits $FFFF.w [Reads: Accumulator] [Flags: Z]
	jsl $13CC00.l		; 22 00 CC 13 ; Jump to subroutine long $13CC00.l [Writes: Stack Pointer] [Flow: call]
	cpy $FF1C.w		; CC 1C FF ; Compare $FF1C.w with Y register [Reads: Y Index] [Flags: NCZ]
	sbc $E20053.l,X		; FF 53 00 E2 ; Subtract with carry (long,X) $E20053.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	ora ($64.b,S),Y		; 13 64 ; OR accumulator (stack relative indirect indexed) ($64.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc $0073FF.l,X		; FF FF 73 00 ; Subtract with carry (long,X) $0073FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $0CB2.w		; 0C B2 0C ; Test and set bits $0CB2.w [Reads: Accumulator] [Flags: Z]
	sbc $000BFF.l,X		; FF FF 0B 00 ; Subtract with carry (long,X) $000BFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	trb $18.b		; 14 18 ; Test and reset bits $18.b [Reads: Accumulator] [Flags: Z]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	clc		; 18 ; Clear carry flag [Flags: C]
	mvn $64,$18		; 54 18 64 ; Move block negative $64,$18 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc $0032FF.l,X		; FF FF 32 00 ; Subtract with carry (long,X) $0032FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sbc ($0B.b)		; F2 0B ; Subtract with carry (indirect) ($0B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($0F.b)		; F2 0F ; Subtract with carry (indirect) ($0F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $0042FF.l,X		; FF FF 42 00 ; Subtract with carry (long,X) $0042FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx $07.b,Y		; B6 07 ; Load X register $07.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	sbc ($07.b)		; F2 07 ; Subtract with carry (indirect) ($07.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $0083FF.l,X		; FF FF 83 00 ; Subtract with carry (long,X) $0083FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	trb $19.b		; 14 19 ; Test and reset bits $19.b [Reads: Accumulator] [Flags: Z]
	asl $2819.w,X		; 1E 19 28 ; Arithmetic shift left $2819.w,X [Reads: X Index] [Flags: NCZ]
	ora $FFFF.w,Y		; 19 FF FF ; OR accumulator with memory $FFFF.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $CA.b		; 00 CA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $F2.b,S		; 03 F2 ; OR accumulator with stack relative $F2.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $FF.b,S		; 03 FF ; OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $D800C0.l,X		; FF C0 00 D8 ; Subtract with carry (long,X) $D800C0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $E4.b		; 06 E4 ; Arithmetic shift left $E4.b [Reads: Direct Page] [Flags: NCZ]
	asl $24.b		; 06 24 ; Arithmetic shift left $24.b [Reads: Direct Page] [Flags: NCZ]
	ora $1518.w		; 0D 18 15 ; Logical OR $1518.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $10, $1A		; 10 1A ; Branch if plus to $10, $1A [Flow: branch]
	sbc $00D0FF.l,X		; FF FF D0 00 ; Subtract with carry (long,X) $00D0FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $240A.w,X		; 1E 0A 24 ; Arithmetic shift left $240A.w,X [Reads: X Index] [Flags: NCZ]
	ora $1012.w		; 0D 12 10 ; Logical OR $1012.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $0055FF.l,X		; FF FF 55 00 ; Subtract with carry (long,X) $0055FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $50, $18		; 50 18 ; Branch if overflow clear to $50, $18 [Flow: branch]
	sbc $0041FF.l,X		; FF FF 41 00 ; Subtract with carry (long,X) $0041FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $7005.w,X		; 3E 05 70 ; Rotate left $7005.w,X [Reads: X Index] [Flags: NCZ]
	asl $1590.w		; 0E 90 15 ; Arithmetic shift left $1590.w [Flags: NCZ]
	sbc $0049FF.l,X		; FF FF 49 00 ; Subtract with carry (long,X) $0049FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp $0FCE05.l		; 5C 05 CE 0F ; Jump long to $0FCE05.l [Flow: jump]
	inc $700F.w		; EE 0F 70 ; Increment $700F.w [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc $0087FF.l,X		; FF FF 87 00 ; Subtract with carry (long,X) $0087FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $50, $18		; 50 18 ; Branch if overflow clear to $50, $18 [Flow: branch]
	jmp ($5018.w)		; 6C 18 50 ; Jump indirect to ($5018.w) [Flow: jump]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	jmp ($FF1B.w)		; 6C 1B FF ; Jump indirect to ($FF1B.w) [Flow: jump]
	sbc $3200C7.l,X		; FF C7 00 32 ; Subtract with carry (long,X) $3200C7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora #$4A.b		; 09 4A ; Logical OR #$4A.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$B2.b		; 09 B2 ; Logical OR #$B2.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0DCA.w		; 0D CA 0D ; Logical OR $0DCA.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $0096FF.l,X		; FF FF 96 00 ; Subtract with carry (long,X) $0096FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr $0C04.w		; 20 04 0C ; Jump to subroutine at $0C04.w [Writes: Stack Pointer] [Flow: call]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	and ($0B.b)		; 32 0B ; AND accumulator with memory (indirect) ($0B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $FF12.w		; 20 12 FF ; Jump to subroutine at $FF12.w [Writes: Stack Pointer] [Flow: call]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $0C00C1.l,X		; FF C1 00 0C ; Subtract with carry (long,X) $0C00C1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	trb $30.b		; 14 30 ; Test and reset bits $30.b [Reads: Accumulator] [Flags: Z]
	trb $0C.b		; 14 0C ; Test and reset bits $0C.b [Reads: Accumulator] [Flags: Z]
	trb $1C30.w		; 1C 30 1C ; Test and reset bits $1C30.w [Reads: Accumulator] [Flags: Z]
	sbc $0097FF.l,X		; FF FF 97 00 ; Subtract with carry (long,X) $0097FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $300C.w		; 0C 0C 30 ; Test and set bits $300C.w [Reads: Accumulator] [Flags: Z]
	tsb $140C.w		; 0C 0C 14 ; Test and set bits $140C.w [Reads: Accumulator] [Flags: Z]
	.db $30, $14		; 30 14 ; Branch if minus to $30, $14 [Flow: branch]
	sbc $009CFF.l,X		; FF FF 9C 00 ; Subtract with carry (long,X) $009CFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $50, $05		; 50 05 ; Branch if overflow clear to $50, $05 [Flow: branch]
	sbc $009DFF.l,X		; FF FF 9D 00 ; Subtract with carry (long,X) $009DFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $6815.w		; 0C 15 68 ; Test and set bits $6815.w [Reads: Accumulator] [Flags: Z]
	asl $FF.b,X		; 16 FF ; Arithmetic shift left $FF.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc $4C003D.l,X		; FF 3D 00 4C ; Subtract with carry (long,X) $4C003D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $70.b,X		; 15 70 ; OR accumulator with memory $70.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $50.b,X		; 15 50 ; OR accumulator with memory $50.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	trb $1C6C.w		; 1C 6C 1C ; Test and reset bits $1C6C.w [Reads: Accumulator] [Flags: Z]
	sbc $0101FF.l,X		; FF FF 01 01 ; Subtract with carry (long,X) $0101FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($32.b,X)		; 01 32 ; Logical OR ($32.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: NCZ]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	sbc $00FF00.l,X		; FF 00 FF 00 ; Subtract with carry (long,X) $00FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $32.b		; 00 32 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $82, $F7, $8C		; 82 F7 8C ; Branch always long to $82, $F7, $8C [Flow: branch]
	sbc [$9A.b],Y		; F7 9A ; Subtract with carry (long indexed) [$9A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$FD.b],Y		; F7 FD ; Subtract with carry (long indexed) [$FD.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	lda $F7.b		; A5 F7 ; Load $F7.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $F7		; B0 F7 ; Branch if carry set to $B0, $F7 [Flow: branch]
	.db $B0, $F7		; B0 F7 ; Branch if carry set to $B0, $F7 [Flow: branch]
	lda [$F7.b],Y		; B7 F7 ; Load accumulator (long indexed) [$F7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
.ACCU 16
.INDEX 16
	rep #$F7		; C2 F7
	cmp #$D5F7.w		; C9 F7 D5 ; Compare #$D5F7.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	sbc [$E0.b],Y		; F7 E0 ; Subtract with carry (long indexed) [$E0.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$EB.b],Y		; F7 EB ; Subtract with carry (long indexed) [$EB.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$F8.b],Y		; F7 F8 ; Subtract with carry (long indexed) [$F8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$FF.b],Y		; F7 FF ; Subtract with carry (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$0A.b],Y		; F7 0A ; Subtract with carry (long indexed) [$0A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora ($F8.b),Y		; 11 F8 ; OR accumulator with memory ($F8.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $23F8.w		; 1C F8 23 ; Test and reset bits $23F8.w [Reads: Accumulator] [Flags: Z]
	sed		; F8 ; Set decimal flag [Flags: D]
	and ($F8.b),Y		; 31 F8 ; AND accumulator with memory ($F8.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sed		; F8 ; Set decimal flag [Flags: D]
	eor $F8.b,S		; 43 F8 ; Exclusive OR accumulator with stack relative $F8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lsr $93F8.w		; 4E F8 93 ; Logical shift right $93F8.w [Flags: NCZ]
	sbc $61F85A.l,X		; FF 5A F8 61 ; Subtract with carry (long,X) $61F85A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	adc $78F8.w		; 6D F8 78 ; Add $78F8.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sta $F8.b,S		; 83 F8 ; Store accumulator (stack relative) $F8.b,S [Reads: Stack Pointer, Accumulator]
	stx $99F8.w		; 8E F8 99 ; Store X register to $99F8.w [Reads: X Index]
	sed		; F8 ; Set decimal flag [Flags: D]
	ldy $F8.b		; A4 F8 ; Load $F8.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	and $F8.b,S		; 23 F8 ; AND accumulator with stack relative $F8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda ($F8.b)		; B2 F8 ; Load accumulator (indirect) ($F8.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $B9F8.w,Y		; B9 F8 B9 ; Load $B9F8.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	dec $F8.b		; C6 F8 ; Decrement $F8.b [Reads: Direct Page] [Flags: NZ]
	cmp ($F8.b)		; D2 F8 ; Compare accumulator (indirect) ($F8.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp $E4F8.w,X		; DD F8 E4 ; Compare accumulator $E4F8.w,X [Reads: X Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sta ($FF.b,S),Y		; 93 FF ; Store accumulator (stack relative indirect indexed) ($FF.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	inc $F8.b,X		; F6 F8 ; Increment memory $F8.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	inc $F8.b,X		; F6 F8 ; Increment memory $F8.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	sbc $04F8.w,X		; FD F8 04 ; Subtract with carry $04F8.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F90F.w,Y		; F9 0F F9 ; Subtract with carry $F90F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	sbc $F926.w,Y		; F9 26 F9 ; Subtract with carry $F926.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and $38F9.w		; 2D F9 38 ; Logical AND $38F9.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $F93F.w,Y		; F9 3F F9 ; Subtract with carry $F93F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $F946.w,Y		; F9 46 F9 ; Subtract with carry $F946.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($F9.b),Y		; 51 F9 ; Exclusive OR accumulator with memory ($F9.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	sbc $F966.w,Y		; F9 66 F9 ; Subtract with carry $F966.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($F9.b),Y		; 71 F9 ; Add with carry ($F9.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sbc $F983.w,Y		; F9 83 F9 ; Subtract with carry $F983.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	stx $9AF9.w		; 8E F9 9A ; Store X register to $9AF9.w [Reads: X Index]
	sbc $F9A6.w,Y		; F9 A6 F9 ; Subtract with carry $F9A6.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lda ($F9.b),Y		; B1 F9 ; Load accumulator ($F9.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda $C4F9.w,X		; BD F9 C4 ; Load $C4F9.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $F9CB.w,Y		; F9 CB F9 ; Subtract with carry $F9CB.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $F9.b,X		; D6 F9 ; Decrement memory $F9.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	cmp $DDF9.w,X		; DD F9 DD ; Compare accumulator $DDF9.w,X [Reads: X Index] [Flags: NCZ]
	sbc $F9DD.w,Y		; F9 DD F9 ; Subtract with carry $F9DD.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx $F9.b		; E4 F9 ; Compare $F9.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $F0, $F9		; F0 F9 ; Branch if equal to $F0, $F9 [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	sbc $FA05.w,Y		; F9 05 FA ; Subtract with carry $FA05.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $FA		; 10 FA ; Branch if plus to $10, $FA [Flow: branch]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	and $FA.b		; 25 FA ; Logical AND $FA.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($FA.b,S),Y		; 33 FA ; AND accumulator (stack relative indirect indexed) ($FA.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $4CFA.w,X		; 3E FA 4C ; Rotate left $4CFA.w,X [Reads: X Index] [Flags: NCZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	eor [$FA.b],Y		; 57 FA ; Exclusive OR accumulator with memory (long indexed) [$FA.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $FA, $69		; 62 FA 69 ; Push effective relative address $62, $FA, $69 [Writes: Stack Pointer]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	.db $70, $FA		; 70 FA ; Branch if overflow set to $70, $FA [Flow: branch]
	adc [$FA.b],Y		; 77 FA ; Add with carry (long indexed) [$FA.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $85FA.w,X		; 7E FA 85 ; Rotate right $85FA.w,X [Reads: X Index] [Flags: NCZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	sty $93FA.w		; 8C FA 93 ; Store Y register to $93FA.w [Reads: Y Index]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	stz $A9FA.w,X		; 9E FA A9 ; Store zero to $A9FA.w,X [Reads: X Index]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	ldy $FA.b,X		; B4 FA ; Load Y register $FA.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	cpy #$C7FA.w		; C0 FA C7 ; Compare #$C7FA.w with Y register [Reads: Y Index] [Flags: NCZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	cpy #$D2FA.w		; C0 FA D2 ; Compare #$D2FA.w with Y register [Reads: Y Index] [Flags: NCZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	cmp $E8FA.w,X		; DD FA E8 ; Compare accumulator $E8FA.w,X [Reads: X Index] [Flags: NCZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	sbc ($FA.b)		; F2 FA ; Subtract with carry (indirect) ($FA.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $04FA.w,X		; FD FA 04 ; Subtract with carry $04FA.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ora [$FB.b],Y		; 17 FB ; OR accumulator with memory (long indexed) [$FB.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $FB2DFB.l		; 22 FB 2D FB ; Jump to subroutine long $FB2DFB.l [Writes: Stack Pointer] [Flow: call]
	bit $FB.b,X		; 34 FB ; Test bits $FB.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and $FB3FFB.l,X		; 3F FB 3F FB ; AND accumulator with memory (long,X) $FB3FFB.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	lsr $FB.b,X		; 56 FB ; Logical shift right $FB.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	adc ($FB.b,X)		; 61 FB ; Add with carry ($FB.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	adc $FB76FB.l		; 6F FB 76 FB ; Add with carry (long) $FB76FB.l [Writes: Accumulator] [Flags: NCVZ]
	sta $FB.b,S		; 83 FB ; Store accumulator (stack relative) $FB.b,S [Reads: Stack Pointer, Accumulator]
	.db $90, $FB		; 90 FB ; Branch if carry clear to $90, $FB [Flow: branch]
	.db $90, $FB		; 90 FB ; Branch if carry clear to $90, $FB [Flow: branch]
	.db $90, $FB		; 90 FB ; Branch if carry clear to $90, $FB [Flow: branch]
	.db $90, $FB		; 90 FB ; Branch if carry clear to $90, $FB [Flow: branch]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	lda ($FB.b,X)		; A1 FB ; Load accumulator ($FB.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ldx $FB.b,Y		; B6 FB ; Load X register $FB.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	cmp ($FB.b,X)		; C1 FB ; Compare accumulator ($FB.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	cpy $CCFB.w		; CC FB CC ; Compare $CCFB.w with Y register [Reads: Y Index] [Flags: NCZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	cmp ($FB.b,S),Y		; D3 FB ; Compare accumulator (stack relative indirect indexed) ($FB.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc ($FB.b,X)		; E1 FB ; Subtract with carry ($FB.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	pea $F4FB.w		; F4 FB F4 ; Push absolute address $F4FB.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	inc $FEFB.w,X		; FE FB FE ; Increment memory $FEFB.w,X [Reads: X Index] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ora $FC.b		; 05 FC ; Logical OR $FC.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($FC.b)		; 12 FC ; OR accumulator with memory (indirect) ($FC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $24FC.w,Y		; 19 FC 24 ; OR accumulator with memory $24FC.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	jsr ($FC24.w,X)		; FC 24 FC ; Jump to subroutine indirect indexed ($FC24.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	jsr ($FC36.w,X)		; FC 36 FC ; Jump to subroutine indirect indexed ($FC36.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	and $48FC.w,X		; 3D FC 48 ; AND accumulator with memory $48FC.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsr ($FC48.w,X)		; FC 48 FC ; Jump to subroutine indirect indexed ($FC48.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	eor $FC5AFC.l		; 4F FC 5A FC ; Exclusive OR accumulator with memory (long) $FC5AFC.l [Writes: Accumulator] [Flags: NZ]
	adc $FC.b		; 65 FC ; Add $FC.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $FC		; 70 FC ; Branch if overflow set to $70, $FC [Flow: branch]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr ($FC7B.w,X)		; FC 7B FC ; Jump to subroutine indirect indexed ($FC7B.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sta $FC.b		; 85 FC ; Store accumulator to $FC.b [Reads: Accumulator]
	sty $96FC.w		; 8C FC 96 ; Store Y register to $96FC.w [Reads: Y Index]
	jsr ($FCA1.w,X)		; FC A1 FC ; Jump to subroutine indirect indexed ($FCA1.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	jsr ($FCB3.w,X)		; FC B3 FC ; Jump to subroutine indirect indexed ($FCB3.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	jsr ($FCB3.w,X)		; FC B3 FC ; Jump to subroutine indirect indexed ($FCB3.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cmp $FC.b		; C5 FC ; Compare $FC.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cpy $D7FC.w		; CC FC D7 ; Compare $D7FC.w with Y register [Reads: Y Index] [Flags: NCZ]
	jsr ($FCE2.w,X)		; FC E2 FC ; Jump to subroutine indirect indexed ($FCE2.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpx $F3FC.w		; EC FC F3 ; Compare $F3FC.w with X register [Reads: X Index] [Flags: NCZ]
	jsr ($FCFD.w,X)		; FC FD FC ; Jump to subroutine indirect indexed ($FCFD.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	tsb $FD.b		; 04 FD ; Test and set bits $FD.b [Reads: Accumulator] [Flags: Z]
	ora $FD16FD.l		; 0F FD 16 FD ; OR accumulator with memory (long) $FD16FD.l [Writes: Accumulator] [Flags: NZ]
	asl $FD.b,X		; 16 FD ; Arithmetic shift left $FD.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	and ($FD.b,X)		; 21 FD ; Logical AND ($FD.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	sbc $FD34.w,X		; FD 34 FD ; Subtract with carry $FD34.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $45FD.w,X		; 3E FD 45 ; Rotate left $45FD.w,X [Reads: X Index] [Flags: NCZ]
	sbc $FD4C.w,X		; FD 4C FD ; Subtract with carry $FD4C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor [$FD.b],Y		; 57 FD ; Exclusive OR accumulator with memory (long indexed) [$FD.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $FD, $2A		; 62 FD 2A ; Push effective relative address $62, $FD, $2A [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	adc $74FD.w		; 6D FD 74 ; Add $74FD.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sbc $FD7B.w,X		; FD 7B FD ; Subtract with carry $FD7B.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $82, $FD, $89		; 82 FD 89 ; Branch always long to $82, $FD, $89 [Flow: branch]
	sbc $FD94.w,X		; FD 94 FD ; Subtract with carry $FD94.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sty $FD.b,X		; 94 FD ; Store Y register $FD.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	sta $FDA6FD.l,X		; 9F FD A6 FD ; Store accumulator (long,X) $FDA6FD.l,X [Reads: Accumulator, X Index]
	lda ($FD.b)		; B2 FD ; Load accumulator (indirect) ($FD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $C0FD.w,Y		; B9 FD C0 ; Load $C0FD.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $FDC7.w,X		; FD C7 FD ; Subtract with carry $FDC7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp ($FD.b)		; D2 FD ; Compare accumulator (indirect) ($FD.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	cmp $E0FD.w,Y		; D9 FD E0 ; Compare accumulator $E0FD.w,Y [Reads: Y Index] [Flags: NCZ]
	sbc $FDE7.w,X		; FD E7 FD ; Subtract with carry $FDE7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $EEFD.w		; EE FD EE ; Increment $EEFD.w [Flags: NZ]
	sbc $FDEE.w,X		; FD EE FD ; Subtract with carry $FDEE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FD.b,X		; F5 FD ; Subtract $FD.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FD.b,X		; F5 FD ; Subtract $FD.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FDFFFD.l,X		; FF FD FF FD ; Subtract with carry (long,X) $FDFFFD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	inc $FE16.w,X		; FE 16 FE ; Increment memory $FE16.w,X [Reads: X Index] [Flags: NZ]
	and ($FE.b,X)		; 21 FE ; Logical AND ($FE.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and ($FE.b,X)		; 21 FE ; Logical AND ($FE.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp ($FD.b)		; D2 FD ; Compare accumulator (indirect) ($FD.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	and ($FE.b,X)		; 21 FE ; Logical AND ($FE.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and ($FE.b,X)		; 21 FE ; Logical AND ($FE.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	inc $FE2F.w,X		; FE 2F FE ; Increment memory $FE2F.w,X [Reads: X Index] [Flags: NZ]
	inc $EEFD.w		; EE FD EE ; Increment $EEFD.w [Flags: NZ]
	sbc $FE3A.w,X		; FD 3A FE ; Subtract with carry $FE3A.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	inc $FE41.w,X		; FE 41 FE ; Increment memory $FE41.w,X [Reads: X Index] [Flags: NZ]
	jmp $57FE.w		; 4C FE 57 ; Jump to $57FE.w [Flow: jump]
	inc $FE5E.w,X		; FE 5E FE ; Increment memory $FE5E.w,X [Reads: X Index] [Flags: NZ]
	adc $FE.b		; 65 FE ; Add $FE.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jmp ($6CFE.w)		; 6C FE 6C ; Jump indirect to ($6CFE.w) [Flow: jump]
	inc $FE73.w,X		; FE 73 FE ; Increment memory $FE73.w,X [Reads: X Index] [Flags: NZ]
	adc ($FE.b,S),Y		; 73 FE ; Add with carry (stack relative indirect indexed) ($FE.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	inc $FE88.w,X		; FE 88 FE ; Increment memory $FE88.w,X [Reads: X Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	inc $FE93.w,X		; FE 93 FE ; Increment memory $FE93.w,X [Reads: X Index] [Flags: NZ]
	stz $9EFE.w,X		; 9E FE 9E ; Store zero to $9EFE.w,X [Reads: X Index]
	inc $FEAA.w,X		; FE AA FE ; Increment memory $FEAA.w,X [Reads: X Index] [Flags: NZ]
	ldy $FE.b,X		; B4 FE ; Load Y register $FE.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	adc ($FE.b,S),Y		; 73 FE ; Add with carry (stack relative indirect indexed) ($FE.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	adc ($FE.b,S),Y		; 73 FE ; Add with carry (stack relative indirect indexed) ($FE.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$C0FE.w		; C0 FE C0 ; Compare #$C0FE.w with Y register [Reads: Y Index] [Flags: NCZ]
	inc $FEC5.w,X		; FE C5 FE ; Increment memory $FEC5.w,X [Reads: X Index] [Flags: NZ]
	cmp $FE.b		; C5 FE ; Compare $FE.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cpy $CCFE.w		; CC FE CC ; Compare $CCFE.w with Y register [Reads: Y Index] [Flags: NCZ]
	inc $FECC.w,X		; FE CC FE ; Increment memory $FECC.w,X [Reads: X Index] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	inc $FEE1.w,X		; FE E1 FE ; Increment memory $FEE1.w,X [Reads: X Index] [Flags: NZ]
	cpx $F7FE.w		; EC FE F7 ; Compare $F7FE.w with X register [Reads: X Index] [Flags: NCZ]
	inc $FEF7.w,X		; FE F7 FE ; Increment memory $FEF7.w,X [Reads: X Index] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	inc $FF03.w,X		; FE 03 FF ; Increment memory $FF03.w,X [Reads: X Index] [Flags: NZ]
	asl $1CFF.w		; 0E FF 1C ; Arithmetic shift left $1CFF.w [Flags: NCZ]
	sbc $2AFF23.l,X		; FF 23 FF 2A ; Subtract with carry (long,X) $2AFF23.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $38FF31.l,X		; FF 31 FF 38 ; Subtract with carry (long,X) $38FF31.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $46FF3F.l,X		; FF 3F FF 46 ; Subtract with carry (long,X) $46FF3F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $54FF4D.l,X		; FF 4D FF 54 ; Subtract with carry (long,X) $54FF4D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $62FF5B.l,X		; FF 5B FF 62 ; Subtract with carry (long,X) $62FF5B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $70FF69.l,X		; FF 69 FF 70 ; Subtract with carry (long,X) $70FF69.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $15FF77.l,X		; FF 77 FF 15 ; Subtract with carry (long,X) $15FF77.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $7EFF15.l,X		; FF 15 FF 7E ; Subtract with carry (long,X) $7EFF15.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $8CFF85.l,X		; FF 85 FF 8C ; Subtract with carry (long,X) $8CFF85.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $93FF93.l,X		; FF 93 FF 93 ; Subtract with carry (long,X) $93FF93.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $A1FF9A.l,X		; FF 9A FF A1 ; Subtract with carry (long,X) $A1FF9A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $A8FF2A.l,X		; FF 2A FF A8 ; Subtract with carry (long,X) $A8FF2A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $BAFFB3.l,X		; FF B3 FF BA ; Subtract with carry (long,X) $BAFFB3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $C1FF15.l,X		; FF 15 FF C1 ; Subtract with carry (long,X) $C1FF15.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $D3FFCC.l,X		; FF CC FF D3 ; Subtract with carry (long,X) $D3FFCC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $7EFFDA.l,X		; FF DA FF 7E ; Subtract with carry (long,X) $7EFFDA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $E1FF7E.l,X		; FF 7E FF E1 ; Subtract with carry (long,X) $E1FF7E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $E8FFE8.l,X		; FF E8 FF E8 ; Subtract with carry (long,X) $E8FFE8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $CCFFE8.l,X		; FF E8 FF CC ; Subtract with carry (long,X) $CCFFE8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $EFFFEF.l,X		; FF EF FF EF ; Subtract with carry (long,X) $EFFFEF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $EFFFEF.l,X		; FF EF FF EF ; Subtract with carry (long,X) $EFFFEF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $EFFFEF.l,X		; FF EF FF EF ; Subtract with carry (long,X) $EFFFEF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $EFFFEF.l,X		; FF EF FF EF ; Subtract with carry (long,X) $EFFFEF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $EFFFEF.l,X		; FF EF FF EF ; Subtract with carry (long,X) $EFFFEF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $EFFFEF.l,X		; FF EF FF EF ; Subtract with carry (long,X) $EFFFEF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $EFFFEF.l,X		; FF EF FF EF ; Subtract with carry (long,X) $EFFFEF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $EFFFEF.l,X		; FF EF FF EF ; Subtract with carry (long,X) $EFFFEF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $EFFFEF.l,X		; FF EF FF EF ; Subtract with carry (long,X) $EFFFEF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $EFFFEF.l,X		; FF EF FF EF ; Subtract with carry (long,X) $EFFFEF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $EFFFEF.l,X		; FF EF FF EF ; Subtract with carry (long,X) $EFFFEF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $EFFFEF.l,X		; FF EF FF EF ; Subtract with carry (long,X) $EFFFEF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $132141.l,X		; FF 41 21 13 ; Subtract with carry (long,X) $132141.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $003D07.l		; 22 07 3D 00 ; Jump to subroutine long $003D07.l [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $C0		; 10 C0 ; Branch if plus to $10, $C0 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $72.b		; 00 72 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $50.b		; 00 50 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($C0.b)		; 52 C0 ; Exclusive OR accumulator with memory (indirect) ($C0.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0604.w,X		; 1D 04 06 ; OR accumulator with memory $0604.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $0026.w		; 0D 26 00 ; Logical OR $0026.w with accumulator [Writes: Accumulator] [Flags: NZ]
	rol $14.b		; 26 14 ; Rotate left $14.b [Reads: Direct Page] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B5.b		; 00 B5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	trb $00.b		; 14 00 ; Test and reset bits $00.b [Reads: Accumulator] [Flags: Z]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $0506.w		; 20 06 05 ; Jump to subroutine at $0506.w [Writes: Stack Pointer] [Flow: call]
	tsb $2500.w		; 0C 00 25 ; Test and set bits $2500.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$C0.b],Y		; 17 C0 ; OR accumulator with memory (long indexed) [$C0.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$19.b]		; 07 19 ; OR accumulator with memory (long) [$19.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $27.b		; 00 27 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $4B.b		; 00 4B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$19.b]		; 07 19 ; OR accumulator with memory (long) [$19.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $27.b		; 00 27 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$19.b]		; 07 19 ; OR accumulator with memory (long) [$19.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $6A.b		; 00 6A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	cpy #$0E28.w		; C0 28 0E ; Compare #$0E28.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora ($00.b,S),Y		; 13 00 ; OR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $6B.b		; 00 6B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $408C.w		; 8C 8C 40 ; Store Y register to $408C.w [Reads: Y Index]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	asl $0518.w		; 0E 18 05 ; Arithmetic shift left $0518.w [Flags: NCZ]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($0B.b,S),Y		; 13 0B ; OR accumulator (stack relative indirect indexed) ($0B.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	trb $0800.w		; 1C 00 08 ; Test and reset bits $0800.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $2100.w,X		; 1E 00 21 ; Arithmetic shift left $2100.w,X [Reads: X Index] [Flags: NCZ]
	ora ($22.b,S),Y		; 13 22 ; OR accumulator (stack relative indirect indexed) ($22.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $C0.b		; 02 C0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0604.w,X		; 1D 04 06 ; OR accumulator with memory $0604.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $0026.w		; 0D 26 00 ; Logical OR $0026.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $001E.w		; 0D 1E 00 ; Logical OR $001E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $0D18.w		; 20 18 0D ; Jump to subroutine at $0D18.w [Writes: Stack Pointer] [Flow: call]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$0D18.w		; C0 18 0D ; Compare #$0D18.w with Y register [Reads: Y Index] [Flags: NCZ]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B6.b		; 00 B6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $08		; 90 08 ; Branch if carry clear to $90, $08 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($03.b),Y		; 11 03 ; OR accumulator with memory ($03.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $66.b		; 00 66 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $0506.w		; 20 06 05 ; Jump to subroutine at $0506.w [Writes: Stack Pointer] [Flow: call]
	ora $3500.w,Y		; 19 00 35 ; OR accumulator with memory $3500.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $27.b		; 00 27 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$27.b]		; 07 27 ; OR accumulator with memory (long) [$27.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$19.b]		; 07 19 ; OR accumulator with memory (long) [$19.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $001907.l		; 0F 07 19 00 ; OR accumulator with memory (long) $001907.l [Writes: Accumulator] [Flags: NZ]
	asl $00.b,X		; 16 00 ; Arithmetic shift left $00.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $6A.b		; 00 6A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	ora $000807.l		; 0F 07 08 00 ; OR accumulator with memory (long) $000807.l [Writes: Accumulator] [Flags: NZ]
	ora $1C.b,S		; 03 1C ; OR accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1A.b		; 00 1A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0009.w		; 0E 09 00 ; Arithmetic shift left $0009.w [Flags: NCZ]
	tsb $3F.b		; 04 3F ; Test and set bits $3F.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8C.b		; 00 8C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1B.b		; 00 1B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0018.w		; 0E 18 00 ; Arithmetic shift left $0018.w [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $4C.b		; 00 4C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $0B13.w		; 20 13 0B ; Jump to subroutine at $0B13.w [Writes: Stack Pointer] [Flow: call]
	trb $1700.w		; 1C 00 17 ; Test and reset bits $1700.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $1300.w		; 0E 00 13 ; Arithmetic shift left $1300.w [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	and #$1700.w		; 29 00 17 ; Logical AND #$1700.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $020C20.l,X		; 3F 20 0C 02 ; AND accumulator with memory (long,X) $020C20.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b)		; 12 00 ; OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $25.b,X		; 15 25 ; OR accumulator with memory $25.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $0026.w		; 0D 26 00 ; Logical OR $0026.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $00.b,X		; 16 00 ; Arithmetic shift left $00.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $76.b		; 00 76 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $76.b,X		; 76 76 ; Rotate right $76.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	jsr $0506.w		; 20 06 05 ; Jump to subroutine at $0506.w [Writes: Stack Pointer] [Flow: call]
	ora $3600.w,Y		; 19 00 36 ; OR accumulator with memory $3600.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $31.b		; 00 31 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$31.b],Y		; 17 31 ; OR accumulator with memory (long indexed) [$31.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $80, $0A		; 80 0A ; Branch always to $80, $0A [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($1B.b)		; 32 1B ; AND accumulator with memory (indirect) ($1B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy $090E.w		; CC 0E 09 ; Compare $090E.w with Y register [Reads: Y Index] [Flags: NCZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cop $25.b		; 02 25 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $001907.l		; 0F 07 19 00 ; OR accumulator with memory (long) $001907.l [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$070F.w		; C0 0F 07 ; Compare #$070F.w with Y register [Reads: Y Index] [Flags: NCZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	brk $16.b		; 00 16 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	trb $2A00.w		; 1C 00 2A ; Test and reset bits $2A00.w [Reads: Accumulator] [Flags: Z]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0000.w,Y		; 19 00 00 ; OR accumulator with memory $0000.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1202.w		; 0C 02 12 ; Test and set bits $1202.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	jsr $0506.w		; 20 06 05 ; Jump to subroutine at $0506.w [Writes: Stack Pointer] [Flow: call]
	ora $3700.w,Y		; 19 00 37 ; OR accumulator with memory $3700.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	brk $77.b		; 00 77 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$77.b]		; 27 77 ; AND accumulator with memory (long) [$77.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $42, $00		; 42 00 ; Reserved instruction
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $15.b		; 00 15 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $80.b		; 25 80 ; Logical AND $80.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $54.b		; 00 54 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $0A		; 80 0A ; Branch always to $80, $0A [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $19.b		; 00 19 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $0A		; 80 0A ; Branch always to $80, $0A [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $0A		; 80 0A ; Branch always to $80, $0A [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $090D.w		; 20 0D 09 ; Jump to subroutine at $090D.w [Writes: Stack Pointer] [Flow: call]
	ora ($00.b,S),Y		; 13 00 ; OR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and #$0F20.w		; 29 20 0F ; Logical AND #$0F20.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$19.b]		; 07 19 ; OR accumulator with memory (long) [$19.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $13.b		; 06 13 ; Arithmetic shift left $13.b [Reads: Direct Page] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	asl $000C.w		; 0E 0C 00 ; Arithmetic shift left $000C.w [Flags: NCZ]
	and ($00.b,S),Y		; 33 00 ; AND accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stx $96.b,Y		; 96 96 ; Store X register $96.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	cpy $0B13.w		; CC 13 0B ; Compare $0B13.w with Y register [Reads: Y Index] [Flags: NCZ]
	and #$0202.w		; 29 02 02 ; Logical AND #$0202.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $1300.w,X		; 1E 00 13 ; Arithmetic shift left $1300.w,X [Reads: X Index] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	and #$2700.w		; 29 00 27 ; Logical AND #$2700.w with accumulator [Writes: Accumulator] [Flags: NZ]
	trb $00.b		; 14 00 ; Test and reset bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00C05F.l,X		; 1F 5F C0 00 ; Logical OR long $00C05F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cop $27.b		; 02 27 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $B0		; 30 B0 ; Branch if minus to $30, $B0 [Flow: branch]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $42, $01		; 42 01 ; Reserved instruction
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $41.b		; 00 41 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($68.b)		; 32 68 ; AND accumulator with memory (indirect) ($68.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1700.w,X		; 1D 00 17 ; OR accumulator with memory $1700.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0A.b],Y		; 17 0A ; OR accumulator with memory (long indexed) [$0A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $0A00.w,X		; BC 00 0A ; Load Y register $0A00.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $0000.w,X		; 3C 00 00 ; Test bits $0000.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	ora $1309.w		; 0D 09 13 ; Logical OR $1309.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $33.b		; 00 33 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora $001907.l		; 0F 07 19 00 ; OR accumulator with memory (long) $001907.l [Writes: Accumulator] [Flags: NZ]
	ora [$00.b],Y		; 17 00 ; OR accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$0F00.w		; 09 00 0F ; Logical OR #$0F00.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1A.b		; 00 1A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $000C.w		; 0E 0C 00 ; Arithmetic shift left $000C.w [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1D.b		; 00 1D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $0E1A.w		; 20 1A 0E ; Jump to subroutine at $0E1A.w [Writes: Stack Pointer] [Flow: call]
	tsb $3200.w		; 0C 00 32 ; Test and set bits $3200.w [Reads: Accumulator] [Flags: Z]
	and $A60000.l,X		; 3F 00 00 A6 ; AND accumulator with memory (long,X) $A60000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldx $00.b		; A6 00 ; Load $00.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	ora ($0B.b,S),Y		; 13 0B ; OR accumulator (stack relative indirect indexed) ($0B.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and #$1700.w		; 29 00 17 ; Logical AND #$1700.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $1300.w		; 6E 00 13 ; Rotate right $1300.w [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	trb $0000.w		; 1C 00 00 ; Test and reset bits $0000.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BE.b		; 00 BE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$0000.w		; C0 00 00 ; Compare #$0000.w with Y register [Reads: Y Index] [Flags: NCZ]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($C0.b,X)		; 01 C0 ; Logical OR ($C0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $61.b		; 00 61 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$0000.w		; C0 00 00 ; Compare #$0000.w with Y register [Reads: Y Index] [Flags: NCZ]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($C0.b,X)		; 01 C0 ; Logical OR ($C0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $20.b,S		; 63 20 ; Add with carry (stack relative) $20.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $10, $0D		; 10 0D ; Branch if plus to $10, $0D [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1309.w		; 0D 09 13 ; Logical OR $1309.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1309.w		; 0D 09 13 ; Logical OR $1309.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $16.b		; 00 16 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1309.w		; 0D 09 13 ; Logical OR $1309.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $21.b		; 00 21 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	cpy #$090D.w		; C0 0D 09 ; Compare #$090D.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora ($00.b,S),Y		; 13 00 ; OR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$15.b]		; 07 15 ; OR accumulator with memory (long) [$15.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $25.b		; 00 25 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	asl $000A.w		; 0E 0A 00 ; Arithmetic shift left $000A.w [Flags: NCZ]
	ora [$00.b],Y		; 17 00 ; OR accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $1B.b		; 00 1B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $000A.w		; 0E 0A 00 ; Arithmetic shift left $000A.w [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $5D.b		; 00 5D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0023.w		; 0E 23 00 ; Arithmetic shift left $0023.w [Flags: NCZ]
	ora #$0000.w		; 09 00 00 ; Logical OR #$0000.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp $0B1320.l		; 5C 20 13 0B ; Jump long to $0B1320.l [Flow: jump]
	trb $0000.w		; 1C 00 00 ; Test and reset bits $0000.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $1300.w,X		; 7E 00 13 ; Rotate right $1300.w,X [Reads: X Index] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	trb $2700.w		; 1C 00 27 ; Test and reset bits $2700.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00C07F.l,X		; 3F 7F C0 00 ; AND accumulator with memory (long,X) $00C07F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($00.b),Y		; 51 00 ; Exclusive OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora #$0A05.w		; 09 05 0A ; Logical OR #$0A05.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($E0.b,S),Y		; 53 E0 ; XOR accumulator (stack relative indirect indexed) ($E0.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $0A.b,S		; 23 0A ; AND accumulator with stack relative $0A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($00.b,X)		; 21 00 ; Logical AND ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$00.b],Y		; 17 00 ; OR accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $AB.b		; 00 AB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$0A23.w		; E0 23 0A ; Compare #$0A23.w with X register [Reads: X Index] [Flags: NCZ]
	and ($00.b,X)		; 21 00 ; Logical AND ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $0AC0.w		; AC C0 0A ; Load $0AC0.w into Y register [Writes: Y Index] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $0000.w,X		; 3C 00 00 ; Test bits $0000.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b,X		; 16 00 ; Arithmetic shift left $00.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $1309.w		; 0D 09 13 ; Logical OR $1309.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1309.w		; 0D 09 13 ; Logical OR $1309.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $001907.l		; 0F 07 19 00 ; OR accumulator with memory (long) $001907.l [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1A.b		; 00 1A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	brk $1B.b		; 00 1B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $000A.w		; 0E 0A 00 ; Arithmetic shift left $000A.w [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0023.w		; 0E 23 00 ; Arithmetic shift left $0023.w [Flags: NCZ]
	ora $3F.b,S		; 03 3F ; OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A5.b		; 00 A5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0023.w		; 0E 23 00 ; Arithmetic shift left $0023.w [Flags: NCZ]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	trb $0200.w		; 1C 00 02 ; Test and reset bits $0200.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $0100.w		; 4E 00 01 ; Logical shift right $0100.w [Flags: NCZ]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($80.b),Y		; 71 80 ; Add with carry ($80.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$0101.w		; C0 01 01 ; Compare #$0101.w with Y register [Reads: Y Index] [Flags: NCZ]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $C0		; 70 C0 ; Branch if overflow set to $70, $C0 [Flow: branch]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora #$0A05.w		; 09 05 0A ; Logical OR #$0A05.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$0A05.w		; 09 05 0A ; Logical OR #$0A05.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $27.b		; 00 27 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$0A05.w		; 09 05 0A ; Logical OR #$0A05.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $26.b		; 00 26 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $26.b		; 26 26 ; Rotate left $26.b [Reads: Direct Page] [Flags: NCZ]
	cpy #$0506.w		; C0 06 05 ; Compare #$0506.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora $0000.w,Y		; 19 00 00 ; OR accumulator with memory $0000.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A7.b		; 00 A7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($87.b),Y		; 31 87 ; AND accumulator with memory ($87.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta [$00.b]		; 87 00 ; Store accumulator (long) [$00.b] [Reads: Direct Page, Accumulator]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	asl $0013.w		; 0E 13 00 ; Arithmetic shift left $0013.w [Flags: NCZ]
	ora $39.b,S		; 03 39 ; OR accumulator with stack relative $39.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $2800.w,X		; 9D 00 28 ; Store accumulator to $2800.w,X [Reads: Accumulator, X Index]
	asl $0013.w		; 0E 13 00 ; Arithmetic shift left $0013.w [Flags: NCZ]
	jsr $0000.w		; 20 00 00 ; Jump to subroutine at $0000.w [Writes: Stack Pointer] [Flow: call]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	asl $0013.w		; 0E 13 00 ; Arithmetic shift left $0013.w [Flags: NCZ]
	tsb $3C.b		; 04 3C ; Test and set bits $3C.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	jsr $0B13.w		; 20 13 0B ; Jump to subroutine at $0B13.w [Writes: Stack Pointer] [Flow: call]
	trb $2B00.w		; 1C 00 2B ; Test and reset bits $2B00.w [Reads: Accumulator] [Flags: Z]
	ora [$00.b],Y		; 17 00 ; OR accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $9E.b		; 00 9E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $1300.w,X		; 5E 00 13 ; Logical shift right $1300.w,X [Reads: X Index] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	trb $0000.w		; 1C 00 00 ; Test and reset bits $0000.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $010160.l,X		; 5F 60 01 01 ; Exclusive OR accumulator with memory (long,X) $010160.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$0101.w		; C0 01 01 ; Compare #$0101.w with Y register [Reads: Y Index] [Flags: NCZ]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0A.b		; 05 0A ; Logical OR $0A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$0A05.w		; 09 05 0A ; Logical OR #$0A05.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$0A05.w		; 09 05 0A ; Logical OR #$0A05.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $05.b		; 06 05 ; Arithmetic shift left $05.b [Reads: Direct Page] [Flags: NCZ]
	ora $3E00.w,Y		; 19 00 3E ; OR accumulator with memory $3E00.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($28.b,X)		; 01 28 ; Logical OR ($28.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $08.b		; 05 08 ; Logical OR $08.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A9.b		; 00 A9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0013.w		; 0E 13 00 ; Arithmetic shift left $0013.w [Flags: NCZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	tsb $2820.w		; 0C 20 28 ; Test and set bits $2820.w [Reads: Accumulator] [Flags: Z]
	asl $0013.w		; 0E 13 00 ; Arithmetic shift left $0013.w [Flags: NCZ]
	asl $00.b,X		; 16 00 ; Arithmetic shift left $00.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1C0C.w		; 0C 0C 1C ; Test and set bits $1C0C.w [Reads: Accumulator] [Flags: Z]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0013.w		; 0E 13 00 ; Arithmetic shift left $0013.w [Flags: NCZ]
	and ($29.b,S),Y		; 33 29 ; AND accumulator (stack relative indirect indexed) ($29.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	trb $0000.w		; 1C 00 00 ; Test and reset bits $0000.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx $1280.w		; AE 80 12 ; Load $1280.w into X register [Writes: X Index] [Flags: NZ]
	tsb $0016.w		; 0C 16 00 ; Test and set bits $0016.w [Reads: Accumulator] [Flags: Z]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $001C.w		; 0C 1C 00 ; Test and set bits $001C.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $001C.w		; 0C 1C 00 ; Test and set bits $001C.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $001C.w		; 0C 1C 00 ; Test and set bits $001C.w [Reads: Accumulator] [Flags: Z]
	asl $00.b,X		; 16 00 ; Arithmetic shift left $00.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx #$2500.w		; A2 00 25 ; Load #$2500.w into X register [Writes: X Index] [Flags: NZ]
	asl $0024.w		; 0E 24 00 ; Arithmetic shift left $0024.w [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $25.b		; 00 25 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0024.w		; 0E 24 00 ; Arithmetic shift left $0024.w [Flags: NCZ]
	and ($00.b,S),Y		; 33 00 ; AND accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3D.b		; 00 3D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	ora ($0C.b),Y		; 11 0C ; OR accumulator with memory ($0C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $1C00.w,X		; 1D 00 1C ; OR accumulator with memory $1C00.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D1.b		; 00 D1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($00.b),Y		; D1 00 ; Compare accumulator ($00.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	ora ($0C.b),Y		; 11 0C ; OR accumulator with memory ($0C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $0000.w		; 1C 00 00 ; Test and reset bits $0000.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($01.b)		; D2 01 ; Compare accumulator (indirect) ($01.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $08.b		; 05 08 ; Logical OR $08.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0013.w		; 0E 13 00 ; Arithmetic shift left $0013.w [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $2800.w,X		; 7D 00 28 ; Add $2800.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $0613.w		; 0E 13 06 ; Arithmetic shift left $0613.w [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0613.w		; 0E 13 06 ; Arithmetic shift left $0613.w [Flags: NCZ]
	brk $3B.b		; 00 3B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $0B13.w		; 20 13 0B ; Jump to subroutine at $0B13.w [Writes: Stack Pointer] [Flow: call]
	trb $0000.w		; 1C 00 00 ; Test and reset bits $0000.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BE.b		; 00 BE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx $1300.w,Y		; BE 00 13 ; Load X register $1300.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	trb $1700.w		; 1C 00 17 ; Test and reset bits $1700.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($0C.b)		; 12 0C ; OR accumulator with memory (indirect) ($0C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0000.w,X		; 1D 00 00 ; OR accumulator with memory $0000.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($00.b),Y		; 91 00 ; Store accumulator ($00.b),Y [Reads: Direct Page, Y Index, Accumulator]
	ora ($0C.b),Y		; 11 0C ; OR accumulator with memory ($0C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $0000.w,X		; 1D 00 00 ; OR accumulator with memory $0000.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($0C.b),Y		; 11 0C ; OR accumulator with memory ($0C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $0000.w,X		; 1D 00 00 ; OR accumulator with memory $0000.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($60.b,S),Y		; 93 60 ; Store accumulator (stack relative indirect indexed) ($60.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	ora $170D.w,Y		; 19 0D 17 ; OR accumulator with memory $170D.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tsb $25.b		; 04 25 ; Test and set bits $25.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $0E.b		; 25 0E ; Logical AND $0E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $6C.b		; 00 6C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $25.b		; 00 25 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0024.w		; 0E 24 00 ; Arithmetic shift left $0024.w [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $4D.b		; 00 4D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $19.b		; 05 19 ; Logical OR $19.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$050B.w		; C0 0B 05 ; Compare #$050B.w with Y register [Reads: Y Index] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $08.b		; 05 08 ; Logical OR $08.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $89.b		; 00 89 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$050B.w		; C0 0B 05 ; Compare #$050B.w with Y register [Reads: Y Index] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0A.b],Y		; 17 0A ; OR accumulator with memory (long indexed) [$0A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $E0.b		; 64 E0 ; Store zero to $E0.b
	ora [$0A.b],Y		; 17 0A ; OR accumulator with memory (long indexed) [$0A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsr $2500.w		; 20 00 25 ; Jump to subroutine at $2500.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($0B.b,S),Y		; 13 0B ; OR accumulator (stack relative indirect indexed) ($0B.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	trb $2700.w		; 1C 00 27 ; Test and reset bits $2700.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stx $1300.w		; 8E 00 13 ; Store X register to $1300.w [Reads: X Index]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	trb $0000.w		; 1C 00 00 ; Test and reset bits $0000.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $02.b		; 26 02 ; Rotate left $02.b [Reads: Direct Page] [Flags: NCZ]
	and ($00.b,X)		; 21 00 ; Logical AND ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $02.b		; 05 02 ; Logical OR $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cpy #$1100.w		; C0 00 11 ; Compare #$1100.w with Y register [Reads: Y Index] [Flags: NCZ]
	tsb $001D.w		; 0C 1D 00 ; Test and set bits $001D.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda ($C0.b)		; B2 C0 ; Load accumulator (indirect) ($C0.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($0C.b),Y		; 11 0C ; OR accumulator with memory ($0C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $0300.w,X		; 1D 00 03 ; OR accumulator with memory $0300.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $11C0.w		; 0E C0 11 ; Arithmetic shift left $11C0.w [Flags: NCZ]
	tsb $001D.w		; 0C 1D 00 ; Test and set bits $001D.w [Reads: Accumulator] [Flags: Z]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $19.b		; 00 19 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0017.w		; 0D 17 00 ; Logical OR $0017.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C4.b		; 00 C4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($18.b,X)		; 01 18 ; Logical OR ($18.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $0025.w		; 0D 25 00 ; Logical OR $0025.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$00.b],Y		; 17 00 ; OR accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $001E.w		; 0D 1E 00 ; Logical OR $001E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $3C.b		; 04 3C ; Test and set bits $3C.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $15.b		; 00 15 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $08.b		; 05 08 ; Logical OR $08.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $27.b		; 00 27 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $08.b		; 05 08 ; Logical OR $08.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $08.b		; 05 08 ; Logical OR $08.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0A.b],Y		; 17 0A ; OR accumulator with memory (long indexed) [$0A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0A.b],Y		; 17 0A ; OR accumulator with memory (long indexed) [$0A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $00.b		; 45 00 ; Exclusive OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($0B.b,S),Y		; 13 0B ; OR accumulator (stack relative indirect indexed) ($0B.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and #$1600.w		; 29 00 16 ; Logical AND #$1600.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $4F.b		; 00 4F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $1300.w,X		; 9E 00 13 ; Store zero to $1300.w,X [Reads: X Index]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	and #$0000.w		; 29 00 00 ; Logical AND #$0000.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $0F.b		; 02 0F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B0.b		; 00 B0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $D0, $00		; D0 00 ; Branch if not equal to $D0, $00 [Flow: branch]
	ora ($0C.b),Y		; 11 0C ; OR accumulator with memory ($0C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $3300.w,X		; 1D 00 33 ; OR accumulator with memory $3300.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($0C.b),Y		; 11 0C ; OR accumulator with memory ($0C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $2700.w,X		; 1D 00 27 ; OR accumulator with memory $2700.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($0C.b),Y		; 11 0C ; OR accumulator with memory ($0C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $0000.w,X		; 1D 00 00 ; OR accumulator with memory $0000.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $0025.w		; 0D 25 00 ; Logical OR $0025.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B4.b		; 00 B4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0025.w		; 0D 25 00 ; Logical OR $0025.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $001E.w		; 0D 1E 00 ; Logical OR $001E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and ($00.b,S),Y		; 33 00 ; AND accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $09.b		; 05 09 ; Logical OR $09.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $15.b		; 00 15 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $08.b		; 05 08 ; Logical OR $08.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0A.b],Y		; 17 0A ; OR accumulator with memory (long indexed) [$0A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($0B.b,S),Y		; 13 0B ; OR accumulator (stack relative indirect indexed) ($0B.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and #$1400.w		; 29 00 14 ; Logical AND #$1400.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DE.b		; 00 DE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $21.b		; 02 21 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$00E0.w		; C0 E0 00 ; Compare #$00E0.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora ($0C.b),Y		; 11 0C ; OR accumulator with memory ($0C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $0000.w,X		; 1D 00 00 ; OR accumulator with memory $0000.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B1.b		; 00 B1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta [$00.b],Y		; 97 00 ; Store accumulator (long indexed) [$00.b],Y [Reads: Direct Page, Y Index, Accumulator]
	ora ($0C.b),Y		; 11 0C ; OR accumulator with memory ($0C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $0A00.w,X		; 1D 00 0A ; OR accumulator with memory $0A00.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $08.b		; 05 08 ; Logical OR $08.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $08.b		; 05 08 ; Logical OR $08.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $08.b		; 05 08 ; Logical OR $08.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $14E0.w,Y		; 99 E0 14 ; Store accumulator to $14E0.w,Y [Reads: Y Index, Accumulator]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	asl $00.b,X		; 16 00 ; Arithmetic shift left $00.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpy #$0620.w		; C0 20 06 ; Compare #$0620.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora ($00.b,S),Y		; 13 00 ; OR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $26.b		; 00 26 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $21.b		; 02 21 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$0607.w		; C0 07 06 ; Compare #$0607.w with Y register [Reads: Y Index] [Flags: NCZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $1306.w		; 20 06 13 ; Jump to subroutine at $1306.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $0906.w		; 20 06 09 ; Jump to subroutine at $0906.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$14.b]		; 07 14 ; OR accumulator with memory (long) [$14.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,S),Y		; 13 00 ; OR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr $0620.w		; 20 20 06 ; Jump to subroutine at $0620.w [Writes: Stack Pointer] [Flow: call]
	ora ($00.b,S),Y		; 13 00 ; OR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	jsr $0607.w		; 20 07 06 ; Jump to subroutine at $0607.w [Writes: Stack Pointer] [Flow: call]
	ora $0000.w,Y		; 19 00 00 ; OR accumulator with memory $0000.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	jsr $0620.w		; 20 20 06 ; Jump to subroutine at $0620.w [Writes: Stack Pointer] [Flow: call]
	ora ($00.b,S),Y		; 13 00 ; OR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FDFD.w,X		; FD FD FD ; Subtract with carry $FDFD.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr $0620.w		; 20 20 06 ; Jump to subroutine at $0620.w [Writes: Stack Pointer] [Flow: call]
	ora ($00.b,S),Y		; 13 00 ; OR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $2020.w,X		; FE 20 20 ; Increment memory $2020.w,X [Reads: X Index] [Flags: NZ]
	asl $13.b		; 06 13 ; Arithmetic shift left $13.b [Reads: Direct Page] [Flags: NCZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $0200FF.l,X		; DF FF 00 02 ; Compare accumulator (long,X) $0200FF.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $000000.l		; 0F 00 00 00 ; OR accumulator with memory (long) $000000.l [Writes: Accumulator] [Flags: NZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $13.b		; 06 13 ; Arithmetic shift left $13.b [Reads: Direct Page] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $13.b		; 06 13 ; Arithmetic shift left $13.b [Reads: Direct Page] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $1306.w		; 20 06 13 ; Jump to subroutine at $1306.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	nop		; EA ; No operation
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $19.b		; 06 19 ; Arithmetic shift left $19.b [Reads: Direct Page] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $13.b		; 06 13 ; Arithmetic shift left $13.b [Reads: Direct Page] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $00ED.w		; ED ED 00 ; Subtract $00ED.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $28.b,S		; 03 28 ; OR accumulator with stack relative $28.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $000503.l,X		; 1F 03 05 00 ; Logical OR long $000503.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,X		; 15 03 ; OR accumulator with memory $03.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $0000.w		; 0D 00 00 ; Logical OR $0000.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $000000.l		; 0F 00 00 00 ; OR accumulator with memory (long) $000000.l [Writes: Accumulator] [Flags: NZ]
	ora ($15.b,X)		; 01 15 ; Logical OR ($15.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $0D.b,S		; 03 0D ; OR accumulator with stack relative $0D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $100F.w		; 1C 0F 10 ; Test and reset bits $100F.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $000F03.l,X		; 1F 03 0F 00 ; Logical OR long $000F03.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0000.w		; 0E 00 00 ; Arithmetic shift left $0000.w [Flags: NCZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $10.b		; 06 10 ; Arithmetic shift left $10.b [Reads: Direct Page] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	brk $27.b		; 00 27 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $08.b		; 06 08 ; Arithmetic shift left $08.b [Reads: Direct Page] [Flags: NCZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $05.b		; 14 05 ; Test and reset bits $05.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0511.w,X		; 1E 11 05 ; Arithmetic shift left $0511.w,X [Reads: X Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$14.b]		; 07 14 ; OR accumulator with memory (long) [$14.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $08		; 10 08 ; Branch if plus to $10, $08 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($07.b)		; 12 07 ; OR accumulator with memory (indirect) ($07.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $0514.w		; 20 14 05 ; Jump to subroutine at $0514.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $0A.b,S		; 23 0A ; AND accumulator with stack relative $0A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $000000.l		; 0F 00 00 00 ; OR accumulator with memory (long) $000000.l [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1D.b		; 00 1D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $000005.l		; 0F 05 00 00 ; OR accumulator with memory (long) $000005.l [Writes: Accumulator] [Flags: NZ]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $0A.b,S		; 23 0A ; AND accumulator with stack relative $0A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $000000.l		; 0F 00 00 00 ; OR accumulator with memory (long) $000000.l [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $19.b		; 00 19 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $2A.b		; 06 2A ; Arithmetic shift left $2A.b [Reads: Direct Page] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $13.b		; 06 13 ; Arithmetic shift left $13.b [Reads: Direct Page] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $FF		; Opcode FF overrunning bank boundry at 027FFC. Skipping. ; Subtract with carry (long,X) $FF [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $FF		; Opcode FF overrunning bank boundry at 027FFD. Skipping. ; Subtract with carry (long,X) $FF [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $FF		; Opcode FF overrunning bank boundry at 027FFE. Skipping. ; Subtract with carry (long,X) $FF [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $FF		; Opcode FF overrunning bank boundry at 027FFF. Skipping. ; Subtract with carry (long,X) $FF [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
.ENDS
