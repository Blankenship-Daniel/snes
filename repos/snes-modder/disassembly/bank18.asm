.BANK 18 SLOT 0
.ORG $0000

.SECTION "Bank18" FORCE

	ora [$D7.b]		; 07 D7 ; OR accumulator with memory (long) [$D7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $1FFF22.l		; 0F 22 FF 1F ; OR accumulator with memory (long) $1FFF22.l [Writes: Accumulator] [Flags: NZ]
	inc $F8FC.w,X		; FE FC F8 ; Increment memory $F8FC.w,X [Reads: X Index] [Flags: NZ]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	ldx $5D1E.w		; AE 1E 5D ; Load $5D1E.w into X register [Writes: X Index] [Flags: NZ]
	bit $79B9.w,X		; 3C B9 79 ; Test bits $79B9.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	adc ($F3.b,S),Y		; 73 F3 ; Add with carry (stack relative indirect indexed) ($F3.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$E7.b]		; E7 E7 ; Subtract with carry (long) [$E7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp $9F9FCF.l		; CF CF 9F 9F ; Compare accumulator (long) $9F9FCF.l [Reads: Accumulator] [Flags: NCZ]
	and $83C13F.l,X		; 3F 3F C1 83 ; AND accumulator with memory (long,X) $83C13F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $0C.b		; 06 0C ; Arithmetic shift left $0C.b [Reads: Direct Page] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $30, $60		; 30 60 ; Branch if minus to $30, $60 [Flow: branch]
	cpy #$FF.b		; C0 FF ; Compare #$FF.b with Y register [Reads: Y Index] [Flags: NCZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $FF0900.l		; 22 00 09 FF ; Jump to subroutine long $FF0900.l [Writes: Stack Pointer] [Flow: call]
	brk $73.b		; 00 73 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $E7		; 90 E7 ; Branch if carry clear to $90, $E7 [Flow: branch]
	jsr $42CD.w		; 20 CD 42 ; Jump to subroutine at $42CD.w [Writes: Stack Pointer] [Flow: call]
	stz $220C.w		; 9C 0C 22 ; Store zero to $220C.w
	sbc $0C0007.l,X		; FF 07 00 0C ; Subtract with carry (long,X) $0C0007.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $30, $63		; 30 63 ; Branch if minus to $30, $63 [Flow: branch]
	sbc $22FF00.l,X		; FF 00 FF 22 ; Subtract with carry (long,X) $22FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $897600.l,X		; FF 00 76 89 ; Subtract with carry (long,X) $897600.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $6DDBC9.l,X		; BF C9 DB 6D ; Load long $6DDBC9.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta ($92.b)		; 92 92 ; Store accumulator (indirect) ($92.b) [Reads: Direct Page, Accumulator]
	jsl $0023FF.l		; 22 FF 23 00 ; Jump to subroutine long $0023FF.l [Writes: Stack Pointer] [Flow: call]
	cpx #$22.b		; E0 22 ; Compare #$22.b with X register [Reads: X Index] [Flags: NCZ]
	adc $08D7.w		; 6D D7 08 ; Add $08D7.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	dec $DC02.w,X		; DE 02 DC ; Decrement memory $DC02.w,X [Reads: X Index] [Flags: NZ]
	tsb $D9.b		; 04 D9 ; Test and set bits $D9.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cmp ($01.b,S),Y		; D3 01 ; Compare accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	cmp [$01.b],Y		; D7 01 ; Compare accumulator (long indexed) [$01.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	jmp.w [$DE02]		; DC 02 DE ; Jump long indirect [$DE02] [Flow: jump]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($E3.b,X)		; E1 E3 ; Subtract with carry ($E3.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $EC.b		; E6 EC ; Increment $EC.b [Reads: Direct Page] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sbc ($E1.b,X)		; E1 E1 ; Subtract with carry ($E1.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp [$0D.b],Y		; D7 0D ; Compare accumulator (long indexed) [$0D.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	asl $DC.b		; 06 DC ; Arithmetic shift left $DC.b [Reads: Direct Page] [Flags: NCZ]
	cop $DF.b		; 02 DF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($D6.b,X)		; 01 D6 ; Logical OR ($D6.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $7C85.w		; 0E 85 7C ; Arithmetic shift left $7C85.w [Flags: NCZ]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$E1.b		; E0 E1 ; Compare #$E1.b with X register [Reads: X Index] [Flags: NCZ]
	sbc ($E0.b,X)		; E1 E0 ; Subtract with carry ($E0.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($E1.b,X)		; E1 E1 ; Subtract with carry ($E1.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$E1.b		; E0 E1 ; Compare #$E1.b with X register [Reads: X Index] [Flags: NCZ]
	sbc $22FF00.l,X		; FF 00 FF 22 ; Subtract with carry (long,X) $22FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FF0000.l,X		; FF 00 00 FF ; Subtract with carry (long,X) $FF0000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp.w [$EFFF]		; DC FF EF ; Jump long indirect [$EFFF] [Flow: jump]
	inc $FEE7.w,X		; FE E7 FE ; Increment memory $FEE7.w,X [Reads: X Index] [Flags: NZ]
	jsl $0024FF.l		; 22 FF 24 00 ; Jump to subroutine long $0024FF.l [Writes: Stack Pointer] [Flow: call]
	cop $FF.b		; 02 FF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $968300.l		; 22 00 83 96 ; Jump to subroutine long $968300.l [Writes: Stack Pointer] [Flow: call]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $F7EBFF.l		; EF FF EB F7 ; Subtract with carry (long) $F7EBFF.l [Writes: Accumulator] [Flags: NCVZ]
	jmp.w [$2263]		; DC 63 22 ; Jump long indirect [$2263] [Flow: jump]
	sbc $020024.l,X		; FF 24 00 02 ; Subtract with carry (long,X) $020024.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $22FF00.l,X		; FF 00 FF 22 ; Subtract with carry (long,X) $22FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $7D8200.l,X		; FF 00 82 7D ; Subtract with carry (long,X) $7D8200.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	.db $80, $02		; 80 02 ; Branch always to $80, $02 [Flow: branch]
	sbc $FF2200.l,X		; FF 00 22 FF ; Subtract with carry (long,X) $FF2200.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $7D.b		; 00 7D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $0043.w,X		; 7D 43 00 ; Add $0043.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $090022.l,X		; FF 22 00 09 ; Subtract with carry (long,X) $090022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F70800.l,X		; FF 00 08 F7 ; Subtract with carry (long,X) $F70800.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	trb $08.b		; 14 08 ; Test and reset bits $08.b [Reads: Accumulator] [Flags: Z]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FF2200.l,X		; FF 00 22 FF ; Subtract with carry (long,X) $FF2200.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$00.b],Y		; F7 00 ; Subtract with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $D14700.l,X		; DF 00 47 D1 ; Compare accumulator (long,X) $D14700.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $D5.b		; 06 D5 ; Arithmetic shift left $D5.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cmp $D506.w,Y		; D9 06 D5 ; Compare accumulator $D506.w,Y [Reads: Y Index] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cpx #$24.b		; E0 24 ; Compare #$24.b with X register [Reads: X Index] [Flags: NCZ]
	inc $01.b		; E6 01 ; Increment $01.b [Reads: Direct Page] [Flags: NZ]
	cpx #$E6.b		; E0 E6 ; Compare #$E6.b with X register [Reads: X Index] [Flags: NCZ]
	eor $D1.b		; 45 D1 ; Exclusive OR $D1.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sty $FA.b		; 84 FA ; Store Y register to $FA.b [Reads: Y Index]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cmp ($23.b),Y		; D1 23 ; Compare accumulator ($23.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	inc $00.b		; E6 00 ; Increment $00.b [Reads: Direct Page] [Flags: NZ]
	cpx #$22.b		; E0 22 ; Compare #$22.b with X register [Reads: X Index] [Flags: NCZ]
	inc $03.b		; E6 03 ; Increment $03.b [Reads: Direct Page] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($01.b,X)		; 41 01 ; Exclusive OR accumulator with memory ($01.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor $7E.b		; 45 7E ; Exclusive OR $7E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $7F43.w,X		; FE 43 7F ; Increment memory $7F43.w,X [Reads: X Index] [Flags: NZ]
	sbc $FE0103.l,X		; FF 03 01 FE ; Subtract with carry (long,X) $FE0103.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $0122FE.l,X		; FF FE 22 01 ; Subtract with carry (long,X) $0122FE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $800500.l		; 22 00 05 80 ; Jump to subroutine long $800500.l [Writes: Stack Pointer] [Flow: call]
	.db $80, $40		; 80 40 ; Branch always to $80, $40 [Flow: branch]
	cpy #$BF.b		; C0 BF ; Compare #$BF.b with Y register [Reads: Y Index] [Flags: NCZ]
	adc $BFDF45.l,X		; 7F 45 DF BF ; Add long $BFDF45.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $6F.b		; 05 6F ; Logical OR $6F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $7F0FF0.l,X		; 9F F0 0F 7F ; Store accumulator (long,X) $7F0FF0.l,X [Reads: Accumulator, X Index]
	and $E00025.l,X		; 3F 25 00 E0 ; AND accumulator with memory (long,X) $E00025.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	sbc $F806.w,X		; FD 06 F8 ; Subtract with carry $F806.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $F9F1.w		; 0E F1 F9 ; Arithmetic shift left $F9F1.w [Flags: NCZ]
	asl $F3.b		; 06 F3 ; Arithmetic shift left $F3.b [Reads: Direct Page] [Flags: NCZ]
	sta $30.b,S		; 83 30 ; Store accumulator (stack relative) $30.b,S [Reads: Stack Pointer, Accumulator]
	cmp $F8EF10.l		; CF 10 EF F8 ; Compare accumulator (long) $F8EF10.l [Reads: Accumulator] [Flags: NCZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0000.w		; 0C 00 00 ; Test and set bits $0000.w [Reads: Accumulator] [Flags: Z]
	clv		; B8 ; Clear overflow flag [Flags: V]
	ldy #$7C.b		; A0 7C ; Load #$7C.b into Y register [Writes: Y Index] [Flags: NZ]
	adc ($9E.b,S),Y		; 73 9E ; Add with carry (stack relative indirect indexed) ($9E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F90E.w,Y		; F9 0E F9 ; Subtract with carry $F90E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $CBFB00.l,X		; FF 00 FB CB ; Subtract with carry (long,X) $CBFB00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $D7		; 30 D7 ; Branch if minus to $30, $D7 [Flow: branch]
	.db $30, $DF		; 30 DF ; Branch if minus to $30, $DF [Flow: branch]
	eor [$80.b]		; 47 80 ; Exclusive OR accumulator with memory (long) [$80.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $040100.l		; 22 00 01 04 ; Jump to subroutine long $040100.l [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $020022.l,X		; FF 22 00 02 ; Subtract with carry (long,X) $020022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $290000.l,X		; FF 00 00 29 ; Subtract with carry (long,X) $290000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $020024.l,X		; FF 24 00 02 ; Subtract with carry (long,X) $020024.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $22FF00.l,X		; FF 00 FF 22 ; Subtract with carry (long,X) $22FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $290000.l,X		; FF 00 00 29 ; Subtract with carry (long,X) $290000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $4F0024.l,X		; FF 24 00 4F ; Subtract with carry (long,X) $4F0024.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp [$0F.b],Y		; D7 0F ; Compare accumulator (long indexed) [$0F.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	and [$E0.b]		; 27 E0 ; AND accumulator with memory (long) [$E0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $270FD7.l		; 4F D7 0F 27 ; Exclusive OR accumulator with memory (long) $270FD7.l [Writes: Accumulator] [Flags: NZ]
	cpx #$43.b		; E0 43 ; Compare #$43.b with X register [Reads: X Index] [Flags: NCZ]
	sbc $C00E00.l,X		; FF 00 0E C0 ; Subtract with carry (long,X) $C00E00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr $00DF.w		; 20 DF 00 ; Jump to subroutine at $00DF.w [Writes: Stack Pointer] [Flow: call]
	cld		; D8 ; Clear decimal flag [Flags: D]
	ora [$D5.b]		; 07 D5 ; OR accumulator with memory (long) [$D5.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	cmp ($0D.b)		; D2 0D ; Compare accumulator (indirect) ($0D.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp $0E.b,X		; D5 0E ; Compare accumulator $0E.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc $24DFFF.l,X		; FF FF DF 24 ; Subtract with carry (long,X) $24DFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$43.b		; E0 43 ; Compare #$43.b with X register [Reads: X Index] [Flags: NCZ]
	cmp [$0F.b],Y		; D7 0F ; Compare accumulator (long indexed) [$0F.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$0F.b],Y		; 17 0F ; OR accumulator with memory (long indexed) [$0F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc [$0F.b],Y		; F7 0F ; Subtract with carry (long indexed) [$0F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$F7.b]		; 07 F7 ; OR accumulator with memory (long) [$F7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc $FD62.w,X		; FD 62 FD ; Subtract with carry $FD62.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $0003E0.l		; 22 E0 03 00 ; Jump to subroutine long $0003E0.l [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	jsl $400100.l		; 22 00 01 40 ; Jump to subroutine long $400100.l [Writes: Stack Pointer] [Flow: call]
	brk $47.b		; 00 47 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $7F02BF.l,X		; 3F BF 02 7F ; AND accumulator with memory (long,X) $7F02BF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $FF2200.l,X		; FF 00 22 FF ; Subtract with carry (long,X) $FF2200.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $40.b,S		; 23 40 ; AND accumulator with stack relative $40.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$FF.b		; 29 FF ; Logical AND #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $0025FF.l		; 22 FF 25 00 ; Jump to subroutine long $0025FF.l [Writes: Stack Pointer] [Flow: call]
	eor $273F3E.l		; 4F 3E 3F 27 ; Exclusive OR accumulator with memory (long) $273F3E.l [Writes: Accumulator] [Flags: NZ]
	cpy #$4B.b		; C0 4B ; Compare #$4B.b with Y register [Reads: Y Index] [Flags: NCZ]
	rol $033F.w,X		; 3E 3F 03 ; Rotate left $033F.w,X [Reads: X Index] [Flags: NCZ]
	.db $42, $03		; 42 03 ; Reserved instruction
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $C0.b		; 25 C0 ; Logical AND $C0.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx #$29.b		; E0 29 ; Compare #$29.b with X register [Reads: X Index] [Flags: NCZ]
	jsr ($7EC0.w,X)		; FC C0 7E ; Jump to subroutine indirect indexed ($7EC0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $987EBC.l,X		; FF BC 7E 98 ; Subtract with carry (long,X) $987EBC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $DBC0.w,X		; BD C0 DB ; Load $DBC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$F7.b		; E0 F7 ; Compare #$F7.b with X register [Reads: X Index] [Flags: NCZ]
	cmp ($EE.b,X)		; C1 EE ; Compare accumulator ($EE.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	sta $DD.b,S		; 83 DD ; Store accumulator (stack relative) $DD.b,S [Reads: Stack Pointer, Accumulator]
	tsb $BB.b		; 04 BB ; Test and set bits $BB.b [Reads: Accumulator] [Flags: Z]
	brk $81.b		; 00 81 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $42, $24		; 42 24 ; Reserved instruction
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sty $9BF3.w		; 8C F3 9B ; Store Y register to $9BF3.w [Reads: Y Index]
	jmp ($9C73.w)		; 6C 73 9C ; Jump indirect to ($9C73.w) [Flow: jump]
	adc [$B9.b]		; 67 B9 ; Add with carry (long) [$B9.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	dec $9E73.w		; CE 73 9E ; Decrement $9E73.w [Flags: NZ]
	sbc $3F.b,S		; E3 3F ; Subtract stack-relative $3F.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	cmp #$77.b		; C9 77 ; Compare #$77.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	stz $0023.w		; 9C 23 00 ; Store zero to $0023.w
	ora ($01.b,S),Y		; 13 01 ; OR accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	lda $14EA40.l,X		; BF 40 EA 14 ; Load long $14EA40.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $28.b,X		; D5 28 ; Compare accumulator $28.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	eor ($D5.b,X)		; 41 D5 ; Exclusive OR accumulator with memory ($D5.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $AD.b,S		; 23 AD ; AND accumulator with stack relative $AD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $D6.b,S		; 43 D6 ; Exclusive OR accumulator with stack relative $D6.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora #$AB.b		; 09 AB ; Logical OR #$AB.b with accumulator [Writes: Accumulator] [Flags: NZ]
	trb $0023.w		; 1C 23 00 ; Test and reset bits $0023.w [Reads: Accumulator] [Flags: Z]
	sta $9C.b,S		; 83 9C ; Store accumulator (stack relative) $9C.b,S [Reads: Stack Pointer, Accumulator]
	cop $17.b		; 02 17 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $080F04.l,X		; FF 04 0F 08 ; Subtract with carry (long,X) $080F04.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $FC00.w,X		; FE 00 FC ; Increment memory $FC00.w,X [Reads: X Index] [Flags: NZ]
	cpy #$F8.b		; C0 F8 ; Compare #$F8.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $80, $FC		; 80 FC ; Branch always to $80, $FC [Flow: branch]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F9.b		; 00 F9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($07.b,S),Y		; F3 07 ; Subtract with carry (stack relative indirect indexed) ($07.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cmp $F3039F.l		; CF 9F 03 F3 ; Compare accumulator (long) $F3039F.l [Reads: Accumulator] [Flags: NCZ]
	ora $23.b,S		; 03 23 ; OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $2F171F.l		; 2F 1F 17 2F ; AND accumulator with memory (long) $2F171F.l [Writes: Accumulator] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	and [$35.b],Y		; 37 35 ; AND accumulator with memory (long indexed) [$35.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	and $3F3C.w,X		; 3D 3C 3F ; AND accumulator with memory $3F3C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $C025FF.l,X		; FF FF 25 C0 ; Subtract with carry (long,X) $C025FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $3E.b,S		; 43 3E ; Exclusive OR accumulator with stack relative $3E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $DFDE05.l,X		; 3F 05 DE DF ; AND accumulator with memory (long,X) $DFDE05.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $F6EF.w		; EE EF F6 ; Increment $F6EF.w [Flags: NZ]
	sbc [$63.b],Y		; F7 63 ; Subtract with carry (long indexed) [$63.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $C0C0.w,X		; FE C0 C0 ; Increment memory $C0C0.w,X [Reads: X Index] [Flags: NZ]
	jsr $8310.w		; 20 10 83 ; Jump to subroutine at $8310.w [Writes: Stack Pointer] [Flow: call]
	tsb DMASRC0L.w		; 0C 02 43 ; Test and set bits DMASRC0L.w [Reads: Accumulator] [Flags: Z]
	cmp [$0F.b],Y		; D7 0F ; Compare accumulator (long indexed) [$0F.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	asl $D3.b		; 06 D3 ; Arithmetic shift left $D3.b [Reads: Direct Page] [Flags: NCZ]
	ora $D60FD4.l		; 0F D4 0F D6 ; OR accumulator with memory (long) $D60FD4.l [Writes: Accumulator] [Flags: NZ]
	ora $0F43D7.l		; 0F D7 43 0F ; OR accumulator with memory (long) $0F43D7.l [Writes: Accumulator] [Flags: NZ]
	cmp ($00.b,S),Y		; D3 00 ; Compare accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	tsb $E027.w		; 0C 27 E0 ; Test and set bits $E027.w [Reads: Accumulator] [Flags: Z]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	cmp [$0E.b],Y		; D7 0E ; Compare accumulator (long indexed) [$0E.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cmp [$0F.b],Y		; D7 0F ; Compare accumulator (long indexed) [$0F.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	dec $0F.b,X		; D6 0F ; Decrement memory $0F.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	cmp ($0E.b),Y		; D1 0E ; Compare accumulator ($0E.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cmp [$0C.b],Y		; D7 0C ; Compare accumulator (long indexed) [$0C.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cmp $0E.b,X		; D5 0E ; Compare accumulator $0E.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	eor $D6.b,S		; 43 D6 ; Exclusive OR accumulator with stack relative $D6.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $22E027.l		; 0F 27 E0 22 ; OR accumulator with memory (long) $22E027.l [Writes: Accumulator] [Flags: NZ]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FF0800.l,X		; FF 00 08 FF ; Subtract with carry (long,X) $FF0800.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $807FC0.l,X		; 7F C0 7F 80 ; Add long $807FC0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $0026FF.l,X		; 7F FF 26 00 ; Add long $0026FF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $C0.b		; 06 C0 ; Arithmetic shift left $C0.b [Reads: Direct Page] [Flags: NCZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	lda $C03F80.l,X		; BF 80 3F C0 ; Load long $C03F80.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $1C.b,S		; 83 1C ; Store accumulator (stack relative) $1C.b,S [Reads: Stack Pointer, Accumulator]
	cop $44.b		; 02 44 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $7F0200.l,X		; FF 00 02 7F ; Subtract with carry (long,X) $7F0200.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	tsb $0377.w		; 0C 77 03 ; Test and set bits $0377.w [Reads: Accumulator] [Flags: Z]
	stz $FC17.w		; 9C 17 FC ; Store zero to $FC17.w
	sta [$25.b]		; 87 25 ; Store accumulator (long) [$25.b] [Reads: Direct Page, Accumulator]
	.db $80, $01		; 80 01 ; Branch always to $80, $01 [Flow: branch]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: NCZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	tsb $0377.w		; 0C 77 03 ; Test and set bits $0377.w [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc ($0B.b,S),Y		; 73 0B ; Add with carry (stack relative indirect indexed) ($0B.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	stz $25.b,X		; 74 25 ; Store zero to $25.b,X [Reads: X Index]
	.db $80, $12		; 80 12 ; Branch always to $80, $12 [Flow: branch]
	sty $80.b		; 84 80 ; Store Y register to $80.b [Reads: Y Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	and $105F20.l,X		; 3F 20 5F 10 ; AND accumulator with memory (long,X) $105F20.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $0F700F.l		; 6F 0F 70 0F ; Add with carry (long) $0F700F.l [Writes: Accumulator] [Flags: NCVZ]
	adc [$0E.b],Y		; 77 0E ; Add with carry (long indexed) [$0E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $0D.b,X		; 75 0D ; Add $0D.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $FF.b,X		; 76 FF ; Rotate right $FF.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	rol $80.b		; 26 80 ; Rotate left $80.b [Reads: Direct Page] [Flags: NCZ]
	.db $10, $8C		; 10 8C ; Branch if plus to $10, $8C [Flow: branch]
	adc [$4C.b],Y		; 77 4C ; Add with carry (long indexed) [$4C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$2C.b],Y		; F7 2C ; Subtract with carry (long indexed) [$2C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$1C.b],Y		; F7 1C ; Subtract with carry (long indexed) [$1C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$FC.b],Y		; F7 FC ; Subtract with carry (long indexed) [$FC.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $02FBF8.l		; 0F F8 FB 02 ; OR accumulator with memory (long) $02FBF8.l [Writes: Accumulator] [Flags: NZ]
	sbc $80FF01.l,X		; FF 01 FF 80 ; Subtract with carry (long,X) $80FF01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp [$0E.b],Y		; D7 0E ; Compare accumulator (long indexed) [$0E.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	eor $D6.b,S		; 43 D6 ; Exclusive OR accumulator with stack relative $D6.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $D547.w		; 0D 47 D5 ; Logical OR $D547.w with accumulator [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora ($D4.b,X)		; 01 D4 ; Logical OR ($D4.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	and [$E0.b]		; 27 E0 ; AND accumulator with memory (long) [$E0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl $1C12.w		; 0E 12 1C ; Arithmetic shift left $1C12.w [Flags: NCZ]
	sbc ($0E.b,S),Y		; F3 0E ; Subtract with carry (stack relative indirect indexed) ($0E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($0F.b),Y		; F1 0F ; Subtract with carry ($0F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $FF		; F0 FF ; Branch if equal to $F0, $FF [Flow: branch]
	tsb $FF.b		; 04 FF ; Test and set bits $FF.b [Reads: Accumulator] [Flags: Z]
	eor $FC.b,S		; 43 FC ; Exclusive OR accumulator with stack relative $FC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc ($26.b,X)		; E1 26 ; Subtract with carry ($26.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $45.b		; 00 45 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0977.w		; 0C 77 09 ; Test and set bits $0977.w [Reads: Accumulator] [Flags: Z]
	jmp $FCF7.w		; 4C F7 FC ; Jump to $FCF7.w [Flow: jump]
	ora [$FF.b]		; 07 FF ; OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $C0BF.w		; 0E BF C0 ; Arithmetic shift left $C0BF.w [Flags: NCZ]
	ora $802260.l,X		; 1F 60 22 80 ; Logical OR long $802260.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $80, $DD		; 80 DD ; Branch always to $80, $DD [Flow: branch]
	rol $7CBB.w,X		; 3E BB 7C ; Rotate left $7CBB.w,X [Reads: X Index] [Flags: NCZ]
	ror $F8.b,X		; 76 F8 ; Rotate right $F8.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc $DBF1.w		; ED F1 DB ; Subtract $DBF1.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sbc $B7.b,S		; E3 B7 ; Subtract stack-relative $B7.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	cmp [$6F.b]		; C7 6F ; Compare accumulator (long) [$6F.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sta $3E1FDF.l		; 8F DF 1F 3E ; Store accumulator (long) $3E1FDF.l [Reads: Accumulator]
	jmp ($F2F9.w,X)		; 7C F9 F2 ; Jump indirect indexed to ($F2F9.w,X) [Reads: X Index] [Flow: jump]
	cpx $C8.b		; E4 C8 ; Compare $C8.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $90, $20		; 90 20 ; Branch if carry clear to $90, $20 [Flow: branch]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	lsr $F7.b		; 46 F7 ; Logical shift right $F7.b [Reads: Direct Page] [Flags: NCZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$FF.b],Y		; F7 FF ; Subtract with carry (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $F72400.l		; 22 00 24 F7 ; Jump to subroutine long $F72400.l [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $DD.b		; 45 DD ; Exclusive OR $DD.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $C104.w,X		; 3E 04 C1 ; Rotate left $C104.w,X [Reads: X Index] [Flags: NCZ]
	rol $00FF.w,X		; 3E FF 00 ; Rotate left $00FF.w,X [Reads: X Index] [Flags: NCZ]
	cmp ($43.b,X)		; C1 43 ; Compare accumulator ($43.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	rol $24DD.w,X		; 3E DD 24 ; Rotate left $24DD.w,X [Reads: X Index] [Flags: NCZ]
	rol $0000.w,X		; 3E 00 00 ; Rotate left $0000.w,X [Reads: X Index] [Flags: NCZ]
	jsl $FF433E.l		; 22 3E 43 FF ; Jump to subroutine long $FF433E.l [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$46.b		; C0 46 ; Compare #$46.b with Y register [Reads: Y Index] [Flags: NCZ]
	and $DC05DF.l,X		; 3F DF 05 DC ; AND accumulator with memory (long,X) $DC05DF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $003EDD.l,X		; 3F DD 3E 00 ; AND accumulator with memory (long,X) $003EDD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $DD3E44.l,X		; 3F 44 3E DD ; AND accumulator with memory (long,X) $DD3E44.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $1D.b		; 00 1D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $FE.b		; 46 FE ; Logical shift right $FE.b [Reads: Direct Page] [Flags: NCZ]
	sbc $0105.w,X		; FD 05 01 ; Subtract with carry $0105.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $00FF.w,X		; FE FF 00 ; Increment memory $00FF.w,X [Reads: X Index] [Flags: NZ]
	rol $243E.w,X		; 3E 3E 24 ; Rotate left $243E.w,X [Reads: X Index] [Flags: NCZ]
	inc $000C.w,X		; FE 0C 00 ; Increment memory $000C.w,X [Reads: X Index] [Flags: NZ]
	sbc $FA0600.l,X		; FF 00 06 FA ; Subtract with carry (long,X) $FA0600.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $F9F4.w		; 0C F4 F9 ; Test and set bits $F9F4.w [Reads: Accumulator] [Flags: Z]
	ora #$33.b		; 09 33 ; Logical OR #$33.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $67		; D0 67 ; Branch if not equal to $D0, $67 [Flow: branch]
	ldy #$83.b		; A0 83 ; Load #$83.b into Y register [Writes: Y Index] [Flags: NZ]
	bit $0200.w,X		; 3C 00 02 ; Test bits $0200.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $83.b,S		; 03 83 ; OR accumulator with stack relative $83.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor [$00.b]		; 47 00 ; Exclusive OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $4E8900.l		; 22 00 89 4E ; Jump to subroutine long $4E8900.l [Writes: Stack Pointer] [Flow: call]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $100023.l,X		; FF 23 00 10 ; Subtract with carry (long,X) $100023.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $6C93.w		; 6D 93 6C ; Add $6C93.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	stx $6A.b,Y		; 96 6A ; Store X register $6A.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	stz $9964.w		; 9C 64 99 ; Store zero to $9964.w
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	lda ($51.b,S),Y		; B3 51 ; Load accumulator (stack relative indirect indexed) ($51.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc [$21.b]		; E7 21 ; Subtract with carry (long) [$21.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cpy $9E42.w		; CC 42 9E ; Compare $9E42.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $10, $85		; 10 85 ; Branch if plus to $10, $85 [Flow: branch]
	.db $90, $04		; 90 04 ; Branch if carry clear to $90, $04 [Flow: branch]
	ora ($31.b,X)		; 01 31 ; Logical OR ($31.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	adc ($8F.b,X)		; 61 8F ; Add with carry ($8F.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc ($61.b,X)		; 61 61 ; Add with carry ($61.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc ($61.b,X)		; 61 61 ; Add with carry ($61.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc ($FF.b,X)		; 61 FF ; Add with carry ($FF.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $868400.l		; 22 00 84 86 ; Jump to subroutine long $868400.l [Writes: Stack Pointer] [Flow: call]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: NCZ]
	sta $227F9E.l,X		; 9F 9E 7F 22 ; Store accumulator (long,X) $227F9E.l,X [Reads: Accumulator, X Index]
	sbc $1A0024.l,X		; FF 24 00 1A ; Subtract with carry (long,X) $1A0024.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $C02000.l,X		; FF 00 20 C0 ; Subtract with carry (long,X) $C02000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $139F88.l		; 4F 88 9F 13 ; Exclusive OR accumulator with memory (long) $139F88.l [Writes: Accumulator] [Flags: NZ]
	lda $20BF27.l,X		; BF 27 BF 20 ; Load long $20BF27.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	sbc $1F0F00.l,X		; FF 00 0F 1F ; Subtract with carry (long,X) $1F0F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $63		; 30 63 ; Branch if minus to $30, $63 [Flow: branch]
	eor [$40.b]		; 47 40 ; Exclusive OR accumulator with memory (long) [$40.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $00FF00.l,X		; 7F 00 FF 00 ; Add long $00FF00.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $43.b		; 04 43 ; Test and set bits $43.b [Reads: Accumulator] [Flags: Z]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $C0		; 10 C0 ; Branch if plus to $10, $C0 [Flow: branch]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ora $DF.b,S		; 03 DF ; OR accumulator with stack relative $DF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $01F307.l		; CF 07 F3 01 ; Compare accumulator (long) $01F307.l [Reads: Accumulator] [Flags: NCZ]
	sta [$B8.b],Y		; 97 B8 ; Store accumulator (long indexed) [$B8.b],Y [Reads: Direct Page, Y Index, Accumulator]
	cop $09.b		; 02 09 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $20C010.l		; EF 10 C0 20 ; Subtract with carry (long) $20C010.l [Writes: Accumulator] [Flags: NCVZ]
	sta $179FC8.l		; 8F C8 9F 17 ; Store accumulator (long) $179FC8.l [Reads: Accumulator]
	lda $02852F.l,X		; BF 2F 85 02 ; Load long $02852F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $6730DF.l		; EF DF 30 67 ; Subtract with carry (long) $6730DF.l [Writes: Accumulator] [Flags: NCVZ]
	eor $050D85.l		; 4F 85 0D 05 ; Exclusive OR accumulator with memory (long) $050D85.l [Writes: Accumulator] [Flags: NZ]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr ($1790.w,X)		; FC 90 17 ; Jump to subroutine indirect indexed ($1790.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora $43.b		; 05 43 ; Logical OR $43.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $FA.b,S		; 03 FA ; OR accumulator with stack relative $FA.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr ($F8F6.w,X)		; FC F6 F8 ; Jump to subroutine indirect indexed ($F8F6.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	eor $FD.b,S		; 43 FD ; Exclusive OR accumulator with stack relative $FD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc ($0B.b),Y		; F1 0B ; Subtract with carry ($0B.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F30CF3.l,X		; FF F3 0C F3 ; Subtract with carry (long,X) $F30CF3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($01FC.w,X)		; FC FC 01 ; Jump to subroutine indirect indexed ($01FC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $47.b		; 00 47 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $073F.w,X		; 3E 3F 07 ; Rotate left $073F.w,X [Reads: X Index] [Flags: NCZ]
	and $201F30.l		; 2F 30 1F 20 ; AND accumulator with memory (long) $201F30.l [Writes: Accumulator] [Flags: NZ]
	and ($C3.b)		; 32 C3 ; AND accumulator with memory (indirect) ($C3.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $25CF.w		; 0E CF 25 ; Arithmetic shift left $25CF.w [Flags: NCZ]
	cpy #$04.b		; C0 04 ; Compare #$04.b with Y register [Reads: Y Index] [Flags: NCZ]
	tsb $0030.w		; 0C 30 00 ; Test and set bits $0030.w [Reads: Accumulator] [Flags: Z]
	and $3F4A7E.l,X		; 3F 7E 4A 3F ; AND accumulator with memory (long,X) $3F4A7E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rol $4701.w,X		; 3E 01 47 ; Rotate left $4701.w,X [Reads: X Index] [Flags: NCZ]
	lsr $26.b		; 46 26 ; Logical shift right $26.b [Reads: Direct Page] [Flags: NCZ]
	cpy #$05.b		; C0 05 ; Compare #$05.b with Y register [Reads: Y Index] [Flags: NCZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	lda $5FDE.w,X		; BD DE 5F ; Load $5FDE.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	and $62.b,S		; 23 62 ; AND accumulator with stack relative $62.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $3E47.w,X		; 3C 47 3E ; Test bits $3E47.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	and $800001.l,X		; 3F 01 00 80 ; AND accumulator with memory (long,X) $800001.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $C0.b		; 25 C0 ; Logical AND $C0.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0C770C.l		; 0F 0C 77 0C ; OR accumulator with memory (long) $0C770C.l [Writes: Accumulator] [Flags: NZ]
	adc ($0E.b,S),Y		; 73 0E ; Add with carry (stack relative indirect indexed) ($0E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	adc ($0F.b),Y		; 71 0F ; Add with carry ($0F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $18		; 70 18 ; Branch if overflow set to $70, $18 [Flow: branch]
	adc $30.b,S		; 63 30 ; Add with carry (stack relative) $30.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	wai		; CB ; Wait for interrupt
	pea $CC0F.w		; F4 0F CC ; Push absolute address $CC0F.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	eor [$23.b],Y		; 57 23 ; Exclusive OR accumulator with memory (long indexed) [$23.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $80, $1B		; 80 1B ; Branch always to $80, $1B [Flow: branch]
	sty $04.b		; 84 04 ; Store Y register to $04.b [Reads: Y Index]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $4CB7.w		; AC B7 4C ; Load $4CB7.w into Y register [Writes: Y Index] [Flags: NZ]
	adc [$CF.b],Y		; 77 CF ; Add with carry (long indexed) [$CF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $EF		; F0 EF ; Branch if equal to $F0, $EF [Flow: branch]
	adc ($FC.b,S),Y		; 73 FC ; Add with carry (stack relative indirect indexed) ($FC.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	and $78.b,X		; 35 78 ; Logical AND $78.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $3C.b,S		; 03 3C ; OR accumulator with stack relative $3C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor [$0C.b]		; 47 0C ; Exclusive OR accumulator with memory (long) [$0C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc [$40.b],Y		; 77 40 ; Add with carry (long indexed) [$40.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $80.b		; 84 80 ; Store Y register to $80.b [Reads: Y Index]
	.db $80, $FF		; 80 FF ; Branch always to $80, $FF [Flow: branch]
	cpx #$2B.b		; E0 2B ; Compare #$2B.b with X register [Reads: X Index] [Flags: NCZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $011F00.l		; 0F 00 1F 01 ; OR accumulator with memory (long) $011F00.l [Writes: Accumulator] [Flags: NZ]
	bit $7803.w,X		; 3C 03 78 ; Test bits $7803.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	brk $F2.b		; 00 F2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc ($18.b),Y		; F1 18 ; Subtract with carry ($18.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FCFEFF.l,X		; FF FF FE FC ; Subtract with carry (long,X) $FCFEFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc [$E5.b],Y		; F7 E5 ; Subtract with carry (long indexed) [$E5.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $79.b		; C6 79 ; Decrement $79.b [Reads: Direct Page] [Flags: NZ]
	ora $8746DB.l		; 0F DB 46 87 ; OR accumulator with memory (long) $8746DB.l [Writes: Accumulator] [Flags: NZ]
	bit $09DE.w		; 2C DE 09 ; Test bits $09DE.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	sbc $BB93.w,X		; FD 93 BB ; Subtract with carry $BB93.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc [$F3.b]		; 67 F3 ; Add with carry (long) [$F3.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	eor $C0DF6F.l		; 4F 6F DF C0 ; Exclusive OR accumulator with memory (long) $C0DF6F.l [Writes: Accumulator] [Flags: NZ]
	ldy #$50.b		; A0 50 ; Load #$50.b into Y register [Writes: Y Index] [Flags: NZ]
	jsr $0023.w		; 20 23 00 ; Jump to subroutine at $0023.w [Writes: Stack Pointer] [Flow: call]
	ora ($BE.b,S),Y		; 13 BE ; OR accumulator (stack relative indirect indexed) ($BE.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $82, $7B, $38		; 82 7B 38 ; Branch always long to $82, $7B, $38 [Flow: branch]
	sbc $186642.l,X		; FF 42 66 18 ; Subtract with carry (long,X) $186642.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $3D.b,S		; 43 3D ; Exclusive OR accumulator with stack relative $3D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $42, $3D		; 42 3D ; Reserved instruction
	ror $19.b		; 66 19 ; Rotate right $19.b [Reads: Direct Page] [Flags: NCZ]
	ldx $7D80.w,Y		; BE 80 7D ; Load X register $7D80.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	dec $81.b		; C6 81 ; Decrement $81.b [Reads: Direct Page] [Flags: NZ]
	sta ($22.b,X)		; 81 22 ; Store accumulator ($22.b,X) [Reads: Direct Page, Accumulator, X Index]
	.db $80, $1E		; 80 1E ; Branch always to $80, $1E [Flow: branch]
	eor ($FF.b,X)		; 41 FF ; Exclusive OR accumulator with memory ($FF.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $64.b		; 00 64 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	rol $E5C0.w,X		; 3E C0 E5 ; Rotate left $E5C0.w,X [Reads: X Index] [Flags: NCZ]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor $26.b,S		; 43 26 ; Exclusive OR accumulator with stack relative $26.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($35.b,S),Y		; 33 35 ; AND accumulator (stack relative indirect indexed) ($35.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $42, $4B		; 42 4B ; Reserved instruction
	.db $B0, $FF		; B0 FF ; Branch if carry set to $B0, $FF [Flow: branch]
	cpx $21.b		; E4 21 ; Compare $21.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	ldy $8CCC.w,X		; BC CC 8C ; Load Y register $8CCC.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	tsb $A1.b		; 04 A1 ; Test and set bits $A1.b [Reads: Accumulator] [Flags: Z]
	sta ($7E.b,X)		; 81 7E ; Store accumulator ($7E.b,X) [Reads: Direct Page, Accumulator, X Index]
	jsr $4CF3.w		; 20 F3 4C ; Jump to subroutine at $4CF3.w [Writes: Stack Pointer] [Flow: call]
	eor $E1.b,S		; 43 E1 ; Exclusive OR accumulator with stack relative $E1.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lsr $B307.w,X		; 5E 07 B3 ; Logical shift right $B307.w,X [Reads: X Index] [Flags: NCZ]
	tsb $A0FF.w		; 0C FF A0 ; Test and set bits $A0FF.w [Reads: Accumulator] [Flags: Z]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	asl $C17E.w		; 0E 7E C1 ; Arithmetic shift left $C17E.w [Flags: NCZ]
	jsl $2CE080.l		; 22 80 E0 2C ; Jump to subroutine long $2CE080.l [Writes: Stack Pointer] [Flow: call]
	cpy #$40.b		; C0 40 ; Compare #$40.b with Y register [Reads: Y Index] [Flags: NCZ]
	lda ($98.b),Y		; B1 98 ; Load accumulator ($98.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($D1.b,X)		; 21 D1 ; Logical AND ($D1.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	inc $05.b,X		; F6 05 ; Increment memory $05.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	ldx #$45.b		; A2 45 ; Load #$45.b into X register [Writes: X Index] [Flags: NZ]
	lda ($40.b,X)		; A1 40 ; Load accumulator ($40.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	inc $00.b,X		; F6 00 ; Increment memory $00.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	lda $9B4E.w		; AD 4E 9B ; Load $9B4E.w into accumulator [Writes: Accumulator] [Flags: NZ]
	jmp $E8C4DE.l		; 5C DE C4 E8 ; Jump long to $E8C4DE.l [Flow: jump]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	stz $90CF.w,X		; 9E CF 90 ; Store zero to $90CF.w,X [Reads: X Index]
	ldy #$FF.b		; A0 FF ; Load #$FF.b into Y register [Writes: Y Index] [Flags: NZ]
	.db $80, $59		; 80 59 ; Branch always to $80, $59 [Flow: branch]
	brk $BF.b		; 00 BF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $1A		; 80 1A ; Branch always to $80, $1A [Flow: branch]
	ldx $18.b		; A6 18 ; Load $18.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	lda $BF11.w,X		; BD 11 BF ; Load $BF11.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ldx $DC07.w,Y		; BE 07 DC ; Load X register $DC07.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	adc $4062FF.l,X		; 7F FF 62 40 ; Add long $4062FF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $40.b,X		; 16 40 ; Arithmetic shift left $40.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	jsr $01FF.w		; 20 FF 01 ; Jump to subroutine at $01FF.w [Writes: Stack Pointer] [Flow: call]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($59.b,X)		; 01 59 ; Logical OR ($59.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	stz $BB.b		; 64 BB ; Store zero to $BB.b
	inc $9EF3.w,X		; FE F3 9E ; Increment memory $9EF3.w,X [Reads: X Index] [Flags: NZ]
	sbc $00FF0C.l,X		; FF 0C FF 00 ; Subtract with carry (long,X) $00FF0C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $02FF.w,X		; FE FF 02 ; Increment memory $02FF.w,X [Reads: X Index] [Flags: NZ]
	.db $82, $23, $00		; 82 23 00 ; Branch always long to $82, $23, $00 [Flow: branch]
	sta $90.b		; 85 90 ; Store accumulator to $90.b [Reads: Accumulator]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $82, $BE, $98		; 82 BE 98 ; Branch always long to $82, $BE, $98 [Flow: branch]
	lda $C0C0.w,X		; BD C0 C0 ; Load $C0C0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FF7F00.l,X		; FF 00 7F FF ; Subtract with carry (long,X) $FF7F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $62, $40, $02		; 62 40 02 ; Push effective relative address $62, $40, $02 [Writes: Stack Pointer]
	and $850000.l,X		; 3F 00 00 85 ; AND accumulator with memory (long,X) $850000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($7D.b,X)		; 41 7D ; Exclusive OR accumulator with memory ($7D.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $03BD.w,Y		; 19 BD 03 ; OR accumulator with memory $03BD.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $83.b,S		; 03 83 ; OR accumulator with stack relative $83.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpy $8300.w		; CC 00 83 ; Compare $8300.w with Y register [Reads: Y Index] [Flags: NCZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $42, $FC		; 42 FC ; Reserved instruction
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $C5BE.w,X		; BD BE C5 ; Load $C5BE.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $A1.b		; 06 A1 ; Arithmetic shift left $A1.b [Reads: Direct Page] [Flags: NCZ]
	mvp $E9,$1A		; 44 1A E9 ; Move block positive $E9,$1A [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora [$A1.b]		; 07 A1 ; OR accumulator with memory (long) [$A1.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lda ($12.b),Y		; B1 12 ; Load accumulator ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($0A.b,X)		; E1 0A ; Subtract with carry ($0A.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sed		; F8 ; Set decimal flag [Flags: D]
	and $C4.b,S		; 23 C4 ; AND accumulator with stack relative $C4.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $CC.b		; 06 CC ; Arithmetic shift left $CC.b [Reads: Direct Page] [Flags: NCZ]
	pei ($E1.b)		; D4 E1 ; Push effective indirect address ($E1.b) [Reads: Direct Page] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lda ($12.b),Y		; B1 12 ; Load accumulator ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda ($44.b,X)		; A1 44 ; Load accumulator ($44.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sbc #$07.b		; E9 07 ; Subtract #$07.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	lda ($1A.b,X)		; A1 1A ; Load accumulator ($1A.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $06.b		; C5 06 ; Compare $06.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	lda $D4BE.w,X		; BD BE D4 ; Load $D4BE.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy $C423.w		; CC 23 C4 ; Compare $C423.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora [$F8.b]		; 07 F8 ; OR accumulator with memory (long) [$F8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sbc $00FFF8.l,X		; FF F8 FF 00 ; Subtract with carry (long,X) $00FFF8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sed		; F8 ; Set decimal flag [Flags: D]
	eor $7E.b,S		; 43 7E ; Exclusive OR accumulator with stack relative $7E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $7F43.w,X		; FE 43 7F ; Increment memory $7F43.w,X [Reads: X Index] [Flags: NZ]
	sbc $FE0106.l,X		; FF 06 01 FE ; Subtract with carry (long,X) $FE0106.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $00FF1F.l,X		; FF 1F FF 00 ; Subtract with carry (long,X) $00FF1F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$1F.b		; E0 1F ; Compare #$1F.b with X register [Reads: X Index] [Flags: NCZ]
	cmp $BF44.w,Y		; D9 44 BF ; Compare accumulator $BF44.w,Y [Reads: Y Index] [Flags: NCZ]
	cmp $9F6F03.l,X		; DF 03 6F 9F ; Compare accumulator (long,X) $9F6F03.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	.db $F0, $0F		; F0 0F ; Branch if equal to $F0, $0F [Flow: branch]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx #$29.b		; E0 29 ; Compare #$29.b with X register [Reads: X Index] [Flags: NCZ]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $FD.b,S		; 03 FD ; OR accumulator with stack relative $FD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	stx $F8.b		; 86 F8 ; Store X register to $F8.b [Reads: X Index]
	stx $F9F1.w		; 8E F1 F9 ; Store X register to $F9F1.w [Reads: X Index]
	asl $F3.b		; 06 F3 ; Arithmetic shift left $F3.b [Reads: Direct Page] [Flags: NCZ]
	sta $30.b,S		; 83 30 ; Store accumulator (stack relative) $30.b,S [Reads: Stack Pointer, Accumulator]
	cmp $F8EF10.l		; CF 10 EF F8 ; Compare accumulator (long) $F8EF10.l [Reads: Accumulator] [Flags: NCZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0000.w		; 0C 00 00 ; Test and set bits $0000.w [Reads: Accumulator] [Flags: Z]
	clv		; B8 ; Clear overflow flag [Flags: V]
	ldy #$7C.b		; A0 7C ; Load #$7C.b into Y register [Writes: Y Index] [Flags: NZ]
	adc ($9E.b,S),Y		; 73 9E ; Add with carry (stack relative indirect indexed) ($9E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F90E.w,Y		; F9 0E F9 ; Subtract with carry $F90E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $CBFB00.l,X		; FF 00 FB CB ; Subtract with carry (long,X) $CBFB00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $D7		; 30 D7 ; Branch if minus to $30, $D7 [Flow: branch]
	.db $30, $DF		; 30 DF ; Branch if minus to $30, $DF [Flow: branch]
	eor [$80.b]		; 47 80 ; Exclusive OR accumulator with memory (long) [$80.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $040100.l		; 22 00 01 04 ; Jump to subroutine long $040100.l [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	stx $BF.b		; 86 BF ; Store X register to $BF.b [Reads: X Index]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ldx $43.b		; A6 43 ; Load $43.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda $0205.w,X		; BD 05 02 ; Load $0205.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldx $5F98.w,Y		; BE 98 5F ; Load X register $5F98.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	adc $4062FF.l,X		; 7F FF 62 40 ; Add long $4062FF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($42.b,X)		; 01 42 ; Logical OR ($42.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor ($87.b,X)		; 41 87 ; Exclusive OR accumulator with memory ($87.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lda [$00.b]		; A7 00 ; Load accumulator (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	adc $19.b		; 65 19 ; Add $19.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda $BD18.w,X		; BD 18 BD ; Load $BD18.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	adc $FA19.w,X		; 7D 19 FA ; Add $FA19.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sty $E8.b		; 84 E8 ; Store Y register to $E8.b [Reads: Y Index]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $42, $82		; 42 82 ; Reserved instruction
	tsb $A1.b		; 04 A1 ; Test and set bits $A1.b [Reads: Accumulator] [Flags: Z]
	ldx $01C0.w,Y		; BE C0 01 ; Load X register $01C0.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ldy #$1E.b		; A0 1E ; Load #$1E.b into Y register [Writes: Y Index] [Flags: NZ]
	eor $FD.b,S		; 43 FD ; Exclusive OR accumulator with stack relative $FD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $1FA008.l		; 0F 08 A0 1F ; OR accumulator with memory (long) $1FA008.l [Writes: Accumulator] [Flags: NZ]
	lda ($13.b)		; B2 13 ; Load accumulator (indirect) ($13.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx #$0D.b		; E0 0D ; Compare #$0D.b with X register [Reads: X Index] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	inc $22C1.w,X		; FE C1 22 ; Increment memory $22C1.w,X [Reads: X Index] [Flags: NZ]
	cpy #$07.b		; C0 07 ; Compare #$07.b with Y register [Reads: Y Index] [Flags: NCZ]
	cpy $E0D2.w		; CC D2 E0 ; Compare $E0D2.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora $13B2.w		; 0D B2 13 ; Logical OR $13B2.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$1F.b		; A0 1F ; Load #$1F.b into Y register [Writes: Y Index] [Flags: NZ]
	eor $FD.b,S		; 43 FD ; Exclusive OR accumulator with stack relative $FD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $1EA007.l		; 0F 07 A0 1E ; OR accumulator with memory (long) $1EA007.l [Writes: Accumulator] [Flags: NZ]
	cpy #$01.b		; C0 01 ; Compare #$01.b with Y register [Reads: Y Index] [Flags: NCZ]
	lda $D2BE.w,Y		; B9 BE D2 ; Load $D2BE.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cpy $C022.w		; CC 22 C0 ; Compare $C022.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpx #$37.b		; E0 37 ; Compare #$37.b with X register [Reads: X Index] [Flags: NCZ]
	cmp ($FE.b,X)		; C1 FE ; Compare accumulator ($FE.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sbc $66BD00.l,X		; FF 00 BD 66 ; Subtract with carry (long,X) $66BD00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$7F.b		; C0 7F ; Compare #$7F.b with Y register [Reads: Y Index] [Flags: NCZ]
	jmp.w [$DF22]		; DC 22 DF ; Jump long indirect [$DF22] [Flow: jump]
	jsr $61DE.w		; 20 DE 61 ; Jump to subroutine at $61DE.w [Writes: Stack Pointer] [Flow: call]
	sta [$78.b],Y		; 97 78 ; Store accumulator (long indexed) [$78.b],Y [Reads: Direct Page, Y Index, Accumulator]
	wai		; CB ; Wait for interrupt
	bit $FF.b		; 24 FF ; Test bits $FF.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sta $C180.w,Y		; 99 80 C1 ; Store accumulator to $C180.w,Y [Reads: Y Index, Accumulator]
	cpy #$80.b		; C0 80 ; Compare #$80.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $80, $D0		; 80 D0 ; Branch always to $80, $D0 [Flow: branch]
	cpx #$01.b		; E0 01 ; Compare #$01.b with X register [Reads: X Index] [Flags: NCZ]
	inc $E701.w,X		; FE 01 E7 ; Increment memory $E701.w,X [Reads: X Index] [Flags: NZ]
	ora ($4F.b,X)		; 01 4F ; Logical OR ($4F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $1557.w		; 0D 57 15 ; Logical OR $1557.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $017F.w,Y		; 19 7F 01 ; OR accumulator with memory $017F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	rol $FEFE.w,X		; 3E FE FE ; Rotate left $FEFE.w,X [Reads: X Index] [Flags: NCZ]
	cpx #$F8.b		; E0 F8 ; Compare #$F8.b with X register [Reads: X Index] [Flags: NCZ]
	.db $B0, $A8		; B0 A8 ; Branch if carry set to $B0, $A8 [Flow: branch]
	sty $80.b		; 84 80 ; Store Y register to $80.b [Reads: Y Index]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $8000FF.l		; 0F FF 00 80 ; OR accumulator with memory (long) $8000FF.l [Writes: Accumulator] [Flags: NZ]
	mvp $CF,$7F		; 44 7F CF ; Move block positive $CF,$7F [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $FE.b		; 05 FE ; Logical OR $FE.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $007FFC.l,X		; 7F FC 7F 00 ; Add long $007FFC.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $0F0027.l,X		; FF 27 00 0F ; Subtract with carry (long,X) $0F0027.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $00FFF0.l,X		; FF F0 FF 00 ; Subtract with carry (long,X) $00FFF0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $DEFE.w		; 8C FE DE ; Store Y register to $DEFE.w [Reads: Y Index]
	inc $FE7E.w,X		; FE 7E FE ; Increment memory $FE7E.w,X [Reads: X Index] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $227F80.l,X		; FF 80 7F 22 ; Subtract with carry (long,X) $227F80.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($12.b,X)		; 01 12 ; Logical OR ($12.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
.ACCU 16
	rep #$23		; C2 23
	dec $DC3F.w		; CE 3F DC ; Decrement $DC3F.w [Flags: NZ]
	and $CE3FDE.l,X		; 3F DE 3F CE ; AND accumulator with memory (long,X) $CE3FDE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $CCBFC6.l,X		; 3F C6 BF CC ; AND accumulator with memory (long,X) $CCBFC6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda $1CBED9.l,X		; BF D9 BE 1C ; Load long $1CBED9.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	cop $D8.b		; 02 D8 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $BF43DC.l,X		; BF DC 43 BF ; Load long $BF43DC.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dec $3F44.w,X		; DE 44 3F ; Decrement memory $3F44.w,X [Reads: X Index] [Flags: NZ]
	dec $03.b		; C6 03 ; Decrement $03.b [Reads: Direct Page] [Flags: NZ]
	dec $FE3F.w,X		; DE 3F FE ; Decrement memory $FE3F.w,X [Reads: X Index] [Flags: NZ]
	ora ($27.b,X)		; 01 27 ; Logical OR ($27.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$EE.b]		; 27 EE ; AND accumulator with memory (long) [$EE.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $B83ED0.l,X		; 9F D0 3E B8 ; Store accumulator (long,X) $B83ED0.l,X [Reads: Accumulator, X Index]
	ora $CB50.w,X		; 1D 50 CB ; OR accumulator with memory $CB50.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$F7.b		; E0 F7 ; Compare #$F7.b with X register [Reads: X Index] [Flags: NCZ]
	cmp $EC.b,S		; C3 EC ; Compare accumulator (stack relative) $EC.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	sta [$D9.b]		; 87 D9 ; Store accumulator (long) [$D9.b] [Reads: Direct Page, Accumulator]
	tsb $BB.b		; 04 BB ; Test and set bits $BB.b [Reads: Accumulator] [Flags: Z]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $42, $24		; 42 24 ; Reserved instruction
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sty $9BF3.w		; 8C F3 9B ; Store Y register to $9BF3.w [Reads: Y Index]
	jmp ($9C73.w)		; 6C 73 9C ; Jump indirect to ($9C73.w) [Flow: jump]
	ror $B9.b		; 66 B9 ; Rotate right $B9.b [Reads: Direct Page] [Flags: NCZ]
	cpy $9873.w		; CC 73 98 ; Compare $9873.w with Y register [Reads: Y Index] [Flags: NCZ]
	sbc [$30.b]		; E7 30 ; Subtract with carry (long) [$30.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp $229F61.l		; CF 61 9F 22 ; Compare accumulator (long) $229F61.l [Reads: Accumulator] [Flags: NCZ]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $40BF.w,X		; 1E BF 40 ; Arithmetic shift left $40BF.w,X [Reads: X Index] [Flags: NCZ]
	nop		; EA ; No operation
	trb $DD.b		; 14 DD ; Test and reset bits $DD.b [Reads: Accumulator] [Flags: Z]
	jsr $51AB.w		; 20 AB 51 ; Jump to subroutine at $51AB.w [Writes: Stack Pointer] [Flow: call]
	sbc [$03.b],Y		; F7 03 ; Subtract with carry (long indexed) [$03.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $0FDF47.l		; AF 47 DF 0F ; Load long $0FDF47.l into accumulator [Writes: Accumulator] [Flags: NZ]
	ldx $221F.w,Y		; BE 1F 22 ; Load X register $221F.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	brk $84.b		; 00 84 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	cop $E0.b		; 02 E0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$FF.b]		; 27 FF ; AND accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $0F.b		; 04 0F ; Test and set bits $0F.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	inc $FC00.w,X		; FE 00 FC ; Increment memory $FC00.w,X [Reads: X Index] [Flags: NZ]
	cpy #$F8.b		; C0 F8 ; Compare #$F8.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $80, $FC		; 80 FC ; Branch always to $80, $FC [Flow: branch]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F9.b		; 00 F9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($07.b,S),Y		; F3 07 ; Subtract with carry (stack relative indirect indexed) ($07.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cmp $F3039F.l		; CF 9F 03 F3 ; Compare accumulator (long) $F3039F.l [Reads: Accumulator] [Flags: NCZ]
	ora $FF.b,S		; 03 FF ; OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $C7.b		; 00 C7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	ldy #$5F.b		; A0 5F ; Load #$5F.b into Y register [Writes: Y Index] [Flags: NZ]
	sta [$6F.b],Y		; 97 6F ; Store accumulator (long indexed) [$6F.b],Y [Reads: Direct Page, Y Index, Accumulator]
	sta $3BDD77.l		; 8F 77 DD 3B ; Store accumulator (long) $3BDD77.l [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	and $3FDC.w,X		; 3D DC 3F ; AND accumulator with memory $3FDC.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $3FDC.w,Y		; 19 DC 3F ; OR accumulator with memory $3FDC.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	stz $0E5F.w		; 9C 5F 0E ; Store zero to $0E5F.w
	sta $F6CFCC.l		; 8F CC CF F6 ; Store accumulator (long) $F6CFCC.l [Reads: Accumulator]
	sbc [$FA.b],Y		; F7 FA ; Subtract with carry (long indexed) [$FA.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	bit $FD.b,X		; 34 FD ; Test bits $FD.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora ($FE.b,X)		; 01 FE ; Logical OR ($FE.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $30		; 70 30 ; Branch if overflow set to $70, $30 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $01B283.l,X		; BF 83 B2 01 ; Load long $01B283.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $0FFC.w		; 0C FC 0F ; Test and set bits $0FFC.w [Reads: Accumulator] [Flags: Z]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	ora $B31FA1.l		; 0F A1 1F B3 ; OR accumulator with memory (long) $B31FA1.l [Writes: Accumulator] [Flags: NZ]
	asl $E7.b,X		; 16 E7 ; Arithmetic shift left $E7.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tsb $FE40.w		; 0C 40 FE ; Test and set bits $FE40.w [Reads: Accumulator] [Flags: Z]
	cmp ($22.b,X)		; C1 22 ; Compare accumulator ($22.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	cpy #$07.b		; C0 07 ; Compare #$07.b with Y register [Reads: Y Index] [Flags: NCZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $D0, $EF		; D0 EF ; Branch if not equal to $D0, $EF [Flow: branch]
	brk $BF.b		; 00 BF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda [$1C.b]		; A7 1C ; Load accumulator (long) [$1C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $F3.b,S		; 43 F3 ; Exclusive OR accumulator with stack relative $F3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $A306.w		; 0E 06 A3 ; Arithmetic shift left $A306.w [Flags: NCZ]
	asl $0CCF.w,X		; 1E CF 0C ; Arithmetic shift left $0CCF.w,X [Reads: X Index] [Flags: NCZ]
	lda [$B8.b]		; A7 B8 ; Load accumulator (long) [$B8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $24		; D0 24 ; Branch if not equal to $D0, $24 [Flow: branch]
	cpy #$03.b		; C0 03 ; Compare #$03.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $F0, $40		; F0 40 ; Branch if equal to $F0, $40 [Flow: branch]
	lda $0043BF.l,X		; BF BF 43 00 ; Load long $0043BF.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $EF100A.l,X		; FF 0A 10 EF ; Subtract with carry (long,X) $EF100A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $7FEF00.l,X		; FF 00 EF 7F ; Subtract with carry (long,X) $7FEF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$7F.b		; C0 7F ; Compare #$7F.b with Y register [Reads: Y Index] [Flags: NCZ]
	stx $79.b		; 86 79 ; Store X register to $79.b [Reads: X Index]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	.db $10, $3D		; 10 3D ; Branch if plus to $10, $3D [Flow: branch]
	lda $67D8.w,X		; BD D8 67 ; Load $67D8.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $6F		; D0 6F ; Branch if not equal to $D0, $6F [Flow: branch]
	cpy #$7F.b		; C0 7F ; Compare #$7F.b with Y register [Reads: Y Index] [Flags: NCZ]
	sbc $FFFF00.l,X		; FF 00 FF FF ; Subtract with carry (long,X) $FFFF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc [$0C.b],Y		; F7 0C ; Subtract with carry (long indexed) [$0C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($42.b,S),Y		; F3 42 ; Subtract with carry (stack relative indirect indexed) ($42.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	eor $0C.b,S		; 43 0C ; Exclusive OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc [$0F.b],Y		; 77 0F ; Add with carry (long indexed) [$0F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sty $8DF7.w		; 8C F7 8D ; Store Y register to $8DF7.w [Reads: Y Index]
	inc $0D.b,X		; F6 0D ; Increment memory $0D.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	ror $0C.b,X		; 76 0C ; Rotate right $0C.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	adc [$EC.b],Y		; 77 EC ; Add with carry (long indexed) [$EC.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$7C.b],Y		; F7 7C ; Subtract with carry (long indexed) [$7C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta [$80.b]		; 87 80 ; Store accumulator (long) [$80.b] [Reads: Direct Page, Accumulator]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $03		; 70 03 ; Branch if overflow set to $70, $03 [Flow: branch]
	ora [$9C.b]		; 07 9C ; OR accumulator with memory (long) [$9C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc [$0C.b]		; E7 0C ; Subtract with carry (long) [$0C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc [$0D.b],Y		; 77 0D ; Add with carry (long indexed) [$0D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $8D.b,X		; 76 8D ; Rotate right $8D.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	inc $43.b,X		; F6 43 ; Increment memory $43.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	stz $06E7.w		; 9C E7 06 ; Store zero to $06E7.w
	stx $8BF7.w		; 8E F7 8B ; Store X register to $8BF7.w [Reads: X Index]
	pea $8000.w		; F4 00 80 ; Push absolute address $8000.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	.db $80, $24		; 80 24 ; Branch always to $80, $24 [Flow: branch]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $C8D9.w,Y		; D9 D9 C8 ; Compare accumulator $C8D9.w,Y [Reads: Y Index] [Flags: NCZ]
	lda [$24.b],Y		; B7 24 ; Load accumulator (long indexed) [$24.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	.db $90, $EF		; 90 EF ; Branch if carry clear to $90, $EF [Flow: branch]
	ora $770F70.l		; 0F 70 0F 77 ; OR accumulator with memory (long) $770F70.l [Writes: Accumulator] [Flags: NZ]
	dec $8DB5.w		; CE B5 8D ; Decrement $8DB5.w [Flags: NZ]
	inc $26.b,X		; F6 26 ; Increment memory $26.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	.db $80, $83		; 80 83 ; Branch always to $80, $83 [Flow: branch]
	lsr $0E03.w,X		; 5E 03 0E ; Logical shift right $0E03.w,X [Reads: X Index] [Flags: NCZ]
	jmp $2CF7.w		; 4C F7 2C ; Jump to $2CF7.w [Flow: jump]
	sbc [$1C.b],Y		; F7 1C ; Subtract with carry (long indexed) [$1C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$FC.b],Y		; F7 FC ; Subtract with carry (long indexed) [$FC.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $02FBF8.l		; 0F F8 FB 02 ; OR accumulator with memory (long) $02FBF8.l [Writes: Accumulator] [Flags: NZ]
	sbc $80FF01.l,X		; FF 01 FF 80 ; Subtract with carry (long,X) $80FF01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $A312B1.l		; 0F B1 12 A3 ; OR accumulator with memory (long) $A312B1.l [Writes: Accumulator] [Flags: NZ]
	trb $FB43.w		; 1C 43 FB ; Test and reset bits $FB43.w [Reads: Accumulator] [Flags: Z]
	ora $A307.w		; 0D 07 A3 ; Logical OR $A307.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0DCA.w,X		; 1D CA 0D ; OR accumulator with memory $0DCA.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ldy $CCD0.w,X		; BC D0 CC ; Load Y register $CCD0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	and $C0.b,S		; 23 C0 ; AND accumulator with stack relative $C0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $40F0.w		; 0C F0 40 ; Test and set bits $40F0.w [Reads: Accumulator] [Flags: Z]
	asl $1C12.w		; 0E 12 1C ; Arithmetic shift left $1C12.w [Flags: NCZ]
	sbc ($0E.b,S),Y		; F3 0E ; Subtract with carry (stack relative indirect indexed) ($0E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($0F.b),Y		; F1 0F ; Subtract with carry ($0F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $FF		; F0 FF ; Branch if equal to $F0, $FF [Flow: branch]
	tsb $FF.b		; 04 FF ; Test and set bits $FF.b [Reads: Accumulator] [Flags: Z]
	eor $FC.b,S		; 43 FC ; Exclusive OR accumulator with stack relative $FC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc ($26.b,X)		; E1 26 ; Subtract with carry ($26.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $45.b		; 00 45 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0977.w		; 0C 77 09 ; Test and set bits $0977.w [Reads: Accumulator] [Flags: Z]
	jmp $FCF7.w		; 4C F7 FC ; Jump to $FCF7.w [Flow: jump]
	ora [$FF.b]		; 07 FF ; OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $C0BF.w		; 0E BF C0 ; Arithmetic shift left $C0BF.w [Flags: NCZ]
	ora $802260.l,X		; 1F 60 22 80 ; Logical OR long $802260.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$80.b],Y		; 17 80 ; OR accumulator with memory (long indexed) [$80.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $8B0E.w,X		; FD 0E 8B ; Subtract with carry $8B0E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $A7.b,X		; 75 A7 ; Add $A7.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	sta $AFDF67.l,X		; 9F 67 DF AF ; Store accumulator (long,X) $AFDF67.l,X [Reads: Accumulator, X Index]
	lda $BF7FDF.l,X		; BF DF 7F BF ; Load long $BF7FDF.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $740E7F.l,X		; FF 7F 0E 74 ; Subtract with carry (long,X) $740E7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ldy #$C0.b		; A0 C0 ; Load #$C0.b into Y register [Writes: Y Index] [Flags: NZ]
	.db $80, $45		; 80 45 ; Branch always to $80, $45 [Flow: branch]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $E3.b		; 02 E3 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $DD.b,S		; E3 DD ; Subtract stack-relative $DD.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	eor $EB.b,S		; 43 EB ; Exclusive OR accumulator with stack relative $EB.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $02.b,X		; D5 02 ; Compare accumulator $02.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc $FF.b,S		; E3 FF ; Subtract stack-relative $FF.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	jsl $E31100.l		; 22 00 11 E3 ; Jump to subroutine long $E31100.l [Writes: Stack Pointer] [Flow: call]
	cmp $D5D5.w,X		; DD D5 D5 ; Compare accumulator $D5D5.w,X [Reads: X Index] [Flags: NCZ]
	sbc [$00.b],Y		; F7 00 ; Subtract with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FD3E.w,X		; FD 3E FD ; Subtract with carry $FD3E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $EF1CE1.l		; 22 E1 1C EF ; Jump to subroutine long $EF1CE1.l [Writes: Stack Pointer] [Flow: call]
	.db $10, $E1		; 10 E1 ; Branch if plus to $10, $E1 [Flow: branch]
	trb $22FD.w		; 1C FD 22 ; Test and reset bits $22FD.w [Reads: Accumulator] [Flags: Z]
	eor $FD.b,S		; 43 FD ; Exclusive OR accumulator with stack relative $FD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $3E07.w,X		; 3E 07 3E ; Rotate left $3E07.w,X [Reads: X Index] [Flags: NCZ]
	jsl $1E101E.l		; 22 1E 10 1E ; Jump to subroutine long $1E101E.l [Writes: Stack Pointer] [Flow: call]
	jsl $443E3E.l		; 22 3E 3E 44 ; Jump to subroutine long $443E3E.l [Writes: Stack Pointer] [Flow: call]
	sbc $1F0000.l,X		; FF 00 00 1F ; Subtract with carry (long,X) $1F0000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $FF.b		; 45 FF ; Exclusive OR $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $3DFC06.l,X		; 3F 06 FC 3D ; AND accumulator with memory (long,X) $3DFC06.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $003E.w,X		; FD 3E 00 ; Subtract with carry $003E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $3F.b,S		; 23 3F ; AND accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $3E.b		; 45 3E ; Exclusive OR $3E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $FE03.w,X		; FD 03 FE ; Subtract with carry $FE03.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FE.b		; E5 FE ; Subtract $FE.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc #$F662.w		; E9 62 F6 ; Subtract #$F662.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	asl $F807.w,X		; 1E 07 F8 ; Arithmetic shift left $F807.w,X [Reads: X Index] [Flags: NCZ]
	sbc $3E3E00.l,X		; FF 00 3E 3E ; Subtract with carry (long,X) $3E3E00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $F6FE.w,X		; FE FE F6 ; Increment memory $F6FE.w,X [Reads: X Index] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $1CC10C.l,X		; FF 0C C1 1C ; Subtract with carry (long,X) $1CC10C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	stz $A13F.w		; 9C 3F A1 ; Store zero to $A13F.w
	and ($8C.b,S),Y		; 33 8C ; AND accumulator (stack relative indirect indexed) ($8C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($9E.b,X)		; 21 9E ; Logical AND ($9E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and ($8C.b,S),Y		; 33 8C ; AND accumulator (stack relative indirect indexed) ($8C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $3E0080.l,X		; 1F 80 00 3E ; Logical OR long $3E0080.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $23.b,S		; 63 23 ; Add with carry (stack relative) $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cpx #$20.b		; E0 20 ; Compare #$20.b with X register [Reads: X Index] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $00C0.w		; 20 C0 00 ; Jump to subroutine at $00C0.w [Writes: Stack Pointer] [Flow: call]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	asl $65C0.w,X		; 1E C0 65 ; Arithmetic shift left $65C0.w,X [Reads: X Index] [Flags: NCZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and ($31.b,S),Y		; 33 31 ; AND accumulator (stack relative indirect indexed) ($31.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $42, $4B		; 42 4B ; Reserved instruction
	.db $B0, $00		; B0 00 ; Branch if carry set to $B0, $00 [Flow: branch]
	and $9A21E4.l,X		; 3F E4 21 9A ; AND accumulator with memory (long,X) $9A21E4.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy $048C.w		; CC 8C 04 ; Compare $048C.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $3B90.w,X		; 1E 90 3B ; Arithmetic shift left $3B90.w,X [Reads: X Index] [Flags: NCZ]
	ldy $43.b		; A4 43 ; Load $43.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	adc ($AE.b),Y		; 71 AE ; Add with carry ($AE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $1B.b		; 06 1B ; Arithmetic shift left $1B.b [Reads: Direct Page] [Flags: NCZ]
	sty $1F.b		; 84 1F ; Store Y register to $1F.b [Reads: Y Index]
	.db $D0, $00		; D0 00 ; Branch if not equal to $D0, $00 [Flow: branch]
	and $402261.l,X		; 3F 61 22 40 ; AND accumulator with memory (long,X) $402261.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $2060.w,Y		; 19 60 20 ; OR accumulator with memory $2060.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $D1.b		; 00 D1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$4ED2.w		; 09 D2 4E ; Logical OR #$4ED2.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $12.b		; 85 12 ; Store accumulator to $12.b [Reads: Accumulator]
	lda $11.b		; A5 11 ; Load $11.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy #$18.b		; A0 18 ; Load #$18.b into Y register [Writes: Y Index] [Flags: NZ]
	.db $80, $15		; 80 15 ; Branch always to $80, $15 [Flow: branch]
	ldx $0B.b		; A6 0B ; Load $0B.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	ldy $242E.w		; AC 2E 24 ; Load $242E.w into Y register [Writes: Y Index] [Flags: NZ]
	.db $70, $48		; 70 48 ; Branch if overflow set to $70, $48 [Flow: branch]
	lsr $4867.w		; 4E 67 48 ; Logical shift right $4867.w [Flags: NCZ]
	.db $50, $87		; 50 87 ; Branch if overflow clear to $50, $87 [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	lda $3FBF00.l,X		; BF 00 BF 3F ; Load long $3FBF00.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$7D.b		; C0 7D ; Compare #$7D.b with Y register [Reads: Y Index] [Flags: NCZ]
	stz $B883.w,X		; 9E 83 B8 ; Store zero to $B883.w,X [Reads: X Index]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $C02000.l,X		; FF 00 20 C0 ; Subtract with carry (long,X) $C02000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $139F88.l		; 4F 88 9F 13 ; Exclusive OR accumulator with memory (long) $139F88.l [Writes: Accumulator] [Flags: NZ]
	lda $20BF27.l,X		; BF 27 BF 20 ; Load long $20BF27.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $1E.b,S		; 83 1E ; Store accumulator (stack relative) $1E.b,S [Reads: Stack Pointer, Accumulator]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	ora $63301F.l		; 0F 1F 30 63 ; OR accumulator with memory (long) $63301F.l [Writes: Accumulator] [Flags: NZ]
	eor [$40.b]		; 47 40 ; Exclusive OR accumulator with memory (long) [$40.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $1D.b,S		; 83 1D ; Store accumulator (stack relative) $1D.b,S [Reads: Stack Pointer, Accumulator]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $43.b		; 04 43 ; Test and set bits $43.b [Reads: Accumulator] [Flags: Z]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $C0		; 10 C0 ; Branch if plus to $10, $C0 [Flow: branch]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ora $DF.b,S		; 03 DF ; OR accumulator with stack relative $DF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $01F307.l		; CF 07 F3 01 ; Compare accumulator (long) $01F307.l [Reads: Accumulator] [Flags: NCZ]
	sta [$B8.b],Y		; 97 B8 ; Store accumulator (long indexed) [$B8.b],Y [Reads: Direct Page, Y Index, Accumulator]
	cop $09.b		; 02 09 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $20C010.l		; EF 10 C0 20 ; Subtract with carry (long) $20C010.l [Writes: Accumulator] [Flags: NCVZ]
	sta $179FC8.l		; 8F C8 9F 17 ; Store accumulator (long) $179FC8.l [Reads: Accumulator]
	lda $02852F.l,X		; BF 2F 85 02 ; Load long $02852F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $6730DF.l		; EF DF 30 67 ; Subtract with carry (long) $6730DF.l [Writes: Accumulator] [Flags: NCVZ]
	eor $050D85.l		; 4F 85 0D 05 ; Exclusive OR accumulator with memory (long) $050D85.l [Writes: Accumulator] [Flags: NZ]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr ($1791.w,X)		; FC 91 17 ; Jump to subroutine indirect indexed ($1791.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0300FF.l,X		; 1F FF 00 03 ; Logical OR long $0300FF.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsr ($F8F6.w,X)		; FC F6 F8 ; Jump to subroutine indirect indexed ($F8F6.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	eor $FD.b,S		; 43 FD ; Exclusive OR accumulator with stack relative $FD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc ($03.b),Y		; F1 03 ; Subtract with carry ($03.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F30CF3.l		; EF F3 0C F3 ; Subtract with carry (long) $F30CF3.l [Writes: Accumulator] [Flags: NCVZ]
	jsl $010400.l		; 22 00 04 01 ; Jump to subroutine long $010400.l [Writes: Stack Pointer] [Flow: call]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $DE.b		; 45 DE ; Exclusive OR $DE.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $BFDC09.l,X		; 3F 09 DC BF ; AND accumulator with memory (long,X) $BFDC09.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $A0DFB0.l		; CF B0 DF A0 ; Compare accumulator (long) $A0DFB0.l [Reads: Accumulator] [Flags: NCZ]
	sbc ($83.b)		; F2 83 ; Subtract with carry (indirect) ($83.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inc $258F.w		; EE 8F 25 ; Increment $258F.w [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $C010.w		; 0C 10 C0 ; Test and set bits $C010.w [Reads: Accumulator] [Flags: Z]
	mvp $DE,$BF		; 44 BF DE ; Move block positive $DE,$BF [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	eor $FE.b,S		; 43 FE ; Exclusive OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $1FDE43.l,X		; BF 43 DE 1F ; Load long $1FDE43.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($C7.b,X)		; 01 C7 ; Logical OR ($C7.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $24.b		; 06 24 ; Arithmetic shift left $24.b [Reads: Direct Page] [Flags: NCZ]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $3820.w		; 20 20 38 ; Jump to subroutine at $3820.w [Writes: Stack Pointer] [Flow: call]
	sbc $FF1E.w,X		; FD 1E FF ; Subtract with carry $FF1E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $E3.b		; 00 E3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $BEDD.w		; 1C DD BE ; Test and reset bits $BEDD.w [Reads: Accumulator] [Flags: Z]
	dec $BF44.w,X		; DE 44 BF ; Decrement memory $BF44.w,X [Reads: X Index] [Flags: NZ]
	dec $DE01.w		; CE 01 DE ; Decrement $DE01.w [Flags: NZ]
	lda $0F0027.l,X		; BF 27 00 0F ; Load long $0F0027.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $0C77.w		; 0C 77 0C ; Test and set bits $0C77.w [Reads: Accumulator] [Flags: Z]
	adc ($0E.b,S),Y		; 73 0E ; Add with carry (stack relative indirect indexed) ($0E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	adc ($0F.b),Y		; 71 0F ; Add with carry ($0F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $18		; 70 18 ; Branch if overflow set to $70, $18 [Flow: branch]
	adc $30.b,S		; 63 30 ; Add with carry (stack relative) $30.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	wai		; CB ; Wait for interrupt
	pea $CC0F.w		; F4 0F CC ; Push absolute address $CC0F.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	eor [$23.b],Y		; 57 23 ; Exclusive OR accumulator with memory (long indexed) [$23.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $80, $1B		; 80 1B ; Branch always to $80, $1B [Flow: branch]
	sty $04.b		; 84 04 ; Store Y register to $04.b [Reads: Y Index]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $4CB7.w		; AC B7 4C ; Load $4CB7.w into Y register [Writes: Y Index] [Flags: NZ]
	adc [$CF.b],Y		; 77 CF ; Add with carry (long indexed) [$CF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $EF		; F0 EF ; Branch if equal to $F0, $EF [Flow: branch]
	adc ($FC.b,S),Y		; 73 FC ; Add with carry (stack relative indirect indexed) ($FC.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	and $78.b,X		; 35 78 ; Logical AND $78.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $3C.b,S		; 03 3C ; OR accumulator with stack relative $3C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor [$0C.b]		; 47 0C ; Exclusive OR accumulator with memory (long) [$0C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc [$40.b],Y		; 77 40 ; Add with carry (long indexed) [$40.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $80.b		; 84 80 ; Store Y register to $80.b [Reads: Y Index]
	.db $80, $FF		; 80 FF ; Branch always to $80, $FF [Flow: branch]
	ora ($DE.b),Y		; 11 DE ; OR accumulator with memory ($DE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $A3.b		; 00 A3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $41.b		; 00 41 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1B.b,S		; 03 1B ; OR accumulator with stack relative $1B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $3F1F31.l		; 0F 31 1F 3F ; OR accumulator with memory (long) $3F1F31.l [Writes: Accumulator] [Flags: NZ]
	adc $0DFF22.l,X		; 7F 22 FF 0D ; Add long $0DFF22.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($E0F0.w,X)		; FC F0 E0 ; Jump to subroutine indirect indexed ($E0F0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $30, $1F		; 30 1F ; Branch if minus to $30, $1F [Flow: branch]
	adc ($1D.b,S),Y		; 73 1D ; Add with carry (stack relative indirect indexed) ($1D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cmp ($1F.b)		; D2 1F ; Compare accumulator (indirect) ($1F.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	.db $10, $1F		; 10 1F ; Branch if plus to $10, $1F [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sbc $FF44F8.l		; EF F8 44 FF ; Subtract with carry (long) $FF44F8.l [Writes: Accumulator] [Flags: NCVZ]
	jsr ($E023.w,X)		; FC 23 E0 ; Jump to subroutine indirect indexed ($E023.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $2CE000.l		; 22 00 E0 2C ; Jump to subroutine long $2CE000.l [Writes: Stack Pointer] [Flow: call]
	sbc $038704.l,X		; FF 04 87 03 ; Subtract with carry (long,X) $038704.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $01.b,S		; 83 01 ; Store accumulator (stack relative) $01.b,S [Reads: Stack Pointer, Accumulator]
	cmp ($01.b,S),Y		; D3 01 ; Compare accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	adc [$03.b],Y		; 77 03 ; Add with carry (long indexed) [$03.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	sta $D5.b,S		; 83 D5 ; Store accumulator (stack relative) $D5.b,S [Reads: Stack Pointer, Accumulator]
	dec $CB.b		; C6 CB ; Decrement $CB.b [Reads: Direct Page] [Flags: NZ]
	cpy $FCF8.w		; CC F8 FC ; Compare $FCF8.w with Y register [Reads: Y Index] [Flags: NCZ]
	inc $FCFE.w,X		; FE FE FC ; Increment memory $FCFE.w,X [Reads: X Index] [Flags: NZ]
	jmp ($3038.w,X)		; 7C 38 30 ; Jump indirect indexed to ($3038.w,X) [Reads: X Index] [Flow: jump]
	cmp ($80.b,X)		; C1 80 ; Compare accumulator ($80.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	ldx #$00.b		; A2 00 ; Load #$00.b into X register [Writes: X Index] [Flags: NZ]
	lda $7201.w		; AD 01 72 ; Load $7201.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $8C.b,S		; 03 8C ; OR accumulator with stack relative $8C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $83FE71.l		; 8F 71 FE 83 ; Store accumulator (long) $83FE71.l [Reads: Accumulator]
	jmp ($00FF.w,X)		; 7C FF 00 ; Jump indirect indexed to ($00FF.w,X) [Reads: X Index] [Flow: jump]
	adc $FCFEFF.l,X		; 7F FF FE FC ; Add long $FCFEFF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $22		; 70 22 ; Branch if overflow set to $70, $22 [Flow: branch]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$07.b],Y		; F7 07 ; Subtract with carry (long indexed) [$07.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ora $8C.b,S		; 03 8C ; OR accumulator with stack relative $8C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $9E.b		; 00 9E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $85.b		; 00 85 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($CA.b,X)		; 01 CA ; Logical OR ($CA.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta $FD.b,S		; 83 FD ; Store accumulator (stack relative) $FD.b,S [Reads: Stack Pointer, Accumulator]
	lsr $7CFB.w		; 4E FB 7C ; Logical shift right $7CFB.w [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($FFFF.w,X)		; FC FF FF ; Jump to subroutine indirect indexed ($FFFF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $307C.w,X		; FE 7C 30 ; Increment memory $307C.w,X [Reads: X Index] [Flags: NZ]
	brk $EB.b		; 00 EB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $0695.w		; 8C 95 06 ; Store Y register to $0695.w [Reads: Y Index]
	adc $06.b,X		; 75 06 ; Add $06.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $06.b,X		; 15 06 ; OR accumulator with memory $06.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor $29.b,S		; 43 29 ; Exclusive OR accumulator with stack relative $29.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $5304.w		; 0E 04 53 ; Arithmetic shift left $5304.w [Flags: NCZ]
	trb $38A7.w		; 1C A7 38 ; Test and reset bits $38A7.w [Reads: Accumulator] [Flags: Z]
	.db $70, $22		; 70 22 ; Branch if overflow set to $70, $22 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora $F0.b,S		; 03 F0 ; OR accumulator with stack relative $F0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: NCZ]
	bit $0030.w		; 2C 30 00 ; Test bits $0030.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	jsl $2CF000.l		; 22 00 F0 2C ; Jump to subroutine long $2CF000.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	jsl $608300.l		; 22 00 83 60 ; Jump to subroutine long $608300.l [Writes: Stack Pointer] [Flow: call]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $8600.w,X		; BC 00 86 ; Load Y register $8600.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	brk $8D.b		; 00 8D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stx $0069.w		; 8E 69 00 ; Store X register to $0069.w [Reads: X Index]
	ora #$8EE9.w		; 09 E9 8E ; Logical OR #$8EE9.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sty $07.b,X		; 94 07 ; Store Y register $07.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	stz $07.b,X		; 74 07 ; Store zero to $07.b,X [Reads: X Index]
	trb $07.b		; 14 07 ; Test and reset bits $07.b [Reads: Accumulator] [Flags: Z]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	ora $008286.l		; 0F 86 82 00 ; OR accumulator with memory (long) $008286.l [Writes: Accumulator] [Flags: NZ]
	jsl $8C83F8.l		; 22 F8 83 8C ; Jump to subroutine long $8C83F8.l [Writes: Stack Pointer] [Flow: call]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $CB.b,X		; 34 CB ; Test bits $CB.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	sta $36D5.w,X		; 9D D5 36 ; Store accumulator to $36D5.w,X [Reads: Accumulator, X Index]
	cpy $37.b		; C4 37 ; Compare $37.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	cpy $C93F.w		; CC 3F C9 ; Compare $C93F.w with Y register [Reads: Y Index] [Flags: NCZ]
	rol $1CEB.w,X		; 3E EB 1C ; Rotate left $1CEB.w,X [Reads: X Index] [Flags: NCZ]
	jsr ($00C3.w,X)		; FC C3 00 ; Jump to subroutine indirect indexed ($00C3.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora #$EB14.w		; 09 14 EB ; Logical OR #$EB14.w with accumulator [Writes: Accumulator] [Flags: NZ]
	rol $EFC9.w		; 2E C9 EF ; Rotate left $EFC9.w [Flags: NCZ]
	bit $6EAD.w		; 2C AD 6E ; Test bits $6EAD.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	sta $437E.w,Y		; 99 7E 43 ; Store accumulator to $437E.w,Y [Reads: Y Index, Accumulator]
	cmp ($3E.b),Y		; D1 3E ; Compare accumulator ($3E.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cop $53.b		; 02 53 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $102200.l,X		; BF 00 22 10 ; Load long $102200.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx #$2C.b		; E0 2C ; Compare #$2C.b with X register [Reads: X Index] [Flags: NCZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	stz $28.b		; 64 28 ; Store zero to $28.b
	.db $30, $2D		; 30 2D ; Branch if minus to $30, $2D [Flow: branch]
	bit $6B.b,X		; 34 6B ; Test bits $6B.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and [$A9.b],Y		; 37 A9 ; AND accumulator with memory (long indexed) [$A9.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and [$68.b],Y		; 37 68 ; AND accumulator with memory (long indexed) [$68.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc [$CC.b],Y		; 77 CC ; Add with carry (long indexed) [$CC.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($9F.b,S),Y		; F3 9F ; Subtract with carry (stack relative indirect indexed) ($9F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$83.b		; E0 83 ; Compare #$83.b with X register [Reads: X Index] [Flags: NCZ]
	cmp [$C3.b]		; C7 C3 ; Compare accumulator (long) [$C3.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp $7C6050.l		; 5C 50 60 7C ; Jump long to $7C6050.l [Flow: jump]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sty $EC.b,X		; 94 EC ; Store Y register $EC.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	ora ($EF.b,S),Y		; 13 EF ; OR accumulator (stack relative indirect indexed) ($EF.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $FCC7.w,Y		; 39 C7 FC ; AND accumulator with memory $FCC7.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $83.b,S		; 03 83 ; OR accumulator with stack relative $83.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $030787.l		; 8F 87 07 03 ; Store accumulator (long) $030787.l [Reads: Accumulator]
	jsl $FE0F00.l		; 22 00 0F FE ; Jump to subroutine long $FE0F00.l [Writes: Stack Pointer] [Flow: call]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A1.b		; 00 A1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E2.b		; 00 E2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $6F.b		; 00 6F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $BA.b,S		; 03 BA ; OR accumulator with stack relative $BA.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $D4.b,S		; 83 D4 ; Store accumulator (stack relative) $D4.b,S [Reads: Stack Pointer, Accumulator]
	cmp [$C8.b]		; C7 C8 ; Compare accumulator (long) [$C8.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp $83FF23.l		; CF 23 FF 83 ; Compare accumulator (long) $83FF23.l [Reads: Accumulator] [Flags: NCZ]
	mvp $13,$00		; 44 00 13 ; Move block positive $13,$00 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	lda $645DC2.l,X		; BF C2 5D 64 ; Load long $645DC2.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	stx $F6.b,Y		; 96 F6 ; Store X register $F6.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	ora $BF4FFF.l		; 0F FF 4F BF ; OR accumulator with memory (long) $BF4FFF.l [Writes: Accumulator] [Flags: NZ]
	eor $0EFF.w		; 4D FF 0E ; Exclusive OR $0EFF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $858301.l,X		; FF 01 83 85 ; Subtract with carry (long,X) $858301.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora #$0023.w		; 09 23 00 ; Logical OR #$0023.w with accumulator [Writes: Accumulator] [Flags: NZ]
	bit #$00F0.w		; 89 F0 00 ; Test bits #$00F0.w with accumulator [Reads: Accumulator] [Flags: Z]
	ora $8A.b		; 05 8A ; Logical OR $8A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $9C.b,S		; 03 9C ; OR accumulator with stack relative $9C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $840F28.l		; 0F 28 0F 84 ; OR accumulator with memory (long) $840F28.l [Writes: Accumulator] [Flags: NZ]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	ora ($FC.b,S),Y		; 13 FC ; OR accumulator (stack relative indirect indexed) ($FC.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	.db $90, $9F		; 90 9F ; Branch if carry clear to $90, $9F [Flow: branch]
	inc $7B.b		; E6 7B ; Increment $7B.b [Reads: Direct Page] [Flags: NZ]
	cpx #$3F.b		; E0 3F ; Compare #$3F.b with X register [Reads: X Index] [Flags: NCZ]
	.db $F0, $1F		; F0 1F ; Branch if equal to $F0, $1F [Flow: branch]
	sbc $5FDF2F.l		; EF 2F DF 5F ; Subtract with carry (long) $5FDF2F.l [Writes: Accumulator] [Flags: NCVZ]
	lda $CEBF.w,X		; BD BF CE ; Load $CEBF.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $002260.l		; 0F 60 22 00 ; OR accumulator with memory (long) $002260.l [Writes: Accumulator] [Flags: NZ]
	cpx #$27.b		; E0 27 ; Compare #$27.b with X register [Reads: X Index] [Flags: NCZ]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $F0, $FF		; F0 FF ; Branch if equal to $F0, $FF [Flow: branch]
	ora $C220E0.l,X		; 1F E0 20 C2 ; Logical OR long $C220E0.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $82, $80, $86		; 82 80 86 ; Branch always long to $82, $80, $86 [Flow: branch]
	.db $80, $FD		; 80 FD ; Branch always to $80, $FD [Flow: branch]
	sta ($FB.b,X)		; 81 FB ; Store accumulator ($FB.b,X) [Reads: Direct Page, Accumulator, X Index]
	sta $87.b,S		; 83 87 ; Store accumulator (stack relative) $87.b,S [Reads: Stack Pointer, Accumulator]
	sta [$00.b]		; 87 00 ; Store accumulator (long) [$00.b] [Reads: Direct Page, Accumulator]
	ora $7F7F3F.l,X		; 1F 3F 7F 7F ; Logical OR long $7F7F3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ror $787C.w,X		; 7E 7C 78 ; Rotate right $787C.w,X [Reads: X Index] [Flags: NCZ]
	and [$07.b],Y		; 37 07 ; AND accumulator with memory (long indexed) [$07.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $98.b,S		; 03 98 ; OR accumulator with stack relative $98.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$6C.b]		; 07 6C ; OR accumulator with memory (long) [$6C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $439F98.l		; 0F 98 9F 43 ; OR accumulator with memory (long) $439F98.l [Writes: Accumulator] [Flags: NZ]
	.db $D0, $DF		; D0 DF ; Branch if not equal to $D0, $DF [Flow: branch]
	ora [$F8.b]		; 07 F8 ; OR accumulator with memory (long) [$F8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr ($F8FF.w,X)		; FC FF F8 ; Jump to subroutine indirect indexed ($F8FF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $F0, $60		; F0 60 ; Branch if equal to $F0, $60 [Flow: branch]
	jsr $4520.w		; 20 20 45 ; Jump to subroutine at $4520.w [Writes: Stack Pointer] [Flow: call]
	cpx #$EF.b		; E0 EF ; Compare #$EF.b with X register [Reads: X Index] [Flags: NCZ]
	ora #$EFE2.w		; 09 E2 EF ; Logical OR #$EFE2.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $FF		; F0 FF ; Branch if equal to $F0, $FF [Flow: branch]
	cpx #$FF.b		; E0 FF ; Compare #$FF.b with X register [Reads: X Index] [Flags: NCZ]
	cmp $FC.b,S		; C3 FC ; Compare accumulator (stack relative) $FC.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	ora [$FB.b]		; 07 FB ; OR accumulator with memory (long) [$FB.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $10.b,S		; 23 10 ; AND accumulator with stack relative $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($0D.b),Y		; 11 0D ; OR accumulator with memory ($0D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $9E6E.w,X		; FD 6E 9E ; Subtract with carry $9E6E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $FF4FBF.l		; 6F BF 4F FF ; Add with carry (long) $FF4FBF.l [Writes: Accumulator] [Flags: NCVZ]
	ora [$FF.b]		; 07 FF ; OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $FB.b,S		; 03 FB ; OR accumulator with stack relative $FB.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc ($11.b,X)		; E1 11 ; Subtract with carry ($11.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $02		; F0 02 ; Branch if equal to $F0, $02 [Flow: branch]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0E.b		; 04 0E ; Test and set bits $0E.b [Reads: Accumulator] [Flags: Z]
	ora $FFFE45.l		; 0F 45 FE FF ; OR accumulator with memory (long) $FFFE45.l [Writes: Accumulator] [Flags: NZ]
	ora #$3F3C.w		; 09 3C 3F ; Logical OR #$3F3C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cmp $13FE01.l		; CF 01 FE 13 ; Compare accumulator (long) $13FE01.l [Reads: Accumulator] [Flags: NCZ]
	sbc $FD03.w,X		; FD 03 FD ; Subtract with carry $FD03.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $C00100.l		; 22 00 01 C0 ; Jump to subroutine long $C00100.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $22		; 30 22 ; Branch if minus to $30, $22 [Flow: branch]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $FD.b,S		; 03 FD ; OR accumulator with stack relative $FD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc ($9D.b,S),Y		; 73 9D ; Add with carry (stack relative indirect indexed) ($9D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	adc $BD.b,S		; 63 BD ; Add with carry (stack relative) $BD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc ($FC.b),Y		; F1 FC ; Subtract with carry ($FC.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	jmp ($BE7C.w,X)		; 7C 7C BE ; Jump indirect indexed to ($BE7C.w,X) [Reads: X Index] [Flow: jump]
	ldx $0023.w,Y		; BE 23 00 ; Load X register $0023.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	cpx #$2D.b		; E0 2D ; Compare #$2D.b with X register [Reads: X Index] [Flags: NCZ]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $41.b,S		; 83 41 ; Store accumulator (stack relative) $41.b,S [Reads: Stack Pointer, Accumulator]
	jsr ($3CFE.w,X)		; FC FE 3C ; Jump to subroutine indirect indexed ($3CFE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr ($C040.w,X)		; FC 40 C0 ; Jump to subroutine indirect indexed ($C040.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	eor $C100.w		; 4D 00 C1 ; Exclusive OR $C100.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($FD.b,X)		; 01 FD ; Logical OR ($FD.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta ($01.b,X)		; 81 01 ; Store accumulator ($01.b,X) [Reads: Direct Page, Accumulator, X Index]
	ora $3F.b,S		; 03 3F ; OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc [$FF.b],Y		; 77 FF ; Add with carry (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FD7EFE.l,X		; FF FE 7E FD ; Subtract with carry (long,X) $FD7EFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FE9E.w,X		; FD 9E FE ; Subtract with carry $FE9E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $FF80FF.l		; 8F FF 80 FF ; Store accumulator (long) $FF80FF.l [Reads: Accumulator]
	sta $F18EF0.l		; 8F F0 8E F1 ; Store accumulator (long) $F18EF0.l [Reads: Accumulator]
	cpy $E8F3.w		; CC F3 E8 ; Compare $E8F3.w with Y register [Reads: Y Index] [Flags: NCZ]
	sbc [$02.b],Y		; F7 02 ; Subtract with carry (long indexed) [$02.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($25.b,X)		; 01 25 ; Logical OR ($25.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta [$78.b]		; 87 78 ; Store accumulator (long) [$78.b] [Reads: Direct Page, Accumulator]
	eor $8D7AB5.l		; 4F B5 7A 8D ; Exclusive OR accumulator with memory (long) $8D7AB5.l [Writes: Accumulator] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy $B847.w,X		; BC 47 B8 ; Load Y register $B847.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $002760.l,X		; DF 60 27 00 ; Compare accumulator (long,X) $002760.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sbc $00E780.l,X		; FF 80 E7 00 ; Subtract with carry (long,X) $00E780.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $011E00.l,X		; 3F 00 1E 01 ; AND accumulator with memory (long,X) $011E00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldy $7883.w,X		; BC 83 78 ; Load Y register $7883.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	sta [$43.b]		; 87 43 ; Store accumulator (long) [$43.b] [Reads: Direct Page, Accumulator]
	jsr ($1303.w,X)		; FC 03 13 ; Jump to subroutine indirect indexed ($1303.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jmp ($F3F9.w,X)		; 7C F9 F3 ; Jump indirect indexed to ($F3F9.w,X) [Reads: X Index] [Flow: jump]
	sbc [$4F.b]		; E7 4F ; Subtract with carry (long) [$4F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $0F0303.l,X		; 1F 03 03 0F ; Logical OR long $0F0303.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $37FF1F.l,X		; FF 1F FF 37 ; Subtract with carry (long,X) $37FF1F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $C3FF67.l,X		; FF 67 FF C3 ; Subtract with carry (long,X) $C3FF67.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $83FFF1.l,X		; FF F1 FF 83 ; Subtract with carry (long,X) $83FFF1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $002700.l		; 22 00 27 00 ; Jump to subroutine long $002700.l [Writes: Stack Pointer] [Flow: call]
	ora [$01.b],Y		; 17 01 ; OR accumulator with memory (long indexed) [$01.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $1A0610.l		; 0F 10 06 1A ; OR accumulator with memory (long) $1A0610.l [Writes: Accumulator] [Flags: NZ]
	ora $7B.b,S		; 03 7B ; OR accumulator with stack relative $7B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $33.b,S		; 03 33 ; OR accumulator with stack relative $33.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $43.b,S		; 83 43 ; Store accumulator (stack relative) $43.b,S [Reads: Stack Pointer, Accumulator]
	cmp $3E.b,S		; C3 3E ; Compare accumulator (stack relative) $3E.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	sbc $F0BF9C.l,X		; FF 9C BF F0 ; Subtract with carry (long,X) $F0BF9C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FCFC.w,Y		; F9 FC FC ; Subtract with carry $FCFC.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp ($003C.w,X)		; 7C 3C 00 ; Jump indirect indexed to ($003C.w,X) [Reads: X Index] [Flow: jump]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sta $430060.l,X		; 9F 60 00 43 ; Store accumulator (long,X) $430060.l,X [Reads: Accumulator, X Index]
	and #$840E.w		; 29 0E 84 ; Logical AND #$840E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	jsl $8C83F8.l		; 22 F8 83 8C ; Jump to subroutine long $8C83F8.l [Writes: Stack Pointer] [Flow: call]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $0C.b,S		; 23 0C ; AND accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	stz $00.b,X		; 74 00 ; Store zero to $00.b,X [Reads: X Index]
	.db $10, $01		; 10 01 ; Branch if plus to $10, $01 [Flow: branch]
	ora ($08.b),Y		; 11 08 ; OR accumulator with memory ($08.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $2C		; 10 2C ; Branch if plus to $10, $2C [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	eor $FECE7C.l		; 4F 7C CE FE ; Exclusive OR accumulator with memory (long) $FECE7C.l [Writes: Accumulator] [Flags: NZ]
	dec $FE.b		; C6 FE ; Decrement $FE.b [Reads: Direct Page] [Flags: NZ]
	sta $EF.b,S		; 83 EF ; Store accumulator (stack relative) $EF.b,S [Reads: Stack Pointer, Accumulator]
	inc $C7EF.w		; EE EF C7 ; Increment $C7EF.w [Flags: NZ]
	sta $01.b,S		; 83 01 ; Store accumulator (stack relative) $01.b,S [Reads: Stack Pointer, Accumulator]
	ora ($0C.b,X)		; 01 0C ; Logical OR ($0C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $10, $1C		; 10 1C ; Branch if plus to $10, $1C [Flow: branch]
	.db $10, $5D		; 10 5D ; Branch if plus to $10, $5D [Flow: branch]
	.db $10, $DF		; 10 DF ; Branch if plus to $10, $DF [Flow: branch]
	.db $10, $2E		; 10 2E ; Branch if plus to $10, $2E [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	eor $CE437C.l		; 4F 7C 43 CE ; Exclusive OR accumulator with memory (long) $CE437C.l [Writes: Accumulator] [Flags: NZ]
	inc $EF23.w,X		; FE 23 EF ; Increment memory $EF23.w,X [Reads: X Index] [Flags: NZ]
	sta $44.b,S		; 83 44 ; Store accumulator (stack relative) $44.b,S [Reads: Stack Pointer, Accumulator]
	ora $09.b,S		; 03 09 ; OR accumulator with stack relative $09.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$87.b]		; 07 87 ; OR accumulator with memory (long) [$87.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sta $9EFF00.l		; 8F 00 FF 9E ; Store accumulator (long) $9EFF00.l [Reads: Accumulator]
	ora $017983.l		; 0F 83 79 01 ; OR accumulator with memory (long) $017983.l [Writes: Accumulator] [Flags: NZ]
	cpx #$21.b		; E0 21 ; Compare #$21.b with X register [Reads: X Index] [Flags: NCZ]
	bit $20.b		; 24 20 ; Test bits $20.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	jsr ($7078.w,X)		; FC 78 70 ; Jump to subroutine indirect indexed ($7078.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jsr ($13DF.w,X)		; FC DF 13 ; Jump to subroutine indirect indexed ($13DF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora $37.b,S		; 03 37 ; OR accumulator with stack relative $37.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $FFFF70.l		; 0F 70 FF FF ; OR accumulator with memory (long) $FFFF70.l [Writes: Accumulator] [Flags: NZ]
	ora $1F07FF.l		; 0F FF 07 1F ; OR accumulator with memory (long) $1F07FF.l [Writes: Accumulator] [Flags: NZ]
	ora $34.b,S		; 03 34 ; OR accumulator with stack relative $34.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	jsr ($43FF.w,X)		; FC FF 43 ; Jump to subroutine indirect indexed ($43FF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr $E0E0.w		; 20 E0 E0 ; Jump to subroutine at $E0E0.w [Writes: Stack Pointer] [Flow: call]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	asl $0F1E.w,X		; 1E 1E 0F ; Arithmetic shift left $0F1E.w,X [Reads: X Index] [Flags: NCZ]
	ora $040F0C.l		; 0F 0C 0F 04 ; OR accumulator with memory (long) $040F0C.l [Writes: Accumulator] [Flags: NZ]
	ora [$1F.b]		; 07 1F ; OR accumulator with memory (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $E1C70F.l,X		; 1F 0F C7 E1 ; Logical OR long $E1C70F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	eor [$C7.b]		; 47 C7 ; Exclusive OR accumulator with memory (long) [$C7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $7F58FF.l,X		; BF FF 58 7F ; Load long $7F58FF.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc $427161.l,X		; 7F 61 71 42 ; Add long $427161.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($C7.b)		; 72 C7 ; Add with carry (indirect) ($C7.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$CB.b],Y		; F7 CB ; Subtract with carry (long indexed) [$CB.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $8E		; 80 8E ; Branch always to $80, $8E [Flow: branch]
	sta $0408.w		; 8D 08 04 ; Store accumulator to $0408.w [Reads: Accumulator]
	sta [$78.b]		; 87 78 ; Store accumulator (long) [$78.b] [Reads: Direct Page, Accumulator]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and #$840E.w		; 29 0E 84 ; Logical AND #$840E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	jsl $8C83F8.l		; 22 F8 83 8C ; Jump to subroutine long $8C83F8.l [Writes: Stack Pointer] [Flow: call]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and #$D8E4.w		; 29 E4 D8 ; Logical AND #$D8E4.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	stz $39.b		; [PATTERN: Memory clearing operation] 64 39 ; Store zero to $39.b
	and ($2C.b,X)		; 21 2C ; Logical AND ($2C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $30, $6B		; 30 6B ; Branch if minus to $30, $6B [Flow: branch]
	.db $70, $6C		; 70 6C ; Branch if overflow set to $70, $6C [Flow: branch]
	stz $CA.b,X		; 74 CA ; Store zero to $CA.b,X [Reads: X Index]
	inc $9A.b,X		; F6 9A ; Increment memory $9A.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	inc $03.b		; E6 03 ; Increment $03.b [Reads: Direct Page] [Flags: NZ]
	sta $C6.b,S		; 83 C6 ; Store accumulator (stack relative) $C6.b,S [Reads: Stack Pointer, Accumulator]
	cmp [$87.b]		; C7 87 ; Compare accumulator (long) [$87.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sta $01.b,S		; 83 01 ; Store accumulator (stack relative) $01.b,S [Reads: Stack Pointer, Accumulator]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta $CE.b,S		; 83 CE ; Store accumulator (stack relative) $CE.b,S [Reads: Stack Pointer, Accumulator]
	cmp $617FFC.l		; CF FC 7F 61 ; Compare accumulator (long) $617FFC.l [Reads: Accumulator] [Flags: NCZ]
	stz $807F.w,X		; 9E 7F 80 ; Store zero to $807F.w,X [Reads: X Index]
	sty $47.b,X		; 94 47 ; Store Y register $47.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $28.b,S		; 03 28 ; OR accumulator with stack relative $28.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr $307C.w		; 20 7C 30 ; Jump to subroutine at $307C.w [Writes: Stack Pointer] [Flow: call]
	jsl $380E00.l		; 22 00 0E 38 ; Jump to subroutine long $380E00.l [Writes: Stack Pointer] [Flow: call]
	jsr ($FFDF.w,X)		; FC DF FF ; Jump to subroutine indirect indexed ($FFDF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	and ($FF.b,S),Y		; 33 FF ; AND accumulator (stack relative indirect indexed) ($FF.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc ($FF.b,S),Y		; 73 FF ; Add with carry (stack relative indirect indexed) ($FF.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FF.b,S		; E3 FF ; Subtract stack-relative $FF.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	cmp $FF.b,S		; C3 FF ; Compare accumulator (stack relative) $FF.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	ora [$FF.b]		; 07 FF ; OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $22FF23.l		; 0F 23 FF 22 ; OR accumulator with memory (long) $22FF23.l [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora ($F0.b,X)		; 01 F0 ; Logical OR ($F0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpx #$22.b		; E0 22 ; Compare #$22.b with X register [Reads: X Index] [Flags: NCZ]
	brk $1D.b		; 00 1D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $C7FF83.l,X		; FF 83 FF C7 ; Subtract with carry (long,X) $C7FF83.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $FEC7.w,X		; 7D C7 FE ; Add $FEC7.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp [$FF.b]		; C7 FF ; Compare accumulator (long) [$FF.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp $FF.b,S		; C3 FF ; Compare accumulator (stack relative) $FF.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	sta ($FF.b,X)		; 81 FF ; Store accumulator ($FF.b,X) [Reads: Direct Page, Accumulator, X Index]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc $FFFF3C.l,X		; FF 3C FF FF ; Subtract with carry (long,X) $FFFF3C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $C3C7EF.l		; EF EF C7 C3 ; Subtract with carry (long) $C3C7EF.l [Writes: Accumulator] [Flags: NCVZ]
	sta ($00.b,X)		; 81 00 ; Store accumulator ($00.b,X) [Reads: Direct Page, Accumulator, X Index]
	sbc $F8DFFC.l		; EF FC DF F8 ; Subtract with carry (long) $F8DFFC.l [Writes: Accumulator] [Flags: NCVZ]
	sbc $FF4471.l,X		; FF 71 44 FF ; Subtract with carry (long,X) $FF4471.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $0E.b,S		; 03 0E ; OR accumulator with stack relative $0E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cmp $FCFEFC.l,X		; DF FC FE FC ; Compare accumulator (long,X) $FCFEFC.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	.db $F0, $FC		; F0 FC ; Branch if equal to $F0, $FC [Flow: branch]
	inc $07FF.w,X		; FE FF 07 ; Increment memory $07FF.w,X [Reads: X Index] [Flags: NZ]
	eor $FB.b,S		; 43 FB ; Exclusive OR accumulator with stack relative $FB.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0FFC05.l		; 0F 05 FC 0F ; OR accumulator with memory (long) $0FFC05.l [Writes: Accumulator] [Flags: NZ]
	sbc $FBDF77.l,X		; FF 77 DF FB ; Subtract with carry (long,X) $FBDF77.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $EF.b,S		; 43 EF ; Exclusive OR accumulator with stack relative $EF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr ($FF25.w,X)		; FC 25 FF ; Jump to subroutine indirect indexed ($FF25.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora ($FC.b),Y		; 11 FC ; OR accumulator with memory ($FC.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $79FF.w,X		; FD FF 79 ; Subtract with carry $79FF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F8EFF9.l		; EF F9 EF F8 ; Subtract with carry (long) $F8EFF9.l [Writes: Accumulator] [Flags: NCVZ]
	sta $F1FFF8.l,X		; 9F F8 FF F1 ; Store accumulator (long,X) $F1FFF8.l,X [Reads: Accumulator, X Index]
	sbc $03FF01.l,X		; FF 01 FF 03 ; Subtract with carry (long,X) $03FF01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FC24CF.l,X		; FF CF 24 FC ; Subtract with carry (long,X) $FC24CF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$25.b		; E0 25 ; Compare #$25.b with X register [Reads: X Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $C7E6.w,X		; FE E6 C7 ; Increment memory $C7E6.w,X [Reads: X Index] [Flags: NZ]
	cmp $85.b,S		; C3 85 ; Compare accumulator (stack relative) $85.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	sta ($05.b,X)		; 81 05 ; Store accumulator ($05.b,X) [Reads: Direct Page, Accumulator, X Index]
	ora ($0D.b,X)		; 01 0D ; Logical OR ($0D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($7A.b,X)		; 01 7A ; Logical OR ($7A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $B5.b,S		; 03 B5 ; OR accumulator with stack relative $B5.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	stx $CB.b		; 86 CB ; Store X register to $CB.b [Reads: X Index]
	cpy $3C19.w		; CC 19 3C ; Compare $3C19.w with Y register [Reads: Y Index] [Flags: NCZ]
	ror $FEFE.w,X		; 7E FE FE ; Rotate right $FEFE.w,X [Reads: X Index] [Flags: NCZ]
	jsr ($3078.w,X)		; FC 78 30 ; Jump to subroutine indirect indexed ($3078.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	lda $83.b,S		; A3 83 ; Load accumulator (stack relative) $83.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $01.b,S		; A3 01 ; Load accumulator (stack relative) $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $8201.w,X		; 7D 01 82 ; Add $8201.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $7D.b,S		; 83 7D ; Store accumulator (stack relative) $7D.b,S [Reads: Stack Pointer, Accumulator]
	sty $53.b		; 84 53 ; Store Y register to $53.b [Reads: Y Index]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $FE7C.w,Y		; 39 7C FE ; AND accumulator with memory $FE7C.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	inc $227C.w,X		; FE 7C 22 ; Increment memory $227C.w,X [Reads: X Index] [Flags: NZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $E3.b,S		; E3 E3 ; Subtract stack-relative $E3.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	cmp $C1.b		; C5 C1 ; Compare $C1.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	stx $80.b		; 86 80 ; Store X register to $80.b [Reads: X Index]
	sta $F6.b,S		; 83 F6 ; Store accumulator (stack relative) $F6.b,S [Reads: Stack Pointer, Accumulator]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	sta $C5.b,S		; 83 C5 ; Store accumulator (stack relative) $C5.b,S [Reads: Stack Pointer, Accumulator]
	dec $7B.b		; C6 7B ; Decrement $7B.b [Reads: Direct Page] [Flags: NZ]
	jmp ($3E1C.w,X)		; 7C 1C 3E ; Jump indirect indexed to ($3E1C.w,X) [Reads: X Index] [Flow: jump]
	adc $7CFEFF.l,X		; 7F FF FE 7C ; Add long $7CFEFF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $80, $EB		; 80 EB ; Branch always to $80, $EB [Flow: branch]
	cpy $8695.w		; CC 95 86 ; Compare $8695.w with Y register [Reads: Y Index] [Flags: NCZ]
	adc $44.b,X		; 75 44 ; Add $44.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $15.b		; 06 15 ; Arithmetic shift left $15.b [Reads: Direct Page] [Flags: NCZ]
	ora [$95.b]		; 07 95 ; OR accumulator with memory (long) [$95.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	stx $EB.b		; 86 EB ; Store X register to $EB.b [Reads: X Index]
	cpy $7877.w		; CC 77 78 ; Compare $7877.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $30, $78		; 30 78 ; Branch if minus to $30, $78 [Flow: branch]
	jsl $7802F8.l		; 22 F8 02 78 ; Jump to subroutine long $7802F8.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $80		; 30 80 ; Branch if minus to $30, $80 [Flow: branch]
	sty $48.b,X		; 94 48 ; Store Y register $48.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$FF.b]		; E7 FF ; Subtract with carry (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$FF.b		; E0 FF ; Compare #$FF.b with X register [Reads: X Index] [Flags: NCZ]
	cmp $F010FF.l		; CF FF 10 F0 ; Compare accumulator (long) $F010FF.l [Reads: Accumulator] [Flags: NCZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	cpx #$25.b		; E0 25 ; Compare #$25.b with X register [Reads: X Index] [Flags: NCZ]
	cpx #$23.b		; E0 23 ; Compare #$23.b with X register [Reads: X Index] [Flags: NCZ]
	cpx #$3F.b		; E0 3F ; Compare #$3F.b with X register [Reads: X Index] [Flags: NCZ]
	sbc $000022.l,X		; FF 22 00 00 ; Subtract with carry (long,X) $000022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $E01F22.l		; 0F 22 1F E0 ; OR accumulator with memory (long) $E01F22.l [Writes: Accumulator] [Flags: NZ]
	jsl $E8FF00.l		; 22 00 FF E8 ; Jump to subroutine long $E8FF00.l [Writes: Stack Pointer] [Flow: call]
	cmp $C33CE0.l,X		; DF E0 3C C3 ; Compare accumulator (long,X) $C33CE0.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	ldy $70C3.w,X		; BC C3 70 ; Load Y register $70C3.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	eor $7C0738.l		; 4F 38 07 7C ; Exclusive OR accumulator with memory (long) $7C0738.l [Writes: Accumulator] [Flags: NZ]
	ora $FE.b,S		; 03 FE ; OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $83C78F.l,X		; 1F 8F C7 83 ; Logical OR long $83C78F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpx $08FF.w		; EC FF 08 ; Compare $08FF.w with X register [Reads: X Index] [Flags: NCZ]
	sbc $617EC0.l,X		; FF C0 7E 61 ; Subtract with carry (long,X) $617EC0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $8323.w,X		; 3C 23 83 ; Test bits $8323.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora $09.b		; 05 09 ; Logical OR $09.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr ($0003.w,X)		; FC 03 00 ; Jump to subroutine indirect indexed ($0003.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta [$CF.b]		; 87 CF ; Store accumulator (long) [$CF.b] [Reads: Direct Page, Accumulator]
	cmp $970383.l,X		; DF 83 03 97 ; Compare accumulator (long,X) $970383.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	cpx #$35.b		; E0 35 ; Compare #$35.b with X register [Reads: X Index] [Flags: NCZ]
	sbc [$80.b],Y		; F7 80 ; Subtract with carry (long indexed) [$80.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$00.b],Y		; F7 00 ; Subtract with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp ($BC43.w,X)		; 7C 43 BC ; Jump indirect indexed to ($BC43.w,X) [Reads: X Index] [Flow: jump]
	cmp $B0.b,S		; C3 B0 ; Compare accumulator (stack relative) $B0.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	cmp $9CE758.l		; CF 58 E7 9C ; Compare accumulator (long) $9CE758.l [Reads: Accumulator] [Flags: NCZ]
	adc $FE.b,S		; 63 FE ; Add with carry (stack relative) $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora ($7B.b,X)		; 01 7B ; Logical OR ($7B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sta $1F.b,S		; 83 1F ; Store accumulator (stack relative) $1F.b,S [Reads: Stack Pointer, Accumulator]
	ora $010307.l		; 0F 07 03 01 ; OR accumulator with memory (long) $010307.l [Writes: Accumulator] [Flags: NZ]
	cmp ($FE.b,X)		; C1 FE ; Compare accumulator ($FE.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	stz $22FF.w,X		; 9E FF 22 ; Store zero to $22FF.w,X [Reads: X Index]
	sbc ($44.b,X)		; E1 44 ; Subtract with carry ($44.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp ($5A.b,X)		; C1 5A ; Compare accumulator ($5A.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	cmp $45.b,S		; C3 45 ; Compare accumulator (stack relative) $45.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	dec $39.b		; C6 39 ; Decrement $39.b [Reads: Direct Page] [Flags: NZ]
	inc $B947.w,X		; FE 47 B9 ; Increment memory $B947.w,X [Reads: X Index] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $3C3E.w,X		; 1E 3E 3C ; Arithmetic shift left $3C3E.w,X [Reads: X Index] [Flags: NCZ]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$FF.b		; C0 FF ; Compare #$FF.b with Y register [Reads: Y Index] [Flags: NCZ]
	sta $22FE.w,X		; 9D FE 22 ; Store accumulator to $22FE.w,X [Reads: Accumulator, X Index]
	sbc $43.b,S		; E3 43 ; Subtract stack-relative $43.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cmp $1D.b,S		; C3 1D ; Compare accumulator (stack relative) $1D.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	eor $C6.b,X		; 55 C6 ; Exclusive OR accumulator with memory $C6.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc #$87CE.w		; 69 CE 87 ; Add #$87CE.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	adc $0000.w,Y		; 79 00 00 ; Add $0000.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	trb $3C3C.w		; 1C 3C 3C ; Test and reset bits $3C3C.w [Reads: Accumulator] [Flags: Z]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	and $817FC1.l,X		; 3F C1 7F 81 ; AND accumulator with memory (long,X) $817FC1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $3C.b,S		; C3 3C ; Compare accumulator (stack relative) $3C.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	sbc ($7E.b,X)		; E1 7E ; Subtract with carry ($7E.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $7EB9CE.l		; 4F CE B9 7E ; Exclusive OR accumulator with memory (long) $7EB9CE.l [Writes: Accumulator] [Flags: NZ]
	.db $42, $BD		; 42 BD ; Reserved instruction
	rol $D9.b		; 26 D9 ; Rotate left $D9.b [Reads: Direct Page] [Flags: NCZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $3E0F00.l		; 22 00 0F 3E ; Jump to subroutine long $3E0F00.l [Writes: Stack Pointer] [Flow: call]
	cmp ($27.b,X)		; C1 27 ; Compare accumulator ($27.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	.db $70, $BF		; 70 BF ; Branch if overflow set to $70, $BF [Flow: branch]
	sta $FF780F.l		; 8F 0F 78 FF ; Store accumulator (long) $FF780F.l [Reads: Accumulator]
	.db $F0, $3F		; F0 3F ; Branch if equal to $F0, $3F [Flow: branch]
	adc ($9F.b,X)		; 61 9F ; Add with carry ($9F.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $0022C1.l,X		; 3F C1 22 00 ; AND accumulator with memory (long,X) $0022C1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($0B.b),Y		; 11 0B ; OR accumulator with memory ($0B.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $96.b,S		; 03 96 ; OR accumulator with stack relative $96.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta [$7C.b]		; 87 7C ; Store accumulator (long) [$7C.b] [Reads: Direct Page, Accumulator]
	sbc $FF7E81.l,X		; FF 81 7E FF ; Subtract with carry (long,X) $FF7E81.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $1E11.w,X		; BC 11 1E ; Load Y register $1E11.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	and $FC1E.w,Y		; 39 1E FC ; AND accumulator with memory $FC1E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jsl $401300.l		; 22 00 13 40 ; Jump to subroutine long $401300.l [Writes: Stack Pointer] [Flow: call]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: NCZ]
	ora $711E.w,Y		; 19 1E 71 ; OR accumulator with memory $711E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	inc $7CA3.w,X		; FE A3 7C ; Increment memory $7CA3.w,X [Reads: X Index] [Flags: NZ]
	adc $BC3380.l,X		; 7F 80 33 BC ; Add long $BC3380.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda #$148E.w		; A9 8E 14 ; Load #$148E.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$16.b]		; 07 16 ; OR accumulator with memory (long) [$16.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$E0.b]		; 07 E0 ; OR accumulator with memory (long) [$E0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $400300.l		; 22 00 03 40 ; Jump to subroutine long $400300.l [Writes: Stack Pointer] [Flow: call]
	.db $70, $F8		; 70 F8 ; Branch if overflow set to $70, $F8 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $00FF43.l,X		; FF 43 FF 00 ; Subtract with carry (long,X) $00FF43.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$41.b		; E0 41 ; Compare #$41.b with X register [Reads: X Index] [Flags: NCZ]
	inc $FC00.w,X		; FE 00 FC ; Increment memory $FC00.w,X [Reads: X Index] [Flags: NZ]
	brk $F9.b		; 00 F9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($F9.b,X)		; 01 F9 ; Logical OR ($F9.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora #$09E9.w		; 09 E9 09 ; Logical OR #$09E9.w with accumulator [Writes: Accumulator] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $7636.w,X		; 1E 36 76 ; Arithmetic shift left $7636.w,X [Reads: X Index] [Flags: NCZ]
	pea $1695.w		; F4 95 16 ; Push absolute address $1695.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sta ($94.b,S),Y		; 93 94 ; Store accumulator (stack relative indirect indexed) ($94.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	stx $99.b,Y		; 96 99 ; Store X register $99.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	ldx $10B1.w		; AE B1 10 ; Load $10B1.w into X register [Writes: X Index] [Flags: NZ]
	and $704F30.l		; 2F 30 4F 70 ; AND accumulator with memory (long) $704F30.l [Writes: Accumulator] [Flags: NZ]
	sta $E97F80.l		; 8F 80 7F E9 ; Store accumulator (long) $E97F80.l [Reads: Accumulator]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc [$4F.b]		; 67 4F ; Add with carry (long) [$4F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp $FF7FBF.l,X		; DF BF 7F FF ; Compare accumulator (long,X) $FF7FBF.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: NCZ]
	cmp $C4B420.l,X		; DF 20 B4 C4 ; Compare accumulator (long,X) $C4B420.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	.db $62, $82, $41		; 62 82 41 ; Push effective relative address $62, $82, $41 [Writes: Stack Pointer]
	sta ($C0.b,X)		; 81 C0 ; Store accumulator ($C0.b,X) [Reads: Direct Page, Accumulator, X Index]
	lda $FF807F.l,X		; BF 7F 80 FF ; Load long $FF807F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $7E7D3B.l,X		; DF 3B 7D 7E ; Compare accumulator (long,X) $7E7D3B.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx #$35.b		; E0 35 ; Compare #$35.b with X register [Reads: X Index] [Flags: NCZ]
	sbc $404700.l,X		; FF 00 47 40 ; Subtract with carry (long,X) $404700.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $9128.w		; 2C 28 91 ; Test bits $9128.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	sta $FC04.w,Y		; 99 04 FC ; Store accumulator to $FC04.w,Y [Reads: Y Index, Accumulator]
	jsr ($FF03.w,X)		; FC 03 FF ; Jump to subroutine indirect indexed ($FF03.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $66D7BF.l,X		; FF BF D7 66 ; Subtract with carry (long,X) $66D7BF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $D1.b		; 00 D1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($E5.b)		; 12 E5 ; OR accumulator with memory (indirect) ($E5.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $ED.b		; 26 ED ; Rotate left $ED.b [Reads: Direct Page] [Flags: NCZ]
	rol $0AC9.w		; 2E C9 0A ; Rotate left $0AC9.w [Flags: NCZ]
	cmp $D11A.w,Y		; D9 1A D1 ; Compare accumulator $D11A.w,Y [Reads: Y Index] [Flags: NCZ]
	ora ($D5.b)		; 12 D5 ; OR accumulator with memory (indirect) ($D5.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $E5.b,X		; 16 E5 ; Arithmetic shift left $E5.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	rol $EC.b		; 26 EC ; Rotate left $EC.b [Reads: Direct Page] [Flags: NCZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	.db $D0, $F4		; D0 F4 ; Branch if not equal to $D0, $F4 [Flow: branch]
	cpx $EC.b		; E4 EC ; Compare $EC.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	sbc #$C92A.w		; E9 2A C9 ; Subtract #$C92A.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cmp ($12.b),Y		; D1 12 ; Compare accumulator ($12.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	sbc ($22.b,X)		; E1 22 ; Subtract with carry ($22.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $62.b		; 85 62 ; Store accumulator to $62.b [Reads: Accumulator]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($12.b),Y		; D1 12 ; Compare accumulator ($12.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	pei ($F4.b)		; D4 F4 ; Push effective indirect address ($F4.b) [Reads: Direct Page] [Writes: Stack Pointer]
	cpx $D8DC.w		; EC DC D8 ; Compare $D8DC.w with X register [Reads: X Index] [Flags: NCZ]
	.db $D0, $F4		; D0 F4 ; Branch if not equal to $D0, $F4 [Flow: branch]
	cpx $FF43.w		; EC 43 FF ; Compare $FF43.w with X register [Reads: X Index] [Flags: NCZ]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stx $86.b		; 86 86 ; Store X register to $86.b [Reads: X Index]
	adc ($71.b),Y		; 71 71 ; Add with carry ($71.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	trb $D81C.w		; 1C 1C D8 ; Test and reset bits $D81C.w [Reads: Accumulator] [Flags: Z]
	sbc [$FF.b],Y		; F7 FF ; Subtract with carry (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $83.b,S		; E3 83 ; Subtract stack-relative $83.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	lsr $00.b,X		; 56 00 ; Logical shift right $00.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tsb $79.b		; 04 79 ; Test and set bits $79.b [Reads: Accumulator] [Flags: Z]
	stx $10E3.w		; 8E E3 10 ; Store X register to $10E3.w [Reads: X Index]
	sbc $44.b,S		; E3 44 ; Subtract stack-relative $44.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($94.b,S),Y		; 93 94 ; Store accumulator (stack relative indirect indexed) ($94.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	brk $95.b		; 00 95 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $4A.b,X		; 95 4A ; Store accumulator to $4A.b,X [Reads: Accumulator, X Index]
	brk $97.b		; 00 97 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $97.b		; 00 97 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7B.b		; 00 7B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $3F.b		; 05 3F ; Logical OR $3F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($DF.b,X)		; 01 DF ; Logical OR ($DF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($FF.b,S),Y		; 13 FF ; OR accumulator (stack relative indirect indexed) ($FF.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $43.b		; 04 43 ; Test and set bits $43.b [Reads: Accumulator] [Flags: Z]
	sbc $000800.l,X		; FF 00 08 00 ; Subtract with carry (long,X) $000800.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F8FCFF.l,X		; FF FF FC F8 ; Subtract with carry (long,X) $F8FCFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: NCZ]
	cpy #$FF.b		; C0 FF ; Compare #$FF.b with Y register [Reads: Y Index] [Flags: NCZ]
	mvp $FB,$00		; 44 00 FB ; Move block positive $FB,$00 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $F7.b		; 05 F7 ; Logical OR $F7.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $80, $FF		; 80 FF ; Branch always to $80, $FF [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sbc $FF43F8.l,X		; FF F8 43 FF ; Subtract with carry (long,X) $FF43F8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $FF		; 80 FF ; Branch always to $80, $FF [Flow: branch]
	sbc $03077F.l,X		; FF 7F 07 03 ; Subtract with carry (long,X) $03077F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $070022.l,X		; 7F 22 00 07 ; Add long $070022.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $03FE01.l,X		; FF 01 FE 03 ; Subtract with carry (long,X) $03FE01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($00FF.w,X)		; FC FF 00 ; Jump to subroutine indirect indexed ($00FF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $807F44.l,X		; FF 44 7F 80 ; Subtract with carry (long,X) $807F44.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $80.b,S		; 43 80 ; Exclusive OR accumulator with stack relative $80.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $3FC00C.l,X		; 3F 0C C0 3F ; AND accumulator with memory (long,X) $3FC00C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $3FFF00.l,X		; FF 00 FF 3F ; Subtract with carry (long,X) $3FFF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$BF.b		; C0 BF ; Compare #$BF.b with Y register [Reads: Y Index] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cmp $40407F.l,X		; DF 7F 40 40 ; Compare accumulator (long,X) $40407F.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $85.b		; 00 85 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $00.b,X		; 94 00 ; Store Y register $00.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	ora $C6.b,S		; 03 C6 ; OR accumulator with stack relative $C6.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $00.b		; C6 00 ; Decrement $00.b [Reads: Direct Page] [Flags: NZ]
	sbc $009E86.l,X		; FF 86 9E 00 ; Subtract with carry (long,X) $009E86.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $39.b		; 02 39 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $8439.w,Y		; 39 39 84 ; AND accumulator with memory $8439.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sty $63.b		; 84 63 ; Store Y register to $63.b [Reads: Y Index]
	adc $30.b,S		; 63 30 ; Add with carry (stack relative) $30.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $85		; 30 85 ; Branch if minus to $30, $85 [Flow: branch]
	sty $0501.w		; 8C 01 05 ; Store Y register to $0501.w [Reads: Y Index]
	dec $7B.b		; C6 7B ; Decrement $7B.b [Reads: Direct Page] [Flags: NZ]
	stz $00CF.w		; 9C CF 00 ; Store zero to $00CF.w
	sbc $00608F.l,X		; FF 8F 60 00 ; Subtract with carry (long,X) $00608F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$ED.b]		; 07 ED ; OR accumulator with memory (long) [$ED.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $F5D1.w,Y		; D9 D1 F5 ; Compare accumulator $F5D1.w,Y [Reads: Y Index] [Flags: NCZ]
	sbc $ED.b		; E5 ED ; Subtract $ED.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc #$97D9.w		; E9 D9 97 ; Subtract #$97D9.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	.db $B0, $01		; B0 01 ; Branch if carry set to $B0, $01 [Flow: branch]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $D0, $30		; D0 30 ; Branch if not equal to $D0, $30 [Flow: branch]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	pei ($1C.b)		; D4 1C ; Push effective indirect address ($1C.b) [Reads: Direct Page] [Writes: Stack Pointer]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	asl $0FCC.w		; 0E CC 0F ; Arithmetic shift left $0FCC.w [Flags: NCZ]
	.db $D0, $13		; D0 13 ; Branch if not equal to $D0, $13 [Flow: branch]
	sbc $C4CFFF.l,X		; FF FF CF C4 ; Subtract with carry (long,X) $C4CFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F1.b,S		; E3 F1 ; Subtract stack-relative $F1.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	.db $F0, $EC		; F0 EC ; Branch if equal to $F0, $EC [Flow: branch]
	eor $C1.b,S		; 43 C1 ; Exclusive OR accumulator with stack relative $C1.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $0B.b		; 02 0B ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($02.b,X)		; 21 02 ; Logical AND ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($02.b),Y		; 11 02 ; OR accumulator with memory ($02.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora #$0502.w		; 09 02 05 ; Logical OR #$0502.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $00FF.w,X		; FE FF 00 ; Increment memory $00FF.w,X [Reads: X Index] [Flags: NZ]
	and $FD.b		; 25 FD ; Logical AND $FD.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $08E31C.l,X		; FF 1C E3 08 ; Subtract with carry (long,X) $08E31C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$83.b],Y		; F7 83 ; Subtract with carry (long indexed) [$83.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	mvn $43,$01		; 54 01 43 ; Move block negative $43,$01 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $18.b,S		; 03 18 ; OR accumulator with stack relative $18.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc [$00.b]		; E7 00 ; Subtract with carry (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	brk $27.b		; 00 27 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $EF1001.l,X		; FF 01 10 EF ; Subtract with carry (long,X) $EF1001.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp $FF00.w		; 4C 00 FF ; Jump to $FF00.w [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$FF.b]		; 27 FF ; AND accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $80FE00.l		; 0F 00 FE 80 ; OR accumulator with memory (long) $80FE00.l [Writes: Accumulator] [Flags: NZ]
	ror $3EC0.w,X		; 7E C0 3E ; Rotate right $3EC0.w,X [Reads: X Index] [Flags: NCZ]
	.db $82, $7C, $02		; 82 7C 02 ; Branch always long to $82, $7C, $02 [Flow: branch]
	jsr ($FE00.w,X)		; FC 00 FE ; Jump to subroutine indirect indexed ($FE00.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	clc		; 18 ; Clear carry flag [Flags: C]
	inc $00.b		; E6 00 ; Increment $00.b [Reads: Direct Page] [Flags: NZ]
	inc $FF27.w,X		; FE 27 FF ; Increment memory $FF27.w,X [Reads: X Index] [Flags: NZ]
	eor [$00.b]		; 47 00 ; Exclusive OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $8001.w,X		; FE 01 80 ; Increment memory $8001.w,X [Reads: X Index] [Flags: NZ]
	ror $0045.w,X		; 7E 45 00 ; Rotate right $0045.w,X [Reads: X Index] [Flags: NCZ]
	inc $FF27.w,X		; FE 27 FF ; Increment memory $FF27.w,X [Reads: X Index] [Flags: NZ]
	sty $01.b		; 84 01 ; Store Y register to $01.b [Reads: Y Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $3A83.w,X		; FD 83 3A ; Subtract with carry $3A83.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($1D.b,X)		; 01 1D ; Logical OR ($1D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($EE.b,X)		; 01 EE ; Logical OR ($EE.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $DD.b,S		; 03 DD ; OR accumulator with stack relative $DD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $BB.b		; 04 BB ; Test and set bits $BB.b [Reads: Accumulator] [Flags: Z]
	inc $FAFD.w,X		; FE FD FA ; Increment memory $FAFD.w,X [Reads: X Index] [Flags: NZ]
	pea $D0E8.w		; F4 E8 D0 ; Push absolute address $D0E8.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	ldy #$40.b		; A0 40 ; Load #$40.b into Y register [Writes: Y Index] [Flags: NZ]
	sty $9BF3.w		; 8C F3 9B ; Store Y register to $9BF3.w [Reads: Y Index]
	jmp ($9C73.w)		; 6C 73 9C ; Jump indirect to ($9C73.w) [Flow: jump]
	adc [$B9.b]		; 67 B9 ; Add with carry (long) [$B9.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp $E79F73.l		; CF 73 9F E7 ; Compare accumulator (long) $E79F73.l [Reads: Accumulator] [Flags: NCZ]
	and $9F7FCF.l,X		; 3F CF 7F 9F ; AND accumulator with memory (long,X) $9F7FCF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $011400.l		; 22 00 14 01 ; Jump to subroutine long $011400.l [Writes: Stack Pointer] [Flow: call]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $BF1C.w		; 0E 1C BF ; Arithmetic shift left $BF1C.w [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	trb $DF.b		; 14 DF ; Test and reset bits $DF.b [Reads: Accumulator] [Flags: Z]
	jsr $50AF.w		; 20 AF 50 ; Jump to subroutine at $50AF.w [Writes: Stack Pointer] [Flow: call]
	sbc $40BF00.l,X		; FF 00 BF 40 ; Subtract with carry (long,X) $40BF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $FC01.w,X		; FE 01 FC ; Increment memory $FC01.w,X [Reads: X Index] [Flags: NZ]
	ora $27.b,S		; 03 27 ; OR accumulator with stack relative $27.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $05.b		; 06 05 ; Arithmetic shift left $05.b [Reads: Direct Page] [Flags: NCZ]
	jsr ($080B.w,X)		; FC 0B 08 ; Jump to subroutine indirect indexed ($080B.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	asl $10.b		; 06 10 ; Arithmetic shift left $10.b [Reads: Direct Page] [Flags: NCZ]
	tsb $1820.w		; 0C 20 18 ; Test and set bits $1820.w [Reads: Accumulator] [Flags: Z]
	bit $43C0.w,X		; 3C C0 43 ; Test bits $43C0.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	jsr ($0400.w,X)		; FC 00 04 ; Jump to subroutine indirect indexed ($0400.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $F7F3.w,Y		; F9 F3 F7 ; Subtract with carry $F7F3.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $0322DF.l		; EF DF 22 03 ; Subtract with carry (long) $0322DF.l [Writes: Accumulator] [Flags: NCVZ]
	cpx #$27.b		; E0 27 ; Compare #$27.b with X register [Reads: X Index] [Flags: NCZ]
	.db $30, $8F		; 30 8F ; Branch if minus to $30, $8F [Flow: branch]
	and $DC.b,S		; 23 DC ; AND accumulator with stack relative $DC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($2D.b)		; 12 2D ; OR accumulator with memory (indirect) ($2D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpy #$3F.b		; C0 3F ; Compare #$3F.b with Y register [Reads: Y Index] [Flags: NCZ]
	bit $CB.b,X		; 34 CB ; Test bits $CB.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc $0D.b		; E5 0D ; Subtract $0D.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($02.b)		; F2 02 ; Subtract with carry (indirect) ($02.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $3F7F.w,X		; FD 7F 3F ; Subtract with carry $3F7F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $FBF7CF.l,X		; DF CF F7 FB ; Compare accumulator (long,X) $FBF7CF.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	sbc $80FE.w,X		; FD FE 80 ; Subtract with carry $80FE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $BE40.w,X		; 7E 40 BE ; Rotate right $BE40.w,X [Reads: X Index] [Flags: NCZ]
	jsr $10DE.w		; 20 DE 10 ; Jump to subroutine at $10DE.w [Writes: Stack Pointer] [Flow: call]
	inc $F608.w		; EE 08 F6 ; Increment $F608.w [Flags: NZ]
	tsb $FA.b		; 04 FA ; Test and set bits $FA.b [Reads: Accumulator] [Flags: Z]
	cop $FC.b		; 02 FC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$FF.b]		; 27 FF ; AND accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$E5.b],Y		; 17 E5 ; OR accumulator with memory (long indexed) [$E5.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	rol $D5.b		; 26 D5 ; Rotate left $D5.b [Reads: Direct Page] [Flags: NCZ]
	asl $D1.b,X		; 16 D1 ; Arithmetic shift left $D1.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	asl $DB.b,X		; 16 DB ; Arithmetic shift left $DB.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	trb $08CF.w		; 1C CF 08 ; Test and reset bits $08CF.w [Reads: Accumulator] [Flags: Z]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	bit $26E1.w		; 2C E1 26 ; Test bits $26E1.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	cmp ($16.b),Y		; D1 16 ; Compare accumulator ($16.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cpx #$F0.b		; E0 F0 ; Compare #$F0.b with X register [Reads: X Index] [Flags: NCZ]
	.db $D0, $D8		; D0 D8 ; Branch if not equal to $D0, $D8 [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sta [$00.b],Y		; 97 00 ; Store accumulator (long indexed) [$00.b],Y [Reads: Direct Page, Y Index, Accumulator]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $588300.l,X		; FF 00 83 58 ; Subtract with carry (long,X) $588300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpy #$83.b		; C0 83 ; Compare #$83.b with Y register [Reads: Y Index] [Flags: NCZ]
	eor $2601.w,X		; 5D 01 26 ; Exclusive OR accumulator with memory $2601.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$80.b		; C0 80 ; Compare #$80.b with Y register [Reads: Y Index] [Flags: NCZ]
	brk $BF.b		; 00 BF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $3F		; 80 3F ; Branch always to $80, $3F [Flow: branch]
	cpy #$7F.b		; C0 7F ; Compare #$7F.b with Y register [Reads: Y Index] [Flags: NCZ]
	sbc $44FF00.l,X		; FF 00 FF 44 ; Subtract with carry (long,X) $44FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $7F0200.l,X		; FF 00 02 7F ; Subtract with carry (long,X) $7F0200.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	tsb $0377.w		; 0C 77 03 ; Test and set bits $0377.w [Reads: Accumulator] [Flags: Z]
	stz $FC17.w		; 9C 17 FC ; Store zero to $FC17.w
	sta [$25.b]		; 87 25 ; Store accumulator (long) [$25.b] [Reads: Direct Page, Accumulator]
	.db $80, $01		; 80 01 ; Branch always to $80, $01 [Flow: branch]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: NCZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	tsb $0377.w		; 0C 77 03 ; Test and set bits $0377.w [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc ($0B.b,S),Y		; 73 0B ; Add with carry (stack relative indirect indexed) ($0B.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	stz $25.b,X		; 74 25 ; Store zero to $25.b,X [Reads: X Index]
	.db $80, $12		; 80 12 ; Branch always to $80, $12 [Flow: branch]
	sty $80.b		; 84 80 ; Store Y register to $80.b [Reads: Y Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	and $105F20.l,X		; 3F 20 5F 10 ; AND accumulator with memory (long,X) $105F20.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $0F700F.l		; 6F 0F 70 0F ; Add with carry (long) $0F700F.l [Writes: Accumulator] [Flags: NCVZ]
	adc [$0E.b],Y		; 77 0E ; Add with carry (long indexed) [$0E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $0D.b,X		; 75 0D ; Add $0D.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $FF.b,X		; 76 FF ; Rotate right $FF.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	rol $80.b		; 26 80 ; Rotate left $80.b [Reads: Direct Page] [Flags: NCZ]
	.db $10, $8C		; 10 8C ; Branch if plus to $10, $8C [Flow: branch]
	adc [$4C.b],Y		; 77 4C ; Add with carry (long indexed) [$4C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$2C.b],Y		; F7 2C ; Subtract with carry (long indexed) [$2C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$1C.b],Y		; F7 1C ; Subtract with carry (long indexed) [$1C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$FC.b],Y		; F7 FC ; Subtract with carry (long indexed) [$FC.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $02FBF8.l		; 0F F8 FB 02 ; OR accumulator with memory (long) $02FBF8.l [Writes: Accumulator] [Flags: NZ]
	sbc $80FF01.l,X		; FF 01 FF 80 ; Subtract with carry (long,X) $80FF01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	trb $04.b		; 14 04 ; Test and reset bits $04.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $27.b		; E4 27 ; Compare $27.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	pei ($17.b)		; D4 17 ; Push effective indirect address ($17.b) [Reads: Direct Page] [Writes: Stack Pointer]
	cld		; D8 ; Clear decimal flag [Flags: D]
	ora $D61DD2.l,X		; 1F D2 1D D6 ; Logical OR long $D61DD2.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $39F6.w,Y		; 19 F6 39 ; OR accumulator with memory $39F6.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	nop		; EA ; No operation
	and $17D0.w		; 2D D0 17 ; Logical AND $17D0.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	sbc #$E122.w		; E9 22 E1 ; Subtract #$E122.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ora ($C1.b,S),Y		; 13 C1 ; OR accumulator (stack relative indirect indexed) ($C1.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp ($E9.b),Y		; D1 E9 ; Compare accumulator ($E9.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	bit $1800.w,X		; 3C 00 18 ; Test bits $1800.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	sbc [$0C.b]		; E7 0C ; Subtract with carry (long) [$0C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($06.b,S),Y		; F3 06 ; Subtract with carry (stack relative indirect indexed) ($06.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc $00FF.w,Y		; F9 FF 00 ; Subtract with carry $00FF.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $CF38C7.l,X		; FF C7 38 CF ; Subtract with carry (long,X) $CF38C7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $DF		; 30 DF ; Branch if minus to $30, $DF [Flow: branch]
	sbc [$26.b]		; E7 26 ; Subtract with carry (long) [$26.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0B77.w		; 0C 77 0B ; Test and set bits $0B77.w [Reads: Accumulator] [Flags: Z]
	sta $31CF70.l		; 8F 70 CF 31 ; Store accumulator (long) $31CF70.l [Reads: Accumulator]
	inc $BC13.w		; EE 13 BC ; Increment $BC13.w [Flags: NZ]
	eor [$1C.b]		; 47 1C ; Exclusive OR accumulator with memory (long) [$1C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc [$0C.b]		; 67 0C ; Add with carry (long) [$0C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc [$22.b],Y		; 77 22 ; Add with carry (long indexed) [$22.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $01		; 80 01 ; Branch always to $80, $01 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $F91680.l		; 22 80 16 F9 ; Jump to subroutine long $F91680.l [Writes: Stack Pointer] [Flow: call]
	rol $7CF3.w,X		; 3E F3 7C ; Rotate left $7CF3.w,X [Reads: X Index] [Flags: NCZ]
	inc $F9.b		; E6 F9 ; Increment $F9.b [Reads: Direct Page] [Flags: NZ]
	dec $9EF3.w		; CE F3 9E ; Decrement $9EF3.w [Flags: NZ]
	sbc [$3E.b]		; E7 3E ; Subtract with carry (long) [$3E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp $C09F7E.l		; CF 7E 9F C0 ; Compare accumulator (long) $C09F7E.l [Reads: Accumulator] [Flags: NCZ]
	and $F87C3E.l,X		; 3F 3E 7C F8 ; AND accumulator with memory (long,X) $F87C3E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	cpy #$80.b		; C0 80 ; Compare #$80.b with Y register [Reads: Y Index] [Flags: NCZ]
	mvp $FF,$00		; 44 00 FF ; Move block positive $FF,$00 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	and [$FF.b]		; 27 FF ; AND accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0022FF.l,X		; FF FF 22 00 ; Subtract with carry (long,X) $0022FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $FF.b		; 24 FF ; Test bits $FF.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $3EFD.w		; 4E FD 3E ; Logical shift right $3EFD.w [Flags: NCZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	rol $FF44.w,X		; 3E 44 FF ; Rotate left $FF44.w,X [Reads: X Index] [Flags: NCZ]
	brk $46.b		; 00 46 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $FC05FF.l,X		; 3F FF 05 FC ; AND accumulator with memory (long,X) $FC05FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $003EFD.l,X		; 3F FD 3E 00 ; AND accumulator with memory (long,X) $003EFD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $FD3E45.l,X		; 3F 45 3E FD ; AND accumulator with memory (long,X) $FD3E45.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr $FE.b		; 46 FE ; Logical shift right $FE.b [Reads: Direct Page] [Flags: NCZ]
	sbc $0483.w,X		; FD 83 04 ; Subtract with carry $0483.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $243E.w,X		; 3E 3E 24 ; Rotate left $243E.w,X [Reads: X Index] [Flags: NCZ]
	inc $60E4.w,X		; FE E4 60 ; Increment memory $60E4.w,X [Reads: X Index] [Flags: NZ]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $860A00.l,X		; FF 00 0A 86 ; Subtract with carry (long,X) $860A00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	stx $7D.b		; 86 7D ; Store X register to $7D.b [Reads: X Index]
	adc $3E22.w,X		; 7D 22 3E ; Add $3E22.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy $1EF3.w		; CC F3 1E ; Compare $1EF3.w with Y register [Reads: Y Index] [Flags: NCZ]
	sbc ($00.b,X)		; E1 00 ; Subtract with carry ($00.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $7905FF.l		; 22 FF 05 79 ; Jump to subroutine long $7905FF.l [Writes: Stack Pointer] [Flow: call]
	.db $82, $C1, $00		; 82 C1 00 ; Branch always long to $82, $C1, $00 [Flow: branch]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $47.b		; E4 47 ; Compare $47.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $97.b		; 00 97 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$FF.b]		; 07 FF ; OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	and [$58.b]		; 27 58 ; AND accumulator with memory (long) [$58.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $F00F60.l,X		; 5F 60 0F F0 ; Exclusive OR accumulator with memory (long,X) $F00F60.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$F7.b],Y		; F7 F7 ; Subtract with carry (long indexed) [$F7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta [$9F.b]		; 87 9F ; Store accumulator (long) [$9F.b] [Reads: Direct Page, Accumulator]
	sta $010307.l		; 8F 07 03 01 ; Store accumulator (long) $010307.l [Reads: Accumulator]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	lda [$16.b]		; A7 16 ; Load accumulator (long) [$16.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $0CDF2C.l		; EF 2C DF 0C ; Subtract with carry (long) $0CDF2C.l [Writes: Accumulator] [Flags: NCVZ]
	sbc $36FF2C.l,X		; FF 2C FF 36 ; Subtract with carry (long,X) $36FF2C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $24FF08.l,X		; FF 08 FF 24 ; Subtract with carry (long,X) $24FF08.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $E1		; F0 E1 ; Branch if equal to $F0, $E1 [Flow: branch]
	cmp ($81.b,X)		; C1 81 ; Compare accumulator ($81.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	sbc [$83.b]		; E7 83 ; Subtract with carry (long) [$83.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $C4DE.w		; 2D DE C4 ; Logical AND $C4DE.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $7D7FBA.l,X		; 3F BA 7F 7D ; AND accumulator with memory (long,X) $7D7FBA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $8344.w,X		; FE 44 83 ; Increment memory $8344.w,X [Reads: X Index] [Flags: NZ]
	adc $02.b		; 65 02 ; Add $02.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$21.b		; E0 21 ; Compare #$21.b with X register [Reads: X Index] [Flags: NCZ]
	sbc ($E1.b,S),Y		; F3 E1 ; Subtract with carry (stack relative indirect indexed) ($E1.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$80.b		; C0 80 ; Compare #$80.b with Y register [Reads: Y Index] [Flags: NCZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $1E00.w,Y		; 39 00 1E ; AND accumulator with memory $1E00.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $DE.b		; 00 DE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EE.b		; 00 EE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	inc $FE00.w,X		; FE 00 FE ; Increment memory $FE00.w,X [Reads: X Index] [Flags: NZ]
	tsb $3E.b		; 04 3E ; Test and set bits $3E.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	inc $FE18.w,X		; FE 18 FE ; Increment memory $FE18.w,X [Reads: X Index] [Flags: NZ]
	sbc $F1FDFF.l,X		; FF FF FD F1 ; Subtract with carry (long,X) $F1FDFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($E1.b),Y		; F1 E1 ; Subtract with carry ($E1.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp ($C1.b,X)		; C1 C1 ; Compare accumulator ($C1.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	trb $0CFF.w		; 1C FF 0C ; Test and reset bits $0CFF.w [Reads: Accumulator] [Flags: Z]
	mvp $04,$FE		; 44 FE 04 ; Move block positive $04,$FE [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $0C.b,S		; 03 0C ; OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $3E00.w,X		; DE 00 3E ; Decrement memory $3E00.w,X [Reads: X Index] [Flags: NZ]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $C000.w,X		; FE 00 C0 ; Increment memory $C000.w,X [Reads: X Index] [Flags: NZ]
	and $E1.b,S		; 23 E1 ; AND accumulator with stack relative $E1.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $F1.b		; 04 F1 ; Test and set bits $F1.b [Reads: Accumulator] [Flags: Z]
	sbc $0FFF.w,X		; FD FF 0F ; Subtract with carry $0FFF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $49		; 70 49 ; Branch if overflow set to $70, $49 [Flow: branch]
	tsb $0377.w		; 0C 77 03 ; Test and set bits $0377.w [Reads: Accumulator] [Flags: Z]
	trb $3C67.w		; 1C 67 3C ; Test and reset bits $3C67.w [Reads: Accumulator] [Flags: Z]
	eor [$27.b]		; 47 27 ; Exclusive OR accumulator with memory (long) [$27.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $80, $05		; 80 05 ; Branch always to $80, $05 [Flow: branch]
	ror $1F83.w,X		; 7E 83 1F ; Rotate right $1F83.w,X [Reads: X Index] [Flags: NCZ]
	ora ($0D.b,X)		; 01 0D ; Logical OR ($0D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ror $49.b,X		; 76 49 ; Rotate right $49.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tsb $0177.w		; 0C 77 01 ; Test and set bits $0177.w [Reads: Accumulator] [Flags: Z]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $80.b		; 25 80 ; Logical AND $80.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $000302.l,X		; FF 02 03 00 ; Subtract with carry (long,X) $000302.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$44.b]		; 07 44 ; OR accumulator with memory (long) [$44.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$7E.b]		; 07 7E ; OR accumulator with memory (long) [$7E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E1.b		; 00 E1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CE.b		; 00 CE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $FF26.w		; 0E 26 FF ; Arithmetic shift left $FF26.w [Flags: NCZ]
	cpx #$28.b		; E0 28 ; Compare #$28.b with X register [Reads: X Index] [Flags: NCZ]
	sbc ($88.b),Y		; F1 88 ; Subtract with carry ($88.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $020FA8.l		; 0F A8 0F 02 ; OR accumulator with memory (long) $020FA8.l [Writes: Accumulator] [Flags: NZ]
	ora [$0D.b]		; 07 0D ; OR accumulator with memory (long) [$0D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$C1.b]		; 07 C1 ; OR accumulator with memory (long) [$C1.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $96.b,S		; C3 96 ; Compare accumulator (stack relative) $96.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	sbc ($45.b,S),Y		; F3 45 ; Subtract with carry (stack relative indirect indexed) ($45.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	adc $3E3A.w,X		; 7D 3A 3E ; Add $3E3A.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	bit $820C.w,X		; 3C 0C 82 ; Test bits $820C.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	cmp ($99.b,X)		; C1 99 ; Compare accumulator ($99.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $77.b		; 00 77 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $AA.b		; 00 AA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta $8D.b		; 85 8D ; Store accumulator to $8D.b [Reads: Accumulator]
	.db $50, $DD		; 50 DD ; Branch if overflow clear to $50, $DD [Flow: branch]
	eor ($D2.b)		; 52 D2 ; Exclusive OR accumulator with memory (indirect) ($D2.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $DF		; 10 DF ; Branch if plus to $10, $DF [Flow: branch]
	jsl $770CFF.l		; 22 FF 0C 77 ; Jump to subroutine long $770CFF.l [Writes: Stack Pointer] [Flow: call]
	adc ($22.b)		; 72 22 ; Add with carry (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and $CC20.w		; 2D 20 CC ; Logical AND $CC20.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $DE.b		; 00 DE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $73.b		; 00 73 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $AD.b		; 00 AD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $5243.w		; 8C 43 52 ; Store Y register to $5243.w [Reads: Y Index]
	dec $1203.w,X		; DE 03 12 ; Decrement memory $1203.w,X [Reads: X Index] [Flags: NZ]
	ora ($01.b)		; 12 01 ; OR accumulator with memory (indirect) ($01.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $E0FF22.l,X		; DF 22 FF E0 ; Compare accumulator (long,X) $E0FF22.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	bit $73.b		; 24 73 ; Test bits $73.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	and ($21.b,X)		; 21 21 ; Logical AND ($21.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $D820.w		; ED 20 D8 ; Subtract $D820.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ora $700766.l,X		; 1F 66 07 70 ; Logical OR long $700766.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $E7.b		; 00 E7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$D0.b]		; 07 D0 ; OR accumulator with memory (long) [$D0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0D68.w,X		; 1D 68 0D ; OR accumulator with memory $0D68.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc ($03.b)		; 72 03 ; Add with carry (indirect) ($03.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	ora $F8E0.w		; 0D E0 F8 ; Logical OR $F8E0.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $F2E2F8.l,X		; FF F8 E2 F2 ; Subtract with carry (long,X) $F2E2F8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($D0F2.w,X)		; FC F2 D0 ; Jump to subroutine indirect indexed ($D0F2.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora $0DEC.w,X		; 1D EC 0D ; OR accumulator with memory $0DEC.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	ror $430F.w		; 6E 0F 43 ; Rotate right $430F.w [Flags: NCZ]
	.db $D0, $1D		; D0 1D ; Branch if not equal to $D0, $1D [Flow: branch]
	ora $310F6E.l,X		; 1F 6E 0F 31 ; Logical OR long $310F6E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($E2.b,X)		; 01 E2 ; Logical OR ($E2.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc ($FF.b)		; F2 FF ; Subtract with carry (indirect) ($FF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $E2		; F0 E2 ; Branch if equal to $F0, $E2 [Flow: branch]
.ACCU 8
.INDEX 8
	sep #$F0		; E2 F0
	inc $00FF.w,X		; FE FF 00 ; Increment memory $00FF.w,X [Reads: X Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	brk $75.b		; 00 75 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $F6.b,X		; 75 F6 ; Add $F6.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $F3.b		; 00 F3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $67B9.w		; 4E B9 67 ; Logical shift right $67B9.w [Flags: NCZ]
	sbc $FFFFF0.l,X		; FF F0 FF FF ; Subtract with carry (long,X) $FFFFF0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $90.b,S		; 83 90 ; Store accumulator (stack relative) $90.b,S [Reads: Stack Pointer, Accumulator]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $50, $75		; [PATTERN: Memory clearing operation] 50 75 ; Branch if overflow clear to $50, $75 [Flow: branch]
	lda ($D6.b,X)		; A1 D6 ; Load accumulator ($D6.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc [$80.b],Y		; 77 80 ; Add with carry (long indexed) [$80.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	stz $AB.b,X		; 74 AB ; Store zero to $AB.b,X [Reads: X Index]
	stz $DF71.w,X		; 9E 71 DF ; Store zero to $DF71.w,X [Reads: X Index]
	jsr $A083.w		; 20 83 A0 ; Jump to subroutine at $A083.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsl $308F00.l		; 22 00 8F 30 ; Jump to subroutine long $308F00.l [Writes: Stack Pointer] [Flow: call]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $00438C.l,X		; FF 8C 43 00 ; Subtract with carry (long,X) $00438C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $52.b,S		; 43 52 ; Exclusive OR accumulator with stack relative $52.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $5483.w,X		; DE 83 54 ; Decrement memory $5483.w,X [Reads: X Index] [Flags: NZ]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $5B24F0.l,X		; FF F0 24 5B ; Subtract with carry (long,X) $5B24F0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $D0, $1D		; D0 1D ; Branch if not equal to $D0, $1D [Flow: branch]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	cpx #$59.b		; E0 59 ; Compare #$59.b with X register [Reads: X Index] [Flags: NCZ]
	cmp ($5E.b),Y		; D1 5E ; Compare accumulator ($5E.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	brk $D3.b		; 00 D3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	sbc ($5E.b),Y		; F1 5E ; Subtract with carry ($5E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($FE7E.w,X)		; FC 7E FE ; Jump to subroutine indirect indexed ($FE7E.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	lsr $7FCE.w		; 4E CE 7F ; Logical shift right $7FCE.w [Flags: NCZ]
	sbc $20FE01.l,X		; FF 01 FE 20 ; Subtract with carry (long,X) $20FE01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $030E.w		; 2C 0E 03 ; Test bits $030E.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	ora ($31.b,X)		; 01 31 ; Logical OR ($31.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $1E.b		; E6 1E ; Increment $1E.b [Reads: Direct Page] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $30, $4F		; 30 4F ; Branch if minus to $30, $4F [Flow: branch]
	lda $DDBF5F.l		; AF 5F BF DD ; Load long $DDBF5F.l into accumulator [Writes: Accumulator] [Flags: NZ]
	lda $B9D9.w,X		; BD D9 B9 ; Load $B9D9.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $0FF09F.l		; 6F 9F F0 0F ; Add with carry (long) $0FF09F.l [Writes: Accumulator] [Flags: NCVZ]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda ($FD.b,S),Y		; B3 FD ; Load accumulator (stack relative indirect indexed) ($FD.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $F8.b		; 26 F8 ; Rotate left $F8.b [Reads: Direct Page] [Flags: NCZ]
	asl $F9F1.w		; 0E F1 F9 ; Arithmetic shift left $F9F1.w [Flags: NCZ]
	asl $F3.b		; 06 F3 ; Arithmetic shift left $F3.b [Reads: Direct Page] [Flags: NCZ]
	sta $30.b,S		; 83 30 ; Store accumulator (stack relative) $30.b,S [Reads: Stack Pointer, Accumulator]
	cmp $F8EF10.l		; CF 10 EF F8 ; Compare accumulator (long) $F8EF10.l [Reads: Accumulator] [Flags: NCZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0000.w		; 0C 00 00 ; Test and set bits $0000.w [Reads: Accumulator] [Flags: Z]
	clv		; B8 ; Clear overflow flag [Flags: V]
	ldy #$6D.b		; A0 6D ; Load #$6D.b into Y register [Writes: Y Index] [Flags: NZ]
	adc $9E.b,S		; 63 9E ; Add with carry (stack relative) $9E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F90E.w,Y		; F9 0E F9 ; Subtract with carry $F90E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $CBFB00.l,X		; FF 00 FB CB ; Subtract with carry (long,X) $CBFB00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $D7		; 30 D7 ; Branch if minus to $30, $D7 [Flow: branch]
	.db $30, $DF		; 30 DF ; Branch if minus to $30, $DF [Flow: branch]
	eor [$90.b]		; 47 90 ; Exclusive OR accumulator with memory (long) [$90.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $041200.l		; 22 00 12 04 ; Jump to subroutine long $041200.l [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $C7.b		; 00 C7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BA.b		; 00 BA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $82, $43, $C3		; 82 43 C3 ; Branch always long to $82, $43, $C3 [Flow: branch]
	eor $C7.b,X		; 55 C7 ; Exclusive OR accumulator with memory $C7.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $C7.b		; 00 C7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $C7		; 10 C7 ; Branch if plus to $10, $C7 [Flow: branch]
	jsl $7D01FF.l		; 22 FF 01 7D ; Jump to subroutine long $7D01FF.l [Writes: Stack Pointer] [Flow: call]
	bit $3822.w,X		; 3C 22 38 ; Test bits $3822.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	ora $CF0087.l		; 0F 87 00 CF ; OR accumulator with memory (long) $CF0087.l [Writes: Accumulator] [Flags: NZ]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $65.b		; 00 65 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0D.b		; 05 0D ; Logical OR $0D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $8DA8.w		; 0D A8 8D ; Logical OR $8DA8.w with accumulator [Writes: Accumulator] [Flags: NZ]
	bit $FF.b		; 24 FF ; Test bits $FF.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	trb $FA.b		; 14 FA ; Test and reset bits $FA.b [Reads: Accumulator] [Flags: Z]
	sbc ($72.b)		; F2 72 ; Subtract with carry (indirect) ($72.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $D0, $1F		; D0 1F ; Branch if not equal to $D0, $1F [Flow: branch]
	cpx $700F.w		; EC 0F 70 ; Compare $700F.w with X register [Reads: X Index] [Flags: NCZ]
	brk $35.b		; 00 35 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E4.b		; 00 E4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$D8.b]		; 07 D8 ; OR accumulator with memory (long) [$D8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $E00FCC.l,X		; 1F CC 0F E0 ; Logical OR long $E00FCC.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $22		; F0 22 ; Branch if equal to $F0, $22 [Flow: branch]
	sbc $E0F813.l,X		; FF 13 F8 E0 ; Subtract with carry (long,X) $E0F813.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $E1		; F0 E1 ; Branch if equal to $F0, $E1 [Flow: branch]
	ora ($74.b,X)		; 01 74 ; Logical OR ($74.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $35.b		; 00 35 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $63.b		; 00 63 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $E6.b,S		; 03 E6 ; OR accumulator with stack relative $E6.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$E8.b]		; 07 E8 ; OR accumulator with memory (long) [$E8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $C6.b		; 00 C6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$FE.b]		; 07 FE ; OR accumulator with memory (long) [$FE.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $FC1DFF.l		; 22 FF 1D FC ; Jump to subroutine long $FC1DFF.l [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $003FF8.l,X		; FF F8 3F 00 ; Subtract with carry (long,X) $003FF8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $18EB00.l,X		; 7F 00 EB 18 ; Add long $18EB00.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $2C.b,X		; D5 2C ; Compare accumulator $2C.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	nop		; EA ; No operation
	rol $D5.b,X		; 36 D5 ; Rotate left $D5.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	ora $06E5.w		; 0D E5 06 ; Logical OR $06E5.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $C3E7FF.l,X		; FF FF E7 C3 ; Subtract with carry (long,X) $C3E7FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp ($E0.b,X)		; C1 E0 ; Compare accumulator ($E0.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora $07E443.l		; 0F 43 E4 07 ; OR accumulator with memory (long) $07E443.l [Writes: Accumulator] [Flags: NZ]
	cpx #$2C.b		; E0 2C ; Compare #$2C.b with X register [Reads: X Index] [Flags: NCZ]
	sta ($03.b)		; 92 03 ; Store accumulator (indirect) ($03.b) [Reads: Direct Page, Accumulator]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cmp ($25.b,X)		; C1 25 ; Compare accumulator ($25.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	sbc ($12.b,X)		; E1 12 ; Subtract with carry ($12.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	jsr ($F8F0.w,X)		; FC F0 F8 ; Jump to subroutine indirect indexed ($F8F0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($1E3E.w,X)		; FC 3E 1E ; Jump to subroutine indirect indexed ($1E3E.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora $EF2803.l		; 0F 03 28 EF ; OR accumulator with memory (long) $EF2803.l [Writes: Accumulator] [Flags: NZ]
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $D0, $F9		; D0 F9 ; Branch if not equal to $D0, $F9 [Flow: branch]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc $BFBFFF.l,X		; FF FF BF BF ; Subtract with carry (long,X) $BFBFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $FF009F.l,X		; 9F 9F 00 FF ; Store accumulator (long,X) $FF009F.l,X [Reads: Accumulator, X Index]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	asl $04.b		; 06 04 ; Arithmetic shift left $04.b [Reads: Direct Page] [Flags: NCZ]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $82.b		; 00 82 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $DF44F0.l		; 8F F0 44 DF ; Store accumulator (long) $DF44F0.l [Reads: Accumulator]
	eor [$08.b],Y		; 57 08 ; Exclusive OR accumulator with memory (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora [$DF.b]		; 07 DF ; OR accumulator with memory (long) [$DF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $DFFD.w		; AD FD DF ; Load $DFFD.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $70FF00.l,X		; FF 00 FF 70 ; Subtract with carry (long,X) $70FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $20.b,S		; 23 20 ; AND accumulator with stack relative $20.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $3E.b,S		; 43 3E ; Exclusive OR accumulator with stack relative $3E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $FF9E0B.l,X		; FF 0B 9E FF ; Subtract with carry (long,X) $FF9E0B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $9E3F.w		; 2E 3F 9E ; Rotate left $9E3F.w [Flags: NCZ]
	sbc $1ECF0E.l,X		; FF 0E CF 1E ; Subtract with carry (long,X) $1ECF0E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $22FF1E.l,X		; DF 1E FF 22 ; Compare accumulator (long,X) $22FF1E.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $00,$C0		; 44 C0 00 ; Move block positive $00,$C0 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	.db $30, $20		; 30 20 ; Branch if minus to $30, $20 [Flow: branch]
	brk $8E.b		; 00 8E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $447F72.l,X		; FF 72 7F 44 ; Subtract with carry (long,X) $447F72.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$72.b]		; 07 72 ; OR accumulator with memory (long) [$72.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $3EFF0E.l,X		; 7F 0E FF 3E ; Add long $3EFF0E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $32F7B6.l,X		; FF B6 F7 32 ; Subtract with carry (long,X) $32F7B6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($00.b,S),Y		; F3 00 ; Subtract with carry (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $F8		; 80 F8 ; Branch always to $80, $F8 [Flow: branch]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $BF9E.w		; 0C 9E BF ; Test and set bits $BF9E.w [Reads: Accumulator] [Flags: Z]
	bit $C8FE.w		; 2C FE C8 ; Test bits $C8FE.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	sbc $FBF0.w,X		; FD F0 FB ; Subtract with carry $FBF0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $62, $77, $C3		; 62 77 C3 ; Push effective relative address $62, $77, $C3 [Writes: Stack Pointer]
	inc $DD83.w		; EE 83 DD ; Increment $DD83.w [Flags: NZ]
	tsb $BB.b		; 04 BB ; Test and set bits $BB.b [Reads: Accumulator] [Flags: Z]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $88.b		; 04 88 ; Test and set bits $88.b [Reads: Accumulator] [Flags: Z]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sty $9BF3.w		; 8C F3 9B ; Store Y register to $9BF3.w [Reads: Y Index]
	jmp ($9C73.w)		; 6C 73 9C ; Jump indirect to ($9C73.w) [Flow: jump]
	adc [$B9.b]		; 67 B9 ; Add with carry (long) [$B9.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp $E79F73.l		; CF 73 9F E7 ; Compare accumulator (long) $E79F73.l [Reads: Accumulator] [Flags: NCZ]
	rol $7DCF.w,X		; 3E CF 7D ; Rotate left $7DCF.w,X [Reads: X Index] [Flags: NCZ]
	sta $140022.l,X		; 9F 22 00 14 ; Store accumulator (long,X) $140022.l,X [Reads: Accumulator, X Index]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $EB42BD.l,X		; 1F BD 42 EB ; Logical OR long $EB42BD.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	trb $DF.b		; 14 DF ; Test and reset bits $DF.b [Reads: Accumulator] [Flags: Z]
	jsr $51AF.w		; 20 AF 51 ; Jump to subroutine at $51AF.w [Writes: Stack Pointer] [Flow: call]
	cmp $47BF23.l,X		; DF 23 BF 47 ; Compare accumulator (long,X) $47BF23.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	inc $FD0F.w,X		; FE 0F FD ; Increment memory $FD0F.w,X [Reads: X Index] [Flags: NZ]
	ora $840022.l,X		; 1F 22 00 84 ; Logical OR long $840022.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	cop $E0.b		; 02 E0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	sbc $080F04.l,X		; FF 04 0F 08 ; Subtract with carry (long,X) $080F04.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $FC00.w,X		; FE 00 FC ; Increment memory $FC00.w,X [Reads: X Index] [Flags: NZ]
	cpy #$F8.b		; C0 F8 ; Compare #$F8.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $80, $FC		; 80 FC ; Branch always to $80, $FC [Flow: branch]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F9.b		; 00 F9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($07.b,S),Y		; F3 07 ; Subtract with carry (stack relative indirect indexed) ($07.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cmp $F3039F.l		; CF 9F 03 F3 ; Compare accumulator (long) $F3039F.l [Reads: Accumulator] [Flags: NCZ]
	ora $B4.b,S		; 03 B4 ; OR accumulator with stack relative $B4.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc [$59.b],Y		; 77 59 ; Add with carry (long indexed) [$59.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $D3DFA3.l,X		; BF A3 DF D3 ; Load long $D3DFA3.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $847749.l		; EF 49 77 84 ; Subtract with carry (long) $847749.l [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	and ($FD.b)		; 32 FD ; AND accumulator with memory (indirect) ($FD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $08FE.w,Y		; 79 FE 08 ; Add $08FE.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $800000.l		; 22 00 00 80 ; Jump to subroutine long $800000.l [Writes: Stack Pointer] [Flow: call]
	jsl $28E000.l		; 22 00 E0 28 ; Jump to subroutine long $28E000.l [Writes: Stack Pointer] [Flow: call]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	ror $37.b,X		; 76 37 ; Rotate right $37.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	lsr $AE5F.w,X		; 5E 5F AE ; Logical shift right $AE5F.w,X [Reads: X Index] [Flags: NCZ]
	lda $BA7776.l		; AF 76 77 BA ; Load long $BA7776.l into accumulator [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	jsr ($01FD.w,X)		; FC FD 01 ; Jump to subroutine indirect indexed ($01FD.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $C8D4.w,X		; FE D4 C8 ; Increment memory $C8D4.w,X [Reads: X Index] [Flags: NZ]
	ldy #$50.b		; A0 50 ; Load #$50.b into Y register [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	mvp $00,$02		; 44 02 00 ; Move block positive $00,$02 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cmp $27FD01.l,X		; DF 01 FD 27 ; Compare accumulator (long,X) $27FD01.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	lda $21BF23.l,X		; BF 23 BF 21 ; Load long $21BF23.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	wai		; CB ; Wait for interrupt
	tsb $B9.b		; 04 B9 ; Test and set bits $B9.b [Reads: Accumulator] [Flags: Z]
	rol $9D.b		; 26 9D ; Rotate left $9D.b [Reads: Direct Page] [Flags: NCZ]
	asl $AF.b		; 06 AF ; Arithmetic shift left $AF.b [Reads: Direct Page] [Flags: NCZ]
	and ($E0.b)		; 32 E0 ; AND accumulator with memory (indirect) ($E0.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $F014C0.l		; 22 C0 14 F0 ; Jump to subroutine long $F014C0.l [Writes: Stack Pointer] [Flow: call]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: NCZ]
	cpy #$D3.b		; C0 D3 ; Compare #$D3.b with Y register [Reads: Y Index] [Flags: NCZ]
	trb $32ED.w		; 1C ED 32 ; Test and reset bits $32ED.w [Reads: Accumulator] [Flags: Z]
	stz $AF27.w		; 9C 27 AF ; Store zero to $AF27.w
	and ($C3.b)		; 32 C3 ; AND accumulator with memory (indirect) ($C3.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $8F.b		; 04 8F ; Test and set bits $8F.b [Reads: Accumulator] [Flags: Z]
	.db $30, $8B		; 30 8B ; Branch if minus to $30, $8B [Flow: branch]
	trb $99.b		; 14 99 ; Test and reset bits $99.b [Reads: Accumulator] [Flags: Z]
	rol $E0.b		; 26 E0 ; Rotate left $E0.b [Reads: Direct Page] [Flags: NCZ]
	jsl $F814C0.l		; 22 C0 14 F8 ; Jump to subroutine long $F814C0.l [Writes: Stack Pointer] [Flow: call]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: NCZ]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: NCZ]
	brk $5C.b		; 00 5C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $00FF08.l,X		; FF 08 FF 00 ; Subtract with carry (long,X) $00FF08.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FF00FF.l,X		; FF FF 00 FF ; Subtract with carry (long,X) $FF00FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $807FC6.l,X		; 7F C6 7F 80 ; Add long $807FC6.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $0026FF.l,X		; 7F FF 26 00 ; Add long $0026FF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $80.b,S		; 03 80 ; OR accumulator with stack relative $80.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $80, $7C		; 80 7C ; Branch always to $80, $7C [Flow: branch]
	sbc $7FC043.l,X		; FF 43 C0 7F ; Subtract with carry (long,X) $7FC043.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $35.b,S		; 83 35 ; Store accumulator (stack relative) $35.b,S [Reads: Stack Pointer, Accumulator]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	trb $83.b		; 14 83 ; Test and reset bits $83.b [Reads: Accumulator] [Flags: Z]
	sec		; 38 ; Set carry flag [Flags: C]
	ora $26.b,S		; 03 26 ; OR accumulator with stack relative $26.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $774E70.l		; 0F 70 4E 77 ; OR accumulator with memory (long) $774E70.l [Writes: Accumulator] [Flags: NZ]
	tsb $4C77.w		; 0C 77 4C ; Test and set bits $4C77.w [Reads: Accumulator] [Flags: Z]
	adc [$6C.b],Y		; 77 6C ; Add with carry (long indexed) [$6C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc [$6E.b],Y		; 77 6E ; Add with carry (long indexed) [$6E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc [$83.b],Y		; 77 83 ; Add with carry (long indexed) [$83.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $62, $03, $27		; 62 03 27 ; Push effective relative address $62, $03, $27 [Writes: Stack Pointer]
	.db $80, $06		; 80 06 ; Branch always to $80, $06 [Flow: branch]
	ldy $4CC7.w,X		; BC C7 4C ; Load Y register $4CC7.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	adc [$0C.b],Y		; 77 0C ; Add with carry (long indexed) [$0C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc [$0E.b],Y		; 77 0E ; Add with carry (long indexed) [$0E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sty $65.b		; 84 65 ; Store Y register to $65.b [Reads: Y Index]
	ora $83.b,S		; 03 83 ; OR accumulator with stack relative $83.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $26.b		; 00 26 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $10		; 80 10 ; Branch always to $80, $10 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $3F.b		; 46 3F ; Logical shift right $3F.b [Reads: Direct Page] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	eor $0F6F50.l,X		; 5F 50 6F 0F ; Exclusive OR accumulator with memory (long,X) $0F6F50.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $70, $0F		; 70 0F ; Branch if overflow set to $70, $0F [Flow: branch]
	adc [$0E.b],Y		; 77 0E ; Add with carry (long indexed) [$0E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $0D.b,X		; 75 0D ; Add $0D.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $FF.b,X		; 76 FF ; Rotate right $FF.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	rol $80.b		; 26 80 ; Rotate left $80.b [Reads: Direct Page] [Flags: NCZ]
	.db $10, $8C		; 10 8C ; Branch if plus to $10, $8C [Flow: branch]
	adc [$4E.b],Y		; 77 4E ; Add with carry (long indexed) [$4E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$2E.b],Y		; F7 2E ; Subtract with carry (long indexed) [$2E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$1C.b],Y		; F7 1C ; Subtract with carry (long indexed) [$1C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$FC.b],Y		; F7 FC ; Subtract with carry (long indexed) [$FC.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $42FBF8.l		; 0F F8 FB 42 ; OR accumulator with memory (long) $42FBF8.l [Writes: Accumulator] [Flags: NZ]
	sbc $80FF01.l,X		; FF 01 FF 80 ; Subtract with carry (long,X) $80FF01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx #$25.b		; E0 25 ; Compare #$25.b with X register [Reads: X Index] [Flags: NCZ]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $D9.b		; 00 D9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $03E3.w,X		; 1E E3 03 ; Arithmetic shift left $03E3.w,X [Reads: X Index] [Flags: NCZ]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	and ($03.b,S),Y		; 33 03 ; AND accumulator (stack relative indirect indexed) ($03.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ror $07.b,X		; 76 07 ; Rotate right $07.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc $06.b		; E5 06 ; Subtract $06.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0E.b		; C9 0E ; Compare #$0E.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	sbc ($03.b,S),Y		; F3 03 ; Subtract with carry (stack relative indirect indexed) ($03.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$FC.b		; E0 FC ; Compare #$FC.b with X register [Reads: X Index] [Flags: NCZ]
	sbc $F8F8FC.l,X		; FF FC F8 F8 ; Subtract with carry (long,X) $F8F8FC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $FC		; F0 FC ; Branch if equal to $F0, $FC [Flow: branch]
	asl $1C12.w,X		; 1E 12 1C ; Arithmetic shift left $1C12.w,X [Reads: X Index] [Flags: NCZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	asl $0FF9.w		; 0E F9 0F ; Arithmetic shift left $0FF9.w [Flags: NCZ]
	.db $F0, $FF		; F0 FF ; Branch if equal to $F0, $FF [Flow: branch]
	tsb $FF.b		; 04 FF ; Test and set bits $FF.b [Reads: Accumulator] [Flags: Z]
	eor $FC.b,S		; 43 FC ; Exclusive OR accumulator with stack relative $FC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc ($26.b,X)		; E1 26 ; Subtract with carry ($26.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $45.b		; 00 45 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0977.w		; 0C 77 09 ; Test and set bits $0977.w [Reads: Accumulator] [Flags: Z]
	cpy $FCF7.w		; CC F7 FC ; Compare $FCF7.w with Y register [Reads: Y Index] [Flags: NCZ]
	adc [$FF.b]		; 67 FF ; Add with carry (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	asl $C0BF.w		; 0E BF C0 ; Arithmetic shift left $C0BF.w [Flags: NCZ]
	ora $802260.l,X		; 1F 60 22 80 ; Logical OR long $802260.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$80.b],Y		; 17 80 ; OR accumulator with memory (long indexed) [$80.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	rol $7DFA.w,X		; 3E FA 7D ; Rotate left $7DFA.w,X [Reads: X Index] [Flags: NCZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc $FDF3.w,X		; FD F3 FD ; Subtract with carry $FDF3.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FB.b		; E5 FB ; Subtract $FB.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sbc [$F7.b],Y		; F7 F7 ; Subtract with carry (long indexed) [$F7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $3E7FBF.l		; 8F BF 7F 3E ; Store accumulator (long) $3E7FBF.l [Reads: Accumulator]
	jmp ($FCFC.w,X)		; 7C FC FC ; Jump indirect indexed to ($FCFC.w,X) [Reads: X Index] [Flow: jump]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $80		; F0 80 ; Branch if equal to $F0, $80 [Flow: branch]
	eor $00.b		; 45 00 ; Exclusive OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $F7FF0C.l,X		; FF 0C FF F7 ; Subtract with carry (long,X) $F7FF0C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $E7FFF0.l,X		; FF F0 FF E7 ; Subtract with carry (long,X) $E7FFF0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F8F80F.l,X		; FF 0F F8 F8 ; Subtract with carry (long,X) $F8F80F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $00F801.l,X		; FF 01 F8 00 ; Subtract with carry (long,X) $00F801.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $FD.b		; 45 FD ; Exclusive OR $FD.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $F903.w,X		; 3E 03 F9 ; Rotate left $F903.w,X [Reads: X Index] [Flags: NCZ]
	rol $3EE3.w,X		; 3E E3 3E ; Rotate left $3EE3.w,X [Reads: X Index] [Flags: NCZ]
	eor $F6.b		; 45 F6 ; Exclusive OR $F6.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $3E24.w,X		; 3D 24 3E ; AND accumulator with memory $3E24.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $FF443C.l		; 22 3C 44 FF ; Jump to subroutine long $FF443C.l [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $3FFF45.l,X		; 1F 45 FF 3F ; Logical OR long $3FFF45.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $FC.b		; 06 FC ; Arithmetic shift left $FC.b [Reads: Direct Page] [Flags: NCZ]
	and $003EFD.l,X		; 3F FD 3E 00 ; AND accumulator with memory (long,X) $003EFD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $3F.b,S		; 23 3F ; AND accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $3E.b		; 04 3E ; Test and set bits $3E.b [Reads: Accumulator] [Flags: Z]
	pea $FA3B.w		; F4 3B FA ; Push absolute address $FA3B.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	and $FD43.w,X		; 3D 43 FD ; AND accumulator with memory $FD43.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $7D09.w,X		; FE 09 7D ; Increment memory $7D09.w,X [Reads: X Index] [Flags: NZ]
	inc $7EB9.w,X		; FE B9 7E ; Increment memory $7EB9.w,X [Reads: X Index] [Flags: NZ]
	eor ($BE.b,X)		; 41 BE ; Exclusive OR accumulator with memory ($BE.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $3C38C0.l,X		; 3F C0 38 3C ; AND accumulator with memory (long,X) $3C38C0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $7E01FE.l		; 22 FE 01 7E ; Jump to subroutine long $7E01FE.l [Writes: Stack Pointer] [Flow: call]
	rol $60E4.w,X		; 3E E4 60 ; Rotate left $60E4.w,X [Reads: X Index] [Flags: NCZ]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $01		; 80 01 ; Branch always to $80, $01 [Flow: branch]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	adc $B900.w,X		; 7D 00 B9 ; Add $B900.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $82		; 80 82 ; Branch always to $80, $82 [Flow: branch]
	.db $82, $0C, $8E		; 82 0C 8E ; Branch always long to $82, $0C, $8E [Flow: branch]
	eor $D7DF.w,Y		; 59 DF D7 ; Exclusive OR accumulator with memory $D7DF.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $FF22.w,Y		; 59 22 FF ; Exclusive OR accumulator with memory $FF22.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tsb $7F.b		; 04 7F ; Test and set bits $7F.b [Reads: Accumulator] [Flags: Z]
	adc $2071.w,X		; 7D 71 20 ; Add $2071.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr $47E4.w		; 20 E4 47 ; Jump to subroutine at $47E4.w [Writes: Stack Pointer] [Flow: call]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $20C010.l		; EF 10 C0 20 ; Subtract with carry (long) $20C010.l [Writes: Accumulator] [Flags: NCVZ]
	sta $179FC8.l		; 8F C8 9F 17 ; Store accumulator (long) $179FC8.l [Reads: Accumulator]
	lda $20BF2F.l,X		; BF 2F BF 20 ; Load long $20BF2F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $1E.b,S		; 83 1E ; Store accumulator (stack relative) $1E.b,S [Reads: Stack Pointer, Accumulator]
	tsb $0A.b		; 04 0A ; Test and set bits $0A.b [Reads: Accumulator] [Flags: Z]
	sbc $6730DF.l		; EF DF 30 67 ; Subtract with carry (long) $6730DF.l [Writes: Accumulator] [Flags: NCVZ]
	eor $007F40.l		; 4F 40 7F 00 ; Exclusive OR accumulator with memory (long) $007F40.l [Writes: Accumulator] [Flags: NZ]
	sbc $430400.l,X		; FF 00 04 43 ; Subtract with carry (long,X) $430400.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: NCZ]
	cpy #$F8.b		; C0 F8 ; Compare #$F8.b with Y register [Reads: Y Index] [Flags: NCZ]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ora $DF.b,S		; 03 DF ; OR accumulator with stack relative $DF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $01F307.l		; CF 07 F3 01 ; Compare accumulator (long) $01F307.l [Reads: Accumulator] [Flags: NCZ]
	ora [$F0.b]		; 07 F0 ; OR accumulator with memory (long) [$F0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc [$F1.b]		; E7 F1 ; Subtract with carry (long) [$F1.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inc $CCF2.w		; EE F2 CC ; Increment $CCF2.w [Flags: NZ]
	.db $F0, $DD		; F0 DD ; Branch if equal to $F0, $DD [Flow: branch]
	sbc ($43.b,X)		; E1 43 ; Subtract with carry ($43.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $1C06E3.l,X		; DF E3 06 1C ; Compare accumulator (long,X) $1C06E3.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	sbc $08.b,S		; E3 08 ; Subtract stack-relative $08.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $0BFF.w,X		; 7E FF 0B ; Rotate right $0BFF.w,X [Reads: X Index] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $3FF00F.l,X		; FF 0F F0 3F ; Subtract with carry (long,X) $3FF00F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E6.b		; 00 E6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$CE.b]		; 27 CE ; AND accumulator with memory (long) [$CE.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $0C0023.l		; 4F 23 00 0C ; Exclusive OR accumulator with memory (long) $0C0023.l [Writes: Accumulator] [Flags: NZ]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $30, $80		; 30 80 ; Branch if minus to $30, $80 [Flow: branch]
	adc $2AFF9E.l,X		; 7F 9E FF 2A ; Add long $2AFF9E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	rol $9F43.w,X		; 3E 43 9F ; Rotate left $9F43.w,X [Reads: X Index] [Flags: NCZ]
	asl $CF1A.w,X		; 1E 1A CF ; Arithmetic shift left $CF1A.w,X [Reads: X Index] [Flags: NCZ]
	sta $62.b,S		; 83 62 ; Store accumulator (stack relative) $62.b,S [Reads: Stack Pointer, Accumulator]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy $04.b		; C4 04 ; Compare $04.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $30, $1C		; 30 1C ; Branch if minus to $30, $1C [Flow: branch]
	cmp $FF3E.w		; CD 3E FF ; Compare $FF3E.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($DE1D.w,X)		; 7C 1D DE ; Jump indirect indexed to ($DE1D.w,X) [Reads: X Index] [Flow: jump]
	ror $BABF.w,X		; 7E BF BA ; Rotate right $BABF.w,X [Reads: X Index] [Flags: NCZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	lda ($B3.b)		; B2 B3 ; Load accumulator (indirect) ($B3.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $223F.w,X		; 3E 3F 22 ; Rotate left $223F.w,X [Reads: X Index] [Flags: NCZ]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $4440.w		; 20 40 44 ; Jump to subroutine at $4440.w [Writes: Stack Pointer] [Flow: call]
	jmp $4CC0.w		; 4C C0 4C ; Jump to $4CC0.w [Flow: jump]
	adc [$0C.b],Y		; 77 0C ; Add with carry (long indexed) [$0C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($6E.b,S),Y		; 73 6E ; Add with carry (stack relative indirect indexed) ($6E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	adc ($4F.b),Y		; 71 4F ; Add with carry ($4F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $18		; 70 18 ; Branch if overflow set to $70, $18 [Flow: branch]
	adc $30.b,S		; 63 30 ; Add with carry (stack relative) $30.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	wai		; CB ; Wait for interrupt
	pea $CC0F.w		; F4 0F CC ; Push absolute address $CC0F.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	eor [$23.b],Y		; 57 23 ; Exclusive OR accumulator with memory (long indexed) [$23.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $80, $1B		; 80 1B ; Branch always to $80, $1B [Flow: branch]
	sty $04.b		; 84 04 ; Store Y register to $04.b [Reads: Y Index]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $4CB7.w		; AC B7 4C ; Load $4CB7.w into Y register [Writes: Y Index] [Flags: NZ]
	adc [$CF.b],Y		; 77 CF ; Add with carry (long indexed) [$CF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $AF		; F0 AF ; Branch if equal to $F0, $AF [Flow: branch]
	and ($FC.b,S),Y		; 33 FC ; AND accumulator (stack relative indirect indexed) ($FC.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $78.b,X		; 35 78 ; Logical AND $78.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $3C.b,S		; 03 3C ; OR accumulator with stack relative $3C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor [$4C.b]		; 47 4C ; Exclusive OR accumulator with memory (long) [$4C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc [$40.b],Y		; 77 40 ; Add with carry (long indexed) [$40.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cop $84.b		; 02 84 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	sbc $00000F.l,X		; FF 0F 00 00 ; Subtract with carry (long,X) $00000F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $1D00.w		; 0E 00 1D ; Arithmetic shift left $1D00.w [Flags: NCZ]
	ora ($3A.b,X)		; 01 3A ; Logical OR ($3A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $75.b,S		; 03 75 ; OR accumulator with stack relative $75.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $6A.b		; 06 6A ; Arithmetic shift left $6A.b [Reads: Direct Page] [Flags: NCZ]
	tsb $FF23.w		; 0C 23 FF ; Test and set bits $FF23.w [Reads: Accumulator] [Flags: Z]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	inc $F8FC.w,X		; FE FC F8 ; Increment memory $F8FC.w,X [Reads: X Index] [Flags: NZ]
	sbc ($65.b),Y		; F1 65 ; Subtract with carry ($65.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora #$E5.b		; 09 E5 ; Logical OR #$E5.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$D5.b		; 09 D5 ; Logical OR #$D5.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $3925.w,Y		; 19 25 39 ; OR accumulator with memory $3925.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sbc ($F7.b,S),Y		; F3 F7 ; Subtract with carry (stack relative indirect indexed) ($F7.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $F2FFFE.l		; 0F FE FF F2 ; OR accumulator with memory (long) $F2FFFE.l [Writes: Accumulator] [Flags: NZ]
	sbc ($E2.b)		; F2 E2 ; Subtract with carry (indirect) ($E2.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	rep #$04		; C2 04 ; Reset processor status bits #$04 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $F0, $44		; F0 44 ; Branch if equal to $F0, $44 [Flow: branch]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$2D.b		; E0 2D ; Compare #$2D.b with X register [Reads: X Index] [Flags: NCZ]
	sbc $0301.w,X		; FD 01 03 ; Subtract with carry $0301.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $82, $07, $85		; 82 07 85 ; Branch always long to $82, $07, $85 [Flow: branch]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sta $9916.w		; 8D 16 99 ; Store accumulator to $9916.w [Reads: Accumulator]
	adc [$F8.b]		; 67 F8 ; Add with carry (long) [$F8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $7CFEFF.l,X		; FF FF FE 7C ; Subtract with carry (long,X) $7CFEFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $70, $60		; 70 60 ; Branch if overflow set to $70, $60 [Flow: branch]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1A.b		; 00 1A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($FC.b,X)		; 01 FC ; Logical OR ($FC.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $FBA3EE.l		; 22 EE A3 FB ; Jump to subroutine long $FBA3EE.l [Writes: Stack Pointer] [Flow: call]
	eor ($E5.b),Y		; 51 E5 ; Exclusive OR accumulator with memory ($E5.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $50, $F3		; 50 F3 ; Branch if overflow clear to $50, $F3 [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	inc $FF.b		; E6 FF ; Increment $FF.b [Reads: Direct Page] [Flags: NZ]
	sbc $1B1B.w,X		; FD 1B 1B ; Subtract with carry $1B1B.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $478E.w		; 8D 8E 47 ; Store accumulator to $478E.w [Reads: Accumulator]
	ora ($E0.b,X)		; 01 E0 ; Logical OR ($E0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $01E143.l,X		; 1F 43 E1 01 ; Logical OR long $01E143.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$39.b		; E0 39 ; Compare #$39.b with X register [Reads: X Index] [Flags: NCZ]
	sep #$03		; E2 03 ; Set processor status bits #$03 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	cpx $07.b		; E4 07 ; Compare $07.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	tsb $10DF.w		; 0C DF 10 ; Test and set bits $10DF.w [Reads: Accumulator] [Flags: Z]
	sbc $E02E.w,X		; FD 2E E0 ; Subtract with carry $E02E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $FCFE.w,X		; FE FE FC ; Increment memory $FCFE.w,X [Reads: X Index] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	cpy #$BE.b		; C0 BE ; Compare #$BE.b with Y register [Reads: Y Index] [Flags: NCZ]
	ora ($BF.b,S),Y		; 13 BF ; OR accumulator (stack relative indirect indexed) ($BF.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $31BF.w		; 0D BF 31 ; Logical OR $31BF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	tsb $02F9.w		; 0C F9 02 ; Test and set bits $02F9.w [Reads: Accumulator] [Flags: Z]
	ldy $01.b,X		; B4 01 ; Load Y register $01.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	and ($AE.b),Y		; 31 AE ; AND accumulator with memory ($AE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	cpy $C0C2.w		; CC C2 C0 ; Compare $C0C2.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $F0, $FC		; F0 FC ; Branch if equal to $F0, $FC [Flow: branch]
	dec $FBB6.w		; CE B6 FB ; Decrement $FBB6.w [Flags: NZ]
	cmp $00.b,S		; C3 00 ; Compare accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	sbc [$00.b]		; E7 00 ; Subtract with carry (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ror $FF00.w,X		; 7E 00 FF ; Rotate right $FF00.w,X [Reads: X Index] [Flags: NCZ]
	cmp $66.b,S		; C3 66 ; Compare accumulator (stack relative) $66.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	sbc [$BD.b]		; E7 BD ; Subtract with carry (long) [$BD.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ror $3C43.w,X		; 7E 43 3C ; Rotate right $3C43.w,X [Reads: X Index] [Flags: NCZ]
	and $FF2200.l,X		; 3F 00 22 FF ; AND accumulator with memory (long,X) $FF2200.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $3C.b		; 04 3C ; Test and set bits $3C.b [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$83.b		; C0 83 ; Compare #$83.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $90, $00		; 90 00 ; Branch if carry clear to $90, $00 [Flow: branch]
	.db $10, $7F		; 10 7F ; Branch if plus to $10, $7F [Flow: branch]
	ora ($FE.b,X)		; 01 FE ; Logical OR ($FE.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp $64.b,S		; C3 64 ; Compare accumulator (stack relative) $64.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	sbc [$B9.b]		; E7 B9 ; Subtract with carry (long) [$B9.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ror $3CC3.w,X		; 7E C3 3C ; Rotate right $3CC3.w,X [Reads: X Index] [Flags: NCZ]
	sbc $FFFF00.l,X		; FF 00 FF FF ; Subtract with carry (long,X) $FFFF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $183C.w,X		; FE 3C 18 ; Increment memory $183C.w,X [Reads: X Index] [Flags: NZ]
	jsl $FF4300.l		; 22 00 43 FF ; Jump to subroutine long $FF4300.l [Writes: Stack Pointer] [Flow: call]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	jsr $4777.w		; 20 77 47 ; Jump to subroutine at $4777.w [Writes: Stack Pointer] [Flow: call]
	sbc $10DF08.l		; EF 08 DF 10 ; Subtract with carry (long) $10DF08.l [Writes: Accumulator] [Flags: NCVZ]
	ldy #$20.b		; A0 20 ; Load #$20.b into Y register [Writes: Y Index] [Flags: NZ]
	sta $B6.b,S		; 83 B6 ; Store accumulator (stack relative) $B6.b,S [Reads: Stack Pointer, Accumulator]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $6070B8.l,X		; DF B8 70 60 ; Compare accumulator (long,X) $6070B8.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	eor $FF0044.l,X		; 5F 44 00 FF ; Exclusive OR accumulator with memory (long,X) $FF0044.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	cmp $06C9C0.l		; CF C0 C9 06 ; Compare accumulator (long) $06C9C0.l [Reads: Accumulator] [Flags: NCZ]
	cpy $2707.w		; CC 07 27 ; Compare $2707.w with Y register [Reads: Y Index] [Flags: NCZ]
	jsr $10F0.w		; 20 F0 10 ; Jump to subroutine at $10F0.w [Writes: Stack Pointer] [Flow: call]
	jsl $3019FF.l		; 22 FF 19 30 ; Jump to subroutine long $3019FF.l [Writes: Stack Pointer] [Flow: call]
	and [$37.b],Y		; 37 37 ; AND accumulator with memory (long indexed) [$37.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	ora $DD00CF.l		; 0F CF 00 DD ; OR accumulator with memory (long) $DD00CF.l [Writes: Accumulator] [Flags: NZ]
	.db $10, $FB		; 10 FB ; Branch if plus to $10, $FB [Flow: branch]
	jsl $ED06F7.l		; 22 F7 06 ED ; Jump to subroutine long $ED06F7.l [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc $E904.w		; ED 04 E9 ; Subtract $E904.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	tsb $ED.b		; 04 ED ; Test and set bits $ED.b [Reads: Accumulator] [Flags: Z]
	tsb $F0.b		; 04 F0 ; Test and set bits $F0.b [Reads: Accumulator] [Flags: Z]
	inc $F8DC.w		; EE DC F8 ; Increment $F8DC.w [Flags: NZ]
	sbc ($22.b)		; F2 22 ; Subtract with carry (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inc $09.b,X		; F6 09 ; Increment memory $09.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	sbc $0CCF02.l		; EF 02 CF 0C ; Subtract with carry (long) $0CCF02.l [Writes: Accumulator] [Flags: NCVZ]
	cmp $DC19.w,Y		; D9 19 DC ; Compare accumulator $DC19.w,Y [Reads: Y Index] [Flags: NCZ]
	tsb $DE.b		; 04 DE ; Test and set bits $DE.b [Reads: Accumulator] [Flags: Z]
	cop $43.b		; 02 43 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($0C.b)		; D2 0C ; Compare accumulator (indirect) ($0C.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	asl $DA.b		; 06 DA ; Arithmetic shift left $DA.b [Reads: Direct Page] [Flags: NCZ]
	tsb $F0.b		; 04 F0 ; Test and set bits $F0.b [Reads: Accumulator] [Flags: Z]
	.db $F0, $E6		; F0 E6 ; Branch if equal to $F0, $E6 [Flow: branch]
	sbc $E1.b,S		; E3 E1 ; Subtract stack-relative $E1.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	jsl $8F05ED.l		; 22 ED 05 8F ; Jump to subroutine long $8F05ED.l [Writes: Stack Pointer] [Flow: call]
	bit #$C7.b		; 89 C7 ; Test bits #$C7.b with accumulator [Reads: Accumulator] [Flags: Z]
	cpy $F9.b		; C4 F9 ; Compare $F9.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	and $FE.b,S		; 23 FE ; AND accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $89FF77.l,X		; FF 77 FF 89 ; Subtract with carry (long,X) $89FF77.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $3870.w,X		; FE 70 38 ; Increment memory $3870.w,X [Reads: X Index] [Flags: NZ]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $FD09.w		; 0D 09 FD ; Logical OR $FD09.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc ($F3.b,X)		; E1 F3 ; Subtract with carry ($F3.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $EF.b,S		; 43 EF ; Exclusive OR accumulator with stack relative $EF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $C71FDF.l		; 0F DF 1F C7 ; OR accumulator with memory (long) $C71FDF.l [Writes: Accumulator] [Flags: NZ]
	and $FFBF50.l,X		; 3F 50 BF FF ; AND accumulator with memory (long,X) $FFBF50.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $0C02F2.l		; 0F F2 02 0C ; OR accumulator with memory (long) $0C02F2.l [Writes: Accumulator] [Flags: NZ]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	jsl $29E000.l		; 22 00 E0 29 ; Jump to subroutine long $29E000.l [Writes: Stack Pointer] [Flow: call]
	adc ($FC.b,S),Y		; 73 FC ; Add with carry (stack relative indirect indexed) ($FC.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sta [$79.b]		; 87 79 ; Store accumulator (long) [$79.b] [Reads: Direct Page, Accumulator]
	ror $0E80.w,X		; 7E 80 0E ; Rotate right $0E80.w,X [Reads: X Index] [Flags: NCZ]
	sbc ($F9.b),Y		; F1 F9 ; Subtract with carry ($F9.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $F3.b		; 06 F3 ; Arithmetic shift left $F3.b [Reads: Direct Page] [Flags: NCZ]
	sta $30.b,S		; 83 30 ; Store accumulator (stack relative) $30.b,S [Reads: Stack Pointer, Accumulator]
	cmp $00EF10.l		; CF 10 EF 00 ; Compare accumulator (long) $00EF10.l [Reads: Accumulator] [Flags: NCZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0000.w		; 0C 00 00 ; Test and set bits $0000.w [Reads: Accumulator] [Flags: Z]
	clv		; B8 ; Clear overflow flag [Flags: V]
	lda [$7F.b]		; A7 7F ; Load accumulator (long) [$7F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $70, $9C		; 70 9C ; Branch if overflow set to $70, $9C [Flow: branch]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	asl $FFF9.w		; 0E F9 FF ; Arithmetic shift left $FFF9.w [Flags: NCZ]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	wai		; CB ; Wait for interrupt
	.db $30, $D7		; 30 D7 ; Branch if minus to $30, $D7 [Flow: branch]
	.db $30, $DF		; 30 DF ; Branch if minus to $30, $DF [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $80, $22		; 80 22 ; Branch always to $80, $22 [Flow: branch]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	brk $8B.b		; 00 8B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $00		; 90 00 ; Branch if carry clear to $90, $00 [Flow: branch]
	ora $42.b,S		; 03 42 ; OR accumulator with stack relative $42.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $003C.w,X		; 3C 3C 00 ; Test bits $003C.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	jsl $3C04FF.l		; 22 FF 04 3C ; Jump to subroutine long $3C04FF.l [Writes: Stack Pointer] [Flow: call]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $81.b		; 00 81 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $8D.b,S		; C3 8D ; Compare accumulator (stack relative) $8D.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	.db $80, $01		; 80 01 ; Branch always to $80, $01 [Flow: branch]
	ora ($3D.b,X)		; 01 3D ; Logical OR ($3D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $019383.l,X		; FF 83 93 01 ; Subtract with carry (long,X) $019383.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $C2.b		; 06 C2 ; Arithmetic shift left $C2.b [Reads: Direct Page] [Flags: NCZ]
	pei ($18.b)		; D4 18 ; Push effective indirect address ($18.b) [Reads: Direct Page] [Writes: Stack Pointer]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	trb $0E7D.w		; 1C 7D 0E ; Test and reset bits $0E7D.w [Reads: Accumulator] [Flags: Z]
	eor $35.b,S		; 43 35 ; Exclusive OR accumulator with stack relative $35.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $0D.b		; 06 0D ; Arithmetic shift left $0D.b [Reads: Direct Page] [Flags: NCZ]
	adc $FA0E.w,X		; 7D 0E FA ; Add $FA0E.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	trb $18D4.w		; 1C D4 18 ; Test and reset bits $18D4.w [Reads: Accumulator] [Flags: Z]
	sbc $E1.b,S		; E3 E1 ; Subtract stack-relative $E1.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $E1		; F0 E1 ; Branch if equal to $F0, $E1 [Flow: branch]
	sbc $85.b,S		; E3 85 ; Subtract stack-relative $85.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	.db $B0, $01		; B0 01 ; Branch if carry set to $B0, $01 [Flow: branch]
	eor $35.b,S		; 43 35 ; Exclusive OR accumulator with stack relative $35.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $8D.b		; 06 8D ; Arithmetic shift left $8D.b [Reads: Direct Page] [Flags: NCZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	ora ($43.b,X)		; 01 43 ; Logical OR ($43.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $FC0B00.l,X		; FF 00 0B FC ; Subtract with carry (long,X) $FC0B00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $E3.b		; 00 E3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $E0.b,S		; 03 E0 ; OR accumulator with stack relative $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $D708E7.l		; 0F E7 08 D7 ; OR accumulator with memory (long) $D708E7.l [Writes: Accumulator] [Flags: NZ]
	ora $1AD7.w,Y		; 19 D7 1A ; OR accumulator with memory $1AD7.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $FC17FF.l		; 22 FF 17 FC ; Jump to subroutine long $FC17FF.l [Writes: Stack Pointer] [Flow: call]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: NCZ]
	cmp $19.b,X		; D5 19 ; Compare accumulator $19.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cmp ($1C.b)		; D2 1C ; Compare accumulator (indirect) ($1C.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora ($1E.b),Y		; 11 1E ; OR accumulator with memory ($1E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($FE.b),Y		; F1 FE ; Subtract with carry ($FE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora #$FE.b		; 09 FE ; Logical OR #$FE.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7E.b		; 85 7E ; Store accumulator to $7E.b [Reads: Accumulator]
	eor $3C.b,S		; 43 3C ; Exclusive OR accumulator with stack relative $3C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $E1E280.l,X		; BF 80 E2 E1 ; Load long $E1E280.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$22.b		; E0 22 ; Compare #$22.b with X register [Reads: X Index] [Flags: NCZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $41		; 80 41 ; Branch always to $80, $41 [Flow: branch]
	sta ($81.b,X)		; 81 81 ; Store accumulator ($81.b,X) [Reads: Direct Page, Accumulator, X Index]
	cmp $C3.b,S		; C3 C3 ; Compare accumulator (stack relative) $C3.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	and [$FF.b]		; 27 FF ; AND accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $78.b		; 05 78 ; Logical OR $78.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $7EFFB7.l,X		; FF B7 FF 7E ; Subtract with carry (long,X) $7EFFB7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $0025.w,X		; 3C 25 00 ; Test bits $0025.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	ora ($80.b,X)		; 01 80 ; Logical OR ($80.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $80, $83		; 80 83 ; Branch always to $80, $83 [Flow: branch]
	ora ($02.b)		; 12 02 ; OR accumulator with memory (indirect) ($02.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sbc [$FF.b]		; E7 FF ; Subtract with carry (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	sbc $5AFFA5.l,X		; FF A5 FF 5A ; Subtract with carry (long,X) $5AFFA5.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$A5.b]		; E7 A5 ; Subtract with carry (long) [$A5.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	adc $00253C.l,X		; 7F 3C 25 00 ; Add long $00253C.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $FD.b,S		; 03 FD ; OR accumulator with stack relative $FD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $237F7E.l,X		; FF 7E 7F 23 ; Subtract with carry (long,X) $237F7E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $3F3E09.l,X		; 3F 09 3E 3F ; AND accumulator with memory (long,X) $3F3E09.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $7D3F.w,X		; 3D 3F 7D ; AND accumulator with memory $7D3F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $00FFFD.l,X		; 7F FD FF 00 ; Add long $00FFFD.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $23		; 80 23 ; Branch always to $80, $23 [Flow: branch]
	cpy #$07.b		; C0 07 ; Compare #$07.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	sbc $7AFF.w,X		; FD FF 7A ; Subtract with carry $7AFF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $433E35.l,X		; 7F 35 3E 43 ; Add long $433E35.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and $3502.w,X		; 3D 02 35 ; AND accumulator with memory $3502.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rol $847A.w,X		; 3E 7A 84 ; Rotate left $847A.w,X [Reads: X Index] [Flags: NCZ]
	eor $2302.w		; 4D 02 23 ; Exclusive OR $2302.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cpy #$07.b		; C0 07 ; Compare #$07.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	cmp ($FF.b,X)		; C1 FF ; Compare accumulator ($FF.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	cmp $F1DEFE.l,X		; DF FE DE F1 ; Compare accumulator (long,X) $F1DEFE.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	eor $D8.b,S		; 43 D8 ; Exclusive OR accumulator with stack relative $D8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc [$05.b],Y		; F7 05 ; Subtract with carry (long indexed) [$05.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $1BF6.w,Y		; D9 F6 1B ; Compare accumulator $1BF6.w,Y [Reads: Y Index] [Flags: NCZ]
	sbc $FE.b,X		; F5 FE ; Subtract $FE.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($27.b,S),Y		; F3 27 ; Subtract with carry (stack relative indirect indexed) ($27.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($1907.w,X)		; FC 07 19 ; Jump to subroutine indirect indexed ($1907.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $DC33.w		; EE 33 DC ; Increment $DC33.w [Flags: NZ]
	ror $B9.b		; 66 B9 ; Rotate right $B9.b [Reads: Direct Page] [Flags: NCZ]
	cpy $9873.w		; CC 73 98 ; Compare $9873.w with Y register [Reads: Y Index] [Flags: NCZ]
	sbc [$30.b]		; E7 30 ; Subtract with carry (long) [$30.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp $229F61.l		; CF 61 9F 22 ; Compare accumulator (long) $229F61.l [Reads: Accumulator] [Flags: NCZ]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $42BD.w,X		; 1E BD 42 ; Arithmetic shift left $42BD.w,X [Reads: X Index] [Flags: NCZ]
	nop		; EA ; No operation
	trb $DD.b		; 14 DD ; Test and reset bits $DD.b [Reads: Accumulator] [Flags: Z]
	jsr $51AB.w		; 20 AB 51 ; Jump to subroutine at $51AB.w [Writes: Stack Pointer] [Flow: call]
	cmp [$23.b],Y		; D7 23 ; Compare accumulator (long indexed) [$23.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	lda $0FDF47.l		; AF 47 DF 0F ; Load long $0FDF47.l into accumulator [Writes: Accumulator] [Flags: NZ]
	ldx $221F.w,Y		; BE 1F 22 ; Load X register $221F.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	brk $84.b		; 00 84 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	cop $E0.b		; 02 E0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and #$FF.b		; 29 FF ; Logical AND #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $0F.b		; 04 0F ; Test and set bits $0F.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	inc $FC00.w,X		; FE 00 FC ; Increment memory $FC00.w,X [Reads: X Index] [Flags: NZ]
	cpy #$F8.b		; C0 F8 ; Compare #$F8.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $80, $FC		; 80 FC ; Branch always to $80, $FC [Flow: branch]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F9.b		; 00 F9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($07.b,S),Y		; F3 07 ; Subtract with carry (stack relative indirect indexed) ($07.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cmp $F3039F.l		; CF 9F 03 F3 ; Compare accumulator (long) $F3039F.l [Reads: Accumulator] [Flags: NCZ]
	ora $83.b,S		; 03 83 ; OR accumulator with stack relative $83.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $5F.b,S		; 43 5F ; Exclusive OR accumulator with stack relative $5F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $575F2F.l,X		; BF 2F 5F 57 ; Load long $575F2F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $75776B.l		; 6F 6B 77 75 ; Add with carry (long) $75776B.l [Writes: Accumulator] [Flags: NCVZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	sbc $FEFD.w,X		; FD FD FE ; Subtract with carry $FEFD.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $2300.w,X		; 3C 00 23 ; Test bits $2300.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	.db $80, $19		; 80 19 ; Branch always to $80, $19 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $BD7F.w,X		; 7D 7F BD ; Add $BD7F.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $EDDFDD.l,X		; BF DD DF ED ; Load long $EDDFDD.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $FBF7F6.l		; EF F6 F7 FB ; Subtract with carry (long) $FBF7F6.l [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	trb $ECFD.w		; 1C FD EC ; Test and reset bits $ECFD.w [Reads: Accumulator] [Flags: Z]
	inc $4080.w,X		; FE 80 40 ; Increment memory $4080.w,X [Reads: X Index] [Flags: NZ]
	jsr $0810.w		; 20 10 08 ; Jump to subroutine at $0810.w [Writes: Stack Pointer] [Flow: call]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	ora ($85.b,X)		; 01 85 ; Logical OR ($85.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $B0, $01		; B0 01 ; Branch if carry set to $B0, $01 [Flow: branch]
	eor $35.b,S		; 43 35 ; Exclusive OR accumulator with stack relative $35.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $04.b		; 06 04 ; Arithmetic shift left $04.b [Reads: Direct Page] [Flags: NCZ]
	adc $FB0E.w,X		; 7D 0E FB ; Add $FB0E.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	trb $86D7.w		; 1C D7 86 ; Test and reset bits $86D7.w [Reads: Accumulator] [Flags: Z]
	lda $E00701.l,X		; BF 01 07 E0 ; Load long $E00701.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$D7.b		; E0 D7 ; Compare #$D7.b with X register [Reads: X Index] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	trb $0E7D.w		; 1C 7D 0E ; Test and reset bits $0E7D.w [Reads: Accumulator] [Flags: Z]
	eor $35.b,S		; 43 35 ; Exclusive OR accumulator with stack relative $35.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	adc $F30E.w,Y		; 79 0E F3 ; Add $F30E.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	trb $38E7.w		; 1C E7 38 ; Test and reset bits $38E7.w [Reads: Accumulator] [Flags: Z]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: NCZ]
	sty $12.b		; 84 12 ; Store Y register to $12.b [Reads: Y Index]
	ora $0B.b,S		; 03 0B ; OR accumulator with stack relative $0B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpy #$48.b		; C0 48 ; Compare #$48.b with Y register [Reads: Y Index] [Flags: NCZ]
	sbc $4978B7.l,X		; FF B7 78 49 ; Subtract with carry (long,X) $4978B7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda [$31.b],Y		; B7 31 ; Load accumulator (long indexed) [$31.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $FF00FF.l		; CF FF 00 FF ; Compare accumulator (long) $FF00FF.l [Reads: Accumulator] [Flags: NCZ]
	mvp $00,$FF		; 44 FF 00 ; Move block positive $00,$FF [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $42.b,S		; 03 42 ; OR accumulator with stack relative $42.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $7EC1.w,X		; BD C1 7E ; Load $7EC1.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $C0.b,S		; 43 C0 ; Exclusive OR accumulator with stack relative $C0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $00FF07.l,X		; 7F 07 FF 00 ; Add long $00FF07.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FE03FE.l,X		; FF FE 03 FE ; Subtract with carry (long,X) $FE03FE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($FE.b,X)		; 01 FE ; Logical OR ($FE.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $4C.b,S		; 03 4C ; OR accumulator with stack relative $4C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda [$AC.b],Y		; B7 AC ; Load accumulator (long indexed) [$AC.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp [$43.b],Y		; D7 43 ; Compare accumulator (long indexed) [$43.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	jmp $AC01E7.l		; 5C E7 01 AC ; Jump long to $AC01E7.l [Flow: jump]
	cmp [$43.b],Y		; D7 43 ; Compare accumulator (long indexed) [$43.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	jmp $01B7.w		; 4C B7 01 ; Jump to $01B7.w [Flow: jump]
	jmp ($27B7.w,X)		; 7C B7 27 ; Jump indirect indexed to ($27B7.w,X) [Reads: X Index] [Flow: jump]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($FC87.w,X)		; 7C 87 FC ; Jump indirect indexed to ($FC87.w,X) [Reads: X Index] [Flow: jump]
	adc [$47.b],Y		; 77 47 ; Add with carry (long indexed) [$47.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $03F7.w		; 0C F7 03 ; Test and set bits $03F7.w [Reads: Accumulator] [Flags: Z]
	stx $4F77.w		; 8E 77 4F ; Store X register to $4F77.w [Reads: X Index]
	.db $B0, $27		; B0 27 ; Branch if carry set to $B0, $27 [Flow: branch]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $7F		; 80 7F ; Branch always to $80, $7F [Flow: branch]
	adc $9F6080.l,X		; 7F 80 60 9F ; Add long $9F6080.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $50, $AF		; 50 AF ; Branch if overflow clear to $50, $AF [Flow: branch]
	eor $B34FB0.l		; 4F B0 4F B3 ; Exclusive OR accumulator with memory (long) $B34FB0.l [Writes: Accumulator] [Flags: NZ]
	lsr $4DB5.w		; 4E B5 4D ; Logical shift right $4DB5.w [Flags: NCZ]
	ldx $27.b,Y		; B6 27 ; Load X register $27.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy $CC37.w		; CC 37 CC ; Compare $CC37.w with Y register [Reads: Y Index] [Flags: NCZ]
	adc [$2C.b],Y		; 77 2C ; Add with carry (long indexed) [$2C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$1C.b],Y		; F7 1C ; Subtract with carry (long indexed) [$1C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$FC.b],Y		; F7 FC ; Subtract with carry (long indexed) [$FC.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $02FBF8.l		; 0F F8 FB 02 ; OR accumulator with memory (long) $02FBF8.l [Writes: Accumulator] [Flags: NZ]
	sbc $24FF01.l,X		; FF 01 FF 24 ; Subtract with carry (long,X) $24FF01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $D7.b		; 00 D7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $1A.b,S		; 83 1A ; Store accumulator (stack relative) $1A.b,S [Reads: Stack Pointer, Accumulator]
	ora $43.b,S		; 03 43 ; OR accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $06.b,X		; 35 06 ; Logical AND $06.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sta $BA.b		; 85 BA ; Store accumulator to $BA.b [Reads: Accumulator]
	ora ($85.b,X)		; 01 85 ; Logical OR ($85.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	ora $11.b,S		; 03 11 ; OR accumulator with stack relative $11.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc ($E3.b,X)		; E1 E3 ; Subtract with carry ($E3.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sbc [$8F.b],Y		; F7 8F ; Subtract with carry (long indexed) [$8F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $7C		; 70 7C ; Branch if overflow set to $70, $7C [Flow: branch]
	sta $06.b,S		; 83 06 ; Store accumulator (stack relative) $06.b,S [Reads: Stack Pointer, Accumulator]
	sbc $00FF.w,Y		; F9 FF 00 ; Subtract with carry $00FF.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FC07F8.l,X		; FF F8 07 FC ; Subtract with carry (long,X) $FC07F8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($FE.b,X)		; 01 FE ; Logical OR ($FE.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($4C.b,X)		; 01 4C ; Logical OR ($4C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda [$45.b],Y		; B7 45 ; Load accumulator (long indexed) [$45.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ldy $07D7.w		; AC D7 07 ; Load $07D7.w into Y register [Writes: Y Index] [Flags: NZ]
	cpx $7E17.w		; EC 17 7E ; Compare $7E17.w with X register [Reads: X Index] [Flags: NCZ]
	sta $5E.b,S		; 83 5E ; Store accumulator (stack relative) $5E.b,S [Reads: Stack Pointer, Accumulator]
	lda ($4F.b,X)		; A1 4F ; Load accumulator ($4F.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $27		; B0 27 ; Branch if carry set to $B0, $27 [Flow: branch]
	brk $16.b		; 00 16 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($3E.b,X)		; C1 3E ; Compare accumulator ($3E.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	lda $B97740.l,X		; BF 40 77 B9 ; Load long $B97740.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $A75FB3.l		; 6F B3 5F A7 ; Add with carry (long) $A75FB3.l [Writes: Accumulator] [Flags: NCVZ]
	adc $9F7F8F.l,X		; 7F 8F 7F 9F ; Add long $9F7F8F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $403E3F.l,X		; FF 3F 3E 40 ; Subtract with carry (long,X) $403E3F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	.db $B0, $A0		; B0 A0 ; Branch if carry set to $B0, $A0 [Flow: branch]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $7EFF0C.l,X		; FF 0C FF 7E ; Subtract with carry (long,X) $7EFF0C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $DB7EBD.l,X		; FF BD 7E DB ; Subtract with carry (long,X) $DB7EBD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $DBE7.w,X		; BD E7 DB ; Load $DBE7.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	trb $FFE7.w		; 1C E7 FF ; Test and reset bits $FFE7.w [Reads: Accumulator] [Flags: Z]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($04.b,X)		; 21 04 ; Logical AND ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora #$BD.b		; 09 BD ; Logical OR #$BD.b with accumulator [Writes: Accumulator] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	sbc [$00.b]		; E7 00 ; Subtract with carry (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F576.w		; ED 76 F5 ; Subtract $F576.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	jmp ($FD43.w,X)		; 7C 43 FD ; Jump indirect indexed to ($FD43.w,X) [Reads: X Index] [Flow: jump]
	ror $27E0.w,X		; 7E E0 27 ; Rotate right $27E0.w,X [Reads: X Index] [Flags: NCZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	jmp ($7AF5.w,X)		; 7C F5 7A ; Jump indirect indexed to ($7AF5.w,X) [Reads: X Index] [Flow: jump]
	sbc $7676.w		; ED 76 76 ; Subtract $7676.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	jmp ($7E7E.w,X)		; 7C 7E 7E ; Jump indirect indexed to ($7E7E.w,X) [Reads: X Index] [Flow: jump]
	jmp ($767A.w,X)		; 7C 7A 76 ; Jump indirect indexed to ($767A.w,X) [Reads: X Index] [Flow: jump]
	sbc $7FFF00.l,X		; FF 00 FF 7F ; Subtract with carry (long,X) $7FFF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $FD7F.w,X		; FE 7F FD ; Increment memory $FD7F.w,X [Reads: X Index] [Flags: NZ]
	ror $7DFB.w,X		; 7E FB 7D ; Rotate right $7DFB.w,X [Reads: X Index] [Flags: NCZ]
	sbc [$7B.b],Y		; F7 7B ; Subtract with carry (long indexed) [$7B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx $DD77.w		; EC 77 DD ; Compare $DD77.w with X register [Reads: X Index] [Flags: NCZ]
	ror $7F00.w		; 6E 00 7F ; Rotate right $7F00.w [Flags: NCZ]
	adc $7B7D7E.l,X		; 7F 7E 7D 7B ; Add long $7B7D7E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc [$6E.b],Y		; 77 6E ; Add with carry (long indexed) [$6E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc DMALEN7H.w		; ED 76 43 ; Subtract DMALEN7H.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sbc $0AF6.w		; ED F6 0A ; Subtract $0AF6.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ora $FDF6.w		; 0D F6 FD ; Logical OR $FDF6.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $FD.b		; 06 FD ; Arithmetic shift left $FD.b [Reads: Direct Page] [Flags: NCZ]
	inc $FE01.w,X		; FE 01 FE ; Increment memory $FE01.w,X [Reads: X Index] [Flags: NZ]
	sbc $227600.l,X		; FF 00 76 22 ; Subtract with carry (long,X) $227600.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $18.b,X		; F6 18 ; Increment memory $18.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	asl $FE.b		; 06 FE ; Arithmetic shift left $FE.b [Reads: Direct Page] [Flags: NCZ]
	inc $FF00.w,X		; FE 00 FF ; Increment memory $FF00.w,X [Reads: X Index] [Flags: NZ]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$31.b		; E0 31 ; Compare #$31.b with X register [Reads: X Index] [Flags: NCZ]
	cmp ($62.b,X)		; C1 62 ; Compare accumulator ($62.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	sta $C5.b,S		; 83 C5 ; Store accumulator (stack relative) $C5.b,S [Reads: Stack Pointer, Accumulator]
	ora [$8B.b]		; 07 8B ; OR accumulator with memory (long) [$8B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $1897.w		; 0D 97 18 ; Logical OR $1897.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc [$78.b],Y		; F7 78 ; Subtract with carry (long indexed) [$78.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $381C.w		; 0E 1C 38 ; Arithmetic shift left $381C.w [Flags: NCZ]
	sty $45.b		; 84 45 ; Store Y register to $45.b [Reads: Y Index]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b)		; 12 01 ; OR accumulator with memory (indirect) ($01.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $E2.b		; 25 E2 ; Logical AND $E2.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $A3.b		; E6 A3 ; Increment $A3.b [Reads: Direct Page] [Flags: NZ]
	sbc [$51.b],Y		; F7 51 ; Subtract with carry (long indexed) [$51.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lda ($10.b,S),Y		; B3 10 ; Load accumulator (stack relative indirect indexed) ($10.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $DC88.w,Y		; B9 88 DC ; Load $DC88.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	stz $83.b		; 64 83 ; Store zero to $83.b
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	brk $15.b		; 00 15 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit #$CC.b		; 89 CC ; Test bits #$CC.b with accumulator [Reads: Accumulator] [Flags: Z]
	lsr $03.b		; 46 03 ; Logical shift right $03.b [Reads: Direct Page] [Flags: NCZ]
	sta $619970.l		; 8F 70 99 61 ; Store accumulator (long) $619970.l [Reads: Accumulator]
	lda ($41.b),Y		; B1 41 ; Load accumulator ($41.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $03.b,S		; E3 03 ; Subtract stack-relative $03.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	cpy $07.b		; C4 07 ; Compare $07.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	tsb $1897.w		; 0C 97 18 ; Test and set bits $1897.w [Reads: Accumulator] [Flags: Z]
	lda $06003C.l		; AF 3C 00 06 ; Load long $06003C.l into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $92.b,S		; 83 92 ; Store accumulator (stack relative) $92.b,S [Reads: Stack Pointer, Accumulator]
	tsb $19.b		; 04 19 ; Test and set bits $19.b [Reads: Accumulator] [Flags: Z]
	cpx #$C0.b		; E0 C0 ; Compare #$C0.b with X register [Reads: X Index] [Flags: NCZ]
	sta $299932.l,X		; 9F 32 99 29 ; Store accumulator (long,X) $299932.l,X [Reads: Accumulator, X Index]
	ldx $CF31.w,Y		; BE 31 CF ; Load X register $CF31.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	tsb $0283.w		; 0C 83 02 ; Test and set bits $0283.w [Reads: Accumulator] [Flags: Z]
	lda $DC01.w,Y		; B9 01 DC ; Load $DC01.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $AE		; 30 AE ; Branch if minus to $30, $AE [Flow: branch]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	cpy $C0C6.w		; CC C6 C0 ; Compare $C0C6.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $F0, $FC		; F0 FC ; Branch if equal to $F0, $FC [Flow: branch]
	dec $B3.b		; C6 B3 ; Decrement $B3.b [Reads: Direct Page] [Flags: NZ]
	sbc $908B.w,Y		; F9 8B 90 ; Subtract with carry $908B.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
.ACCU 16
.INDEX 16
	rep #$BC		; C2 BC
	jsr ($2200.w,X)		; FC 00 22 ; Jump to subroutine indirect indexed ($2200.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $183C10.l,X		; FF 10 3C 18 ; Subtract with carry (long,X) $183C10.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $FF.b,S		; 03 FF ; OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$884F.w		; C0 4F 88 ; Compare #$884F.w with Y register [Reads: Y Index] [Flags: NCZ]
	sta $27BF13.l,X		; 9F 13 BF 27 ; Store accumulator (long,X) $27BF13.l,X [Reads: Accumulator, X Index]
	lda $1E8320.l,X		; BF 20 83 1E ; Load long $1E8320.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $0A.b		; 04 0A ; Test and set bits $0A.b [Reads: Accumulator] [Flags: Z]
	ora $63301F.l		; 0F 1F 30 63 ; OR accumulator with memory (long) $63301F.l [Writes: Accumulator] [Flags: NZ]
	eor [$40.b]		; 47 40 ; Exclusive OR accumulator with memory (long) [$40.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $00FF00.l,X		; 7F 00 FF 00 ; Add long $00FF00.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $43.b		; 04 43 ; Test and set bits $43.b [Reads: Accumulator] [Flags: Z]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $C0		; 10 C0 ; Branch if plus to $10, $C0 [Flow: branch]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ora $DF.b,S		; 03 DF ; OR accumulator with stack relative $DF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $01F307.l		; CF 07 F3 01 ; Compare accumulator (long) $01F307.l [Reads: Accumulator] [Flags: NCZ]
	sta [$B8.b],Y		; 97 B8 ; Store accumulator (long indexed) [$B8.b],Y [Reads: Direct Page, Y Index, Accumulator]
	cop $09.b		; 02 09 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $20C010.l		; EF 10 C0 20 ; Subtract with carry (long) $20C010.l [Writes: Accumulator] [Flags: NCVZ]
	sta $179FC8.l		; 8F C8 9F 17 ; Store accumulator (long) $179FC8.l [Reads: Accumulator]
	lda $02852F.l,X		; BF 2F 85 02 ; Load long $02852F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $6730DF.l		; EF DF 30 67 ; Subtract with carry (long) $6730DF.l [Writes: Accumulator] [Flags: NCVZ]
	eor $050D85.l		; 4F 85 0D 05 ; Exclusive OR accumulator with memory (long) $050D85.l [Writes: Accumulator] [Flags: NZ]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr ($1790.w,X)		; FC 90 17 ; Jump to subroutine indirect indexed ($1790.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora $11.b		; 05 11 ; Logical OR $11.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($80.b,X)		; 81 80 ; Store accumulator ($80.b,X) [Reads: Direct Page, Accumulator, X Index]
	sbc $FEFDFE.l,X		; FF FE FD FE ; Subtract with carry (long,X) $FEFDFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	jsr ($F9F5.w,X)		; FC F5 F9 ; Jump to subroutine indirect indexed ($F9F5.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc ($78.b,S),Y		; F3 78 ; Subtract with carry (stack relative indirect indexed) ($78.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$8F.b],Y		; F7 8F ; Subtract with carry (long indexed) [$8F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$7E.b],Y		; F7 7E ; Subtract with carry (long indexed) [$7E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $62.b		; 00 62 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $83.b		; 04 83 ; Test and set bits $83.b [Reads: Accumulator] [Flags: Z]
	rol $4502.w,X		; 3E 02 45 ; Rotate left $4502.w,X [Reads: X Index] [Flags: NCZ]
	ror $087F.w,X		; 7E 7F 08 ; Rotate right $087F.w,X [Reads: X Index] [Flags: NCZ]
	adc [$78.b],Y		; 77 78 ; Add with carry (long indexed) [$78.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc #$5573.w		; 69 73 55 ; Add #$5573.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	adc [$ED.b]		; 67 ED ; Add with carry (long) [$ED.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $802300.l		; 0F 00 23 80 ; OR accumulator with memory (long) $802300.l [Writes: Accumulator] [Flags: NZ]
	cop $84.b		; 02 84 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $10, $83		; 10 83 ; Branch if plus to $10, $83 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cop $43.b		; 02 43 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $073F.w,X		; 3E 3F 07 ; Rotate left $073F.w,X [Reads: X Index] [Flags: NCZ]
	lda $DABF.w,X		; BD BF DA ; Load $DABF.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $E31FDA.l,X		; 5F DA 1F E3 ; Exclusive OR accumulator with memory (long,X) $E31FDA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	stx $83.b		; 86 83 ; Store X register to $83.b [Reads: X Index]
	.db $50, $02		; 50 02 ; Branch if overflow clear to $50, $02 [Flow: branch]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	jsr $1820.w		; 20 20 18 ; Jump to subroutine at $1820.w [Writes: Stack Pointer] [Flow: call]
	adc $7F42.w,X		; 7D 42 7F ; Add $7F42.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc ($46.b),Y		; 71 46 ; Add with carry ($46.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	asl $9FD9.w		; 0E D9 9F ; Arithmetic shift left $9FD9.w [Flags: NCZ]
	cmp $3D1F.w,X		; DD 1F 3D ; Compare accumulator $3D1F.w,X [Reads: X Index] [Flags: NCZ]
	and $80FFFD.l,X		; 3F FD FF 80 ; AND accumulator with memory (long,X) $80FFFD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $80, $88		; 80 88 ; Branch always to $80, $88 [Flow: branch]
	.db $90, $20		; 90 20 ; Branch if carry clear to $90, $20 [Flow: branch]
	jsr $83C0.w		; 20 C0 83 ; Jump to subroutine at $83C0.w [Writes: Stack Pointer] [Flow: call]
	eor $D30C03.l,X		; 5F 03 0C D3 ; Exclusive OR accumulator with memory (long,X) $D30C03.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldx $AFD1.w		; AE D1 AF ; Load $AFD1.w into X register [Writes: X Index] [Flags: NZ]
	.db $D0, $38		; D0 38 ; Branch if not equal to $D0, $38 [Flow: branch]
	cmp $70.b,S		; C3 70 ; Compare accumulator (stack relative) $70.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	pea $CC0F.w		; F4 0F CC ; Push absolute address $CC0F.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	eor [$23.b],Y		; 57 23 ; Exclusive OR accumulator with memory (long indexed) [$23.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $4CB7.w		; AC B7 4C ; Load $4CB7.w into Y register [Writes: Y Index] [Flags: NZ]
	adc [$CF.b],Y		; 77 CF ; Add with carry (long indexed) [$CF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $EF		; F0 EF ; Branch if equal to $F0, $EF [Flow: branch]
	adc ($FC.b,S),Y		; 73 FC ; Add with carry (stack relative indirect indexed) ($FC.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	and $78.b,X		; 35 78 ; Logical AND $78.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sta $5C.b,S		; 83 5C ; Store accumulator (stack relative) $5C.b,S [Reads: Stack Pointer, Accumulator]
	lda [$4C.b]		; A7 4C ; Load accumulator (long) [$4C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda [$83.b],Y		; B7 83 ; Load accumulator (long indexed) [$83.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $00FF43.l,X		; FF 43 FF 00 ; Subtract with carry (long,X) $00FF43.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $0806FF.l		; 22 FF 06 08 ; Jump to subroutine long $0806FF.l [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$00.b],Y		; F7 00 ; Subtract with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $000024.l,X		; FF 24 00 00 ; Subtract with carry (long,X) $000024.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$23.b],Y		; F7 23 ; Subtract with carry (long indexed) [$23.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FF000E.l,X		; FF 0E 00 FF ; Subtract with carry (long,X) $FF000E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $C42FD7.l,X		; 1F D7 2F C4 ; Logical OR long $C42FD7.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	bit $3CDC.w,X		; 3C DC 3C ; Test bits $3CDC.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	cmp ($30.b),Y		; D1 30 ; Compare accumulator ($30.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cmp ($30.b)		; D2 30 ; Compare accumulator (indirect) ($30.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0CCB43.l		; 0F 43 CB 0C ; OR accumulator with memory (long) $0CCB43.l [Writes: Accumulator] [Flags: NZ]
	ora $C8.b,S		; 03 C8 ; OR accumulator with stack relative $C8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $430FCF.l		; 0F CF 0F 43 ; OR accumulator with memory (long) $430FCF.l [Writes: Accumulator] [Flags: NZ]
	cpy #$0300.w		; C0 00 03 ; Compare #$0300.w with Y register [Reads: Y Index] [Flags: NCZ]
	lda $007F00.l,X		; BF 00 7F 00 ; Load long $007F00.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $F0.b,S		; 23 F0 ; AND accumulator with stack relative $F0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $FF.b		; 24 FF ; Test bits $FF.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	asl $FF00.w		; 0E 00 FF ; Arithmetic shift left $FF00.w [Flags: NCZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	pea $3C23.w		; F4 23 3C ; Push absolute address $3C23.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $0C8B.w,X		; 3C 8B 0C ; Test bits $0C8B.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	tsb $0023.w		; 0C 23 00 ; Test and set bits $0023.w [Reads: Accumulator] [Flags: Z]
	ora $C0.b,S		; 03 C0 ; OR accumulator with stack relative $C0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpy #$F0F0.w		; C0 F0 F0 ; Compare #$F0F0.w with Y register [Reads: Y Index] [Flags: NCZ]
	eor $D3.b,S		; 43 D3 ; Exclusive OR accumulator with stack relative $D3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $30, $03		; 30 03 ; Branch if minus to $30, $03 [Flow: branch]
	ora ($F0.b,S),Y		; 13 F0 ; OR accumulator (stack relative indirect indexed) ($F0.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc ($F0.b,S),Y		; F3 F0 ; Subtract with carry (stack relative indirect indexed) ($F0.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	eor $03.b,S		; 43 03 ; Exclusive OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FE00.w,X		; FD 00 FE ; Subtract with carry $FE00.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0EFF23.l		; 0F 23 FF 0E ; OR accumulator with memory (long) $0EFF23.l [Writes: Accumulator] [Flags: NZ]
.INDEX 8
	sep #$1F		; E2 1F
	sta $7B7F.w		; 8D 7F 7B ; Store accumulator to $7B7F.w [Reads: Accumulator]
	sbc $08DCD4.l,X		; FF D4 DC 08 ; Subtract with carry (long,X) $08DCD4.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc [$00.b]		; E7 00 ; Subtract with carry (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$23.b],Y		; F7 23 ; Subtract with carry (long indexed) [$23.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $F7.b,S		; 23 F7 ; AND accumulator with stack relative $F7.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc [$FF.b],Y		; F7 FF ; Subtract with carry (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $B330D3.l,X		; FF D3 30 B3 ; Subtract with carry (long,X) $B330D3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $A3		; 70 A3 ; Branch if overflow set to $70, $A3 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	and ($F0.b),Y		; 31 F0 ; AND accumulator with memory ($F0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jmp ($53FC.w)		; 6C FC 53 ; Jump indirect to ($53FC.w) [Flow: jump]
	.db $F0, $A7		; F0 A7 ; Branch if equal to $F0, $A7 [Flow: branch]
	cpx #$67.b		; E0 67 ; Compare #$67.b with X register [Reads: X Index] [Flags: NCZ]
	cpx #$0F.b		; E0 0F ; Compare #$0F.b with X register [Reads: X Index] [Flags: NCZ]
	ora $030F1F.l		; 0F 1F 0F 03 ; OR accumulator with memory (long) $030F1F.l [Writes: Accumulator] [Flags: NZ]
	ora $DC1F1F.l		; 0F 1F 1F DC ; OR accumulator with memory (long) $DC1F1F.l [Writes: Accumulator] [Flags: NZ]
	bit $4494.w,X		; 3C 94 44 ; Test bits $4494.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	jmp ($028C.w,X)		; 7C 8C 02 ; Jump indirect indexed to ($028C.w,X) [Reads: X Index] [Flow: jump]
	stz $8C7C.w		; 9C 7C 8C ; Store zero to $8C7C.w
	mvp $9C,$7C		; 44 7C 9C ; Move block positive $9C,$7C [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	and [$03.b]		; 27 03 ; AND accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $9D.b,S		; 43 9D ; Exclusive OR accumulator with stack relative $9D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $E200.w,X		; FD 00 E2 ; Subtract with carry $E200.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $DD.b		; 00 DD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($EA.b,X)		; 01 EA ; Logical OR ($EA.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $F5.b		; 00 F5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $25FE00.l,X		; FF 00 FE 25 ; Subtract with carry (long,X) $25FE00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FEFC10.l,X		; FF 10 FC FE ; Subtract with carry (long,X) $FEFC10.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($F8.b),Y		; F1 F8 ; Subtract with carry ($F8.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp [$E3.b]		; C7 E3 ; Compare accumulator (long) [$E3.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora $3F7F8F.l,X		; 1F 8F 7F 3F ; Logical OR long $3F7F8F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $FFFC7C.l,X		; FF 7C FC FF ; Subtract with carry (long,X) $FFFC7C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($C0F0.w,X)		; FC F0 C0 ; Jump to subroutine indirect indexed ($C0F0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsl $030900.l		; 22 00 09 03 ; Jump to subroutine long $030900.l [Writes: Stack Pointer] [Flow: call]
	sbc $7F8000.l,X		; FF 00 80 7F ; Subtract with carry (long,X) $7F8000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	wai		; CB ; Wait for interrupt
	sbc $FF22BF.l,X		; FF BF 22 FF ; Subtract with carry (long,X) $FF22BF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and #$2200.w		; 29 00 22 ; Logical AND #$2200.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $00000E.l,X		; FF 0E 00 00 ; Subtract with carry (long,X) $00000E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $9EFF01.l,X		; FF 01 FF 9E ; Subtract with carry (long,X) $9EFF01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $FC3C.w,X		; FE 3C FC ; Increment memory $FC3C.w,X [Reads: X Index] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora #$0C01.w		; 09 01 0C ; Logical OR #$0C01.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $19.b		; 00 19 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$FE.b]		; 07 FE ; OR accumulator with memory (long) [$FE.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $00FF.w,X		; FE FF 00 ; Increment memory $00FF.w,X [Reads: X Index] [Flags: NZ]
	lda $1F10BF.l,X		; BF BF 10 1F ; Load long $1F10BF.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $605F30.l		; 2F 30 5F 60 ; AND accumulator with memory (long) $605F30.l [Writes: Accumulator] [Flags: NZ]
	lda $807FC0.l,X		; BF C0 7F 80 ; Load long $807FC0.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $400000.l,X		; FF 00 00 40 ; Subtract with carry (long,X) $400000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$C0.b		; E0 C0 ; Compare #$C0.b with X register [Reads: X Index] [Flags: NCZ]
	.db $80, $22		; 80 22 ; Branch always to $80, $22 [Flow: branch]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $46.b		; C5 46 ; Compare $46.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	tsb $58D7.w		; 0C D7 58 ; Test and set bits $58D7.w [Reads: Accumulator] [Flags: Z]
	sbc $DF4770.l		; EF 70 47 DF ; Subtract with carry (long) $DF4770.l [Writes: Accumulator] [Flags: NCVZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cop $38.b		; 02 38 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $20		; 70 20 ; Branch if overflow set to $70, $20 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $050024.l,X		; FF 24 00 05 ; Subtract with carry (long,X) $050024.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($81.b,X)		; 81 81 ; Store accumulator ($81.b,X) [Reads: Direct Page, Accumulator, X Index]
	cmp $42.b,S		; C3 42 ; Compare accumulator (stack relative) $42.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	ror $24.b		; 66 24 ; Rotate right $24.b [Reads: Direct Page] [Flags: NCZ]
	jsl $FF0A00.l		; 22 00 0A FF ; Jump to subroutine long $FF0A00.l [Writes: Stack Pointer] [Flow: call]
	sbc $183C7E.l,X		; FF 7E 3C 18 ; Subtract with carry (long,X) $183C7E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $24.b		; 66 24 ; Rotate right $24.b [Reads: Direct Page] [Flags: NCZ]
	cmp $42.b,S		; C3 42 ; Compare accumulator (stack relative) $42.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	sta ($81.b,X)		; 81 81 ; Store accumulator ($81.b,X) [Reads: Direct Page, Accumulator, X Index]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	tsb $18.b		; 04 18 ; Test and set bits $18.b [Reads: Accumulator] [Flags: Z]
	bit $FF7E.w,X		; 3C 7E FF ; Test bits $FF7E.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	sbc $470022.l,X		; FF 22 00 47 ; Subtract with carry (long,X) $470022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp ($30.b,S),Y		; D3 30 ; Compare accumulator (stack relative indirect indexed) ($30.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	ora ($D9.b,X)		; 01 D9 ; Logical OR ($D9.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sec		; 38 ; Set carry flag [Flags: C]
	eor $D3.b		; 45 D3 ; Exclusive OR $D3.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $30, $23		; 30 23 ; Branch if minus to $30, $23 [Flow: branch]
	ora $220700.l		; 0F 00 07 22 ; OR accumulator with memory (long) $220700.l [Writes: Accumulator] [Flags: NZ]
	ora $007F02.l		; 0F 02 7F 00 ; OR accumulator with memory (long) $007F02.l [Writes: Accumulator] [Flags: NZ]
	lda $C00044.l,X		; BF 44 00 C0 ; Load long $C00044.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $CF.b,S		; 03 CF ; OR accumulator with stack relative $CF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $430FC8.l		; 0F C8 0F 43 ; OR accumulator with memory (long) $430FC8.l [Writes: Accumulator] [Flags: NZ]
	wai		; CB ; Wait for interrupt
	tsb $FF23.w		; 0C 23 FF ; Test and set bits $FF23.w [Reads: Accumulator] [Flags: Z]
	and $F0.b,S		; 23 F0 ; AND accumulator with stack relative $F0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	cmp ($30.b)		; D2 30 ; Compare accumulator (indirect) ($30.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp ($30.b),Y		; D1 30 ; Compare accumulator ($30.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	jmp.w [$C43C]		; DC 3C C4 ; Jump long indirect [$C43C] [Flow: jump]
	bit $2FD7.w,X		; 3C D7 2F ; Test bits $2FD7.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	cpx #$1F.b		; E0 1F ; Compare #$1F.b with X register [Reads: X Index] [Flags: NCZ]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03030F.l		; 0F 0F 03 03 ; OR accumulator with memory (long) $03030F.l [Writes: Accumulator] [Flags: NZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $FE.b		; 02 FE ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $03,$00		; 44 00 03 ; Move block positive $03,$00 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $F3.b,S		; 03 F3 ; OR accumulator with stack relative $F3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $13		; F0 13 ; Branch if equal to $F0, $13 [Flow: branch]
	.db $F0, $43		; F0 43 ; Branch if equal to $F0, $43 [Flow: branch]
	cmp ($30.b,S),Y		; D3 30 ; Compare accumulator (stack relative indirect indexed) ($30.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $0F.b,S		; 23 0F ; AND accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	tsb $0C8B.w		; 0C 8B 0C ; Test and set bits $0C8B.w [Reads: Accumulator] [Flags: Z]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $3C23.w,X		; 3C 23 3C ; Test bits $3C23.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	pea $F807.w		; F4 07 F8 ; Push absolute address $F807.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: NCZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $F9F3FC.l,X		; 1F FC F3 F9 ; Logical OR long $F9F3FC.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc [$FB.b],Y		; F7 FB ; Subtract with carry (long indexed) [$FB.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$F3.b]		; E7 F3 ; Subtract with carry (long) [$F3.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $E7CFF7.l		; EF F7 CF E7 ; Subtract with carry (long) $E7CFF7.l [Writes: Accumulator] [Flags: NCVZ]
	cmp $CE9EEE.l,X		; DF EE 9E CE ; Compare accumulator (long,X) $CE9EEE.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	ldx $F0F0.w,Y		; BE F0 F0 ; Load X register $F0F0.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: NCZ]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: NCZ]
	sta ($81.b,X)		; 81 81 ; Store accumulator ($81.b,X) [Reads: Direct Page, Accumulator, X Index]
	cmp $C0CEC0.l		; CF C0 CE C0 ; Compare accumulator (long) $C0CEC0.l [Reads: Accumulator] [Flags: NCZ]
	sta $9E80.w,X		; 9D 80 9E ; Store accumulator to $9E80.w,X [Reads: Accumulator, X Index]
	.db $80, $43		; 80 43 ; Branch always to $80, $43 [Flow: branch]
	and $4300.w,X		; 3D 00 43 ; AND accumulator with memory $4300.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $0300.w,X		; 7D 00 03 ; Add $0300.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $7F7F3F.l,X		; 3F 3F 7F 7F ; AND accumulator with memory (long,X) $7F7F3F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $94.b		; 02 94 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($8484.w,X)		; 7C 84 84 ; Jump indirect indexed to ($8484.w,X) [Reads: X Index] [Flow: jump]
	lda $0700.w		; AD 00 07 ; Load $0700.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $78997C.l,X		; 9F 7C 99 78 ; Store accumulator (long,X) $78997C.l,X [Reads: Accumulator, X Index]
	.db $90, $70		; 90 70 ; Branch if carry clear to $90, $70 [Flow: branch]
	ldx #$63.b		; A2 63 ; Load #$63.b into X register [Writes: X Index] [Flags: NZ]
	bit $03.b		; 24 03 ; Test bits $03.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $00FF1C.l		; 0F 1C FF 00 ; OR accumulator with memory (long) $00FF1C.l [Writes: Accumulator] [Flags: NZ]
	cmp $8800.w,X		; DD 00 88 ; Compare accumulator $8800.w,X [Reads: X Index] [Flags: NCZ]
	jsl $FF0200.l		; 22 00 02 FF ; Jump to subroutine long $FF0200.l [Writes: Stack Pointer] [Flow: call]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $3F0100.l		; 22 00 01 3F ; Jump to subroutine long $3F0100.l [Writes: Stack Pointer] [Flow: call]
	cpy #$26.b		; C0 26 ; Compare #$26.b with Y register [Reads: Y Index] [Flags: NCZ]
	sbc $F00007.l,X		; FF 07 00 F0 ; Subtract with carry (long,X) $F00007.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $C3		; F0 C3 ; Branch if equal to $F0, $C3 [Flow: branch]
	cpy #$0F.b		; C0 0F ; Compare #$0F.b with Y register [Reads: Y Index] [Flags: NCZ]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $FF,$00		; 44 00 FF ; Move block positive $FF,$00 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $D0.b		; 05 D0 ; Logical OR $D0.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $AF.b		; 00 AF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $0EFF26.l,X		; 3F 26 FF 0E ; AND accumulator with memory (long,X) $0EFF26.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $37.b		; 00 37 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EB.b		; 00 EB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $ED.b		; 00 ED ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EB.b		; 00 EB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $15.b		; 00 15 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EA.b		; 00 EA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	rol $FF.b		; 26 FF ; Rotate left $FF.b [Reads: Direct Page] [Flags: NCZ]
	tsb $ECF7.w		; 0C F7 EC ; Test and set bits $ECF7.w [Reads: Accumulator] [Flags: Z]
	ora ($CC.b,X)		; 01 CC ; Logical OR ($CC.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($8D.b,X)		; 01 8D ; Logical OR ($8D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $CD.b		; 00 CD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $ED.b		; 00 ED ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CD.b		; 00 CD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $2702.w		; 8C 02 27 ; Store Y register to $2702.w [Reads: Y Index]
	inc $FF4E.w,X		; FE 4E FF ; Increment memory $FF4E.w,X [Reads: X Index] [Flags: NZ]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $47.b		; 00 47 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($30.b,S),Y		; D3 30 ; Compare accumulator (stack relative indirect indexed) ($30.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	ora ($D9.b,X)		; 01 D9 ; Logical OR ($D9.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sec		; 38 ; Set carry flag [Flags: C]
	eor $D3.b		; 45 D3 ; Exclusive OR $D3.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $30, $23		; 30 23 ; Branch if minus to $30, $23 [Flow: branch]
	ora $220700.l		; 0F 00 07 22 ; OR accumulator with memory (long) $220700.l [Writes: Accumulator] [Flags: NZ]
	ora $042605.l		; 0F 05 26 04 ; OR accumulator with memory (long) $042605.l [Writes: Accumulator] [Flags: NZ]
	and $02.b,S		; 23 02 ; AND accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($01.b,X)		; 21 01 ; Logical AND ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor $20.b,S		; 43 20 ; Exclusive OR accumulator with stack relative $20.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($01.b,X)		; 21 01 ; Logical AND ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $02.b,S		; 23 02 ; AND accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $04.b		; 26 04 ; Rotate left $04.b [Reads: Direct Page] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	trb $1F1E.w		; 1C 1E 1F ; Test and reset bits $1F1E.w [Reads: Accumulator] [Flags: Z]
	ora $181C1E.l,X		; 1F 1E 1C 18 ; Logical OR long $181C1E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	stz $20.b		; 64 20 ; Store zero to $20.b
	cpy $40.b		; C4 40 ; Compare $40.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	sty $80.b		; 84 80 ; Store Y register to $80.b [Reads: Y Index]
	eor $04.b,S		; 43 04 ; Exclusive OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $80.b		; 84 80 ; Store Y register to $80.b [Reads: Y Index]
	cpy $40.b		; C4 40 ; Compare $40.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	stz $20.b		; 64 20 ; Store zero to $20.b
	clc		; 18 ; Clear carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sec		; 38 ; Set carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $FF.b		; 24 FF ; Test bits $FF.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	eor $FE.b,S		; 43 FE ; Exclusive OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $FEFC0E.l,X		; FF 0E FC FE ; Subtract with carry (long,X) $FEFC0E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F9FE.w,X		; FD FE F9 ; Subtract with carry $F9FE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($FFFB.w,X)		; FC FB FF ; Jump to subroutine indirect indexed ($FFFB.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $FCFEFE.l,X		; FF FE FE FC ; Subtract with carry (long,X) $FCFEFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($F8F8.w,X)		; FC F8 F8 ; Jump to subroutine indirect indexed ($F8F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc $00DB84.l,X		; FF 84 DB 00 ; Subtract with carry (long,X) $00DB84.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $FF.b		; 24 FF ; Test bits $FF.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cpx #$24.b		; E0 24 ; Compare #$24.b with X register [Reads: X Index] [Flags: NCZ]
	jsr ($C0F0.w,X)		; FC F0 C0 ; Jump to subroutine indirect indexed ($C0F0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	lda $60A760.l		; AF 60 A7 60 ; Load long $60A760.l into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $30		; D0 30 ; Branch if not equal to $D0, $30 [Flow: branch]
	cld		; D8 ; Clear decimal flag [Flags: D]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $0FF01F.l		; EF 1F F0 0F ; Subtract with carry (long) $0FF01F.l [Writes: Accumulator] [Flags: NCVZ]
	cmp $38C730.l		; CF 30 C7 38 ; Compare accumulator (long) $38C730.l [Reads: Accumulator] [Flags: NCZ]
	ora $070F1F.l,X		; 1F 1F 0F 07 ; Logical OR long $070F1F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $38		; 30 38 ; Branch if minus to $30, $38 [Flow: branch]
	sbc $03FC00.l,X		; FF 00 FC 03 ; Subtract with carry (long,X) $03FC00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($CF.b,S),Y		; 33 CF ; AND accumulator (stack relative indirect indexed) ($CF.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $59DC.w		; 2C DC 59 ; Test bits $59DC.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	eor $D3.b		; 45 D3 ; Exclusive OR $D3.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $30, $04		; 30 04 ; Branch if minus to $30, $04 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$C3.b		; C0 C3 ; Compare #$C3.b with Y register [Reads: Y Index] [Flags: NCZ]
	sta [$22.b]		; 87 22 ; Store accumulator (long) [$22.b] [Reads: Direct Page, Accumulator]
	ora $1FFF14.l		; 0F 14 FF 1F ; OR accumulator with memory (long) $1FFF14.l [Writes: Accumulator] [Flags: NZ]
	sbc $E7FF8F.l,X		; FF 8F FF E7 ; Subtract with carry (long,X) $E7FF8F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $19E733.l,X		; DF 33 E7 19 ; Compare accumulator (long,X) $19E733.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	sbc ($0C.b,S),Y		; F3 0C ; Subtract with carry (stack relative indirect indexed) ($0C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	pea $7887.w		; F4 87 78 ; Push absolute address $7887.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	ora $03070F.l,X		; 1F 0F 07 03 ; Logical OR long $03070F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ror $3EDB.w,X		; 7E DB 3E ; Rotate right $3EDB.w,X [Reads: X Index] [Flags: NCZ]
	sta $78.b,S		; 83 78 ; Store accumulator (stack relative) $78.b,S [Reads: Stack Pointer, Accumulator]
	ora $85.b,S		; 03 85 ; OR accumulator with stack relative $85.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $3E.b,S		; C3 3E ; Compare accumulator (stack relative) $3E.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $FC62FD.l		; 0F FD 62 FC ; OR accumulator with memory (long) $FC62FD.l [Writes: Accumulator] [Flags: NZ]
	and $EC.b,S		; 23 EC ; AND accumulator with stack relative $EC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($F4.b,S),Y		; 33 F4 ; AND accumulator (stack relative indirect indexed) ($F4.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	sbc ($CD.b)		; F2 CD ; Subtract with carry (indirect) ($CD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFE6.w,Y		; F9 E6 FF ; Subtract with carry $FFE6.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $FF		; F0 FF ; Branch if equal to $F0, $FF [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsl $800900.l		; 22 00 09 80 ; Jump to subroutine long $800900.l [Writes: Stack Pointer] [Flow: call]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	sbc $55AA00.l,X		; FF 00 AA 55 ; Subtract with carry (long,X) $55AA00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $00007F.l,X		; FF 7F 00 00 ; Subtract with carry (long,X) $00007F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $2400.w,X		; 3C 00 24 ; Test bits $2400.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	brk $A5.b		; 00 A5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $24.b		; 04 24 ; Test and set bits $24.b [Reads: Accumulator] [Flags: Z]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $18.b		; 25 18 ; Logical AND $18.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	cmp $04.b,S		; C3 04 ; Compare accumulator (stack relative) $04.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	sta ($3A.b,X)		; 81 3A ; Store accumulator ($3A.b,X) [Reads: Direct Page, Accumulator, X Index]
	sta $F122.w,Y		; 99 22 F1 ; Store accumulator to $F122.w,Y [Reads: Y Index, Accumulator]
	asl $E3.b		; 06 E3 ; Arithmetic shift left $E3.b [Reads: Direct Page] [Flags: NCZ]
	tsb $08E7.w		; 0C E7 08 ; Test and set bits $08E7.w [Reads: Accumulator] [Flags: Z]
	sbc $08E700.l,X		; FF 00 E7 08 ; Subtract with carry (long,X) $08E700.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and [$FF.b]		; 27 FF ; AND accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and [$00.b],Y		; 37 00 ; AND accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $BC.b		; 06 BC ; Arithmetic shift left $BC.b [Reads: Direct Page] [Flags: NCZ]
	eor $74.b,S		; 43 74 ; Exclusive OR accumulator with stack relative $74.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $073F7F.l,X		; FF 7F 3F 07 ; Subtract with carry (long,X) $073F7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sbc $09FF18.l,X		; FF 18 FF 09 ; Subtract with carry (long,X) $09FF18.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $FD02.w,X		; FE 02 FD ; Increment memory $FD02.w,X [Reads: X Index] [Flags: NZ]
	sbc [$19.b]		; E7 19 ; Subtract with carry (long) [$19.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	asl $0101.w,X		; 1E 01 01 ; Arithmetic shift left $0101.w,X [Reads: X Index] [Flags: NCZ]
	jsl $FF2200.l		; 22 00 22 FF ; Jump to subroutine long $FF2200.l [Writes: Stack Pointer] [Flow: call]
	ora ($FE.b),Y		; 11 FE ; OR accumulator with memory ($FE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $00011F.l,X		; FF 1F 01 00 ; Subtract with carry (long,X) $00011F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $50, $BF		; 50 BF ; Branch if overflow clear to $50, $BF [Flow: branch]
	cpx #$5F.b		; E0 5F ; Compare #$5F.b with X register [Reads: X Index] [Flags: NCZ]
	sbc ($EE.b),Y		; F1 EE ; Subtract with carry ($EE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $C2F0.w,X		; 7E F0 C2 ; Rotate right $C2F0.w,X [Reads: X Index] [Flags: NCZ]
	jsr ($FC02.w,X)		; FC 02 FC ; Jump to subroutine indirect indexed ($FC02.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr ($0022.w,X)		; FC 22 00 ; Jump to subroutine indirect indexed ($0022.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc $7E7FBF.l,X		; FF BF 7F 7E ; Subtract with carry (long,X) $7E7FBF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $FCFE.w,X		; FE FE FC ; Increment memory $FCFE.w,X [Reads: X Index] [Flags: NZ]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	bit $0100.w		; 2C 00 01 ; Test bits $0100.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	cpy #$80.b		; C0 80 ; Compare #$80.b with Y register [Reads: Y Index] [Flags: NCZ]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $7FC639.l		; 0F 39 C6 7F ; OR accumulator with memory (long) $7FC639.l [Writes: Accumulator] [Flags: NZ]
	sta ($F9.b,X)		; 81 F9 ; Store accumulator ($F9.b,X) [Reads: Direct Page, Accumulator, X Index]
	ora [$39.b]		; 07 39 ; OR accumulator with memory (long) [$39.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc [$E4.b],Y		; F7 E4 ; Subtract with carry (long indexed) [$E4.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	bit $FB.b		; 24 FB ; Test bits $FB.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	asl $F9.b		; 06 F9 ; Arithmetic shift left $F9.b [Reads: Direct Page] [Flags: NCZ]
	sbc $2200.w,Y		; F9 00 22 ; Subtract with carry $2200.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $223F00.l,X		; FF 00 3F 22 ; Subtract with carry (long,X) $223F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $00F903.l,X		; FF 03 F9 00 ; Subtract with carry (long,X) $00F903.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $00.b		; 46 00 ; Logical shift right $00.b [Reads: Direct Page] [Flags: NCZ]
	sbc $009F43.l,X		; FF 43 9F 00 ; Subtract with carry (long,X) $009F43.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $01BE.w		; 0C BE 01 ; Test and set bits $01BE.w [Reads: Accumulator] [Flags: Z]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$04.b],Y		; F7 04 ; Subtract with carry (long indexed) [$04.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $96.b		; 66 96 ; Rotate right $96.b [Reads: Direct Page] [Flags: NCZ]
	stx $BF.b,Y		; 96 BF ; Store X register $BF.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $46.b		; 04 46 ; Test and set bits $46.b [Reads: Accumulator] [Flags: Z]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00CB.w		; 0D CB 00 ; Logical OR $00CB.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp ($00.b,S),Y		; D3 00 ; Compare accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta ($00.b),Y		; 91 00 ; Store accumulator ($00.b),Y [Reads: Direct Page, Y Index, Accumulator]
	tsb $FB.b		; 04 FB ; Test and set bits $FB.b [Reads: Accumulator] [Flags: Z]
	tsb $76.b		; 04 76 ; Test and set bits $76.b [Reads: Accumulator] [Flags: Z]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	eor ($FB.b)		; 52 FB ; Exclusive OR accumulator with memory (indirect) ($FB.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $1D.b		; 02 1D ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BF.b		; 00 BF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $DD,$00		; 44 00 DD ; Move block positive $DD,$00 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sbc $3500.w,X		; FD 00 35 ; Subtract with carry $3500.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $55A2.w,X		; 1D A2 55 ; OR accumulator with memory $55A2.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $35.b,X		; 55 35 ; Exclusive OR accumulator with memory $35.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $0023.w,X		; FD 23 00 ; Subtract with carry $0023.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($F8.b,S),Y		; 13 F8 ; OR accumulator (stack relative indirect indexed) ($F8.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EE.b		; 00 EE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $29.b		; 00 29 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $00.b		; C6 00 ; Decrement $00.b [Reads: Direct Page] [Flags: NZ]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $32.b		; 04 32 ; Test and set bits $32.b [Reads: Accumulator] [Flags: Z]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$23EF.w		; 29 EF 23 ; Logical AND #$23EF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $001F00.l		; 0F 00 1F 00 ; OR accumulator with memory (long) $001F00.l [Writes: Accumulator] [Flags: NZ]
	trb $BF83.w		; 1C 83 BF ; Test and reset bits $BF83.w [Reads: Accumulator] [Flags: Z]
	ora $08.b,S		; 03 08 ; OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($14.b,S),Y		; 13 14 ; OR accumulator (stack relative indirect indexed) ($14.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $3C.b		; 24 3C ; Test bits $3C.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $8F.b		; 02 8F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DF.b		; 00 DF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $EF,$00		; 44 00 EF ; Move block positive $EF,$00 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sbc $669900.l,X		; FF 00 99 66 ; Subtract with carry (long,X) $669900.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $A92950.l		; 8F 50 29 A9 ; Store accumulator (long) $A92950.l [Reads: Accumulator]
	sta $23FF.w,Y		; 99 FF 23 ; Store accumulator to $23FF.w,Y [Reads: Y Index, Accumulator]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$44.b		; E0 44 ; Compare #$44.b with X register [Reads: X Index] [Flags: NCZ]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $20.b,X		; 15 20 ; OR accumulator with memory $20.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$10.b		; E0 10 ; Compare #$10.b with X register [Reads: X Index] [Flags: NCZ]
	.db $D0, $20		; D0 20 ; Branch if not equal to $D0, $20 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cpx #$C3.b		; E0 C3 ; Compare #$C3.b with X register [Reads: X Index] [Flags: NCZ]
	sta ($42.b,X)		; 81 42 ; Store accumulator ($42.b,X) [Reads: Direct Page, Accumulator, X Index]
	sta ($C3.b,X)		; 81 C3 ; Store accumulator ($C3.b,X) [Reads: Direct Page, Accumulator, X Index]
	sta ($4A.b,X)		; 81 4A ; Store accumulator ($4A.b,X) [Reads: Direct Page, Accumulator, X Index]
	sta ($43.b,X)		; 81 43 ; Store accumulator ($43.b,X) [Reads: Direct Page, Accumulator, X Index]
	sbc $FB0000.l,X		; FF 00 00 FB ; Subtract with carry (long,X) $FB0000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $C30D00.l		; 22 00 0D C3 ; Jump to subroutine long $C30D00.l [Writes: Stack Pointer] [Flow: call]
	.db $42, $C3		; 42 C3 ; Reserved instruction
	wai		; CB ; Wait for interrupt
	ror $04.b,X		; 76 04 ; Rotate right $04.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($6C.b,S),Y		; F3 6C ; Subtract with carry (stack relative indirect indexed) ($6C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sta ($D7.b,S),Y		; 93 D7 ; Store accumulator (stack relative indirect indexed) ($D7.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	sta $83.b,S		; 83 83 ; Store accumulator (stack relative) $83.b,S [Reads: Stack Pointer, Accumulator]
	rol $0205.w		; 2E 05 02 ; Rotate left $0205.w [Flags: NCZ]
	sbc $F800.w,X		; FD 00 F8 ; Subtract with carry $F800.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $FF0F00.l		; 22 00 0F FF ; Jump to subroutine long $FF0F00.l [Writes: Stack Pointer] [Flow: call]
	jmp ($CBD7.w)		; 6C D7 CB ; Jump indirect to ($CBD7.w) [Flow: jump]
	ror $05.b,X		; 76 05 ; Rotate right $05.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $19A6.w,X		; 3D A6 19 ; AND accumulator with memory $19A6.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda $19A619.l,X		; BF 19 A6 19 ; Load long $19A619.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($22.b,S),Y		; F3 22 ; Subtract with carry (stack relative indirect indexed) ($22.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $BFBFA6.l,X		; FF A6 BF BF ; Subtract with carry (long,X) $BFBFA6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $0C.b		; 66 0C ; Rotate right $0C.b [Reads: Direct Page] [Flags: NCZ]
	sbc ($00.b,S),Y		; F3 00 ; Subtract with carry (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc ($7A.b),Y		; F1 7A ; Subtract with carry ($7A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($D3.b),Y		; 91 D3 ; Store accumulator ($D3.b),Y [Reads: Direct Page, Y Index, Accumulator]
	sta ($4A.b,X)		; 81 4A ; Store accumulator ($4A.b,X) [Reads: Direct Page, Accumulator, X Index]
	sta ($43.b,X)		; 81 43 ; Store accumulator ($43.b,X) [Reads: Direct Page, Accumulator, X Index]
	sbc $FB0000.l,X		; FF 00 00 FB ; Subtract with carry (long,X) $FB0000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $FB0200.l		; 22 00 02 FB ; Jump to subroutine long $FB0200.l [Writes: Stack Pointer] [Flow: call]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	cmp ($84.b,S),Y		; D3 84 ; Compare accumulator (stack relative indirect indexed) ($84.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0C.b		; 05 0C ; Logical OR $0C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $9568.w,X		; FD 68 95 ; Subtract with carry $9568.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sbc $A538.w,X		; FD 38 A5 ; Subtract with carry $A538.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda $DF00.w,X		; BD 00 DF ; Load $DF00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $89.b		; 00 89 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $FD1400.l		; 22 00 14 FD ; Jump to subroutine long $FD1400.l [Writes: Stack Pointer] [Flow: call]
	sta $FD.b,X		; 95 FD ; Store accumulator to $FD.b,X [Reads: Accumulator, X Index]
	lda $56A5.w,X		; BD A5 56 ; Load $56A5.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	bit #$EF00.w		; 89 00 EF ; Test bits #$EF00.w with accumulator [Reads: Accumulator] [Flags: Z]
	dec $29.b		; C6 29 ; Decrement $29.b [Reads: Direct Page] [Flags: NZ]
	dec $EF.b		; C6 EF ; Decrement $EF.b [Reads: Direct Page] [Flags: NZ]
	dec $2A.b		; C6 2A ; Decrement $2A.b [Reads: Direct Page] [Flags: NZ]
	cpy $FE.b		; C4 FE ; Compare $FE.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $EF1400.l		; 22 00 14 EF ; Jump to subroutine long $EF1400.l [Writes: Stack Pointer] [Flow: call]
	and #$EEEF.w		; 29 EF EE ; Logical AND #$EEEF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and ($04.b)		; 32 04 ; AND accumulator with memory (indirect) ($04.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $18.b		; 24 18 ; Test bits $18.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	bit $1418.w,X		; 3C 18 14 ; Test bits $1418.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $000F00.l,X		; 1F 00 0F 00 ; Logical OR long $000F00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $3C24.w,X		; 3C 24 3C ; Test bits $3C24.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	trb $0813.w		; 1C 13 08 ; Test and reset bits $0813.w [Reads: Accumulator] [Flags: Z]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $669967.l,X		; FF 67 99 66 ; Subtract with carry (long,X) $669967.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $46A966.l,X		; FF 66 A9 46 ; Subtract with carry (long,X) $46A966.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $00DF00.l		; EF 00 DF 00 ; Subtract with carry (long) $00DF00.l [Writes: Accumulator] [Flags: NCVZ]
	sta $0C0022.l		; 8F 22 00 0C ; Store accumulator (long) $0C0022.l [Reads: Accumulator]
	sbc $EFFF99.l,X		; FF 99 FF EF ; Subtract with carry (long,X) $EFFF99.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and #$8F50.w		; 29 50 8F ; Logical AND #$8F50.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$A0.b		; C0 A0 ; Compare #$A0.b with Y register [Reads: Y Index] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $1E.b,S		; 83 1E ; Store accumulator (stack relative) $1E.b,S [Reads: Stack Pointer, Accumulator]
	ora $02.b		; 05 02 ; Logical OR $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $E700C3.l		; 0F C3 00 E7 ; OR accumulator with memory (long) $E700C3.l [Writes: Accumulator] [Flags: NZ]
	brk $EC.b		; 00 EC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $F7.b,S		; 83 F7 ; Store accumulator (stack relative) $F7.b,S [Reads: Stack Pointer, Accumulator]
	tsb $EC.b		; 04 EC ; Test and set bits $EC.b [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $F1.b		; 14 F1 ; Test and reset bits $F1.b [Reads: Accumulator] [Flags: Z]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	jsl $7C14FF.l		; 22 FF 14 7C ; Jump to subroutine long $7C14FF.l [Writes: Stack Pointer] [Flow: call]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	adc ($63.b),Y		; 71 63 ; Add with carry ($63.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$E1.b]		; 07 E1 ; OR accumulator with memory (long) [$E1.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $F3.b		; 00 F3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $ED.b		; 00 ED ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($F3.b,X)		; E1 F3 ; Subtract with carry ($F3.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($3F.b)		; 12 3F ; OR accumulator with memory (indirect) ($3F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $12DE.w		; 2D DE 12 ; Logical AND $12DE.w with accumulator [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $FF22.w		; 0E 22 FF ; Arithmetic shift left $FF22.w [Flags: NCZ]
	tsb $1E.b		; 04 1E ; Test and set bits $1E.b [Reads: Accumulator] [Flags: Z]
	tsb $E1C0.w		; 0C C0 E1 ; Test and set bits $E1C0.w [Reads: Accumulator] [Flags: Z]
	sbc ($43.b),Y		; F1 43 ; Subtract with carry ($43.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $010B00.l,X		; FF 00 0B 01 ; Subtract with carry (long,X) $010B00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $87.b		; 02 87 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $7F.b		; 85 7F ; Store accumulator to $7F.b [Reads: Accumulator]
	cop $C1.b		; 02 C1 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($80.b,X)		; 01 80 ; Logical OR ($80.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $14FF22.l,X		; 3F 22 FF 14 ; AND accumulator with memory (long,X) $14FF22.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($78.b,X)		; 01 78 ; Logical OR ($78.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsr ($C0FE.w,X)		; FC FE C0 ; Jump to subroutine indirect indexed ($C0FE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: NCZ]
	sbc $007F00.l,X		; FF 00 7F 00 ; Subtract with carry (long,X) $007F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $83.b,S		; 83 83 ; Store accumulator (stack relative) $83.b,S [Reads: Stack Pointer, Accumulator]
	sbc $EA7C.w,X		; FD 7C EA ; Subtract with carry $EA7C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $FF.b		; 24 FF ; Test bits $FF.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora ($7C.b)		; 12 7C ; OR accumulator with memory (indirect) ($7C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: NCZ]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9F.b		; 00 9F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $8F		; 80 8F ; Branch always to $80, $8F [Flow: branch]
	.db $80, $87		; 80 87 ; Branch always to $80, $87 [Flow: branch]
	.db $80, $E3		; 80 E3 ; Branch always to $80, $E3 [Flow: branch]
	cpx #$23.b		; E0 23 ; Compare #$23.b with X register [Reads: X Index] [Flags: NCZ]
	sbc $107F22.l,X		; FF 22 7F 10 ; Subtract with carry (long,X) $107F22.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $2F001F.l,X		; 1F 1F 00 2F ; Logical OR long $2F001F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $77.b		; 00 77 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E4.b		; 00 E4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $C7.b		; 04 C7 ; Test and set bits $C7.b [Reads: Accumulator] [Flags: Z]
	ora [$8F.b]		; 07 8F ; OR accumulator with memory (long) [$8F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $23101F.l		; 0F 1F 10 23 ; OR accumulator with memory (long) $23101F.l [Writes: Accumulator] [Flags: NZ]
	sbc $F8FB03.l,X		; FF 03 FB F8 ; Subtract with carry (long,X) $F8FB03.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	mvp $00,$FF		; 44 FF 00 ; Move block positive $00,$FF [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	bit $FF.b		; 24 FF ; Test bits $FF.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $FF.b		; 24 FF ; Test bits $FF.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	jsl $FC0F00.l		; 22 00 0F FC ; Jump to subroutine long $FC0F00.l [Writes: Stack Pointer] [Flow: call]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E7.b		; 00 E7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $73.b		; 00 73 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $39.b		; 00 39 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $99.b		; 00 99 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	cpy #$FF.b		; C0 FF ; Compare #$FF.b with Y register [Reads: Y Index] [Flags: NCZ]
	adc $01FF24.l,X		; 7F 24 FF 01 ; Add long $01FF24.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $004D3F.l,X		; 7F 3F 4D 00 ; Add long $004D3F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $280022.l,X		; FF 22 00 28 ; Subtract with carry (long,X) $280022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $230000.l,X		; FF 00 00 23 ; Subtract with carry (long,X) $230000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $009383.l,X		; FF 83 93 00 ; Subtract with carry (long,X) $009383.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $FF.b		; 24 FF ; Test bits $FF.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $000022.l,X		; FF 22 00 00 ; Subtract with carry (long,X) $000022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $0F0022.l,X		; FF 22 00 0F ; Subtract with carry (long,X) $0F0022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FF80FF.l,X		; FF FF 80 FF ; Subtract with carry (long,X) $FF80FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $F8BFFC.l,X		; BF FC BF F8 ; Load long $F8BFFC.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda [$F8.b],Y		; B7 F8 ; Load accumulator (long indexed) [$F8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda $E0BFF0.l,X		; BF F0 BF E0 ; Load long $E0BFF0.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $FF27E0.l,X		; 9F E0 27 FF ; Store accumulator (long,X) $FF27E0.l,X [Reads: Accumulator, X Index]
	ora ($BD.b,X)		; 01 BD ; Logical OR ($BD.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	inc $F48B.w,X		; FE 8B F4 ; Increment memory $F48B.w,X [Reads: X Index] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: NCZ]
	and [$FF.b]		; 27 FF ; AND accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $30,$1F		; 44 1F 30 ; Move block positive $30,$1F [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cop $3F.b		; 02 3F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $30,$1F		; 44 1F 30 ; Move block positive $30,$1F [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $C0BFE0.l,X		; DF E0 BF C0 ; Compare accumulator (long,X) $C0BFE0.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	adc $FF4680.l,X		; 7F 80 46 FF ; Add long $FF4680.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $7FBFDF.l		; EF DF BF 7F ; Subtract with carry (long) $7FBFDF.l [Writes: Accumulator] [Flags: NCVZ]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora #$44C5.w		; 09 C5 44 ; Logical OR #$44C5.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp $54.b,X		; D5 54 ; Compare accumulator $54.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cmp ($50.b),Y		; D1 50 ; Compare accumulator ($50.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cmp $CD58.w,Y		; D9 58 CD ; Compare accumulator $CD58.w,Y [Reads: Y Index] [Flags: NCZ]
	jmp $5085.w		; 4C 85 50 ; Jump to $5085.w [Flow: jump]
	ora ($0B.b,X)		; 01 0B ; Logical OR ($0B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rol $3226.w		; 2E 26 32 ; Rotate left $3226.w [Flags: NCZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rol $00FF.w		; 2E FF 00 ; Rotate left $00FF.w [Flags: NCZ]
	sbc $548B7E.l,X		; FF 7E 8B 54 ; Subtract with carry (long,X) $548B7E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $62.b		; 85 62 ; Store accumulator to $62.b [Reads: Accumulator]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc ($00.b,S),Y		; F3 00 ; Subtract with carry (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	jsr ($43EC.w,X)		; FC EC 43 ; Jump to subroutine indirect indexed ($43EC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $08ED.w,X		; FD ED 08 ; Subtract with carry $08ED.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $D5DD.w		; ED DD D5 ; Subtract $D5DD.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	lda $6FAB.w,X		; BD AB 6F ; Load $6FAB.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $2303C7.l		; 0F C7 03 23 ; OR accumulator with memory (long) $2303C7.l [Writes: Accumulator] [Flags: NZ]
	cop $E0.b		; 02 E0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and #$3A10.w		; 29 10 3A ; Logical AND #$3A10.w with accumulator [Writes: Accumulator] [Flags: NZ]
	rol $7E42.w,X		; 3E 42 7E ; Rotate left $7E42.w,X [Reads: X Index] [Flags: NCZ]
	bit #$25FF.w		; 89 FF 25 ; Test bits #$25FF.w with accumulator [Reads: Accumulator] [Flags: Z]
	cmp $51DF22.l,X		; DF 22 DF 51 ; Compare accumulator (long,X) $51DF22.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	sbc $3FF06F.l		; EF 6F F0 3F ; Subtract with carry (long) $3FF06F.l [Writes: Accumulator] [Flags: NCVZ]
	sbc $3881C1.l,X		; FF C1 81 38 ; Subtract with carry (long,X) $3881C1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp ($7F7E.w,X)		; 7C 7E 7F ; Jump indirect indexed to ($7F7E.w,X) [Reads: X Index] [Flow: jump]
	adc $7E033F.l,X		; 7F 3F 03 7E ; Add long $7E033F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $DE.b,S		; 23 DE ; AND accumulator with stack relative $DE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor ($EE.b,S),Y		; 53 EE ; XOR accumulator (stack relative indirect indexed) ($EE.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	inc $77.b,X		; F6 77 ; Increment memory $77.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	rol $4EBF.w,X		; 3E BF 4E ; Rotate left $4EBF.w,X [Reads: X Index] [Flags: NCZ]
	sta $23BE70.l		; 8F 70 BE 23 ; Store accumulator (long) $23BE70.l [Reads: Accumulator]
	ror $2FE0.w,X		; 7E E0 2F ; Rotate right $2FE0.w,X [Reads: X Index] [Flags: NCZ]
	rol $000E.w,X		; 3E 0E 00 ; Rotate left $000E.w,X [Reads: X Index] [Flags: NCZ]
	cmp $30.b,X		; D5 30 ; Compare accumulator $30.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	eor [$C3.b],Y		; 57 C3 ; Exclusive OR accumulator with memory (long indexed) [$C3.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda $0F5F87.l		; AF 87 5F 0F ; Load long $0F5F87.l into accumulator [Writes: Accumulator] [Flags: NZ]
	lda $3F401F.l,X		; BF 1F 40 3F ; Load long $3F401F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $1D0E00.l,X		; FF 00 0E 1D ; Subtract with carry (long,X) $1D0E00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc [$EF.b],Y		; 77 EF ; Add with carry (long indexed) [$EF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $BB60BF.l,X		; DF BF 60 BB ; Compare accumulator (long,X) $BB60BF.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	wai		; CB ; Wait for interrupt
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	sbc ($6E.b,X)		; E1 6E ; Subtract with carry ($6E.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda ($70.b),Y		; B1 70 ; Load accumulator ($70.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $7E8F7E.l,X		; 9F 7E 8F 7E ; Store accumulator (long,X) $7E8F7E.l,X [Reads: Accumulator, X Index]
	sta ($7E.b,X)		; 81 7E ; Store accumulator ($7E.b,X) [Reads: Direct Page, Accumulator, X Index]
	tsb $44.b		; 04 44 ; Test and set bits $44.b [Reads: Accumulator] [Flags: Z]
	bit $10.b		; 24 10 ; Test bits $10.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	asl $0022.w		; 0E 22 00 ; Arithmetic shift left $0022.w [Flags: NCZ]
	trb $DD.b		; 14 DD ; Test and reset bits $DD.b [Reads: Accumulator] [Flags: Z]
	eor ($CE.b,X)		; 41 CE ; Exclusive OR accumulator with memory ($CE.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cmp [$40.b]		; C7 40 ; Compare accumulator (long) [$40.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cpx #$60.b		; E0 60 ; Compare #$60.b with X register [Reads: X Index] [Flags: NCZ]
	.db $F0, $70		; F0 70 ; Branch if equal to $F0, $70 [Flow: branch]
	lda $7F9F7F.l,X		; BF 7F 9F 7F ; Load long $7F9F7F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $3F3E00.l,X		; FF 00 3E 3F ; Subtract with carry (long,X) $3F3E00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $220F1F.l,X		; 3F 1F 0F 22 ; AND accumulator with memory (long,X) $220F1F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $D828.w		; 2E 28 D8 ; Rotate left $D828.w [Flags: NCZ]
	lda $DD.b		; A5 DD ; Load $DD.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($6F.b,S),Y		; 13 6F ; OR accumulator (stack relative indirect indexed) ($6F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora #$E477.w		; 09 77 E4 ; Logical OR #$E477.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	sbc ($BD.b)		; F2 BD ; Subtract with carry (indirect) ($BD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda $FFDF.w,Y		; B9 DF FF ; Load $FFDF.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $27.b		; 00 27 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($B8.b)		; 32 B8 ; AND accumulator with memory (indirect) ($B8.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy $3F3E.w,X		; BC 3E 3F ; Load Y register $3F3E.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ora $8FEF00.l,X		; 1F 00 EF 8F ; Logical OR long $8FEF00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $911F.w,Y		; D9 1F 91 ; Compare accumulator $911F.w,Y [Reads: Y Index] [Flags: NCZ]
	ora $A01E00.l,X		; 1F 00 1E A0 ; Logical OR long $A01E00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	stx $C05E.w		; 8E 5E C0 ; Store X register to $C05E.w [Reads: X Index]
	jsr $FFE0.w		; 20 E0 FF ; Jump to subroutine at $FFE0.w [Writes: Stack Pointer] [Flow: call]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: NCZ]
	sbc ($71.b,X)		; E1 71 ; Subtract with carry ($71.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $00461F.l,X		; 3F 1F 46 00 ; AND accumulator with memory (long,X) $00461F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $25FF22.l,X		; FF 22 FF 25 ; Subtract with carry (long,X) $25FF22.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $220000.l,X		; FF 00 00 22 ; Subtract with carry (long,X) $220000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $830023.l,X		; FF 23 00 83 ; Subtract with carry (long,X) $830023.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	stz $2300.w,X		; 9E 00 23 ; Store zero to $2300.w,X [Reads: X Index]
	brk $84.b		; 00 84 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000022.l,X		; FF 22 00 00 ; Subtract with carry (long,X) $000022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $0F0022.l,X		; FF 22 00 0F ; Subtract with carry (long,X) $0F0022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FF01FF.l,X		; FF FF 01 FF ; Subtract with carry (long,X) $FF01FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FCFF.w,X		; FD FF FC ; Subtract with carry $FCFF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $FCDE.w,X		; FE DE FC ; Increment memory $FCDE.w,X [Reads: X Index] [Flags: NZ]
	nop		; EA ; No operation
	jsr ($F8FE.w,X)		; FC FE F8 ; Jump to subroutine indirect indexed ($F8FE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $27F0.w,X		; FE F0 27 ; Increment memory $27F0.w,X [Reads: X Index] [Flags: NZ]
	sbc $808001.l,X		; FF 01 80 80 ; Subtract with carry (long,X) $808001.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $007F.w		; 4D 7F 00 ; Exclusive OR $007F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and #$43FF.w		; 29 FF 43 ; Logical AND #$43FF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $FF.b		; 02 FF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $00,$FF		; 44 FF 00 ; Move block positive $00,$FF [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $20.b		; E4 20 ; Compare $20.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pei ($54.b)		; D4 54 ; Push effective indirect address ($54.b) [Reads: Direct Page] [Writes: Stack Pointer]
	dec $56.b,X		; D6 56 ; Decrement memory $56.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	cpy #$40.b		; C0 40 ; Compare #$40.b with Y register [Reads: Y Index] [Flags: NCZ]
	dec $46.b		; C6 46 ; Decrement $46.b [Reads: Direct Page] [Flags: NZ]
	.db $F0, $40		; F0 40 ; Branch if equal to $F0, $40 [Flow: branch]
	mvp $7F,$FF		; 44 FF 7F ; Move block positive $7F,$FF [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	and #$393F.w		; 29 3F 39 ; Logical AND #$393F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $070024.l,X		; 3F 24 00 07 ; AND accumulator with memory (long,X) $070024.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc ($73.b,S),Y		; 73 73 ; Add with carry (stack relative indirect indexed) ($73.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	dec $00CE.w		; CE CE 00 ; Decrement $00CE.w [Flags: NZ]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FF0005.l,X		; FF 05 00 FF ; Subtract with carry (long,X) $FF0005.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sty $31E7.w		; 8C E7 31 ; Store Y register to $31E7.w [Reads: Y Index]
	sbc $E00022.l,X		; FF 22 00 E0 ; Subtract with carry (long,X) $E00022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sec		; 38 ; Set carry flag [Flags: C]
	cmp $43.b,S		; C3 43 ; Compare accumulator (stack relative) $43.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	dec $43.b		; C6 43 ; Decrement $43.b [Reads: Direct Page] [Flags: NZ]
	cpx $F467.w		; EC 67 F4 ; Compare $F467.w with X register [Reads: X Index] [Flags: NCZ]
	adc [$F5.b],Y		; 77 F5 ; Add with carry (long indexed) [$F5.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc [$BD.b],Y		; 77 BD ; Add with carry (long indexed) [$BD.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $FFBF40.l,X		; 7F 40 BF FF ; Add long $FFBF40.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $0919.w,X		; 3C 19 09 ; Test bits $0919.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	ora #$0001.w		; 09 01 00 ; Logical OR #$0001.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $2F		; F0 2F ; Branch if equal to $F0, $2F [Flow: branch]
	.db $F0, $1F		; F0 1F ; Branch if equal to $F0, $1F [Flow: branch]
	.db $F0, $8F		; F0 8F ; Branch if equal to $F0, $8F [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	eor [$BC.b]		; 47 BC ; Exclusive OR accumulator with memory (long) [$BC.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	dec $FF.b		; C6 FF ; Decrement $FF.b [Reads: Direct Page] [Flags: NZ]
	inc $00FF.w,X		; FE FF 00 ; Increment memory $00FF.w,X [Reads: X Index] [Flags: NZ]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	jsr ($FEFE.w,X)		; FC FE FE ; Jump to subroutine indirect indexed ($FEFE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $35.b		; 00 35 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $D0, $6B		; D0 6B ; Branch if not equal to $D0, $6B [Flow: branch]
	lda ($D7.b,X)		; A1 D7 ; Load accumulator ($D7.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor $A8.b,S		; 43 A8 ; Exclusive OR accumulator with stack relative $A8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$80.b]		; 07 80 ; OR accumulator with memory (long) [$80.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $DE.b		; 85 DE ; Store accumulator to $DE.b [Reads: Accumulator]
	brk $84.b		; 00 84 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp [$01.b],Y		; D7 01 ; Compare accumulator (long indexed) [$01.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $FF0700.l		; 22 00 07 FF ; Jump to subroutine long $FF0700.l [Writes: Stack Pointer] [Flow: call]
	.db $F0, $FF		; F0 FF ; Branch if equal to $F0, $FF [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $FE01FC.l,X		; FF FC 01 FE ; Subtract with carry (long,X) $FE01FC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sty $EA.b		; 84 EA ; Store Y register to $EA.b [Reads: Y Index]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $8300FF.l,X		; FF FF 00 83 ; Subtract with carry (long,X) $8300FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $E00022.l,X		; FF 22 00 E0 ; Subtract with carry (long,X) $E00022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and [$38.b],Y		; 37 38 ; AND accumulator with memory (long indexed) [$38.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc [$7E.b]		; E7 7E ; Subtract with carry (long) [$7E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp $EF8FFF.l		; CF FF 8F EF ; Compare accumulator (long) $EF8FFF.l [Reads: Accumulator] [Flags: NCZ]
	ora [$97.b]		; 07 97 ; OR accumulator with memory (long) [$97.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $8F.b		; 00 8F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C3		; 80 C3 ; Branch always to $80, $C3 [Flow: branch]
	cpx #$80.b		; E0 80 ; Compare #$80.b with X register [Reads: X Index] [Flags: NCZ]
	.db $D0, $E7		; D0 E7 ; Branch if not equal to $D0, $E7 [Flow: branch]
	cmp $78378F.l		; CF 8F 37 78 ; Compare accumulator (long) $78378F.l [Reads: Accumulator] [Flags: NCZ]
	adc $3F2F1F.l,X		; 7F 1F 2F 3F ; Add long $3F2F1F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx $7B.b		; E4 7B ; Compare $7B.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $18EB1F.l		; EF 1F EB 18 ; Subtract with carry (long) $18EB1F.l [Writes: Accumulator] [Flags: NCVZ]
	cmp $20B810.l,X		; DF 10 B8 20 ; Compare accumulator (long,X) $20B810.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	adc [$47.b],Y		; 77 47 ; Add with carry (long indexed) [$47.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $C7.b,S		; E3 C7 ; Subtract stack-relative $C7.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	sta [$00.b]		; 87 00 ; Store accumulator (long) [$00.b] [Reads: Direct Page, Accumulator]
	ora [$EF.b]		; 07 EF ; OR accumulator with memory (long) [$EF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $F8F8B8.l,X		; DF B8 F8 F8 ; Compare accumulator (long,X) $F8F8B8.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	asl $FEF0.w		; 0E F0 FE ; Arithmetic shift left $FEF0.w [Flags: NCZ]
	cpx #$DE.b		; E0 DE ; Compare #$DE.b with X register [Reads: X Index] [Flags: NCZ]
	cpx #$43.b		; E0 43 ; Compare #$43.b with X register [Reads: X Index] [Flags: NCZ]
	inc $02C0.w,X		; FE C0 02 ; Increment memory $02C0.w,X [Reads: X Index] [Flags: NZ]
	dec $FDE0.w,X		; DE E0 FD ; Decrement memory $FDE0.w,X [Reads: X Index] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	sbc $4C0000.l,X		; FF 00 00 4C ; Subtract with carry (long,X) $4C0000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BF.b		; 00 BF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	sbc $FFFD43.l,X		; FF 43 FD FF ; Subtract with carry (long,X) $FFFD43.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $ED.b,S		; 03 ED ; OR accumulator with stack relative $ED.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $43FFDD.l,X		; FF DD FF 43 ; Subtract with carry (long,X) $43FFDD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($03FE.w,X)		; FC FE 03 ; Jump to subroutine indirect indexed ($03FE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cop $FC.b		; 02 FC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	and [$FF.b]		; 27 FF ; AND accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $BF.b		; 02 BF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$FF.b		; C0 FF ; Compare #$FF.b with Y register [Reads: Y Index] [Flags: NCZ]
	eor $80.b,S		; 43 80 ; Exclusive OR accumulator with stack relative $80.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $7F0045.l,X		; 7F 45 00 7F ; Add long $7F0045.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $FF2700.l		; 22 00 27 FF ; Jump to subroutine long $FF2700.l [Writes: Stack Pointer] [Flow: call]
	ora $EE.b,S		; 03 EE ; OR accumulator with stack relative $EE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $DE		; F0 DE ; Branch if equal to $F0, $DE [Flow: branch]
	cpx #$43.b		; E0 43 ; Compare #$43.b with X register [Reads: X Index] [Flags: NCZ]
	inc $83C0.w,X		; FE C0 83 ; Increment memory $83C0.w,X [Reads: X Index] [Flags: NZ]
	stz $0003.w		; 9C 03 00 ; Store zero to $0003.w
	ora ($2A.b,X)		; 01 2A ; Logical OR ($2A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $007F49.l,X		; FF 49 7F 00 ; Subtract with carry (long,X) $007F49.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $BF.b		; 02 BF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FF2A80.l,X		; FF 80 2A FF ; Subtract with carry (long,X) $FF2A80.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	.db $D0, $30		; D0 30 ; Branch if not equal to $D0, $30 [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	mvp $60,$CC		; 44 CC 60 ; Move block positive $60,$CC [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sbc [$71.b]		; E7 71 ; Subtract with carry (long) [$71.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $79		; F0 79 ; Branch if equal to $F0, $79 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	eor $7B.b,S		; 43 7B ; Exclusive OR accumulator with stack relative $7B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	cpx #$3F.b		; E0 3F ; Compare #$3F.b with X register [Reads: X Index] [Flags: NCZ]
	ora $183367.l		; 0F 67 33 18 ; OR accumulator with memory (long) $183367.l [Writes: Accumulator] [Flags: NZ]
	asl $0406.w		; 0E 06 04 ; Arithmetic shift left $0406.w [Flags: NCZ]
	tsb $33.b		; 04 33 ; Test and set bits $33.b [Reads: Accumulator] [Flags: Z]
	sbc $CADE62.l		; EF 62 DE CA ; Subtract with carry (long) $CADE62.l [Writes: Accumulator] [Flags: NCVZ]
	ldx $7E9A.w,Y		; BE 9A 7E ; Load X register $7E9A.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	lda ($77.b,S),Y		; B3 77 ; Load accumulator (stack relative indirect indexed) ($77.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $67.b,S		; E3 67 ; Subtract stack-relative $67.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	cmp $DA47.w		; CD 47 DA ; Compare $DA47.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	eor $E0.b,S		; 43 E0 ; Exclusive OR accumulator with stack relative $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp ($81.b,X)		; C1 81 ; Compare accumulator ($81.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	clc		; 18 ; Clear carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	bit $3F60.w,X		; 3C 60 3F ; Test bits $3F60.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	ldx $5F1F.w,Y		; BE 1F 5F ; Load X register $5F1F.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ora $17072F.l		; 0F 2F 07 17 ; OR accumulator with memory (long) $17072F.l [Writes: Accumulator] [Flags: NZ]
	brk $8F.b		; 00 8F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C7		; 80 C7 ; Branch always to $80, $C7 [Flow: branch]
	cpx #$80.b		; E0 80 ; Compare #$80.b with X register [Reads: X Index] [Flags: NCZ]
	.db $F0, $BF		; F0 BF ; Branch if equal to $F0, $BF [Flow: branch]
	cmp $F8F7EF.l,X		; DF EF F7 F8 ; Compare accumulator (long,X) $F8F7EF.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	adc $D72F1F.l,X		; 7F 1F 2F D7 ; Add long $D72F1F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $B0, $6B		; B0 6B ; Branch if carry set to $B0, $6B [Flow: branch]
	cld		; D8 ; Clear decimal flag [Flags: D]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	sed		; F8 ; Set decimal flag [Flags: D]
	sta $8087FF.l		; 8F FF 87 80 ; Store accumulator (long) $8087FF.l [Reads: Accumulator]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $E0E7C7.l		; 8F C7 E7 E0 ; Store accumulator (long) $E0E7C7.l [Reads: Accumulator]
	sta $8C.b,S		; 83 8C ; Store accumulator (stack relative) $8C.b,S [Reads: Stack Pointer, Accumulator]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $4200.w,X		; 3C 00 42 ; Test bits $4200.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	brk $B9.b		; 00 B9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A5.b		; 00 A5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $83.b,S		; 83 83 ; Store accumulator (stack relative) $83.b,S [Reads: Stack Pointer, Accumulator]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	brk $42.b		; 00 42 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $0D09.w		; 0E 09 0D ; Arithmetic shift left $0D09.w [Flags: NCZ]
	ora ($1D.b),Y		; 11 1D ; OR accumulator with memory ($1D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($1A.b,S),Y		; 13 1A ; OR accumulator (stack relative indirect indexed) ($1A.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $3B.b,S		; 23 3B ; AND accumulator with stack relative $3B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr $2037.w		; 20 37 20 ; Jump to subroutine at $2037.w [Writes: Stack Pointer] [Flow: call]
	jsl $09143F.l		; 22 3F 14 09 ; Jump to subroutine long $09143F.l [Writes: Stack Pointer] [Flow: call]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora ($16.b,S),Y		; 13 16 ; OR accumulator (stack relative indirect indexed) ($16.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and [$2F.b]		; 27 2F ; AND accumulator with memory (long) [$2F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $FE3F.w		; 20 3F FE ; Jump to subroutine at $FE3F.w [Writes: Stack Pointer] [Flow: call]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	jsr ($FCFF.w,X)		; FC FF FC ; Jump to subroutine indirect indexed ($FCFF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	lsr $FF.b,X		; 56 FF ; Logical shift right $FF.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $FF006D.l,X		; FF 6D 00 FF ; Subtract with carry (long,X) $FF006D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $F6AB08.l,X		; FF 08 AB F6 ; Subtract with carry (long,X) $F6AB08.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $6A.b,S		; 03 6A ; OR accumulator with stack relative $6A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and #$00FF.w		; 29 FF 00 ; Logical AND #$00FF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $FF437F.l,X		; FF 7F 43 FF ; Subtract with carry (long,X) $FF437F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$FF.b]		; E7 FF ; Subtract with carry (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	rol $FF00.w,X		; 3E 00 FF ; Rotate left $FF00.w,X [Reads: X Index] [Flags: NCZ]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $007F06.l,X		; FF 06 7F 00 ; Subtract with carry (long,X) $007F06.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FF36A2.l,X		; FF A2 36 FF ; Subtract with carry (long,X) $FF36A2.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $00DE84.l,X		; FF 84 DE 00 ; Subtract with carry (long,X) $00DE84.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $9D.b		; 05 9D ; Logical OR $9D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $FF00F8.l,X		; FF F8 00 FF ; Subtract with carry (long,X) $FF00F8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FF0013.l,X		; FF 13 00 FF ; Subtract with carry (long,X) $FF0013.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	stz $FFA0.w		; 9C A0 FF ; Store zero to $FFA0.w
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $A73EDF.l,X		; 1F DF 3E A7 ; Logical OR long $A73EDF.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ror $FE65.w,X		; 7E 65 FE ; Rotate right $FE65.w,X [Reads: X Index] [Flags: NCZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	inc $00DF.w,X		; FE DF 00 ; Increment memory $00DF.w,X [Reads: X Index] [Flags: NZ]
	sbc $FF2200.l,X		; FF 00 22 FF ; Subtract with carry (long,X) $FF2200.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora #$632D.w		; 09 2D 63 ; Logical OR #$632D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp $B9.b		; C5 B9 ; Compare $B9.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp ($FF.b,S),Y		; D3 FF ; Compare accumulator (stack relative indirect indexed) ($FF.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $49E0.w		; 20 E0 49 ; Jump to subroutine at $49E0.w [Writes: Stack Pointer] [Flow: call]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cpy #$23.b		; C0 23 ; Compare #$23.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	ldy #$24.b		; A0 24 ; Load #$24.b into Y register [Writes: Y Index] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	ora ($80.b,X)		; 01 80 ; Logical OR ($80.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $80, $23		; 80 23 ; Branch always to $80, $23 [Flow: branch]
	ora ($49.b,X)		; 01 49 ; Logical OR ($49.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $09.b		; 05 09 ; Logical OR $09.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $2B0606.l		; 0F 06 06 2B ; OR accumulator with memory (long) $2B0606.l [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$3D06.w		; 09 06 3D ; Logical OR #$3D06.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $05		; 10 05 ; Branch if plus to $10, $05 [Flow: branch]
	ora ($80.b,X)		; 01 80 ; Logical OR ($80.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $80, $29		; 80 29 ; Branch always to $80, $29 [Flow: branch]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $8040.w		; 20 40 80 ; Jump to subroutine at $8040.w [Writes: Stack Pointer] [Flow: call]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora $02.b		; 05 02 ; Logical OR $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $27.b		; 00 27 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $82, $83, $02		; 82 83 02 ; Branch always long to $82, $83, $02 [Flow: branch]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $01.b,S		; 23 01 ; AND accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $82.b		; 00 82 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $27C040.l		; 4F 40 C0 27 ; Exclusive OR accumulator with memory (long) $27C040.l [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $01.b,S		; 23 01 ; AND accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $02.b,S		; 43 02 ; Exclusive OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	tsb $06.b		; 04 06 ; Test and set bits $06.b [Reads: Accumulator] [Flags: Z]
	sta $8C.b,S		; 83 8C ; Store accumulator (stack relative) $8C.b,S [Reads: Stack Pointer, Accumulator]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	cpx $2F.b		; E4 2F ; Compare $2F.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00FF.w,Y		; 19 FF 00 ; OR accumulator with memory $00FF.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $906080.l,X		; 7F 80 60 90 ; Add long $906080.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$0C.b		; E0 0C ; Compare #$0C.b with X register [Reads: X Index] [Flags: NCZ]
	.db $F0, $07		; F0 07 ; Branch if equal to $F0, $07 [Flow: branch]
	jsr ($8F00.w,X)		; FC 00 8F ; Jump to subroutine indirect indexed ($8F00.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc $787367.l		; 6F 67 73 78 ; Add with carry (long) $787367.l [Writes: Accumulator] [Flags: NCVZ]
	adc $708F0F.l,X		; 7F 0F 8F 70 ; Add long $708F0F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $FE.b,S		; 43 FE ; Exclusive OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	dec $31.b		; C6 31 ; Decrement $31.b [Reads: Direct Page] [Flags: NZ]
	cmp $08.b,S		; C3 08 ; Compare accumulator (stack relative) $08.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	cmp $44.b,S		; C3 44 ; Compare accumulator (stack relative) $44.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	tsb $C1.b		; 04 C1 ; Test and set bits $C1.b [Reads: Accumulator] [Flags: Z]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	ror $0E7E.w,X		; 7E 7E 0E ; Rotate right $0E7E.w,X [Reads: X Index] [Flags: NCZ]
	and [$22.b],Y		; 37 22 ; AND accumulator with memory (long indexed) [$22.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx #$2F.b		; E0 2F ; Compare #$2F.b with X register [Reads: X Index] [Flags: NCZ]
	eor $F89F48.l		; 4F 48 9F F8 ; Exclusive OR accumulator with memory (long) $F89F48.l [Writes: Accumulator] [Flags: NZ]
	eor $C80FB8.l,X		; 5F B8 0F C8 ; Exclusive OR accumulator with memory (long,X) $C80FB8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $0908.w		; 0C 08 09 ; Test and set bits $0908.w [Reads: Accumulator] [Flags: Z]
	ora $3E0605.l		; 0F 05 06 3E ; OR accumulator with memory (long) $3E0605.l [Writes: Accumulator] [Flags: NZ]
	and $0000B0.l,X		; 3F B0 00 00 ; AND accumulator with memory (long,X) $0000B0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $F3		; 30 F3 ; Branch if minus to $30, $F3 [Flow: branch]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	cpy #$FF.b		; C0 FF ; Compare #$FF.b with Y register [Reads: Y Index] [Flags: NCZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	cmp $8F7F67.l		; CF 67 7F 8F ; Compare accumulator (long) $8F7F67.l [Reads: Accumulator] [Flags: NCZ]
	jsr ($EBFF.w,X)		; FC FF EB ; Jump to subroutine indirect indexed ($EBFF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpx $EC88.w		; EC 88 EC ; Compare $EC88.w with X register [Reads: X Index] [Flags: NCZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $703800.l		; AF 00 38 70 ; Load long $703800.l into accumulator [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $13		; 10 13 ; Branch if plus to $10, $13 [Flow: branch]
	.db $10, $4F		; 10 4F ; Branch if plus to $10, $4F [Flow: branch]
	.db $F0, $0F		; F0 0F ; Branch if equal to $F0, $0F [Flow: branch]
	and [$70.b]		; 27 70 ; AND accumulator with memory (long) [$70.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$837C.w		; 09 7C 83 ; Logical OR #$837C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cpx #$F1.b		; E0 F1 ; Compare #$F1.b with X register [Reads: X Index] [Flags: NCZ]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($0200.w,X)		; FC 00 02 ; Jump to subroutine indirect indexed ($0200.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	eor $FC.b		; 45 FC ; Exclusive OR $FC.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $7C04.w,X		; FE 04 7C ; Increment memory $7C04.w,X [Reads: X Index] [Flags: NZ]
	asl $0307.w		; 0E 07 03 ; Arithmetic shift left $0307.w [Flags: NCZ]
	sbc $0122.w,X		; FD 22 01 ; Subtract with carry $0122.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($77.b,X)		; 01 77 ; Logical OR ($77.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc [$43.b],Y		; F7 43 ; Subtract with carry (long indexed) [$43.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$77.b],Y		; F7 77 ; Subtract with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lda [$77.b],Y		; B7 77 ; Load accumulator (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta [$37.b],Y		; 97 37 ; Store accumulator (long indexed) [$37.b],Y [Reads: Direct Page, Y Index, Accumulator]
	sta [$17.b]		; 87 17 ; Store accumulator (long) [$17.b] [Reads: Direct Page, Accumulator]
	brk $8F.b		; 00 8F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsl $C80388.l		; 22 88 03 C8 ; Jump to subroutine long $C80388.l [Writes: Stack Pointer] [Flow: call]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $70, $3F		; 70 3F ; Branch if overflow set to $70, $3F [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	sbc $800200.l,X		; FF 00 02 80 ; Subtract with carry (long,X) $800200.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FF43C0.l,X		; FF C0 43 FF ; Subtract with carry (long,X) $FF43C0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $1F3F03.l,X		; 7F 03 3F 1F ; Add long $1F3F03.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $FF4F3F.l,X		; 1F 3F 4F FF ; Logical OR long $FF4F3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: NCZ]
	jsr ($FE22.w,X)		; FC 22 FE ; Jump to subroutine indirect indexed ($FE22.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora $F20E.w		; 0D 0E F2 ; Logical OR $F20E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $07F900.l,X		; FF 00 F9 07 ; Subtract with carry (long,X) $07F900.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $42, $BE		; 42 BE ; Reserved instruction
	sed		; F8 ; Set decimal flag [Flags: D]
	cmp [$58.b]		; C7 58 ; Compare accumulator (long) [$58.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	cmp $B0833F.l,X		; DF 3F 83 B0 ; Compare accumulator (long,X) $B0833F.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $19.b		; 00 19 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $50DF00.l,X		; FF 00 DF 50 ; Subtract with carry (long,X) $50DF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $3EDB69.l		; AF 69 DB 3E ; Load long $3EDB69.l into accumulator [Writes: Accumulator] [Flags: NZ]
.INDEX 8
	sep #$1B		; E2 1B
	cmp $2F.b,X		; D5 2F ; Compare accumulator $2F.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	adc [$BE.b],Y		; 77 BE ; Add with carry (long indexed) [$BE.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $00.b,X		; 76 00 ; Rotate right $00.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	jsr $0010.w		; 20 10 00 ; Jump to subroutine at $0010.w [Writes: Stack Pointer] [Flow: call]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	adc [$45.b],Y		; 77 45 ; Add with carry (long indexed) [$45.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	ror $43.b,X		; 76 43 ; Rotate right $43.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	adc [$04.b],Y		; 77 04 ; Add with carry (long indexed) [$04.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	ror $AE.b,X		; 76 AE ; Rotate right $AE.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ror $00.b,X		; 76 00 ; Rotate right $00.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	jsl $001A01.l		; 22 01 1A 00 ; Jump to subroutine long $001A01.l [Writes: Stack Pointer] [Flow: call]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($BF.b,X)		; 01 BF ; Logical OR ($BF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpy #$DF.b		; C0 DF ; Compare #$DF.b with Y register [Reads: Y Index] [Flags: NCZ]
	cpx #$EF.b		; E0 EF ; Compare #$EF.b with X register [Reads: X Index] [Flags: NCZ]
	.db $F0, $6F		; F0 6F ; Branch if equal to $F0, $6F [Flow: branch]
	.db $F0, $60		; F0 60 ; Branch if equal to $F0, $60 [Flow: branch]
	.db $F0, $A0		; F0 A0 ; Branch if equal to $F0, $A0 [Flow: branch]
	.db $B0, $40		; B0 40 ; Branch if carry set to $B0, $40 [Flow: branch]
	adc $1FEF91.l,X		; 7F 91 EF 1F ; Add long $1FEF91.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $0F0000.l		; 0F 00 00 0F ; OR accumulator with memory (long) $0F0000.l [Writes: Accumulator] [Flags: NZ]
	eor $004780.l		; 4F 80 47 00 ; Exclusive OR accumulator with memory (long) $004780.l [Writes: Accumulator] [Flags: NZ]
	sbc $160023.l,X		; FF 23 00 16 ; Subtract with carry (long,X) $160023.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: NCZ]
	sbc $F83F20.l,X		; FF 20 3F F8 ; Subtract with carry (long,X) $F83F20.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: NCZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $C4C000.l,X		; 3F 00 C0 C4 ; AND accumulator with memory (long,X) $C4C000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $D4.b		; 45 D4 ; Exclusive OR $D4.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $D0.b,X		; 55 D0 ; Exclusive OR accumulator with memory $D0.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($D8.b),Y		; 51 D8 ; Exclusive OR accumulator with memory ($D8.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $4DCC.w,Y		; 59 CC 4D ; Exclusive OR accumulator with memory $4DCC.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $50.b		; 85 50 ; Store accumulator to $50.b [Reads: Accumulator]
	ora ($0B.b,X)		; 01 0B ; Logical OR ($0B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rol $3226.w		; 2E 26 32 ; Rotate left $3226.w [Flags: NCZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rol $00FF.w		; 2E FF 00 ; Rotate left $00FF.w [Flags: NCZ]
	inc $8B7F.w,X		; FE 7F 8B ; Increment memory $8B7F.w,X [Reads: X Index] [Flags: NZ]
	mvn $01,$01		; 54 01 01 ; Move block negative $01,$01 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $62.b		; 85 62 ; Store accumulator to $62.b [Reads: Accumulator]
	ora ($0B.b,X)		; 01 0B ; Logical OR ($0B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	adc $EDFE.w		; 6D FE ED ; Add $EDFE.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	and $D14FBD.l,X		; 3F BD 4F D1 ; AND accumulator with memory (long,X) $D14FBD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $F171EE.l		; 6F EE 71 F1 ; Add with carry (long) $F171EE.l [Writes: Accumulator] [Flags: NCVZ]
	ror $F743.w,X		; 7E 43 F7 ; Rotate right $F743.w,X [Reads: X Index] [Flags: NCZ]
	adc [$00.b],Y		; 77 00 ; Add with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc $BFDF00.l,X		; FF 00 DF BF ; Subtract with carry (long,X) $BFDF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $CF37DF.l		; EF DF 37 CF ; Subtract with carry (long) $CF37DF.l [Writes: Accumulator] [Flags: NCVZ]
	.db $D0, $E8		; D0 E8 ; Branch if not equal to $D0, $E8 [Flow: branch]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sbc [$0B.b],Y		; F7 0B ; Subtract with carry (long indexed) [$0B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$F7.b],Y		; F7 F7 ; Subtract with carry (long indexed) [$F7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx #$33.b		; E0 33 ; Compare #$33.b with X register [Reads: X Index] [Flags: NCZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $FFC17F.l,X		; 7F 7F C1 FF ; Add long $FFC17F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $E7		; 80 E7 ; Branch always to $80, $E7 [Flow: branch]
	sta $DE.b,S		; 83 DE ; Store accumulator (stack relative) $DE.b,S [Reads: Stack Pointer, Accumulator]
	sta [$FE.b]		; 87 FE ; Store accumulator (long) [$FE.b] [Reads: Direct Page, Accumulator]
	ldx $FDFD.w,Y		; BE FD FD ; Load X register $FDFD.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	cmp $FF.b,S		; C3 FF ; Compare accumulator (stack relative) $FF.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	sbc $1C0080.l,X		; FF 80 00 1C ; Subtract with carry (long,X) $1C0080.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $3C3E.w,X		; 3E 3E 3C ; Rotate left $3C3E.w,X [Reads: X Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp #$8BCE.w		; C9 CE 8B ; Compare #$8BCE.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	sty $484F.w		; 8C 4F 48 ; Store Y register to $484F.w [Reads: Y Index]
	sta $AC48E8.l		; 8F E8 48 AC ; Store accumulator (long) $AC48E8.l [Reads: Accumulator]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	cmp $8B0E09.l		; CF 09 0E 8B ; Compare accumulator (long) $8B0E09.l [Reads: Accumulator] [Flags: NCZ]
	sty $7030.w		; 8C 30 70 ; Store Y register to $7030.w [Reads: Y Index]
	.db $B0, $10		; B0 10 ; Branch if carry set to $B0, $10 [Flow: branch]
	ora ($30.b,S),Y		; 13 30 ; OR accumulator (stack relative indirect indexed) ($30.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $70		; F0 70 ; Branch if equal to $F0, $70 [Flow: branch]
	eor [$FF.b]		; 47 FF ; Exclusive OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $48.b		; 00 48 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $0023FF.l		; 22 FF 23 00 ; Jump to subroutine long $0023FF.l [Writes: Stack Pointer] [Flow: call]
	mvp $00,$FF		; 44 FF 00 ; Move block positive $00,$FF [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	mvp $00,$FF		; 44 FF 00 ; Move block positive $00,$FF [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cop $FF.b		; 02 FF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $0023FF.l		; 22 FF 23 00 ; Jump to subroutine long $0023FF.l [Writes: Stack Pointer] [Flow: call]
	eor $270EE1.l		; 4F E1 0E 27 ; Exclusive OR accumulator with memory (long) $270EE1.l [Writes: Accumulator] [Flags: NZ]
	.db $70, $48		; 70 48 ; Branch if overflow set to $70, $48 [Flow: branch]
	sbc $800200.l,X		; FF 00 02 80 ; Subtract with carry (long,X) $800200.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $0083E0.l,X		; DF E0 83 00 ; Compare accumulator (long,X) $0083E0.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $0F1F03.l,X		; 7F 03 1F 0F ; Add long $0F1F03.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $FF4F3F.l		; 0F 3F 4F FF ; OR accumulator with memory (long) $FF4F3F.l [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($FE25.w,X)		; FC 25 FE ; Jump to subroutine indirect indexed ($FE25.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$FF.b],Y		; 37 FF ; AND accumulator with memory (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $BB.b		; 45 BB ; Exclusive OR $BB.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc [$43.b],Y		; 77 43 ; Add with carry (long indexed) [$43.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	ror $01.b,X		; 76 01 ; Rotate right $01.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ldx $4376.w,Y		; BE 76 43 ; Load X register $4376.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	lda [$6F.b],Y		; B7 6F ; Load accumulator (long indexed) [$6F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $012200.l		; 22 00 22 01 ; Jump to subroutine long $012200.l [Writes: Stack Pointer] [Flow: call]
	ora [$00.b],Y		; 17 00 ; OR accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $B7.b		; 00 B7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $B96FB3.l		; 6F B3 6F B9 ; Add with carry (long) $B96FB3.l [Writes: Accumulator] [Flags: NCVZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sty $6D.b,X		; 94 6D ; Store Y register $6D.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	lda ($57.b)		; B2 57 ; Load accumulator (indirect) ($57.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
.ACCU 8
	sep #$27		; E2 27
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	adc $000EF1.l,X		; 7F F1 0E 00 ; Add long $000EF1.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	sty $EE.b		; 84 EE ; Store Y register to $EE.b [Reads: Y Index]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$68.b		; E0 68 ; Compare #$68.b with X register [Reads: X Index] [Flags: NCZ]
	adc [$08.b],Y		; 77 08 ; Add with carry (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$00.b],Y		; F7 00 ; Subtract with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FF0001.l,X		; FF 01 00 FF ; Subtract with carry (long,X) $FF0001.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $800200.l		; 22 00 02 80 ; Jump to subroutine long $800200.l [Writes: Stack Pointer] [Flow: call]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $21E000.l		; 22 00 E0 21 ; Jump to subroutine long $21E000.l [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpy #$CF.b		; C0 CF ; Compare #$CF.b with Y register [Reads: Y Index] [Flags: NCZ]
	cmp $D650D0.l		; CF D0 50 D6 ; Compare accumulator (long) $D650D0.l [Reads: Accumulator] [Flags: NCZ]
	lsr $C4.b,X		; 56 C4 ; Logical shift right $C4.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	mvp $45,$C5		; 44 C5 45 ; Move block positive $45,$C5 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	.db $D0, $51		; D0 51 ; Branch if not equal to $D0, $51 [Flow: branch]
	pei ($55.b)		; D4 55 ; Push effective indirect address ($55.b) [Reads: Direct Page] [Writes: Stack Pointer]
	and $292F30.l,X		; 3F 30 2F 29 ; AND accumulator with memory (long,X) $292F30.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	rol $D42A.w		; 2E 2A D4 ; Rotate left $D42A.w [Flags: NCZ]
	mvn $56,$D6		; 54 D6 56 ; Move block negative $56,$D6 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cpy #$40.b		; C0 40 ; Compare #$40.b with Y register [Reads: Y Index] [Flags: NCZ]
	dec $46.b		; C6 46 ; Decrement $46.b [Reads: Direct Page] [Flags: NZ]
	.db $F0, $40		; F0 40 ; Branch if equal to $F0, $40 [Flow: branch]
	mvp $7F,$FF		; 44 FF 7F ; Move block positive $7F,$FF [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	and #$3F.b		; 29 3F ; Logical AND #$3F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	and $243F.w,Y		; 39 3F 24 ; AND accumulator with memory $243F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($73.b,S),Y		; 73 73 ; Add with carry (stack relative indirect indexed) ($73.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	dec $00CE.w		; CE CE 00 ; Decrement $00CE.w [Flags: NZ]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FF0005.l,X		; FF 05 00 FF ; Subtract with carry (long,X) $FF0005.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sty $31E7.w		; 8C E7 31 ; Store Y register to $31E7.w [Reads: Y Index]
	sbc $0E0022.l,X		; FF 22 00 0E ; Subtract with carry (long,X) $0E0022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $AC21.w,X		; DE 21 AC ; Decrement memory $AC21.w,X [Reads: X Index] [Flags: NZ]
	adc ($B6.b,S),Y		; 73 B6 ; Add with carry (stack relative indirect indexed) ($B6.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	adc $7CBB.w,Y		; 79 BB 7C ; Add $7CBB.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	stz $CF7C.w		; 9C 7C CF ; Store zero to $CF7C.w
	and $FF1FE0.l,X		; 3F E0 1F FF ; AND accumulator with memory (long,X) $FF1FE0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $630100.l		; 22 00 01 63 ; Jump to subroutine long $630100.l [Writes: Stack Pointer] [Flow: call]
	sbc $43.b,S		; E3 43 ; Subtract stack-relative $43.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $AB8300.l		; 22 00 83 AB ; Jump to subroutine long $AB8300.l [Writes: Stack Pointer] [Flow: call]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $221C00.l,X		; FF 00 1C 22 ; Subtract with carry (long,X) $221C00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $140022.l,X		; FF 22 00 14 ; Subtract with carry (long,X) $140022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $32E1.w,X		; 1D E1 32 ; OR accumulator with memory $32E1.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	wai		; CB ; Wait for interrupt
	cmp [$36.b],Y		; D7 36 ; Compare accumulator (long indexed) [$36.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	eor $1BCE.w		; 4D CE 1B ; Exclusive OR $1BCE.w with accumulator [Writes: Accumulator] [Flags: NZ]
	trb $F8F7.w		; 1C F7 F8 ; Test and reset bits $F8F7.w [Reads: Accumulator] [Flags: Z]
	ora $00FFF0.l		; 0F F0 FF 00 ; OR accumulator with memory (long) $00FFF0.l [Writes: Accumulator] [Flags: NZ]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $30, $E0		; 30 E0 ; Branch if minus to $30, $E0 [Flow: branch]
	jsl $1F1000.l		; 22 00 10 1F ; Jump to subroutine long $1F1000.l [Writes: Stack Pointer] [Flow: call]
	.db $10, $EC		; 10 EC ; Branch if plus to $10, $EC [Flow: branch]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ror $FD.b,X		; 76 FD ; Rotate right $FD.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	adc $1DEA.w,X		; 7D EA 1D ; Add $1DEA.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $FF19.w		; 6E 19 FF ; Rotate right $FF19.w [Flags: NCZ]
	.db $F0, $FF		; F0 FF ; Branch if equal to $F0, $FF [Flow: branch]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx #$21.b		; E0 21 ; Compare #$21.b with X register [Reads: X Index] [Flags: NCZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $FCFF.w,X		; FE FF FC ; Increment memory $FCFF.w,X [Reads: X Index] [Flags: NZ]
	sbc $F0FFF8.l,X		; FF F8 FF F0 ; Subtract with carry (long,X) $F0FFF8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $C1FEE0.l,X		; FF E0 FE C1 ; Subtract with carry (long,X) $C1FEE0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($F883.w,X)		; FC 83 F8 ; Jump to subroutine indirect indexed ($F883.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora [$FE.b]		; 07 FE ; OR accumulator with memory (long) [$FE.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $F7FB.w,X		; FD FB F7 ; Subtract with carry $F7FB.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $7FBFDF.l		; EF DF BF 7F ; Subtract with carry (long) $7FBFDF.l [Writes: Accumulator] [Flags: NCVZ]
	adc $9E.b,S		; 63 9E ; Add with carry (stack relative) $9E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	and ($CE.b,S),Y		; 33 CE ; AND accumulator (stack relative indirect indexed) ($CE.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	inc $7B.b		; E6 7B ; Increment $7B.b [Reads: Direct Page] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	ror $0B.b,X		; 76 0B ; Rotate right $0B.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cop $1C.b		; 02 1C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $2404.w		; 0C 04 24 ; Test and set bits $2404.w [Reads: Accumulator] [Flags: Z]
	sty $0A.b		; 84 0A ; Store Y register to $0A.b [Reads: Y Index]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $7F		; 90 7F ; Branch if carry clear to $90, $7F [Flow: branch]
	.db $D0, $3F		; D0 3F ; Branch if not equal to $D0, $3F [Flow: branch]
	.db $70, $9F		; 70 9F ; Branch if overflow set to $70, $9F [Flow: branch]
	and $2300C0.l,X		; 3F C0 00 23 ; AND accumulator with memory (long,X) $2300C0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $1F0005.l,X		; FF 05 00 1F ; Subtract with carry (long,X) $1F0005.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	sta $E6.b,S		; 83 E6 ; Store accumulator (stack relative) $E6.b,S [Reads: Stack Pointer, Accumulator]
	ora ($88.b,X)		; 01 88 ; Logical OR ($88.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	adc ($03.b,X)		; 61 03 ; Add with carry ($03.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $FF.b		; 05 FF ; Logical OR $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpy #$FE.b		; C0 FE ; Compare #$FE.b with Y register [Reads: Y Index] [Flags: NCZ]
	sta ($FC.b,X)		; 81 FC ; Store accumulator ($FC.b,X) [Reads: Direct Page, Accumulator, X Index]
	ora $87.b,S		; 03 87 ; OR accumulator with stack relative $87.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $70, $03		; 70 03 ; Branch if overflow set to $70, $03 [Flow: branch]
	ora $F306F9.l		; 0F F9 06 F3 ; OR accumulator with memory (long) $F306F9.l [Writes: Accumulator] [Flags: NZ]
	ora $1BE7.w		; 0D E7 1B ; Logical OR $1BE7.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp $6F9F37.l		; CF 37 9F 6F ; Compare accumulator (long) $6F9F37.l [Reads: Accumulator] [Flags: NCZ]
	and $BF7FDF.l,X		; 3F DF 7F BF ; AND accumulator with memory (long,X) $BF7FDF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $70877F.l,X		; FF 7F 87 70 ; Subtract with carry (long,X) $70877F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $37.b,S		; 03 37 ; OR accumulator with stack relative $37.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $002FE4.l,X		; FF E4 2F 00 ; Subtract with carry (long,X) $002FE4.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($FF.b,S),Y		; 13 FF ; OR accumulator (stack relative indirect indexed) ($FF.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sbc $70FF8F.l,X		; FF 8F FF 70 ; Subtract with carry (long,X) $70FF8F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $00FF1F.l,X		; FF 1F FF 00 ; Subtract with carry (long,X) $00FF1F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $7E8140.l,X		; BF 40 81 7E ; Load long $7E8140.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $8F7800.l,X		; FF 00 78 8F ; Subtract with carry (long,X) $8F7800.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $1F		; 70 1F ; Branch if overflow set to $70, $1F [Flow: branch]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $277E81.l		; 4F 81 7E 27 ; Exclusive OR accumulator with memory (long) $277E81.l [Writes: Accumulator] [Flags: NZ]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $B9189F.l		; 2F 9F 18 B9 ; AND accumulator with memory (long) $B9189F.l [Writes: Accumulator] [Flags: NZ]
	cmp $E773DE.l		; CF DE 73 E7 ; Compare accumulator (long) $E773DE.l [Reads: Accumulator] [Flags: NCZ]
	ldy $DFB3.w,X		; BC B3 DF ; Load Y register $DFB3.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $DC6F.w,Y		; B9 6F DC ; Load $DC6F.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc [$DE.b],Y		; 77 DE ; Add with carry (long indexed) [$DE.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc [$68.b],Y		; 77 68 ; Add with carry (long indexed) [$68.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $DFBC73.l		; CF 73 BC DF ; Compare accumulator (long) $DFBC73.l [Reads: Accumulator] [Flags: NCZ]
	adc $BE7777.l		; 6F 77 77 BE ; Add with carry (long) $BE7777.l [Writes: Accumulator] [Flags: NCVZ]
	lda ($F7.b,S),Y		; B3 F7 ; Load accumulator (stack relative indirect indexed) ($F7.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $CF7B.w,X		; 3C 7B CF ; Test bits $CF7B.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	lda $DEF7.w,X		; BD F7 DE ; Load $DEF7.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $DEF7BD.l		; EF BD F7 DE ; Subtract with carry (long) $DEF7BD.l [Writes: Accumulator] [Flags: NCVZ]
	adc ($EE.b,S),Y		; 73 EE ; Add with carry (stack relative indirect indexed) ($EE.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $D0, $3C		; D0 3C ; Branch if not equal to $D0, $3C [Flow: branch]
	cmp $BD7BF7.l		; CF F7 7B BD ; Compare accumulator (long) $BD7BF7.l [Reads: Accumulator] [Flags: NCZ]
	dec $E5EE.w,X		; DE EE E5 ; Decrement memory $E5EE.w,X [Reads: X Index] [Flags: NZ]
	adc $18FF00.l,X		; 7F 00 FF 18 ; Add long $18FF00.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $02FE01.l,X		; FF 01 FE 02 ; Subtract with carry (long,X) $02FE01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	.db $F0, $08		; F0 08 ; Branch if equal to $F0, $08 [Flow: branch]
	jsr $41D0.w		; 20 D0 41 ; Jump to subroutine at $41D0.w [Writes: Stack Pointer] [Flow: call]
	ldy #$82.b		; A0 82 ; Load #$82.b into Y register [Writes: Y Index] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sbc $61.b		; E5 61 ; Subtract $61.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inc $FBFD.w,X		; FE FD FB ; Increment memory $FBFD.w,X [Reads: X Index] [Flags: NZ]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $FF1E3F.l,X		; 1F 3F 1E FF ; Logical OR long $FF1E3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rol $80.b		; 26 80 ; Rotate left $80.b [Reads: Direct Page] [Flags: NCZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $FF0380.l		; 22 80 03 FF ; Jump to subroutine long $FF0380.l [Writes: Stack Pointer] [Flow: call]
	sbc $25FF00.l,X		; FF 00 FF 25 ; Subtract with carry (long,X) $25FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $0021E0.l,X		; 7F E0 21 00 ; Add long $0021E0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $D3.b		; 00 D3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0BD5.w		; 0C D5 0B ; Test and set bits $0BD5.w [Reads: Accumulator] [Flags: Z]
	cmp $D005.w,Y		; D9 05 D0 ; Compare accumulator $D005.w,Y [Reads: Y Index] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cpy #$10.b		; C0 10 ; Compare #$10.b with Y register [Reads: Y Index] [Flags: NCZ]
	sbc ($20.b,X)		; E1 20 ; Subtract with carry ($20.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	rep #$40		; C2 40 ; Reset processor status bits #$40 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	sta $81.b		; 85 81 ; Store accumulator to $81.b [Reads: Accumulator]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: NCZ]
.ACCU 8
	sep #$E7		; E2 E7
	sbc $7EBFDF.l		; EF DF BF 7E ; Subtract with carry (long) $7EBFDF.l [Writes: Accumulator] [Flags: NCVZ]
	sbc $FF6000.l,X		; FF 00 60 FF ; Subtract with carry (long,X) $FF6000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	sbc $43FFDC.l,X		; FF DC FF 43 ; Subtract with carry (long,X) $43FFDC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $BF.b,S		; 03 BF ; OR accumulator with stack relative $BF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpy #$7F.b		; C0 7F ; Compare #$7F.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $80, $23		; 80 23 ; Branch always to $80, $23 [Flow: branch]
	brk $15.b		; 00 15 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $84.b		; 84 84 ; Store Y register to $84.b [Reads: Y Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $F80400.l,X		; FF 00 04 F8 ; Subtract with carry (long,X) $F80400.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$41.b		; C0 41 ; Compare #$41.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $80, $C2		; 80 C2 ; Branch always to $80, $C2 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	lda $61.b		; A5 61 ; Load $61.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $13.b,S		; 83 13 ; Store accumulator (stack relative) $13.b,S [Reads: Stack Pointer, Accumulator]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $2FE41E.l,X		; 3F 1E E4 2F ; AND accumulator with memory (long,X) $2FE41E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $709800.l,X		; FF 00 98 70 ; Subtract with carry (long,X) $709800.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $B0, $60		; B0 60 ; Branch if carry set to $B0, $60 [Flow: branch]
	lda ($61.b),Y		; B1 61 ; Load accumulator ($61.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor [$B2.b]		; 47 B2 ; Exclusive OR accumulator with memory (long) [$B2.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $62, $03, $00		; 62 03 00 ; Push effective relative address $62, $03, $00 [Writes: Stack Pointer]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $0D23.w		; 0E 23 0D ; Arithmetic shift left $0D23.w [Flags: NCZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora $E0.b,S		; 03 E0 ; OR accumulator with stack relative $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx #$3F.b		; E0 3F ; Compare #$3F.b with X register [Reads: X Index] [Flags: NCZ]
	and $030026.l,X		; 3F 26 00 03 ; AND accumulator with memory (long,X) $030026.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $C01FFF.l,X		; FF FF 1F C0 ; Subtract with carry (long,X) $C01FFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $B247FF.l		; 22 FF 47 B2 ; Jump to subroutine long $B247FF.l [Writes: Stack Pointer] [Flow: call]
	.db $62, $07, $B1		; 62 07 B1 ; Push effective relative address $62, $07, $B1 [Writes: Stack Pointer]
	adc ($B8.b,X)		; 61 B8 ; Add with carry ($B8.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	ldy $B76C.w,X		; BC 6C B7 ; Load Y register $B76C.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	adc $020D23.l		; 6F 23 0D 02 ; Add with carry (long) $020D23.l [Writes: Accumulator] [Flags: NCVZ]
	asl $0307.w		; 0E 07 03 ; Arithmetic shift left $0307.w [Flags: NCZ]
	jsl $400700.l		; 22 00 07 40 ; Jump to subroutine long $400700.l [Writes: Stack Pointer] [Flow: call]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $E0E01F.l,X		; 1F 1F E0 E0 ; Logical OR long $E0E01F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $BF04FF.l		; 22 FF 04 BF ; Jump to subroutine long $BF04FF.l [Writes: Stack Pointer] [Flow: call]
	sbc $FF1FE0.l,X		; FF E0 1F FF ; Subtract with carry (long,X) $FF1FE0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $51.b		; 05 51 ; Logical OR $51.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $55FF5D.l,X		; FF 5D FF 55 ; Subtract with carry (long,X) $55FF5D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $27.b		; 00 27 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FF1002.l,X		; FF 02 10 FF ; Subtract with carry (long,X) $FF1002.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $83		; F0 83 ; Branch if equal to $F0, $83 [Flow: branch]
	jsr $0301.w		; 20 01 03 ; Jump to subroutine at $0301.w [Writes: Stack Pointer] [Flow: call]
	sbc $D0FF90.l,X		; FF 90 FF D0 ; Subtract with carry (long,X) $D0FF90.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $20.b,S		; 83 20 ; Store accumulator (stack relative) $20.b,S [Reads: Stack Pointer, Accumulator]
	ora ($27.b,X)		; 01 27 ; Logical OR ($27.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $7C830B.l,X		; FF 0B 83 7C ; Subtract with carry (long,X) $7C830B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $7C8300.l,X		; FF 00 83 7C ; Subtract with carry (long,X) $7C8300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $5CA340.l,X		; BF 40 A3 5C ; Load long $5CA340.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	tsb $83.b		; 04 83 ; Test and set bits $83.b [Reads: Accumulator] [Flags: Z]
	sec		; 38 ; Set carry flag [Flags: C]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ror $7E02.w,X		; 7E 02 7E ; Rotate right $7E02.w,X [Reads: X Index] [Flags: NCZ]
	.db $42, $5E		; 42 5E ; Reserved instruction
	asl $7E.b		; 06 7E ; Arithmetic shift left $7E.b [Reads: Direct Page] [Flags: NCZ]
	brk $C5.b		; 00 C5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $54,$D5		; 44 D5 54 ; Move block positive $54,$D5 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cmp ($50.b),Y		; D1 50 ; Compare accumulator ($50.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cmp $CD58.w,Y		; D9 58 CD ; Compare accumulator $CD58.w,Y [Reads: Y Index] [Flags: NCZ]
	jmp $5085.w		; 4C 85 50 ; Jump to $5085.w [Flow: jump]
	ora ($0B.b,X)		; 01 0B ; Logical OR ($0B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rol $3226.w		; 2E 26 32 ; Rotate left $3226.w [Flags: NCZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rol $00FF.w		; 2E FF 00 ; Rotate left $00FF.w [Flags: NCZ]
	sbc $548B7E.l,X		; FF 7E 8B 54 ; Subtract with carry (long,X) $548B7E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $62.b		; 85 62 ; Store accumulator to $62.b [Reads: Accumulator]
	ora ($0B.b,X)		; 01 0B ; Logical OR ($0B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda ($73.b)		; B2 73 ; Load accumulator (indirect) ($73.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $EF7E.w,X		; DD 7E EF ; Compare accumulator $EF7E.w,X [Reads: X Index] [Flags: NCZ]
	jmp ($7CB3.w,X)		; 7C B3 7C ; Jump indirect indexed to ($7CB3.w,X) [Reads: X Index] [Flow: jump]
	lda $70937C.l,X		; BF 7C 93 70 ; Load long $70937C.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $8F.b,S		; 43 8F ; Exclusive OR accumulator with stack relative $8F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jmp ($0C00.w,X)		; 7C 00 0C ; Jump indirect indexed to ($0C00.w,X) [Reads: X Index] [Flow: jump]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($0C.b,X)		; 01 0C ; Logical OR ($0C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $4F.b		; 00 4F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $4DFF.w,X		; FE FF 4D ; Increment memory $4DFF.w,X [Reads: X Index] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $26.b		; 00 26 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($FF4E.w,X)		; FC 4E FF ; Jump to subroutine indirect indexed ($FF4E.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $802500.l,X		; FF 00 25 80 ; Subtract with carry (long,X) $802500.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $FF0080.l		; 22 80 00 FF ; Jump to subroutine long $FF0080.l [Writes: Stack Pointer] [Flow: call]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $0031E4.l,X		; 7F E4 31 00 ; Add long $0031E4.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $B2.b,S		; 43 B2 ; Exclusive OR accumulator with stack relative $B2.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $62, $47, $B1		; 62 47 B1 ; Push effective relative address $62, $47, $B1 [Writes: Stack Pointer]
	adc ($43.b,X)		; 61 43 ; Add with carry ($43.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda ($62.b)		; B2 62 ; Load accumulator (indirect) ($62.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($0D.b,X)		; 01 0D ; Logical OR ($0D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $0E23.w		; 0D 23 0E ; Logical OR $0E23.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0D.b		; 05 0D ; Logical OR $0D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $4242.w		; 0D 42 42 ; Logical OR $4242.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $18.b,S		; 23 18 ; AND accumulator with stack relative $18.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $060000.l,X		; 1F 00 00 06 ; Logical OR long $060000.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $46.b		; 06 46 ; Arithmetic shift left $46.b [Reads: Direct Page] [Flags: NCZ]
	lsr $00.b		; 46 00 ; Logical shift right $00.b [Reads: Direct Page] [Flags: NCZ]
	brk $BD.b		; 00 BD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FFE7E7.l,X		; FF E7 E7 FF ; Subtract with carry (long,X) $FFE7E7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFB9.w,Y		; F9 B9 FF ; Subtract with carry $FFB9.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	adc [$AF.b],Y		; 77 AF ; Add with carry (long indexed) [$AF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	lda [$7F.b]		; A7 7F ; Load accumulator (long) [$7F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $80, $5F		; 80 5F ; Branch always to $80, $5F [Flow: branch]
	ldy #$6F.b		; A0 6F ; Load #$6F.b into Y register [Writes: Y Index] [Flags: NZ]
	.db $90, $70		; 90 70 ; Branch if carry clear to $90, $70 [Flow: branch]
	cpy #$3F.b		; C0 3F ; Compare #$3F.b with Y register [Reads: Y Index] [Flags: NCZ]
	adc $002280.l,X		; 7F 80 22 00 ; Add long $002280.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	jsr $0F10.w		; 20 10 0F ; Jump to subroutine at $0F10.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $08F0F0.l		; EF F0 F0 08 ; Subtract with carry (long) $08F0F0.l [Writes: Accumulator] [Flags: NCVZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$DA36]		; DC 36 DA ; Jump long indirect [$DA36] [Flow: jump]
	ror $BB.b,X		; 76 BB ; Rotate right $BB.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	bit $3B.b		; 24 3B ; Test bits $3B.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cop $FD.b		; 02 FD ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $070000.l,X		; FF 00 00 07 ; Subtract with carry (long,X) $070000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $50.b		; 00 50 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $FF.b		; 26 FF ; Rotate left $FF.b [Reads: Direct Page] [Flags: NCZ]
	ora ($00.b)		; 12 00 ; OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $FC11.w,X		; FE 11 FC ; Increment memory $FC11.w,X [Reads: X Index] [Flags: NZ]
	sbc ($FF.b,S),Y		; F3 FF ; Subtract with carry (stack relative indirect indexed) ($FF.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $FFF5FF.l,X		; 1F FF F5 FF ; Logical OR long $FFF5FF.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $FF.b,X		; 95 FF ; Store accumulator to $FF.b,X [Reads: Accumulator, X Index]
	lda $21FF.w,X		; BD FF 21 ; Load $21FF.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $FBFDFF.l,X		; FF FF FD FB ; Subtract with carry (long,X) $FBFDFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $FF.b		; 25 FF ; Logical AND $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $FE05.w,X		; FE 05 FE ; Increment memory $FE05.w,X [Reads: X Index] [Flags: NZ]
	sbc $FF44FC.l,X		; FF FC 44 FF ; Subtract with carry (long,X) $FF44FC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy $BC04.w		; AC 04 BC ; Load $BC04.w into Y register [Writes: Y Index] [Flags: NZ]
	sbc $FCFF84.l,X		; FF 84 FF FC ; Subtract with carry (long,X) $FCFF84.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and [$FE.b]		; 27 FE ; AND accumulator with memory (long) [$FE.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$D4.b		; 09 D4 ; Logical OR #$D4.b with accumulator [Writes: Accumulator] [Flags: NZ]
	mvn $56,$D6		; 54 D6 56 ; Move block negative $56,$D6 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cpy #$40.b		; C0 40 ; Compare #$40.b with Y register [Reads: Y Index] [Flags: NCZ]
	dec $46.b		; C6 46 ; Decrement $46.b [Reads: Direct Page] [Flags: NZ]
	.db $F0, $40		; F0 40 ; Branch if equal to $F0, $40 [Flow: branch]
	mvp $7F,$FF		; 44 FF 7F ; Move block positive $7F,$FF [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	and #$3F.b		; 29 3F ; Logical AND #$3F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	and $243F.w,Y		; 39 3F 24 ; AND accumulator with memory $243F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($73.b,S),Y		; 73 73 ; Add with carry (stack relative indirect indexed) ($73.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	dec $00CE.w		; CE CE 00 ; Decrement $00CE.w [Flags: NZ]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FF0005.l,X		; FF 05 00 FF ; Subtract with carry (long,X) $FF0005.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sty $31E7.w		; 8C E7 31 ; Store Y register to $31E7.w [Reads: Y Index]
	sbc $0F0022.l,X		; FF 22 00 0F ; Subtract with carry (long,X) $0F0022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $1DEE3C.l		; CF 3C EE 1D ; Compare accumulator (long) $1DEE3C.l [Reads: Accumulator] [Flags: NCZ]
	inc $FF2D.w,X		; FE 2D FF ; Increment memory $FF2D.w,X [Reads: X Index] [Flags: NZ]
	and ($DF.b),Y		; 31 DF ; AND accumulator with memory ($DF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $3CCE.w,X		; 3D CE 3C ; AND accumulator with memory $3CCE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $3D.b,S		; C3 3D ; Compare accumulator (stack relative) $3D.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
.INDEX 8
	sep #$1D		; E2 1D
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $A2A2.w,X		; 5D A2 A2 ; Exclusive OR accumulator with memory $A2A2.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $4400.w,X		; 5D 00 44 ; Exclusive OR accumulator with memory $4400.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $0805F7.l,X		; FF F7 05 08 ; Subtract with carry (long,X) $0805F7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$08.b],Y		; F7 08 ; Subtract with carry (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$24.b],Y		; F7 24 ; Subtract with carry (long indexed) [$24.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$00.b],Y		; F7 00 ; Subtract with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	mvp $FF,$00		; 44 00 FF ; Move block positive $FF,$00 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $71.b,S		; 03 71 ; OR accumulator with stack relative $71.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldx $DF38.w,Y		; BE 38 DF ; Load X register $DF38.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	eor $FC.b,S		; 43 FC ; Exclusive OR accumulator with stack relative $FC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $00FF03.l		; EF 03 FF 00 ; Subtract with carry (long) $00FF03.l [Writes: Accumulator] [Flags: NCVZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $48.b,S		; 83 48 ; Store accumulator (stack relative) $48.b,S [Reads: Stack Pointer, Accumulator]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta [$78.b]		; 87 78 ; Store accumulator (long) [$78.b] [Reads: Direct Page, Accumulator]
	sta $4A.b		; 85 4A ; Store accumulator to $4A.b [Reads: Accumulator]
	ora $23.b,S		; 03 23 ; OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $37.b		; 04 37 ; Test and set bits $37.b [Reads: Accumulator] [Flags: Z]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $C8.b		; 06 C8 ; Arithmetic shift left $C8.b [Reads: Direct Page] [Flags: NCZ]
	adc $F87FCF.l,X		; 7F CF 7F F8 ; Add long $F87FCF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $7F44D7.l,X		; 7F D7 44 7F ; Add long $7F44D7.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	pei ($27.b)		; D4 27 ; Push effective indirect address ($27.b) [Reads: Direct Page] [Writes: Stack Pointer]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0401.w		; 0D 01 04 ; Logical OR $0401.w with accumulator [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	sbc $2AFFCB.l,X		; FF CB FF 2A ; Subtract with carry (long,X) $2AFFCB.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $0043FF.l		; 22 FF 43 00 ; Jump to subroutine long $0043FF.l [Writes: Stack Pointer] [Flow: call]
	sbc $0F0027.l,X		; FF 27 00 0F ; Subtract with carry (long,X) $0F0027.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	pei ($7F.b)		; D4 7F ; Push effective indirect address ($7F.b) [Reads: Direct Page] [Writes: Stack Pointer]
	jmp.w [$C47F]		; DC 7F C4 ; Jump long indirect [$C47F] [Flow: jump]
	adc $C47FFC.l,X		; 7F FC 7F C4 ; Add long $C47FFC.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $F47FCC.l,X		; 7F CC 7F F4 ; Add long $F47FCC.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $277FD4.l,X		; 7F D4 7F 27 ; Add long $277FD4.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$FF.b]		; 07 FF ; OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc $23FF11.l,X		; FF 11 FF 23 ; Subtract with carry (long,X) $23FF11.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $83FF41.l,X		; FF 41 FF 83 ; Subtract with carry (long,X) $83FF41.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $BCFF96.l,X		; FF 96 FF BC ; Subtract with carry (long,X) $BCFF96.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $001383.l,X		; FF 83 13 00 ; Subtract with carry (long,X) $001383.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $004FFF.l		; 22 FF 4F 00 ; Jump to subroutine long $004FFF.l [Writes: Stack Pointer] [Flow: call]
	sbc $090027.l,X		; FF 27 00 09 ; Subtract with carry (long,X) $090027.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $7FA000.l,X		; FF 00 A0 7F ; Subtract with carry (long,X) $7FA000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $877F8C.l,X		; 7F 8C 7F 87 ; Add long $877F8C.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $7E8344.l,X		; 7F 44 83 7E ; Add long $7E8344.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($7F.b,X)		; 01 7F ; Logical OR ($7F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $26.b		; 00 26 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $7E850B.l,X		; 7F 0B 85 7E ; Add long $7E850B.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	jmp ($7897.w,X)		; 7C 97 78 ; Jump indirect indexed to ($7897.w,X) [Reads: X Index] [Flow: jump]
	lda $609F70.l		; AF 70 9F 60 ; Load long $609F70.l into accumulator [Writes: Accumulator] [Flags: NZ]
	lda $FF4340.l,X		; BF 40 43 FF ; Load long $FF4340.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $26.b		; 00 26 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $830000.l,X		; 7F 00 00 83 ; Add long $830000.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($4603.w,X)		; FC 03 46 ; Jump to subroutine indirect indexed ($4603.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sta $7E.b,S		; 83 7E ; Store accumulator (stack relative) $7E.b,S [Reads: Stack Pointer, Accumulator]
	sta $F9.b,S		; 83 F9 ; Store accumulator (stack relative) $F9.b,S [Reads: Stack Pointer, Accumulator]
	ora $28.b,S		; 03 28 ; OR accumulator with stack relative $28.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $51FF01.l,X		; 7F 01 FF 51 ; Add long $51FF01.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $258CFF.l		; 22 FF 8C 25 ; Jump to subroutine long $258CFF.l [Writes: Stack Pointer] [Flow: call]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc [$F7.b],Y		; F7 F7 ; Subtract with carry (long indexed) [$F7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc $43FE.w,X		; FD FE 43 ; Subtract with carry $43FE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FF2300.l,X		; FF 00 23 FF ; Subtract with carry (long,X) $FF2300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $45.b		; 06 45 ; Arithmetic shift left $45.b [Reads: Direct Page] [Flags: NCZ]
	sbc $5DFF55.l,X		; FF 55 FF 5D ; Subtract with carry (long,X) $5DFF55.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FF2A51.l,X		; FF 51 2A FF ; Subtract with carry (long,X) $FF2A51.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $45.b		; 00 45 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $004AFF.l		; 22 FF 4A 00 ; Jump to subroutine long $004AFF.l [Writes: Stack Pointer] [Flow: call]
	sbc $E5FF26.l,X		; FF 26 FF E5 ; Subtract with carry (long,X) $E5FF26.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	sbc $F0FF05.l,X		; FF 05 FF F0 ; Subtract with carry (long,X) $F0FF05.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $DFEFEF.l,X		; FF EF EF DF ; Subtract with carry (long,X) $DFEFEF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $CE.b,S		; 43 CE ; Exclusive OR accumulator with stack relative $CE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldx $8E45.w,Y		; BE 45 8E ; Load X register $8E45.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ror $F004.w,X		; 7E 04 F0 ; Rotate right $F004.w,X [Reads: X Index] [Flags: NCZ]
	cpx #$C0.b		; E0 C0 ; Compare #$C0.b with X register [Reads: X Index] [Flags: NCZ]
	sta ($81.b,X)		; 81 81 ; Store accumulator ($81.b,X) [Reads: Direct Page, Accumulator, X Index]
	jsl $FF0101.l		; 22 01 01 FF ; Jump to subroutine long $FF0101.l [Writes: Stack Pointer] [Flow: call]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $43FF.w,X		; FE FF 43 ; Increment memory $43FF.w,X [Reads: X Index] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $7E.b		; 05 7E ; Logical OR $7E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $617E7F.l,X		; 7F 7F 7E 61 ; Add long $617E7F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $0022.w,X		; 7E 22 00 ; Rotate right $0022.w,X [Reads: X Index] [Flags: NCZ]
	ora ($FE.b,X)		; 01 FE ; Logical OR ($FE.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	inc $8022.w,X		; FE 22 80 ; Increment memory $8022.w,X [Reads: X Index] [Flags: NZ]
	cpx #$23.b		; E0 23 ; Compare #$23.b with X register [Reads: X Index] [Flags: NCZ]
	sbc $E3F700.l,X		; FF 00 F7 E3 ; Subtract with carry (long,X) $E3F700.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $105FCB.l		; EF CB 5F 10 ; Subtract with carry (long) $105FCB.l [Writes: Accumulator] [Flags: NCVZ]
	.db $B0, $20		; B0 20 ; Branch if carry set to $B0, $20 [Flow: branch]
	sbc $10D848.l		; EF 48 D8 10 ; Subtract with carry (long) $10D848.l [Writes: Accumulator] [Flags: NCVZ]
	ldy $27.b,X		; B4 27 ; Load Y register $27.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $A0		; 10 A0 ; Branch if plus to $10, $A0 [Flow: branch]
	eor $482710.l		; 4F 10 27 48 ; Exclusive OR accumulator with memory (long) $482710.l [Writes: Accumulator] [Flags: NZ]
	sbc $E8F800.l,X		; FF 00 F8 E8 ; Subtract with carry (long,X) $E8F800.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$C7.b		; E0 C7 ; Compare #$C7.b with X register [Reads: X Index] [Flags: NCZ]
	cmp $279890.l		; CF 90 98 27 ; Compare accumulator (long) $279890.l [Reads: Accumulator] [Flags: NCZ]
	lda ($0C.b,S),Y		; B3 0C ; Load accumulator (stack relative indirect indexed) ($0C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $A0.b,S		; 43 A0 ; Exclusive OR accumulator with stack relative $A0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $070017.l,X		; 1F 17 00 07 ; Logical OR long $070017.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsr $4F47.w		; 20 47 4F ; Jump to subroutine at $4F47.w [Writes: Stack Pointer] [Flow: call]
	eor $22EE5F.l,X		; 5F 5F EE 22 ; Exclusive OR accumulator with memory (long,X) $22EE5F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $CE68.w		; EE 68 CE ; Increment $CE68.w [Flags: NZ]
	jmp ($6C8A.w)		; 6C 8A 6C ; Jump indirect to ($6C8A.w) [Flow: jump]
	sta ($7C.b)		; 92 7C ; Store accumulator (indirect) ($7C.b) [Reads: Direct Page, Accumulator]
	stx $7A.b,Y		; 96 7A ; Store X register $7A.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	sta [$7B.b],Y		; 97 7B ; Store accumulator (long indexed) [$7B.b],Y [Reads: Direct Page, Y Index, Accumulator]
	sta ($7D.b,S),Y		; 93 7D ; Store accumulator (stack relative indirect indexed) ($7D.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	and $11.b,S		; 23 11 ; AND accumulator with stack relative $11.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora #$01.b		; 09 01 ; Logical OR #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$7F.b		; C0 7F ; Compare #$7F.b with Y register [Reads: Y Index] [Flags: NCZ]
	adc $436F70.l		; 6F 70 6F 43 ; Add with carry (long) $436F70.l [Writes: Accumulator] [Flags: NCVZ]
	and $68E030.l,X		; 3F 30 E0 68 ; AND accumulator with memory (long,X) $68E030.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $F0FF70.l,X		; 7F 70 FF F0 ; Add long $F0FF70.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $8000E0.l,X		; FF E0 00 80 ; Subtract with carry (long,X) $8000E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	cpy #$80.b		; C0 80 ; Compare #$80.b with Y register [Reads: Y Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($47.b,X)		; E1 47 ; Subtract with carry ($47.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda ($43.b,X)		; A1 43 ; Load accumulator ($43.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($11.b)		; F2 11 ; Subtract with carry (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	eor #$EE.b		; 49 EE ; Exclusive OR #$EE.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $62, $BC, $74		; 62 BC 74 ; Push effective relative address $62, $BC, $74 [Writes: Stack Pointer]
	sta $52B369.l,X		; 9F 69 B3 52 ; Store accumulator (long,X) $52B369.l,X [Reads: Accumulator, X Index]
	clc		; 18 ; Clear carry flag [Flags: C]
	trb $240C.w		; 1C 0C 24 ; Test and reset bits $240C.w [Reads: Accumulator] [Flags: Z]
	ora ($03.b),Y		; 11 03 ; OR accumulator with memory ($03.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FCFFFE.l,X		; FF FE FF FC ; Subtract with carry (long,X) $FCFFFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $EFF0F0.l,X		; FF F0 F0 EF ; Subtract with carry (long,X) $EFF0F0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$DF.b]		; E7 DF ; Subtract with carry (long) [$DF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp ($BF.b,X)		; C1 BF ; Compare accumulator ($BF.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	sta $7F.b,S		; 83 7F ; Store accumulator (stack relative) $7F.b,S [Reads: Stack Pointer, Accumulator]
	.db $82, $7E, $FE		; 82 7E FE ; Branch always long to $82, $7E, $FE [Flow: branch]
	jsr ($E8F0.w,X)		; FC F0 E8 ; Jump to subroutine indirect indexed ($E8F0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $D0, $A0		; D0 A0 ; Branch if not equal to $D0, $A0 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	eor ($FF.b,X)		; 41 FF ; Exclusive OR accumulator with memory ($FF.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr ($FF10.w,X)		; FC 10 FF ; Jump to subroutine indirect indexed ($FF10.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	bit $EF.b		; 24 EF ; Test bits $EF.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cpy $CC.b		; C4 CC ; Compare $CC.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	lda $AD.b		; A5 AD ; Load $AD.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc ($76.b)		; 72 76 ; Add with carry (indirect) ($76.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda ($F3.b),Y		; B1 F3 ; Load accumulator ($F3.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $FC.b,S		; 03 FC ; OR accumulator with stack relative $FC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $80, $10		; 80 10 ; Branch always to $80, $10 [Flow: branch]
	and ($52.b,S),Y		; 33 52 ; AND accumulator (stack relative indirect indexed) ($52.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit #$0C.b		; 89 0C ; Test bits #$0C.b with accumulator [Reads: Accumulator] [Flags: Z]
	sta $7D.b		; 85 7D ; Store accumulator to $7D.b [Reads: Accumulator]
	sty $7C.b		; 84 7C ; Store Y register to $7C.b [Reads: Y Index]
	stx $7E.b		; 86 7E ; Store X register to $7E.b [Reads: X Index]
	sta $7F887F.l		; 8F 7F 88 7F ; Store accumulator (long) $7F887F.l [Reads: Accumulator]
	.db $90, $7F		; 90 7F ; Branch if carry clear to $90, $7F [Flow: branch]
	ldy #$7F.b		; A0 7F ; Load #$7F.b into Y register [Writes: Y Index] [Flags: NZ]
	.db $80, $7F		; 80 7F ; Branch always to $80, $7F [Flow: branch]
	.db $42, $43		; 42 43 ; Reserved instruction
	eor ($23.b,X)		; 41 23 ; Exclusive OR accumulator with memory ($23.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	eor ($E8.b,X)		; 41 E8 ; Exclusive OR accumulator with memory ($E8.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cpx $DBD3.w		; EC D3 DB ; Compare $DBD3.w with X register [Reads: X Index] [Flags: NCZ]
	and [$37.b]		; 27 37 ; AND accumulator with memory (long) [$37.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $EF2DEF.l		; CF EF 2D EF ; Compare accumulator (long) $EF2DEF.l [Reads: Accumulator] [Flags: NCZ]
	and $E3.b,S		; 23 E3 ; AND accumulator with stack relative $E3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jmp ($53EC.w)		; 6C EC 53 ; Jump indirect to ($53EC.w) [Flow: jump]
	cmp $C82413.l,X		; DF 13 24 C8 ; Compare accumulator (long,X) $C82413.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	trb $A093.w		; 1C 93 A0 ; Test and reset bits $A093.w [Reads: Accumulator] [Flags: Z]
	sbc $004400.l,X		; FF 00 44 00 ; Subtract with carry (long,X) $004400.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $05FF23.l,X		; FF 23 FF 05 ; Subtract with carry (long,X) $05FF23.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($FF.b),Y		; 51 FF ; Exclusive OR accumulator with memory ($FF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $55FF.w,X		; 5D FF 55 ; Exclusive OR accumulator with memory $55FF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $27.b		; 00 27 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FF1002.l,X		; FF 02 10 FF ; Subtract with carry (long,X) $FF1002.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $83		; F0 83 ; Branch if equal to $F0, $83 [Flow: branch]
	jsr $0301.w		; 20 01 03 ; Jump to subroutine at $0301.w [Writes: Stack Pointer] [Flow: call]
	sbc $D0FF90.l,X		; FF 90 FF D0 ; Subtract with carry (long,X) $D0FF90.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $20.b,S		; 83 20 ; Store accumulator (stack relative) $20.b,S [Reads: Stack Pointer, Accumulator]
	ora ($27.b,X)		; 01 27 ; Logical OR ($27.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $7C830B.l,X		; FF 0B 83 7C ; Subtract with carry (long,X) $7C830B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $7C8300.l,X		; FF 00 83 7C ; Subtract with carry (long,X) $7C8300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $5CA340.l,X		; BF 40 A3 5C ; Load long $5CA340.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	tsb $83.b		; 04 83 ; Test and set bits $83.b [Reads: Accumulator] [Flags: Z]
	sec		; 38 ; Set carry flag [Flags: C]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ror $7E02.w,X		; 7E 02 7E ; Rotate right $7E02.w,X [Reads: X Index] [Flags: NCZ]
	.db $42, $5E		; 42 5E ; Reserved instruction
	asl $7E.b		; 06 7E ; Arithmetic shift left $7E.b [Reads: Direct Page] [Flags: NCZ]
	brk $C5.b		; 00 C5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $54,$D5		; 44 D5 54 ; Move block positive $54,$D5 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cmp ($50.b),Y		; D1 50 ; Compare accumulator ($50.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cmp $CD58.w,Y		; D9 58 CD ; Compare accumulator $CD58.w,Y [Reads: Y Index] [Flags: NCZ]
	jmp $5085.w		; 4C 85 50 ; Jump to $5085.w [Flow: jump]
	ora ($0B.b,X)		; 01 0B ; Logical OR ($0B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rol $3226.w		; 2E 26 32 ; Rotate left $3226.w [Flags: NCZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rol $00FF.w		; 2E FF 00 ; Rotate left $00FF.w [Flags: NCZ]
	sbc $548B7E.l,X		; FF 7E 8B 54 ; Subtract with carry (long,X) $548B7E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $62.b		; 85 62 ; Store accumulator to $62.b [Reads: Accumulator]
	ora ($13.b,X)		; 01 13 ; Logical OR ($13.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpy $3F.b		; C4 3F ; Compare $3F.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ror $C644.w		; 6E 44 C6 ; Rotate right $C644.w [Flags: NCZ]
	jmp ($7CEE.w)		; 6C EE 7C ; Jump indirect to ($7CEE.w) [Flow: jump]
	inc $7EBA.w,X		; FE BA 7E ; Increment memory $7EBA.w,X [Reads: X Index] [Flags: NZ]
	dec $3A.b		; C6 3A ; Decrement $3A.b [Reads: Direct Page] [Flags: NZ]
	inc $0006.w,X		; FE 06 00 ; Increment memory $0006.w,X [Reads: X Index] [Flags: NZ]
	ora ($39.b),Y		; 11 39 ; OR accumulator with memory ($39.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($23.b),Y		; 11 23 ; OR accumulator with memory ($23.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($12.b,X)		; 01 12 ; Logical OR ($12.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sty $C21F.w		; 8C 1F C2 ; Store Y register to $C21F.w [Reads: Y Index]
	lsr $6EEA.w		; 4E EA 6E ; Logical shift right $6EEA.w [Flags: NCZ]
	ldy $7C.b,X		; B4 7C ; Load Y register $7C.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	cpy $BC3C.w		; CC 3C BC ; Compare $BC3C.w with Y register [Reads: Y Index] [Flags: NCZ]
	jmp ($7ECE.w,X)		; 7C CE 7E ; Jump indirect indexed to ($7ECE.w,X) [Reads: X Index] [Flow: jump]
	sbc $5F.b,S		; E3 5F ; Subtract stack-relative $5F.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	and ($11.b),Y		; 31 11 ; AND accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $47E003.l		; 22 03 E0 47 ; Jump to subroutine long $47E003.l [Writes: Stack Pointer] [Flow: call]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda $50D808.l		; AF 08 D8 50 ; Load long $50D808.l into accumulator [Writes: Accumulator] [Flags: NZ]
	pei ($07.b)		; D4 07 ; Push effective indirect address ($07.b) [Reads: Direct Page] [Writes: Stack Pointer]
	sbc $0CEF28.l		; EF 28 EF 0C ; Subtract with carry (long) $0CEF28.l [Writes: Accumulator] [Flags: NCVZ]
	inc $17.b,X		; F6 17 ; Increment memory $17.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sbc $5005.w,X		; FD 05 50 ; Subtract with carry $5005.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and [$28.b]		; 27 28 ; AND accumulator with memory (long) [$28.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	.db $B0, $2F		; B0 2F ; Branch if carry set to $B0, $2F [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor [$07.b],Y		; 57 07 ; Exclusive OR accumulator with memory (long indexed) [$07.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $90, $7F		; 90 7F ; Branch if carry clear to $90, $7F [Flow: branch]
	dec $673E.w		; CE 3E 67 ; Decrement $673E.w [Flags: NZ]
	sta $4FC7B8.l,X		; 9F B8 C7 4F ; Store accumulator (long,X) $4FC7B8.l,X [Reads: Accumulator, X Index]
	and [$98.b]		; 27 98 ; AND accumulator with memory (long) [$98.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $99.b		; 00 99 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $6F8C.w,X		; 7E 8C 6F ; Rotate right $6F8C.w,X [Reads: X Index] [Flags: NCZ]
	sta $60806F.l		; 8F 6F 80 60 ; Store accumulator (long) $60806F.l [Reads: Accumulator]
	.db $90, $5F		; 90 5F ; Branch if carry clear to $90, $5F [Flow: branch]
	ldy #$3F.b		; A0 3F ; Load #$3F.b into Y register [Writes: Y Index] [Flags: NZ]
	cpy #$7F.b		; C0 7F ; Compare #$7F.b with Y register [Reads: Y Index] [Flags: NCZ]
	sbc $100000.l,X		; FF 00 00 10 ; Subtract with carry (long,X) $100000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $1F		; 10 1F ; Branch if plus to $10, $1F [Flow: branch]
	jsr $8340.w		; 20 40 83 ; Jump to subroutine at $8340.w [Writes: Stack Pointer] [Flow: call]
	ora #$01.b		; 09 01 ; Logical OR #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $0022FF.l		; 22 FF 22 00 ; Jump to subroutine long $0022FF.l [Writes: Stack Pointer] [Flow: call]
	mvp $00,$FF		; 44 FF 00 ; Move block positive $00,$FF [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx #$47.b		; E0 47 ; Compare #$47.b with X register [Reads: X Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $50, $FF		; 50 FF ; Branch if overflow clear to $50, $FF [Flow: branch]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	lda [$63.b],Y		; B7 63 ; Load accumulator (long indexed) [$63.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	pei ($23.b)		; D4 23 ; Push effective indirect address ($23.b) [Reads: Direct Page] [Writes: Stack Pointer]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	eor $9F60DF.l		; 4F DF 60 9F ; Exclusive OR accumulator with memory (long) $9F60DF.l [Writes: Accumulator] [Flags: NZ]
	ora $0700FF.l,X		; 1F FF 00 07 ; Logical OR long $0700FF.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $86.b		; 00 86 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $7F8B.w,X		; 7E 8B 7F ; Rotate right $7F8B.w,X [Reads: X Index] [Flags: NCZ]
	sta ($7F.b)		; 92 7F ; Store accumulator (indirect) ($7F.b) [Reads: Direct Page, Accumulator]
	sta ($7F.b,X)		; 81 7F ; Store accumulator ($7F.b,X) [Reads: Direct Page, Accumulator, X Index]
	.db $82, $7E, $C5		; 82 7E C5 ; Branch always long to $82, $7E, $C5 [Flow: branch]
	lda $9DED.w,X		; BD ED 9D ; Load $9DED.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $41BD.w,X		; FD BD 41 ; Subtract with carry $41BD.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $42, $4C		; 42 4C ; Reserved instruction
	adc $92BA.w,Y		; 79 BA 92 ; Add $92BA.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx #$E8.b		; A2 E8 ; Load #$E8.b into X register [Writes: X Index] [Flags: NZ]
	sbc $031C10.l		; EF 10 1C 03 ; Subtract with carry (long) $031C10.l [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ora $1B.b,S		; 03 1B ; OR accumulator with stack relative $1B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $EB.b,S		; E3 EB ; Subtract stack-relative $EB.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	sbc $ED.b		; E5 ED ; Subtract $ED.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($F6.b)		; F2 F6 ; Subtract with carry (indirect) ($F6.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $B0, $F7		; B0 F7 ; Branch if carry set to $B0, $F7 [Flow: branch]
	.db $10, $E3		; 10 E3 ; Branch if plus to $10, $E3 [Flow: branch]
	tsb $E4.b		; 04 E4 ; Test and set bits $E4.b [Reads: Accumulator] [Flags: Z]
	trb $12.b		; 14 12 ; Test and reset bits $12.b [Reads: Accumulator] [Flags: Z]
	ora #$08.b		; 09 08 ; Logical OR #$08.b with accumulator [Writes: Accumulator] [Flags: NZ]
	eor $80.b,S		; 43 80 ; Exclusive OR accumulator with stack relative $80.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $3EC107.l,X		; 7F 07 C1 3E ; Add long $3EC107.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($9E.b,X)		; E1 9E ; Subtract with carry ($9E.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F8FFC0.l,X		; FF C0 FF F8 ; Subtract with carry (long,X) $F8FFC0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$63.b]		; 07 63 ; OR accumulator with memory (long) [$63.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc [$3E.b],Y		; 77 3E ; Add with carry (long indexed) [$3E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	stz $F8C0.w,X		; 9E C0 F8 ; Store zero to $F8C0.w,X [Reads: X Index]
	sbc $2043FF.l,X		; FF FF 43 20 ; Subtract with carry (long,X) $2043FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $FF4113.l,X		; BF 13 41 FF ; Load long $FF4113.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $7F		; 80 7F ; Branch always to $80, $7F [Flow: branch]
	cpy #$3F.b		; C0 3F ; Compare #$3F.b with Y register [Reads: Y Index] [Flags: NCZ]
	sbc $C0C080.l,X		; FF 80 C0 C0 ; Subtract with carry (long,X) $C0C080.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($B1.b),Y		; 91 B1 ; Store accumulator ($B1.b),Y [Reads: Direct Page, Y Index, Accumulator]
	clv		; B8 ; Clear overflow flag [Flags: V]
	adc $4F803F.l,X		; 7F 3F 80 4F ; Add long $4F803F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FF2600.l,X		; FF 00 26 FF ; Subtract with carry (long,X) $FF2600.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($00.b)		; 12 00 ; OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $FC11.w,X		; FE 11 FC ; Increment memory $FC11.w,X [Reads: X Index] [Flags: NZ]
	sbc ($FF.b,S),Y		; F3 FF ; Subtract with carry (stack relative indirect indexed) ($FF.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $FFF5FF.l,X		; 1F FF F5 FF ; Logical OR long $FFF5FF.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $FF.b,X		; 95 FF ; Store accumulator to $FF.b,X [Reads: Accumulator, X Index]
	lda $21FF.w,X		; BD FF 21 ; Load $21FF.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $FBFDFF.l,X		; FF FF FD FB ; Subtract with carry (long,X) $FBFDFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $FF.b		; 25 FF ; Logical AND $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $FE05.w,X		; FE 05 FE ; Increment memory $FE05.w,X [Reads: X Index] [Flags: NZ]
	sbc $FF44FC.l,X		; FF FC 44 FF ; Subtract with carry (long,X) $FF44FC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy $BC04.w		; AC 04 BC ; Load $BC04.w into Y register [Writes: Y Index] [Flags: NZ]
	sbc $FCFF84.l,X		; FF 84 FF FC ; Subtract with carry (long,X) $FCFF84.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and [$FE.b]		; 27 FE ; AND accumulator with memory (long) [$FE.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$D4.b		; 09 D4 ; Logical OR #$D4.b with accumulator [Writes: Accumulator] [Flags: NZ]
	mvn $56,$D6		; 54 D6 56 ; Move block negative $56,$D6 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cpy #$40.b		; C0 40 ; Compare #$40.b with Y register [Reads: Y Index] [Flags: NCZ]
	dec $46.b		; C6 46 ; Decrement $46.b [Reads: Direct Page] [Flags: NZ]
	.db $F0, $40		; F0 40 ; Branch if equal to $F0, $40 [Flow: branch]
	mvp $7F,$FF		; 44 FF 7F ; Move block positive $7F,$FF [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	and #$3F.b		; 29 3F ; Logical AND #$3F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	and $243F.w,Y		; 39 3F 24 ; AND accumulator with memory $243F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($73.b,S),Y		; 73 73 ; Add with carry (stack relative indirect indexed) ($73.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	dec $00CE.w		; CE CE 00 ; Decrement $00CE.w [Flags: NZ]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FF0005.l,X		; FF 05 00 FF ; Subtract with carry (long,X) $FF0005.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sty $31E7.w		; 8C E7 31 ; Store Y register to $31E7.w [Reads: Y Index]
	sbc $1D0022.l,X		; FF 22 00 1D ; Subtract with carry (long,X) $1D0022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy $7CFD.w,X		; BC FD 7C ; Load Y register $7CFD.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	adc $7978.w,X		; 7D 78 79 ; Add $7978.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	adc $6160.w,Y		; 79 60 61 ; Add $6160.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($BF.b,X)		; 01 BF ; Logical OR ($BF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc ($8E.b,X)		; E1 8E ; Subtract with carry ($8E.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sep #$02		; E2 02 ; Set processor status bits #$02 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	.db $82, $86, $86		; 82 86 86 ; Branch always long to $82, $86, $86 [Flow: branch]
	stz $1EFE.w,X		; 9E FE 1E ; Store zero to $1EFE.w,X [Reads: X Index]
	ora $FA6E.w,X		; 1D 6E FA ; OR accumulator with memory $FA6E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc [$6A.b]		; 67 6A ; Add with carry (long) [$6A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc [$76.b],Y		; 77 76 ; Add with carry (long indexed) [$76.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $77.b,S		; 43 77 ; Exclusive OR accumulator with stack relative $77.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc ($E0.b)		; 72 E0 ; Add with carry (indirect) ($E0.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jsr $393B.w		; 20 3B 39 ; Jump to subroutine at $393B.w [Writes: Stack Pointer] [Flow: call]
	ora $0E1C.w,X		; 1D 1C 0E ; OR accumulator with memory $0E1C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $9505.w		; 0E 05 95 ; Arithmetic shift left $9505.w [Flags: NCZ]
	bit #$8D.b		; 89 8D ; Test bits #$8D.b with accumulator [Reads: Accumulator] [Flags: Z]
	sta $E3C6.w		; 8D C6 E3 ; Store accumulator to $E3C6.w [Reads: Accumulator]
	sbc ($D3.b),Y		; F1 D3 ; Subtract with carry ($D3.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $D9.b,S		; C3 D9 ; Compare accumulator (stack relative) $D9.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	cmp ($B5.b,X)		; C1 B5 ; Compare accumulator ($B5.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	sta ($63.b,X)		; 81 63 ; Store accumulator ($63.b,X) [Reads: Direct Page, Accumulator, X Index]
	brk $C3.b		; 00 C3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($87.b,X)		; 01 87 ; Logical OR ($87.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $FF.b,S		; 03 FF ; OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $3C.b		; 04 3C ; Test and set bits $3C.b [Reads: Accumulator] [Flags: Z]
	rol $227E.w,X		; 3E 7E 22 ; Rotate left $227E.w,X [Reads: X Index] [Flags: NCZ]
	inc $21E0.w,X		; FE E0 21 ; Increment memory $21E0.w,X [Reads: X Index] [Flags: NZ]
	jsr ($C3F8.w,X)		; FC F8 C3 ; Jump to subroutine indirect indexed ($C3F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sed		; F8 ; Set decimal flag [Flags: D]
	ror $8785.w,X		; 7E 85 87 ; Rotate right $8785.w,X [Reads: X Index] [Flags: NCZ]
	.db $62, $03, $F8		; 62 03 F8 ; Push effective relative address $62, $03, $F8 [Writes: Stack Pointer]
	ora ($8D.b,X)		; 01 8D ; Logical OR ($8D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($87.b,X)		; 01 87 ; Logical OR ($87.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jsr ($FEFE.w,X)		; FC FE FE ; Jump to subroutine indirect indexed ($FEFE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $FF7EFF.l,X		; FF FF 7E FF ; Subtract with carry (long,X) $FF7EFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $FF.b,X		; F6 FF ; Increment memory $FF.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	jsr ($BCFF.w,X)		; FC FF BC ; Jump to subroutine indirect indexed ($BCFF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	mvp $FE,$FF		; 44 FF FE ; Move block positive $FE,$FF [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora #$76.b		; 09 76 ; Logical OR #$76.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $F67E00.l,X		; FF 00 7E F6 ; Subtract with carry (long,X) $F67E00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($FEBC.w,X)		; FC BC FE ; Jump to subroutine indirect indexed ($FEBC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $4376.w,X		; FE 76 43 ; Increment memory $4376.w,X [Reads: X Index] [Flags: NZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$7F.b]		; 07 7F ; OR accumulator with memory (long) [$7F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	adc $F87FCF.l,X		; 7F CF 7F F8 ; Add long $F87FCF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $7F44D7.l,X		; 7F D7 44 7F ; Add long $7F44D7.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	pei ($27.b)		; D4 27 ; Push effective indirect address ($27.b) [Reads: Direct Page] [Writes: Stack Pointer]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0401.w		; 0D 01 04 ; Logical OR $0401.w with accumulator [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	sbc $2AFFCB.l,X		; FF CB FF 2A ; Subtract with carry (long,X) $2AFFCB.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $0043FF.l		; 22 FF 43 00 ; Jump to subroutine long $0043FF.l [Writes: Stack Pointer] [Flow: call]
	sbc $0F0027.l,X		; FF 27 00 0F ; Subtract with carry (long,X) $0F0027.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	pei ($7F.b)		; D4 7F ; Push effective indirect address ($7F.b) [Reads: Direct Page] [Writes: Stack Pointer]
	jmp.w [$C47F]		; DC 7F C4 ; Jump long indirect [$C47F] [Flow: jump]
	adc $C47FFC.l,X		; 7F FC 7F C4 ; Add long $C47FFC.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $F47FCC.l,X		; 7F CC 7F F4 ; Add long $F47FCC.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $277FD4.l,X		; 7F D4 7F 27 ; Add long $277FD4.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$FF.b]		; 07 FF ; OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc $23FF11.l,X		; FF 11 FF 23 ; Subtract with carry (long,X) $23FF11.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $83FF41.l,X		; FF 41 FF 83 ; Subtract with carry (long,X) $83FF41.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $BCFF96.l,X		; FF 96 FF BC ; Subtract with carry (long,X) $BCFF96.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $1F0F07.l,X		; FF 07 0F 1F ; Subtract with carry (long,X) $1F0F07.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $FF227F.l,X		; 3F 7F 22 FF ; AND accumulator with memory (long,X) $FF227F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $27FF00.l		; 4F 00 FF 27 ; Exclusive OR accumulator with memory (long) $27FF00.l [Writes: Accumulator] [Flags: NZ]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $7FA000.l,X		; FF 00 A0 7F ; Subtract with carry (long,X) $7FA000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $877F8C.l,X		; 7F 8C 7F 87 ; Add long $877F8C.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $7E8344.l,X		; 7F 44 83 7E ; Add long $7E8344.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($7F.b,X)		; 01 7F ; Logical OR ($7F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $26.b		; 00 26 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $7E850B.l,X		; 7F 0B 85 7E ; Add long $7E850B.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	jmp ($7897.w,X)		; 7C 97 78 ; Jump indirect indexed to ($7897.w,X) [Reads: X Index] [Flow: jump]
	lda $609F70.l		; AF 70 9F 60 ; Load long $609F70.l into accumulator [Writes: Accumulator] [Flags: NZ]
	lda $FF4340.l,X		; BF 40 43 FF ; Load long $FF4340.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $26.b		; 00 26 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $830000.l,X		; 7F 00 00 83 ; Add long $830000.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($4603.w,X)		; FC 03 46 ; Jump to subroutine indirect indexed ($4603.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sta $7E.b,S		; 83 7E ; Store accumulator (stack relative) $7E.b,S [Reads: Stack Pointer, Accumulator]
	sta $F9.b,S		; 83 F9 ; Store accumulator (stack relative) $F9.b,S [Reads: Stack Pointer, Accumulator]
	ora $28.b,S		; 03 28 ; OR accumulator with stack relative $28.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $51FF01.l,X		; 7F 01 FF 51 ; Add long $51FF01.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $258CFF.l		; 22 FF 8C 25 ; Jump to subroutine long $258CFF.l [Writes: Stack Pointer] [Flow: call]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc [$F7.b],Y		; F7 F7 ; Subtract with carry (long indexed) [$F7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc $43FE.w,X		; FD FE 43 ; Subtract with carry $43FE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FF2300.l,X		; FF 00 23 FF ; Subtract with carry (long,X) $FF2300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $45.b		; 06 45 ; Arithmetic shift left $45.b [Reads: Direct Page] [Flags: NCZ]
	sbc $5DFF55.l,X		; FF 55 FF 5D ; Subtract with carry (long,X) $5DFF55.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FF2A51.l,X		; FF 51 2A FF ; Subtract with carry (long,X) $FF2A51.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $45.b		; 00 45 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $004AFF.l		; 22 FF 4A 00 ; Jump to subroutine long $004AFF.l [Writes: Stack Pointer] [Flow: call]
	sbc $E5FF26.l,X		; FF 26 FF E5 ; Subtract with carry (long,X) $E5FF26.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	sbc $04FF02.l,X		; FF 02 FF 04 ; Subtract with carry (long,X) $04FF02.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsl $2BE008.l		; 22 08 E0 2B ; Jump to subroutine long $2BE008.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	asl $77.b		; 06 77 ; Arithmetic shift left $77.b [Reads: Direct Page] [Flags: NCZ]
	sta $A669.w,Y		; 99 69 A6 ; Store accumulator to $A669.w,Y [Reads: Y Index, Accumulator]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	eor $4B.b		; 45 4B ; Exclusive OR $4B.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpy $FB.b		; C4 FB ; Compare $FB.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	sbc [$F7.b],Y		; F7 F7 ; Subtract with carry (long indexed) [$F7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $37.b,X		; 16 37 ; Arithmetic shift left $37.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	and $DB.b,X		; 35 DB ; Logical AND $DB.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc $750C.w		; ED 0C 75 ; Subtract $750C.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	tsb $31.b		; 04 31 ; Test and set bits $31.b [Reads: Accumulator] [Flags: Z]
	brk $19.b		; 00 19 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $99.b		; 00 99 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C9		; 80 C9 ; Branch always to $80, $C9 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	eor #$80.b		; 49 80 ; Exclusive OR #$80.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc [$F3.b]		; E7 F3 ; Subtract with carry (long) [$F3.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc $3F7FFF.l,X		; FF FF 7F 3F ; Subtract with carry (long,X) $3F7FFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $4300FB.l,X		; BF FB 00 43 ; Load long $4300FB.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpy #$09.b		; C0 09 ; Compare #$09.b with Y register [Reads: Y Index] [Flags: NCZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	brk $2B.b		; 00 2B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$23.b		; C0 23 ; Compare #$23.b with Y register [Reads: Y Index] [Flags: NCZ]
	cmp ($F3.b,X)		; C1 F3 ; Compare accumulator ($F3.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	.db $10, $33		; 10 33 ; Branch if plus to $10, $33 [Flow: branch]
	.db $D0, $23		; D0 23 ; Branch if not equal to $D0, $23 [Flow: branch]
	trb $1D07.w		; 1C 07 1D ; Test and reset bits $1D07.w [Reads: Accumulator] [Flags: Z]
	trb $0C0C.w		; 1C 0C 0C ; Test and reset bits $0C0C.w [Reads: Accumulator] [Flags: Z]
	sbc $FF0000.l,X		; FF 00 00 FF ; Subtract with carry (long,X) $FF0000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $FF.b		; 45 FF ; Exclusive OR $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FF0001.l,X		; FF 01 00 FF ; Subtract with carry (long,X) $FF0001.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $4B.b,S		; 83 4B ; Store accumulator (stack relative) $4B.b,S [Reads: Stack Pointer, Accumulator]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $228025.l,X		; FF 25 80 22 ; Subtract with carry (long,X) $228025.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $005A83.l,X		; FF 83 5A 00 ; Subtract with carry (long,X) $005A83.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $00437F.l		; 22 7F 43 00 ; Jump to subroutine long $00437F.l [Writes: Stack Pointer] [Flow: call]
	sbc $00FF15.l,X		; FF 15 FF 00 ; Subtract with carry (long,X) $00FF15.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $090DF9.l,X		; FF F9 0D 09 ; Subtract with carry (long,X) $090DF9.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $11.b,X		; 15 11 ; OR accumulator with memory $11.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $21.b		; 25 21 ; Logical AND $21.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $E1.b		; E5 E1 ; Subtract $E1.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $21.b		; E5 21 ; Subtract $21.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $F6.b		; 06 F6 ; Arithmetic shift left $F6.b [Reads: Direct Page] [Flags: NCZ]
	inc $1EDE.w		; EE DE 1E ; Increment $1EDE.w [Flags: NZ]
	dec $4A84.w,X		; DE 84 4A ; Decrement memory $4A84.w,X [Reads: X Index] [Flags: NZ]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $8203FE.l		; 22 FE 03 82 ; Jump to subroutine long $8203FE.l [Writes: Stack Pointer] [Flow: call]
	sta $C2.b,S		; 83 C2 ; Store accumulator (stack relative) $C2.b,S [Reads: Stack Pointer, Accumulator]
	cmp $E2.b,S		; C3 E2 ; Compare accumulator (stack relative) $E2.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	sbc $F0EFFE.l		; EF FE EF F0 ; Subtract with carry (long) $F0EFFE.l [Writes: Accumulator] [Flags: NCVZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($7D.b,X)		; 01 7D ; Logical OR ($7D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $011D.w,X		; 3D 1D 01 ; AND accumulator with memory $011D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $B9BF40.l		; 0F 40 BF B9 ; OR accumulator with memory (long) $B9BF40.l [Writes: Accumulator] [Flags: NZ]
	adc $EF7FF7.l,X		; 7F F7 7F EF ; Add long $EF7FF7.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $857FDE.l,X		; 7F DE 7F 85 ; Add long $857FDE.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and [$80.b]		; 27 80 ; AND accumulator with memory (long) [$80.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $247F9B.l,X		; 7F 9B 7F 24 ; Add long $247F9B.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	jsl $FF0E00.l		; 22 00 0E FF ; Jump to subroutine long $FF0E00.l [Writes: Stack Pointer] [Flow: call]
	sbc [$FF.b]		; E7 FF ; Subtract with carry (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $FF7EFF.l,X		; 9F FF 7E FF ; Store accumulator (long,X) $FF7EFF.l,X [Reads: Accumulator, X Index]
	jsr ($08FF.w,X)		; FC FF 08 ; Jump to subroutine indirect indexed ($08FF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	tsb $FF00.w		; 0C 00 FF ; Test and set bits $FF00.w [Reads: Accumulator] [Flags: Z]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $020024.l,X		; FF 24 00 02 ; Subtract with carry (long,X) $020024.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($00.b,S),Y		; F3 00 ; Subtract with carry (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $0B3F.w		; AD 3F 0B ; Load $0B3F.w into accumulator [Writes: Accumulator] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	and $8068A0.l,X		; 3F A0 68 80 ; AND accumulator with memory (long,X) $8068A0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $F67FB6.l,X		; 7F B6 7F F6 ; Add long $F67FB6.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $223FB7.l,X		; 7F B7 3F 22 ; Add long $223FB7.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $401000.l		; 22 00 10 40 ; Jump to subroutine long $401000.l [Writes: Stack Pointer] [Flow: call]
	cmp $EEFF.w,X		; DD FF EE ; Compare accumulator $EEFF.w,X [Reads: X Index] [Flags: NCZ]
	sbc $1AFFED.l,X		; FF ED FF 1A ; Subtract with carry (long,X) $1AFFED.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $FF00.w,X		; 7E 00 FF ; Rotate right $FF00.w,X [Reads: X Index] [Flags: NCZ]
	sbc [$FF.b],Y		; F7 FF ; Subtract with carry (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FF1EFF.l		; EF FF 1E FF ; Subtract with carry (long) $FF1EFF.l [Writes: Accumulator] [Flags: NCVZ]
	jsl $810000.l		; 22 00 00 81 ; Jump to subroutine long $810000.l [Writes: Stack Pointer] [Flow: call]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$75.b],Y		; 17 75 ; OR accumulator with memory (long indexed) [$75.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lda $8A.b,X		; B5 8A ; Load $8A.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor $ADC2.w,X		; 5D C2 AD ; Exclusive OR accumulator with memory $ADC2.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $D7, $30		; 62 D7 30 ; Push effective relative address $62, $D7, $30 [Writes: Stack Pointer]
	lda $60.b,S		; A3 60 ; Load accumulator (stack relative) $60.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $0C.b,X		; F5 0C ; Subtract $0C.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	asl $80.b		; 06 80 ; Arithmetic shift left $80.b [Reads: Direct Page] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	jsr $0810.w		; 20 10 08 ; Jump to subroutine at $0810.w [Writes: Stack Pointer] [Flow: call]
	trb $0102.w		; 1C 02 01 ; Test and reset bits $0102.w [Reads: Accumulator] [Flags: Z]
	and [$00.b],Y		; 37 00 ; AND accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $DF.b		; 00 DF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $DF.b		; 05 DF ; Logical OR $DF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $E000DF.l,X		; 1F DF 00 E0 ; Logical OR long $E000DF.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $020022.l,X		; FF 22 00 02 ; Subtract with carry (long,X) $020022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $4BE0E0.l,X		; FF E0 E0 4B ; Subtract with carry (long,X) $4BE0E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FF2200.l,X		; FF 00 22 FF ; Subtract with carry (long,X) $FF2200.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $6E8400.l		; 22 00 84 6E ; Jump to subroutine long $6E8400.l [Writes: Stack Pointer] [Flow: call]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0F0F1F.l,X		; 1F 1F 0F 0F ; Logical OR long $0F0F1F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	ora ($7F.b,X)		; 01 7F ; Logical OR ($7F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $E00025.l,X		; 3F 25 00 E0 ; AND accumulator with memory (long,X) $E00025.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $C649.w,Y		; 39 49 C6 ; AND accumulator with memory $C649.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	mvp $23,$C3		; 44 C3 23 ; Move block positive $23,$C3 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cpx #$B8.b		; E0 B8 ; Compare #$B8.b with X register [Reads: X Index] [Flags: NCZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jsr ($F71C.w,X)		; FC 1C F7 ; Jump to subroutine indirect indexed ($F71C.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	adc $9F0799.l		; 6F 99 07 9F ; Add with carry (long) $9F0799.l [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $36		; 10 36 ; Branch if plus to $10, $36 [Flow: branch]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	trb $0307.w		; 1C 07 03 ; Test and reset bits $0307.w [Reads: Accumulator] [Flags: Z]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc $A0.b,S		; 63 A0 ; Add with carry (stack relative) $A0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	adc [$A0.b]		; 67 A0 ; Add with carry (long) [$A0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	jsr $A0E1.w		; 20 E1 A0 ; Jump to subroutine at $A0E1.w [Writes: Stack Pointer] [Flow: call]
	adc $6C.b		; 65 6C ; Add $6C.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora #$0C.b		; 09 0C ; Logical OR #$0C.b with accumulator [Writes: Accumulator] [Flags: NZ]
	cpy $C4.b		; C4 C4 ; Compare $C4.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	asl $9FFE.w		; 0E FE 9F ; Arithmetic shift left $9FFE.w [Flags: NCZ]
	sta $931F1F.l,X		; 9F 1F 1F 93 ; Store accumulator (long,X) $931F1F.l,X [Reads: Accumulator, X Index]
	sbc ($3B.b,S),Y		; F3 3B ; Subtract with carry (stack relative indirect indexed) ($3B.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora ($3B.b,X)		; 01 3B ; Logical OR ($3B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cld		; D8 ; Clear decimal flag [Flags: D]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora $D82B.w,Y		; 19 2B D8 ; OR accumulator with memory $D82B.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta $48.b		; 85 48 ; Store accumulator to $48.b [Reads: Accumulator]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $430022.l,X		; FF 22 00 43 ; Subtract with carry (long,X) $430022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $040500.l,X		; FF 00 05 04 ; Subtract with carry (long,X) $040500.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc $DF2000.l,X		; FF 00 20 DF ; Subtract with carry (long,X) $DF2000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $48.b,S		; 83 48 ; Store accumulator (stack relative) $48.b,S [Reads: Stack Pointer, Accumulator]
	brk $25.b		; 00 25 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor [$7F.b]		; 47 7F ; Exclusive OR accumulator with memory (long) [$7F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $80, $E0		; 80 E0 ; Branch always to $80, $E0 [Flow: branch]
	sbc $387F71.l,X		; FF 71 7F 38 ; Subtract with carry (long,X) $387F71.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $9E9C.w,X		; 3E 9C 9E ; Rotate left $9E9C.w,X [Reads: X Index] [Flags: NCZ]
	eor $65CE.w		; 4D CE 65 ; Exclusive OR $65CE.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lda [$32.b]		; A7 32 ; Load accumulator (long) [$32.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp ($00.b,S),Y		; D3 00 ; Compare accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($61.b,X)		; C1 61 ; Compare accumulator ($61.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	and ($18.b),Y		; 31 18 ; AND accumulator with memory ($18.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tsb $40CE.w		; 0C CE 40 ; Test and set bits $40CE.w [Reads: Accumulator] [Flags: Z]
	sta $113F8E.l,X		; 9F 8E 3F 11 ; Store accumulator (long,X) $113F8E.l,X [Reads: Accumulator, X Index]
	adc $59F92E.l,X		; 7F 2E F9 59 ; Add long $59F92E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $B0.b,X		; F6 B0 ; Increment memory $B0.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	jsr ($FE70.w,X)		; FC 70 FE ; Jump to subroutine indirect indexed ($FE70.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $70, $3F		; 70 3F ; Branch if overflow set to $70, $3F [Flow: branch]
	adc ($E0.b),Y		; 71 E0 ; Add with carry ($E0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $3F9F.w		; CE 9F 3F ; Decrement $3F9F.w [Flags: NZ]
	adc ($71.b,S),Y		; 73 71 ; Add with carry (stack relative indirect indexed) ($71.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc $7778E0.l,X		; FF E0 78 77 ; Subtract with carry (long,X) $7778E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy $DE3B.w,X		; BC 3B DE ; Load Y register $DE3B.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	sta $4EEF.w,X		; 9D EF 4E ; Store accumulator to $4EEF.w,X [Reads: Accumulator, X Index]
	sbc [$A7.b],Y		; F7 A7 ; Subtract with carry (long indexed) [$A7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor ($35.b,S),Y		; 53 35 ; XOR accumulator (stack relative indirect indexed) ($35.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($00.b,X)		; 21 00 ; Logical AND ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $30, $98		; 30 98 ; Branch if minus to $30, $98 [Flow: branch]
	cpy $43EE.w		; CC EE 43 ; Compare $43EE.w with Y register [Reads: Y Index] [Flags: NCZ]
	lda $8B3F.w		; AD 3F 8B ; Load $8B3F.w into accumulator [Writes: Accumulator] [Flags: NZ]
	jmp.w [$2200]		; DC 00 22 ; Jump long indirect [$2200] [Flow: jump]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $EF9000.l		; 22 00 90 EF ; Jump to subroutine long $EF9000.l [Writes: Stack Pointer] [Flow: call]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($23.b,X)		; 81 23 ; Store accumulator ($23.b,X) [Reads: Direct Page, Accumulator, X Index]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	and $804280.l,X		; 3F 80 42 80 ; AND accumulator with memory (long,X) $804280.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $ED3FC0.l,X		; 7F C0 3F ED ; Add long $ED3FC0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($EC.b)		; 12 EC ; OR accumulator with memory (indirect) ($EC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $F90FF0.l,X		; 1F F0 0F F9 ; Logical OR long $F90FF0.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $40.b		; 06 40 ; Arithmetic shift left $40.b [Reads: Direct Page] [Flags: NCZ]
	and $0025.w,X		; 3D 25 00 ; AND accumulator with memory $0025.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $F9.b,S		; 03 F9 ; OR accumulator with stack relative $F9.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $431800.l,X		; FF 00 18 43 ; Subtract with carry (long,X) $431800.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor [$FF.b]		; 47 FF ; Exclusive OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E7.b		; 00 E7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $BE037D.l		; 0F 7D 03 BE ; OR accumulator with memory (long) $BE037D.l [Writes: Accumulator] [Flags: NZ]
	ora ($DF.b,X)		; 01 DF ; Logical OR ($DF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $6F.b		; 00 6F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $77		; 80 77 ; Branch always to $80, $77 [Flow: branch]
	.db $80, $7B		; 80 7B ; Branch always to $80, $7B [Flow: branch]
	.db $80, $5D		; 80 5D ; Branch always to $80, $5D [Flow: branch]
	ldy #$56.b		; A0 56 ; Load #$56.b into Y register [Writes: Y Index] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	sty $18.b		; 84 18 ; Store Y register to $18.b [Reads: Y Index]
	ora ($0E.b,X)		; 01 0E ; Logical OR ($0E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	ora ($16.b,X)		; 01 16 ; Logical OR ($16.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $D6.b,S		; 23 D6 ; AND accumulator with stack relative $D6.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $D6.b,S		; C3 D6 ; Compare accumulator (stack relative) $D6.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	cmp $D3.b		; C5 D3 ; Compare $D3.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	eor $9DC4.w,Y		; 59 C4 9D ; Exclusive OR accumulator with memory $9DC4.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $42, $22		; 42 22 ; Reserved instruction
	sbc $C80007.l,X		; FF 07 00 C8 ; Subtract with carry (long,X) $C80007.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	bit $22.b		; 24 22 ; Test bits $22.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	jsr $4300.w		; 20 00 43 ; Jump to subroutine at $4300.w [Writes: Stack Pointer] [Flow: call]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$F8.b]		; 07 F8 ; OR accumulator with memory (long) [$F8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	sbc $43FF00.l,X		; FF 00 FF 43 ; Subtract with carry (long,X) $43FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $000500.l,X		; FF 00 05 00 ; Subtract with carry (long,X) $000500.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $000022.l,X		; FF 22 00 00 ; Subtract with carry (long,X) $000022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $43.b		; 05 43 ; Logical OR $43.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $022500.l		; 22 00 25 02 ; Jump to subroutine long $022500.l [Writes: Stack Pointer] [Flow: call]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $FF2400.l		; 22 00 24 FF ; Jump to subroutine long $FF2400.l [Writes: Stack Pointer] [Flow: call]
	lsr $00.b		; 46 00 ; Logical shift right $00.b [Reads: Direct Page] [Flags: NCZ]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $0022FF.l,X		; FF FF 22 00 ; Subtract with carry (long,X) $0022FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $9F4302.l		; 22 02 43 9F ; Jump to subroutine long $9F4302.l [Writes: Stack Pointer] [Flow: call]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $58DF.w		; 0D DF 58 ; Logical OR $58DF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lda $34D768.l		; AF 68 D7 34 ; Load long $34D768.l into accumulator [Writes: Accumulator] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	and $CD.b,X		; 35 CD ; Logical AND $CD.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $6060D0.l		; 2F D0 60 60 ; AND accumulator with memory (long) $6060D0.l [Writes: Accumulator] [Flags: NZ]
	sty $9A.b		; 84 9A ; Store Y register to $9A.b [Reads: Y Index]
	cop $0F.b		; 02 0F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2F.b		; 00 2F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $D0, $B7		; D0 B7 ; Branch if not equal to $D0, $B7 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	cmp [$DF.b]		; C7 DF ; Compare accumulator (long) [$DF.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cpx #$60.b		; E0 60 ; Compare #$60.b with X register [Reads: X Index] [Flags: NCZ]
	sbc $C07FBF.l,X		; FF BF 7F C0 ; Subtract with carry (long,X) $C07FBF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $0028FF.l,X		; 3F FF 28 00 ; AND accumulator with memory (long,X) $0028FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $00.b		; 46 00 ; Logical shift right $00.b [Reads: Direct Page] [Flags: NCZ]
	lda $3F9F03.l,X		; BF 03 9F 3F ; Load long $3F9F03.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $9F433E.l,X		; 9F 3E 43 9F ; Store accumulator (long,X) $9F433E.l,X [Reads: Accumulator, X Index]
	bit $0002.w,X		; 3C 02 00 ; Test bits $0002.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	adc $40247F.l,X		; 7F 7F 24 40 ; Add long $40247F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($9D.b,X)		; 01 9D ; Logical OR ($9D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $9F44.w,X		; 3C 44 9F ; Test bits $9F44.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	rol $3743.w,X		; 3E 43 37 ; Rotate left $3743.w,X [Reads: X Index] [Flags: NCZ]
	sta $2064E0.l,X		; 9F E0 64 20 ; Store accumulator (long,X) $2064E0.l,X [Reads: Accumulator, X Index]
	sbc $00FF7F.l,X		; FF 7F FF 00 ; Subtract with carry (long,X) $00FF7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $42, $40		; 42 40 ; Reserved instruction
	eor ($40.b,X)		; 41 40 ; Exclusive OR accumulator with memory ($40.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	eor $190000.l,X		; 5F 00 00 19 ; Exclusive OR accumulator with memory (long,X) $190000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc #$54.b		; E9 54 ; Subtract #$54.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	jsr ($FEF2.w,X)		; FC F2 FE ; Jump to subroutine indirect indexed ($FEF2.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $A8FF.w,Y		; F9 FF A8 ; Subtract with carry $A8FF.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	inc $FFAB.w,X		; FE AB FF ; Increment memory $FFAB.w,X [Reads: X Index] [Flags: NZ]
	adc $063F40.l,X		; 7F 40 3F 06 ; Add long $063F40.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $54.b		; 00 54 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $FF		; 80 FF ; Branch always to $80, $FF [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sbc $5777AC.l		; EF AC 77 57 ; Subtract with carry (long) $5777AC.l [Writes: Accumulator] [Flags: NCVZ]
	and $9F29.w,Y		; 39 29 9F ; AND accumulator with memory $9F29.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $90, $4F		; 90 4F ; Branch if carry clear to $90, $4F [Flow: branch]
	cmp $00F030.l		; CF 30 F0 00 ; Compare accumulator (long) $00F030.l [Reads: Accumulator] [Flags: NCZ]
	sbc $9F3C78.l,X		; FF 78 3C 9F ; Subtract with carry (long,X) $9F3C78.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $0F3060.l		; CF 60 30 0F ; Compare accumulator (long) $0F3060.l [Reads: Accumulator] [Flags: NCZ]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sbc $F868.w,Y		; F9 68 F8 ; Subtract with carry $F868.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sbc $D6.b		; E5 D6 ; Subtract $D6.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
.INDEX 8
	sep #$14		; E2 14
	sbc $F0.b		; E5 F0 ; Subtract $F0.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $11.b,X		; 15 11 ; OR accumulator with memory $11.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $F1.b		; 04 F1 ; Test and set bits $F1.b [Reads: Accumulator] [Flags: Z]
	adc [$67.b]		; 67 67 ; Add with carry (long) [$67.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$C8.b]		; E7 C8 ; Subtract with carry (long) [$C8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora #$0B.b		; 09 0B ; Logical OR #$0B.b with accumulator [Writes: Accumulator] [Flags: NZ]
	nop		; EA ; No operation
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $80, $BF		; 80 BF ; Branch always to $80, $BF [Flow: branch]
	dec $E65F.w		; CE 5F E6 ; Decrement $E65F.w [Flags: NZ]
	and $799773.l		; 2F 73 97 79 ; AND accumulator with memory (long) $799773.l [Writes: Accumulator] [Flags: NZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	bit $1EC5.w,X		; 3C C5 1E ; Test bits $1EC5.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
.INDEX 8
	sep #$17		; E2 17
	sbc #$86.b		; E9 86 ; Subtract #$86.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0002.w,Y		; 99 02 00 ; Store accumulator to $0002.w,Y [Reads: Y Index, Accumulator]
	brk $89.b		; 00 89 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jmp ($5E85.w,X)		; 7C 85 5E ; Jump indirect indexed to ($5E85.w,X) [Reads: X Index] [Flow: jump]
	ldx #$57.b		; A2 57 ; Load #$57.b into X register [Writes: X Index] [Flags: NZ]
	lda #$87.b		; A9 87 ; Load #$87.b into accumulator [Writes: Accumulator] [Flags: NZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	ora $0B.b,S		; 03 0B ; OR accumulator with stack relative $0B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $E5.b,S		; 23 E5 ; AND accumulator with stack relative $E5.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	lda $B9DA.w,Y		; B9 DA B9 ; Load $B9DA.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	cld		; D8 ; Clear decimal flag [Flags: D]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	and ($C8.b,S),Y		; 33 C8 ; AND accumulator (stack relative indirect indexed) ($C8.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $0001FF.l		; 22 FF 01 00 ; Jump to subroutine long $0001FF.l [Writes: Stack Pointer] [Flow: call]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $04.b		; 24 04 ; Test bits $04.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cpx $31.b		; E4 31 ; Compare $31.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $C1817E.l		; 22 7E 81 C1 ; Jump to subroutine long $C1817E.l [Writes: Stack Pointer] [Flow: call]
	rol $03.b,X		; 36 03 ; Rotate left $03.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	jmp ($E906.w)		; 6C 06 E9 ; Jump indirect to ($E906.w) [Flow: jump]
	cmp ($36.b,X)		; C1 36 ; Compare accumulator ($36.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	sbc ($0A.b),Y		; F1 0A ; Subtract with carry ($0A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $BE7F30.l		; EF 30 7F BE ; Subtract with carry (long) $BE7F30.l [Writes: Accumulator] [Flags: NCVZ]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $1C		; F0 1C ; Branch if equal to $F0, $1C [Flow: branch]
	tsb $8000.w		; 0C 00 80 ; Test and set bits $8000.w [Reads: Accumulator] [Flags: Z]
	cmp $CC3E.w,Y		; D9 3E CC ; Compare accumulator $CC3E.w,Y [Reads: Y Index] [Flags: NCZ]
	and $4EBF46.l,X		; 3F 46 BF 4E ; AND accumulator with memory (long,X) $4EBF46.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda $CE3FDE.l,X		; BF DE 3F CE ; Load long $CE3FDE.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	mvp $C6,$3F		; 44 3F C6 ; Move block positive $C6,$3F [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	jsl $800000.l		; 22 00 00 80 ; Jump to subroutine long $800000.l [Writes: Stack Pointer] [Flow: call]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx #$2F.b		; E0 2F ; Compare #$2F.b with X register [Reads: X Index] [Flags: NCZ]
	adc $1FE080.l,X		; 7F 80 E0 1F ; Add long $1FE080.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $EC.b,S		; 03 EC ; OR accumulator with stack relative $EC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp ($36.b,X)		; C1 36 ; Compare accumulator ($36.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	.db $F0, $0B		; F0 0B ; Branch if equal to $F0, $0B [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc [$00.b],Y		; F7 00 ; Subtract with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $0F00.w		; CE 00 0F ; Decrement $0F00.w [Flags: NZ]
	sbc $0E1CF8.l,X		; FF F8 1C 0E ; Subtract with carry (long,X) $0E1CF8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$FB.b]		; 07 FB ; OR accumulator with memory (long) [$FB.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx $1F.b		; E4 1F ; Compare $1F.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $EE.b,X		; 15 EE ; OR accumulator with memory $EE.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	asl $8031.w		; 0E 31 80 ; Arithmetic shift left $8031.w [Flags: NCZ]
	lsr $1DC0.w,X		; 5E C0 1D ; Logical shift right $1DC0.w,X [Reads: X Index] [Flags: NCZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ror $57.b,X		; 76 57 ; Rotate right $57.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ldy $CC37.w		; AC 37 CC ; Load $CC37.w into Y register [Writes: Y Index] [Flags: NZ]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($7F.b,X)		; E1 7F ; Subtract with carry ($7F.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $800063.l,X		; 3F 63 00 80 ; AND accumulator with memory (long,X) $800063.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $7F.b		; E5 7F ; Subtract $7F.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $80		; 70 80 ; Branch if overflow set to $70, $80 [Flow: branch]
	adc $880F88.l,X		; 7F 88 0F 88 ; Add long $880F88.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $8C.b,S		; 03 8C ; OR accumulator with stack relative $8C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $88.b		; 04 88 ; Test and set bits $88.b [Reads: Accumulator] [Flags: Z]
	ora $49.b		; 05 49 ; Logical OR $49.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $237FFF.l,X		; FF FF 7F 23 ; Subtract with carry (long,X) $237FFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc [$04.b],Y		; 77 04 ; Add with carry (long indexed) [$04.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx $C0.b,Y		; B6 C0 ; Load X register $C0.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	rol $01F0.w,X		; 3E F0 01 ; Rotate left $01F0.w,X [Reads: X Index] [Flags: NCZ]
	eor $F0.b,S		; 43 F0 ; Exclusive OR accumulator with stack relative $F0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cld		; D8 ; Clear decimal flag [Flags: D]
	ora $DC04DB.l,X		; 1F DB 04 DC ; Logical OR long $DC04DB.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $DD.b		; 00 DD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($C1.b,X)		; 01 C1 ; Logical OR ($C1.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	inc $FFFF.w,X		; FE FF FF ; Increment memory $FFFF.w,X [Reads: X Index] [Flags: NZ]
	cpx #$FF.b		; E0 FF ; Compare #$FF.b with X register [Reads: X Index] [Flags: NCZ]
	sbc $2FE4FE.l,X		; FF FE E4 2F ; Subtract with carry (long,X) $2FE4FE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $47.b		; 00 47 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $B7067F.l,X		; BF 7F 06 B7 ; Load long $B7067F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $807FBF.l,X		; 7F BF 7F 80 ; Add long $807FBF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sbc $010026.l,X		; FF 26 00 01 ; Subtract with carry (long,X) $010026.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $FF2700.l,X		; 3F 00 27 FF ; AND accumulator with memory (long,X) $FF2700.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $0002FF.l		; 22 FF 02 00 ; Jump to subroutine long $0002FF.l [Writes: Stack Pointer] [Flow: call]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	cop $FF.b		; 02 FF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $F70700.l		; 22 00 07 F7 ; Jump to subroutine long $F70700.l [Writes: Stack Pointer] [Flow: call]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sbc $43BC30.l		; EF 30 BC 43 ; Subtract with carry (long) $43BC30.l [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	mvp $F7,$43		; 44 43 F7 ; Move block positive $F7,$43 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $0F0025.l,X		; FF 25 00 0F ; Subtract with carry (long,X) $0F0025.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	lda $F77FB9.l,X		; BF B9 7F F7 ; Load long $F77FB9.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $DE7FEF.l,X		; 7F EF 7F DE ; Add long $DE7FEF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $802785.l,X		; 7F 85 27 80 ; Add long $802785.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $247F9B.l,X		; 7F 9B 7F 24 ; Add long $247F9B.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	jsl $FF0E00.l		; 22 00 0E FF ; Jump to subroutine long $FF0E00.l [Writes: Stack Pointer] [Flow: call]
	sbc [$FF.b]		; E7 FF ; Subtract with carry (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $FF7EFF.l,X		; 9F FF 7E FF ; Store accumulator (long,X) $FF7EFF.l,X [Reads: Accumulator, X Index]
	jsr ($08FF.w,X)		; FC FF 08 ; Jump to subroutine indirect indexed ($08FF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	tsb $FF00.w		; 0C 00 FF ; Test and set bits $FF00.w [Reads: Accumulator] [Flags: Z]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $020024.l,X		; FF 24 00 02 ; Subtract with carry (long,X) $020024.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($00.b,S),Y		; F3 00 ; Subtract with carry (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $0B3F.w		; AD 3F 0B ; Load $0B3F.w into accumulator [Writes: Accumulator] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	and $8068A0.l,X		; 3F A0 68 80 ; AND accumulator with memory (long,X) $8068A0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $F67FB6.l,X		; 7F B6 7F F6 ; Add long $F67FB6.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $223FB7.l,X		; 7F B7 3F 22 ; Add long $223FB7.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $401000.l		; 22 00 10 40 ; Jump to subroutine long $401000.l [Writes: Stack Pointer] [Flow: call]
	cmp $EEFF.w,X		; DD FF EE ; Compare accumulator $EEFF.w,X [Reads: X Index] [Flags: NCZ]
	sbc $1AFFED.l,X		; FF ED FF 1A ; Subtract with carry (long,X) $1AFFED.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $FF00.w,X		; 7E 00 FF ; Rotate right $FF00.w,X [Reads: X Index] [Flags: NCZ]
	sbc [$FF.b],Y		; F7 FF ; Subtract with carry (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FF1EFF.l		; EF FF 1E FF ; Subtract with carry (long) $FF1EFF.l [Writes: Accumulator] [Flags: NCVZ]
	jsl $810000.l		; 22 00 00 81 ; Jump to subroutine long $810000.l [Writes: Stack Pointer] [Flow: call]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $80.b,S		; 43 80 ; Exclusive OR accumulator with stack relative $80.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $7FBF10.l,X		; 7F 10 BF 7F ; Add long $7FBF10.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$40.b		; C0 40 ; Compare #$40.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $80, $3F		; 80 3F ; Branch always to $80, $3F [Flow: branch]
	.db $80, $7F		; 80 7F ; Branch always to $80, $7F [Flow: branch]
	sta $7C.b,S		; 83 7C ; Store accumulator (stack relative) $7C.b,S [Reads: Stack Pointer, Accumulator]
	sbc $407F00.l,X		; FF 00 7F 40 ; Subtract with carry (long,X) $407F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	jsl $FF0100.l		; 22 00 01 FF ; Jump to subroutine long $FF0100.l [Writes: Stack Pointer] [Flow: call]
	brk $87.b		; 00 87 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0601.w		; 0C 01 06 ; Test and set bits $0601.w [Reads: Accumulator] [Flags: Z]
	stx $9F71.w		; 8E 71 9F ; Store X register to $9F71.w [Reads: X Index]
	adc $007FBF.l,X		; 7F BF 7F 00 ; Add long $007FBF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sty $1A.b		; 84 1A ; Store Y register to $1A.b [Reads: Y Index]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $00FF3F.l,X		; 1F 3F FF 00 ; Logical OR long $00FF3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $0022FF.l,X		; FF FF 22 00 ; Subtract with carry (long,X) $0022FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$FF.b]		; 07 FF ; OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc ($8C.b,S),Y		; 73 8C ; Add with carry (stack relative indirect indexed) ($8C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $BF		; 70 BF ; Branch if overflow set to $70, $BF [Flow: branch]
	eor [$FF.b]		; 47 FF ; Exclusive OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $008385.l,X		; DF 85 83 00 ; Compare accumulator (long,X) $008385.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	tsb $7F3F.w		; 0C 3F 7F ; Test and set bits $7F3F.w [Reads: Accumulator] [Flags: Z]
	sbc $D544C5.l,X		; FF C5 44 D5 ; Subtract with carry (long,X) $D544C5.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	mvn $50,$D1		; 54 D1 50 ; Move block negative $50,$D1 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cmp $CD58.w,Y		; D9 58 CD ; Compare accumulator $CD58.w,Y [Reads: Y Index] [Flags: NCZ]
	jmp $5085.w		; 4C 85 50 ; Jump to $5085.w [Flow: jump]
	ora ($0B.b,X)		; 01 0B ; Logical OR ($0B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rol $3226.w		; 2E 26 32 ; Rotate left $3226.w [Flags: NCZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rol $00FF.w		; 2E FF 00 ; Rotate left $00FF.w [Flags: NCZ]
	sbc $548B7E.l,X		; FF 7E 8B 54 ; Subtract with carry (long,X) $548B7E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $62.b		; 85 62 ; Store accumulator to $62.b [Reads: Accumulator]
	ora ($E0.b,X)		; 01 E0 ; Logical OR ($E0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rol $41.b,X		; 36 41 ; Rotate left $41.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	lda $C428.w,Y		; B9 28 C4 ; Load $C428.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $ED.b,X		; 15 ED ; OR accumulator with memory $ED.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	trb $EC.b		; 14 EC ; Test and reset bits $EC.b [Reads: Accumulator] [Flags: Z]
	asl $FE.b		; 06 FE ; Arithmetic shift left $FE.b [Reads: Direct Page] [Flags: NCZ]
	ora $00FD.w		; 0D FD 00 ; Logical OR $00FD.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $C6.b		; 04 C6 ; Test and set bits $C6.b [Reads: Accumulator] [Flags: Z]
	sbc ($F0.b,S),Y		; F3 F0 ; Subtract with carry (stack relative indirect indexed) ($F0.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($F3.b)		; F2 F3 ; Subtract with carry (indirect) ($F3.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($F2.b),Y		; F1 F2 ; Subtract with carry ($F2.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $7E		; 80 7E ; Branch always to $80, $7E [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	ldx $8618.w,Y		; BE 18 86 ; Load X register $8618.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	.db $42, $BE		; 42 BE ; Reserved instruction
	asl $047F.w,X		; 1E 7F 04 ; Arithmetic shift left $047F.w,X [Reads: X Index] [Flags: NCZ]
	bit $92.b		; 24 92 ; Test bits $92.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	lda ($FF.b)		; B2 FF ; Load accumulator (indirect) ($FF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $017F7F.l,X		; FF 7F 7F 01 ; Subtract with carry (long,X) $017F7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $DB		; 80 DB ; Branch always to $80, $DB [Flow: branch]
	eor $E7FF.w		; 4D FF E7 ; Exclusive OR $E7FF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $08EF18.l,X		; FF 18 EF 08 ; Subtract with carry (long,X) $08EF18.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$44.b]		; E7 44 ; Subtract with carry (long) [$44.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc $43FF00.l		; EF 00 FF 43 ; Subtract with carry (long) $43FF00.l [Writes: Accumulator] [Flags: NCVZ]
	bit $E7.b		; 24 E7 ; Test bits $E7.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora $C3.b,S		; 03 C3 ; OR accumulator with stack relative $C3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp ($C3.b,S),Y		; D3 C3 ; Compare accumulator (stack relative indirect indexed) ($C3.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	jsl $0037BD.l		; 22 BD 37 00 ; Jump to subroutine long $0037BD.l [Writes: Stack Pointer] [Flow: call]
	ora ($A7.b),Y		; 11 A7 ; OR accumulator with memory ($A7.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	.db $B0, $70		; B0 70 ; Branch if carry set to $B0, $70 [Flow: branch]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	adc $A03FD1.l,X		; 7F D1 3F A0 ; Add long $A03FD1.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $BF60DF.l,X		; 5F DF 60 BF ; Exclusive OR accumulator with memory (long,X) $BF60DF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsr $00FF.w		; 20 FF 00 ; Jump to subroutine at $00FF.w [Writes: Stack Pointer] [Flow: call]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $40.b		; 02 40 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $E70500.l		; 22 00 05 E7 ; Jump to subroutine long $E70500.l [Writes: Stack Pointer] [Flow: call]
	sbc $00FFC3.l,X		; FF C3 FF 00 ; Subtract with carry (long,X) $00FFC3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $00FF45.l,X		; FF 45 FF 00 ; Subtract with carry (long,X) $00FF45.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $0E0025.l,X		; FF 25 00 0E ; Subtract with carry (long,X) $0E0025.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda [$48.b],Y		; B7 48 ; Load accumulator (long indexed) [$48.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc [$88.b],Y		; F7 88 ; Subtract with carry (long indexed) [$88.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp [$E8.b],Y		; D7 E8 ; Compare accumulator (long indexed) [$E8.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	cpx $84.b		; E4 84 ; Compare $84.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	ldy $40E0.w		; AC E0 40 ; Load $40E0.w into Y register [Writes: Y Index] [Flags: NZ]
	sbc $030024.l,X		; FF 24 00 03 ; Subtract with carry (long,X) $030024.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $10, $1F		; 10 1F ; Branch if plus to $10, $1F [Flow: branch]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $8B3F.w		; AD 3F 8B ; Load $8B3F.w into accumulator [Writes: Accumulator] [Flags: NZ]
	jmp.w [$2200]		; DC 00 22 ; Jump long indirect [$2200] [Flow: jump]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $EF9000.l		; 22 00 90 EF ; Jump to subroutine long $EF9000.l [Writes: Stack Pointer] [Flow: call]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($23.b,X)		; 81 23 ; Store accumulator ($23.b,X) [Reads: Direct Page, Accumulator, X Index]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	and $804280.l,X		; 3F 80 42 80 ; AND accumulator with memory (long,X) $804280.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $ED3FC0.l,X		; 7F C0 3F ED ; Add long $ED3FC0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($EC.b)		; 12 EC ; OR accumulator with memory (indirect) ($EC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $F90FF0.l,X		; 1F F0 0F F9 ; Logical OR long $F90FF0.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $40.b		; 06 40 ; Arithmetic shift left $40.b [Reads: Direct Page] [Flags: NCZ]
	and $0025.w,X		; 3D 25 00 ; AND accumulator with memory $0025.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $F9.b,S		; 03 F9 ; OR accumulator with stack relative $F9.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $431800.l,X		; FF 00 18 43 ; Subtract with carry (long,X) $431800.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor [$FF.b]		; 47 FF ; Exclusive OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E7.b		; 00 E7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $020022.l,X		; FF 22 00 02 ; Subtract with carry (long,X) $020022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $45FF00.l,X		; FF 00 FF 45 ; Subtract with carry (long,X) $45FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $000100.l,X		; FF 00 01 00 ; Subtract with carry (long,X) $000100.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $000023.l,X		; FF 23 00 00 ; Subtract with carry (long,X) $000023.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	mvp $F0,$7F		; 44 7F F0 ; Move block positive $F0,$7F [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	tsb $FC.b		; 04 FC ; Test and set bits $FC.b [Reads: Accumulator] [Flags: Z]
	adc $FC7FFF.l,X		; 7F FF 7F FC ; Add long $FC7FFF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $7F.b,S		; 43 7F ; Exclusive OR accumulator with stack relative $7F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	adc $FF0043.l,X		; 7F 43 00 FF ; Add long $FF0043.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $1F.b		; 04 1F ; Test and set bits $1F.b [Reads: Accumulator] [Flags: Z]
	sbc $80FFF8.l,X		; FF F8 FF 80 ; Subtract with carry (long,X) $80FFF8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $FF.b		; 45 FF ; Exclusive OR $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $54D409.l,X		; FF 09 D4 54 ; Subtract with carry (long,X) $54D409.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $56.b,X		; D6 56 ; Decrement memory $56.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	cpy #$40.b		; C0 40 ; Compare #$40.b with Y register [Reads: Y Index] [Flags: NCZ]
	dec $46.b		; C6 46 ; Decrement $46.b [Reads: Direct Page] [Flags: NZ]
	.db $F0, $40		; F0 40 ; Branch if equal to $F0, $40 [Flow: branch]
	mvp $7F,$FF		; 44 FF 7F ; Move block positive $7F,$FF [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	and #$3F.b		; 29 3F ; Logical AND #$3F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	and $243F.w,Y		; 39 3F 24 ; AND accumulator with memory $243F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($73.b,S),Y		; 73 73 ; Add with carry (stack relative indirect indexed) ($73.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	dec $00CE.w		; CE CE 00 ; Decrement $00CE.w [Flags: NZ]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FF0005.l,X		; FF 05 00 FF ; Subtract with carry (long,X) $FF0005.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sty $31E7.w		; 8C E7 31 ; Store Y register to $31E7.w [Reads: Y Index]
	sbc $070022.l,X		; FF 22 00 07 ; Subtract with carry (long,X) $070022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $B757C0.l,X		; 3F C0 57 B7 ; AND accumulator with memory (long,X) $B757C0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	adc $4368A7.l		; 6F A7 68 43 ; Add with carry (long) $4368A7.l [Writes: Accumulator] [Flags: NCVZ]
	lda $AC4360.l		; AF 60 43 AC ; Load long $AC4360.l into accumulator [Writes: Accumulator] [Flags: NZ]
	adc $03.b,S		; 63 03 ; Add with carry (stack relative) $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	and $17.b,S		; 23 17 ; AND accumulator with stack relative $17.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $FF.b		; 85 FF ; Store accumulator to $FF.b [Reads: Accumulator]
	ora ($45.b,X)		; 01 45 ; Logical OR ($45.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $004300.l,X		; FF 00 43 00 ; Subtract with carry (long,X) $004300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $230023.l,X		; FF 23 00 23 ; Subtract with carry (long,X) $230023.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $63AC4F.l,X		; FF 4F AC 63 ; Subtract with carry (long,X) $63AC4F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and [$17.b]		; 27 17 ; AND accumulator with memory (long) [$17.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr $FF00.w		; 4E 00 FF ; Logical shift right $FF00.w [Flags: NCZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	sbc $0030E4.l,X		; FF E4 30 00 ; Subtract with carry (long,X) $0030E4.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora #$77.b		; 09 77 ; Logical OR #$77.b with accumulator [Writes: Accumulator] [Flags: NZ]
	eor $FF.b,X		; 55 FF ; Exclusive OR accumulator with memory $FF.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $55AAAA.l,X		; FF AA AA 55 ; Subtract with carry (long,X) $55AAAA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	eor $55.b,S		; 43 55 ; Exclusive OR accumulator with stack relative $55.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $88AA01.l,X		; FF 01 AA 88 ; Subtract with carry (long,X) $88AA01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $440000.l		; 22 00 00 44 ; Jump to subroutine long $440000.l [Writes: Stack Pointer] [Flow: call]
	jsl $FC0700.l		; 22 00 07 FC ; Jump to subroutine long $FC0700.l [Writes: Stack Pointer] [Flow: call]
	sta [$C6.b],Y		; 97 C6 ; Store accumulator (long indexed) [$C6.b],Y [Reads: Direct Page, Y Index, Accumulator]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr ($CE96.w,X)		; FC 96 CE ; Jump to subroutine indirect indexed ($CE96.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta [$A8.b]		; 87 A8 ; Store accumulator (long) [$A8.b] [Reads: Direct Page, Accumulator]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta $B8.b,S		; 83 B8 ; Store accumulator (stack relative) $B8.b,S [Reads: Stack Pointer, Accumulator]
	ora $14.b,S		; 03 14 ; OR accumulator with stack relative $14.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr ($C496.w,X)		; FC 96 C4 ; Jump to subroutine indirect indexed ($C496.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	eor ($FB.b,S),Y		; 53 FB ; XOR accumulator (stack relative indirect indexed) ($FB.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sty $D7.b,X		; 94 D7 ; Store Y register $D7.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	adc #$ED.b		; 69 ED ; Add #$ED.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta ($F5.b,X)		; 81 F5 ; Store accumulator ($F5.b,X) [Reads: Direct Page, Accumulator, X Index]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	sbc $D5FF8A.l,X		; FF 8A FF D5 ; Subtract with carry (long,X) $D5FF8A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($28.b,X)		; 01 28 ; Logical OR ($28.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($22.b)		; 12 22 ; OR accumulator with memory (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $26DFFF.l,X		; FF FF DF 26 ; Subtract with carry (long,X) $26DFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $24FB00.l,X		; FF 00 FB 24 ; Subtract with carry (long,X) $24FB00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $430027.l,X		; FF 27 00 43 ; Subtract with carry (long,X) $430027.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FF013C.l		; EF 3C 01 FF ; Subtract with carry (long) $FF013C.l [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FF0002.l,X		; FF 02 00 FF ; Subtract with carry (long,X) $FF0002.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $C300.w,X		; BD 00 C3 ; Load $C300.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $0000FF.l		; 22 FF 00 00 ; Jump to subroutine long $0000FF.l [Writes: Stack Pointer] [Flow: call]
	eor $2740FF.l		; 4F FF 40 27 ; Exclusive OR accumulator with memory (long) $2740FF.l [Writes: Accumulator] [Flags: NZ]
	adc $C0FF01.l,X		; 7F 01 FF C0 ; Add long $C0FF01.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $00FF.w		; 4D FF 00 ; Exclusive OR $00FF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	sbc $FF0049.l,X		; FF 49 00 FF ; Subtract with carry (long,X) $FF0049.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rol $FF.b		; 26 FF ; Rotate left $FF.b [Reads: Direct Page] [Flags: NCZ]
	ora ($7F.b),Y		; 11 7F ; OR accumulator with memory ($7F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$20.b		; C0 20 ; Compare #$20.b with Y register [Reads: Y Index] [Flags: NCZ]
	cmp [$2A.b]		; C7 2A ; Compare accumulator (long) [$2A.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp $2A.b		; C5 2A ; Compare $2A.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sbc $0A.b		; E5 0A ; Subtract $0A.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$08.b]		; E7 08 ; Subtract with carry (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $0FFF1F.l,X		; FF 1F FF 0F ; Subtract with carry (long,X) $0FFF1F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $221F00.l,X		; FF 00 1F 22 ; Subtract with carry (long,X) $221F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($02.b)		; 12 02 ; OR accumulator with memory (indirect) ($02.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	ora $000022.l		; 0F 22 00 00 ; OR accumulator with memory (long) $000022.l [Writes: Accumulator] [Flags: NZ]
	eor #$45.b		; 49 45 ; Exclusive OR #$45.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ldx $FF.b,Y		; B6 FF ; Load X register $FF.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $FF.b		; 24 FF ; Test bits $FF.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $303000.l,X		; FF 00 30 30 ; Subtract with carry (long,X) $303000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0080E5.l,X		; FF E5 80 00 ; Subtract with carry (long,X) $0080E5.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $5028E0.l,X		; FF E0 28 50 ; Subtract with carry (long,X) $5028E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $AFDF04.l,X		; DF 04 DF AF ; Compare accumulator (long,X) $AFDF04.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	sbc $85FFC0.l,X		; FF C0 FF 85 ; Subtract with carry (long,X) $85FFC0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $00.b		; E5 00 ; Subtract $00.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$02.b		; C0 02 ; Compare #$02.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $82, $00, $00		; 82 00 00 ; Branch always long to $82, $00, $00 [Flow: branch]
	jsr $0020.w		; 20 20 00 ; Jump to subroutine at $0020.w [Writes: Stack Pointer] [Flow: call]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $93FF12.l		; EF 12 FF 93 ; Subtract with carry (long) $93FF12.l [Writes: Accumulator] [Flags: NCVZ]
	sbc $53FF07.l,X		; FF 07 FF 53 ; Subtract with carry (long,X) $53FF07.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $002721.l,X		; DF 21 27 00 ; Compare accumulator (long,X) $002721.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $200000.l		; 22 00 00 20 ; Jump to subroutine long $200000.l [Writes: Stack Pointer] [Flow: call]
	jsl $27E000.l		; 22 00 E0 27 ; Jump to subroutine long $27E000.l [Writes: Stack Pointer] [Flow: call]
	sed		; [PATTERN: Memory clearing operation] F8 ; Set decimal flag [Flags: D]
	adc [$F0.b]		; 67 F0 ; Add with carry (long) [$F0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc $F368F3.l		; 6F F3 68 F3 ; Add with carry (long) $F368F3.l [Writes: Accumulator] [Flags: NCVZ]
	stz $93.b		; 64 93 ; Store zero to $93.b
	stz $B3.b		; 64 B3 ; Store zero to $B3.b
	bit $F3.b		; 24 F3 ; Test bits $F3.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	stz $F9.b		; 64 F9 ; Store zero to $F9.b
	ror $0000.w		; 6E 00 00 ; Rotate right $0000.w [Flags: NCZ]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta [$87.b]		; 87 87 ; Store accumulator (long) [$87.b] [Reads: Direct Page, Accumulator]
	sbc $BBFF4C.l,X		; FF 4C FF BB ; Subtract with carry (long,X) $BBFF4C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp ($4887.w,X)		; 7C 87 48 ; Jump indirect indexed to ($4887.w,X) [Reads: X Index] [Flow: jump]
	sta [$58.b],Y		; 97 58 ; Store accumulator (long indexed) [$58.b],Y [Reads: Direct Page, Y Index, Accumulator]
	cmp $38E710.l,X		; DF 10 E7 38 ; Compare accumulator (long,X) $38E710.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $30.b		; 02 30 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $E420.w		; 20 20 E4 ; Jump to subroutine at $E420.w [Writes: Stack Pointer] [Flow: call]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$23.b]		; 07 23 ; OR accumulator with memory (long) [$23.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $1F		; 30 1F ; Branch if minus to $30, $1F [Flow: branch]
	ora $446362.l,X		; 1F 62 63 44 ; Logical OR long $446362.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dec $38.b		; C6 38 ; Decrement $38.b [Reads: Direct Page] [Flags: NZ]
	sbc $F100.w,X		; FD 00 F1 ; Subtract with carry $F100.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $8D.b		; 00 8D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $80, $01		; 80 01 ; Branch always to $80, $01 [Flow: branch]
	sta $CF.b,S		; 83 CF ; Store accumulator (stack relative) $CF.b,S [Reads: Stack Pointer, Accumulator]
	sbc ($00.b,S),Y		; F3 00 ; Subtract with carry (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	brk $7B.b		; 00 7B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $FEDD.w,X		; FD DD FE ; Subtract with carry $FEDD.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $F7DF.w		; 2E DF F7 ; Rotate left $F7DF.w [Flags: NCZ]
	sbc $7D77FB.l		; EF FB 77 7D ; Subtract with carry (long) $7D77FB.l [Writes: Accumulator] [Flags: NCVZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $C47F.w,X		; 3E 7F C4 ; Rotate left $C47F.w,X [Reads: X Index] [Flags: NCZ]
	jsl $0408D1.l		; 22 D1 08 04 ; Jump to subroutine long $0408D1.l [Writes: Stack Pointer] [Flow: call]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $2401FD.l,X		; FF FD 01 24 ; Subtract with carry (long,X) $2401FD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: NCZ]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: NCZ]
	sbc $000102.l,X		; FF 02 01 00 ; Subtract with carry (long,X) $000102.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $40		; 80 40 ; Branch always to $80, $40 [Flow: branch]
	jsr $0010.w		; 20 10 00 ; Jump to subroutine at $0010.w [Writes: Stack Pointer] [Flow: call]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $FFFA.w,X		; FE FA FF ; Increment memory $FFFA.w,X [Reads: X Index] [Flags: NZ]
	sbc $7E7F.w,X		; FD 7F 7E ; Subtract with carry $7E7F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $1F1F3F.l,X		; 3F 3F 1F 1F ; AND accumulator with memory (long,X) $1F1F3F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $FF070F.l		; 0F 0F 07 FF ; OR accumulator with memory (long) $FF070F.l [Writes: Accumulator] [Flags: NZ]
	brk $84.b		; 00 84 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($00.b,S),Y		; D3 00 ; Compare accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$4E.b		; E0 4E ; Compare #$4E.b with X register [Reads: X Index] [Flags: NCZ]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $08.b		; 06 08 ; Arithmetic shift left $08.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $10080E.l		; 0F 0E 08 10 ; OR accumulator with memory (long) $10080E.l [Writes: Accumulator] [Flags: NZ]
	asl $F6.b		; 06 F6 ; Arithmetic shift left $F6.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $90		; 10 90 ; Branch if plus to $10, $90 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc ($80.b,X)		; 61 80 ; Add with carry ($80.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $82, $00, $05		; 82 00 05 ; Branch always long to $82, $00, $05 [Flow: branch]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $70, $E8		; 70 E8 ; Branch if overflow set to $70, $E8 [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ora $02.b		; 05 02 ; Logical OR $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	brk $2D.b		; 00 2D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $58.b		; 00 58 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($B9.b,X)		; 01 B9 ; Logical OR ($B9.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $2F.b,X		; 16 2F ; Arithmetic shift left $2F.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	jmp $9848AC.l		; 5C AC 48 98 ; Jump long to $9848AC.l [Flow: jump]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	.db $30, $20		; 30 20 ; Branch if minus to $30, $20 [Flow: branch]
	cpx #$10.b		; E0 10 ; Compare #$10.b with X register [Reads: X Index] [Flags: NCZ]
	.db $F0, $08		; F0 08 ; Branch if equal to $F0, $08 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	tsb $7C.b		; 04 7C ; Test and set bits $7C.b [Reads: Accumulator] [Flags: Z]
	ora $60001F.l		; 0F 1F 00 60 ; OR accumulator with memory (long) $60001F.l [Writes: Accumulator] [Flags: NZ]
	brk $6F.b		; 00 6F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $C8.b,S		; 83 C8 ; Store accumulator (stack relative) $C8.b,S [Reads: Stack Pointer, Accumulator]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $1D1010.l,X		; 1F 10 10 1D ; Logical OR long $1D1010.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora $1E1D.w,X		; 1D 1D 1E ; OR accumulator with memory $1E1D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	and $22FFE0.l,X		; 3F E0 FF 22 ; AND accumulator with memory (long,X) $22FFE0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0588B8.l,X		; FF B8 88 05 ; Subtract with carry (long,X) $0588B8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sty $BE.b		; 84 BE ; Store Y register to $BE.b [Reads: Y Index]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $70		; F0 70 ; Branch if equal to $F0, $70 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	sec		; 38 ; Set carry flag [Flags: C]
	jmp ($BE9C.w,X)		; 7C 9C BE ; Jump indirect indexed to ($BE9C.w,X) [Reads: X Index] [Flow: jump]
	lsr $A75F.w		; 4E 5F A7 ; Logical shift right $A75F.w [Flags: NCZ]
	jsl $FF0800.l		; 22 00 08 FF ; Jump to subroutine long $FF0800.l [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cpy $62.b		; C4 62 ; Compare $62.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	lda ($58.b),Y		; B1 58 ; Load accumulator ($58.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $440022.l,X		; FF 22 00 44 ; Subtract with carry (long,X) $440022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	ora #$C0.b		; 09 C0 ; Logical OR #$C0.b with accumulator [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc ($30.b)		; 72 30 ; Add with carry (indirect) ($30.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda [$17.b],Y		; B7 17 ; Load accumulator (long indexed) [$17.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp [$24.b],Y		; D7 24 ; Compare accumulator (long indexed) [$24.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $40		; 80 40 ; Branch always to $80, $40 [Flow: branch]
	jsr $4401.w		; 20 01 44 ; Jump to subroutine at $4401.w [Writes: Stack Pointer] [Flow: call]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora #$03.b		; 09 03 ; Logical OR #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr $ED0C.w		; 4E 0C ED ; Logical shift right $ED0C.w [Flags: NCZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	asl $01.b,X		; 16 01 ; Arithmetic shift left $01.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $69		; F0 69 ; Branch if equal to $F0, $69 [Flow: branch]
	sbc ($6F.b,S),Y		; F3 6F ; Subtract with carry (stack relative indirect indexed) ($6F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sta $AC67.w,Y		; 99 67 AC ; Store accumulator to $AC67.w,Y [Reads: Y Index, Accumulator]
	adc $DF.b,S		; 63 DF ; Add with carry (stack relative) $DF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sec		; 38 ; Set carry flag [Flags: C]
	inc $771D.w		; EE 1D 77 ; Increment $771D.w [Flags: NZ]
	stx $CE33.w		; 8E 33 CE ; Store X register to $CE33.w [Reads: X Index]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $EF18FF.l		; 0F FF 18 EF ; OR accumulator with memory (long) $EF18FF.l [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc $C0FF80.l,X		; FF 80 FF C0 ; Subtract with carry (long,X) $C0FF80.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $EF7000.l,X		; FF 00 70 EF ; Subtract with carry (long,X) $EF7000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $EF		; 30 EF ; Branch if minus to $30, $EF [Flow: branch]
	ora $0032FF.l		; 0F FF 32 00 ; OR accumulator with memory (long) $0032FF.l [Writes: Accumulator] [Flags: NZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $F7.b		; 84 F7 ; Store Y register to $F7.b [Reads: Y Index]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($0E.b,S),Y		; 33 0E ; AND accumulator (stack relative indirect indexed) ($0E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $3010.w		; 0E 10 30 ; Arithmetic shift left $3010.w [Flags: NCZ]
	jsr $46E0.w		; 20 E0 46 ; Jump to subroutine at $46E0.w [Writes: Stack Pointer] [Flow: call]
	cmp [$78.b]		; C7 78 ; Compare accumulator (long) [$78.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	inc $F921.w,X		; FE 21 F9 ; Increment memory $F921.w,X [Reads: X Index] [Flags: NZ]
	ora $C0301E.l		; 0F 1E 30 C0 ; OR accumulator with memory (long) $C0301E.l [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $70, $7D		; 70 7D ; Branch if overflow set to $70, $7D [Flow: branch]
	.db $90, $99		; 90 99 ; Branch if carry clear to $90, $99 [Flow: branch]
	tsb $15.b		; 04 15 ; Test and set bits $15.b [Reads: Accumulator] [Flags: Z]
	tsb $1C6D.w		; 0C 6D 1C ; Test and set bits $1C6D.w [Reads: Accumulator] [Flags: Z]
	sta $6D68.w,X		; 9D 68 6D ; Store accumulator to $6D68.w,X [Reads: Accumulator, X Index]
	.db $80, $89		; 80 89 ; Branch always to $80, $89 [Flow: branch]
	brk $15.b		; 00 15 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $82, $06, $0A		; 82 06 0A ; Branch always long to $82, $06, $0A [Flow: branch]
	ora ($62.b)		; 12 62 ; OR accumulator with memory (indirect) ($62.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $82, $06, $0A		; 82 06 0A ; Branch always long to $82, $06, $0A [Flow: branch]
	ora $0E1F.w,X		; 1D 1F 0E ; OR accumulator with memory $0E1F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $030707.l		; 0F 07 07 03 ; OR accumulator with memory (long) $030707.l [Writes: Accumulator] [Flags: NZ]
	ora $83.b,S		; 03 83 ; OR accumulator with stack relative $83.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $0301.w		; ED 01 03 ; Subtract $0301.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cpy #$27.b		; C0 27 ; Compare #$27.b with Y register [Reads: Y Index] [Flags: NCZ]
	brk $86.b		; 00 86 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	dec $E7DF.w		; CE DF E7 ; Decrement $E7DF.w [Flags: NZ]
	sbc $7977F3.l		; EF F3 77 79 ; Subtract with carry (long) $7977F3.l [Writes: Accumulator] [Flags: NCVZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $C488.w,X		; 3C 88 C4 ; Test bits $C488.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	.db $62, $31, $18		; 62 31 18 ; Push effective relative address $62, $31, $18 [Writes: Stack Pointer]
	tsb $0306.w		; 0C 06 03 ; Test and set bits $0306.w [Reads: Accumulator] [Flags: Z]
	sty $2D.b		; 84 2D ; Store Y register to $2D.b [Reads: Y Index]
	cop $24.b		; 02 24 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $85.b		; 00 85 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $0200.w,X		; BD 00 02 ; Load $0200.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $80, $40		; 80 40 ; Branch always to $80, $40 [Flow: branch]
	jsr $1022.w		; 20 22 10 ; Jump to subroutine at $1022.w [Writes: Stack Pointer] [Flow: call]
	eor $20.b,S		; 43 20 ; Exclusive OR accumulator with stack relative $20.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora ($73.b,S),Y		; 13 73 ; OR accumulator (stack relative indirect indexed) ($73.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $007F.w		; 0C 7F 00 ; Test and set bits $007F.w [Reads: Accumulator] [Flags: Z]
	ror $7D00.w,X		; 7E 00 7D ; Rotate right $7D00.w,X [Reads: X Index] [Flags: NCZ]
	brk $7A.b		; 00 7A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	and $80.b,S		; 23 80 ; AND accumulator with stack relative $80.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	trb $C281.w		; 1C 81 C2 ; Test and reset bits $C281.w [Reads: Accumulator] [Flags: Z]
	cpy $2900.w		; CC 00 29 ; Compare $2900.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $53.b		; 00 53 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $A3		; 80 A3 ; Branch always to $80, $A3 [Flow: branch]
	tsb $A6.b		; 04 A6 ; Test and set bits $A6.b [Reads: Accumulator] [Flags: Z]
	and $007D.w,Y		; 39 7D 00 ; AND accumulator with memory $007D.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $C901.w,Y		; F9 01 C9 ; Subtract with carry $C901.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	eor ($82.b,X)		; 41 82 ; Exclusive OR accumulator with memory ($82.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	asl $04.b		; 06 04 ; Arithmetic shift left $04.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0101.w		; 0D 01 01 ; Logical OR $0101.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($81.b,X)		; 81 81 ; Store accumulator ($81.b,X) [Reads: Direct Page, Accumulator, X Index]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00BF.w,X		; 3C BF 00 ; Test bits $00BF.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	adc $A09050.l,X		; 7F 50 90 A0 ; Add long $A09050.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy #$22.b		; A0 22 ; Load #$22.b into Y register [Writes: Y Index] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $80.b,S		; 43 80 ; Exclusive OR accumulator with stack relative $80.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	ora ($84.b,X)		; 01 84 ; Logical OR ($84.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpx $0245.w		; EC 45 02 ; Compare $0245.w with X register [Reads: X Index] [Flags: NCZ]
	inc $0143.w		; EE 43 01 ; Increment $0143.w [Flags: NZ]
	sbc $111025.l		; EF 25 10 11 ; Subtract with carry (long) $111025.l [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $70		; 30 70 ; Branch if minus to $30, $70 [Flow: branch]
	jmp.w [$AEC4]		; DC C4 AE ; Jump long indirect [$AEC4] [Flow: jump]
	ldx #$17.b		; A2 17 ; Load #$17.b into X register [Writes: X Index] [Flags: NZ]
	ora ($0B.b),Y		; 11 0B ; OR accumulator with memory ($0B.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($12.b)		; 32 12 ; AND accumulator with memory (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $1C29.w,Y		; 39 29 1C ; AND accumulator with memory $1C29.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $83.b		; 14 83 ; Test and reset bits $83.b [Reads: Accumulator] [Flags: Z]
	mvn $03,$02		; 54 02 03 ; Move block negative $03,$02 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora ($20.b,X)		; 01 20 ; Logical OR ($20.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $10, $08		; 10 08 ; Branch if plus to $10, $08 [Flow: branch]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$80.b		; 09 80 ; Logical OR #$80.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cpx #$20.b		; E0 20 ; Compare #$20.b with X register [Reads: X Index] [Flags: NCZ]
	.db $70, $10		; 70 10 ; Branch if overflow set to $70, $10 [Flow: branch]
	clv		; B8 ; Clear overflow flag [Flags: V]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $80.b		; 05 80 ; Logical OR $80.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpy #$60.b		; C0 60 ; Compare #$60.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $30, $01		; 30 01 ; Branch if minus to $30, $01 [Flow: branch]
	ora ($25.b,X)		; 01 25 ; Logical OR ($25.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $09.b		; 04 09 ; Test and set bits $09.b [Reads: Accumulator] [Flags: Z]
	asl $2018.w		; 0E 18 20 ; Arithmetic shift left $2018.w [Flags: NCZ]
	.db $10, $98		; 10 98 ; Branch if plus to $10, $98 [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $B0, $B0		; B0 B0 ; Branch if carry set to $B0, $B0 [Flow: branch]
	.db $30, $30		; [PATTERN: Memory clearing operation] 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	stz $6C.b		; 64 6C ; Store zero to $6C.b
	asl $1C.b		; 06 1C ; Arithmetic shift left $1C.b [Reads: Direct Page] [Flags: NCZ]
	stz $84.b		; 64 84 ; Store zero to $84.b
	jsl $44E008.l		; 22 08 E0 44 ; Jump to subroutine long $44E008.l [Writes: Stack Pointer] [Flow: call]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	ora ($00.b,S),Y		; 13 00 ; OR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b)		; 12 00 ; OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora ($19.b,X)		; 01 19 ; Logical OR ($19.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $1A.b,S		; 03 1A ; OR accumulator with stack relative $1A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $19.b,S		; 03 19 ; OR accumulator with stack relative $19.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $32.b		; 26 32 ; Rotate left $32.b [Reads: Direct Page] [Flags: NCZ]
	mvp $0F,$74		; 44 74 0F ; Move block positive $0F,$74 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $050607.l		; 0F 07 06 05 ; OR accumulator with memory (long) $050607.l [Writes: Accumulator] [Flags: NZ]
	asl $0C.b		; 06 0C ; Arithmetic shift left $0C.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	eor #$B0.b		; 49 B0 ; Exclusive OR #$B0.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($E0.b),Y		; 91 E0 ; Store accumulator ($E0.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda ($C0.b,X)		; A1 C0 ; Load accumulator ($C0.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($80.b,X)		; 41 80 ; Exclusive OR accumulator with memory ($80.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sta $04.b,S		; 83 04 ; Store accumulator (stack relative) $04.b,S [Reads: Stack Pointer, Accumulator]
	tsb $0A.b		; 04 0A ; Test and set bits $0A.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	trb $12.b		; 14 12 ; Test and reset bits $12.b [Reads: Accumulator] [Flags: Z]
	.db $90, $20		; 90 20 ; Branch if carry clear to $90, $20 [Flow: branch]
	.db $42, $84		; 42 84 ; Reserved instruction
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($07.b,S),Y		; 13 07 ; OR accumulator (stack relative indirect indexed) ($07.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $C000.w		; 0D 00 C0 ; Logical OR $C000.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $B0.b		; 00 B0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $A0.b		; 04 A0 ; Test and set bits $A0.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	jsr $2060.w		; 20 60 20 ; Jump to subroutine at $2060.w [Writes: Stack Pointer] [Flow: call]
	cpx #$18.b		; E0 18 ; Compare #$18.b with X register [Reads: X Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora [$FF.b]		; 07 FF ; OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $884440.l,X		; 3F 40 44 88 ; AND accumulator with memory (long,X) $884440.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $83.b,S		; 83 83 ; Store accumulator (stack relative) $83.b,S [Reads: Stack Pointer, Accumulator]
	ora ($13.b,X)		; 01 13 ; Logical OR ($13.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $1005.w		; 20 05 10 ; Jump to subroutine at $1005.w [Writes: Stack Pointer] [Flow: call]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $04.b		; 06 04 ; Arithmetic shift left $04.b [Reads: Direct Page] [Flags: NCZ]
	ora [$18.b]		; 07 18 ; OR accumulator with memory (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $FCFFE0.l,X		; 1F E0 FF FC ; Logical OR long $FCFFE0.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($83.b),Y		; 11 83 ; OR accumulator with memory ($83.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cpy #$1F.b		; C0 1F ; Compare #$1F.b with Y register [Reads: Y Index] [Flags: NCZ]
	sta $BF3F49.l,X		; 9F 49 3F BF ; Store accumulator (long,X) $BF3F49.l,X [Reads: Accumulator, X Index]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $402460.l,X		; 3F 60 24 40 ; AND accumulator with memory (long,X) $402460.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($0C.b,X)		; 01 0C ; Logical OR ($0C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $0723.w		; 0C 23 07 ; Test and set bits $0723.w [Reads: Accumulator] [Flags: Z]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $23.b,S		; 03 23 ; OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $08		; 10 08 ; Branch if plus to $10, $08 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($63.b,X)		; 01 63 ; Logical OR ($63.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	adc $47EFE0.l		; 6F E0 EF 47 ; Add with carry (long) $47EFE0.l [Writes: Accumulator] [Flags: NCVZ]
	cpy #$DF.b		; C0 DF ; Compare #$DF.b with Y register [Reads: Y Index] [Flags: NCZ]
	eor $80.b,S		; 43 80 ; Exclusive OR accumulator with stack relative $80.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldx $1001.w,Y		; BE 01 10 ; Load X register $1001.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	.db $10, $22		; 10 22 ; Branch if plus to $10, $22 [Flow: branch]
	jsr $2104.w		; 20 04 21 ; Jump to subroutine at $2104.w [Writes: Stack Pointer] [Flow: call]
	eor $4F.b,S		; 43 4F ; Exclusive OR accumulator with stack relative $4F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $0100.w		; 2D 00 01 ; Logical AND $0100.w with accumulator [Writes: Accumulator] [Flags: NZ]
	dec $26F0.w,X		; DE F0 26 ; Decrement memory $26F0.w,X [Reads: X Index] [Flags: NZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $00.b,X		; 74 00 ; Store zero to $00.b,X [Reads: X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	ora $53.b,S		; 03 53 ; OR accumulator with stack relative $53.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $0F43.w		; 0C 43 0F ; Test and set bits $0F43.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $23.b,S		; 03 23 ; OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($21.b,X)		; 21 21 ; Logical AND ($21.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp $E3.b,S		; C3 E3 ; Compare accumulator (stack relative) $E3.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	cop $C2.b		; 02 C2 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $86.b		; [PATTERN: Memory clearing operation] 06 86 ; Arithmetic shift left $86.b [Reads: Direct Page] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	stz $64.b		; 64 64 ; Store zero to $64.b
	stz $6C9C.w		; 9C 9C 6C ; Store zero to $6C9C.w
	jmp ($1010.w)		; 6C 10 10 ; Jump indirect to ($1010.w) [Flow: jump]
	and ($41.b,X)		; 21 41 ; Logical AND ($41.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp [$9A.b]		; C7 9A ; Compare accumulator (long) [$9A.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	.db $62, $82, $00		; 62 82 00 ; Push effective relative address $62, $82, $00 [Writes: Stack Pointer]
	ora $1C.b,S		; 03 1C ; OR accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $2303.w,X		; 3C 03 23 ; Test bits $2303.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $91.b		; 00 91 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $4F.b		; 00 4F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and [$E0.b]		; 27 E0 ; AND accumulator with memory (long) [$E0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $C0C3FC.l		; 2F FC C3 C0 ; AND accumulator with memory (long) $C0C3FC.l [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $30, $1F		; 30 1F ; Branch if minus to $30, $1F [Flow: branch]
	ora $00EF00.l,X		; 1F 00 EF 00 ; Logical OR long $00EF00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $10EF80.l		; 0F 80 EF 10 ; OR accumulator with memory (long) $10EF80.l [Writes: Accumulator] [Flags: NZ]
	cmp ($10.b,S),Y		; D3 10 ; Compare accumulator (stack relative indirect indexed) ($10.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	cmp ($22.b),Y		; D1 22 ; Compare accumulator ($22.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	ldy #$26.b		; A0 26 ; Load #$26.b into Y register [Writes: Y Index] [Flags: NZ]
	lda $4C.b,S		; A3 4C ; Load accumulator (stack relative) $4C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $F8.b		; 45 F8 ; Exclusive OR $F8.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	bit $636E.w,X		; 3C 6E 63 ; Test bits $636E.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	cmp $C4.b,S		; C3 C4 ; Compare accumulator (stack relative) $C4.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	stx $878A.w		; 8E 8A 87 ; Store X register to $878A.w [Reads: X Index]
	sta $43.b		; 85 43 ; Store accumulator to $43.b [Reads: Accumulator]
	rep #$41		; C2 41 ; Reset processor status bits #$41 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	cmp ($30.b,X)		; C1 30 ; Compare accumulator ($30.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	.db $F0, $0C		; F0 0C ; Branch if equal to $F0, $0C [Flow: branch]
	jsr ($7F03.w,X)		; FC 03 7F ; Jump to subroutine indirect indexed ($7F03.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $9F.b		; 00 9F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $BD.b		; 84 BD ; Store Y register to $BD.b [Reads: Y Index]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $E080.w		; 2E 80 E0 ; Rotate left $E080.w [Flags: NCZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	eor $2945.w,X		; 5D 45 29 ; Exclusive OR accumulator with memory $2945.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($92.b,X)		; 21 92 ; Logical AND ($92.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta ($CE.b,S),Y		; 93 CE ; Store accumulator (stack relative indirect indexed) ($CE.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	eor $70AFEC.l		; 4F EC AF 70 ; Exclusive OR accumulator with memory (long) $70AFEC.l [Writes: Accumulator] [Flags: NZ]
	eor $00FEC0.l,X		; 5F C0 FE 00 ; Exclusive OR accumulator with memory (long,X) $00FEC0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $0818.w,Y		; F9 18 08 ; Subtract with carry $0818.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	and ($07.b,X)		; 21 07 ; Logical AND ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $FF03.w,X		; 1E 03 FF ; Arithmetic shift left $FF03.w,X [Reads: X Index] [Flags: NCZ]
	trb $37FF.w		; 1C FF 37 ; Test and reset bits $37FF.w [Reads: Accumulator] [Flags: Z]
	sed		; F8 ; Set decimal flag [Flags: D]
	lsr $9CF1.w		; 4E F1 9C ; Logical shift right $9CF1.w [Flags: NCZ]
	sbc $38.b,S		; E3 38 ; Subtract stack-relative $38.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	cmp [$60.b]		; C7 60 ; Compare accumulator (long) [$60.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sta $03FF18.l,X		; 9F 18 FF 03 ; Store accumulator (long,X) $03FF18.l,X [Reads: Accumulator, X Index]
	ora $237F3F.l,X		; 1F 3F 7F 23 ; Logical OR long $237F3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $FFB812.l,X		; FF 12 B8 FF ; Subtract with carry (long,X) $FFB812.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	trb $02FF.w		; 1C FF 02 ; Test and reset bits $02FF.w [Reads: Accumulator] [Flags: Z]
	sbc $10EF17.l,X		; FF 17 EF 10 ; Subtract with carry (long,X) $10EF17.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F08778.l		; EF 78 87 F0 ; Subtract with carry (long) $F08778.l [Writes: Accumulator] [Flags: NCVZ]
	ora $F81FE0.l		; 0F E0 1F F8 ; OR accumulator with memory (long) $F81FE0.l [Writes: Accumulator] [Flags: NZ]
	jsr ($24FE.w,X)		; FC FE 24 ; Jump to subroutine indirect indexed ($24FE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $FF0043.l,X		; FF 43 00 FF ; Subtract with carry (long,X) $FF0043.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $AA.b		; 00 AA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $FF.b		; 24 FF ; Test bits $FF.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora $1F.b		; 05 1F ; Logical OR $1F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $1FFF3F.l,X		; FF 3F FF 1F ; Subtract with carry (long,X) $1FFF3F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $030022.l,X		; FF 22 00 03 ; Subtract with carry (long,X) $030022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $FC		; F0 FC ; Branch if equal to $F0, $FC [Flow: branch]
	inc $44FF.w,X		; FE FF 44 ; Increment memory $44FF.w,X [Reads: X Index] [Flags: NZ]
	sbc $AF0000.l,X		; FF 00 00 AF ; Subtract with carry (long,X) $AF0000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $F00EFF.l		; 22 FF 0E F0 ; Jump to subroutine long $F00EFF.l [Writes: Stack Pointer] [Flow: call]
	sbc $9DF3EC.l,X		; FF EC F3 9D ; Subtract with carry (long,X) $9DF3EC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $1A.b,S		; E3 1A ; Subtract stack-relative $1A.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	sbc [$00.b]		; E7 00 ; Subtract with carry (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $FF7F1F.l		; 0F 1F 7F FF ; OR accumulator with memory (long) $FF7F1F.l [Writes: Accumulator] [Flags: NZ]
	mvp $00,$FF		; 44 FF 00 ; Move block positive $00,$FF [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	brk $AA.b		; 00 AA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $FF.b		; 24 FF ; Test bits $FF.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $3F00FF.l		; 22 FF 00 3F ; Jump to subroutine long $3F00FF.l [Writes: Stack Pointer] [Flow: call]
	sta $E8.b,S		; 83 E8 ; Store accumulator (stack relative) $E8.b,S [Reads: Stack Pointer, Accumulator]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $83		; F0 83 ; Branch if equal to $F0, $83 [Flow: branch]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	ora $01FE.w		; 0D FE 01 ; Logical OR $01FE.w with accumulator [Writes: Accumulator] [Flags: NZ]
	inc $7C83.w,X		; FE 83 7C ; Increment memory $7C83.w,X [Reads: X Index] [Flags: NZ]
	eor $C7.b,S		; 43 C7 ; Exclusive OR accumulator with stack relative $C7.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	ora $CF.b		; 05 CF ; Logical OR $CF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $30, $DE		; 30 DE ; Branch if minus to $30, $DE [Flow: branch]
	and ($DF.b,X)		; 21 DF ; Logical AND ($DF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsr $FF27.w		; 20 27 FF ; Jump to subroutine at $FF27.w [Writes: Stack Pointer] [Flow: call]
	ora ($C1.b,X)		; 01 C1 ; Logical OR ($C1.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $738C43.l,X		; 3F 43 8C 73 ; AND accumulator with memory (long,X) $738C43.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$98.b		; 09 98 ; Logical OR #$98.b with accumulator [Writes: Accumulator] [Flags: NZ]
	adc [$38.b]		; 67 38 ; Add with carry (long) [$38.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp [$71.b]		; C7 71 ; Compare accumulator (long) [$71.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	stx $0CF3.w		; 8E F3 0C ; Store X register to $0CF3.w [Reads: X Index]
	sbc [$08.b],Y		; F7 08 ; Subtract with carry (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and [$FF.b]		; 27 FF ; AND accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$E7.b		; 09 E7 ; Logical OR #$E7.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $10FF0C.l,X		; FF 0C FF 10 ; Subtract with carry (long,X) $10FF0C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $9FF906.l,X		; FF 06 F9 9F ; Subtract with carry (long,X) $9FF906.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	eor $FF.b		; 45 FF ; Exclusive OR $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $27.b		; 00 27 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FF040F.l,X		; FF 0F 04 FF ; Subtract with carry (long,X) $FF040F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($FD.b)		; 72 FD ; Add with carry (indirect) ($FD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inc $1FF9.w,X		; FE F9 1F ; Increment memory $1FF9.w,X [Reads: X Index] [Flags: NZ]
	jsr ($DE23.w,X)		; FC 23 DE ; Jump to subroutine indirect indexed ($DE23.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ldy #$5F.b		; A0 5F ; Load #$5F.b into Y register [Writes: Y Index] [Flags: NZ]
	sbc ($0D.b)		; F2 0D ; Subtract with carry (indirect) ($0D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$08.b],Y		; F7 08 ; Subtract with carry (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and [$FF.b]		; 27 FF ; AND accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $78FF.w,X		; 1D FF 78 ; OR accumulator with memory $78FF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $EF39DE.l,X		; FF DE 39 EF ; Subtract with carry (long,X) $EF39DE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $08FF.w,Y		; 19 FF 08 ; OR accumulator with memory $08FF.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc [$08.b],Y		; F7 08 ; Subtract with carry (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $77.b,S		; 43 77 ; Exclusive OR accumulator with stack relative $77.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	sbc $FFFE0E.l,X		; FF 0E FE FF ; Subtract with carry (long,X) $FFFE0E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $FF0EFF.l,X		; BF FF 0E FF ; Load long $FF0EFF.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $CB7E.w		; 8D 7E CB ; Store accumulator to $CB7E.w [Reads: Accumulator]
	bit $18F7.w,X		; 3C F7 18 ; Test bits $18F7.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	cpx #$F0.b		; E0 F0 ; Compare #$F0.b with X register [Reads: X Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	rol $FF.b		; 26 FF ; Rotate left $FF.b [Reads: Direct Page] [Flags: NCZ]
	ora $E9FFFB.l		; 0F FB FF E9 ; OR accumulator with memory (long) $E9FFFB.l [Writes: Accumulator] [Flags: NZ]
	sbc $28FF98.l,X		; FF 98 FF 28 ; Subtract with carry (long,X) $28FF98.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$99.b],Y		; F7 99 ; Subtract with carry (long indexed) [$99.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc [$3D.b]		; 67 3D ; Add with carry (long) [$3D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp $7E.b,S		; C3 7E ; Compare accumulator (stack relative) $7E.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	sta ($3E.b,X)		; 81 3E ; Store accumulator ($3E.b,X) [Reads: Direct Page, Accumulator, X Index]
	adc $0EFF29.l,X		; 7F 29 FF 0E ; Add long $0EFF29.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F5.b,X		; F5 F5 ; Subtract $F5.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $F0		; 70 F0 ; Branch if overflow set to $70, $F0 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	stz $D2FC.w		; 9C FC D2 ; Store zero to $D2FC.w
	rol $01FE.w		; 2E FE 01 ; Rotate left $01FE.w [Flags: NCZ]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	nop		; EA ; No operation
	bit $FF.b		; 24 FF ; Test bits $FF.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	eor $28FF00.l		; 4F 00 FF 28 ; Exclusive OR accumulator with memory (long) $28FF00.l [Writes: Accumulator] [Flags: NZ]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda ($04.b),Y		; B1 04 ; Load accumulator ($04.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc $230027.l,X		; FF 27 00 23 ; Subtract with carry (long,X) $230027.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $555501.l,X		; FF 01 55 55 ; Subtract with carry (long,X) $555501.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	bit $FF.b		; 24 FF ; Test bits $FF.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sbc $37002F.l,X		; FF 2F 00 37 ; Subtract with carry (long,X) $37002F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $070027.l,X		; FF 27 00 07 ; Subtract with carry (long,X) $070027.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	ora $281857.l		; 0F 57 18 28 ; OR accumulator with memory (long) $281857.l [Writes: Accumulator] [Flags: NZ]
	.db $30, $43		; 30 43 ; Branch if minus to $30, $43 [Flow: branch]
	.db $50, $60		; 50 60 ; Branch if overflow clear to $50, $60 [Flow: branch]
	eor $A0.b,S		; 43 A0 ; Exclusive OR accumulator with stack relative $A0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpy #$0D.b		; C0 0D ; Compare #$0D.b with Y register [Reads: Y Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	cpy #$80.b		; C0 80 ; Compare #$80.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $E4.b		; 00 E4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$16.b		; E0 16 ; Compare #$16.b with X register [Reads: X Index] [Flags: NCZ]
	.db $F0, $EA		; F0 EA ; Branch if equal to $F0, $EA [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	eor $14.b,S		; 43 14 ; Exclusive OR accumulator with stack relative $14.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $0A01.w		; 0C 01 0A ; Test and set bits $0A01.w [Reads: Accumulator] [Flags: Z]
	asl $43.b		; 06 43 ; Arithmetic shift left $43.b [Reads: Direct Page] [Flags: NCZ]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $070F1F.l		; 0F 1F 0F 07 ; OR accumulator with memory (long) $070F1F.l [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C4.b		; 00 C4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	jsr ($C6C5.w,X)		; FC C5 C6 ; Jump to subroutine indirect indexed ($C6C5.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	eor $05.b		; 45 05 ; Exclusive OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tsb $0022.w		; 0C 22 00 ; Test and set bits $0022.w [Reads: Accumulator] [Flags: Z]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $F000F8.l		; 22 F8 00 F0 ; Jump to subroutine long $F000F8.l [Writes: Stack Pointer] [Flow: call]
	and $FF.b		; 25 FF ; Logical AND $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$FE.b		; 09 FE ; Logical OR #$FE.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc $F1F0.w,X		; FE F0 F1 ; Increment memory $F1F0.w,X [Reads: X Index] [Flags: NZ]
	cpy #$CF.b		; C0 CF ; Compare #$CF.b with Y register [Reads: Y Index] [Flags: NCZ]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $010400.l		; 22 00 04 01 ; Jump to subroutine long $010400.l [Writes: Stack Pointer] [Flow: call]
	asl $C030.w		; 0E 30 C0 ; Arithmetic shift left $C030.w [Flags: NCZ]
	brk $25.b		; 00 25 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $460022.l,X		; FF 22 00 46 ; Subtract with carry (long,X) $460022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $002200.l,X		; FF 00 22 00 ; Subtract with carry (long,X) $002200.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $E73EE3.l		; 0F E3 3E E7 ; OR accumulator with memory (long) $E73EE3.l [Writes: Accumulator] [Flags: NZ]
	bit $99FF.w,X		; 3C FF 99 ; Test bits $99FF.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	jmp ($3EC3.w,X)		; 7C C3 3E ; Jump indirect indexed to ($3EC3.w,X) [Reads: X Index] [Flow: jump]
	sbc $1F.b,S		; E3 1F ; Subtract stack-relative $1F.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	sbc $FC07.w,Y		; F9 07 FC ; Subtract with carry $FC07.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $FE.b,S		; 03 FE ; OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and [$FF.b]		; 27 FF ; AND accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $877EC3.l		; 0F C3 7E 87 ; OR accumulator with memory (long) $877EC3.l [Writes: Accumulator] [Flags: NZ]
	jsr ($F90F.w,X)		; FC 0F F9 ; Jump to subroutine indirect indexed ($F90F.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	dec $DE33.w,X		; DE 33 DE ; Decrement memory $DE33.w,X [Reads: X Index] [Flags: NZ]
	sbc [$3E.b],Y		; F7 3E ; Subtract with carry (long indexed) [$3E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FF.b,S		; E3 FF ; Subtract stack-relative $FF.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	cmp #$F7.b		; C9 F7 ; Compare #$F7.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	trb $FF27.w		; 1C 27 FF ; Test and reset bits $FF27.w [Reads: Accumulator] [Flags: Z]
	eor $00.b		; 45 00 ; Exclusive OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $FF1809.l,X		; FF 09 18 FF ; Subtract with carry (long,X) $FF1809.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $5EFF.w,X		; 3C FF 5E ; Test bits $5EFF.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	sbc $01FF93.l,X		; FF 93 FF 01 ; Subtract with carry (long,X) $01FF93.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $030022.l,X		; FF 22 00 03 ; Subtract with carry (long,X) $030022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $FF7E.w,X		; 3C 7E FF ; Test bits $FF7E.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	sbc $1C0700.l,X		; FF 00 07 1C ; Subtract with carry (long,X) $1C0700.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $E7FF7E.l,X		; FF 7E FF E7 ; Subtract with carry (long,X) $E7FF7E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $23FF03.l,X		; FF 03 FF 23 ; Subtract with carry (long,X) $23FF03.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $FF7E.w		; 1C 7E FF ; Test and reset bits $FF7E.w [Reads: Accumulator] [Flags: Z]
	sbc $43007F.l,X		; FF 7F 00 43 ; Subtract with carry (long,X) $43007F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $FF30.w,X		; 3C 30 FF ; Test bits $FF30.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $61FC63.l,X		; FF 63 FC 61 ; Subtract with carry (long,X) $61FC63.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $FE79.w,X		; FE 79 FE ; Increment memory $FE79.w,X [Reads: X Index] [Flags: NZ]
	adc $FC.b,S		; 63 FC ; Add with carry (stack relative) $FC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sta $07FF26.l,X		; 9F 26 FF 07 ; Store accumulator (long,X) $07FF26.l,X [Reads: Accumulator, X Index]
	inc $FF11.w		; EE 11 FF ; Increment $FF11.w [Flags: NZ]
	brk $B1.b		; 00 B1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $08F7.w		; 4E F7 08 ; Logical shift right $08F7.w [Flags: NCZ]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $CE81.w,X		; 7E 81 CE ; Rotate right $CE81.w,X [Reads: X Index] [Flags: NCZ]
	and ($FF.b),Y		; 31 FF ; AND accumulator with memory ($FF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($6E.b),Y		; 11 6E ; OR accumulator with memory ($6E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $956E6F.l		; 6F 6F 6E 95 ; Add with carry (long) $956E6F.l [Writes: Accumulator] [Flags: NCVZ]
	lda ($0A.b,S),Y		; B3 0A ; Load accumulator (stack relative indirect indexed) ($0A.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $FC0B.w,X		; FD 0B FC ; Subtract with carry $FC0B.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpy $04FB.w		; CC FB 04 ; Compare $04FB.w with Y register [Reads: Y Index] [Flags: NCZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	sbc $FF0A00.l,X		; FF 00 0A FF ; Subtract with carry (long,X) $FF0A00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($00CC.w,X)		; FC CC 00 ; Jump to subroutine indirect indexed ($00CC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora ($7F.b,X)		; 01 7F ; Logical OR ($7F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $EFF02F.l,X		; FF 2F F0 EF ; Subtract with carry (long,X) $EFF02F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $49		; 10 49 ; Branch if plus to $10, $49 [Flow: branch]
	sbc $F00600.l,X		; FF 00 06 F0 ; Subtract with carry (long,X) $F00600.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $00F0F0.l		; 0F F0 F0 00 ; OR accumulator with memory (long) $00F0F0.l [Writes: Accumulator] [Flags: NZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $C0.b,S		; 03 C0 ; OR accumulator with stack relative $C0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $22FF00.l,X		; 3F 00 FF 22 ; AND accumulator with memory (long,X) $22FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $0AFF23.l,X		; 3F 23 FF 0A ; AND accumulator with memory (long,X) $0AFF23.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsr $CCE0.w		; 20 E0 CC ; Jump to subroutine at $CCE0.w [Writes: Stack Pointer] [Flow: call]
	bit $0E32.w,X		; 3C 32 0E ; Test bits $0E32.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	ora $0203.w		; 0D 03 02 ; Logical OR $0203.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cop $1F.b		; 02 1F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $EA.b		; 00 EA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
.INDEX 8
	sep #$1D		; E2 1D
	sbc $1D1DE2.l,X		; FF E2 1D 1D ; Subtract with carry (long,X) $1D1DE2.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $221D00.l,X		; FF 00 1D 22 ; Subtract with carry (long,X) $221D00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy #$C0.b		; A0 C0 ; Load #$C0.b into Y register [Writes: Y Index] [Flags: NZ]
	ora ($50.b,S),Y		; 13 50 ; OR accumulator (stack relative indirect indexed) ($50.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	.db $30, $68		; 30 68 ; Branch if minus to $30, $68 [Flow: branch]
	.db $30, $77		; 30 77 ; Branch if minus to $30, $77 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	ora $000707.l		; 0F 07 07 00 ; OR accumulator with memory (long) $000707.l [Writes: Accumulator] [Flags: NZ]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: NCZ]
	cpx #$F0.b		; E0 F0 ; Compare #$F0.b with X register [Reads: X Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	eor $05.b,S		; 43 05 ; Exclusive OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $09.b,S		; 03 09 ; OR accumulator with stack relative $09.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	asl $25.b		; 06 25 ; Arithmetic shift left $25.b [Reads: Direct Page] [Flags: NCZ]
	trb $38DE.w		; 1C DE 38 ; Test and reset bits $38DE.w [Reads: Accumulator] [Flags: Z]
	bit $D8E0.w		; 2C E0 D8 ; Test bits $D8E0.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	cpy #$23.b		; C0 23 ; Compare #$23.b with Y register [Reads: Y Index] [Flags: NCZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$1F.b]		; 07 1F ; OR accumulator with memory (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $0A43FF.l,X		; 3F FF 43 0A ; AND accumulator with memory (long,X) $0A43FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $1A0B.w		; 0C 0B 1A ; Test and set bits $1A0B.w [Reads: Accumulator] [Flags: Z]
	tsb $0C6A.w		; 0C 6A 0C ; Test and set bits $0C6A.w [Reads: Accumulator] [Flags: Z]
	trb $E418.w		; 1C 18 E4 ; Test and reset bits $E418.w [Reads: Accumulator] [Flags: Z]
	sed		; F8 ; Set decimal flag [Flags: D]
	clc		; 18 ; Clear carry flag [Flags: C]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: NCZ]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	cpx #$22.b		; E0 22 ; Compare #$22.b with X register [Reads: X Index] [Flags: NCZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($F8FC.w,X)		; FC FC F8 ; Jump to subroutine indirect indexed ($F8FC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	cpx #$E7.b		; E0 E7 ; Compare #$E7.b with X register [Reads: X Index] [Flags: NCZ]
	cpy #$DF.b		; C0 DF ; Compare #$DF.b with Y register [Reads: Y Index] [Flags: NCZ]
	eor $80.b,S		; 43 80 ; Exclusive OR accumulator with stack relative $80.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $7F0043.l,X		; BF 43 00 7F ; Load long $7F0043.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $18.b		; 04 18 ; Test and set bits $18.b [Reads: Accumulator] [Flags: Z]
	jsr $4040.w		; 20 40 40 ; Jump to subroutine at $4040.w [Writes: Stack Pointer] [Flow: call]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	and [$00.b],Y		; 37 00 ; AND accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $F77EC7.l		; 0F C7 7E F7 ; OR accumulator with memory (long) $F77EC7.l [Writes: Accumulator] [Flags: NZ]
	bit $99FF.w,X		; 3C FF 99 ; Test bits $99FF.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	ror $3CC3.w,X		; 7E C3 3C ; Rotate right $3CC3.w,X [Reads: X Index] [Flags: NCZ]
	sbc [$3E.b]		; E7 3E ; Subtract with carry (long) [$3E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $7C.b,S		; E3 7C ; Subtract stack-relative $7C.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	cmp $279FF1.l		; CF F1 9F 27 ; Compare accumulator (long) $279FF1.l [Reads: Accumulator] [Flags: NCZ]
	sbc $3EC10F.l,X		; FF 0F C1 3E ; Subtract with carry (long,X) $3EC10F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$7F.b		; E0 7F ; Compare #$7F.b with X register [Reads: X Index] [Flags: NCZ]
	cpx $3F.b		; E4 3F ; Compare $3F.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	jsr ($7E9F.w,X)		; FC 9F 7E ; Jump to subroutine indirect indexed ($7E9F.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cmp [$7F.b]		; C7 7F ; Compare accumulator (long) [$7F.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp $FF.b,S		; C3 FF ; Compare accumulator (stack relative) $FF.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	sta $3CF7.w,Y		; 99 F7 3C ; Store accumulator to $3CF7.w,Y [Reads: Y Index, Accumulator]
	and [$FF.b]		; 27 FF ; AND accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$38.b]		; 07 38 ; OR accumulator with memory (long) [$38.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp [$78.b]		; C7 78 ; Compare accumulator (long) [$78.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sta [$FA.b]		; 87 FA ; Store accumulator (long) [$FA.b] [Reads: Direct Page, Accumulator]
	ora $FE.b		; 05 FE ; Logical OR $FE.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($47.b,X)		; 01 47 ; Logical OR ($47.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $FF2600.l,X		; FF 00 26 FF ; Subtract with carry (long,X) $FF2600.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $F48F70.l,X		; DF 70 8F F4 ; Compare accumulator (long,X) $F48F70.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	inc $4701.w,X		; FE 01 47 ; Increment memory $4701.w,X [Reads: X Index] [Flags: NZ]
	sbc $FF2600.l,X		; FF 00 26 FF ; Subtract with carry (long,X) $FF2600.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $70FE61.l,X		; FF 61 FE 70 ; Subtract with carry (long,X) $70FE61.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $2701.w		; 0D 01 27 ; Logical OR $2701.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $807F09.l,X		; FF 09 7F 80 ; Subtract with carry (long,X) $807F09.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $C03F00.l,X		; FF 00 3F C0 ; Subtract with carry (long,X) $C03F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $40BFF0.l		; 0F F0 BF 40 ; OR accumulator with memory (long) $40BFF0.l [Writes: Accumulator] [Flags: NZ]
	eor $3F.b,S		; 43 3F ; Exclusive OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpy #$01.b		; C0 01 ; Compare #$01.b with Y register [Reads: Y Index] [Flags: NCZ]
	sbc $FE2200.l,X		; FF 00 22 FE ; Subtract with carry (long,X) $FE2200.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $FC.b,X		; 15 FC ; OR accumulator with memory $FC.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	inc $E0FE.w,X		; FE FE E0 ; Increment memory $E0FE.w,X [Reads: X Index] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora [$8F.b]		; 07 8F ; OR accumulator with memory (long) [$8F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $70, $F0		; 70 F0 ; Branch if overflow set to $70, $F0 [Flow: branch]
	ora $C003FC.l		; 0F FC 03 C0 ; OR accumulator with memory (long) $C003FC.l [Writes: Accumulator] [Flags: NZ]
	and $C00FF0.l,X		; 3F F0 0F C0 ; AND accumulator with memory (long,X) $C00FF0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $7F38C7.l,X		; 3F C7 38 7F ; AND accumulator with memory (long,X) $7F38C7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $D6.b,S		; 83 D6 ; Store accumulator (stack relative) $D6.b,S [Reads: Stack Pointer, Accumulator]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $0843C0.l,X		; 3F C0 43 08 ; AND accumulator with memory (long,X) $0843C0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc [$07.b],Y		; F7 07 ; Subtract with carry (long indexed) [$07.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sta [$27.b]		; 87 27 ; Store accumulator (long) [$27.b] [Reads: Direct Page, Accumulator]
	sbc $C13E01.l,X		; FF 01 3E C1 ; Subtract with carry (long,X) $C13E01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $02.b,S		; 43 02 ; Exclusive OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $3F08.w,X		; FD 08 3F ; Subtract with carry $3F08.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$20.b		; C0 20 ; Compare #$20.b with Y register [Reads: Y Index] [Flags: NCZ]
	cmp $201FE0.l,X		; DF E0 1F 20 ; Compare accumulator (long,X) $201FE0.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	cmp $FF2800.l,X		; DF 00 28 FF ; Compare accumulator (long,X) $FF2800.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	trb $00.b		; 14 00 ; Test and reset bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $64.b,S		; 03 64 ; OR accumulator with stack relative $64.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$CB.b]		; 07 CB ; OR accumulator with memory (long) [$CB.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $3834.w		; 0C 34 38 ; Test and set bits $3834.w [Reads: Accumulator] [Flags: Z]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $F0, $30		; F0 30 ; Branch if equal to $F0, $30 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: NCZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($F0F8.w,X)		; FC F8 F0 ; Jump to subroutine indirect indexed ($F0F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpy #$22.b		; C0 22 ; Compare #$22.b with Y register [Reads: Y Index] [Flags: NCZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($03FF.w,X)		; FC FF 03 ; Jump to subroutine indirect indexed ($03FF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr ($32FC.w,X)		; FC FC 32 ; Jump to subroutine indirect indexed ($32FC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $18.b		; 26 18 ; Rotate left $18.b [Reads: Direct Page] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $3C.b		; 24 3C ; Test bits $3C.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	ror $A5.b		; 66 A5 ; Rotate right $A5.b [Reads: Direct Page] [Flags: NCZ]
	cmp $AA.b,S		; C3 AA ; Compare accumulator (stack relative) $AA.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	dec $B4.b		; C6 B4 ; Decrement $B4.b [Reads: Direct Page] [Flags: NZ]
	cpy $7848.w		; CC 48 78 ; Compare $7848.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	sbc [$C3.b]		; E7 C3 ; Subtract with carry (long) [$C3.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta ($00.b,X)		; 81 00 ; Store accumulator ($00.b,X) [Reads: Direct Page, Accumulator, X Index]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta [$CF.b]		; 87 CF ; Store accumulator (long) [$CF.b] [Reads: Direct Page, Accumulator]
	bit $4200.w,X		; 3C 00 42 ; Test bits $4200.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	bit $7EBD.w,X		; 3C BD 7E ; Test bits $7EBD.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	lda $A566.w		; AD 66 A5 ; Load $A566.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ror $5D.b		; 66 5D ; Rotate right $5D.b [Reads: Direct Page] [Flags: NCZ]
	rol $3C42.w,X		; 3E 42 3C ; Rotate left $3C42.w,X [Reads: X Index] [Flags: NCZ]
	rol $0023.w,X		; 3E 23 00 ; Rotate left $0023.w,X [Reads: X Index] [Flags: NCZ]
	ora ($18.b,X)		; 01 18 ; Logical OR ($18.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lsr $00FF.w		; 4E FF 00 ; Logical shift right $00FF.w [Flags: NCZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $43BF80.l,X		; 7F 80 BF 43 ; Add long $43BF80.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$DF.b		; C0 DF ; Compare #$DF.b with Y register [Reads: Y Index] [Flags: NCZ]
	eor $E0.b,S		; 43 E0 ; Exclusive OR accumulator with stack relative $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $DFC043.l		; EF 43 C0 DF ; Subtract with carry (long) $DFC043.l [Writes: Accumulator] [Flags: NCVZ]
	ora [$80.b]		; 07 80 ; OR accumulator with memory (long) [$80.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	jsr $1020.w		; 20 20 10 ; Jump to subroutine at $1020.w [Writes: Stack Pointer] [Flow: call]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	jsr $0037.w		; 20 37 00 ; Jump to subroutine at $0037.w [Writes: Stack Pointer] [Flow: call]
	ora ($AA.b,X)		; 01 AA ; Logical OR ($AA.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $1C.b,S		; 03 1C ; OR accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	trb $7E7E.w		; 1C 7E 7E ; Test and reset bits $7E7E.w [Reads: Accumulator] [Flags: Z]
	sta $FC.b,S		; 83 FC ; Store accumulator (stack relative) $FC.b,S [Reads: Stack Pointer, Accumulator]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $26.b,X		; 55 26 ; Exclusive OR accumulator with memory $26.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $AAAA01.l,X		; FF 01 AA AA ; Subtract with carry (long,X) $AAAA01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $18.b		; 05 18 ; Logical OR $18.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $5E3C.w,X		; 3C 3C 5E ; Test bits $5E3C.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	ror $E483.w,X		; 7E 83 E4 ; Rotate right $E483.w,X [Reads: X Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $26.b,X		; 55 26 ; Exclusive OR accumulator with memory $26.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $FF6043.l,X		; FF 43 60 FF ; Subtract with carry (long,X) $FF6043.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora #$71.b		; 09 71 ; Logical OR #$71.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc $FF60.w,X		; FE 60 FF ; Increment memory $FF60.w,X [Reads: X Index] [Flags: NZ]
	adc [$F8.b]		; 67 F8 ; Add with carry (long) [$F8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	sbc [$DF.b]		; E7 DF ; Subtract with carry (long) [$DF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and $43FF29.l,X		; 3F 29 FF 43 ; AND accumulator with memory (long,X) $43FF29.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $FD0A80.l,X		; 7F 80 0A FD ; Add long $FD0A80.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $EF.b,S		; 03 EF ; OR accumulator with stack relative $EF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $FEFF7F.l,X		; 1F 7F FF FE ; Logical OR long $FEFF7F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $00FFF0.l,X		; FF F0 FF 00 ; Subtract with carry (long,X) $00FFF0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	sbc $609F0B.l,X		; FF 0B 9F 60 ; Subtract with carry (long,X) $609F0B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	nop		; EA ; No operation
	sbc [$8E.b],Y		; F7 8E ; Subtract with carry (long indexed) [$8E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$9C.b],Y		; F7 9C ; Subtract with carry (long indexed) [$9C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$98.b]		; E7 98 ; Subtract with carry (long) [$98.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc [$FF.b]		; 67 FF ; Add with carry (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sty $B143.w		; 8C 43 B1 ; Store Y register to $B143.w [Reads: Y Index]
	dec $FF27.w,X		; DE 27 FF ; Decrement memory $FF27.w,X [Reads: X Index] [Flags: NZ]
	and [$00.b],Y		; 37 00 ; AND accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($DF.b,X)		; 01 DF ; Logical OR ($DF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsr $FF45.w		; 20 45 FF ; Jump to subroutine at $FF45.w [Writes: Stack Pointer] [Flow: call]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0045E0.l,X		; 1F E0 45 00 ; Logical OR long $0045E0.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $DBBB03.l,X		; FF 03 BB DB ; Subtract with carry (long,X) $DBBB03.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	tsb $10.b		; 04 10 ; Test and set bits $10.b [Reads: Accumulator] [Flags: Z]
	sbc $F306.w,Y		; F9 06 F3 ; Subtract with carry $F306.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $08F7.w		; 0C F7 08 ; Test and set bits $08F7.w [Reads: Accumulator] [Flags: Z]
	adc $FE0180.l,X		; 7F 80 01 FE ; Add long $FE0180.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	lda $6F96.w,Y		; B9 96 6F ; Load $6F96.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $830022.l		; 0F 22 00 83 ; OR accumulator with memory (long) $830022.l [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	inc $F901.w,X		; FE 01 F9 ; Increment memory $F901.w,X [Reads: X Index] [Flags: NZ]
	asl $43.b		; 06 43 ; Arithmetic shift left $43.b [Reads: Direct Page] [Flags: NCZ]
	sbc [$08.b],Y		; F7 08 ; Subtract with carry (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sbc $F80700.l,X		; FF 00 07 F8 ; Subtract with carry (long,X) $F80700.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ldx $C739.w,Y		; BE 39 C7 ; Load X register $C739.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	sbc $00076F.l		; EF 6F 07 00 ; Subtract with carry (long) $00076F.l [Writes: Accumulator] [Flags: NCVZ]
	eor $00.b		; 45 00 ; Exclusive OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $FC0301.l,X		; FF 01 03 FC ; Subtract with carry (long,X) $FC0301.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $74.b,S		; 83 74 ; Store accumulator (stack relative) $74.b,S [Reads: Stack Pointer, Accumulator]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $E11EC0.l,X		; 3F C0 1E E1 ; AND accumulator with memory (long,X) $E11EC0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $780900.l,X		; FF 00 09 78 ; Subtract with carry (long,X) $780900.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta [$0F.b]		; 87 0F ; Store accumulator (long) [$0F.b] [Reads: Direct Page, Accumulator]
	.db $F0, $06		; F0 06 ; Branch if equal to $F0, $06 [Flow: branch]
	sbc $03FC.w,Y		; F9 FC 03 ; Subtract with carry $03FC.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $00FF.w		; 0E FF 00 ; Arithmetic shift left $00FF.w [Flags: NCZ]
	jsr ($0F03.w,X)		; FC 03 0F ; Jump to subroutine indirect indexed ($0F03.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $F0, $3F		; F0 3F ; Branch if equal to $F0, $3F [Flow: branch]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: NCZ]
	ora $F0FF00.l		; 0F 00 FF F0 ; OR accumulator with memory (long) $F0FF00.l [Writes: Accumulator] [Flags: NZ]
	ora $0028FF.l		; 0F FF 28 00 ; OR accumulator with memory (long) $0028FF.l [Writes: Accumulator] [Flags: NZ]
	sta $B8.b,S		; 83 B8 ; Store accumulator (stack relative) $B8.b,S [Reads: Stack Pointer, Accumulator]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	cpy #$3F.b		; C0 3F ; Compare #$3F.b with Y register [Reads: Y Index] [Flags: NCZ]
	sta $3E.b,S		; 83 3E ; Store accumulator (stack relative) $3E.b,S [Reads: Stack Pointer, Accumulator]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	ora $FC.b,S		; 03 FC ; OR accumulator with stack relative $FC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $B0.b,S		; 83 B0 ; Store accumulator (stack relative) $B0.b,S [Reads: Stack Pointer, Accumulator]
	tsb $27.b		; 04 27 ; Test and set bits $27.b [Reads: Accumulator] [Flags: Z]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $FF		; F0 FF ; Branch if equal to $F0, $FF [Flow: branch]
	cpx #$FF.b		; E0 FF ; Compare #$FF.b with X register [Reads: X Index] [Flags: NCZ]
	cpy #$FF.b		; C0 FF ; Compare #$FF.b with Y register [Reads: Y Index] [Flags: NCZ]
	sta $D827F8.l,X		; 9F F8 27 D8 ; Store accumulator (long,X) $D827F8.l,X [Reads: Accumulator, X Index]
	eor $FF.b		; 45 FF ; Exclusive OR $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $08D822.l,X		; FF 22 D8 08 ; Subtract with carry (long,X) $08D822.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	inc $7E01.w,X		; FE 01 7E ; Increment memory $7E01.w,X [Reads: X Index] [Flags: NZ]
	sta ($FE.b,X)		; 81 FE ; Store accumulator ($FE.b,X) [Reads: Direct Page, Accumulator, X Index]
	and ($CF.b),Y		; 31 CF ; AND accumulator with memory ($CF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $47		; 30 47 ; Branch if minus to $30, $47 [Flow: branch]
	sbc $FB2300.l,X		; FF 00 23 FB ; Subtract with carry (long,X) $FB2300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $002630.l		; 22 30 26 00 ; Jump to subroutine long $002630.l [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $603F30.l,X		; 1F 30 3F 60 ; Logical OR long $603F30.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $FF28C0.l,X		; 7F C0 28 FF ; Add long $FF28C0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$FE.b		; 09 FE ; Logical OR #$FE.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc $FF00.w,X		; FE 00 FF ; Increment memory $FF00.w,X [Reads: X Index] [Flags: NZ]
	ror $FE81.w,X		; 7E 81 FE ; Rotate right $FE81.w,X [Reads: X Index] [Flags: NCZ]
	ora ($3E.b,X)		; 01 3E ; Logical OR ($3E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp ($24.b,X)		; C1 24 ; Compare accumulator ($24.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	sbc $06FD22.l,X		; FF 22 FD 06 ; Subtract with carry (long,X) $06FD22.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $7F781F.l,X		; 1F 1F 78 7F ; Logical OR long $7F781F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $80, $44		; 80 44 ; Branch always to $80, $44 [Flow: branch]
	sbc $040300.l,X		; FF 00 03 04 ; Subtract with carry (long,X) $040300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $27FD0A.l,X		; FF 0A FD 27 ; Subtract with carry (long,X) $27FD0A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $46F000.l,X		; FF 00 F0 46 ; Subtract with carry (long,X) $46F000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $100700.l,X		; FF 00 07 10 ; Subtract with carry (long,X) $100700.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $29F728.l,X		; FF 28 F7 29 ; Subtract with carry (long,X) $29F728.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $2F.b,X		; F6 2F ; Increment memory $2F.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	.db $F0, $26		; F0 26 ; Branch if equal to $F0, $26 [Flow: branch]
	sbc $83FE00.l,X		; FF 00 FE 83 ; Subtract with carry (long,X) $83FE00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp.w [$0100]		; DC 00 01 ; Jump long indirect [$0100] [Flow: jump]
	.db $30, $FF		; 30 FF ; Branch if minus to $30, $FF [Flow: branch]
	eor $24.b,S		; 43 24 ; Exclusive OR accumulator with stack relative $24.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ora $27.b		; 05 27 ; Logical OR $27.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc [$38.b]		; E7 38 ; Subtract with carry (long) [$38.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$18.b]		; E7 18 ; Subtract with carry (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $FBFB.w		; 0D FB FB ; Logical OR $FBFB.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc ($9E.b,X)		; E1 9E ; Subtract with carry ($9E.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($0C.b,S),Y		; F3 0C ; Subtract with carry (stack relative indirect indexed) ($0C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $FCE3E0.l,X		; 1F E0 E3 FC ; Logical OR long $FCE3E0.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $FF273F.l,X		; 3F 3F 27 FF ; AND accumulator with memory (long,X) $FF273F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cop $1E.b		; 02 1E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $BF0100.l		; 22 00 01 BF ; Jump to subroutine long $BF0100.l [Writes: Stack Pointer] [Flow: call]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	eor $FF.b		; 45 FF ; Exclusive OR $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$FF.b		; C0 FF ; Compare #$FF.b with Y register [Reads: Y Index] [Flags: NCZ]
	sta $46.b,S		; 83 46 ; Store accumulator (stack relative) $46.b,S [Reads: Stack Pointer, Accumulator]
	ora $02.b		; 05 02 ; Logical OR $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $70, $24		; 70 24 ; Branch if overflow set to $70, $24 [Flow: branch]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $233F.w,X		; 3E 3F 23 ; Rotate left $233F.w,X [Reads: X Index] [Flags: NCZ]
	sbc $3E21E0.l,X		; FF E0 21 3E ; Subtract with carry (long,X) $3E21E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $FC7F78.l,X		; 3F 78 7F FC ; AND accumulator with memory (long,X) $FC7F78.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $7ECFCF.l,X		; FF CF CF 7E ; Subtract with carry (long,X) $7ECFCF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $0000C0.l,X		; 7F C0 00 00 ; Add long $0000C0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$80.b		; C0 80 ; Compare #$80.b with Y register [Reads: Y Index] [Flags: NCZ]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	sbc $E0FF80.l,X		; FF 80 FF E0 ; Subtract with carry (long,X) $E0FF80.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $0EFF00.l,X		; FF 00 FF 0E ; Subtract with carry (long,X) $0EFF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $C0FF1C.l,X		; FF 1C FF C0 ; Subtract with carry (long,X) $C0FF1C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $27FF00.l,X		; FF 00 FF 27 ; Subtract with carry (long,X) $27FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	nop		; EA ; No operation
	jsr $10E0.w		; 20 E0 10 ; Jump to subroutine at $10E0.w [Writes: Stack Pointer] [Flow: call]
	.db $F0, $0C		; F0 0C ; Branch if equal to $F0, $0C [Flow: branch]
	jsr ($FE1E.w,X)		; FC 1E FE ; Jump to subroutine indirect indexed ($FE1E.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	adc $00FB84.l,X		; 7F 84 FB 00 ; Add long $00FB84.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$15.b]		; 07 15 ; OR accumulator with memory (long) [$15.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $1D030F.l,X		; 1F 0F 03 1D ; Logical OR long $1D030F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ror $FFFF.w,X		; 7E FF FF ; Rotate right $FFFF.w,X [Reads: X Index] [Flags: NCZ]
	sbc $B76809.l,X		; FF 09 68 B7 ; Subtract with carry (long,X) $B76809.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $37B2.w,X		; 7D B2 37 ; Add $37B2.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	and ($DF.b)		; 32 DF ; AND accumulator with memory (indirect) ($DF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc ($1F.b)		; F2 1F ; Subtract with carry (indirect) ($1F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	eor $2A.b		; 45 2A ; Exclusive OR $2A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $0F0027.l,X		; DF 27 00 0F ; Compare accumulator (long,X) $0F0027.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc [$FF.b],Y		; F7 FF ; Subtract with carry (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $BF.b		; 00 BF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$78.b		; C0 78 ; Compare #$78.b with Y register [Reads: Y Index] [Flags: NCZ]
	sbc $603FC7.l,X		; FF C7 3F 60 ; Subtract with carry (long,X) $603FC7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $60FF3F.l,X		; 9F 3F FF 60 ; Store accumulator (long,X) $60FF3F.l,X [Reads: Accumulator, X Index]
	sta $0F0027.l,X		; 9F 27 00 0F ; Store accumulator (long,X) $0F0027.l,X [Reads: Accumulator, X Index]
	jsr ($FE00.w,X)		; FC 00 FE ; Jump to subroutine indirect indexed ($FE00.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	stz $FC.b,X		; 74 FC ; Store zero to $FC.b,X [Reads: X Index]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	sta $7F8747.l		; 8F 47 87 7F ; Store accumulator (long) $7F8747.l [Reads: Accumulator]
	.db $80, $22		; 80 22 ; Branch always to $80, $22 [Flow: branch]
	sbc $030714.l,X		; FF 14 07 03 ; Subtract with carry (long,X) $030714.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $78		; 70 78 ; Branch if overflow set to $70, $78 [Flow: branch]
	adc $3F001F.l,X		; 7F 1F 00 3F ; Add long $3F001F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $081F17.l		; 0F 17 1F 08 ; OR accumulator with memory (long) $081F17.l [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	sbc $FF2200.l,X		; FF 00 22 FF ; Subtract with carry (long,X) $FF2200.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	trb $E0F0.w		; 1C F0 E0 ; Test and reset bits $E0F0.w [Reads: Accumulator] [Flags: Z]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $D20FD4.l,X		; FF D4 0F D2 ; Subtract with carry (long,X) $D20FD4.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $0CD4.w		; 0E D4 0C ; Arithmetic shift left $0CD4.w [Flags: NCZ]
	cmp $D308.w,Y		; D9 08 D3 ; Compare accumulator $D308.w,Y [Reads: Y Index] [Flags: NCZ]
	ora ($C7.b),Y		; 11 C7 ; OR accumulator with memory ($C7.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $BF.b,S		; 03 BF ; OR accumulator with stack relative $BF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$BF.b]		; 07 BF ; OR accumulator with memory (long) [$BF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $E1E0.w		; 0E E0 E1 ; Arithmetic shift left $E1E0.w [Flags: NCZ]
	sbc $E7.b,S		; E3 E7 ; Subtract stack-relative $E7.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	inc $F8FC.w		; EE FC F8 ; Increment $F8FC.w [Flags: NZ]
	.db $F0, $44		; F0 44 ; Branch if equal to $F0, $44 [Flow: branch]
	sty $0AF7.w		; 8C F7 0A ; Store Y register to $0AF7.w [Reads: Y Index]
	adc [$4C.b],Y		; 77 4C ; Add with carry (long indexed) [$4C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lda [$AC.b],Y		; B7 AC ; Load accumulator (long indexed) [$AC.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp [$5C.b],Y		; D7 5C ; Compare accumulator (long indexed) [$5C.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	adc [$A8.b]		; 67 A8 ; Add with carry (long) [$A8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and [$54.b],Y		; 37 54 ; AND accumulator with memory (long indexed) [$54.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cpx #$98.b		; E0 98 ; Compare #$98.b with X register [Reads: X Index] [Flags: NCZ]
	.db $80, $40		; 80 40 ; Branch always to $80, $40 [Flow: branch]
	cpx #$DE.b		; E0 DE ; Compare #$DE.b with X register [Reads: X Index] [Flags: NCZ]
	adc [$DC.b],Y		; 77 DC ; Add with carry (long indexed) [$DC.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc [$B9.b],Y		; 77 B9 ; Add with carry (long indexed) [$B9.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $E7DFB3.l		; 6F B3 DF E7 ; Add with carry (long) $E7DFB3.l [Writes: Accumulator] [Flags: NCVZ]
	ldy $73DE.w,X		; BC DE 73 ; Load Y register $73DE.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $9FCF.w,Y		; B9 CF 9F ; Load $9FCF.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $73BCDF.l		; 6F DF BC 73 ; Add with carry (long) $73BCDF.l [Writes: Accumulator] [Flags: NCVZ]
	cmp $EE7B68.l		; CF 68 7B EE ; Compare accumulator (long) $EE7B68.l [Reads: Accumulator] [Flags: NCZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $F69D.w		; EE 9D F6 ; Increment $F69D.w [Flags: NZ]
	cmp $E7FB.w		; CD FB E7 ; Compare $E7FB.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	and $CE7B.w,X		; 3D 7B CE ; AND accumulator with memory $CE7B.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $F9F3.w,X		; 9D F3 F9 ; Store accumulator to $F9F3.w,X [Reads: Accumulator, X Index]
	clc		; 18 ; Clear carry flag [Flags: C]
	inc $F6EE.w		; EE EE F6 ; Increment $F6EE.w [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	and $F3CE.w,X		; 3D CE F3 ; AND accumulator with memory $F3CE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $FF.b,X		; 16 FF ; Arithmetic shift left $FF.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	and ($6F.b,S),Y		; 33 6F ; AND accumulator (stack relative indirect indexed) ($6F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jmp $BBEF37.l		; 5C 37 EF BB ; Jump long to $BBEF37.l [Flow: jump]
	sbc [$DC.b]		; E7 DC ; Subtract with carry (long) [$DC.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda ($5F.b,S),Y		; B3 5F ; Load accumulator (stack relative indirect indexed) ($5F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $DC6F.w,Y		; B9 6F DC ; Load $DC6F.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $B7EF58.l		; 6F 58 EF B7 ; Add with carry (long) $B7EF58.l [Writes: Accumulator] [Flags: NCVZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$6F5F]		; DC 5F 6F ; Jump long indirect [$6F5F] [Flow: jump]
	adc $CC1AFF.l		; 6F FF 1A CC ; Add with carry (long) $CC1AFF.l [Writes: Accumulator] [Flags: NCVZ]
	inc $3A.b,X		; F6 3A ; Increment memory $3A.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	cpx $DDF7.w		; EC F7 DD ; Compare $DDF7.w with X register [Reads: X Index] [Flags: NCZ]
	sbc [$3B.b]		; E7 3B ; Subtract with carry (long) [$3B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp $9DFA.w		; CD FA 9D ; Compare $9DFA.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	inc $3B.b,X		; F6 3B ; Increment memory $3B.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	inc $1A.b,X		; F6 1A ; Increment memory $1A.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	sbc [$ED.b],Y		; F7 ED ; Subtract with carry (long indexed) [$ED.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp.w [$FA3B]		; DC 3B FA ; Jump long indirect [$FA3B] [Flow: jump]
	inc $F6.b,X		; F6 F6 ; Increment memory $F6.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	ldx $9C00.w,Y		; BE 00 9C ; Load X register $9C00.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	brk $C9.b		; 00 C9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($E3.b,X)		; 41 E3 ; Exclusive OR accumulator with memory ($E3.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $DD2DCE.l		; 22 CE 2D DD ; Jump to subroutine long $DD2DCE.l [Writes: Stack Pointer] [Flow: call]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	lda $789E3A.l,X		; BF 3A 9E 78 ; Load long $789E3A.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $366B.w,X		; 5D 6B 36 ; Exclusive OR accumulator with memory $366B.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $A793.w,X		; 9D 93 A7 ; Store accumulator to $A793.w,X [Reads: Accumulator, X Index]
	eor [$87.b]		; 47 87 ; Exclusive OR accumulator with memory (long) [$87.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $1900.w,X		; 3C 00 19 ; Test bits $1900.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	ora ($C3.b,X)		; 01 C3 ; Logical OR ($C3.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
.ACCU 16
.INDEX 16
	rep #$FE		; C2 FE
	adc $80C7.w,X		; 7D C7 80 ; Add $80C7.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $201F18.l,X		; 9F 18 1F 20 ; Store accumulator (long,X) $201F18.l,X [Reads: Accumulator, X Index]
	.db $30, $5F		; 30 5F ; Branch if minus to $30, $5F [Flow: branch]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	inc $3D.b		; E6 3D ; Increment $3D.b [Reads: Direct Page] [Flags: NZ]
	sta $FF.b,S		; 83 FF ; Store accumulator (stack relative) $FF.b,S [Reads: Stack Pointer, Accumulator]
	sbc [$D8.b]		; E7 D8 ; Subtract with carry (long) [$D8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda $E803B4.l,X		; BF B4 03 E8 ; Load long $E803B4.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$F0.b]		; 07 F0 ; OR accumulator with memory (long) [$F0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0EF147.l		; 0F 47 F1 0E ; OR accumulator with memory (long) $0EF147.l [Writes: Accumulator] [Flags: NZ]
	tsb $FF.b		; 04 FF ; Test and set bits $FF.b [Reads: Accumulator] [Flags: Z]
	brk $7B.b		; 00 7B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc [$6F.b],Y		; 77 6F ; Add with carry (long indexed) [$6F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and $6E.b,S		; 23 6E ; AND accumulator with stack relative $6E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $8181.w,X		; 7E 81 81 ; Rotate right $8181.w,X [Reads: X Index] [Flags: NCZ]
	ror $FF7E.w,X		; 7E 7E FF ; Rotate right $FF7E.w,X [Reads: X Index] [Flags: NCZ]
	sbc [$E7.b]		; E7 E7 ; Subtract with carry (long) [$E7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	eor $DB.b,S		; 43 DB ; Exclusive OR accumulator with stack relative $DB.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $0B.b,S		; C3 0B ; Compare accumulator (stack relative) $0B.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	sbc $81FF00.l,X		; FF 00 FF 81 ; Subtract with carry (long,X) $81FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $003C.w,X		; 3C 3C 00 ; Test bits $003C.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	sbc $004B00.l,X		; FF 00 4B 00 ; Subtract with carry (long,X) $004B00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $28FF00.l,X		; FF 00 FF 28 ; Subtract with carry (long,X) $28FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $17C0.w		; 2D C0 17 ; Logical AND $17C0.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cpx #$F00F.w		; E0 0F F0 ; Compare #$F00F.w with X register [Reads: X Index] [Flags: NCZ]
	eor $8F.b,S		; 43 8F ; Exclusive OR accumulator with stack relative $8F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $70, $11		; 70 11 ; Branch if overflow set to $70, $11 [Flow: branch]
	stx $8F70.w		; 8E 70 8F ; Store X register to $8F70.w [Reads: X Index]
	.db $70, $FF		; 70 FF ; Branch if overflow set to $70, $FF [Flow: branch]
	brk $DE.b		; 00 DE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $76F6.w		; EE F6 76 ; Increment $76F6.w [Flags: NZ]
	ror $77.b,X		; 76 77 ; Rotate right $77.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	adc [$07.b],Y		; 77 07 ; Add with carry (long indexed) [$07.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $7FFF00.l,X		; FF 00 FF 7F ; Subtract with carry (long,X) $7FFF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $E0.b		; 45 E0 ; Exclusive OR $E0.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora [$B0.b]		; 07 B0 ; OR accumulator with memory (long) [$B0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $30, $DF		; 30 DF ; Branch if minus to $30, $DF [Flow: branch]
	sta $FFC070.l,X		; 9F 70 C0 FF ; Store accumulator (long,X) $FFC070.l,X [Reads: Accumulator, X Index]
	.db $80, $22		; 80 22 ; Branch always to $80, $22 [Flow: branch]
	sta $60CF0A.l,X		; 9F 0A CF 60 ; Store accumulator (long,X) $60CF0A.l,X [Reads: Accumulator, X Index]
	and $FB01FC.l,X		; 3F FC 01 FB ; AND accumulator with memory (long,X) $FB01FC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $7CFE.w,Y		; 79 FE 7C ; Add $7CFE.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $44.b		; C5 44 ; Compare $44.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	eor [$C3.b]		; 47 C3 ; Exclusive OR accumulator with memory (long) [$C3.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $42, $03		; 42 03 ; Reserved instruction
	inc $8386.w,X		; FE 86 83 ; Increment memory $8386.w,X [Reads: X Index] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	and $BD.b,S		; 23 BD ; AND accumulator with stack relative $BD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx #$CF33.w		; E0 33 CF ; Compare #$CF33.w with X register [Reads: X Index] [Flags: NCZ]
	.db $70, $CE		; 70 CE ; Branch if overflow set to $70, $CE [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	eor [$B9.b]		; 47 B9 ; Exclusive OR accumulator with memory (long) [$B9.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $BC.b,S		; 63 BC ; Add with carry (stack relative) $BC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($1E.b),Y		; F1 1E ; Subtract with carry ($1E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sec		; 38 ; Set carry flag [Flags: C]
	cmp $0EE71C.l		; CF 1C E7 0E ; Compare accumulator (long) $0EE71C.l [Reads: Accumulator] [Flags: NCZ]
	sbc ($77.b,S),Y		; F3 77 ; Subtract with carry (stack relative indirect indexed) ($77.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	and $0F1E.w,X		; 3D 1E 0F ; AND accumulator with memory $0F1E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $007E78.l,X		; FF 78 7E 00 ; Subtract with carry (long,X) $007E78.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$89.b],Y		; F7 89 ; Subtract with carry (long indexed) [$89.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $1C.b,S		; E3 1C ; Subtract stack-relative $1C.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	cmp #$9C3E.w		; C9 3E 9C ; Compare #$9C3E.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	adc [$36.b],Y		; 77 36 ; Add with carry (long indexed) [$36.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	adc $DD.b,S		; 63 DD ; Add with carry (stack relative) $DD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cop $87.b		; 02 87 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cmp $77BE.w,X		; DD BE 77 ; Compare accumulator $77BE.w,X [Reads: X Index] [Flags: NCZ]
	sbc $C1.b,S		; E3 C1 ; Subtract stack-relative $C1.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	lda $0DBE0C.l,X		; BF 0C BE 0D ; Load long $0DBE0C.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $E0.b,S		; 83 E0 ; Store accumulator (stack relative) $E0.b,S [Reads: Stack Pointer, Accumulator]
	ora ($46.b,X)		; 01 46 ; Logical OR ($46.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda $0D000C.l,X		; BF 0C 00 0D ; Load long $0D000C.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and [$F0.b]		; 27 F0 ; AND accumulator with memory (long) [$F0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($2A.b,X)		; 01 2A ; Logical OR ($2A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $2249.w		; ED 49 22 ; Subtract $2249.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sbc $04.b		; E5 04 ; Subtract $04.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	sbc $FDF2.w,X		; FD F2 FD ; Subtract with carry $FDF2.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $24		; F0 24 ; Branch if equal to $F0, $24 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	tsb $00E0.w		; 0C E0 00 ; Test and set bits $00E0.w [Reads: Accumulator] [Flags: Z]
	adc $609F80.l,X		; 7F 80 9F 60 ; Add long $609F80.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $90EF30.l		; CF 30 EF 90 ; Compare accumulator (long) $90EF30.l [Reads: Accumulator] [Flags: NCZ]
	sbc [$D8.b]		; E7 D8 ; Subtract with carry (long) [$D8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc [$44.b],Y		; 77 44 ; Add with carry (long indexed) [$44.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	lda $030304.l,X		; BF 04 03 03 ; Load long $030304.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($81.b,X)		; 01 81 ; Logical OR ($81.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp ($22.b,X)		; C1 22 ; Compare accumulator ($22.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	sbc ($E0.b,X)		; E1 E0 ; Subtract with carry ($E0.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $3F.b,S		; 23 3F ; AND accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpy #$30CF.w		; C0 CF 30 ; Compare #$30CF.w with Y register [Reads: Y Index] [Flags: NCZ]
	sbc [$C8.b],Y		; F7 C8 ; Subtract with carry (long indexed) [$C8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	stz $FF.b		; 64 FF ; Store zero to $FF.b
	pea $30DB.w		; F4 DB 30 ; Push absolute address $30DB.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	.db $F0, $3B		; F0 3B ; Branch if equal to $F0, $3B [Flow: branch]
	cpx #$0303.w		; E0 03 03 ; Compare #$0303.w with X register [Reads: X Index] [Flags: NCZ]
	cmp ($61.b,X)		; C1 61 ; Compare accumulator ($61.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	sbc ($35.b),Y		; F1 35 ; Subtract with carry ($35.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $E5.b,X		; F5 E5 ; Subtract $E5.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $7EAB.w,X		; 7E AB 7E ; Rotate right $7EAB.w,X [Reads: X Index] [Flags: NCZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	lda $BF5F.w,Y		; B9 5F BF ; Load $BF5F.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr $20DF.w		; 4E DF 20 ; Logical shift right $20DF.w [Flags: NCZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $07000E.l,X		; 1F 0E 00 07 ; Logical OR long $07000E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$7BFF.w		; C0 FF 7B ; Compare #$7BFF.w with Y register [Reads: Y Index] [Flags: NCZ]
	sta $9F4FBC.l,X		; 9F BC 4F 9F ; Store accumulator (long,X) $9F4FBC.l,X [Reads: Accumulator, X Index]
	adc [$C7.b]		; 67 C7 ; Add with carry (long) [$C7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc ($0F.b,S),Y		; F3 0F ; Subtract with carry (stack relative indirect indexed) ($0F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	eor $FF.b		; 45 FF ; Exclusive OR $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $22070F.l,X		; 1F 0F 07 22 ; Logical OR long $22070F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cpy #$ECFF.w		; C0 FF EC ; Compare #$ECFF.w with Y register [Reads: Y Index] [Flags: NCZ]
	asl $0FED.w,X		; 1E ED 0F ; Arithmetic shift left $0FED.w,X [Reads: X Index] [Flags: NCZ]
	cmp $EB1B.w,X		; DD 1B EB ; Compare accumulator $EB1B.w,X [Reads: X Index] [Flags: NCZ]
	and $DF.b,X		; 35 DF ; Logical AND $DF.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	rol $EF.b,X		; 36 EF ; Rotate left $EF.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	sbc ($0D.b,S),Y		; F3 0D ; Subtract with carry (stack relative indirect indexed) ($0D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc $D0C100.l,X		; FF 00 C1 D0 ; Subtract with carry (long,X) $D0C100.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy $8E.b		; A4 8E ; Load $8E.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	sta $C3C3C7.l		; 8F C7 C3 C3 ; Store accumulator (long) $C3C3C7.l [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $DF7FCF.l,X		; BF CF 7F DF ; Load long $DF7FCF.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc [$FF.b],Y		; 77 FF ; Add with carry (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sbc $4FFF9C.l,X		; FF 9C FF 4F ; Subtract with carry (long,X) $4FFF9C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $589720.l,X		; DF 20 97 58 ; Compare accumulator (long,X) $589720.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	adc $13FF22.l,X		; 7F 22 FF 13 ; Add long $13FF22.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $A0DFBF.l,X		; 7F BF DF A0 ; Add long $A0DFBF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp ($3E.b,X)		; C1 3E ; Compare accumulator ($3E.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	eor $2FD0B0.l		; 4F B0 D0 2F ; Exclusive OR accumulator with memory (long) $2FD0B0.l [Writes: Accumulator] [Flags: NZ]
	sbc $38D81F.l		; EF 1F D8 38 ; Subtract with carry (long) $38D81F.l [Writes: Accumulator] [Flags: NCVZ]
	lda [$70.b],Y		; B7 70 ; Load accumulator (long indexed) [$70.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $40DB60.l		; EF 60 DB 40 ; Subtract with carry (long) $40DB60.l [Writes: Accumulator] [Flags: NCVZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx #$0725.w		; E0 25 07 ; Compare #$0725.w with X register [Reads: X Index] [Flags: NCZ]
	ora $BD3C1F.l		; 0F 1F 3C BD ; OR accumulator with memory (long) $BD3C1F.l [Writes: Accumulator] [Flags: NZ]
	ror $FF7E.w,X		; 7E 7E FF ; Rotate right $FF7E.w,X [Reads: X Index] [Flags: NCZ]
	cmp $C3.b,S		; C3 C3 ; Compare accumulator (stack relative) $C3.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	lda $7E81.w,X		; BD 81 7E ; Load $7E81.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $C3.b		; 00 C3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BD.b		; 00 BD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C3.b		; 00 C3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $0000.w,X		; 3C 00 00 ; Test bits $0000.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	bit $FF7E.w,X		; 3C 7E FF ; Test bits $FF7E.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	sbc $FF3CC3.l,X		; FF C3 3C FF ; Subtract with carry (long,X) $FF3CC3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sbc $FDA6.w,Y		; F9 A6 FD ; Subtract with carry $FDA6.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx #$B2FD.w		; A2 FD B2 ; Load #$B2FD.w into X register [Writes: X Index] [Flags: NZ]
	sbc $43D2.w,X		; FD D2 43 ; Subtract with carry $43D2.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $0652.w,X		; FD 52 06 ; Subtract with carry $0652.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $A04050.l,X		; FF 50 40 A0 ; Subtract with carry (long,X) $A04050.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy #$D0B0.w		; A0 B0 D0 ; Load #$D0B0.w into Y register [Writes: Y Index] [Flags: NZ]
	jsl $830F50.l		; 22 50 0F 83 ; Jump to subroutine long $830F50.l [Writes: Stack Pointer] [Flow: call]
	jmp ($0CF3.w,X)		; 7C F3 0C ; Jump indirect indexed to ($0CF3.w,X) [Reads: X Index] [Flow: jump]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	pea $F8F7.w		; F4 F7 F8 ; Push absolute address $F8F7.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	trb $0EED.w		; 1C ED 0E ; Test and reset bits $0EED.w [Reads: Accumulator] [Flags: Z]
	sbc [$06.b],Y		; F7 06 ; Subtract with carry (long indexed) [$06.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	cop $23.b		; 02 23 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$F8F0.w		; E0 F0 F8 ; Compare #$F8F0.w with X register [Reads: X Index] [Flags: NCZ]
	bit $20CF.w,X		; 3C CF 20 ; Test bits $20CF.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	lda [$5F.b]		; A7 5F ; Load accumulator (long) [$5F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc #$ED56.w		; E9 56 ED ; Subtract #$ED56.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	adc ($95.b)		; 72 95 ; Add with carry (indirect) ($95.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	lda $B0506F.l		; AF 6F 50 B0 ; Load long $B0506F.l into accumulator [Writes: Accumulator] [Flags: NZ]
	adc [$BF.b]		; 67 BF ; Add with carry (long) [$BF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $180022.l,X		; 1F 22 00 18 ; Logical OR long $180022.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsr $0F10.w		; 20 10 0F ; Jump to subroutine at $0F10.w [Writes: Stack Pointer] [Flow: call]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $B3.b,S		; 03 B3 ; OR accumulator with stack relative $B3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jmp ($9774.w,X)		; 7C 74 97 ; Jump indirect indexed to ($9774.w,X) [Reads: X Index] [Flow: jump]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	and ($4B.b)		; 32 4B ; AND accumulator with memory (indirect) ($4B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $4D65.w,X		; 5D 65 4D ; Exclusive OR accumulator with memory $4D65.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $457F.w,X		; 7D 7F 45 ; Add $457F.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $84.b		; 04 84 ; Test and set bits $84.b [Reads: Accumulator] [Flags: Z]
	jsl $FF0282.l		; 22 82 02 FF ; Jump to subroutine long $FF0282.l [Writes: Stack Pointer] [Flow: call]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $6F.b,S		; 83 6F ; Store accumulator (stack relative) $6F.b,S [Reads: Stack Pointer, Accumulator]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	adc ($46.b)		; 72 46 ; Add with carry (indirect) ($46.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $700471.l		; 8F 71 04 70 ; Store accumulator (long) $700471.l [Reads: Accumulator]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $71.b,X		; 74 71 ; Store zero to $71.b,X [Reads: X Index]
	jsl $760074.l		; 22 74 00 76 ; Jump to subroutine long $760074.l [Writes: Stack Pointer] [Flow: call]
	eor $FF.b		; 45 FF ; Exclusive OR $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $007C40.l,X		; 7F 40 7C 00 ; Add long $007C40.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $B7.b,S		; 03 B7 ; OR accumulator with stack relative $B7.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta [$CF.b]		; 87 CF ; Store accumulator (long) [$CF.b] [Reads: Direct Page, Accumulator]
	cpy $0000.w		; CC 00 00 ; Compare $0000.w with Y register [Reads: Y Index] [Flags: NCZ]
	and $B4BB9C.l,X		; 3F 9C BB B4 ; AND accumulator with memory (long,X) $B4BB9C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	sbc $7EBEBD.l,X		; FF BD BE 7E ; Subtract with carry (long,X) $7EBEBD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $1AFF22.l,X		; 7F 22 FF 1A ; Add long $1AFF22.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp ($FF.b,X)		; C1 FF ; Compare accumulator ($FF.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	.db $80, $FF		; 80 FF ; Branch always to $80, $FF [Flow: branch]
	ora ($FF.b)		; 12 FF ; OR accumulator with memory (indirect) ($FF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $FFDA.w		; 6D DA FF ; Add $FFDA.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	eor #$91FD.w		; 49 FD 91 ; Exclusive OR #$91FD.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $F125.w,Y		; F9 25 F1 ; Subtract with carry $F125.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $1DE1.w		; CD E1 1D ; Compare $1DE1.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora ($FD.b,X)		; 01 FD ; Logical OR ($FD.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx #$B56A.w		; E0 6A B5 ; Compare #$B56A.w with X register [Reads: X Index] [Flags: NCZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cmp [$2F.b],Y		; D7 2F ; Compare accumulator (long indexed) [$2F.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	ora $00FDFF.l,X		; 1F FF FD 00 ; Logical OR long $00FDFF.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc ($EE.b,S),Y		; 73 EE ; Add with carry (stack relative indirect indexed) ($EE.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$DE.b],Y		; F7 DE ; Subtract with carry (long indexed) [$DE.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $7BDEBD.l		; EF BD DE 7B ; Subtract with carry (long) $7BDEBD.l [Writes: Accumulator] [Flags: NCVZ]
	lda $7BF7.w,X		; BD F7 7B ; Load $7BF7.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $BE3CF7.l		; CF F7 3C BE ; Compare accumulator (long) $BE3CF7.l [Reads: Accumulator] [Flags: NCZ]
	lda ($EE.b,S),Y		; B3 EE ; Load accumulator (stack relative indirect indexed) ($EE.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $7BBD.w,X		; DE BD 7B ; Decrement memory $7BBD.w,X [Reads: X Index] [Flags: NZ]
	sbc [$CF.b],Y		; F7 CF ; Subtract with carry (long indexed) [$CF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $CED0.w,X		; 3C D0 CE ; Test bits $CED0.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	adc [$EF.b],Y		; 77 EF ; Add with carry (long indexed) [$EF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc [$BD.b],Y		; F7 BD ; Subtract with carry (long indexed) [$BD.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dec $EFBD.w,X		; DE BD EF ; Decrement memory $EFBD.w,X [Reads: X Index] [Flags: NZ]
	dec $EFF3.w,X		; DE F3 EF ; Decrement memory $EFF3.w,X [Reads: X Index] [Flags: NZ]
	bit $CD7D.w,X		; 3C 7D CD ; Test bits $CD7D.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	adc [$7B.b],Y		; 77 7B ; Add with carry (long indexed) [$7B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $EFDE.w,X		; BD DE EF ; Load $EFDE.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($3C.b,S),Y		; F3 3C ; Subtract with carry (stack relative indirect indexed) ($3C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	dec $6FB7.w,X		; DE B7 6F ; Decrement memory $6FB7.w,X [Reads: X Index] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc [$DD.b],Y		; F7 DD ; Subtract with carry (long indexed) [$DD.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	dec $6FBC.w,X		; DE BC 6F ; Decrement memory $6FBC.w,X [Reads: X Index] [Flags: NZ]
	dec $EF77.w,X		; DE 77 EF ; Decrement memory $EF77.w,X [Reads: X Index] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	adc [$BC.b],Y		; 77 BC ; Add with carry (long indexed) [$BC.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lda [$BB.b],Y		; B7 BB ; Load accumulator (long indexed) [$BB.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $6FDE.w,X		; 5D DE 6F ; Exclusive OR accumulator with memory $6FDE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc [$3B.b],Y		; 77 3B ; Add with carry (long indexed) [$3B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $ED7B.w,X		; 3C 7B ED ; Test bits $ED7B.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	inc $DC.b,X		; F6 DC ; Increment memory $DC.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	sbc $7BDFBB.l		; EF BB DF 7B ; Subtract with carry (long) $7BDFBB.l [Writes: Accumulator] [Flags: NCVZ]
	and $7BF6.w,X		; 3D F6 7B ; AND accumulator with memory $7BF6.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $DDF7.w		; EE F7 DD ; Increment $DDF7.w [Flags: NZ]
	inc $ED3D.w		; EE 3D ED ; Increment $ED3D.w [Flags: NZ]
	cmp $7BBA.w,X		; DD BA 7B ; Compare accumulator $7BBA.w,X [Reads: X Index] [Flags: NCZ]
	inc $EE.b,X		; F6 EE ; Increment memory $EE.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	jmp.w [$C13C]		; DC 3C C1 ; Jump long indirect [$C13C] [Flow: jump]
	jsl $1C46DD.l		; 22 DD 46 1C ; Jump to subroutine long $1C46DD.l [Writes: Stack Pointer] [Flow: call]
	cmp $06.b,X		; D5 06 ; Compare accumulator $06.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cmp $E31C.w,X		; DD 1C E3 ; Compare accumulator $E31C.w,X [Reads: X Index] [Flags: NCZ]
	jsl $9C3EDD.l		; 22 DD 3E 9C ; Jump to subroutine long $9C3EDD.l [Writes: Stack Pointer] [Flow: call]
	bit $BE.b		; 24 BE ; Test bits $BE.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	tsb $809C.w		; 0C 9C 80 ; Test and set bits $809C.w [Reads: Accumulator] [Flags: Z]
	lda $3F183F.l		; AF 3F 18 3F ; Load long $3F183F.l into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $10, $3F		; 10 3F ; Branch if plus to $10, $3F [Flow: branch]
	ora $3F.b,X		; 15 3F ; OR accumulator with memory $3F.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	asl $3F.b,X		; 16 3F ; Arithmetic shift left $3F.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($44.b,S),Y		; 13 44 ; OR accumulator (stack relative indirect indexed) ($44.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $4F0011.l,X		; 3F 11 00 4F ; AND accumulator with memory (long,X) $4F0011.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rol $DF.b		; 26 DF ; Rotate left $DF.b [Reads: Direct Page] [Flags: NCZ]
	ora ($CF.b,S),Y		; 13 CF ; OR accumulator (stack relative indirect indexed) ($CF.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	dec $7617.w,X		; DE 17 76 ; Decrement memory $7617.w,X [Reads: X Index] [Flags: NZ]
	lda $4F19E1.l		; AF E1 19 4F ; Load long $4F19E1.l into accumulator [Writes: Accumulator] [Flags: NZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	dec $7637.w,X		; DE 37 76 ; Decrement memory $7637.w,X [Reads: X Index] [Flags: NZ]
	lda $309F66.l		; AF 66 9F 30 ; Load long $309F66.l into accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $0600.w		; 20 00 06 ; Jump to subroutine at $0600.w [Writes: Stack Pointer] [Flow: call]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$3E.b]		; 07 3E ; OR accumulator with memory (long) [$3E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $FFC141.l,X		; FF 41 C1 FF ; Subtract with carry (long,X) $FFC141.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $BE		; 80 BE ; Branch always to $80, $BE [Flow: branch]
	adc $FF3E43.l,X		; 7F 43 3E FF ; Add long $FF3E43.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sty $5C.b		; 84 5C ; Store Y register to $5C.b [Reads: Y Index]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rol $0025.w,X		; 3E 25 00 ; Rotate left $0025.w,X [Reads: X Index] [Flags: NCZ]
	ora ($18.b)		; 12 18 ; OR accumulator with memory (indirect) ($18.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $42, $42		; 42 42 ; Reserved instruction
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $00.b,S		; C3 00 ; Compare accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	bit $C300.w,X		; 3C 00 C3 ; Test bits $C300.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	cmp $DB.b,S		; C3 DB ; Compare accumulator (stack relative) $DB.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	bit $F7E7.w,X		; 3C E7 F7 ; Test bits $F7E7.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	lda $FF22.w,X		; BD 22 FF ; Load $FF22.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $3C.b,X		; 16 3C ; Arithmetic shift left $3C.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $39.b		; 00 39 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$F835.w		; C0 35 F8 ; Compare #$F835.w with Y register [Reads: Y Index] [Flags: NCZ]
	lda ($FC.b,S),Y		; B3 FC ; Load accumulator (stack relative indirect indexed) ($FC.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc ($7E.b),Y		; F1 7E ; Subtract with carry ($7E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($8E.b,X)		; 41 8E ; Exclusive OR accumulator with memory ($8E.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $3DCE.w,Y		; 39 CE 3D ; AND accumulator with memory $3DCE.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	inc $35.b,X		; F6 35 ; Increment memory $35.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	asl $02.b		; 06 02 ; Arithmetic shift left $02.b [Reads: Direct Page] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $22		; 30 22 ; Branch if minus to $30, $22 [Flow: branch]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	and $9F37FA.l		; 2F FA 37 9F ; AND accumulator with memory (long) $9F37FA.l [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ldx $B35E.w		; AE 5E B3 ; Load $B35E.w into X register [Writes: X Index] [Flags: NZ]
	adc $8070BF.l		; 6F BF 70 80 ; Add with carry (long) $8070BF.l [Writes: Accumulator] [Flags: NCVZ]
	and $0022FF.l,X		; 3F FF 22 00 ; AND accumulator with memory (long,X) $0022FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $4140.w,Y		; 19 40 41 ; OR accumulator with memory $4140.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $70, $7F		; 70 7F ; Branch if overflow set to $70, $7F [Flow: branch]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C1.b		; 00 C1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $EEDD.w,X		; 3C DD EE ; Test bits $EEDD.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	sbc $F576.w		; ED 76 F5 ; Subtract $F576.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	and $DA.b,X		; 35 DA ; Logical AND $DA.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $2DDA.w,X		; FD DA 2D ; Subtract with carry $2DDA.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $2206.w		; 0E 06 22 ; Arithmetic shift left $2206.w [Flags: NCZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b)		; 12 00 ; OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $FF.b		; 26 FF ; Rotate left $FF.b [Reads: Direct Page] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$FF.b]		; 27 FF ; AND accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $0000FF.l		; 22 FF 00 00 ; Jump to subroutine long $0000FF.l [Writes: Stack Pointer] [Flow: call]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $99.b		; 02 99 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FF44A5.l,X		; FF A5 44 FF ; Subtract with carry (long,X) $FF44A5.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	cop $A5.b		; 02 A5 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FF2B99.l,X		; FF 99 2B FF ; Subtract with carry (long,X) $FF2B99.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $40FF80.l,X		; 7F 80 FF 40 ; Add long $40FF80.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $457F00.l,X		; BF 00 7F 45 ; Load long $457F00.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $1F0900.l		; 22 00 09 1F ; Jump to subroutine long $1F0900.l [Writes: Stack Pointer] [Flow: call]
	eor $7F3F9F.l,X		; 5F 9F 3F 7F ; Exclusive OR accumulator with memory (long,X) $7F3F9F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $EF40B7.l,X		; FF B7 40 EF ; Subtract with carry (long,X) $EF40B7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr $FF4B.w		; 20 4B FF ; Jump to subroutine at $FF4B.w [Writes: Stack Pointer] [Flow: call]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$0713.w		; 09 13 07 ; Logical OR #$0713.w with accumulator [Writes: Accumulator] [Flags: NZ]
	bit $3F.b		; 24 3F ; Test bits $3F.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora $8F.b,S		; 03 8F ; OR accumulator with stack relative $8F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $8D		; F0 8D ; Branch if equal to $F0, $8D [Flow: branch]
	inc $43.b,X		; F6 43 ; Increment memory $43.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	sty $01F7.w		; 8C F7 01 ; Store Y register to $01F7.w [Reads: Y Index]
	sta $8C43F0.l		; 8F F0 43 8C ; Store accumulator (long) $8C43F0.l [Reads: Accumulator]
	sbc [$01.b],Y		; F7 01 ; Subtract with carry (long indexed) [$01.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($2707.w,X)		; FC 07 27 ; Jump to subroutine indirect indexed ($2707.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $01FE46.l,X		; FF 46 FE 01 ; Subtract with carry (long,X) $01FE46.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$FF.b]		; 07 FF ; OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc [$88.b],Y		; 77 88 ; Add with carry (long indexed) [$88.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc [$C8.b],Y		; 77 C8 ; Add with carry (long indexed) [$C8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and [$27.b],Y		; 37 27 ; AND accumulator with memory (long indexed) [$27.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($4553.w,X)		; FC 53 45 ; Jump to subroutine indirect indexed ($4553.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $4351.w,X		; FE 51 43 ; Increment memory $4351.w,X [Reads: X Index] [Flags: NZ]
	sbc $7F0350.l,X		; FF 50 03 7F ; Subtract with carry (long,X) $7F0350.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	adc $5025AA.l,X		; 7F AA 25 50 ; Add long $5025AA.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $28.b		; 06 28 ; Arithmetic shift left $28.b [Reads: Direct Page] [Flags: NCZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	jsr ($FF03.w,X)		; FC 03 FF ; Jump to subroutine indirect indexed ($FF03.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr ($83FF.w,X)		; FC FF 83 ; Jump to subroutine indirect indexed ($83FF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	eor $0705.w,Y		; 59 05 07 ; Exclusive OR accumulator with memory $0705.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $FF.b,S		; 03 FF ; OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($0F.b,X)		; 81 0F ; Store accumulator ($0F.b,X) [Reads: Direct Page, Accumulator, X Index]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	eor $FC.b,S		; 43 FC ; Exclusive OR accumulator with stack relative $FC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0C.b,S		; 03 0C ; OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E3.b		; 00 E3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $01FE.w		; 1C FE 01 ; Test and reset bits $01FE.w [Reads: Accumulator] [Flags: Z]
	inc $0D.b,X		; F6 0D ; Increment memory $0D.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	asl $FD.b		; 06 FD ; Arithmetic shift left $FD.b [Reads: Direct Page] [Flags: NCZ]
	cop $45.b		; 02 45 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $800000.l,X		; FF 00 00 80 ; Subtract with carry (long,X) $800000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $C0.b		; 24 C0 ; Test bits $C0.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	trb $E0.b		; 14 E0 ; Test and reset bits $E0.b [Reads: Accumulator] [Flags: Z]
	jsr ($9F88.w,X)		; FC 88 9F ; Jump to subroutine indirect indexed ($9F88.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cmp [$4F.b]		; C7 4F ; Compare accumulator (long) [$4F.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ldy #$DF3F.w		; A0 3F DF ; Load #$DF3F.w into Y register [Writes: Y Index] [Flags: NZ]
	sta $E798E0.l,X		; 9F E0 98 E7 ; Store accumulator (long,X) $E798E0.l,X [Reads: Accumulator, X Index]
	lda $00FFC0.l,X		; BF C0 FF 00 ; Load long $00FFC0.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $231F37.l		; 6F 37 1F 23 ; Add with carry (long) $231F37.l [Writes: Accumulator] [Flags: NCVZ]
	brk $1B.b		; 00 1B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $FF00FF.l,X		; 1F FF 00 FF ; Logical OR long $FF00FF.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsr ($E11E.w,X)		; FC 1E E1 ; Jump to subroutine indirect indexed ($E11E.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $30, $CF		; 30 CF ; Branch if minus to $30, $CF [Flow: branch]
	jmp ($DC9F.w)		; 6C 9F DC ; Jump indirect to ($DC9F.w) [Flow: jump]
	rol $30F0.w,X		; 3E F0 30 ; Rotate left $30F0.w,X [Reads: X Index] [Flags: NCZ]
	sbc ($21.b,X)		; E1 21 ; Subtract with carry ($21.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$80C0.w		; E0 C0 80 ; Compare #$80C0.w with X register [Reads: X Index] [Flags: NCZ]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $00FF.w,X		; 1E FF 00 ; Arithmetic shift left $00FF.w,X [Reads: X Index] [Flags: NCZ]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $228000.l,X		; FF 00 80 22 ; Subtract with carry (long,X) $228000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $2304.w,X		; 3C 04 23 ; Test bits $2304.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $E001.w,X		; 5D 01 E0 ; Exclusive OR accumulator with memory $E001.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $2B020B.l		; 2F 0B 02 2B ; AND accumulator with memory (long) $2B020B.l [Writes: Accumulator] [Flags: NZ]
	jsl $C50104.l		; 22 04 01 C5 ; Jump to subroutine long $C50104.l [Writes: Stack Pointer] [Flow: call]
	cmp ($85.b,X)		; C1 85 ; Compare accumulator ($85.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	sta ($04.b,X)		; 81 04 ; Store accumulator ($04.b,X) [Reads: Direct Page, Accumulator, X Index]
	ora ($2B.b,X)		; 01 2B ; Logical OR ($2B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $FC020B.l		; 22 0B 02 FC ; Jump to subroutine long $FC020B.l [Writes: Stack Pointer] [Flow: call]
	jmp.w [$3EFE]		; DC FE 3E ; Jump long indirect [$3EFE] [Flow: jump]
	ror $DCFE.w,X		; 7E FE DC ; Rotate right $DCFE.w,X [Reads: X Index] [Flags: NCZ]
	jsr ($1FE0.w,X)		; FC E0 1F ; Jump to subroutine indirect indexed ($1FE0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $30, $CF		; 30 CF ; Branch if minus to $30, $CF [Flow: branch]
	jmp.w [$8FE3]		; DC E3 8F ; Jump long indirect [$8FE3] [Flow: jump]
	.db $B0, $43		; B0 43 ; Branch if carry set to $B0, $43 [Flow: branch]
	bit $1E0D.w,X		; 3C 0D 1E ; Test bits $1E0D.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	cmp [$46.b]		; C7 46 ; Compare accumulator (long) [$46.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	adc $A2.b,S		; 63 A2 ; Add with carry (stack relative) $A2.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $40030F.l,X		; 1F 0F 03 40 ; Logical OR long $40030F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$38E0.w		; C0 E0 38 ; Compare #$38E0.w with Y register [Reads: Y Index] [Flags: NCZ]
	trb $0FFF.w		; 1C FF 0F ; Test and reset bits $0FFF.w [Reads: Accumulator] [Flags: Z]
	cmp $5FEF3F.l		; CF 3F EF 5F ; Compare accumulator (long) $5FEF3F.l [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $6F		; B0 6F ; Branch if carry set to $B0, $6F [Flow: branch]
	sta $788870.l,X		; 9F 70 88 78 ; Store accumulator (long,X) $788870.l,X [Reads: Accumulator, X Index]
	eor [$BF.b]		; 47 BF ; Exclusive OR accumulator with memory (long) [$BF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc [$9F.b]		; 67 9F ; Add with carry (long) [$9F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc [$AF.b],Y		; 77 AF ; Add with carry (long indexed) [$AF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $FC0900.l		; 22 00 09 FC ; Jump to subroutine long $FC0900.l [Writes: Stack Pointer] [Flow: call]
	ora $C7.b,S		; 03 C7 ; OR accumulator with stack relative $C7.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	adc $BD.b,S		; 63 BD ; Add with carry (stack relative) $BD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	and ($DE.b),Y		; 31 DE ; AND accumulator with memory ($DE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $E7D645.l		; EF 45 D6 E7 ; Subtract with carry (long) $E7D645.l [Writes: Accumulator] [Flags: NCVZ]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	jsl $FF4308.l		; 22 08 43 FF ; Jump to subroutine long $FF4308.l [Writes: Stack Pointer] [Flow: call]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $007E00.l,X		; 7F 00 7E 00 ; Add long $007E00.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $7B01.w,X		; 7D 01 7B ; Add $7B01.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $77.b		; 02 77 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $6E.b		; 05 6E ; Logical OR $6E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $FE.b,S		; 03 FE ; OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr ($F1F8.w,X)		; FC F8 F1 ; Jump to subroutine indirect indexed ($F1F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $80FF7F.l,X		; 7F 7F FF 80 ; Add long $80FF7F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$20.b]		; E7 20 ; Subtract with carry (long) [$20.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $383B80.l		; 8F 80 3B 38 ; Store accumulator (long) $383B80.l [Reads: Accumulator]
	adc $FF64.w,X		; 7D 64 FF ; Add $FF64.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $1F0080.l,X		; FF 80 00 1F ; Subtract with carry (long,X) $1F0080.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $C083C7.l,X		; 7F C7 83 C0 ; Add long $C083C7.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	mvp $FF,$00		; 44 00 FF ; Move block positive $FF,$00 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora #$00FE.w		; 09 FE 00 ; Logical OR #$00FE.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $FB01.w,X		; FD 01 FB ; Subtract with carry $FB01.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $F7.b		; 02 F7 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $EE.b		; 05 EE ; Logical OR $EE.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $44.b,S		; 83 44 ; Store accumulator (stack relative) $44.b,S [Reads: Stack Pointer, Accumulator]
	brk $1A.b		; 00 1A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $0F		; F0 0F ; Branch if equal to $F0, $0F [Flow: branch]
	sbc $ECCBC0.l,X		; FF C0 CB EC ; Subtract with carry (long,X) $ECCBC0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $5F9FEF.l		; CF EF 9F 5F ; Compare accumulator (long) $5F9FEF.l [Reads: Accumulator] [Flags: NCZ]
	.db $70, $8F		; 70 8F ; Branch if overflow set to $70, $8F [Flow: branch]
	sta $6C4BD0.l		; 8F D0 4B 6C ; Store accumulator (long) $6C4BD0.l [Reads: Accumulator]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	jsr $2000.w		; 20 00 20 ; Jump to subroutine at $2000.w [Writes: Stack Pointer] [Flow: call]
	.db $90, $FF		; 90 FF ; Branch if carry clear to $90, $FF [Flow: branch]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $FF0800.l		; 22 00 08 FF ; Jump to subroutine long $FF0800.l [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $B0FFE0.l,X		; FF E0 FF B0 ; Subtract with carry (long,X) $B0FFE0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FF2319.l,X		; FF 19 23 FF ; Subtract with carry (long,X) $FF2319.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cop $FF.b		; 02 FF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $968300.l		; 22 00 83 96 ; Jump to subroutine long $968300.l [Writes: Stack Pointer] [Flow: call]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($FF.b),Y		; 71 FF ; Add with carry ($FF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	and $FF.b		; 25 FF ; Logical AND $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	dec $0F.b,X		; D6 0F ; Decrement memory $0F.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	pei ($0F.b)		; D4 0F ; Push effective indirect address ($0F.b) [Reads: Direct Page] [Writes: Stack Pointer]
	dec $0F.b,X		; D6 0F ; Decrement memory $0F.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	cmp ($0F.b,S),Y		; D3 0F ; Compare accumulator (stack relative indirect indexed) ($0F.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	cmp ($44.b),Y		; D1 44 ; Compare accumulator ($44.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	ora $D101D0.l		; 0F D0 01 D1 ; OR accumulator with memory (long) $D101D0.l [Writes: Accumulator] [Flags: NZ]
	ora $00E027.l		; 0F 27 E0 00 ; OR accumulator with memory (long) $00E027.l [Writes: Accumulator] [Flags: NZ]
	cmp ($46.b,S),Y		; D3 46 ; Compare accumulator (stack relative indirect indexed) ($46.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	ora $C683D7.l		; 0F D7 83 C6 ; OR accumulator with memory (long) $C683D7.l [Writes: Accumulator] [Flags: NZ]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cld		; D8 ; Clear decimal flag [Flags: D]
	brk $27.b		; 00 27 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$FF12.w		; E0 12 FF ; Compare #$FF12.w with X register [Reads: X Index] [Flags: NCZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $FE.b,S		; 03 FE ; OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc [$FC.b],Y		; 77 FC ; Add with carry (long indexed) [$FC.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	pei ($6A.b)		; D4 6A ; Push effective indirect address ($6A.b) [Reads: Direct Page] [Writes: Stack Pointer]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	adc $66DF.w		; 6D DF 66 ; Add $66DF.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp $030072.l		; CF 72 00 03 ; Compare accumulator (long) $030072.l [Reads: Accumulator] [Flags: NCZ]
	ora [$23.b]		; 07 23 ; OR accumulator with memory (long) [$23.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $FF0712.l		; 0F 12 07 FF ; OR accumulator with memory (long) $FF0712.l [Writes: Accumulator] [Flags: NZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $3C.b,S		; 83 3C ; Store accumulator (stack relative) $3C.b,S [Reads: Stack Pointer, Accumulator]
	adc $702E38.l		; 6F 38 2E 70 ; Add with carry (long) $702E38.l [Writes: Accumulator] [Flags: NCVZ]
	cpx $DCF0.w		; EC F0 DC ; Compare $DCF0.w with X register [Reads: X Index] [Flags: NCZ]
	sbc [$B8.b]		; E7 B8 ; Subtract with carry (long) [$B8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cpx $0076.w		; EC 76 00 ; Compare $0076.w with X register [Reads: X Index] [Flags: NCZ]
	cmp [$22.b]		; C7 22 ; Compare accumulator (long) [$22.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sbc $BBDF03.l		; EF 03 DF BB ; Subtract with carry (long) $BBDF03.l [Writes: Accumulator] [Flags: NCVZ]
	adc [$63.b],Y		; 77 63 ; Add with carry (long indexed) [$63.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $431F00.l,X		; FF 00 1F 43 ; Subtract with carry (long,X) $431F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$0120.w		; E0 20 01 ; Compare #$0120.w with X register [Reads: X Index] [Flags: NCZ]
	sbc ($21.b,X)		; E1 21 ; Subtract with carry ($21.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $E0.b,S		; 43 E0 ; Exclusive OR accumulator with stack relative $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr $FF08.w		; 20 08 FF ; Jump to subroutine at $FF08.w [Writes: Stack Pointer] [Flow: call]
	sbc $DFDFE0.l,X		; FF E0 DF DF ; Subtract with carry (long,X) $DFDFE0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $DFDF.w,X		; DE DF DF ; Decrement memory $DFDF.w,X [Reads: X Index] [Flags: NZ]
	stx $0043.w		; 8E 43 00 ; Store X register to $0043.w [Reads: X Index]
	sbc $23FF00.l,X		; FF 00 FF 23 ; Subtract with carry (long,X) $23FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $3A.b,S		; 83 3A ; Store accumulator (stack relative) $3A.b,S [Reads: Stack Pointer, Accumulator]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $80FFFF.l		; EF FF FF 80 ; Subtract with carry (long) $80FFFF.l [Writes: Accumulator] [Flags: NCVZ]
	mvp $C0,$00		; 44 00 C0 ; Move block positive $C0,$00 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	.db $D0, $00		; D0 00 ; Branch if not equal to $D0, $00 [Flow: branch]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	pei ($0C.b)		; D4 0C ; Push effective indirect address ($0C.b) [Reads: Direct Page] [Writes: Stack Pointer]
	dec $0E.b,X		; D6 0E ; Decrement memory $0E.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	cmp [$0F.b],Y		; D7 0F ; Compare accumulator (long indexed) [$0F.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	and $E0.b		; 25 E0 ; Logical AND $E0.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$59.b],Y		; 17 59 ; OR accumulator with memory (long indexed) [$59.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $0EEC.w		; 1C EC 0E ; Test and reset bits $0EEC.w [Reads: Accumulator] [Flags: Z]
	inc $C7.b,X		; F6 C7 ; Increment memory $C7.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $1D.b,S		; 23 1D ; AND accumulator with stack relative $1D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($0E.b),Y		; 11 0E ; OR accumulator with memory ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sta [$84.b]		; 87 84 ; Store accumulator (long) [$84.b] [Reads: Direct Page, Accumulator]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $F1.b,S		; E3 F1 ; Subtract stack-relative $F1.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	sec		; 38 ; Set carry flag [Flags: C]
	jmp.w [$F7EE]		; DC EE F7 ; Jump long indirect [$F7EE] [Flow: jump]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $2A83.w,X		; FD 83 2A ; Subtract with carry $2A83.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpx $24.b		; E4 24 ; Compare $24.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	sta $28.b,S		; 83 28 ; Store accumulator (stack relative) $28.b,S [Reads: Stack Pointer, Accumulator]
	ora ($E0.b,X)		; 01 E0 ; Logical OR ($E0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and ($50.b),Y		; 31 50 ; AND accumulator with memory ($50.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $AF		; 10 AF ; Branch if plus to $10, $AF [Flow: branch]
	sta $DE40DF.l		; 8F DF 40 DE ; Store accumulator (long) $DE40DF.l [Reads: Accumulator]
	cmp $DEDFDB.l,X		; DF DB DF DE ; Compare accumulator (long,X) $DEDFDB.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	sbc $F93F70.l		; EF 70 3F F9 ; Subtract with carry (long) $F93F70.l [Writes: Accumulator] [Flags: NCVZ]
	cop $F4.b		; 02 F4 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($0A.b),Y		; F1 0A ; Subtract with carry ($0A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $22.b,S		; 23 22 ; AND accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsr ($F70E.w,X)		; FC 0E F7 ; Jump to subroutine indirect indexed ($F70E.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc $FDDD.w,X		; FD DD FD ; Subtract with carry $FDDD.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $FA.b,X		; 75 FA ; Add $FA.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $F5.b,X		; 76 F5 ; Rotate right $F5.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $32.b		; C5 32 ; Compare $32.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cpy $7B0A.w		; CC 0A 7B ; Compare $7B0A.w with Y register [Reads: Y Index] [Flags: NCZ]
	lda $BD5A.w,X		; BD 5A BD ; Load $BD5A.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $7B.b,S		; 43 7B ; Exclusive OR accumulator with stack relative $7B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	stz $0103.w		; 9C 03 01 ; Store zero to $0103.w
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($23.b),Y		; 31 23 ; AND accumulator with memory ($23.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rol $F5.b,X		; 36 F5 ; Rotate left $F5.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc ($FD.b)		; F2 FD ; Subtract with carry (indirect) ($FD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora [$F4.b]		; 07 F4 ; OR accumulator with memory (long) [$F4.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $FD0E.w		; 0C 0E FD ; Test and set bits $FD0E.w [Reads: Accumulator] [Flags: Z]
	sbc $86FF79.l,X		; FF 79 FF 86 ; Subtract with carry (long,X) $86FF79.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $00C1.w,Y		; 79 C1 00 ; Add $00C1.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($22.b),Y		; F1 22 ; Subtract with carry ($22.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $1B.b		; 00 1B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp.w [$F914]		; DC 14 F9 ; Jump long indirect [$F914] [Flow: jump]
	and ($FB.b,X)		; 21 FB ; Logical AND ($FB.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	sbc ($22.b,S),Y		; F3 22 ; Subtract with carry (stack relative indirect indexed) ($22.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$22.b],Y		; F7 22 ; Subtract with carry (long indexed) [$22.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FE21.w,X		; FD 21 FE ; Subtract with carry $FE21.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr $20FF.w		; 20 FF 20 ; Jump to subroutine at $20FF.w [Writes: Stack Pointer] [Flow: call]
	sbc $C6.b,S		; E3 C6 ; Subtract stack-relative $C6.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	cpy $CC.b		; C4 CC ; Compare $CC.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	cpy $CFCE.w		; CC CE CF ; Compare $CFCE.w with Y register [Reads: Y Index] [Flags: NCZ]
	cmp $667665.l		; CF 65 76 66 ; Compare accumulator (long) $667665.l [Reads: Accumulator] [Flags: NCZ]
	adc [$43.b],Y		; 77 43 ; Add with carry (long indexed) [$43.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $F7.b		; 66 F7 ; Rotate right $F7.b [Reads: Direct Page] [Flags: NCZ]
	asl $8E.b,X		; 16 8E ; Arithmetic shift left $8E.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	adc $A1BE5D.l		; 6F 5D BE A1 ; Add with carry (long) $A1BE5D.l [Writes: Accumulator] [Flags: NCVZ]
	dec $6756.w,X		; DE 56 67 ; Decrement memory $6756.w,X [Reads: X Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $88.b		; 00 88 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $FF.b		; 06 FF ; Arithmetic shift left $FF.b [Reads: Direct Page] [Flags: NCZ]
	cop $FF.b		; 02 FF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sta $48.b,S		; 83 48 ; Store accumulator (stack relative) $48.b,S [Reads: Stack Pointer, Accumulator]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	adc $807FC0.l,X		; 7F C0 7F 80 ; Add long $807FC0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $0027FE.l,X		; 7F FE 27 00 ; Add long $0027FE.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora #$8E80.w		; 09 80 8E ; Logical OR #$8E80.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $C07FC4.l,X		; 3F C4 7F C0 ; AND accumulator with memory (long,X) $C07FC4.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $FF00FF.l,X		; 7F FF 00 FF ; Add long $FF00FF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	mvp $00,$FF		; 44 FF 00 ; Move block positive $00,$FF [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora ($7F.b,X)		; 01 7F ; Logical OR ($7F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $0F.b		; 02 0F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $1E		; 70 1E ; Branch if overflow set to $70, $1E [Flow: branch]
	lsr $77.b		; 46 77 ; Logical shift right $77.b [Reads: Direct Page] [Flags: NCZ]
	tsb $4C05.w		; 0C 05 4C ; Test and set bits $4C05.w [Reads: Accumulator] [Flags: Z]
	adc [$6C.b],Y		; 77 6C ; Add with carry (long indexed) [$6C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc [$0C.b],Y		; 77 0C ; Add with carry (long indexed) [$0C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$26.b],Y		; F7 26 ; Subtract with carry (long indexed) [$26.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $04		; 80 04 ; Branch always to $80, $04 [Flow: branch]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta [$3C.b]		; 87 3C ; Store accumulator (long) [$3C.b] [Reads: Direct Page, Accumulator]
	and [$43.b],Y		; 37 43 ; AND accumulator with memory (long indexed) [$43.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tsb $8377.w		; 0C 77 83 ; Test and set bits $8377.w [Reads: Accumulator] [Flags: Z]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp $0C77.w		; 4C 77 0C ; Jump to $0C77.w [Flow: jump]
	adc [$00.b],Y		; 77 00 ; Add with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$8025.w		; C0 25 80 ; Compare #$8025.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpx #$CF5F.w		; E0 5F CF ; Compare #$CF5F.w with X register [Reads: X Index] [Flags: NCZ]
	.db $70, $DF		; 70 DF ; Branch if overflow set to $70, $DF [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $1AF74A.l,X		; BF 4A F7 1A ; Load long $1AF74A.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc [$3B.b]		; E7 3B ; Subtract with carry (long) [$3B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inc $FF3B.w		; EE 3B FF ; Increment $FF3B.w [Flags: NZ]
	adc ($FF.b,X)		; 61 FF ; Add with carry ($FF.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cop $09.b		; 02 09 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc ($63.b,S),Y		; 73 63 ; Add with carry (stack relative indirect indexed) ($63.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $D0, $EC		; D0 EC ; Branch if not equal to $D0, $EC [Flow: branch]
	sbc [$D8.b]		; E7 D8 ; Subtract with carry (long) [$D8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $A4FCB0.l		; EF B0 FC A4 ; Subtract with carry (long) $A4FCB0.l [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	sbc $93.b,S		; E3 93 ; Subtract stack-relative $93.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	stz $96.b		; 64 96 ; Store zero to $96.b
	sbc $DFEF9C.l		; EF 9C EF DF ; Subtract with carry (long) $DFEF9C.l [Writes: Accumulator] [Flags: NCVZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	lda ($A7.b,S),Y		; B3 A7 ; Load accumulator (stack relative indirect indexed) ($A7.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpy $C0C9.w		; CC C9 C0 ; Compare $C0C9.w with Y register [Reads: Y Index] [Flags: NCZ]
	ldy $9A1D.w		; AC 1D 9A ; Load $9A1D.w into Y register [Writes: Y Index] [Flags: NZ]
	and $73B6.w,Y		; 39 B6 73 ; AND accumulator with memory $73B6.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $0CBF66.l		; EF 66 BF 0C ; Subtract with carry (long) $0CBF66.l [Writes: Accumulator] [Flags: NCVZ]
	sta $BF18.w,X		; 9D 18 BF ; Store accumulator to $BF18.w,X [Reads: Accumulator, X Index]
	brk $9C.b		; 00 9C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $4662.w		; 9C 62 46 ; Store zero to $4662.w
	tsb $7218.w		; 0C 18 72 ; Test and set bits $7218.w [Reads: Accumulator] [Flags: Z]
	ror $40.b		; 66 40 ; Rotate right $40.b [Reads: Direct Page] [Flags: NCZ]
	adc $B1.b,S		; 63 B1 ; Add with carry (stack relative) $B1.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sta $C5BEE1.l,X		; 9F E1 BE C5 ; Store accumulator (long,X) $C5BEE1.l,X [Reads: Accumulator, X Index]
	lda ($5A.b)		; B2 5A ; Load accumulator (indirect) ($5A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $C5.b		; 25 C5 ; Logical AND $C5.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ror $FF3A.w,X		; 7E 3A FF ; Rotate right $FF3A.w,X [Reads: X Index] [Flags: NCZ]
	brk $71.b		; 00 71 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($5F.b),Y		; 71 5F ; Add with carry ($5F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $BC3E.w,X		; 3E 3E BC ; Rotate left $BC3E.w,X [Reads: X Index] [Flags: NCZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	lda $8E00.w,Y		; B9 00 8E ; Load $8E00.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $2020.w		; 0C 20 20 ; Test and set bits $2020.w [Reads: Accumulator] [Flags: Z]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	bit $3E3C.w,X		; 3C 3C 3E ; Test bits $3E3C.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	rol $3F3F.w,X		; 3E 3F 3F ; Rotate left $3F3F.w,X [Reads: X Index] [Flags: NCZ]
	.db $80, $26		; 80 26 ; Branch always to $80, $26 [Flow: branch]
	cpy #$23E0.w		; C0 E0 23 ; Compare #$23E0.w with Y register [Reads: Y Index] [Flags: NCZ]
	sty $840F.w		; 8C 0F 84 ; Store Y register to $840F.w [Reads: Y Index]
	adc [$50.b],Y		; 77 50 ; Add with carry (long indexed) [$50.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0C0FFC.l,X		; 9F FC 0F 0C ; Store accumulator (long,X) $0C0FFC.l,X [Reads: Accumulator, X Index]
	ora [$84.b]		; 07 84 ; OR accumulator with memory (long) [$84.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc ($92.b,S),Y		; 73 92 ; Add with carry (stack relative indirect indexed) ($92.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sta $0870.w,Y		; 99 70 08 ; Store accumulator to $0870.w,Y [Reads: Y Index, Accumulator]
	bit $60.b		; 24 60 ; Test bits $60.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	tsb $E066.w		; 0C 66 E0 ; Test and set bits $E066.w [Reads: Accumulator] [Flags: Z]
	ldy #$5F7F.w		; A0 7F 5F ; Load #$5F7F.w into Y register [Writes: Y Index] [Flags: NZ]
	.db $B0, $AF		; B0 AF ; Branch if carry set to $B0, $AF [Flow: branch]
	cmp $6FAF50.l,X		; DF 50 AF 6F ; Compare accumulator (long,X) $6FAF50.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	.db $90, $70		; 90 70 ; Branch if carry clear to $90, $70 [Flow: branch]
	eor $8F.b,S		; 43 8F ; Exclusive OR accumulator with stack relative $8F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $801F0F.l,X		; 7F 0F 1F 80 ; Add long $801F0F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	jsr $0F10.w		; 20 10 0F ; Jump to subroutine at $0F10.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $5FD0A0.l,X		; BF A0 D0 5F ; Load long $5FD0A0.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	lda $475734.l		; AF 34 57 47 ; Load long $475734.l into accumulator [Writes: Accumulator] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $40.b,S		; 03 40 ; OR accumulator with stack relative $40.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr $8810.w		; 20 10 88 ; Jump to subroutine at $8810.w [Writes: Stack Pointer] [Flow: call]
	and $84.b,S		; 23 84 ; AND accumulator with stack relative $84.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx #$1431.w		; E0 31 14 ; Compare #$1431.w with X register [Reads: X Index] [Flags: NCZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	jmp ($7EF4.w,X)		; 7C F4 7E ; Jump indirect indexed to ($7EF4.w,X) [Reads: X Index] [Flow: jump]
	inc $6B.b,X		; F6 6B ; Increment memory $6B.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	sbc [$8D.b],Y		; F7 8D ; Subtract with carry (long indexed) [$8D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $9A.b,S		; 63 9A ; Add with carry (stack relative) $9A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora ($FB.b),Y		; 11 FB ; OR accumulator with memory ($FB.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc ($FD.b)		; 72 FD ; Add with carry (indirect) ($FD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc $63.b,X		; 75 63 ; Add $63.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $04.b		; 64 04 ; Store zero to $04.b
	cop $67.b		; 02 67 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	adc ($5C.b)		; 72 5C ; Add with carry (indirect) ($5C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	trb $0C1E.w		; 1C 1E 0C ; Test and reset bits $0C1E.w [Reads: Accumulator] [Flags: Z]
	stx $6380.w		; 8E 80 63 ; Store X register to $6380.w [Reads: X Index]
.INDEX 8
	sep #$D9		; E2 D9
	sec		; 38 ; Set carry flag [Flags: C]
	bit $CC.b,X		; 34 CC ; Test bits $CC.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sta $DD9D.w,Y		; 99 9D DD ; Store accumulator to $DD9D.w,Y [Reads: Y Index, Accumulator]
	sbc $1D71.w		; ED 71 1D ; Subtract $1D71.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $7343F0.l		; 0F F0 43 73 ; OR accumulator with memory (long) $7343F0.l [Writes: Accumulator] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx #$2D.b		; E0 2D ; Compare #$2D.b with X register [Reads: X Index] [Flags: NCZ]
	sbc [$F7.b]		; E7 F7 ; Subtract with carry (long) [$F7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc $71E980.l,X		; 7F 80 E9 71 ; Add long $71E980.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $3A.b,X		; 36 3A ; Rotate left $3A.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $8400.w,X		; 1D 00 84 ; OR accumulator with memory $8400.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sty $08.b		; 84 08 ; Store Y register to $08.b [Reads: Y Index]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($E0.b,X)		; C1 E0 ; Compare accumulator ($E0.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $C5C6.w		; 0D C6 C5 ; Logical OR $C5C6.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $06.b		; E5 06 ; Subtract $06.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc ($E2.b,S),Y		; 73 E2 ; Add with carry (stack relative indirect indexed) ($E2.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sbc ($99.b,S),Y		; F3 99 ; Subtract with carry (stack relative indirect indexed) ($99.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	adc ($FC.b),Y		; 71 FC ; Add with carry ($FC.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sty $86.b		; 84 86 ; Store Y register to $86.b [Reads: Y Index]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	cpx $76F4.w		; EC F4 76 ; Compare $76F4.w with X register [Reads: X Index] [Flags: NCZ]
	ora $FF.b,S		; 03 FF ; OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $45.b		; 00 45 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $6F04BF.l,X		; 3F BF 04 6F ; AND accumulator with memory (long,X) $6F04BF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $00FF46.l,X		; FF 46 FF 00 ; Subtract with carry (long,X) $00FF46.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $4022FF.l		; 22 FF 22 40 ; Jump to subroutine long $4022FF.l [Writes: Stack Pointer] [Flow: call]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	cop $F8.b		; 02 F8 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FF44FD.l,X		; FF FD 44 FF ; Subtract with carry (long,X) $FF44FD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $FF0F02.l,X		; 1F 02 0F FF ; Logical OR long $FF0F02.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $070026.l,X		; FF 26 00 07 ; Subtract with carry (long,X) $070026.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $3C0746.l,X		; 3F 46 07 3C ; AND accumulator with memory (long,X) $3C0746.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $3C3F38.l,X		; 3F 38 3F 3C ; AND accumulator with memory (long,X) $3C3F38.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	mvp $3E,$3F		; 44 3F 3E ; Move block positive $3E,$3F [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $3C.b,S		; 03 3C ; OR accumulator with stack relative $3C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $25F8C0.l,X		; 3F C0 F8 25 ; AND accumulator with memory (long,X) $25F8C0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$45.b		; C0 45 ; Compare #$45.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $30, $3F		; 30 3F ; Branch if minus to $30, $3F [Flow: branch]
	sta $C8.b,S		; 83 C8 ; Store accumulator (stack relative) $C8.b,S [Reads: Stack Pointer, Accumulator]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $0E3F.w,X		; 1E 3F 0E ; Arithmetic shift left $0E3F.w,X [Reads: X Index] [Flags: NCZ]
	and $273F1E.l,X		; 3F 1E 3F 27 ; AND accumulator with memory (long,X) $273F1E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$01.b		; C0 01 ; Compare #$01.b with Y register [Reads: Y Index] [Flags: NCZ]
	sbc [$4C.b],Y		; F7 4C ; Subtract with carry (long indexed) [$4C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $FD.b,S		; 43 FD ; Exclusive OR accumulator with stack relative $FD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lsr $F81B.w		; 4E 1B F8 ; Logical shift right $F81B.w [Flags: NCZ]
	eor [$F1.b]		; 47 F1 ; Exclusive OR accumulator with memory (long) [$F1.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $FF0DFE.l		; 0F FE 0D FF ; OR accumulator with memory (long) $FF0DFE.l [Writes: Accumulator] [Flags: NZ]
	jmp $66DF.w		; 4C DF 66 ; Jump to $66DF.w [Flow: jump]
	adc ($60.b,X)		; 61 60 ; Add with carry ($60.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc ($2F.b,X)		; 61 2F ; Add with carry ($2F.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $F50E0D.l		; 0F 0D 0E F5 ; OR accumulator with memory (long) $F50E0D.l [Writes: Accumulator] [Flags: NZ]
	asl $07FB.w		; 0E FB 07 ; Arithmetic shift left $07FB.w [Flags: NCZ]
	sbc $3CF738.l		; EF 38 F7 3C ; Subtract with carry (long) $3CF738.l [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	trb $B384.w		; 1C 84 B3 ; Test and reset bits $B384.w [Reads: Accumulator] [Flags: Z]
	ora $E0.b,S		; 03 E0 ; OR accumulator with stack relative $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	ora [$C0.b]		; 07 C0 ; OR accumulator with memory (long) [$C0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $30, $78		; 30 78 ; Branch if minus to $30, $78 [Flow: branch]
	adc $0F3F7F.l,X		; 7F 7F 3F 0F ; Add long $0F3F7F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $C3		; 70 C3 ; Branch if overflow set to $70, $C3 [Flow: branch]
	and $B87E9A.l,X		; 3F 9A 7E B8 ; AND accumulator with memory (long,X) $B87E9A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	pea $C973.w		; F4 73 C9 ; Push absolute address $C973.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	eor [$83.b]		; 47 83 ; Exclusive OR accumulator with memory (long) [$83.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $D46EA6.l,X		; 3F A6 6E D4 ; AND accumulator with memory (long,X) $D46EA6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $0100.w		; 4D 00 01 ; Exclusive OR $0100.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0C.b		; 05 0C ; Logical OR $0C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	ora ($32.b),Y		; 11 32 ; OR accumulator with memory ($32.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $4F.b,S		; 03 4F ; OR accumulator with stack relative $4F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $7F.b		; 06 7F ; Arithmetic shift left $7F.b [Reads: Direct Page] [Flags: NCZ]
	rol $CDFF.w,X		; 3E FF CD ; Rotate left $CDFF.w,X [Reads: X Index] [Flags: NCZ]
	cmp $2EBF83.l		; CF 83 BF 2E ; Compare accumulator (long) $2EBF83.l [Reads: Accumulator] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lsr $BFC0.w,X		; 5E C0 BF ; Logical shift right $BFC0.w,X [Reads: X Index] [Flags: NCZ]
	stx $80B0.w		; 8E B0 80 ; Store X register to $80B0.w [Reads: X Index]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sta $226E31.l,X		; 9F 31 6E 22 ; Store accumulator (long,X) $226E31.l,X [Reads: Accumulator, X Index]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $70, $0C		; 70 0C ; Branch if overflow set to $70, $0C [Flow: branch]
	stz $0C.b,X		; 74 0C ; Store zero to $0C.b,X [Reads: X Index]
	ror $0C.b,X		; 76 0C ; Rotate right $0C.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	adc [$27.b],Y		; 77 27 ; Add with carry (long indexed) [$27.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $E0		; 80 E0 ; Branch always to $80, $E0 [Flow: branch]
	rol $4E.b		; 26 4E ; Rotate left $4E.b [Reads: Direct Page] [Flags: NCZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	sta $9E89.w,X		; 9D 89 9E ; Store accumulator to $9E89.w,X [Reads: Accumulator, X Index]
	sty $97.b		; 84 97 ; Store Y register to $97.b [Reads: Y Index]
	asl $1F.b		; 06 1F ; Arithmetic shift left $1F.b [Reads: Direct Page] [Flags: NCZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	and $AC7F9D.l,X		; 3F 9D 7F AC ; AND accumulator with memory (long,X) $AC7F9D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $606020.l		; 6F 20 60 60 ; Add with carry (long) $606020.l [Writes: Accumulator] [Flags: NCVZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	cpx #$C0.b		; E0 C0 ; Compare #$C0.b with X register [Reads: X Index] [Flags: NCZ]
	.db $80, $10		; 80 10 ; Branch always to $80, $10 [Flow: branch]
	cmp $38C830.l,X		; DF 30 C8 38 ; Compare accumulator (long,X) $38C830.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	sbc [$1F.b]		; E7 1F ; Subtract with carry (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $6F		; F0 6F ; Branch if equal to $F0, $6F [Flow: branch]
	sbc $7FFF70.l,X		; FF 70 FF 7F ; Subtract with carry (long,X) $7FFF70.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $83FF3F.l,X		; BF 3F FF 83 ; Load long $83FF3F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b)		; 12 00 ; OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $3020.w		; 0E 20 30 ; Arithmetic shift left $3020.w [Flags: NCZ]
	and $7F0040.l,X		; 3F 40 00 7F ; AND accumulator with memory (long,X) $7F0040.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $80, $FD		; 80 FD ; Branch always to $80, $FD [Flow: branch]
	bit $DE3F.w,X		; 3C 3F DE ; Test bits $DE3F.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	sta $76CFEE.l,X		; 9F EE CF 76 ; Store accumulator (long,X) $76CFEE.l,X [Reads: Accumulator, X Index]
	eor $AF.b		; 45 AF ; Exclusive OR $AF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $04.b,X		; 36 04 ; Rotate left $04.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $040C.w		; 1C 0C 04 ; Test and reset bits $040C.w [Reads: Accumulator] [Flags: Z]
	jsl $FF0144.l		; 22 44 01 FF ; Jump to subroutine long $FF0144.l [Writes: Stack Pointer] [Flow: call]
	sbc $840022.l,X		; FF 22 00 84 ; Subtract with carry (long,X) $840022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda ($00.b,X)		; A1 00 ; Load accumulator ($00.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $FF1300.l		; 22 00 13 FF ; Jump to subroutine long $FF1300.l [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $E781.w,X		; 7E 81 E7 ; Rotate right $E781.w,X [Reads: X Index] [Flags: NCZ]
	ror $7E91.w,X		; 7E 91 7E ; Rotate right $7E91.w,X [Reads: X Index] [Flags: NCZ]
	lda ($7E.b),Y		; B1 7E ; Load accumulator ($7E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $7E.b		; 85 7E ; Store accumulator to $7E.b [Reads: Accumulator]
	sta $3E.b,S		; 83 3E ; Store accumulator (stack relative) $3E.b,S [Reads: Stack Pointer, Accumulator]
	cmp $5A.b,S		; C3 5A ; Compare accumulator (stack relative) $5A.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	ror $0081.w,X		; 7E 81 00 ; Rotate right $0081.w,X [Reads: X Index] [Flags: NCZ]
	and $7E.b		; 25 7E ; Logical AND $7E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx $30.b		; E4 30 ; Compare $30.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	.db $10, $EF		; 10 EF ; Branch if plus to $10, $EF [Flow: branch]
	.db $10, $FF		; 10 FF ; Branch if plus to $10, $FF [Flow: branch]
	sbc $10FF07.l		; EF 07 FF 10 ; Subtract with carry (long) $10FF07.l [Writes: Accumulator] [Flags: NCVZ]
	sbc $EFD7FF.l		; EF FF D7 EF ; Subtract with carry (long) $EFD7FF.l [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	jsl $EF1410.l		; 22 10 14 EF ; Jump to subroutine long $EF1410.l [Writes: Stack Pointer] [Flow: call]
	sbc $10D7EF.l,X		; FF EF D7 10 ; Subtract with carry (long,X) $10D7EF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $14		; 10 14 ; Branch if plus to $10, $14 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc [$08.b],Y		; F7 08 ; Subtract with carry (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F71CEB.l,X		; FF EB 1C F7 ; Subtract with carry (long,X) $F71CEB.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sbc $F7F7FF.l,X		; FF FF F7 F7 ; Subtract with carry (long,X) $F7F7FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	trb $22.b		; 14 22 ; Test and reset bits $22.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $EB.b		; 05 EB ; Logical OR $EB.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc [$FF.b],Y		; F7 FF ; Subtract with carry (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$08.b],Y		; F7 08 ; Subtract with carry (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sty $10.b		; 84 10 ; Store Y register to $10.b [Reads: Y Index]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp [$10.b],Y		; D7 10 ; Compare accumulator (long indexed) [$10.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	sbc $4B8307.l		; EF 07 83 4B ; Subtract with carry (long) $4B8307.l [Writes: Accumulator] [Flags: NCVZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	jsl $D70610.l		; 22 10 06 D7 ; Jump to subroutine long $D70610.l [Writes: Stack Pointer] [Flow: call]
	sbc $10EFFF.l		; EF FF EF 10 ; Subtract with carry (long) $10EFFF.l [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $14		; 10 14 ; Branch if plus to $10, $14 [Flow: branch]
	eor $08.b,S		; 43 08 ; Exclusive OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $23F609.l,X		; FF 09 F6 23 ; Subtract with carry (long,X) $23F609.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $FE81.w,X		; FE 81 FE ; Increment memory $FE81.w,X [Reads: X Index] [Flags: NZ]
	sbc $08F7EA.l,X		; FF EA F7 08 ; Subtract with carry (long,X) $08F7EA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	trb $22.b		; 14 22 ; Test and reset bits $22.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $F6.b		; 05 F6 ; Logical OR $F6.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $EAFE.w,X		; FE FE EA ; Increment memory $EAFE.w,X [Reads: X Index] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	eor $DF.b,S		; 43 DF ; Exclusive OR accumulator with stack relative $DF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	asl $CF.b		; 06 CF ; Arithmetic shift left $CF.b [Reads: Direct Page] [Flags: NCZ]
	.db $70, $C3		; 70 C3 ; Branch if overflow set to $70, $C3 [Flow: branch]
	jmp ($7EE1.w,X)		; 7C E1 7E ; Jump indirect indexed to ($7EE1.w,X) [Reads: X Index] [Flow: jump]
	.db $F0, $84		; F0 84 ; Branch if equal to $F0, $84 [Flow: branch]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: NCZ]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $90, $03		; 90 03 ; Branch if carry clear to $90, $03 [Flow: branch]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ldy $3F73.w,X		; BC 73 3F ; Load Y register $3F73.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	.db $F0, $3F		; F0 3F ; Branch if equal to $F0, $3F [Flow: branch]
	cpx #$F8.b		; E0 F8 ; Compare #$F8.b with X register [Reads: X Index] [Flags: NCZ]
	cmp [$F0.b]		; C7 F0 ; Compare accumulator (long) [$F0.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora $FF2300.l		; 0F 00 23 FF ; OR accumulator with memory (long) $FF2300.l [Writes: Accumulator] [Flags: NZ]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($FF.b),Y		; 11 FF ; OR accumulator with memory ($FF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $D770CF.l,X		; 7F CF 70 D7 ; Add long $D770CF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $D25CAC.l		; 6F AC 5C D2 ; Add with carry (long) $D25CAC.l [Writes: Accumulator] [Flags: NCVZ]
	and ($C9.b,S),Y		; 33 C9 ; AND accumulator (stack relative indirect indexed) ($C9.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $227F00.l		; 2F 00 7F 22 ; AND accumulator with memory (long) $227F00.l [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0C.b,S		; 03 0C ; OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $10, $FF		; 10 FF ; Branch if plus to $10, $FF [Flow: branch]
	jsl $071300.l		; 22 00 13 07 ; Jump to subroutine long $071300.l [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	asl $C4.b		; 06 C4 ; Arithmetic shift left $C4.b [Reads: Direct Page] [Flags: NCZ]
	jsr ($7100.w,X)		; FC 00 71 ; Jump to subroutine indirect indexed ($7100.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $30, $FB		; 30 FB ; Branch if minus to $30, $FB [Flow: branch]
	sta ($CF.b,X)		; 81 CF ; Store accumulator ($CF.b,X) [Reads: Direct Page, Accumulator, X Index]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $8E.b,S		; 03 8E ; OR accumulator with stack relative $8E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $30.b		; 04 30 ; Test and set bits $30.b [Reads: Accumulator] [Flags: Z]
	and [$00.b],Y		; 37 00 ; AND accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora [$FF.b],Y		; 17 FF ; OR accumulator with memory (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F9.b		; 00 F9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	jsr ($F456.w,X)		; FC 56 F4 ; Jump to subroutine indirect indexed ($F456.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	cpx $DE55.w		; EC 55 DE ; Compare $DE55.w with X register [Reads: X Index] [Flags: NCZ]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $83.b		; 06 83 ; Arithmetic shift left $83.b [Reads: Direct Page] [Flags: NCZ]
	ora ($09.b,X)		; 01 09 ; Logical OR ($09.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	sbc $807F0F.l,X		; FF 0F 7F 80 ; Subtract with carry (long,X) $807F0F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda [$7F.b],Y		; B7 7F ; Load accumulator (long indexed) [$7F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpx $DB7F.w		; EC 7F DB ; Compare $DB7F.w with X register [Reads: X Index] [Flags: NCZ]
	adc $EE7FB7.l,X		; 7F B7 7F EE ; Add long $EE7FB7.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $DB7FED.l,X		; 7F ED 7F DB ; Add long $DB7FED.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $0F0027.l,X		; 7F 27 00 0F ; Add long $0F0027.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $ED01.w,X		; FE 01 ED ; Increment memory $ED01.w,X [Reads: X Index] [Flags: NZ]
	inc $FF36.w,X		; FE 36 FF ; Increment memory $FF36.w,X [Reads: X Index] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	sbc $76FFEC.l,X		; FF EC FF 76 ; Subtract with carry (long,X) $76FFEC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $DAFFB6.l,X		; FF B6 FF DA ; Subtract with carry (long,X) $DAFFB6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $090027.l,X		; FF 27 00 09 ; Subtract with carry (long,X) $090027.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $1F.b,S		; E3 1F ; Subtract stack-relative $1F.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	cmp ($2F.b,S),Y		; D3 2F ; Compare accumulator (stack relative indirect indexed) ($2F.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ora [$EF.b],Y		; 17 EF ; OR accumulator with memory (long indexed) [$EF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	sbc [$1C.b]		; E7 1C ; Subtract with carry (long) [$1C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	eor $E3.b		; 45 E3 ; Exclusive OR $E3.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $000123.l,X		; 1F 23 01 00 ; Logical OR long $000123.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($43.b,X)		; 01 43 ; Logical OR ($43.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $F00A00.l,X		; FF 00 0A F0 ; Subtract with carry (long,X) $F00A00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $180F90.l		; 0F 90 0F 18 ; OR accumulator with memory (long) $180F90.l [Writes: Accumulator] [Flags: NZ]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $0F0900.l		; 22 00 09 0F ; Jump to subroutine long $0F0900.l [Writes: Stack Pointer] [Flow: call]
	adc $F0F7E7.l		; 6F E7 F7 F0 ; Add with carry (long) $F0F7E7.l [Writes: Accumulator] [Flags: NCVZ]
	sbc [$FF.b],Y		; F7 FF ; Subtract with carry (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $06FF.w		; 0C FF 06 ; Test and set bits $06FF.w [Reads: Accumulator] [Flags: Z]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	sbc $F00103.l,X		; FF 03 01 F0 ; Subtract with carry (long,X) $F00103.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	and $FC.b		; 25 FC ; Logical AND $FC.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $1CC738.l		; 0F 38 C7 1C ; OR accumulator with memory (long) $1CC738.l [Writes: Accumulator] [Flags: NZ]
	sbc $CE.b,S		; E3 CE ; Subtract stack-relative $CE.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	sbc ($E7.b),Y		; F1 E7 ; Subtract with carry ($E7.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sbc ($3C.b,S),Y		; F3 3C ; Subtract with carry (stack relative indirect indexed) ($3C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FC1F.w,Y		; F9 1F FC ; Subtract with carry $FC1F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $26079E.l		; 0F 9E 07 26 ; OR accumulator with memory (long) $26079E.l [Writes: Accumulator] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sta ($6C.b,S),Y		; 93 6C ; Store accumulator (stack relative indirect indexed) ($6C.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	adc [$E8.b],Y		; 77 E8 ; Add with carry (long indexed) [$E8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$CF.b],Y		; F7 CF ; Subtract with carry (long indexed) [$CF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $8F		; F0 8F ; Branch if equal to $F0, $8F [Flow: branch]
	.db $F0, $1F		; F0 1F ; Branch if equal to $F0, $1F [Flow: branch]
	cpx #$26.b		; E0 26 ; Compare #$26.b with X register [Reads: X Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $807F46.l		; 0F 46 7F 80 ; OR accumulator with memory (long) $807F46.l [Writes: Accumulator] [Flags: NZ]
	brk $8C.b		; 00 8C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor [$7F.b]		; 47 7F ; Exclusive OR accumulator with memory (long) [$7F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	stz $1F03.w,X		; 9E 03 1F ; Store zero to $1F03.w,X [Reads: X Index]
	ora $230C01.l,X		; 1F 01 0C 23 ; Logical OR long $230C01.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $0001.w,X		; 1E 01 00 ; Arithmetic shift left $0001.w,X [Reads: X Index] [Flags: NCZ]
	brk $29.b		; 00 29 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $3F3F04.l,X		; 7F 04 3F 3F ; Add long $3F3F04.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $24FF1F.l,X		; 1F 1F FF 24 ; Logical OR long $24FF1F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $80, $05		; 80 05 ; Branch always to $80, $05 [Flow: branch]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: NCZ]
	adc $400000.l,X		; 7F 00 00 40 ; Add long $400000.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $3F.b		; 45 3F ; Exclusive OR $3F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $00C083.l,X		; 7F 83 C0 00 ; Add long $00C083.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $FF.b,S		; 03 FF ; OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	lda $E08022.l,X		; BF 22 80 E0 ; Load long $E08022.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	bit #$80FF.w		; 89 FF 80 ; Test bits #$80FF.w with accumulator [Reads: Accumulator] [Flags: Z]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta [$C7.b]		; 87 C7 ; Store accumulator (long) [$C7.b] [Reads: Direct Page, Accumulator]
	eor $FB.b,S		; 43 FB ; Exclusive OR accumulator with stack relative $FB.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $7CFD.w,Y		; 79 FD 7C ; Add $7CFD.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx $DF7E.w,Y		; BE 7E DF ; Load X register $DF7E.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	lda $F7DFEF.l,X		; BF EF DF F7 ; Load long $F7DFEF.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $053B87.l		; EF 87 3B 05 ; Subtract with carry (long) $053B87.l [Writes: Accumulator] [Flags: NCVZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	cpx #$FF.b		; E0 FF ; Compare #$FF.b with X register [Reads: X Index] [Flags: NCZ]
	jsr ($FAFE.w,X)		; FC FE FA ; Jump to subroutine indirect indexed ($FAFE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $F0F5.w,X		; FD F5 F0 ; Subtract with carry $F0F5.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sbc $6949.w,Y		; F9 49 69 ; Subtract with carry $6949.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $BBCD.w,X		; 9D CD BB ; Store accumulator to $BBCD.w,X [Reads: Accumulator, X Index]
	jsr ($F2F9.w,X)		; FC F9 F2 ; Jump to subroutine indirect indexed ($F2F9.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc [$46.b]		; E7 46 ; Subtract with carry (long) [$46.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	cld		; D8 ; Clear decimal flag [Flags: D]
	eor [$90.b],Y		; 57 90 ; Exclusive OR accumulator with memory (long indexed) [$90.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tsb $08B7.w		; 0C B7 08 ; Test and set bits $08B7.w [Reads: Accumulator] [Flags: Z]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	cmp $A06040.l,X		; DF 40 60 A0 ; Compare accumulator (long,X) $A06040.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	rol $10C1.w,X		; 3E C1 10 ; Rotate left $10C1.w,X [Reads: X Index] [Flags: NCZ]
	and [$6F.b]		; 27 6F ; AND accumulator with memory (long) [$6F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc $001F3F.l,X		; 7F 3F 1F 00 ; Add long $001F3F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	nop		; EA ; No operation
	and $55.b,S		; 23 55 ; AND accumulator with stack relative $55.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $BA.b		; 06 BA ; Arithmetic shift left $BA.b [Reads: Direct Page] [Flags: NCZ]
	ora $1B74.w		; 0D 74 1B ; Logical OR $1B74.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $6F5030.l		; EF 30 50 6F ; Subtract with carry (long) $6F5030.l [Writes: Accumulator] [Flags: NCVZ]
	ldy #$DF.b		; A0 DF ; Load #$DF.b into Y register [Writes: Y Index] [Flags: NZ]
	sbc $B81C00.l,X		; FF 00 1C B8 ; Subtract with carry (long,X) $B81C00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $E0		; 70 E0 ; Branch if overflow set to $70, $E0 [Flow: branch]
	cpy #$80.b		; C0 80 ; Compare #$80.b with Y register [Reads: Y Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $80.b,S		; C3 80 ; Compare accumulator (stack relative) $80.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	.db $80, $78		; 80 78 ; Branch always to $80, $78 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	ror $8785.w,X		; 7E 85 87 ; Rotate right $8785.w,X [Reads: X Index] [Flags: NCZ]
	.db $62, $03, $F8		; 62 03 F8 ; Push effective relative address $62, $03, $F8 [Writes: Stack Pointer]
	ora ($8D.b,X)		; 01 8D ; Logical OR ($8D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($87.b,X)		; 01 87 ; Logical OR ($87.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jsr ($FEFE.w,X)		; FC FE FE ; Jump to subroutine indirect indexed ($FEFE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $FF40BF.l,X		; FF BF 40 FF ; Subtract with carry (long,X) $FF40BF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $20C020.l,X		; 1F 20 C0 20 ; Logical OR long $20C020.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $2000FF.l,X		; DF FF 00 20 ; Compare accumulator (long,X) $2000FF.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	cpy #$2F.b		; C0 2F ; Compare #$2F.b with Y register [Reads: Y Index] [Flags: NCZ]
	cpy #$EF.b		; C0 EF ; Compare #$EF.b with Y register [Reads: Y Index] [Flags: NCZ]
	jsl $1F0200.l		; 22 00 02 1F ; Jump to subroutine long $1F0200.l [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $D6091F.l		; 22 1F 09 D6 ; Jump to subroutine long $D6091F.l [Writes: Stack Pointer] [Flow: call]
	adc $807FD5.l,X		; 7F D5 7F 80 ; Add long $807FD5.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $FF00FF.l,X		; 7F FF 00 FF ; Add long $FF00FF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $008044.l,X		; 7F 44 80 00 ; Add long $008044.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	tsb $7F7F.w		; 0C 7F 7F ; Test and set bits $7F7F.w [Reads: Accumulator] [Flags: Z]
	brk $6A.b		; 00 6A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $00FFAA.l,X		; FF AA FF 00 ; Subtract with carry (long,X) $00FFAA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FF00FF.l,X		; FF FF 00 FF ; Subtract with carry (long,X) $FF00FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $010123.l,X		; FF 23 01 01 ; Subtract with carry (long,X) $010123.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cop $FE.b		; 02 FE ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $4700.w,X		; FE 00 47 ; Increment memory $4700.w,X [Reads: X Index] [Flags: NZ]
	sbc ($0F.b,S),Y		; F3 0F ; Subtract with carry (stack relative indirect indexed) ($0F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora [$D3.b]		; 07 D3 ; OR accumulator with memory (long) [$D3.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $B777E8.l		; 6F E8 77 B7 ; Add with carry (long) $B777E8.l [Writes: Accumulator] [Flags: NCVZ]
	sec		; 38 ; Set carry flag [Flags: C]
	lda $01243F.l,X		; BF 3F 24 01 ; Load long $01243F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sbc $7BFC70.l,X		; FF 70 FC 7B ; Subtract with carry (long,X) $7BFC70.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($433B.w,X)		; FC 3B 43 ; Jump to subroutine indirect indexed ($433B.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $004500.l,X		; FF 00 45 00 ; Subtract with carry (long,X) $004500.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $7B7002.l,X		; FF 02 70 7B ; Subtract with carry (long,X) $7B7002.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	eor $2703FF.l		; 4F FF 03 27 ; Exclusive OR accumulator with memory (long) $2703FF.l [Writes: Accumulator] [Flags: NZ]
	jsr ($8F02.w,X)		; FC 02 8F ; Jump to subroutine indirect indexed ($8F02.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora ($C7.b,X)		; 01 C7 ; Logical OR ($C7.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor $01.b,S		; 43 01 ; Exclusive OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc [$00.b]		; E7 00 ; Subtract with carry (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta ($44.b,X)		; 81 44 ; Store accumulator ($44.b,X) [Reads: Direct Page, Accumulator, X Index]
	sbc $010CC1.l,X		; FF C1 0C 01 ; Subtract with carry (long,X) $010CC1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $3A7201.l,X		; FF 01 72 3A ; Subtract with carry (long,X) $3A7201.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	rep #$C2		; C2 C2 ; Reset processor status bits #$C2 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	eor $5543A0.l,X		; 5F A0 43 55 ; Exclusive OR accumulator with memory (long,X) $5543A0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ora #$2AD5.w		; 09 D5 2A ; Logical OR #$2AD5.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc [$08.b],Y		; F7 08 ; Subtract with carry (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $0DE2.w,X		; 1D E2 0D ; OR accumulator with memory $0DE2.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($C7.b)		; F2 C7 ; Subtract with carry (indirect) ($C7.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sec		; 38 ; Set carry flag [Flags: C]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cmp $3A.b		; C5 3A ; Compare $3A.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sbc $1A.b,X		; F5 1A ; Subtract $1A.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $9A.b,X		; 75 9A ; Add $9A.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and [$D8.b],Y		; 37 D8 ; AND accumulator with memory (long indexed) [$D8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc [$18.b],Y		; F7 18 ; Subtract with carry (long indexed) [$18.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $44.b,X		; F5 44 ; Subtract $44.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	and $19.b,X		; 35 19 ; Logical AND $19.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	cpy #$40.b		; C0 40 ; Compare #$40.b with Y register [Reads: Y Index] [Flags: NCZ]
	adc $C03FBF.l,X		; 7F BF 3F C0 ; Add long $C03FBF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy #$FF.b		; A0 FF ; Load #$FF.b into Y register [Writes: Y Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $C05F9F.l,X		; FF 9F 5F C0 ; Subtract with carry (long,X) $C05F9F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $233F7F.l,X		; 3F 7F 3F 23 ; AND accumulator with memory (long,X) $233F7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $8D83.w		; 20 83 8D ; Jump to subroutine at $8D83.w [Writes: Stack Pointer] [Flow: call]
	ora ($0C.b,X)		; 01 0C ; Logical OR ($0C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $80FF7F.l,X		; FF 7F FF 80 ; Subtract with carry (long,X) $80FF7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FE807F.l,X		; FF 7F 80 FE ; Subtract with carry (long,X) $FE807F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($BF.b,X)		; 01 BF ; Logical OR ($BF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	ora $0024E0.l,X		; 1F E0 24 00 ; Logical OR long $0024E0.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $4E1D.w		; 0E 1D 4E ; Arithmetic shift left $4E1D.w [Flags: NCZ]
	sbc [$FB.b]		; E7 FB ; Subtract with carry (long) [$FB.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$ED.b]		; E7 ED ; Subtract with carry (long) [$ED.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	dec $B5.b,X		; D6 B5 ; Decrement memory $B5.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	cmp $A6.b		; C5 A6 ; Compare $A6.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp $A4.b,S		; C3 A4 ; Compare accumulator (stack relative) $A4.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	ldy $C343.w,X		; BC 43 C3 ; Load Y register $C343.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ldy $19.b		; A4 19 ; Load $19.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	cpx #$C0.b		; E0 C0 ; Compare #$C0.b with X register [Reads: X Index] [Flags: NCZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta ($99.b,X)		; 81 99 ; Store accumulator ($99.b,X) [Reads: Direct Page, Accumulator, X Index]
	sta $5B87.w,Y		; 99 87 5B ; Store accumulator to $5B87.w,Y [Reads: Y Index, Accumulator]
	lda $6B.b		; A5 6B ; Load $6B.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dec $B9.b,X		; D6 B9 ; Decrement memory $B9.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	adc $DA.b		; 65 DA ; Add $DA.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ldx $FD47.w,Y		; BE 47 FD ; Load X register $FD47.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ora $FA.b,X		; 15 FA ; OR accumulator with memory $FA.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	asl $EC.b,X		; 16 EC ; Arithmetic shift left $EC.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	and ($20.b,S),Y		; 33 20 ; AND accumulator (stack relative indirect indexed) ($20.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $10, $22		; 10 22 ; Branch if plus to $10, $22 [Flow: branch]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $02.b		; 45 02 ; Exclusive OR $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($80.b,X)		; 81 80 ; Store accumulator ($80.b,X) [Reads: Direct Page, Accumulator, X Index]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rol $C1.b,X		; 36 C1 ; Rotate left $C1.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc [$00.b],Y		; F7 00 ; Subtract with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	jsr ($1F04.w,X)		; FC 04 1F ; Jump to subroutine indirect indexed ($1F04.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpx #$FF.b		; E0 FF ; Compare #$FF.b with X register [Reads: X Index] [Flags: NCZ]
	ora $049070.l		; 0F 70 90 04 ; OR accumulator with memory (long) $049070.l [Writes: Accumulator] [Flags: NZ]
	ora $070C.w		; 0D 0C 07 ; Logical OR $070C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $3213.w,Y		; F9 13 32 ; Subtract with carry $3213.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	stx $E5.b		; 86 E5 ; Store X register to $E5.b [Reads: X Index]
	ora $1BCB.w		; 0D CB 1B ; Logical OR $1BCB.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $36.b,X		; 16 36 ; Arithmetic shift left $36.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc $DA2C.w		; ED 2C DA ; Subtract $DA2C.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	and $31.b,X		; 35 31 ; Logical AND $31.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $32D9.w		; 0C D9 32 ; Test and set bits $32D9.w [Reads: Accumulator] [Flags: Z]
	cpx $C9.b		; E4 C9 ; Compare $C9.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($27.b,S),Y		; 13 27 ; OR accumulator (stack relative indirect indexed) ($27.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $C3D3.w		; CE D3 C3 ; Decrement $C3D3.w [Flags: NZ]
	cmp $B5C1.w,Y		; D9 C1 B5 ; Compare accumulator $B5C1.w,Y [Reads: Y Index] [Flags: NCZ]
	sta ($63.b,X)		; 81 63 ; Store accumulator ($63.b,X) [Reads: Direct Page, Accumulator, X Index]
	brk $C3.b		; 00 C3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($87.b,X)		; 01 87 ; Logical OR ($87.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $FF.b,S		; 03 FF ; OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $3C.b		; 04 3C ; Test and set bits $3C.b [Reads: Accumulator] [Flags: Z]
	rol $227E.w,X		; 3E 7E 22 ; Rotate left $227E.w,X [Reads: X Index] [Flags: NCZ]
	inc $FC13.w,X		; FE 13 FC ; Increment memory $FC13.w,X [Reads: X Index] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $DE.b,X		; 15 DE ; OR accumulator with memory $DE.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sta ($75.b,X)		; 81 75 ; Store accumulator ($75.b,X) [Reads: Direct Page, Accumulator, X Index]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	lda $57EB03.l,X		; BF 03 EB 57 ; Load long $57EB03.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc [$0F.b],Y		; 77 0F ; Add with carry (long indexed) [$0F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $00F0AF.l,X		; DF AF F0 00 ; Compare accumulator (long,X) $00F0AF.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	cpx #$60.b		; E0 60 ; Compare #$60.b with X register [Reads: X Index] [Flags: NCZ]
	sta $3E.b,S		; 83 3E ; Store accumulator (stack relative) $3E.b,S [Reads: Stack Pointer, Accumulator]
	cop $16.b		; 02 16 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $9F108F.l		; 0F 8F 10 9F ; OR accumulator with memory (long) $9F108F.l [Writes: Accumulator] [Flags: NZ]
	and $E85BB0.l		; 2F B0 5B E8 ; AND accumulator with memory (long) $E85BB0.l [Writes: Accumulator] [Flags: NZ]
	and ($CE.b,S),Y		; 33 CE ; AND accumulator (stack relative indirect indexed) ($CE.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $FF83.w,X		; 7D 83 FF ; Add $FF83.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($7F.b,X)		; 01 7F ; Logical OR ($7F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $70, $60		; 70 60 ; Branch if overflow set to $70, $60 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	tsb $24.b		; 04 24 ; Test and set bits $24.b [Reads: Accumulator] [Flags: Z]
	brk $84.b		; 00 84 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $0901.w,X		; 9D 01 09 ; Store accumulator to $0901.w,X [Reads: Accumulator, X Index]
	brk $32.b		; 00 32 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy #$BF.b		; A0 BF ; Load #$BF.b into Y register [Writes: Y Index] [Flags: NZ]
	adc $2DF2.w		; 6D F2 2D ; Add $2DF2.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp $22FF20.l,X		; DF 20 FF 22 ; Compare accumulator (long,X) $22FF20.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $0022.w		; 4D 22 00 ; Exclusive OR $0022.w with accumulator [Writes: Accumulator] [Flags: NZ]
	eor $E3.b,S		; 43 E3 ; Exclusive OR accumulator with stack relative $E3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0FF307.l,X		; 1F 07 F3 0F ; Logical OR long $0FF307.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ora [$FD.b]		; 07 FD ; OR accumulator with memory (long) [$FD.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sbc [$0C.b],Y		; F7 0C ; Subtract with carry (long indexed) [$0C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $F3.b,S		; 43 F3 ; Exclusive OR accumulator with stack relative $F3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $050124.l		; 0F 24 01 05 ; OR accumulator with memory (long) $050124.l [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $00.b		; 45 00 ; Exclusive OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $E045.w,X		; FE 45 E0 ; Increment memory $E045.w,X [Reads: X Index] [Flags: NZ]
	inc $6004.w,X		; FE 04 60 ; Increment memory $6004.w,X [Reads: X Index] [Flags: NZ]
	sbc [$E7.b],Y		; F7 E7 ; Subtract with carry (long indexed) [$E7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($0D.b,X)		; 01 0D ; Logical OR ($0D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $6506ED.l		; 22 ED 06 65 ; Jump to subroutine long $6506ED.l [Writes: Stack Pointer] [Flow: call]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$FF.b		; C0 FF ; Compare #$FF.b with Y register [Reads: Y Index] [Flags: NCZ]
	sbc $FF437F.l,X		; FF 7F 43 FF ; Subtract with carry (long,X) $FF437F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $45.b		; 00 45 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora [$24.b]		; 07 24 ; OR accumulator with memory (long) [$24.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$37.b],Y		; 17 37 ; OR accumulator with memory (long indexed) [$37.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and [$43.b],Y		; 37 43 ; AND accumulator with memory (long indexed) [$43.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $E30700.l,X		; FF 00 07 E3 ; Subtract with carry (long,X) $E30700.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $3DC3.w,X		; 1D C3 3D ; OR accumulator with memory $3DC3.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp [$39.b]		; C7 39 ; Compare accumulator (long) [$39.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp $DF4330.l		; CF 30 43 DF ; Compare accumulator (long) $DF4330.l [Reads: Accumulator] [Flags: NCZ]
	jsr $2007.w		; 20 07 20 ; Jump to subroutine at $2007.w [Writes: Stack Pointer] [Flow: call]
	brk $1D.b		; 00 1D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $3039.w,X		; 3D 39 30 ; AND accumulator with memory $3039.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rol $2F.b		; 26 2F ; Rotate left $2F.b [Reads: Direct Page] [Flags: NCZ]
	sta $14.b,S		; 83 14 ; Store accumulator (stack relative) $14.b,S [Reads: Stack Pointer, Accumulator]
	cop $0B.b		; 02 0B ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0A.b,X		; F5 0A ; Subtract $0A.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $F00FC0.l,X		; 3F C0 0F F0 ; AND accumulator with memory (long,X) $F00FC0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $7C.b,S		; 83 7C ; Store accumulator (stack relative) $7C.b,S [Reads: Stack Pointer, Accumulator]
	cpx #$1F.b		; E0 1F ; Compare #$1F.b with X register [Reads: X Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora [$26.b]		; 07 26 ; OR accumulator with memory (long) [$26.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $EF		; 80 EF ; Branch always to $80, $EF [Flow: branch]
	.db $10, $43		; 10 43 ; Branch if plus to $10, $43 [Flow: branch]
	cpx #$1F.b		; E0 1F ; Compare #$1F.b with X register [Reads: X Index] [Flags: NCZ]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000C0E.l,X		; FF 0E 0C 00 ; Subtract with carry (long,X) $000C0E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $DFD000.l,X		; FF 00 D0 DF ; Subtract with carry (long,X) $DFD000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $6E0E00.l,X		; DF 00 0E 6E ; Compare accumulator (long,X) $6E0E00.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ror $00FF.w,X		; 7E FF 00 ; Rotate right $00FF.w,X [Reads: X Index] [Flags: NCZ]
	eor $3FC3.w		; 4D C3 3F ; Exclusive OR $3FC3.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $01.b		; 26 01 ; Rotate left $01.b [Reads: Direct Page] [Flags: NCZ]
	ora [$3F.b],Y		; 17 3F ; OR accumulator with memory (long indexed) [$3F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$F3.b		; C0 F3 ; Compare #$F3.b with Y register [Reads: Y Index] [Flags: NCZ]
	brk $E3.b		; 00 E3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($E7.b,X)		; 01 E7 ; Logical OR ($E7.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($E7.b,X)		; 01 E7 ; Logical OR ($E7.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $1DE3.w,Y		; 19 E3 1D ; OR accumulator with memory $1DE3.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $0CC000.l,X		; FF 00 C0 0C ; Subtract with carry (long,X) $0CC000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $C1D9.w,X		; 9D D9 C1 ; Store accumulator to $C1D9.w,X [Reads: Accumulator, X Index]
	eor $001D.w,Y		; 59 1D 00 ; Exclusive OR accumulator with memory $001D.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor [$C3.b]		; 47 C3 ; Exclusive OR accumulator with memory (long) [$C3.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy $01.b		; A4 01 ; Load $01.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	ldy $C343.w,X		; BC 43 C3 ; Load Y register $C343.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ldy $1F.b		; A4 1F ; Load $1F.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	cmp ($B2.b),Y		; D1 B2 ; Compare accumulator ($B2.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	sta $9898.w,Y		; 99 98 98 ; Store accumulator to $9898.w,Y [Reads: Y Index, Accumulator]
	sta $9981.w,Y		; 99 81 99 ; Store accumulator to $9981.w,Y [Reads: Y Index, Accumulator]
	sta $DB8C.w,Y		; 99 8C DB ; Store accumulator to $DB8C.w,Y [Reads: Y Index, Accumulator]
	stz $B4.b		; 64 B4 ; Store zero to $B4.b
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sbc [$0C.b],Y		; F7 0C ; Subtract with carry (long indexed) [$0C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ora [$7C.b]		; 07 7C ; OR accumulator with memory (long) [$7C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $EF.b,S		; 03 EF ; OR accumulator with stack relative $EF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B8.b		; 00 B8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($20.b,X)		; 01 20 ; Logical OR ($20.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpx #$F0.b		; E0 F0 ; Compare #$F0.b with X register [Reads: X Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsl $1884FF.l		; 22 FF 84 18 ; Jump to subroutine long $1884FF.l [Writes: Stack Pointer] [Flow: call]
	ora $83.b,S		; 03 83 ; OR accumulator with stack relative $83.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	stz $0501.w		; 9C 01 05 ; Store zero to $0501.w
	ora $FC.b,S		; 03 FC ; OR accumulator with stack relative $FC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $1C01.w,X		; FE 01 1C ; Increment memory $1C01.w,X [Reads: X Index] [Flags: NZ]
	cpx $26.b		; E4 26 ; Compare $26.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $FB.b,S		; 03 FB ; OR accumulator with stack relative $FB.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc ($FD.b),Y		; F1 FD ; Subtract with carry ($FD.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $3A.b,S		; 03 3A ; OR accumulator with stack relative $3A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $F4.b		; C6 F4 ; Decrement $F4.b [Reads: Direct Page] [Flags: NZ]
	tsb $18E8.w		; 0C E8 18 ; Test and set bits $18E8.w [Reads: Accumulator] [Flags: Z]
	and [$F5.b],Y		; 37 F5 ; AND accumulator with memory (long indexed) [$F5.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tsb $0409.w		; 0C 09 04 ; Test and set bits $0409.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$0A.b]		; 07 0A ; OR accumulator with memory (long) [$0A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $6E.b,X		; F6 6E ; Increment memory $6E.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	adc [$6A.b]		; 67 6A ; Add with carry (long) [$6A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc [$76.b],Y		; 77 76 ; Add with carry (long indexed) [$76.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $77.b,S		; 43 77 ; Exclusive OR accumulator with stack relative $77.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc ($0F.b)		; 72 0F ; Add with carry (indirect) ($0F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $1C1D.w,Y		; 39 1D 1C ; AND accumulator with memory $1C1D.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $050E.w		; 0E 0E 05 ; Arithmetic shift left $050E.w [Flags: NCZ]
	sta $89.b,X		; 95 89 ; Store accumulator to $89.b,X [Reads: Accumulator, X Index]
	sta $C68D.w		; 8D 8D C6 ; Store accumulator to $C68D.w [Reads: Accumulator]
	sbc $F1.b,S		; E3 F1 ; Subtract stack-relative $F1.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	sbc $43B8.w,X		; FD B8 43 ; Subtract with carry $43B8.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $0F1B68.l		; 2F 68 1B 0F ; AND accumulator with memory (long) $0F1B68.l [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	sta $C847C8.l		; 8F C8 47 C8 ; Store accumulator (long) $C847C8.l [Reads: Accumulator]
	ora $90BF80.l		; 0F 80 BF 90 ; OR accumulator with memory (long) $90BF80.l [Writes: Accumulator] [Flags: NZ]
	cop $90.b		; 02 90 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $B0		; 90 B0 ; Branch if carry clear to $90, $B0 [Flow: branch]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	.db $70, $60		; 70 60 ; Branch if overflow set to $70, $60 [Flow: branch]
	sbc $01FF00.l,X		; FF 00 FF 01 ; Subtract with carry (long,X) $01FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rep #$03		; C2 03 ; Reset processor status bits #$03 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	sbc ($7E.b,X)		; E1 7E ; Subtract with carry ($7E.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $848541.l,X		; FF 41 85 84 ; Subtract with carry (long,X) $848541.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $E0.b		; 04 E0 ; Test and set bits $E0.b [Reads: Accumulator] [Flags: Z]
	jsl $3C0000.l		; 22 00 00 3C ; Jump to subroutine long $3C0000.l [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $0000.w,X		; 3C 00 00 ; Test bits $0000.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora [$E7.b]		; 07 E7 ; OR accumulator with memory (long) [$E7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $9A3CCC.l,X		; 1F CC 3C 9A ; Logical OR long $9A3CCC.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy $B97E.w,X		; BC 7E B9 ; Load Y register $B97E.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	adc $7B93.w,X		; 7D 93 7B ; Add $7B93.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta [$77.b]		; 87 77 ; Store accumulator (long) [$77.b] [Reads: Direct Page, Accumulator]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	sbc $250000.l,X		; FF 00 00 25 ; Subtract with carry (long,X) $250000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $000001.l,X		; FF 01 00 00 ; Subtract with carry (long,X) $000001.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $FF.b		; 24 FF ; Test bits $FF.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	stx $21.b		; 86 21 ; Store X register to $21.b [Reads: X Index]
	tsb $4F.b		; 04 4F ; Test and set bits $4F.b [Reads: Accumulator] [Flags: Z]
	sbc $FF2881.l,X		; FF 81 28 FF ; Subtract with carry (long,X) $FF2881.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx $2F.b		; E4 2F ; Compare $2F.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $03.b		; 84 03 ; Store Y register to $03.b [Reads: Y Index]
	sty $4B.b		; 84 4B ; Store Y register to $4B.b [Reads: Y Index]
	sta [$78.b]		; 87 78 ; Store accumulator (long) [$78.b] [Reads: Direct Page, Accumulator]
	sty $7B.b		; 84 7B ; Store Y register to $7B.b [Reads: Y Index]
	eor $87.b,S		; 43 87 ; Exclusive OR accumulator with stack relative $87.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora $CF.b		; 05 CF ; Logical OR $CF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $30, $FF		; 30 FF ; Branch if minus to $30, $FF [Flow: branch]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $25		; 30 25 ; Branch if minus to $30, $25 [Flow: branch]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $F8.b		; 04 F8 ; Test and set bits $F8.b [Reads: Accumulator] [Flags: Z]
	tsb $FA.b		; 04 FA ; Test and set bits $FA.b [Reads: Accumulator] [Flags: Z]
	jsr ($0403.w,X)		; FC 03 04 ; Jump to subroutine indirect indexed ($0403.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	eor $FC.b,S		; 43 FC ; Exclusive OR accumulator with stack relative $FC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $FF01.w,X		; FE 01 FF ; Increment memory $FF01.w,X [Reads: X Index] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($25.b,X)		; 01 25 ; Logical OR ($25.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $84.b		; 00 84 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $04.b		; 84 04 ; Store Y register to $04.b [Reads: Y Index]
	asl $40.b		; 06 40 ; Arithmetic shift left $40.b [Reads: Direct Page] [Flags: NCZ]
	sbc $FB06.w,X		; FD 06 FB ; Subtract with carry $FB06.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $09E4.w		; 0D E4 09 ; Logical OR $09E4.w with accumulator [Writes: Accumulator] [Flags: NZ]
	eor $F6.b,S		; 43 F6 ; Exclusive OR accumulator with stack relative $F6.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($12.b,S),Y		; 13 12 ; OR accumulator (stack relative indirect indexed) ($12.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $20DF6F.l		; 8F 6F DF 20 ; Store accumulator (long) $20DF6F.l [Reads: Accumulator]
	cpx #$1F.b		; E0 1F ; Compare #$1F.b with X register [Reads: X Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sta [$7F.b]		; 87 7F ; Store accumulator (long) [$7F.b] [Reads: Direct Page, Accumulator]
	ldy #$9F.b		; A0 9F ; Load #$9F.b into Y register [Writes: Y Index] [Flags: NZ]
	jsr $6DD2.w		; 20 D2 6D ; Jump to subroutine at $6DD2.w [Writes: Stack Pointer] [Flow: call]
	cmp $23106D.l,X		; DF 6D 10 23 ; Compare accumulator (long,X) $23106D.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $0040.w		; 2E 40 00 ; Rotate left $0040.w [Flags: NCZ]
	brk $C8.b		; 00 C8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $BCC4.w,Y		; B9 C4 BC ; Load $BCC4.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
.INDEX 8
	sep #$9E		; E2 9E
	sbc ($CF.b),Y		; F1 CF ; Subtract with carry ($CF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc [$FC.b]		; E7 FC ; Subtract with carry (long) [$FC.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($FE.b,S),Y		; F3 FE ; Subtract with carry (stack relative indirect indexed) ($FE.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FCFF.w,Y		; F9 FF FC ; Subtract with carry $FCFF.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	stx $83.b		; 86 83 ; Store X register to $83.b [Reads: X Index]
	sta ($C0.b,X)		; 81 C0 ; Store accumulator ($C0.b,X) [Reads: Direct Page, Accumulator, X Index]
	cpx #$F0.b		; E0 F0 ; Compare #$F0.b with X register [Reads: X Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($00DF.w,X)		; FC DF 00 ; Jump to subroutine indirect indexed ($00DF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $80, $3F		; 80 3F ; Branch always to $80, $3F [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc [$FF.b],Y		; F7 FF ; Subtract with carry (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sbc [$08.b],Y		; F7 08 ; Subtract with carry (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$FF.b],Y		; F7 FF ; Subtract with carry (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $23F780.l,X		; 3F 80 F7 23 ; AND accumulator with memory (long,X) $23F780.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $104900.l,X		; FF 00 49 10 ; Subtract with carry (long,X) $104900.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $00FF43.l		; EF 43 FF 00 ; Subtract with carry (long) $00FF43.l [Writes: Accumulator] [Flags: NCVZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $002822.l		; EF 22 28 00 ; Subtract with carry (long) $002822.l [Writes: Accumulator] [Flags: NCVZ]
	sbc $01D183.l		; EF 83 D1 01 ; Subtract with carry (long) $01D183.l [Writes: Accumulator] [Flags: NCVZ]
	eor $08.b,S		; 43 08 ; Exclusive OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc [$01.b],Y		; F7 01 ; Subtract with carry (long indexed) [$01.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $0F43F0.l		; 0F F0 43 0F ; OR accumulator with memory (long) $0F43F0.l [Writes: Accumulator] [Flags: NZ]
	sbc [$E0.b],Y		; F7 E0 ; Subtract with carry (long indexed) [$E0.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and $F8.b		; 25 F8 ; Logical AND $F8.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$14.b],Y		; F7 14 ; Subtract with carry (long indexed) [$14.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	.db $F0, $07		; F0 07 ; Branch if equal to $F0, $07 [Flow: branch]
	tsb $BC.b		; 04 BC ; Test and set bits $BC.b [Reads: Accumulator] [Flags: Z]
	sbc $7D7C.w,X		; FD 7C 7D ; Subtract with carry $7D7C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	adc $79F8.w,Y		; 79 F8 79 ; Add $79F8.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc ($3B.b,X)		; 61 3B ; Add with carry ($3B.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($BF.b,X)		; 01 BF ; Logical OR ($BF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc ($8E.b,X)		; E1 8E ; Subtract with carry ($8E.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sep #$02		; E2 02 ; Set processor status bits #$02 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	.db $82, $86, $86		; 82 86 86 ; Branch always long to $82, $86, $86 [Flow: branch]
	stz $1EFE.w,X		; 9E FE 1E ; Store zero to $1EFE.w,X [Reads: X Index]
	ora $00FF.w,X		; 1D FF 00 ; OR accumulator with memory $00FF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $08.b,S		; 43 08 ; Exclusive OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc [$01.b],Y		; F7 01 ; Subtract with carry (long indexed) [$01.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FF4300.l,X		; FF 00 43 FF ; Subtract with carry (long,X) $FF4300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $0102.w,X		; FE 02 01 ; Increment memory $0102.w,X [Reads: X Index] [Flags: NZ]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $C7.b,S		; 83 C7 ; Store accumulator (stack relative) $C7.b,S [Reads: Stack Pointer, Accumulator]
	ora $22.b		; 05 22 ; Logical OR $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $FF02.w,X		; FE 02 FF ; Increment memory $FF02.w,X [Reads: X Index] [Flags: NZ]
	ora #$B768.w		; 09 68 B7 ; Logical OR #$B768.w with accumulator [Writes: Accumulator] [Flags: NZ]
	adc $37B2.w,X		; 7D B2 37 ; Add $37B2.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	and ($DF.b)		; 32 DF ; AND accumulator with memory (indirect) ($DF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc ($1F.b)		; F2 1F ; Subtract with carry (indirect) ($1F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	eor $2A.b		; 45 2A ; Exclusive OR $2A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $0F0027.l,X		; DF 27 00 0F ; Compare accumulator (long,X) $0F0027.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc [$FF.b],Y		; F7 FF ; Subtract with carry (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $BF.b		; 00 BF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$78.b		; C0 78 ; Compare #$78.b with Y register [Reads: Y Index] [Flags: NCZ]
	sbc $603FC7.l,X		; FF C7 3F 60 ; Subtract with carry (long,X) $603FC7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $60FF3F.l,X		; 9F 3F FF 60 ; Store accumulator (long,X) $60FF3F.l,X [Reads: Accumulator, X Index]
	sta $130027.l,X		; 9F 27 00 13 ; Store accumulator (long,X) $130027.l,X [Reads: Accumulator, X Index]
	inc $5880.w,X		; FE 80 58 ; Increment memory $5880.w,X [Reads: X Index] [Flags: NZ]
	ora ($BD.b,X)		; 01 BD ; Logical OR ($BD.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta $1E.b,S		; 83 1E ; Store accumulator (stack relative) $1E.b,S [Reads: Stack Pointer, Accumulator]
	ldx #$1C.b		; A2 1C ; Load #$1C.b into X register [Writes: X Index] [Flags: NZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	ora $06B8.w,X		; 1D B8 06 ; OR accumulator with memory $06B8.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	sta $7F59.w,X		; 9D 59 7F ; Store accumulator to $7F59.w,X [Reads: Accumulator, X Index]
	inc $4140.w,X		; FE 40 41 ; Increment memory $4140.w,X [Reads: X Index] [Flags: NZ]
	jsl $42E043.l		; 22 43 E0 42 ; Jump to subroutine long $42E043.l [Writes: Stack Pointer] [Flow: call]
	jsl $90D050.l		; 22 50 D0 90 ; Jump to subroutine long $90D050.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $2F		; 90 2F ; Branch if carry clear to $90, $2F [Flow: branch]
	brk $50.b		; 00 50 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $AF		; 10 AF ; Branch if plus to $10, $AF [Flow: branch]
	and $FF607F.l,X		; 3F 7F 60 FF ; AND accumulator with memory (long,X) $FF607F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$FF.b		; C0 FF ; Compare #$FF.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $80, $2F		; 80 2F ; Branch always to $80, $2F [Flow: branch]
	adc $C0EFFF.l		; 6F FF EF C0 ; Add with carry (long) $C0EFFF.l [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $A1.b		; 00 A1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx $01C0.w,Y		; BE C0 01 ; Load X register $01C0.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ldy #$1E.b		; A0 1E ; Load #$1E.b into Y register [Writes: Y Index] [Flags: NZ]
	sbc $BF0F.w,X		; FD 0F BF ; Subtract with carry $BF0F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $92.b		; 00 92 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $25		; 30 25 ; Branch if minus to $30, $25 [Flow: branch]
	adc ($4B.b,X)		; 61 4B ; Add with carry ($4B.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $40.b,S		; C3 40 ; Compare accumulator (stack relative) $40.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	inc $C0C1.w,X		; FE C1 C0 ; Increment memory $C0C1.w,X [Reads: X Index] [Flags: NZ]
	cpy #$CF.b		; C0 CF ; Compare #$CF.b with Y register [Reads: Y Index] [Flags: NCZ]
	stz $8F3C.w,X		; 9E 3C 8F ; Store zero to $8F3C.w,X [Reads: X Index]
	.db $F0, $0E		; F0 0E ; Branch if equal to $F0, $0E [Flow: branch]
	adc [$8C.b],Y		; 77 8C ; Add with carry (long indexed) [$8C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$98.b],Y		; F7 98 ; Subtract with carry (long indexed) [$98.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$8C.b]		; E7 8C ; Subtract with carry (long) [$8C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$8D.b],Y		; F7 8D ; Subtract with carry (long indexed) [$8D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $8D.b,X		; F6 8D ; Increment memory $8D.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	ror $CC.b,X		; 76 CC ; Rotate right $CC.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	lda [$00.b],Y		; B7 00 ; Load accumulator (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $80, $E4		; 80 E4 ; Branch always to $80, $E4 [Flow: branch]
	and $00.b,X		; 35 00 ; Logical AND $00.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor $FF.b		; 45 FF ; Exclusive OR $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $45.b		; 00 45 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $0601.w,X		; FE 01 06 ; Increment memory $0601.w,X [Reads: X Index] [Flags: NZ]
	jsr ($F803.w,X)		; FC 03 F8 ; Jump to subroutine indirect indexed ($F803.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora [$0C.b]		; 07 0C ; OR accumulator with memory (long) [$0C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $FF.b		; 25 FF ; Logical AND $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $CA.b,S		; 83 CA ; Store accumulator (stack relative) $CA.b,S [Reads: Stack Pointer, Accumulator]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$24.b		; E0 24 ; Compare #$24.b with X register [Reads: X Index] [Flags: NCZ]
	ora $9F34E0.l,X		; 1F E0 34 9F ; Logical OR long $9F34E0.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $FF7F3F.l,X		; 9F 3F 7F FF ; Store accumulator (long,X) $FF7F3F.l,X [Reads: Accumulator, X Index]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $EF6FFF.l,X		; 7F FF 6F EF ; Add long $EF6FFF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr $FE.b,X		; 56 FE ; Logical shift right $FE.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	eor $4DEF.w,Y		; 59 EF 4D ; Exclusive OR accumulator with memory $4DEF.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $47.b		; E5 47 ; Subtract $47.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$57.b],Y		; F7 57 ; Subtract with carry (long indexed) [$57.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $504046.l		; 6F 46 40 50 ; Add with carry (long) $504046.l [Writes: Accumulator] [Flags: NCVZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	sbc $DFE000.l,X		; FF 00 E0 DF ; Subtract with carry (long,X) $DFE000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp.w [$703C]		; DC 3C 70 ; Jump long indirect [$703C] [Flow: jump]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	cpx #$C0.b		; E0 C0 ; Compare #$C0.b with X register [Reads: X Index] [Flags: NCZ]
	cpy #$C2.b		; C0 C2 ; Compare #$C2.b with Y register [Reads: Y Index] [Flags: NCZ]
	cmp $D5.b,S		; C3 D5 ; Compare accumulator (stack relative) $D5.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	cmp [$00.b],Y		; D7 00 ; Compare accumulator (long indexed) [$00.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cpy #$03.b		; C0 03 ; Compare #$03.b with Y register [Reads: Y Index] [Flags: NCZ]
	ora $3C3F1F.l		; 0F 1F 3F 3C ; OR accumulator with memory (long) $3C3F1F.l [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	adc $43.b,S		; 63 43 ; Add with carry (stack relative) $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $E0.b,S		; 43 E0 ; Exclusive OR accumulator with stack relative $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr $E101.w		; 20 01 E1 ; Jump to subroutine at $E101.w [Writes: Stack Pointer] [Flow: call]
	and ($43.b,X)		; 21 43 ; Logical AND ($43.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpx #$20.b		; E0 20 ; Compare #$20.b with X register [Reads: X Index] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc $DFE0FF.l,X		; FF FF E0 DF ; Subtract with carry (long,X) $DFE0FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $DFDFDE.l,X		; DF DE DF DF ; Compare accumulator (long,X) $DFDFDE.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	stx $0043.w		; 8E 43 00 ; Store X register to $0043.w [Reads: X Index]
	sbc $23FF00.l,X		; FF 00 FF 23 ; Subtract with carry (long,X) $23FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $D7.b,S		; 83 D7 ; Store accumulator (stack relative) $D7.b,S [Reads: Stack Pointer, Accumulator]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FFFFEF.l,X		; FF EF FF FF ; Subtract with carry (long,X) $FFFFEF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and [$00.b],Y		; 37 00 ; AND accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora [$59.b],Y		; 17 59 ; OR accumulator with memory (long indexed) [$59.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $0EEC.w		; 1C EC 0E ; Test and reset bits $0EEC.w [Reads: Accumulator] [Flags: Z]
	inc $C7.b,X		; F6 C7 ; Increment memory $C7.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $1D.b,S		; 23 1D ; AND accumulator with stack relative $1D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($0E.b),Y		; 11 0E ; OR accumulator with memory ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sta [$84.b]		; 87 84 ; Store accumulator (long) [$84.b] [Reads: Direct Page, Accumulator]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $F1.b,S		; E3 F1 ; Subtract stack-relative $F1.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	sec		; 38 ; Set carry flag [Flags: C]
	jmp.w [$F7EE]		; DC EE F7 ; Jump long indirect [$F7EE] [Flow: jump]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $F083.w,X		; FD 83 F0 ; Subtract with carry $F083.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $45.b		; 00 45 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$60.b		; E0 60 ; Compare #$60.b with X register [Reads: X Index] [Flags: NCZ]
	ora [$B0.b]		; 07 B0 ; OR accumulator with memory (long) [$B0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $30, $DF		; 30 DF ; Branch if minus to $30, $DF [Flow: branch]
	sta $FFC070.l,X		; 9F 70 C0 FF ; Store accumulator (long,X) $FFC070.l,X [Reads: Accumulator, X Index]
	.db $80, $22		; 80 22 ; Branch always to $80, $22 [Flow: branch]
	sta $60CF0A.l,X		; 9F 0A CF 60 ; Store accumulator (long,X) $60CF0A.l,X [Reads: Accumulator, X Index]
	and $FB01FC.l,X		; 3F FC 01 FB ; AND accumulator with memory (long,X) $FB01FC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $7CFE.w,Y		; 79 FE 7C ; Add $7CFE.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $44.b		; C5 44 ; Compare $44.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	eor [$C3.b]		; 47 C3 ; Exclusive OR accumulator with memory (long) [$C3.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $42, $03		; 42 03 ; Reserved instruction
	inc $8386.w,X		; FE 86 83 ; Increment memory $8386.w,X [Reads: X Index] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	and $BD.b,S		; 23 BD ; AND accumulator with stack relative $BD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($BF.b,X)		; 01 BF ; Logical OR ($BF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ldx $0043.w,Y		; BE 43 00 ; Load X register $0043.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	sbc $EF100A.l,X		; FF 0A 10 EF ; Subtract with carry (long,X) $EF100A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $7FEF00.l,X		; FF 00 EF 7F ; Subtract with carry (long,X) $7FEF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$7F.b		; C0 7F ; Compare #$7F.b with Y register [Reads: Y Index] [Flags: NCZ]
	stx $79.b		; 86 79 ; Store X register to $79.b [Reads: X Index]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	ora [$CF.b]		; 07 CF ; OR accumulator with memory (long) [$CF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $6F70E0.l,X		; DF E0 70 6F ; Compare accumulator (long,X) $6F70E0.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	sta $83C03F.l,X		; 9F 3F C0 83 ; Store accumulator (long,X) $83C03F.l,X [Reads: Accumulator, X Index]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc [$0C.b],Y		; F7 0C ; Subtract with carry (long indexed) [$0C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($20.b,S),Y		; F3 20 ; Subtract with carry (stack relative indirect indexed) ($20.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $050025.l		; 0F 25 00 05 ; OR accumulator with memory (long) $050025.l [Writes: Accumulator] [Flags: NZ]
	sta [$86.b],Y		; 97 86 ; Store accumulator (long indexed) [$86.b],Y [Reads: Direct Page, Y Index, Accumulator]
	and $D8D70C.l		; 2F 0C D7 D8 ; AND accumulator with memory (long) $D8D70C.l [Writes: Accumulator] [Flags: NZ]
	eor #$082F.w		; 49 2F 08 ; Exclusive OR #$082F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cop $78.b		; 02 78 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $20		; F0 20 ; Branch if equal to $F0, $20 [Flow: branch]
	bit $F0.b		; 24 F0 ; Test bits $F0.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	cpx $7CD7.w		; EC D7 7C ; Compare $7CD7.w with X register [Reads: X Index] [Flags: NCZ]
	eor [$1C.b]		; 47 1C ; Exclusive OR accumulator with memory (long) [$1C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc [$BC.b]		; E7 BC ; Subtract with carry (long) [$BC.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda [$BF.b]		; A7 BF ; Load accumulator (long) [$BF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy $BD.b		; A4 BD ; Load $BD.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	ldx $43.b		; A6 43 ; Load $43.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	ldy $02A7.w,X		; BC A7 02 ; Load Y register $02A7.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	ora $8F.b,S		; 03 8F ; OR accumulator with stack relative $8F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $70, $88		; 70 88 ; Branch if overflow set to $70, $88 [Flow: branch]
	adc [$43.b],Y		; 77 43 ; Add with carry (long indexed) [$43.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $CF0370.l		; 8F 70 03 CF ; Store accumulator (long) $CF0370.l [Reads: Accumulator]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	inc $3B.b		; E6 3B ; Increment $3B.b [Reads: Direct Page] [Flags: NZ]
	eor $F3.b,S		; 43 F3 ; Exclusive OR accumulator with stack relative $F3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	trb $700B.w		; 1C 0B 70 ; Test and reset bits $700B.w [Reads: Accumulator] [Flags: Z]
	adc [$70.b],Y		; 77 70 ; Add with carry (long indexed) [$70.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $78		; 70 78 ; Branch if overflow set to $70, $78 [Flow: branch]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	trb $E71C.w		; 1C 1C E7 ; Test and reset bits $E71C.w [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $E7.b		; 24 E7 ; Test bits $E7.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sta $28.b		; 85 28 ; Store accumulator to $28.b [Reads: Accumulator]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$18.b]		; E7 18 ; Subtract with carry (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc $191822.l,X		; FF 22 18 19 ; Subtract with carry (long,X) $191822.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FF1818.l,X		; FF 18 18 FF ; Subtract with carry (long,X) $FF1818.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora [$FC.b]		; 07 FC ; OR accumulator with memory (long) [$FC.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $FF.b,S		; 03 FF ; OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora $BF43BC.l		; 0F BC 43 BF ; OR accumulator with memory (long) $BF43BC.l [Writes: Accumulator] [Flags: NZ]
	mvp $44,$BB		; 44 BB 44 ; Move block positive $44,$BB [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($0FFF.w,X)		; FC FF 0F ; Jump to subroutine indirect indexed ($0FFF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	eor $44.b,S		; 43 44 ; Exclusive OR accumulator with stack relative $44.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	mvp $BB,$44		; 44 44 BB ; Move block positive $BB,$44 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	mvp $32,$43		; 44 43 32 ; Move block positive $32,$43 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $44.b,S		; 43 44 ; Exclusive OR accumulator with stack relative $44.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	and $44.b,S		; 23 44 ; AND accumulator with stack relative $44.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $034422.l,X		; FF 22 44 03 ; Subtract with carry (long,X) $034422.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$57.b]		; E7 57 ; Subtract with carry (long) [$57.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $57.b		; E5 57 ; Subtract $57.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	eor $ED.b,S		; 43 ED ; Exclusive OR accumulator with stack relative $ED.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $4FFD0B.l,X		; 5F 0B FD 4F ; Exclusive OR accumulator with memory (long,X) $4FFD0B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $4F.b,X		; F5 4F ; Subtract $4F.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	eor [$E4.b]		; 47 E4 ; Exclusive OR accumulator with memory (long) [$E4.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	jsl $48E060.l		; 22 60 E0 48 ; Jump to subroutine long $48E060.l [Writes: Stack Pointer] [Flow: call]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cmp ($D6.b)		; D2 D6 ; Compare accumulator (indirect) ($D6.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sbc ($F7.b,S),Y		; F3 F7 ; Subtract with carry (stack relative indirect indexed) ($F7.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F7.b		; E5 F7 ; Subtract $F7.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	nop		; EA ; No operation
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	.db $80, $FC		; 80 FC ; Branch always to $80, $FC [Flow: branch]
	eor $C7.b		; 45 C7 ; Exclusive OR $C7.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	sta $ED.b,S		; 83 ED ; Store accumulator (stack relative) $ED.b,S [Reads: Stack Pointer, Accumulator]
	lda #$0829.w		; A9 29 08 ; Load #$0829.w into accumulator [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	sec		; 38 ; Set carry flag [Flags: C]
	mvp $AC,$12		; 44 12 AC ; Move block positive $AC,$12 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $399A.w,X		; 1D 9A 39 ; OR accumulator with memory $399A.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldx $73.b,Y		; B6 73 ; Load X register $73.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	sbc $0CBF66.l		; EF 66 BF 0C ; Subtract with carry (long) $0CBF66.l [Writes: Accumulator] [Flags: NCVZ]
	sta $BF18.w,X		; 9D 18 BF ; Store accumulator to $BF18.w,X [Reads: Accumulator, X Index]
	brk $9C.b		; 00 9C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $4662.w		; 9C 62 46 ; Store zero to $4662.w
	tsb $7218.w		; 0C 18 72 ; Test and set bits $7218.w [Reads: Accumulator] [Flags: Z]
	ror $40.b		; 66 40 ; Rotate right $40.b [Reads: Direct Page] [Flags: NCZ]
	adc $B1.b,S		; 63 B1 ; Add with carry (stack relative) $B1.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sta $C5BEE1.l,X		; 9F E1 BE C5 ; Store accumulator (long,X) $C5BEE1.l,X [Reads: Accumulator, X Index]
	lda ($5A.b)		; B2 5A ; Load accumulator (indirect) ($5A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $C5.b		; 25 C5 ; Logical AND $C5.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ror $FF3A.w,X		; 7E 3A FF ; Rotate right $FF3A.w,X [Reads: X Index] [Flags: NCZ]
	brk $71.b		; 00 71 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($5F.b),Y		; 71 5F ; Add with carry ($5F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $BC3E.w,X		; 3E 3E BC ; Rotate left $BC3E.w,X [Reads: X Index] [Flags: NCZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	lda $8E00.w,Y		; B9 00 8E ; Load $8E00.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and [$00.b],Y		; 37 00 ; AND accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$28.b		; E0 28 ; Compare #$28.b with X register [Reads: X Index] [Flags: NCZ]
	sty $840F.w		; 8C 0F 84 ; Store Y register to $840F.w [Reads: Y Index]
	adc [$50.b],Y		; 77 50 ; Add with carry (long indexed) [$50.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0C0FFC.l,X		; 9F FC 0F 0C ; Store accumulator (long,X) $0C0FFC.l,X [Reads: Accumulator, X Index]
	ora [$84.b]		; 07 84 ; OR accumulator with memory (long) [$84.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc ($92.b,S),Y		; 73 92 ; Add with carry (stack relative indirect indexed) ($92.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sta $0870.w,Y		; 99 70 08 ; Store accumulator to $0870.w,Y [Reads: Y Index, Accumulator]
	bit $60.b		; 24 60 ; Test bits $60.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	tsb $CF66.w		; 0C 66 CF ; Test and set bits $CF66.w [Reads: Accumulator] [Flags: Z]
	jsr $5FA7.w		; 20 A7 5F ; Jump to subroutine at $5FA7.w [Writes: Stack Pointer] [Flow: call]
	sbc #$ED56.w		; E9 56 ED ; Subtract #$ED56.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	adc ($95.b)		; 72 95 ; Add with carry (indirect) ($95.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	lda $B0506F.l		; AF 6F 50 B0 ; Load long $B0506F.l into accumulator [Writes: Accumulator] [Flags: NZ]
	adc [$BF.b]		; 67 BF ; Add with carry (long) [$BF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $180022.l,X		; 1F 22 00 18 ; Logical OR long $180022.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsr $0F10.w		; 20 10 0F ; Jump to subroutine at $0F10.w [Writes: Stack Pointer] [Flow: call]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $B3.b,S		; 03 B3 ; OR accumulator with stack relative $B3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jmp ($9774.w,X)		; 7C 74 97 ; Jump indirect indexed to ($9774.w,X) [Reads: X Index] [Flow: jump]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	and ($4B.b)		; 32 4B ; AND accumulator with memory (indirect) ($4B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $4D65.w,X		; 5D 65 4D ; Exclusive OR accumulator with memory $4D65.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $457F.w,X		; 7D 7F 45 ; Add $457F.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $84.b		; 04 84 ; Test and set bits $84.b [Reads: Accumulator] [Flags: Z]
	jsl $FF0482.l		; 22 82 04 FF ; Jump to subroutine long $FF0482.l [Writes: Stack Pointer] [Flow: call]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $87.b		; 00 87 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $C7,$7B		; 44 7B C7 ; Move block positive $C7,$7B [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora [$FC.b]		; 07 FC ; OR accumulator with memory (long) [$FC.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $037A.w,X		; FE 7A 03 ; Increment memory $037A.w,X [Reads: X Index] [Flags: NZ]
	sbc $0300.w,X		; FD 00 03 ; Subtract with carry $0300.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $45.b		; 00 45 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $3F0780.l,X		; FF 80 07 3F ; Subtract with carry (long,X) $3F0780.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$5F.b		; C0 5F ; Compare #$5F.b with Y register [Reads: Y Index] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $B0, $AF		; B0 AF ; Branch if carry set to $B0, $AF [Flow: branch]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $80.b		; 04 80 ; Test and set bits $80.b [Reads: Accumulator] [Flags: Z]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	inc $DE01.w,X		; FE 01 DE ; Increment memory $DE01.w,X [Reads: X Index] [Flags: NZ]
	mvp $C6,$3F		; 44 3F C6 ; Move block positive $C6,$3F [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $FE.b,S		; 03 FE ; OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($BB.b,X)		; 01 BB ; Logical OR ($BB.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rol $B943.w,X		; 3E 43 B9 ; Rotate left $B943.w,X [Reads: X Index] [Flags: NCZ]
	and $0024.w,X		; 3D 24 00 ; AND accumulator with memory $0024.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $42, $42		; 42 42 ; Reserved instruction
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	asl $FD.b		; 06 FD ; Arithmetic shift left $FD.b [Reads: Direct Page] [Flags: NCZ]
	ora $FF.b,S		; 03 FF ; OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $49.b		; 00 49 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $0001.w,X		; FE 01 00 ; Increment memory $0001.w,X [Reads: X Index] [Flags: NZ]
	ora ($26.b,X)		; 01 26 ; Logical OR ($26.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $3FC000.l,X		; FF 00 C0 3F ; Subtract with carry (long,X) $3FC000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $73		; 80 73 ; Branch always to $80, $73 [Flow: branch]
	.db $80, $7F		; 80 7F ; Branch always to $80, $7F [Flow: branch]
	sta $9F457F.l		; 8F 7F 45 9F ; Store accumulator (long) $9F457F.l [Reads: Accumulator]
	.db $70, $01		; 70 01 ; Branch if overflow set to $70, $01 [Flow: branch]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $70227F.l		; 22 7F 22 70 ; Jump to subroutine long $70227F.l [Writes: Stack Pointer] [Flow: call]
	asl $FF.b		; 06 FF ; Arithmetic shift left $FF.b [Reads: Direct Page] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$20.b],Y		; F7 20 ; Subtract with carry (long indexed) [$20.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $FF23.w		; 20 23 FF ; Jump to subroutine at $FF23.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $E7.b,S		; 43 E7 ; Exclusive OR accumulator with stack relative $E7.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $3E.b,S		; 83 3E ; Store accumulator (stack relative) $3E.b,S [Reads: Stack Pointer, Accumulator]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$3F.b		; C0 3F ; Compare #$3F.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $80, $7F		; 80 7F ; Branch always to $80, $7F [Flow: branch]
	sta [$7F.b]		; 87 7F ; Store accumulator (long) [$7F.b] [Reads: Direct Page, Accumulator]
	mvp $58,$8F		; 44 8F 58 ; Move block positive $58,$8F [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cop $78.b		; 02 78 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $A08378.l		; 8F 78 83 A0 ; Store accumulator (long) $A08378.l [Reads: Accumulator]
	ora $23.b,S		; 03 23 ; OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sta $CA.b,S		; 83 CA ; Store accumulator (stack relative) $CA.b,S [Reads: Stack Pointer, Accumulator]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $7B8C78.l,X		; BF 78 8C 7B ; Load long $7B8C78.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sty $843B.w		; 8C 3B 84 ; Store Y register to $843B.w [Reads: Y Index]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	ora $23.b,S		; 03 23 ; OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora ($7B.b,X)		; 01 7B ; Logical OR ($7B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $EF0178.l		; 22 78 01 EF ; Jump to subroutine long $EF0178.l [Writes: Stack Pointer] [Flow: call]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	eor $EC.b,S		; 43 EC ; Exclusive OR accumulator with stack relative $EC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	cpx #$26.b		; E0 26 ; Compare #$26.b with X register [Reads: X Index] [Flags: NCZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	eor $5DEF.w,X		; 5D EF 5D ; Exclusive OR accumulator with memory $5DEF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc [$4E.b],Y		; F7 4E ; Subtract with carry (long indexed) [$4E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	eor [$FD.b],Y		; 57 FD ; Exclusive OR accumulator with memory (long indexed) [$FD.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	eor ($41.b,X)		; 41 41 ; Exclusive OR accumulator with memory ($41.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	inc $5F3C.w,X		; FE 3C 5F ; Increment memory $5F3C.w,X [Reads: X Index] [Flags: NZ]
	and $82BE.w,X		; 3D BE 82 ; AND accumulator with memory $82BE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $B0504C.l		; CF 4C 50 B0 ; Compare accumulator (long) $B0504C.l [Reads: Accumulator] [Flags: NCZ]
	lda $67FBC0.l,X		; BF C0 FB 67 ; Load long $67FBC0.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $01B7.w,Y		; 59 B7 01 ; Exclusive OR accumulator with memory $01B7.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $80, $41		; 80 41 ; Branch always to $80, $41 [Flow: branch]
	.db $30, $0F		; 30 0F ; Branch if minus to $30, $0F [Flow: branch]
	jsl $2FE000.l		; 22 00 E0 2F ; Jump to subroutine long $2FE000.l [Writes: Stack Pointer] [Flow: call]
	cmp $3F.b,S		; C3 3F ; Compare accumulator (stack relative) $3F.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	ror $7AB8.w,X		; 7E B8 7A ; Rotate right $7AB8.w,X [Reads: X Index] [Flags: NCZ]
	pea $C973.w		; F4 73 C9 ; Push absolute address $C973.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	eor [$83.b]		; 47 83 ; Exclusive OR accumulator with memory (long) [$83.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $D46EA6.l,X		; 3F A6 6E D4 ; AND accumulator with memory (long,X) $D46EA6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $0100.w		; 4D 00 01 ; Exclusive OR $0100.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0C.b		; 05 0C ; Logical OR $0C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	ora ($32.b),Y		; 11 32 ; OR accumulator with memory ($32.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $4F.b,S		; 03 4F ; OR accumulator with stack relative $4F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $7F.b		; 06 7F ; Arithmetic shift left $7F.b [Reads: Direct Page] [Flags: NCZ]
	rol $CDFF.w,X		; 3E FF CD ; Rotate left $CDFF.w,X [Reads: X Index] [Flags: NCZ]
	cmp $2EBF83.l		; CF 83 BF 2E ; Compare accumulator (long) $2EBF83.l [Reads: Accumulator] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lsr $BFC0.w,X		; 5E C0 BF ; Logical shift right $BFC0.w,X [Reads: X Index] [Flags: NCZ]
	stx $80B0.w		; 8E B0 80 ; Store X register to $80B0.w [Reads: X Index]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sta $376E31.l,X		; 9F 31 6E 37 ; Store accumulator (long,X) $376E31.l,X [Reads: Accumulator, X Index]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $4E.b		; 26 4E ; Rotate left $4E.b [Reads: Direct Page] [Flags: NCZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	sta $9E89.w,X		; 9D 89 9E ; Store accumulator to $9E89.w,X [Reads: Accumulator, X Index]
	sty $97.b		; 84 97 ; Store Y register to $97.b [Reads: Y Index]
	asl $1F.b		; 06 1F ; Arithmetic shift left $1F.b [Reads: Direct Page] [Flags: NCZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	and $AC7F9D.l,X		; 3F 9D 7F AC ; AND accumulator with memory (long,X) $AC7F9D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $606020.l		; 6F 20 60 60 ; Add with carry (long) $606020.l [Writes: Accumulator] [Flags: NCVZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	cpx #$C0.b		; E0 C0 ; Compare #$C0.b with X register [Reads: X Index] [Flags: NCZ]
	.db $80, $10		; 80 10 ; Branch always to $80, $10 [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	and $9F37FA.l		; 2F FA 37 9F ; AND accumulator with memory (long) $9F37FA.l [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ldx $B35E.w		; AE 5E B3 ; Load $B35E.w into X register [Writes: X Index] [Flags: NZ]
	adc $8070BF.l		; 6F BF 70 80 ; Add with carry (long) $8070BF.l [Writes: Accumulator] [Flags: NCVZ]
	and $0022FF.l,X		; 3F FF 22 00 ; AND accumulator with memory (long,X) $0022FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $4140.w,Y		; 19 40 41 ; OR accumulator with memory $4140.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $70, $7F		; 70 7F ; Branch if overflow set to $70, $7F [Flow: branch]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C1.b		; 00 C1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $EEDD.w,X		; 3C DD EE ; Test bits $EEDD.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	sbc $F576.w		; ED 76 F5 ; Subtract $F576.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	and $DA.b,X		; 35 DA ; Logical AND $DA.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $2DDA.w,X		; FD DA 2D ; Subtract with carry $2DDA.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $2206.w		; 0E 06 22 ; Arithmetic shift left $2206.w [Flags: NCZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($FF.b)		; 12 FF ; OR accumulator with memory (indirect) ($FF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $840022.l,X		; FF 22 00 84 ; Subtract with carry (long,X) $840022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $0001.w,X		; 3C 01 00 ; Test bits $0001.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	sbc $130022.l,X		; FF 22 00 13 ; Subtract with carry (long,X) $130022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $7E0000.l,X		; FF 00 00 7E ; Subtract with carry (long,X) $7E0000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($E7.b,X)		; 81 E7 ; Store accumulator ($E7.b,X) [Reads: Direct Page, Accumulator, X Index]
	ror $7E91.w,X		; 7E 91 7E ; Rotate right $7E91.w,X [Reads: X Index] [Flags: NCZ]
	lda ($7E.b),Y		; B1 7E ; Load accumulator ($7E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $7E.b		; 85 7E ; Store accumulator to $7E.b [Reads: Accumulator]
	sta $3E.b,S		; 83 3E ; Store accumulator (stack relative) $3E.b,S [Reads: Stack Pointer, Accumulator]
	cmp $5A.b,S		; C3 5A ; Compare accumulator (stack relative) $5A.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	ror $0081.w,X		; 7E 81 00 ; Rotate right $0081.w,X [Reads: X Index] [Flags: NCZ]
	and $7E.b		; 25 7E ; Logical AND $7E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $8F.b,S		; 83 8F ; Store accumulator (stack relative) $8F.b,S [Reads: Stack Pointer, Accumulator]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $437F9F.l,X		; 7F 9F 7F 43 ; Add long $437F9F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $B00160.l,X		; BF 60 01 B0 ; Load long $B00160.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $60BF43.l,X		; 7F 43 BF 60 ; Add long $60BF43.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	adc $60607F.l,X		; 7F 7F 60 60 ; Add long $60607F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $604460.l,X		; 7F 60 44 60 ; Add long $604460.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $7FB001.l,X		; BF 01 B0 7F ; Load long $7FB001.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $BF.b,S		; 43 BF ; Exclusive OR accumulator with stack relative $BF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $9F.b		; 05 9F ; Logical OR $9F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $FF7FC0.l,X		; 7F C0 7F FF ; Add long $FF7FC0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $84.b		; 00 84 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($04.b,S),Y		; F3 04 ; Subtract with carry (stack relative indirect indexed) ($04.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora #$7F7F.w		; 09 7F 7F ; Logical OR #$7F7F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $EF		; 10 EF ; Branch if plus to $10, $EF [Flow: branch]
	.db $10, $FF		; 10 FF ; Branch if plus to $10, $FF [Flow: branch]
	sbc $B58307.l		; EF 07 83 B5 ; Subtract with carry (long) $B58307.l [Writes: Accumulator] [Flags: NCVZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp [$EF.b],Y		; D7 EF ; Compare accumulator (long indexed) [$EF.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	jsl $EF1410.l		; 22 10 14 EF ; Jump to subroutine long $EF1410.l [Writes: Stack Pointer] [Flow: call]
	sbc $10D7EF.l,X		; FF EF D7 10 ; Subtract with carry (long,X) $10D7EF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $14		; 10 14 ; Branch if plus to $10, $14 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc [$08.b],Y		; F7 08 ; Subtract with carry (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F71CEB.l,X		; FF EB 1C F7 ; Subtract with carry (long,X) $F71CEB.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sbc $F7F7FF.l,X		; FF FF F7 F7 ; Subtract with carry (long,X) $F7F7FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	trb $22.b		; 14 22 ; Test and reset bits $22.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $EB.b		; 05 EB ; Logical OR $EB.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc [$FF.b],Y		; F7 FF ; Subtract with carry (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$08.b],Y		; F7 08 ; Subtract with carry (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sty $10.b		; 84 10 ; Store Y register to $10.b [Reads: Y Index]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp [$10.b],Y		; D7 10 ; Compare accumulator (long indexed) [$10.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	sbc $4B8307.l		; EF 07 83 4B ; Subtract with carry (long) $4B8307.l [Writes: Accumulator] [Flags: NCVZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	jsl $D70610.l		; 22 10 06 D7 ; Jump to subroutine long $D70610.l [Writes: Stack Pointer] [Flow: call]
	sbc $10EFFF.l		; EF FF EF 10 ; Subtract with carry (long) $10EFFF.l [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $14		; 10 14 ; Branch if plus to $10, $14 [Flow: branch]
	eor $08.b,S		; 43 08 ; Exclusive OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $23F609.l,X		; FF 09 F6 23 ; Subtract with carry (long,X) $23F609.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $FE81.w,X		; FE 81 FE ; Increment memory $FE81.w,X [Reads: X Index] [Flags: NZ]
	sbc $08F7EA.l,X		; FF EA F7 08 ; Subtract with carry (long,X) $08F7EA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	trb $22.b		; 14 22 ; Test and reset bits $22.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $FEF6.w,Y		; 19 F6 FE ; OR accumulator with memory $FEF6.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	inc $08EA.w,X		; FE EA 08 ; Increment memory $08EA.w,X [Reads: X Index] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc $4DF75D.l		; EF 5D F7 4D ; Subtract with carry (long) $4DF75D.l [Writes: Accumulator] [Flags: NCVZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	adc $FF.b		; 65 FF ; Add $FF.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $FF		; 70 FF ; Branch if overflow set to $70, $FF [Flow: branch]
	jmp ($7FFF.w,X)		; 7C FF 7F ; Jump indirect indexed to ($7FFF.w,X) [Reads: X Index] [Flow: jump]
	.db $80, $7F		; 80 7F ; Branch always to $80, $7F [Flow: branch]
	sbc $604000.l,X		; FF 00 40 60 ; Subtract with carry (long,X) $604000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $78		; 70 78 ; Branch if overflow set to $70, $78 [Flow: branch]
	jsl $2AE07F.l		; 22 7F E0 2A ; Jump to subroutine long $2AE07F.l [Writes: Stack Pointer] [Flow: call]
	brk $EA.b		; 00 EA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp [$3B.b],Y		; D7 3B ; Compare accumulator (long indexed) [$3B.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	and [$D9.b]		; 27 D9 ; AND accumulator with memory (long) [$D9.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp [$7A.b],Y		; D7 7A ; Compare accumulator (long indexed) [$7A.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	sbc [$FB.b],Y		; F7 FB ; Subtract with carry (long indexed) [$FB.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$F8.b]		; 07 F8 ; OR accumulator with memory (long) [$F8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $04.b,X		; F6 04 ; Increment memory $04.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc $C00000.l,X		; FF 00 00 C0 ; Subtract with carry (long,X) $C00000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr $0000.w		; 20 00 00 ; Jump to subroutine at $0000.w [Writes: Stack Pointer] [Flow: call]
	sbc ($F8.b),Y		; F1 F8 ; Subtract with carry ($F8.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $D770CF.l,X		; 7F CF 70 D7 ; Add long $D770CF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $D25CAC.l		; 6F AC 5C D2 ; Add with carry (long) $D25CAC.l [Writes: Accumulator] [Flags: NCVZ]
	and ($C9.b,S),Y		; 33 C9 ; AND accumulator (stack relative indirect indexed) ($C9.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $227F00.l		; 2F 00 7F 22 ; AND accumulator with memory (long) $227F00.l [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0C.b,S		; 03 0C ; OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $10, $FF		; 10 FF ; Branch if plus to $10, $FF [Flow: branch]
	jsl $071300.l		; 22 00 13 07 ; Jump to subroutine long $071300.l [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	asl $C4.b		; 06 C4 ; Arithmetic shift left $C4.b [Reads: Direct Page] [Flags: NCZ]
	jsr ($7100.w,X)		; FC 00 71 ; Jump to subroutine indirect indexed ($7100.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $30, $FB		; 30 FB ; Branch if minus to $30, $FB [Flow: branch]
	sta ($CF.b,X)		; 81 CF ; Store accumulator ($CF.b,X) [Reads: Direct Page, Accumulator, X Index]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $8E.b,S		; 03 8E ; OR accumulator with stack relative $8E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $30.b		; 04 30 ; Test and set bits $30.b [Reads: Accumulator] [Flags: Z]
	and [$00.b],Y		; 37 00 ; AND accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora [$FF.b],Y		; 17 FF ; OR accumulator with memory (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F9.b		; 00 F9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	jsr ($F456.w,X)		; FC 56 F4 ; Jump to subroutine indirect indexed ($F456.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	cpx $DE55.w		; EC 55 DE ; Compare $DE55.w with X register [Reads: X Index] [Flags: NCZ]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $83.b		; 06 83 ; Arithmetic shift left $83.b [Reads: Direct Page] [Flags: NCZ]
	ora ($09.b,X)		; 01 09 ; Logical OR ($09.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	sbc $00FF43.l,X		; FF 43 FF 00 ; Subtract with carry (long,X) $00FF43.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($81.b)		; 12 81 ; OR accumulator with memory (indirect) ($81.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($7F.b,X)		; 81 7F ; Store accumulator ($7F.b,X) [Reads: Direct Page, Accumulator, X Index]
	adc ($1A.b),Y		; 71 1A ; Add with carry ($1A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($CF.b),Y		; 11 CF ; OR accumulator with memory ($CF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($04.b,X)		; C1 04 ; Compare accumulator ($04.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc $FFFF00.l,X		; FF 00 FF FF ; Subtract with carry (long,X) $FFFF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $E480.w,X		; 7E 80 E4 ; Rotate right $E480.w,X [Reads: X Index] [Flags: NCZ]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	sta $0D.b,S		; 83 0D ; Store accumulator (stack relative) $0D.b,S [Reads: Stack Pointer, Accumulator]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $6C.b		; 00 6C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	mvn $6C,$00		; 54 00 6C ; Move block negative $6C,$00 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	adc $FF2210.l,X		; 7F 10 22 FF ; Add long $FF2210.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $C7.b		; 04 C7 ; Test and set bits $C7.b [Reads: Accumulator] [Flags: Z]
	sta ($AB.b,S),Y		; 93 AB ; Store accumulator (stack relative indirect indexed) ($AB.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	.db $10, $83		; 10 83 ; Branch if plus to $10, $83 [Flow: branch]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($31.b),Y		; 31 31 ; AND accumulator with memory ($31.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpx $22EC.w		; EC EC 22 ; Compare $22EC.w with X register [Reads: X Index] [Flags: NCZ]
	sbc $FF000C.l,X		; FF 0C 00 FF ; Subtract with carry (long,X) $FF000C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $CEFFFF.l,X		; 3F FF FF CE ; AND accumulator with memory (long,X) $CEFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,S),Y		; 13 00 ; OR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $43C0FF.l,X		; FF FF C0 43 ; Subtract with carry (long,X) $43C0FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $860300.l,X		; FF 00 03 86 ; Subtract with carry (long,X) $860300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	stx $41.b		; 86 41 ; Store X register to $41.b [Reads: X Index]
	eor ($22.b,X)		; 41 22 ; Exclusive OR accumulator with memory ($22.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $FF0002.l,X		; FF 02 00 FF ; Subtract with carry (long,X) $FF0002.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $BE7905.l,X		; FF 05 79 BE ; Subtract with carry (long,X) $BE7905.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $DF4300.l,X		; FF 00 43 DF ; Subtract with carry (long,X) $DF4300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $FF.b,S		; 03 FF ; OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $DF4328.l		; EF 28 43 DF ; Subtract with carry (long) $DF4328.l [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $CF.b,X		; 15 CF ; OR accumulator with memory $CF.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc $E7E728.l		; EF 28 E7 E7 ; Subtract with carry (long) $E7E728.l [Writes: Accumulator] [Flags: NCVZ]
	cmp [$D7.b]		; C7 D7 ; Compare accumulator (long) [$D7.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sbc [$E7.b]		; E7 E7 ; Subtract with carry (long) [$E7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$D7.b],Y		; F7 D7 ; Subtract with carry (long indexed) [$D7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sty $4CF7.w		; 8C F7 4C ; Store Y register to $4CF7.w [Reads: Y Index]
	lda [$AC.b],Y		; B7 AC ; Load accumulator (long indexed) [$AC.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp [$5C.b],Y		; D7 5C ; Compare accumulator (long indexed) [$5C.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	adc [$BC.b]		; 67 BC ; Add with carry (long) [$BC.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda [$45.b]		; A7 45 ; Load accumulator (long) [$45.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpy $2257.w		; CC 57 22 ; Compare $2257.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $40		; 80 40 ; Branch always to $80, $40 [Flow: branch]
	jsl $FF0120.l		; 22 20 01 FF ; Jump to subroutine long $FF0120.l [Writes: Stack Pointer] [Flow: call]
	adc $40FF4D.l,X		; 7F 4D FF 40 ; Add long $40FF4D.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and [$7F.b]		; 27 7F ; AND accumulator with memory (long) [$7F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $004CFF.l		; 22 FF 4C 00 ; Jump to subroutine long $004CFF.l [Writes: Stack Pointer] [Flow: call]
	sbc $E0FF27.l,X		; FF 27 FF E0 ; Subtract with carry (long,X) $E0FF27.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc $37D080.l,X		; 7F 80 D0 37 ; Add long $37D080.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy #$7F.b		; A0 7F ; Load #$7F.b into Y register [Writes: Y Index] [Flags: NZ]
	sta $7D.b,X		; 95 7D ; Store accumulator to $7D.b,X [Reads: Accumulator, X Index]
	.db $82, $73, $C1		; 82 73 C1 ; Branch always long to $82, $73, $C1 [Flow: branch]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpy #$3A.b		; C0 3A ; Compare #$3A.b with Y register [Reads: Y Index] [Flags: NCZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsl $15142C.l		; 22 2C 14 15 ; Jump to subroutine long $15142C.l [Writes: Stack Pointer] [Flow: call]
	bit $94.b		; 24 94 ; Test bits $94.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	jmp ($3FD8.w,X)		; 7C D8 3F ; Jump indirect indexed to ($3FD8.w,X) [Reads: X Index] [Flow: jump]
	ldy #$5B.b		; A0 5B ; Load #$5B.b into Y register [Writes: Y Index] [Flags: NZ]
	sta $7B8464.l,X		; 9F 64 84 7B ; Store accumulator (long,X) $7B8464.l,X [Reads: Accumulator, X Index]
	cmp $E43B.w		; CD 3B E4 ; Compare $E43B.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	adc $202380.l,X		; 7F 80 23 20 ; Add long $202380.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $1D0024.l,X		; 1F 24 00 1D ; Logical OR long $1D0024.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: NCZ]
	sta $BEBE9F.l,X		; 9F 9F BE BE ; Store accumulator (long,X) $BEBE9F.l,X [Reads: Accumulator, X Index]
	lda $F9BD.w,X		; BD BD F9 ; Load $F9BD.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $F0F1.w,Y		; F9 F1 F0 ; Subtract with carry $F0F1.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $BDF8.w,Y		; F9 F8 BD ; Subtract with carry $BDF8.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $E07F.w,X		; 3C 7F E0 ; Test bits $E07F.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	cmp ($C2.b,X)		; C1 C2 ; Compare accumulator ($C2.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	sta [$AE.b]		; 87 AE ; Store accumulator (long) [$AE.b] [Reads: Direct Page, Accumulator]
	ldx $42.b		; A6 42 ; Load $42.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sbc $0000FF.l,X		; FF FF 00 00 ; Subtract with carry (long,X) $0000FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and #$03FF.w		; 29 FF 03 ; Logical AND #$03FF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lda $00FF40.l,X		; BF 40 FF 00 ; Load long $00FF40.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	bit $FF.b		; 24 FF ; Test bits $FF.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	trb $FDF0.w		; 1C F0 FD ; Test and reset bits $FDF0.w [Reads: Accumulator] [Flags: Z]
	cpy #$FA.b		; C0 FA ; Compare #$FA.b with Y register [Reads: Y Index] [Flags: NCZ]
	sta ($F1.b),Y		; 91 F1 ; Store accumulator ($F1.b),Y [Reads: Direct Page, Y Index, Accumulator]
	rol $F5.b		; 26 F5 ; Rotate left $F5.b [Reads: Direct Page] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc $3A.b,X		; F5 3A ; Subtract $3A.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $4A.b,X		; F5 4A ; Subtract $4A.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $4E.b,X		; F5 4E ; Subtract $4E.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $C3		; F0 C3 ; Branch if equal to $F0, $C3 [Flow: branch]
	sty $3519.w		; 8C 19 35 ; Store Y register to $3519.w [Reads: Y Index]
	ora $35.b		; 05 35 ; Logical OR $35.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($9F.b),Y		; 31 9F ; AND accumulator with memory ($9F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $50, $FD		; 50 FD ; Branch if overflow clear to $50, $FD [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	ora ($89.b),Y		; 11 89 ; OR accumulator with memory ($89.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	rol $01.b		; 26 01 ; Rotate left $01.b [Reads: Direct Page] [Flags: NCZ]
	cop $20.b		; 02 20 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0C.b,S		; 03 0C ; OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sty $33.b		; 84 33 ; Store Y register to $33.b [Reads: Y Index]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $4ADF00.l,X		; FF 00 DF 4A ; Subtract with carry (long,X) $4ADF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $FF01C0.l,X		; 1F C0 01 FF ; Logical OR long $FF01C0.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $27.b		; 00 27 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $00FF02.l,X		; 7F 02 FF 00 ; Add long $00FF02.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $00FF4A.l,X		; FF 4A FF 00 ; Subtract with carry (long,X) $00FF4A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FF7F0A.l,X		; FF 0A 7F FF ; Subtract with carry (long,X) $FF7F0A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $5F		; 80 5F ; Branch always to $80, $5F [Flow: branch]
	ldy #$E0.b		; A0 E0 ; Load #$E0.b into Y register [Writes: Y Index] [Flags: NZ]
	and $43BF7F.l,X		; 3F 7F BF 43 ; AND accumulator with memory (long,X) $43BF7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $002580.l,X		; 7F 80 25 00 ; Add long $002580.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($3F.b,X)		; 01 3F ; Logical OR ($3F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $9C000B.l,X		; FF 0B 00 9C ; Subtract with carry (long,X) $9C000B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $A2.b,S		; 63 A2 ; Add with carry (stack relative) $A2.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	adc $FFB6D5.l,X		; 7F D5 B6 FF ; Add long $FFB6D5.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp ($FF.b,X)		; C1 FF ; Compare accumulator ($FF.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	asl $0088.w		; 0E 88 00 ; Arithmetic shift left $0088.w [Flags: NCZ]
	sbc $ECAB00.l,X		; FF 00 AB EC ; Subtract with carry (long,X) $ECAB00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor [$B7.b],Y		; 57 B7 ; Exclusive OR accumulator with memory (long indexed) [$B7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	cld		; D8 ; Clear decimal flag [Flags: D]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc [$FF.b]		; E7 FF ; Subtract with carry (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $00,$FF		; 44 FF 00 ; Move block positive $00,$FF [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cop $10.b		; 02 10 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$24.b]		; 07 24 ; OR accumulator with memory (long) [$24.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FF5DA2.l,X		; FF A2 5D FF ; Subtract with carry (long,X) $FF5DA2.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx #$A2.b		; A2 A2 ; Load #$A2.b into X register [Writes: X Index] [Flags: NZ]
	sty $69.b		; 84 69 ; Store Y register to $69.b [Reads: Y Index]
	ora ($44.b,X)		; 01 44 ; Logical OR ($44.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	adc $000280.l,X		; 7F 80 02 00 ; Add long $000280.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $5D.b		; 00 5D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sta $66.b,S		; 83 66 ; Store accumulator (stack relative) $66.b,S [Reads: Stack Pointer, Accumulator]
	brk $45.b		; 00 45 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $EF4308.l		; CF 08 43 EF ; Compare accumulator (long) $EF4308.l [Reads: Accumulator] [Flags: NCZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	ora $DF.b,S		; 03 DF ; OR accumulator with stack relative $DF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	cmp [$E7.b],Y		; D7 E7 ; Compare accumulator (long indexed) [$E7.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	jsl $D708F7.l		; 22 F7 08 D7 ; Jump to subroutine long $D708F7.l [Writes: Stack Pointer] [Flow: call]
	cmp [$E7.b],Y		; D7 E7 ; Compare accumulator (long indexed) [$E7.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	lda $57CCF0.l		; AF F0 CC 57 ; Load long $57CCF0.l into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy $45F7.w		; AC F7 45 ; Load $45F7.w into Y register [Writes: Y Index] [Flags: NZ]
	cpy $8357.w		; CC 57 83 ; Compare $8357.w with Y register [Reads: Y Index] [Flags: NCZ]
	jsr ($0201.w,X)		; FC 01 02 ; Jump to subroutine indirect indexed ($0201.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $0001.w		; 20 01 00 ; Jump to subroutine at $0001.w [Writes: Stack Pointer] [Flow: call]
	jsr $FF4A.w		; 20 4A FF ; Jump to subroutine at $FF4A.w [Writes: Stack Pointer] [Flow: call]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $26.b		; 00 26 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $FF004A.l,X		; 7F 4A 00 FF ; Add long $FF004A.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $0002FF.l		; 22 FF 02 00 ; Jump to subroutine long $0002FF.l [Writes: Stack Pointer] [Flow: call]
	sbc $FF2600.l,X		; FF 00 26 FF ; Subtract with carry (long,X) $FF2600.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	ora $0D17.w,X		; 1D 17 0D ; OR accumulator with memory $0D17.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc [$43.b],Y		; F7 43 ; Subtract with carry (long indexed) [$43.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $FB.b		; 06 FB ; Arithmetic shift left $FB.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	inc $FA03.w,X		; FE 03 FA ; Increment memory $FA03.w,X [Reads: X Index] [Flags: NZ]
	jsr ($FC03.w,X)		; FC 03 FC ; Jump to subroutine indirect indexed ($FC03.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$23.b		; E0 23 ; Compare #$23.b with X register [Reads: X Index] [Flags: NCZ]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $C6.b		; 00 C6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	jmp.w [$EC05]		; DC 05 EC ; Jump long indirect [$EC05] [Flow: jump]
	.db $80, $F7		; 80 F7 ; Branch always to $80, $F7 [Flow: branch]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	adc $07FF22.l,X		; 7F 22 FF 07 ; Add long $07FF22.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $132339.l,X		; FF 39 23 13 ; Subtract with carry (long,X) $132339.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $80, $22		; 80 22 ; Branch always to $80, $22 [Flow: branch]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $431C.w,X		; 9D 1C 43 ; Store accumulator to $431C.w,X [Reads: Accumulator, X Index]
	lda $033C.w,X		; BD 3C 03 ; Load $033C.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $E718.w,Y		; 99 18 E7 ; Store accumulator to $E718.w,Y [Reads: Y Index, Accumulator]
	brk $45.b		; 00 45 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $621F7E.l,X		; FF 7E 1F 62 ; Subtract with carry (long,X) $621F7E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr $6642.w		; 4E 42 66 ; Logical shift right $6642.w [Flags: NCZ]
	ror $3C3C.w,X		; 7E 3C 3C ; Rotate right $3C3C.w,X [Reads: X Index] [Flags: NCZ]
	rol $55FF.w,X		; 3E FF 55 ; Rotate left $55FF.w,X [Reads: X Index] [Flags: NCZ]
	sbc $F0FF00.l,X		; FF 00 FF F0 ; Subtract with carry (long,X) $F0FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $42FD60.l,X		; FF 60 FD 42 ; Subtract with carry (long,X) $42FD60.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc $FFFB04.l,X		; FF 04 FB FF ; Subtract with carry (long,X) $FFFB04.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	eor $00.b,X		; 55 00 ; Exclusive OR accumulator with memory $00.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $60		; F0 60 ; Branch if equal to $F0, $60 [Flow: branch]
	eor $04.b,S		; 43 04 ; Exclusive OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $44.b		; 04 44 ; Test and set bits $44.b [Reads: Accumulator] [Flags: Z]
	and [$00.b],Y		; 37 00 ; AND accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$21.b		; E0 21 ; Compare #$21.b with X register [Reads: X Index] [Flags: NCZ]
	sbc $FF67.w,Y		; F9 67 FF ; Subtract with carry $FF67.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	lda $3FBF3C.l,X		; BF 3C BF 3F ; Load long $3FBF3C.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $67C75F.l,X		; 9F 5F C7 67 ; Store accumulator (long,X) $67C75F.l,X [Reads: Accumulator, X Index]
	cpx #$78.b		; E0 78 ; Compare #$78.b with X register [Reads: X Index] [Flags: NCZ]
	.db $F0, $7F		; F0 7F ; Branch if equal to $F0, $7F [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$47.b]		; 07 47 ; OR accumulator with memory (long) [$47.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	sbc $70BF7F.l,X		; FF 7F BF 70 ; Subtract with carry (long,X) $70BF7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $569956.l,X		; 9F 56 99 56 ; Store accumulator (long,X) $569956.l,X [Reads: Accumulator, X Index]
	eor $D9.b		; 45 D9 ; Exclusive OR $D9.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $02.b,X		; 16 02 ; Arithmetic shift left $02.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	adc $240000.l,X		; 7F 00 00 24 ; Add long $240000.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $83.b		; 26 83 ; Rotate left $83.b [Reads: Direct Page] [Flags: NCZ]
	tsb $0501.w		; 0C 01 05 ; Test and set bits $0501.w [Reads: Accumulator] [Flags: Z]
	adc $365F80.l,X		; 7F 80 5F 36 ; Add long $365F80.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $45B2.w,Y		; F9 B2 45 ; Subtract with carry $45B2.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $03B6.w,Y		; F9 B6 03 ; Subtract with carry $03B6.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $B60000.l,X		; FF 00 00 B6 ; Subtract with carry (long,X) $B60000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $36.b,S		; 23 36 ; AND accumulator with stack relative $36.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($84.b,X)		; 01 84 ; Logical OR ($84.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $C4.b,S		; 43 C4 ; Exclusive OR accumulator with stack relative $C4.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00CE.w,Y		; 39 CE 00 ; AND accumulator with memory $00CE.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $00DB00.l,X		; DF 00 DB 00 ; Compare accumulator (long,X) $00DB00.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	cmp $03.b,S		; C3 03 ; Compare accumulator (stack relative) $03.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	sbc $7B0000.l,X		; FF 00 00 7B ; Subtract with carry (long,X) $7B0000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $60.b,X		; 75 60 ; Add $60.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	stz $7C.b		; 64 7C ; Store zero to $7C.b
	adc $D67DEE.l,X		; 7F EE 7D D6 ; Add long $D67DEE.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	mvn $54,$82		; 54 82 54 ; Move block negative $54,$82 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	jmp ($BAC6.w,X)		; 7C C6 BA ; Jump indirect indexed to ($BAC6.w,X) [Reads: X Index] [Flow: jump]
	jmp ($0044.w,X)		; 7C 44 00 ; Jump indirect indexed to ($0044.w,X) [Reads: X Index] [Flow: jump]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and #$0139.w		; 29 39 01 ; Logical AND #$0139.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $0738FF.l,X		; FF FF 38 07 ; Subtract with carry (long,X) $0738FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $183F0D.l,X		; 3F 0D 3F 18 ; AND accumulator with memory (long,X) $183F0D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $382F30.l,X		; 1F 30 2F 38 ; Logical OR long $382F30.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and [$2D.b],Y		; 37 2D ; AND accumulator with memory (long indexed) [$2D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	eor [$0F.b]		; 47 0F ; Exclusive OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $25.b,X		; D5 25 ; Compare accumulator $25.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cpy #$11.b		; C0 11 ; Compare #$11.b with Y register [Reads: Y Index] [Flags: NCZ]
	ldy #$20.b		; A0 20 ; Load #$20.b into Y register [Writes: Y Index] [Flags: NZ]
	sbc $1C.b,S		; E3 1C ; Subtract stack-relative $1C.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	sbc $E3FFB6.l,X		; FF B6 FF E3 ; Subtract with carry (long,X) $E3FFB6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $E3BE41.l,X		; FF 41 BE E3 ; Subtract with carry (long,X) $E3BE41.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $EBB6.w,X		; 5D B6 EB ; Exclusive OR accumulator with memory $EBB6.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	trb $14FF.w		; 1C FF 14 ; Test and reset bits $14FF.w [Reads: Accumulator] [Flags: Z]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b)		; 12 02 ; OR accumulator with memory (indirect) ($02.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($EC.b,X)		; 01 EC ; Logical OR ($EC.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	stz $BBF4.w		; 9C F4 BB ; Store zero to $BBF4.w
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	cpx $C7BD.w		; EC BD C7 ; Compare $C7BD.w with X register [Reads: X Index] [Flags: NCZ]
	sbc $C7BD82.l,X		; FF 82 BD C7 ; Subtract with carry (long,X) $C7BD82.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $03FE.w,X		; FD FE 03 ; Subtract with carry $03FE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora $BB.b,S		; 03 BB ; OR accumulator with stack relative $BB.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx $B8F7.w		; EC F7 B8 ; Compare $B8F7.w with X register [Reads: X Index] [Flags: NCZ]
	sta [$68.b]		; 87 68 ; Store accumulator (long) [$68.b] [Reads: Direct Page, Accumulator]
	ora $83.b,S		; 03 83 ; OR accumulator with stack relative $83.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora $E4.b,S		; 03 E4 ; OR accumulator with stack relative $E4.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and [$00.b],Y		; 37 00 ; AND accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $F0.b,S		; 43 F0 ; Exclusive OR accumulator with stack relative $F0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	trb $EB02.w		; 1C 02 EB ; Test and reset bits $EB02.w [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	cpx $1B43.w		; EC 43 1B ; Compare $1B43.w with X register [Reads: X Index] [Flags: NCZ]
	inc $0D07.w		; EE 07 0D ; Increment $0D07.w [Flags: NZ]
	sbc [$0D.b],Y		; F7 0D ; Subtract with carry (long indexed) [$0D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$EF.b],Y		; 17 EF ; OR accumulator with memory (long indexed) [$EF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $23E3E0.l		; EF E0 E3 23 ; Subtract with carry (long) $23E3E0.l [Writes: Accumulator] [Flags: NCVZ]
	cpx #$24.b		; E0 24 ; Compare #$24.b with X register [Reads: X Index] [Flags: NCZ]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $1DFD07.l,X		; FF 07 FD 1D ; Subtract with carry (long,X) $1DFD07.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($FD3C.w,X)		; FC 3C FD ; Jump to subroutine indirect indexed ($FD3C.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	and $59D7.w,X		; 3D D7 59 ; AND accumulator with memory $59D7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0A.b,S		; 83 0A ; Store accumulator (stack relative) $0A.b,S [Reads: Stack Pointer, Accumulator]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $383F3F.l,X		; 1F 3F 3F 38 ; Logical OR long $383F3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	mvp $7E,$FF		; 44 FF 7E ; Move block positive $7E,$FF [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $FF.b		; 46 FF ; Logical shift right $FF.b [Reads: Direct Page] [Flags: NCZ]
	rol $001A.w,X		; 3E 1A 00 ; Rotate left $001A.w,X [Reads: X Index] [Flags: NCZ]
	sbc $7E7E3E.l,X		; FF 3E 7E 7E ; Subtract with carry (long,X) $7E7E3E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $003E.w,X		; 3E 3E 00 ; Rotate left $003E.w,X [Reads: X Index] [Flags: NCZ]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	.db $F0, $1B		; F0 1B ; Branch if equal to $F0, $1B [Flow: branch]
	sbc $38.b,S		; E3 38 ; Subtract stack-relative $38.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $30, $DB		; 30 DB ; Branch if minus to $30, $DB [Flow: branch]
	brk $CB.b		; 00 CB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $E3		; 10 E3 ; Branch if plus to $10, $E3 [Flow: branch]
	and #$3BFD.w		; 29 FD 3B ; Logical AND #$3BFD.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $04.b,S		; 23 04 ; AND accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx #$3D.b		; E0 3D ; Compare #$3D.b with X register [Reads: X Index] [Flags: NCZ]
	bit $24.b		; 24 24 ; Test bits $24.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	and $34.b,X		; 35 34 ; Logical AND $34.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$F8.b]		; E7 F8 ; Subtract with carry (long) [$F8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$70.b		; E0 70 ; Compare #$70.b with X register [Reads: X Index] [Flags: NCZ]
	cmp ($E7.b,S),Y		; D3 E7 ; Compare accumulator (stack relative indirect indexed) ($E7.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	eor $9F12.w		; 4D 12 9F ; Exclusive OR $9F12.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $229D.w		; 20 9D 22 ; Jump to subroutine at $229D.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0C.b]		; 07 0C ; OR accumulator with memory (long) [$0C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $A0		; 10 A0 ; Branch if plus to $10, $A0 [Flow: branch]
	eor ($49.b,X)		; 41 49 ; Exclusive OR accumulator with memory ($49.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sta [$5F.b],Y		; 97 5F ; Store accumulator (long indexed) [$5F.b],Y [Reads: Direct Page, Y Index, Accumulator]
	cmp [$67.b]		; C7 67 ; Compare accumulator (long) [$67.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	.db $B0, $68		; B0 68 ; Branch if carry set to $B0, $68 [Flow: branch]
	jmp.w [$EB33]		; DC 33 EB ; Jump long indirect [$EB33] [Flow: jump]
	and [$78.b],Y		; 37 78 ; AND accumulator with memory (long indexed) [$78.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta [$3F.b],Y		; 97 3F ; Store accumulator (long indexed) [$3F.b],Y [Reads: Direct Page, Y Index, Accumulator]
	wai		; CB ; Wait for interrupt
	ora $1820E0.l,X		; 1F E0 20 18 ; Logical OR long $1820E0.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $0B10.w		; 20 10 0B ; Jump to subroutine at $0B10.w [Writes: Stack Pointer] [Flow: call]
	brk $DF.b		; 00 DF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $C0		; 10 C0 ; Branch if plus to $10, $C0 [Flow: branch]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $ED22ED.l		; 2F ED 22 ED ; AND accumulator with memory (long) $ED22ED.l [Writes: Accumulator] [Flags: NZ]
	jsr $EF44.w		; 20 44 EF ; Jump to subroutine at $EF44.w [Writes: Stack Pointer] [Flow: call]
	jsl $202005.l		; 22 05 20 20 ; Jump to subroutine long $202005.l [Writes: Stack Pointer] [Flow: call]
	and $121010.l,X		; 3F 10 10 12 ; AND accumulator with memory (long,X) $121010.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $FF0010.l		; 22 10 00 FF ; Jump to subroutine long $FF0010.l [Writes: Stack Pointer] [Flow: call]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $FF.b		; 04 FF ; Test and set bits $FF.b [Reads: Accumulator] [Flags: Z]
	eor $1259B6.l		; 4F B6 59 12 ; Exclusive OR accumulator with memory (long) $1259B6.l [Writes: Accumulator] [Flags: NZ]
	eor $79.b,S		; 43 79 ; Exclusive OR accumulator with stack relative $79.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $83.b,X		; 36 83 ; Rotate left $83.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora ($0C.b,X)		; 01 0C ; Logical OR ($0C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx $86.b		; A6 86 ; Load $86.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	stx $00.b		; 86 00 ; Store X register to $00.b [Reads: X Index]
	sbc $10EF00.l,X		; FF 00 EF 10 ; Subtract with carry (long,X) $10EF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $DF		; F0 DF ; Branch if equal to $F0, $DF [Flow: branch]
	cpx #$44.b		; E0 44 ; Compare #$44.b with X register [Reads: X Index] [Flags: NCZ]
	cpy #$FF.b		; C0 FF ; Compare #$FF.b with Y register [Reads: Y Index] [Flags: NCZ]
	jsl $0022FF.l		; 22 FF 22 00 ; Jump to subroutine long $0022FF.l [Writes: Stack Pointer] [Flow: call]
	tsb $DFC0.w		; 0C C0 DF ; Test and set bits $DFC0.w [Reads: Accumulator] [Flags: Z]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	mvp $7D,$BB		; 44 BB 7D ; Move block positive $7D,$BB [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sbc $440083.l,X		; FF 83 00 44 ; Subtract with carry (long,X) $440083.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $0004FF.l		; 22 FF 04 00 ; Jump to subroutine long $0004FF.l [Writes: Stack Pointer] [Flow: call]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $FF.b,S		; 83 FF ; Store accumulator (stack relative) $FF.b,S [Reads: Stack Pointer, Accumulator]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $840022.l,X		; FF 22 00 84 ; Subtract with carry (long,X) $840022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $01.b,X		; 75 01 ; Add $01.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $0A8400.l		; 22 00 84 0A ; Jump to subroutine long $0A8400.l [Writes: Stack Pointer] [Flow: call]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $010022.l,X		; FF 22 00 01 ; Subtract with carry (long,X) $010022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FF487E.l,X		; FF 7E 48 FF ; Subtract with carry (long,X) $FF487E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $42, $83		; 42 83 ; Reserved instruction
	sbc ($03.b,S),Y		; F3 03 ; Subtract with carry (stack relative indirect indexed) ($03.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cpx $37.b		; E4 37 ; Compare $37.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($43.b,X)		; C1 43 ; Compare accumulator ($43.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	ror $01FF.w,X		; 7E FF 01 ; Rotate right $01FF.w,X [Reads: X Index] [Flags: NCZ]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $7F.b,S		; 43 7F ; Exclusive OR accumulator with stack relative $7F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $027983.l,X		; FF 83 79 02 ; Subtract with carry (long,X) $027983.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora #$7E00.w		; 09 00 7E ; Logical OR #$7E00.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ror $7F00.w,X		; 7E 00 7F ; Rotate right $7F00.w,X [Reads: X Index] [Flags: NCZ]
	adc $007E00.l,X		; 7F 00 7E 00 ; Add long $007E00.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($43.b,X)		; 01 43 ; Logical OR ($43.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	inc $01FF.w,X		; FE FF 01 ; Increment memory $01FF.w,X [Reads: X Index] [Flags: NZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $EF.b,S		; 43 EF ; Exclusive OR accumulator with stack relative $EF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $830000.l,X		; FF 00 00 83 ; Subtract with carry (long,X) $830000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $0D.b		; 05 0D ; Logical OR $0D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $00FE.w,X		; FE FE 00 ; Increment memory $00FE.w,X [Reads: X Index] [Flags: NZ]
	sbc $FE00EF.l		; EF EF 00 FE ; Subtract with carry (long) $FE00EF.l [Writes: Accumulator] [Flags: NCVZ]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $BF		; 80 BF ; Branch always to $80, $BF [Flow: branch]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $43.b,S		; 03 43 ; OR accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $0A02.w,X		; FD 02 0A ; Subtract with carry $0A02.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $2BD400.l,X		; FF 00 D4 2B ; Subtract with carry (long,X) $2BD400.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $7C0000.l,X		; FF 00 00 7C ; Subtract with carry (long,X) $7C0000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($52.b,S),Y		; 53 52 ; XOR accumulator (stack relative indirect indexed) ($52.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor ($22.b)		; 52 22 ; Exclusive OR accumulator with memory (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	mvn $FF,$01		; 54 01 FF ; Move block negative $FF,$01 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $570054.l,X		; FF 54 00 57 ; Subtract with carry (long,X) $570054.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	mvp $54,$FF		; 44 FF 54 ; Move block positive $54,$FF [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $7F.b,S		; 03 7F ; OR accumulator with stack relative $7F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $267F80.l,X		; 7F 80 7F 26 ; Add long $267F80.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $1EFF3E.l,X		; FF 3E FF 1E ; Subtract with carry (long,X) $1EFF3E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $9EFF80.l,X		; FF 80 FF 9E ; Subtract with carry (long,X) $9EFF80.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $E0FFDE.l,X		; FF DE FF E0 ; Subtract with carry (long,X) $E0FFDE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $0014FF.l		; 22 FF 14 00 ; Jump to subroutine long $0014FF.l [Writes: Stack Pointer] [Flow: call]
	rol $801E.w,X		; 3E 1E 80 ; Rotate left $801E.w,X [Reads: X Index] [Flags: NCZ]
	.db $80, $DE		; 80 DE ; Branch always to $80, $DE [Flow: branch]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: NCZ]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $FF4FFF.l,X		; 5F FF 4F FF ; Exclusive OR accumulator with memory (long,X) $FF4FFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $FF.b,S		; 63 FF ; Add with carry (stack relative) $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	stz $BF.b,X		; 74 BF ; Store zero to $BF.b,X [Reads: X Index]
	rol $FF.b,X		; 36 FF ; Rotate left $FF.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $580005.l,X		; FF 05 00 58 ; Subtract with carry (long,X) $580005.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $403463.l		; 4F 63 34 40 ; Exclusive OR accumulator with memory (long) $403463.l [Writes: Accumulator] [Flags: NZ]
	jsl $2CE000.l		; 22 00 E0 2C ; Jump to subroutine long $2CE000.l [Writes: Stack Pointer] [Flow: call]
	sta $9622.w,X		; 9D 22 96 ; Store accumulator to $9622.w,X [Reads: Accumulator, X Index]
	eor #$508F.w		; 49 8F 50 ; Exclusive OR #$508F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp $A4.b,S		; C3 A4 ; Compare accumulator (stack relative) $A4.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	clv		; B8 ; Clear overflow flag [Flags: V]
	inc $DE.b		; E6 DE ; Increment $DE.b [Reads: Direct Page] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc [$17.b]		; E7 17 ; Subtract with carry (long) [$17.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	eor ($20.b,X)		; 41 20 ; Exclusive OR accumulator with memory ($20.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $070F18.l		; 22 18 0F 07 ; Jump to subroutine long $070F18.l [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $DAC3.w,X		; FD C3 DA ; Subtract with carry $DAC3.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $66BD.w,X		; BD BD 66 ; Load $66BD.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $A566.w,Y		; 99 66 A5 ; Store accumulator to $A566.w,Y [Reads: Y Index, Accumulator]
	ror $BD42.w,X		; 7E 42 BD ; Rotate right $BD42.w,X [Reads: X Index] [Flags: NCZ]
	lda $02C3.w,X		; BD C3 02 ; Load $02C3.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $241800.l,X		; FF 00 18 24 ; Subtract with carry (long,X) $241800.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $3C.b		; 24 3C ; Test bits $3C.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	jsl $FF0E00.l		; 22 00 0E FF ; Jump to subroutine long $FF0E00.l [Writes: Stack Pointer] [Flow: call]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cpx #$3F.b		; E0 3F ; Compare #$3F.b with X register [Reads: X Index] [Flags: NCZ]
	ldx $8241.w,Y		; BE 41 82 ; Load X register $8241.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	adc $7DC2.w,X		; 7D C2 7D ; Add $7DC2.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx $C07D.w,Y		; BE 7D C0 ; Load X register $C07D.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	and $0028FF.l,X		; 3F FF 28 00 ; AND accumulator with memory (long,X) $0028FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0B.b,S		; 83 0B ; Store accumulator (stack relative) $0B.b,S [Reads: Stack Pointer, Accumulator]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ror $4381.w,X		; 7E 81 43 ; Rotate right $4381.w,X [Reads: X Index] [Flags: NCZ]
	.db $42, $BD		; 42 BD ; Reserved instruction
	tsb $7E.b		; 04 7E ; Test and set bits $7E.b [Reads: Accumulator] [Flags: Z]
	lda $FF00.w,X		; BD 00 FF ; Load $FF00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $FF0028.l,X		; FF 28 00 FF ; Subtract with carry (long,X) $FF0028.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $E63FCF.l		; 0F CF 3F E6 ; OR accumulator with memory (long) $E63FCF.l [Writes: Accumulator] [Flags: NZ]
	eor $9F6FB0.l,X		; 5F B0 6F 9F ; Exclusive OR accumulator with memory (long,X) $9F6FB0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $70, $88		; 70 88 ; Branch if overflow set to $70, $88 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	eor [$BF.b]		; 47 BF ; Exclusive OR accumulator with memory (long) [$BF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror $9F.b		; 66 9F ; Rotate right $9F.b [Reads: Direct Page] [Flags: NCZ]
	adc ($AF.b,S),Y		; 73 AF ; Add with carry (stack relative indirect indexed) ($AF.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $F80F00.l		; 22 00 0F F8 ; Jump to subroutine long $F80F00.l [Writes: Stack Pointer] [Flow: call]
	ora [$C7.b]		; 07 C7 ; OR accumulator with memory (long) [$C7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	adc $BD.b,S		; 63 BD ; Add with carry (stack relative) $BD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	and ($DE.b),Y		; 31 DE ; AND accumulator with memory ($DE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $D7E7D6.l		; EF D6 E7 D7 ; Subtract with carry (long) $D7E7D6.l [Writes: Accumulator] [Flags: NCVZ]
	sbc [$95.b]		; E7 95 ; Subtract with carry (long) [$95.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$24.b]		; E7 24 ; Subtract with carry (long) [$24.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora #$804F.w		; 09 4F 80 ; Logical OR #$804F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	eor $877F80.l,X		; 5F 80 7F 87 ; Exclusive OR accumulator with memory (long,X) $877F80.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $88.b,X		; 75 88 ; Add $88.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $90, $43		; 90 43 ; Branch if carry clear to $90, $43 [Flow: branch]
	.db $70, $E0		; 70 E0 ; Branch if overflow set to $70, $E0 [Flow: branch]
	cpx #$39.b		; E0 39 ; Compare #$39.b with X register [Reads: X Index] [Flags: NCZ]
	adc ($E3.b,S),Y		; 73 E3 ; Add with carry (stack relative indirect indexed) ($E3.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	adc $73787F.l,X		; 7F 7F 78 73 ; Add long $73787F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc [$0F.b]		; 67 0F ; Add with carry (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $00FC0C.l		; 0F 0C FC 00 ; OR accumulator with memory (long) $00FC0C.l [Writes: Accumulator] [Flags: NZ]
	inc $FB00.w,X		; FE 00 FB ; Increment memory $FB00.w,X [Reads: X Index] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $1C.b,X		; F5 1C ; Subtract $1C.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	asl $073D.w		; 0E 3D 07 ; Arithmetic shift left $073D.w [Flags: NCZ]
	asl $ED03.w,X		; 1E 03 ED ; Arithmetic shift left $ED03.w,X [Reads: X Index] [Flags: NCZ]
	sbc ($FF.b,X)		; E1 FF ; Subtract with carry ($FF.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F1E307.l,X		; FF 07 E3 F1 ; Subtract with carry (long,X) $F1E307.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($001E.w,X)		; FC 1E 00 ; Jump to subroutine indirect indexed ($001E.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $3F07FF.l,X		; FF FF 07 3F ; Subtract with carry (long,X) $3F07FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$77.b]		; 07 77 ; OR accumulator with memory (long) [$77.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $F0		; 10 F0 ; Branch if plus to $10, $F0 [Flow: branch]
	jsr $21E9.w		; 20 E9 21 ; Jump to subroutine at $21E9.w [Writes: Stack Pointer] [Flow: call]
	sbc $0021.w,Y		; F9 21 00 ; Subtract with carry $0021.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $E7		; F0 E7 ; Branch if equal to $F0, $E7 [Flow: branch]
	cmp $45DEDE.l		; CF DE DE 45 ; Compare accumulator (long) $45DEDE.l [Reads: Accumulator] [Flags: NCZ]
	sty $09F7.w		; 8C F7 09 ; Store Y register to $09F7.w [Reads: Y Index]
	cpy $7F37.w		; CC 37 7F ; Compare $7F37.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $80, $63		; 80 63 ; Branch always to $80, $63 [Flow: branch]
	stz $BCC7.w,X		; 9E C7 BC ; Store zero to $BCC7.w,X [Reads: X Index]
	dec $24B9.w		; CE B9 24 ; Decrement $24B9.w [Flags: NZ]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $383C.w,X		; 1E 3C 38 ; Arithmetic shift left $383C.w,X [Reads: X Index] [Flags: NCZ]
	sbc $005980.l,X		; FF 80 59 00 ; Subtract with carry (long,X) $005980.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $A61A80.l,X		; BF 80 1A A6 ; Load long $A61A80.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $18.b,S		; 43 18 ; Exclusive OR accumulator with stack relative $18.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $0205.w,X		; BD 05 02 ; Load $0205.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldx $5F98.w,Y		; BE 98 5F ; Load X register $5F98.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	adc $4062FF.l,X		; 7F FF 62 40 ; Add long $4062FF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$20.b		; E0 20 ; Compare #$20.b with X register [Reads: X Index] [Flags: NCZ]
	.db $42, $41		; 42 41 ; Reserved instruction
	jsr $01FF.w		; 20 FF 01 ; Jump to subroutine at $01FF.w [Writes: Stack Pointer] [Flow: call]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($59.b,X)		; 01 59 ; Logical OR ($59.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	adc $19.b		; 65 19 ; Add $19.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda $BD18.w,X		; BD 18 BD ; Load $BD18.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	adc $FA19.w,X		; 7D 19 FA ; Add $FA19.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $02FF.w,X		; FE FF 02 ; Increment memory $02FF.w,X [Reads: X Index] [Flags: NZ]
	.db $82, $42, $42		; 82 42 42 ; Branch always long to $82, $42, $42 [Flow: branch]
	.db $82, $04, $A1		; 82 04 A1 ; Branch always long to $82, $04, $A1 [Flow: branch]
	ldx $01C0.w,Y		; BE C0 01 ; Load X register $01C0.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ldy #$1E.b		; A0 1E ; Load #$1E.b into Y register [Writes: Y Index] [Flags: NZ]
	eor $FD.b,S		; 43 FD ; Exclusive OR accumulator with stack relative $FD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $1FA008.l		; 0F 08 A0 1F ; OR accumulator with memory (long) $1FA008.l [Writes: Accumulator] [Flags: NZ]
	lda ($13.b)		; B2 13 ; Load accumulator (indirect) ($13.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx #$0D.b		; E0 0D ; Compare #$0D.b with X register [Reads: X Index] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	inc $22C1.w,X		; FE C1 22 ; Increment memory $22C1.w,X [Reads: X Index] [Flags: NZ]
	cpy #$07.b		; C0 07 ; Compare #$07.b with Y register [Reads: Y Index] [Flags: NCZ]
	cpy $E0D2.w		; CC D2 E0 ; Compare $E0D2.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora $13B2.w		; 0D B2 13 ; Logical OR $13B2.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$1F.b		; A0 1F ; Load #$1F.b into Y register [Writes: Y Index] [Flags: NZ]
	eor $FD.b,S		; 43 FD ; Exclusive OR accumulator with stack relative $FD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $1EA007.l		; 0F 07 A0 1E ; OR accumulator with memory (long) $1EA007.l [Writes: Accumulator] [Flags: NZ]
	cpy #$01.b		; C0 01 ; Compare #$01.b with Y register [Reads: Y Index] [Flags: NCZ]
	lda $D2BE.w,Y		; B9 BE D2 ; Load $D2BE.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cpy $C022.w		; CC 22 C0 ; Compare $C022.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora $C1.b,X		; 15 C1 ; OR accumulator with memory $C1.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	inc $FF40.w,X		; FE 40 FF ; Increment memory $FF40.w,X [Reads: X Index] [Flags: NZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $FE.b,S		; 03 FE ; OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc [$FC.b],Y		; 77 FC ; Add with carry (long indexed) [$FC.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	pei ($6A.b)		; D4 6A ; Push effective indirect address ($6A.b) [Reads: Direct Page] [Writes: Stack Pointer]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	adc $66DF.w		; 6D DF 66 ; Add $66DF.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp $030072.l		; CF 72 00 03 ; Compare accumulator (long) $030072.l [Reads: Accumulator] [Flags: NCZ]
	ora [$23.b]		; 07 23 ; OR accumulator with memory (long) [$23.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $FF0712.l		; 0F 12 07 FF ; OR accumulator with memory (long) $FF0712.l [Writes: Accumulator] [Flags: NZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $3C.b,S		; 83 3C ; Store accumulator (stack relative) $3C.b,S [Reads: Stack Pointer, Accumulator]
	adc $702E38.l		; 6F 38 2E 70 ; Add with carry (long) $702E38.l [Writes: Accumulator] [Flags: NCVZ]
	cpx $DCF0.w		; EC F0 DC ; Compare $DCF0.w with X register [Reads: X Index] [Flags: NCZ]
	sbc [$B8.b]		; E7 B8 ; Subtract with carry (long) [$B8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cpx $0076.w		; EC 76 00 ; Compare $0076.w with X register [Reads: X Index] [Flags: NCZ]
	cmp [$22.b]		; C7 22 ; Compare accumulator (long) [$22.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sbc $BBDF15.l		; EF 15 DF BB ; Subtract with carry (long) $BBDF15.l [Writes: Accumulator] [Flags: NCVZ]
	adc [$7E.b],Y		; 77 7E ; Add with carry (long indexed) [$7E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $7D837B.l,X		; FF 7B 83 7D ; Subtract with carry (long,X) $7D837B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($6E.b,X)		; 81 6E ; Store accumulator ($6E.b,X) [Reads: Direct Page, Accumulator, X Index]
	.db $80, $67		; 80 67 ; Branch always to $80, $67 [Flow: branch]
	.db $80, $63		; 80 63 ; Branch always to $80, $63 [Flow: branch]
	.db $80, $61		; 80 61 ; Branch always to $80, $61 [Flow: branch]
	.db $80, $60		; 80 60 ; Branch always to $80, $60 [Flow: branch]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	jmp ($247E.w,X)		; 7C 7E 24 ; Jump indirect indexed to ($247E.w,X) [Reads: X Index] [Flow: jump]
	adc $7F400B.l,X		; 7F 0B 40 7F ; Add long $7F400B.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $00403F.l,X		; BF 3F 40 00 ; Load long $00403F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda $404080.l,X		; BF 80 40 40 ; Load long $404080.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda $FF433F.l,X		; BF 3F 43 FF ; Load long $FF433F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	sbc $C0BF7F.l,X		; FF 7F BF C0 ; Subtract with carry (long,X) $C0BF7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $0080FF.l,X		; FF FF 80 00 ; Subtract with carry (long,X) $0080FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $40		; 80 40 ; Branch always to $80, $40 [Flow: branch]
	cpy #$60.b		; C0 60 ; Compare #$60.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $D0, $20		; D0 20 ; Branch if not equal to $D0, $20 [Flow: branch]
	cld		; D8 ; Clear decimal flag [Flags: D]
	jsr $60DC.w		; 20 DC 60 ; Jump to subroutine at $60DC.w [Writes: Stack Pointer] [Flow: call]
	stx $78.b,Y		; 96 78 ; Store X register $78.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	wai		; CB ; Wait for interrupt
	bit $22.b		; 24 22 ; Test bits $22.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	.db $80, $10		; 80 10 ; Branch always to $80, $10 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	.db $D0, $DC		; D0 DC ; Branch if not equal to $D0, $DC [Flow: branch]
	cmp ($BA.b,X)		; C1 BA ; Compare accumulator ($BA.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	sta $75.b,S		; 83 75 ; Store accumulator (stack relative) $75.b,S [Reads: Stack Pointer, Accumulator]
	ora [$EB.b]		; 07 EB ; OR accumulator with memory (long) [$EB.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $FB1C1C.l		; 0F 1C 1C FB ; OR accumulator with memory (long) $FB1C1C.l [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc [$3E.b]		; 67 3E ; Add with carry (long) [$3E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jmp ($F0F8.w,X)		; 7C F8 F0 ; Jump indirect indexed to ($F0F8.w,X) [Reads: X Index] [Flow: jump]
	sbc $07.b,S		; E3 07 ; Subtract stack-relative $07.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	sbc $21E1FF.l,X		; FF FF E1 21 ; Subtract with carry (long,X) $21E1FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$20.b		; E0 20 ; Compare #$20.b with X register [Reads: X Index] [Flags: NCZ]
	cpx $24.b		; E4 24 ; Compare $24.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $F0, $30		; F0 30 ; Branch if equal to $F0, $30 [Flow: branch]
	cmp $6F19.w,Y		; D9 19 6F ; Compare accumulator $6F19.w,Y [Reads: Y Index] [Flags: NCZ]
	ora $DF80B0.l		; 0F B0 80 DF ; OR accumulator with memory (long) $DF80B0.l [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	dec $DBDF.w,X		; DE DF DB ; Decrement memory $DBDF.w,X [Reads: X Index] [Flags: NZ]
	cmp $7FF0E6.l		; CF E6 F0 7F ; Compare accumulator (long) $7FF0E6.l [Reads: Accumulator] [Flags: NCZ]
	and $FD02FB.l,X		; 3F FB 02 FD ; AND accumulator with memory (long,X) $FD02FB.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($F6.b,X)		; 01 F6 ; Logical OR ($F6.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $F0, $1B		; F0 1B ; Branch if equal to $F0, $1B [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $250C.w		; 0D 0C 25 ; Logical OR $250C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	bit $05.b		; 24 05 ; Test bits $05.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	tsb $8D.b		; 04 8D ; Test and set bits $8D.b [Reads: Accumulator] [Flags: Z]
	sty $FEFC.w		; 8C FC FE ; Store Y register to $FEFC.w [Reads: Y Index]
	ora $DBF3E7.l		; 0F E7 F3 DB ; OR accumulator with memory (long) $DBF3E7.l [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	adc ($F3.b,S),Y		; 73 F3 ; Add with carry (stack relative indirect indexed) ($F3.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc $0CE01F.l		; EF 1F E0 0C ; Subtract with carry (long) $0CE01F.l [Writes: Accumulator] [Flags: NCVZ]
	sbc ($08.b,S),Y		; F3 08 ; Subtract with carry (stack relative indirect indexed) ($08.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$F9.b],Y		; F7 F9 ; Subtract with carry (long indexed) [$F9.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$FB.b]		; 07 FB ; OR accumulator with memory (long) [$FB.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $0F.b,X		; F6 0F ; Increment memory $0F.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	pea $F10E.w		; F4 0E F1 ; Push absolute address $F10E.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	sta ($98.b)		; 92 98 ; Store accumulator (indirect) ($98.b) [Reads: Direct Page, Accumulator]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	jmp $45C5.w		; 4C C5 45 ; Jump to $45C5.w [Flow: jump]
	sbc ($21.b,X)		; E1 21 ; Subtract with carry ($21.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $40DF1F.l,X		; BF 1F DF 40 ; Load long $40DF1F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldy #$60.b		; A0 60 ; Load #$60.b into Y register [Writes: Y Index] [Flags: NZ]
	cpy #$3F.b		; C0 3F ; Compare #$3F.b with Y register [Reads: Y Index] [Flags: NCZ]
	adc $33.b		; 65 33 ; Add $33.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	asl $2040.w,X		; 1E 40 20 ; Arithmetic shift left $2040.w,X [Reads: X Index] [Flags: NCZ]
	ora $F94300.l,X		; 1F 00 43 F9 ; Logical OR long $F94300.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($0B.b,X)		; 21 0B ; Logical AND ($0B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $FE21.w,X		; FD 21 FE ; Subtract with carry $FE21.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $EF		; 30 EF ; Branch if minus to $30, $EF [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	cmp [$1C.b],Y		; D7 1C ; Compare accumulator (long indexed) [$1C.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl $0735.w		; 0E 35 07 ; Arithmetic shift left $0735.w [Flags: NCZ]
	jsl $46E0DE.l		; 22 DE E0 46 ; Jump to subroutine long $46E0DE.l [Writes: Stack Pointer] [Flow: call]
	cmp $F1E3C7.l		; CF C7 E3 F1 ; Compare accumulator (long) $F1E3C7.l [Reads: Accumulator] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $667580.l,X		; FF 80 75 66 ; Subtract with carry (long,X) $667580.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora ($8C.b,S),Y		; 13 8C ; OR accumulator (stack relative indirect indexed) ($8C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit #$C94C.w		; 89 4C C9 ; Test bits #$C94C.w with accumulator [Reads: Accumulator] [Flags: Z]
	bit $8C69.w		; 2C 69 8C ; Test bits $8C69.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	ora #$393C.w		; 09 3C 39 ; Logical OR #$393C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $88.b		; 00 88 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $72.b		; E4 72 ; Compare $72.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	and ($92.b)		; 32 92 ; AND accumulator with memory (indirect) ($92.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc ($C2.b)		; 72 C2 ; Add with carry (indirect) ($C2.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $FD.b,S		; 03 FD ; OR accumulator with stack relative $FD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	stx $F8.b		; 86 F8 ; Store X register to $F8.b [Reads: X Index]
	stx $F9F1.w		; 8E F1 F9 ; Store X register to $F9F1.w [Reads: X Index]
	asl $F3.b		; 06 F3 ; Arithmetic shift left $F3.b [Reads: Direct Page] [Flags: NCZ]
	sta $30.b,S		; 83 30 ; Store accumulator (stack relative) $30.b,S [Reads: Stack Pointer, Accumulator]
	cmp $F8EF10.l		; CF 10 EF F8 ; Compare accumulator (long) $F8EF10.l [Reads: Accumulator] [Flags: NCZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0000.w		; 0C 00 00 ; Test and set bits $0000.w [Reads: Accumulator] [Flags: Z]
	clv		; B8 ; Clear overflow flag [Flags: V]
	ldy #$7C.b		; A0 7C ; Load #$7C.b into Y register [Writes: Y Index] [Flags: NZ]
	adc ($9E.b,S),Y		; 73 9E ; Add with carry (stack relative indirect indexed) ($9E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F90E.w,Y		; F9 0E F9 ; Subtract with carry $F90E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $CBFB00.l,X		; FF 00 FB CB ; Subtract with carry (long,X) $CBFB00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $D7		; 30 D7 ; Branch if minus to $30, $D7 [Flow: branch]
	.db $30, $DF		; 30 DF ; Branch if minus to $30, $DF [Flow: branch]
	eor [$80.b]		; 47 80 ; Exclusive OR accumulator with memory (long) [$80.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $041200.l		; 22 00 12 04 ; Jump to subroutine long $041200.l [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc [$0C.b],Y		; 77 0C ; Add with carry (long indexed) [$0C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($0E.b,S),Y		; 73 0E ; Add with carry (stack relative indirect indexed) ($0E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	adc ($0F.b),Y		; 71 0F ; Add with carry ($0F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $18		; 70 18 ; Branch if overflow set to $70, $18 [Flow: branch]
	adc $30.b,S		; 63 30 ; Add with carry (stack relative) $30.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	wai		; CB ; Wait for interrupt
	pea $CC0F.w		; F4 0F CC ; Push absolute address $CC0F.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	eor [$23.b],Y		; 57 23 ; Exclusive OR accumulator with memory (long indexed) [$23.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $80, $E0		; 80 E0 ; Branch always to $80, $E0 [Flow: branch]
	lsr $0484.w		; 4E 84 04 ; Logical shift right $0484.w [Flags: NCZ]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $4CB7.w		; AC B7 4C ; Load $4CB7.w into Y register [Writes: Y Index] [Flags: NZ]
	adc [$CF.b],Y		; 77 CF ; Add with carry (long indexed) [$CF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $EF		; F0 EF ; Branch if equal to $F0, $EF [Flow: branch]
	adc ($FC.b,S),Y		; 73 FC ; Add with carry (stack relative indirect indexed) ($FC.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	and $78.b,X		; 35 78 ; Logical AND $78.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $3C.b,S		; 03 3C ; OR accumulator with stack relative $3C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor [$0C.b]		; 47 0C ; Exclusive OR accumulator with memory (long) [$0C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc [$40.b],Y		; 77 40 ; Add with carry (long indexed) [$40.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $80.b		; 84 80 ; Store Y register to $80.b [Reads: Y Index]
	.db $80, $CF		; 80 CF ; Branch always to $80, $CF [Flow: branch]
	.db $70, $DF		; 70 DF ; Branch if overflow set to $70, $DF [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $1AF74A.l,X		; BF 4A F7 1A ; Load long $1AF74A.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc [$3B.b]		; E7 3B ; Subtract with carry (long) [$3B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inc $FF3B.w		; EE 3B FF ; Increment $FF3B.w [Flags: NZ]
	adc ($FF.b,X)		; 61 FF ; Add with carry ($FF.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cop $09.b		; 02 09 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc ($63.b,S),Y		; 73 63 ; Add with carry (stack relative indirect indexed) ($63.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $D0, $EC		; D0 EC ; Branch if not equal to $D0, $EC [Flow: branch]
	sbc [$D8.b]		; E7 D8 ; Subtract with carry (long) [$D8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $A4FCB0.l		; EF B0 FC A4 ; Subtract with carry (long) $A4FCB0.l [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	sbc $93.b,S		; E3 93 ; Subtract stack-relative $93.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	stz $96.b		; 64 96 ; Store zero to $96.b
	sbc $DFEF9C.l		; EF 9C EF DF ; Subtract with carry (long) $DFEF9C.l [Writes: Accumulator] [Flags: NCVZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	lda ($A7.b,S),Y		; B3 A7 ; Load accumulator (stack relative indirect indexed) ($A7.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpy $C0C9.w		; CC C9 C0 ; Compare $C0C9.w with Y register [Reads: Y Index] [Flags: NCZ]
	cmp [$5E.b],Y		; D7 5E ; Compare accumulator (long indexed) [$5E.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cmp ($46.b)		; D2 46 ; Compare accumulator (indirect) ($46.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	lsr $05DA.w,X		; 5E DA 05 ; Logical shift right $05DA.w,X [Reads: X Index] [Flags: NCZ]
	cmp ($5E.b)		; D2 5E ; Compare accumulator (indirect) ($5E.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	.db $80, $7E		; 80 7E ; Branch always to $80, $7E [Flow: branch]
	jmp ($25FF.w,X)		; 7C FF 25 ; Jump indirect indexed to ($25FF.w,X) [Reads: X Index] [Flow: jump]
	and ($E0.b,X)		; 21 E0 ; Logical AND ($E0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and #$0001.w		; 29 01 00 ; Logical AND #$0001.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lsr $B07F.w,X		; 5E 7F B0 ; Logical shift right $B07F.w,X [Reads: X Index] [Flags: NCZ]
	sbc [$67.b]		; E7 67 ; Subtract with carry (long) [$67.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp $189F0C.l		; CF 0C 9F 18 ; Compare accumulator (long) $189F0C.l [Reads: Accumulator] [Flags: NCZ]
	lda $56BE11.l,X		; BF 11 BE 56 ; Load long $56BE11.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $FF00.w,Y		; F9 00 FF ; Subtract with carry $FF00.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $18		; 80 18 ; Branch always to $80, $18 [Flow: branch]
	and [$6F.b],Y		; 37 6F ; AND accumulator with memory (long indexed) [$6F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $001F5F.l,X		; 5F 5F 1F 00 ; Exclusive OR accumulator with memory (long,X) $001F5F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: NCZ]
	ldy #$40.b		; A0 40 ; Load #$40.b into Y register [Writes: Y Index] [Flags: NZ]
	.db $90, $60		; 90 60 ; Branch if carry clear to $90, $60 [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $70, $DC		; 70 DC ; Branch if overflow set to $70, $DC [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	bit $3FDC.w,X		; 3C DC 3F ; Test bits $3FDC.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx #$79.b		; E0 79 ; Compare #$79.b with X register [Reads: X Index] [Flags: NCZ]
	lsr $01.b		; 46 01 ; Logical shift right $01.b [Reads: Direct Page] [Flags: NCZ]
	bit $8083.w,X		; 3C 83 80 ; Test bits $8083.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	sbc $88FF06.l,X		; FF 06 FF 88 ; Subtract with carry (long,X) $88FF06.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $F948.w,Y		; 79 48 F9 ; Add $F948.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	stx $F1.b,Y		; 96 F1 ; Store X register $F1.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	rol $FEE1.w		; 2E E1 FE ; Rotate left $FEE1.w [Flags: NCZ]
	jmp ($C080.w,X)		; 7C 80 C0 ; Jump indirect indexed to ($C080.w,X) [Reads: X Index] [Flow: jump]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	stx $E01E.w		; 8E 1E E0 ; Store X register to $E01E.w [Reads: X Index]
	ldy #$7B.b		; A0 7B ; Load #$7B.b into Y register [Writes: Y Index] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	lda ($AB.b)		; B2 AB ; Load accumulator (indirect) ($AB.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $6FAF56.l,X		; DF 56 AF 6F ; Compare accumulator (long,X) $6FAF56.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	.db $90, $70		; 90 70 ; Branch if carry clear to $90, $70 [Flow: branch]
	sta $7F897F.l		; 8F 7F 89 7F ; Store accumulator (long) $7F897F.l [Reads: Accumulator]
	ora $204484.l,X		; 1F 84 44 20 ; Logical OR long $204484.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $5FD0A0.l,X		; BF A0 D0 5F ; Load long $5FD0A0.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	lda $5B5774.l		; AF 74 57 5B ; Load long $5B5774.l into accumulator [Writes: Accumulator] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	jsr $8810.w		; 20 10 88 ; Jump to subroutine at $8810.w [Writes: Stack Pointer] [Flow: call]
	sty $E4.b		; 84 E4 ; Store Y register to $E4.b [Reads: Y Index]
	sty $84.b		; 84 84 ; Store Y register to $84.b [Reads: Y Index]
	sbc $66.b,X		; F5 66 ; Subtract $66.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $ED1B0D.l,X		; FF 0D 1B ED ; Subtract with carry (long,X) $ED1B0D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $EC.b,X		; F5 EC ; Subtract $EC.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	pea $F2E4.w		; F4 E4 F2 ; Push absolute address $F2E4.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
.ACCU 8
.INDEX 8
	sep #$F9		; E2 F9
	sbc #$14.b		; E9 14 ; Subtract #$14.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cpx $0108.w		; EC 08 01 ; Compare $0108.w with X register [Reads: X Index] [Flags: NCZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $0306.w		; 0D 06 03 ; Logical OR $0306.w with accumulator [Writes: Accumulator] [Flags: NZ]
	inc $00.b,X		; F6 00 ; Increment memory $00.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $EE		; F0 EE ; Branch if equal to $F0, $EE [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	inc $FA.b,X		; F6 FA ; Increment memory $FA.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	sbc $017D71.l,X		; FF 71 7D 01 ; Subtract with carry (long,X) $017D71.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $94.b,S		; 83 94 ; Store accumulator (stack relative) $94.b,S [Reads: Stack Pointer, Accumulator]
	ora [$10.b]		; 07 10 ; OR accumulator with memory (long) [$10.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $F9FBF7.l		; 0F F7 FB F9 ; OR accumulator with memory (long) $F9FBF7.l [Writes: Accumulator] [Flags: NZ]
	.db $70, $8E		; 70 8E ; Branch if overflow set to $70, $8E [Flow: branch]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc #$DE.b		; E9 DE ; Subtract #$DE.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	and $BFDE43.l,X		; 3F 43 DE BF ; AND accumulator with memory (long,X) $BFDE43.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$FF.b		; 09 FF ; Logical OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $62.b		; 00 62 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($D9.b,S),Y		; 73 D9 ; Add with carry (stack relative indirect indexed) ($D9.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc $8464.w,Y		; F9 64 84 ; Subtract with carry $8464.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($62.b)		; F2 62 ; Subtract with carry (indirect) ($62.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $8C.b		; 05 8C ; Logical OR $8C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $1B.b		; 06 1B ; Arithmetic shift left $1B.b [Reads: Direct Page] [Flags: NCZ]
	adc $72BA.w		; 6D BA 72 ; Add $72BA.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	eor $BC.b,S		; 43 BC ; Exclusive OR accumulator with stack relative $BC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora [$DC.b],Y		; 17 DC ; OR accumulator with memory (long indexed) [$DC.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jmp ($BD30.w)		; 6C 30 BD ; Jump indirect to ($BD30.w) [Flow: jump]
	cop $FB.b		; 02 FB ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	tsb $7B75.w		; 0C 75 7B ; Test and set bits $7B75.w [Reads: Accumulator] [Flags: Z]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	lda [$C4.b],Y		; B7 C4 ; Load accumulator (long indexed) [$C4.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	inc $F3.b		; E6 F3 ; Increment $F3.b [Reads: Direct Page] [Flags: NZ]
	sbc $00FFF8.l,X		; FF F8 FF 00 ; Subtract with carry (long,X) $00FFF8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sed		; F8 ; Set decimal flag [Flags: D]
	eor $7E.b,S		; 43 7E ; Exclusive OR accumulator with stack relative $7E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $7F43.w,X		; FE 43 7F ; Increment memory $7F43.w,X [Reads: X Index] [Flags: NZ]
	sbc $FE0106.l,X		; FF 06 01 FE ; Subtract with carry (long,X) $FE0106.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $00FF1F.l,X		; FF 1F FF 00 ; Subtract with carry (long,X) $00FF1F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$1F.b		; E0 1F ; Compare #$1F.b with X register [Reads: X Index] [Flags: NCZ]
	cmp $BF44.w,Y		; D9 44 BF ; Compare accumulator $BF44.w,Y [Reads: Y Index] [Flags: NCZ]
	cmp $9F6F03.l,X		; DF 03 6F 9F ; Compare accumulator (long,X) $9F6F03.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	.db $F0, $0F		; F0 0F ; Branch if equal to $F0, $0F [Flow: branch]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $DE,$BF		; 44 BF DE ; Move block positive $DE,$BF [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	eor $FE.b,S		; 43 FE ; Exclusive OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $1FDE43.l,X		; BF 43 DE 1F ; Load long $1FDE43.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($C7.b,X)		; 01 C7 ; Logical OR ($C7.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $24.b		; 06 24 ; Arithmetic shift left $24.b [Reads: Direct Page] [Flags: NCZ]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $3820.w		; 20 20 38 ; Jump to subroutine at $3820.w [Writes: Stack Pointer] [Flow: call]
	sbc $FF1E.w,X		; FD 1E FF ; Subtract with carry $FF1E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $E3.b		; 00 E3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $BEDD.w		; 1C DD BE ; Test and reset bits $BEDD.w [Reads: Accumulator] [Flags: Z]
	dec $BF44.w,X		; DE 44 BF ; Decrement memory $BF44.w,X [Reads: X Index] [Flags: NZ]
	dec $DE01.w		; CE 01 DE ; Decrement $DE01.w [Flags: NZ]
	lda $010027.l,X		; BF 27 00 01 ; Load long $010027.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc [$4C.b],Y		; F7 4C ; Subtract with carry (long indexed) [$4C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $FD.b,S		; 43 FD ; Exclusive OR accumulator with stack relative $FD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lsr $6AE0.w		; 4E E0 6A ; Logical shift right $6AE0.w [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	eor [$F1.b]		; 47 F1 ; Exclusive OR accumulator with memory (long) [$F1.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $FF0DFE.l		; 0F FE 0D FF ; OR accumulator with memory (long) $FF0DFE.l [Writes: Accumulator] [Flags: NZ]
	jmp $66DF.w		; 4C DF 66 ; Jump to $66DF.w [Flow: jump]
	adc ($60.b,X)		; 61 60 ; Add with carry ($60.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc ($2F.b,X)		; 61 2F ; Add with carry ($2F.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $F50E0D.l		; 0F 0D 0E F5 ; OR accumulator with memory (long) $F50E0D.l [Writes: Accumulator] [Flags: NZ]
	asl $07FB.w		; 0E FB 07 ; Arithmetic shift left $07FB.w [Flags: NCZ]
	sbc $3CF738.l		; EF 38 F7 3C ; Subtract with carry (long) $3CF738.l [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	trb $0FFF.w		; 1C FF 0F ; Test and reset bits $0FFF.w [Reads: Accumulator] [Flags: Z]
	sbc $07FF00.l,X		; FF 00 FF 07 ; Subtract with carry (long,X) $07FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$30.b		; C0 30 ; Compare #$30.b with Y register [Reads: Y Index] [Flags: NCZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	adc $0F3F7F.l,X		; 7F 7F 3F 0F ; Add long $0F3F7F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $99		; 70 99 ; Branch if overflow set to $70, $99 [Flow: branch]
	asl $6F82.w,X		; 1E 82 6F ; Arithmetic shift left $6F82.w,X [Reads: X Index] [Flags: NCZ]
	sbc $7D.b		; E5 7D ; Subtract $7D.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	pea $F57C.w		; F4 7C F5 ; Push absolute address $F57C.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	jmp ($1C96.w,X)		; 7C 96 1C ; Jump indirect indexed to ($1C96.w,X) [Reads: X Index] [Flow: jump]
	sta [$6D.b]		; 87 6D ; Store accumulator (long) [$6D.b] [Reads: Direct Page, Accumulator]
	sbc $7D.b		; E5 7D ; Subtract $7D.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $10, $02		; 10 02 ; Branch if plus to $10, $02 [Flow: branch]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $12.b,S		; 63 12 ; Add with carry (stack relative) $12.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cop $B4.b		; 02 B4 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $18E8.w		; AC E8 18 ; Load $18E8.w into Y register [Writes: Y Index] [Flags: NZ]
	ora $93F8.w,Y		; 19 F8 93 ; OR accumulator with memory $93F8.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $56		; F0 56 ; Branch if equal to $F0, $56 [Flow: branch]
	.db $70, $94		; 70 94 ; Branch if overflow set to $70, $94 [Flow: branch]
	lda ($44.b),Y		; B1 44 ; Load accumulator ($44.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($A0.b),Y		; 31 A0 ; AND accumulator with memory ($A0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $0743.w,Y		; 39 43 07 ; AND accumulator with memory $0743.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $C6CE4E.l		; 8F 4E CE C6 ; Store accumulator (long) $C6CE4E.l [Reads: Accumulator]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	cpy #$80.b		; C0 80 ; Compare #$80.b with Y register [Reads: Y Index] [Flags: NCZ]
	jsr $9040.w		; 20 40 90 ; Jump to subroutine at $9040.w [Writes: Stack Pointer] [Flow: call]
	cpx #$08.b		; E0 08 ; Compare #$08.b with X register [Reads: X Index] [Flags: NCZ]
	.db $70, $0C		; 70 0C ; Branch if overflow set to $70, $0C [Flow: branch]
	stz $CE.b,X		; 74 CE ; Store zero to $CE.b,X [Reads: X Index]
	ldy $8D.b,X		; B4 8D ; Load Y register $8D.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	inc $00.b,X		; F6 00 ; Increment memory $00.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $80, $12		; 80 12 ; Branch always to $80, $12 [Flow: branch]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($FC.b,X)		; 01 FC ; Logical OR ($FC.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($80.b,X)		; 01 80 ; Logical OR ($80.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($2C.b,X)		; 01 2C ; Logical OR ($2C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	adc $DD52.w		; 6D 52 DD ; Add $DD52.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $76.b,X		; B5 76 ; Load $76.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $394A.w		; 0D 4A 39 ; Logical OR $394A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $9213FE.l		; 22 FE 13 92 ; Jump to subroutine long $9213FE.l [Writes: Stack Pointer] [Flow: call]
	jsl $C6C242.l		; 22 42 C2 C6 ; Jump to subroutine long $C6C242.l [Writes: Stack Pointer] [Flow: call]
	cmp $3FCF30.l,X		; DF 30 CF 3F ; Compare accumulator (long,X) $3FCF30.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	sbc [$1F.b]		; E7 1F ; Subtract with carry (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $D0, $6F		; D0 6F ; Branch if not equal to $D0, $6F [Flow: branch]
	cmp $7FE070.l		; CF 70 E0 7F ; Compare accumulator (long) $7FE070.l [Reads: Accumulator] [Flags: NCZ]
	lda $26FF3F.l,X		; BF 3F FF 26 ; Load long $26FF3F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $DE27.w		; 1C 27 DE ; Test and reset bits $DE27.w [Reads: Accumulator] [Flags: Z]
	sta ($EE.b,S),Y		; 93 EE ; Store accumulator (stack relative indirect indexed) ($EE.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	wai		; CB ; Wait for interrupt
	lsr $76.b		; 46 76 ; Logical shift right $76.b [Reads: Direct Page] [Flags: NCZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $25.b		; 02 25 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0022FF.l,X		; FF FF 22 00 ; Subtract with carry (long,X) $0022FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $FF.b		; 04 FF ; Test and set bits $FF.b [Reads: Accumulator] [Flags: Z]
	sbc $FFFF00.l,X		; FF 00 FF FF ; Subtract with carry (long,X) $FFFF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $B08300.l		; 22 00 83 B0 ; Jump to subroutine long $B08300.l [Writes: Stack Pointer] [Flow: call]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	sbc $130022.l,X		; FF 22 00 13 ; Subtract with carry (long,X) $130022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $7E0000.l,X		; FF 00 00 7E ; Subtract with carry (long,X) $7E0000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($E7.b,X)		; 81 E7 ; Store accumulator ($E7.b,X) [Reads: Direct Page, Accumulator, X Index]
	ror $7E91.w,X		; 7E 91 7E ; Rotate right $7E91.w,X [Reads: X Index] [Flags: NCZ]
	lda ($7E.b),Y		; B1 7E ; Load accumulator ($7E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $7E.b		; 85 7E ; Store accumulator to $7E.b [Reads: Accumulator]
	sta $3E.b,S		; 83 3E ; Store accumulator (stack relative) $3E.b,S [Reads: Stack Pointer, Accumulator]
	cmp $5A.b,S		; C3 5A ; Compare accumulator (stack relative) $5A.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	ror $0081.w,X		; 7E 81 00 ; Rotate right $0081.w,X [Reads: X Index] [Flags: NCZ]
	and $7E.b		; 25 7E ; Logical AND $7E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx $31.b		; E4 31 ; Compare $31.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FF437F.l,X		; FF 7F 43 FF ; Subtract with carry (long,X) $FF437F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	mvp $FE,$08		; 44 08 FE ; Move block positive $FE,$08 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	jsr ($F850.w,X)		; FC 50 F8 ; Jump to subroutine indirect indexed ($F850.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $F0, $40		; F0 40 ; Branch if equal to $F0, $40 [Flow: branch]
	inc $22.b		; E6 22 ; Increment $22.b [Reads: Direct Page] [Flags: NZ]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $CE40.w,Y		; 19 40 CE ; OR accumulator with memory $CE40.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	inc $FE70.w,X		; FE 70 FE ; Increment memory $FE70.w,X [Reads: X Index] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	eor $FE.b,S		; 43 FE ; Exclusive OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	mvp $FF,$05		; 44 05 FF ; Move block positive $FF,$05 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	adc $FF00FF.l,X		; 7F FF 00 FF ; Add long $FF00FF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($23.b),Y		; 31 23 ; AND accumulator with memory ($23.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $42FF7F.l,X		; FF 7F FF 42 ; Subtract with carry (long,X) $42FF7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sty $15.b		; 84 15 ; Store Y register to $15.b [Reads: Y Index]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $70, $F9		; 70 F9 ; Branch if overflow set to $70, $F9 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sbc ($40.b),Y		; F1 40 ; Subtract with carry ($40.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$22.b		; E0 22 ; Compare #$22.b with X register [Reads: X Index] [Flags: NCZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $0E.b		; 06 0E ; Arithmetic shift left $0E.b [Reads: Direct Page] [Flags: NCZ]
	ora $FEFF00.l,X		; 1F 00 FF FE ; Logical OR long $FEFF00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $7F2243.l,X		; FF 43 22 7F ; Subtract with carry (long,X) $7F2243.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $12.b		; 02 12 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FF430E.l,X		; FF 0E 43 FF ; Subtract with carry (long,X) $FF430E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $22		; 80 22 ; Branch always to $80, $22 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	eor $DF.b,S		; 43 DF ; Exclusive OR accumulator with stack relative $DF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tsb $70CF.w		; 0C CF 70 ; Test and set bits $70CF.w [Reads: Accumulator] [Flags: Z]
	cmp $7C.b,S		; C3 7C ; Compare accumulator (stack relative) $7C.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	sbc ($7E.b,X)		; E1 7E ; Subtract with carry ($7E.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $7F		; F0 7F ; Branch if equal to $F0, $7F [Flow: branch]
	sta $00FF1F.l,X		; 9F 1F FF 00 ; Store accumulator (long,X) $00FF1F.l,X [Reads: Accumulator, X Index]
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: NCZ]
	ora ($0E.b,X)		; 01 0E ; Logical OR ($0E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $BC.b		; 00 BC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($3F.b,S),Y		; 73 3F ; Add with carry (stack relative indirect indexed) ($3F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $3F		; F0 3F ; Branch if equal to $F0, $3F [Flow: branch]
	cpx #$F8.b		; E0 F8 ; Compare #$F8.b with X register [Reads: X Index] [Flags: NCZ]
	cmp [$F0.b]		; C7 F0 ; Compare accumulator (long) [$F0.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora $FF2300.l		; 0F 00 23 FF ; OR accumulator with memory (long) $FF2300.l [Writes: Accumulator] [Flags: NZ]
	sta $70.b,S		; 83 70 ; Store accumulator (stack relative) $70.b,S [Reads: Stack Pointer, Accumulator]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$23.b		; E0 23 ; Compare #$23.b with X register [Reads: X Index] [Flags: NCZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $7FBF00.l,X		; FF 00 BF 7F ; Subtract with carry (long,X) $7FBF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $7C.b,S		; E3 7C ; Subtract stack-relative $7C.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	cmp $7D.b,S		; C3 7D ; Compare accumulator (stack relative) $7D.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	sbc $718F01.l,X		; FF 01 8F 71 ; Subtract with carry (long,X) $718F01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$79.b],Y		; F7 79 ; Subtract with carry (long indexed) [$79.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	adc $0027.w,X		; 7D 27 00 ; Add $0027.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $B6.b,S		; 83 B6 ; Store accumulator (stack relative) $B6.b,S [Reads: Stack Pointer, Accumulator]
	tsb $0B.b		; 04 0B ; Test and set bits $0B.b [Reads: Accumulator] [Flags: Z]
	sta [$78.b]		; 87 78 ; Store accumulator (long) [$78.b] [Reads: Direct Page, Accumulator]
	wai		; CB ; Wait for interrupt
	and [$F4.b],Y		; 37 F4 ; AND accumulator with memory (long indexed) [$F4.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sty $4B78.w		; 8C 78 4B ; Store Y register to $4B78.w [Reads: Y Index]
	lda $5A2F.w,Y		; B9 2F 5A ; Load $5A2F.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $23.b,X		; 16 23 ; Arithmetic shift left $23.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $84.b,S		; 03 84 ; OR accumulator with stack relative $84.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpy #$E1.b		; C0 E1 ; Compare #$E1.b with Y register [Reads: Y Index] [Flags: NCZ]
	and [$00.b],Y		; 37 00 ; AND accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $58.b,S		; 83 58 ; Store accumulator (stack relative) $58.b,S [Reads: Stack Pointer, Accumulator]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $FE.b,S		; 03 FE ; OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr ($0002.w,X)		; FC 02 00 ; Jump to subroutine indirect indexed ($0002.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sta $58.b,S		; 83 58 ; Store accumulator (stack relative) $58.b,S [Reads: Stack Pointer, Accumulator]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $010400.l		; 22 00 04 01 ; Jump to subroutine long $010400.l [Writes: Stack Pointer] [Flow: call]
	sbc $0000.w,X		; FD 00 00 ; Subtract with carry $0000.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $09FF.w,X		; FE FF 09 ; Increment memory $09FF.w,X [Reads: X Index] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	lda [$7D.b],Y		; B7 7D ; Load accumulator (long indexed) [$7D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda ($37.b)		; B2 37 ; Load accumulator (indirect) ($37.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	and ($DF.b)		; 32 DF ; AND accumulator with memory (indirect) ($DF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc ($1F.b)		; F2 1F ; Subtract with carry (indirect) ($1F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	eor $2A.b		; 45 2A ; Exclusive OR $2A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $0F0027.l,X		; DF 27 00 0F ; Compare accumulator (long,X) $0F0027.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc [$FF.b],Y		; F7 FF ; Subtract with carry (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $BF.b		; 00 BF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$78.b		; C0 78 ; Compare #$78.b with Y register [Reads: Y Index] [Flags: NCZ]
	sbc $603FC7.l,X		; FF C7 3F 60 ; Subtract with carry (long,X) $603FC7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $60FF3F.l,X		; 9F 3F FF 60 ; Store accumulator (long,X) $60FF3F.l,X [Reads: Accumulator, X Index]
	sta $E00027.l,X		; 9F 27 00 E0 ; Store accumulator (long,X) $E00027.l,X [Reads: Accumulator, X Index]
	sta $C7.b,S		; 83 C7 ; Store accumulator (stack relative) $C7.b,S [Reads: Stack Pointer, Accumulator]
	brk $9B.b		; 00 9B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $27.b		; 00 27 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc [$18.b]		; E7 18 ; Subtract with carry (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	eor #$B4.b		; 49 B4 ; Exclusive OR #$B4.b with accumulator [Writes: Accumulator] [Flags: NZ]
	jmp.w [$BFA2]		; DC A2 BF ; Jump long indirect [$BFA2] [Flow: jump]
	mvp $49,$BE		; 44 BE 49 ; Move block positive $49,$BE [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sbc $1AD8E7.l,X		; FF E7 D8 1A ; Subtract with carry (long,X) $1AD8E7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($25.b,S),Y		; 33 25 ; AND accumulator (stack relative indirect indexed) ($25.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	eor ($83.b),Y		; 51 83 ; Exclusive OR accumulator with memory ($83.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $7D.b		; 00 7D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E6.b		; 00 E6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $2CC7.w,X		; 3C C7 2C ; Test bits $2CC7.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	cpy $10.b		; C4 10 ; Compare $10.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	sta $3724.w,X		; 9D 24 37 ; Store accumulator to $3724.w,X [Reads: Accumulator, X Index]
	cpy #$7F.b		; C0 7F ; Compare #$7F.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $80, $FF		; 80 FF ; Branch always to $80, $FF [Flow: branch]
	sta $3D.b,S		; 83 3D ; Store accumulator (stack relative) $3D.b,S [Reads: Stack Pointer, Accumulator]
	bit $633B.w,X		; 3C 3B 63 ; Test bits $633B.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	cmp $0CD78F.l		; CF 8F D7 0C ; Compare accumulator (long) $0CD78F.l [Reads: Accumulator] [Flags: NCZ]
	stz $3303.w		; 9C 03 33 ; Store zero to $3303.w
	tsb $3847.w		; 0C 47 38 ; Test and set bits $3847.w [Reads: Accumulator] [Flags: Z]
	eor $0AB731.l		; 4F 31 B7 0A ; Exclusive OR accumulator with memory (long) $0AB731.l [Writes: Accumulator] [Flags: NZ]
	sbc ($04.b,S),Y		; F3 04 ; Subtract with carry (stack relative indirect indexed) ($04.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	ora ($E0.b,X)		; 01 E0 ; Logical OR ($E0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $CC.b,S		; E3 CC ; Subtract stack-relative $CC.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	lda $C4B2.w,Y		; B9 B2 C4 ; Load $C4B2.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	cmp $20DF.w		; CD DF 20 ; Compare $20DF.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	sbc [$5E.b]		; E7 5E ; Subtract with carry (long) [$5E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $0CF321.l,X		; FF 21 F3 0C ; Subtract with carry (long,X) $0CF321.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$AB.b],Y		; F7 AB ; Subtract with carry (long indexed) [$AB.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $1DEE06.l,X		; [PATTERN: Memory clearing operation] FF 06 EE 1D ; Subtract with carry (long,X) $1DEE06.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp.w [$2033]		; DC 33 20 ; Jump long indirect [$2033] [Flow: jump]
	stz $2041.w,X		; 9E 41 20 ; Store zero to $2041.w,X [Reads: X Index]
	ora $86.b,S		; 03 86 ; OR accumulator with stack relative $86.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	stz $0030.w		; 9C 30 00 ; Store zero to $0030.w
	sbc [$00.b],Y		; F7 00 ; Subtract with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora [$FC.b]		; 07 FC ; OR accumulator with memory (long) [$FC.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $18.b		; 02 18 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $00.b		; E5 00 ; Subtract $00.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc $FF6681.l,X		; 7F 81 66 FF ; Add long $FF6681.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0305.w		; 0E 05 03 ; Arithmetic shift left $0305.w [Flags: NCZ]
	cmp [$FE.b]		; C7 FE ; Compare accumulator (long) [$FE.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	jmp ($0000.w,X)		; 7C 00 00 ; Jump indirect indexed to ($0000.w,X) [Reads: X Index] [Flow: jump]
	sbc $1FDF00.l		; EF 00 DF 1F ; Subtract with carry (long) $1FDF00.l [Writes: Accumulator] [Flags: NCVZ]
	cpx #$3F.b		; E0 3F ; Compare #$3F.b with X register [Reads: X Index] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	clc		; 18 ; Clear carry flag [Flags: C]
	lda [$00.b]		; A7 00 ; Load accumulator (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $9C83.w,X		; FE 83 9C ; Increment memory $9C83.w,X [Reads: X Index] [Flags: NZ]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $C0A070.l,X		; BF 70 A0 C0 ; Load long $C0A070.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $7F.b,S		; E3 7F ; Subtract stack-relative $7F.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	rol $4C00.w,X		; 3E 00 4C ; Rotate left $4C00.w,X [Reads: X Index] [Flags: NCZ]
	sta ($CC.b,S),Y		; 93 CC ; Store accumulator (stack relative indirect indexed) ($CC.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	and ($C4.b,S),Y		; 33 C4 ; AND accumulator (stack relative indirect indexed) ($C4.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sty $6A.b		; 84 6A ; Store Y register to $6A.b [Reads: Y Index]
	.db $82, $75, $80		; 82 75 80 ; Branch always long to $82, $75, $80 [Flow: branch]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $90, $6F		; 90 6F ; Branch if carry clear to $90, $6F [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ror $22.b		; 66 22 ; Rotate right $22.b [Reads: Direct Page] [Flags: NCZ]
	and ($06.b),Y		; 31 06 ; AND accumulator with memory ($06.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $6E7D.w,Y		; 39 7D 6E ; AND accumulator with memory $6E7D.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc [$63.b]		; 67 63 ; Add with carry (long) [$63.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and ($C8.b,S),Y		; 33 C8 ; AND accumulator (stack relative indirect indexed) ($C8.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $31.b,S		; 43 31 ; Exclusive OR accumulator with stack relative $31.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $21E0.w		; CE E0 21 ; Decrement $21E0.w [Flags: NZ]
	and $39C4.w,Y		; 39 C4 39 ; AND accumulator with memory $39C4.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	mvp $AE,$11		; 44 11 AE ; Move block positive $AE,$11 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora ($F6.b,X)		; 01 F6 ; Logical OR ($F6.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $EC.b,S		; 03 EC ; OR accumulator with stack relative $EC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sty $868E.w		; 8C 8E 86 ; Store Y register to $868E.w [Reads: Y Index]
	stx $C6.b		; 86 C6 ; Store X register to $C6.b [Reads: X Index]
	inc $B85C.w		; EE 5C B8 ; Increment $B85C.w [Flags: NZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $73CC00.l,X		; FF 00 CC 73 ; Subtract with carry (long,X) $73CC00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	adc [$B6.b]		; 67 B6 ; Add with carry (long) [$B6.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lsr $1DED.w		; 4E ED 1D ; Logical shift right $1DED.w [Flags: NCZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
.ACCU 16
.INDEX 16
	rep #$3F		; C2 3F
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,S),Y		; 13 01 ; OR accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$F3.b],Y		; F7 F3 ; Subtract with carry (long indexed) [$F3.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $AC5F67.l		; EF 67 5F AC ; Subtract with carry (long) $AC5F67.l [Writes: Accumulator] [Flags: NCVZ]
	jmp.w [$BC44]		; DC 44 BC ; Jump long indirect [$BC44] [Flow: jump]
.ACCU 8
	sep #$62		; E2 62
	cpy #$2240.w		; C0 40 22 ; Compare #$2240.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $80.b		; 45 80 ; Exclusive OR $80.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $9D3F.w,X		; 1D 3F 9D ; OR accumulator with memory $9D3F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $81		; 30 81 ; Branch if minus to $30, $81 [Flow: branch]
	asl $01BC.w,X		; 1E BC 01 ; Arithmetic shift left $01BC.w,X [Reads: X Index] [Flags: NCZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	ora $FA.b,S		; 03 FA ; OR accumulator with stack relative $FA.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $FE.b,S		; 43 FE ; Exclusive OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($F6.b,X)		; 01 F6 ; Logical OR ($F6.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $FF.b		; 06 FF ; Arithmetic shift left $FF.b [Reads: Direct Page] [Flags: NCZ]
	brk $4E.b		; 00 4E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ror $3C7C.w,X		; 7E 7C 3C ; Rotate right $3C7C.w,X [Reads: X Index] [Flags: NCZ]
	brk $F9.b		; 00 F9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $EE31FF.l,X		; FF FF 31 EE ; Subtract with carry (long,X) $EE31FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($6F.b),Y		; 71 6F ; Add with carry ($6F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($BF.b),Y		; 31 BF ; AND accumulator with memory ($BF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($5F.b)		; 12 5F ; OR accumulator with memory (indirect) ($5F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($BF.b,X)		; 01 BF ; Logical OR ($BF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $80, $E0		; 80 E0 ; Branch always to $80, $E0 [Flow: branch]
	cpx #$00FF.w		; E0 FF 00 ; Compare #$00FF.w with X register [Reads: X Index] [Flags: NCZ]
	and ($71.b),Y		; 31 71 ; AND accumulator with memory ($71.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda $E0DE.w,X		; BD DE E0 ; Load $E0DE.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $F3FF1F.l,X		; 7F 1F FF F3 ; Add long $F3FF1F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $00FF.w		; 0C FF 00 ; Test and set bits $00FF.w [Reads: Accumulator] [Flags: Z]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($FF.b),Y		; 11 FF ; OR accumulator with memory ($FF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $FCFFFE.l,X		; FF FE FF FC ; Subtract with carry (long,X) $FCFFFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $08FE01.l,X		; FF 01 FE 08 ; Subtract with carry (long,X) $08FE01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	inc $EF81.w		; EE 81 EF ; Increment $EF81.w [Flags: NZ]
	sta ($DC.b,X)		; 81 DC ; Store accumulator ($DC.b,X) [Reads: Direct Page, Accumulator, X Index]
	.db $42, $BE		; 42 BE ; Reserved instruction
	.db $82, $54, $00		; 82 54 00 ; Branch always long to $82, $54, $00 [Flow: branch]
	ldy $DB38.w		; AC 38 DB ; Load $DB38.w into Y register [Writes: Y Index] [Flags: NZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	sbc $989800.l,X		; FF 00 98 98 ; Subtract with carry (long,X) $989800.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and #$69.b		; 29 69 ; Logical AND #$69.b with accumulator [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cmp $27.b,S		; C3 27 ; Compare accumulator (stack relative) $27.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	sbc $FF00FF.l,X		; FF FF 00 FF ; Subtract with carry (long,X) $FF00FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $60E045.l,X		; 7F 45 E0 60 ; Add long $60E045.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$B0.b]		; 07 B0 ; OR accumulator with memory (long) [$B0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $30, $DF		; 30 DF ; Branch if minus to $30, $DF [Flow: branch]
	sta $FFC070.l,X		; 9F 70 C0 FF ; Store accumulator (long,X) $FFC070.l,X [Reads: Accumulator, X Index]
	.db $80, $22		; 80 22 ; Branch always to $80, $22 [Flow: branch]
	sta $60CF0A.l,X		; 9F 0A CF 60 ; Store accumulator (long,X) $60CF0A.l,X [Reads: Accumulator, X Index]
	and $FB01FC.l,X		; 3F FC 01 FB ; AND accumulator with memory (long,X) $FB01FC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $7CFE.w,Y		; 79 FE 7C ; Add $7CFE.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $44.b		; C5 44 ; Compare $44.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	eor [$C3.b]		; 47 C3 ; Exclusive OR accumulator with memory (long) [$C3.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $42, $03		; 42 03 ; Reserved instruction
	inc $8386.w,X		; FE 86 83 ; Increment memory $8386.w,X [Reads: X Index] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	and $BD.b,S		; 23 BD ; AND accumulator with stack relative $BD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx #$FF83.w		; E0 83 FF ; Compare #$FF83.w with X register [Reads: X Index] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc $A97E40.l,X		; FF 40 7E A9 ; Subtract with carry (long,X) $A97E40.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $A3C3.w,X		; 3D C3 A3 ; AND accumulator with memory $A3C3.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dec $56EB.w,X		; DE EB 56 ; Decrement memory $56EB.w,X [Reads: X Index] [Flags: NZ]
	inc $4D.b,X		; F6 4D ; Increment memory $4D.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	jsr ($462B.w,X)		; FC 2B 46 ; Jump to subroutine indirect indexed ($462B.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr $C391.w		; 20 91 C3 ; Jump to subroutine at $C391.w [Writes: Stack Pointer] [Flow: call]
	dec $46.b		; C6 46 ; Decrement $46.b [Reads: Direct Page] [Flags: NZ]
	jmp $5B28.w		; 4C 28 5B ; Jump to $5B28.w [Flow: jump]
	.db $80, $4F		; 80 4F ; Branch always to $80, $4F [Flow: branch]
	.db $80, $51		; 80 51 ; Branch always to $80, $51 [Flow: branch]
	.db $80, $4C		; 80 4C ; Branch always to $80, $4C [Flow: branch]
	lda ($62.b,X)		; A1 62 ; Load accumulator ($62.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sta ($BF.b),Y		; 91 BF ; Store accumulator ($BF.b),Y [Reads: Direct Page, Y Index, Accumulator]
	cpy #$6DD2.w		; C0 D2 6D ; Compare #$6DD2.w with Y register [Reads: Y Index] [Flags: NCZ]
	adc $B9B7B1.l		; 6F B1 B7 B9 ; Add with carry (long) $B9B7B1.l [Writes: Accumulator] [Flags: NCVZ]
	lda $C08C92.l		; AF 92 8C C0 ; Load long $C08C92.l into accumulator [Writes: Accumulator] [Flags: NZ]
	adc ($31.b,X)		; 61 31 ; Add with carry ($31.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy $7903.w,X		; BC 03 79 ; Load Y register $7903.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	cop $63.b		; 02 63 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $47.b,X		; 34 47 ; Test bits $47.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	eor $30.b		; 45 30 ; Exclusive OR $30.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $00B334.l,X		; 7F 34 B3 00 ; Add long $00B334.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp [$00.b],Y		; D7 00 ; Compare accumulator (long indexed) [$00.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cmp $86.b,S		; C3 86 ; Compare accumulator (stack relative) $86.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	ldy $BBB8.w,X		; BC B8 BB ; Load Y register $BBB8.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda ($CF.b,S),Y		; B3 CF ; Load accumulator (stack relative indirect indexed) ($CF.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $FBFD06.l		; EF 06 FD FB ; Subtract with carry (long) $FBFD06.l [Writes: Accumulator] [Flags: NCVZ]
	asl $0D.b		; 06 0D ; Arithmetic shift left $0D.b [Reads: Direct Page] [Flags: NCZ]
	ora ($A6.b,S),Y		; 13 A6 ; OR accumulator (stack relative indirect indexed) ($A6.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora #$D5.b		; 09 D5 ; Logical OR #$D5.b with accumulator [Writes: Accumulator] [Flags: NZ]
	cop $55.b		; 02 55 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $CF.b		; 02 CF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E5.b		; 00 E5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	jsr ($E306.w,X)		; FC 06 E3 ; Jump to subroutine indirect indexed ($E306.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cmp ($68.b),Y		; D1 68 ; Compare accumulator ($68.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	.db $B0, $E3		; B0 E3 ; Branch if carry set to $B0, $E3 [Flow: branch]
	sbc $F60F06.l,X		; FF 06 0F F6 ; Subtract with carry (long,X) $F60F06.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$7A.b]		; 07 7A ; OR accumulator with memory (long) [$7A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and [$DA.b]		; 27 DA ; AND accumulator with memory (long) [$DA.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc [$88.b],Y		; 77 88 ; Add with carry (long indexed) [$88.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $F60FE6.l,X		; 1F E6 0F F6 ; Logical OR long $F60FE6.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $E40436.l		; CF 36 04 E4 ; Compare accumulator (long) $E40436.l [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $88		; F0 88 ; Branch if equal to $F0, $88 [Flow: branch]
	brk $C4.b		; 00 C4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $24.b		; E4 24 ; Compare $24.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc $C302.w,X		; FD 02 C3 ; Subtract with carry $C302.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $FE01.w,X		; 3C 01 FE ; Test bits $FE01.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	ora ($FA.b,X)		; 01 FA ; Logical OR ($FA.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($F6.b,X)		; 01 F6 ; Logical OR ($F6.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($CE.b,X)		; 01 CE ; Logical OR ($CE.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor $01.b,S		; 43 01 ; Exclusive OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $0007.w,X		; FE 07 00 ; Increment memory $0007.w,X [Reads: X Index] [Flags: NZ]
	trb $CEA6.w		; 1C A6 CE ; Test and reset bits $CEA6.w [Reads: Accumulator] [Flags: Z]
	jsr ($8078.w,X)		; FC 78 80 ; Jump to subroutine indirect indexed ($8078.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpx $C043.w		; EC 43 C0 ; Compare $C043.w with X register [Reads: X Index] [Flags: NCZ]
	and $7B8044.l,X		; 3F 44 80 7B ; AND accumulator with memory (long,X) $7B8044.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$7739.w		; E0 39 77 ; Compare #$7739.w with X register [Reads: X Index] [Flags: NCZ]
	.db $80, $6E		; 80 6E ; Branch always to $80, $6E [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	lda $3B00FF.l,X		; BF FF 00 3B ; Load long $3B00FF.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $4E2D.w,X		; 1D 2D 4E ; OR accumulator with memory $4E2D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $00317B.l,X		; 5F 7B 31 00 ; Exclusive OR accumulator with memory (long,X) $00317B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta ($5E.b,X)		; 81 5E ; Store accumulator ($5E.b,X) [Reads: Direct Page, Accumulator, X Index]
	bit #$76.b		; 89 76 ; Test bits #$76.b with accumulator [Reads: Accumulator] [Flags: Z]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc [$8C.b]		; 67 8C ; Add with carry (long) [$8C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc ($C7.b,S),Y		; 73 C7 ; Add with carry (stack relative indirect indexed) ($C7.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $F7FFC7.l,X		; FF C7 FF F7 ; Subtract with carry (long,X) $F7FFC7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $667600.l,X		; FF 00 76 66 ; Subtract with carry (long,X) $667600.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $20.b,S		; 63 20 ; Add with carry (stack relative) $20.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $C7		; 10 C7 ; Branch if plus to $10, $C7 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	ror $6CCB.w		; 6E CB 6C ; Rotate right $6CCB.w [Flags: NCZ]
.ACCU 16
.INDEX 16
	rep #$7D		; C2 7D
	cmp $73.b,X		; D5 73 ; Compare accumulator $73.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sta $73.b,X		; 95 73 ; Store accumulator to $73.b,X [Reads: Accumulator, X Index]
	cmp $73.b,X		; D5 73 ; Compare accumulator $73.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	jmp.w [$D67B]		; DC 7B D6 ; Jump long indirect [$D67B] [Flow: jump]
	adc $1010.w,Y		; 79 10 10 ; Add $1010.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cpx #$0029.w		; E0 29 00 ; Compare #$0029.w with X register [Reads: X Index] [Flags: NCZ]
	brk $82.b		; 00 82 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $901E.w		; 0E 1E 90 ; Arithmetic shift left $901E.w [Flags: NCZ]
	ldx $1EA0.w,Y		; BE A0 1E ; Load X register $1EA0.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	jsr $221E.w		; 20 1E 22 ; Jump to subroutine at $221E.w [Writes: Stack Pointer] [Flow: call]
	bit $9824.w,X		; 3C 24 98 ; Test bits $9824.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$71C0.w		; C0 C0 71 ; Compare #$71C0.w with Y register [Reads: Y Index] [Flags: NCZ]
	adc ($41.b,X)		; 61 41 ; Add with carry ($41.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp ($C1.b,X)		; C1 C1 ; Compare accumulator ($C1.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	cmp $67.b,S		; C3 67 ; Compare accumulator (stack relative) $67.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	and $FB2BFD.l,X		; 3F FD 2B FB ; AND accumulator with memory (long,X) $FB2BFD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$DF.b]		; 07 DF ; OR accumulator with memory (long) [$DF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and [$BC.b],Y		; 37 BC ; AND accumulator with memory (long indexed) [$BC.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	stz $E5.b,X		; 74 E5 ; Store zero to $E5.b,X [Reads: X Index]
	jmp ($4CCA.w)		; 6C CA 4C ; Jump indirect to ($4CCA.w) [Flow: jump]
	cmp $BF47.w		; CD 47 BF ; Compare $BF47.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $62, $22, $00		; 62 22 00 ; Push effective relative address $62, $22, $00 [Writes: Stack Pointer]
	cpx #$0331.w		; E0 31 03 ; Compare #$0331.w with X register [Reads: X Index] [Flags: NCZ]
	ora ($33.b,S),Y		; 13 33 ; OR accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	trb $DCFF.w		; 1C FF DC ; Test and reset bits $DCFF.w [Reads: Accumulator] [Flags: Z]
	and $01.b,S		; 23 01 ; AND accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $B7.b		; 00 B7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $3F.b		; 24 3F ; Test bits $3F.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	adc $80FF40.l,X		; 7F 40 FF 80 ; Add long $80FF40.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $DC001F.l,X		; FF 1F 00 DC ; Subtract with carry (long,X) $DC001F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $C1C9.w,X		; DD C9 C1 ; Compare accumulator $C1C9.w,X [Reads: X Index] [Flags: NCZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	ora $8731CE.l,X		; 1F CE 31 87 ; Logical OR long $8731CE.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sta [$4B.b]		; 87 4B ; Store accumulator (long) [$4B.b] [Reads: Direct Page, Accumulator]
	sta $35.b,S		; 83 35 ; Store accumulator (stack relative) $35.b,S [Reads: Stack Pointer, Accumulator]
	sta $79.b,S		; 83 79 ; Store accumulator (stack relative) $79.b,S [Reads: Stack Pointer, Accumulator]
	sta ($6D.b,S),Y		; 93 6D ; Store accumulator (stack relative indirect indexed) ($6D.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	ror $0091.w		; 6E 91 00 ; Rotate right $0091.w [Flags: NCZ]
	sbc $783031.l,X		; FF 31 30 78 ; Subtract with carry (long,X) $783031.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp ($226C.w,X)		; 7C 6C 22 ; Jump indirect indexed to ($226C.w,X) [Reads: X Index] [Flow: jump]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	sbc [$24.b],Y		; F7 24 ; Subtract with carry (long indexed) [$24.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	.db $10, $FD		; 10 FD ; Branch if plus to $10, $FD [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sbc $A4BFC4.l,X		; FF C4 BF A4 ; Subtract with carry (long,X) $A4BFC4.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $AD90.w,X		; DD 90 AD ; Compare accumulator $AD90.w,X [Reads: X Index] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cmp [$02.b],Y		; D7 02 ; Compare accumulator (long indexed) [$02.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	tsb $0206.w		; 0C 06 02 ; Test and set bits $0206.w [Reads: Accumulator] [Flags: Z]
	.db $42, $62		; 42 62 ; Reserved instruction
	adc ($38.b)		; 72 38 ; Add with carry (indirect) ($38.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp $5FA720.l		; CF 20 A7 5F ; Compare accumulator (long) $5FA720.l [Reads: Accumulator] [Flags: NCZ]
	sbc #$ED56.w		; E9 56 ED ; Subtract #$ED56.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	adc ($95.b)		; 72 95 ; Add with carry (indirect) ($95.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	lda $B0506F.l		; AF 6F 50 B0 ; Load long $B0506F.l into accumulator [Writes: Accumulator] [Flags: NZ]
	adc [$BF.b]		; 67 BF ; Add with carry (long) [$BF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $180022.l,X		; 1F 22 00 18 ; Logical OR long $180022.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsr $0F10.w		; 20 10 0F ; Jump to subroutine at $0F10.w [Writes: Stack Pointer] [Flow: call]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $B3.b,S		; 03 B3 ; OR accumulator with stack relative $B3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jmp ($9774.w,X)		; 7C 74 97 ; Jump indirect indexed to ($9774.w,X) [Reads: X Index] [Flow: jump]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	and ($4B.b)		; 32 4B ; AND accumulator with memory (indirect) ($4B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $4D65.w,X		; 5D 65 4D ; Exclusive OR accumulator with memory $4D65.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $457F.w,X		; 7D 7F 45 ; Add $457F.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $84.b		; 04 84 ; Test and set bits $84.b [Reads: Accumulator] [Flags: Z]
	jsl $EC4382.l		; 22 82 43 EC ; Jump to subroutine long $EC4382.l [Writes: Stack Pointer] [Flow: call]
	ora $E0.b,S		; 03 E0 ; OR accumulator with stack relative $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($FE.b,S),Y		; 33 FE ; AND accumulator (stack relative indirect indexed) ($FE.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($DE.b,X)		; 01 DE ; Logical OR ($DE.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($BE.b),Y		; 11 BE ; OR accumulator with memory ($BE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($DE.b,X)		; 21 DE ; Logical AND ($DE.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor ($BF.b,X)		; 41 BF ; Exclusive OR accumulator with memory ($BF.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	jsr $10BF.w		; 20 BF 10 ; Jump to subroutine at $10BF.w [Writes: Stack Pointer] [Flow: call]
	and ($13.b,S),Y		; 33 13 ; AND accumulator (stack relative indirect indexed) ($13.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($69.b,X)		; 21 69 ; Logical AND ($69.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor $21.b		; 45 21 ; Exclusive OR $21.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $50, $48		; 50 48 ; Branch if overflow clear to $50, $48 [Flow: branch]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	brk $96.b		; 00 96 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D6.b		; 00 D6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	and #$817C.w		; 29 7C 81 ; Logical AND #$817C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jmp ($7D80.w,X)		; 7C 80 7D ; Jump indirect indexed to ($7D80.w,X) [Reads: X Index] [Flow: jump]
	.db $80, $57		; 80 57 ; Branch always to $80, $57 [Flow: branch]
	.db $80, $4D		; 80 4D ; Branch always to $80, $4D [Flow: branch]
	adc #$0629.w		; 69 29 06 ; Add #$0629.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	.db $82, $93, $BA		; 82 93 BA ; Branch always long to $82, $93, $BA [Flow: branch]
	ldy $00FF.w		; AC FF 00 ; Load $00FF.w into Y register [Writes: Y Index] [Flags: NZ]
	pea $EB04.w		; F4 04 EB ; Push absolute address $EB04.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and $FF4311.l,X		; 3F 11 43 FF ; AND accumulator with memory (long,X) $FF4311.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and #$C03F.w		; 29 3F C0 ; Logical AND #$C03F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $FC.b,S		; 03 FC ; OR accumulator with stack relative $FC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $1B.b		; 00 1B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $C2.b,X		; B4 C2 ; Load Y register $C2.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	ora ($08.b),Y		; 11 08 ; OR accumulator with memory ($08.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$F0FC.w		; C0 FC F0 ; Compare #$F0FC.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora $9E20BF.l		; 0F BF 20 9E ; OR accumulator with memory (long) $9E20BF.l [Writes: Accumulator] [Flags: NZ]
	.db $10, $FF		; 10 FF ; Branch if plus to $10, $FF [Flow: branch]
	brk $9E.b		; 00 9E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $6F		; 10 6F ; Branch if plus to $10, $6F [Flow: branch]
	brk $F1.b		; 00 F1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $0663C0.l		; 0F C0 63 06 ; OR accumulator with memory (long) $0663C0.l [Writes: Accumulator] [Flags: NZ]
	sbc $91.b,S		; E3 91 ; Subtract stack-relative $91.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	asl $0CE4.w,X		; 1E E4 0C ; Arithmetic shift left $0CE4.w,X [Reads: X Index] [Flags: NCZ]
	adc ($00.b,S),Y		; 73 00 ; Add with carry (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	and $437F00.l,X		; 3F 00 7F 43 ; AND accumulator with memory (long,X) $437F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $CF		; 30 CF ; Branch if minus to $30, $CF [Flow: branch]
	ora ($00.b,S),Y		; 13 00 ; OR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldx $5986.w,Y		; BE 86 59 ; Load X register $5986.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	sbc $FBC100.l,X		; FF 00 C1 FB ; Subtract with carry (long,X) $FBC100.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($478E.w,X)		; FC 8E 47 ; Jump to subroutine indirect indexed ($478E.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	adc ($00.b),Y		; 71 00 ; Add with carry ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $CE		; 30 CE ; Branch if minus to $30, $CE [Flow: branch]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $0C.b,S		; 43 0C ; Exclusive OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc ($E0.b,S),Y		; F3 E0 ; Subtract with carry (stack relative indirect indexed) ($E0.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	jsr $7D00.w		; 20 00 7D ; Jump to subroutine at $7D00.w [Writes: Stack Pointer] [Flow: call]
	adc ($9A.b,X)		; 61 9A ; Add with carry ($9A.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $DF8300.l,X		; FF 00 83 DF ; Subtract with carry (long,X) $DF8300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $DFE271.l,X		; 3F 71 E2 DF ; AND accumulator with memory (long,X) $DFE271.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	stx $9C00.w		; 8E 00 9C ; Store X register to $9C00.w [Reads: X Index]
	eor $8A.b,S		; 43 8A ; Exclusive OR accumulator with stack relative $8A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $81.b,X		; 55 81 ; Exclusive OR accumulator with memory $81.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ror $43.b		; 66 43 ; Rotate right $43.b [Reads: Direct Page] [Flags: NCZ]
	ldy $DB24.w,X		; BC 24 DB ; Load Y register $DB24.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	sbc $DF.b,S		; E3 DF ; Subtract stack-relative $DF.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	and $D4.b,S		; 23 D4 ; AND accumulator with stack relative $D4.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $A8.b,S		; 43 A8 ; Exclusive OR accumulator with stack relative $A8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc ($74.b,X)		; 61 74 ; Add with carry ($74.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $1822.w,X		; 3C 22 18 ; Test bits $1822.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	cpx #$1C2E.w		; E0 2E 1C ; Compare #$1C2E.w with X register [Reads: X Index] [Flags: NCZ]
	bit $1C03.w,X		; 3C 03 1C ; Test bits $1C03.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	ora ($BA.b,X)		; 01 BA ; Logical OR ($BA.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $19E4.w,Y		; 19 E4 19 ; OR accumulator with memory $19E4.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	inc $81.b		; E6 81 ; Increment $81.b [Reads: Direct Page] [Flags: NZ]
	ror $7C83.w,X		; 7E 83 7C ; Rotate right $7C83.w,X [Reads: X Index] [Flags: NCZ]
	ora $FC.b,S		; 03 FC ; OR accumulator with stack relative $FC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($FA.b,X)		; 01 FA ; Logical OR ($FA.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	pea $66EE.w		; F4 EE 66 ; Push absolute address $66EE.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	ror $74.b		; 66 74 ; Rotate right $74.b [Reads: Direct Page] [Flags: NCZ]
	sec		; 38 ; Set carry flag [Flags: C]
	jmp $75C2CE.l		; 5C CE C2 75 ; Jump long to $75C2CE.l [Flow: jump]
	cmp ($70.b,S),Y		; D3 70 ; Compare accumulator (stack relative indirect indexed) ($70.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	sta $E27E.w,Y		; 99 7E E2 ; Store accumulator to $E27E.w,Y [Reads: Y Index, Accumulator]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $7D.b,X		; F5 7D ; Subtract $7D.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $3F.b,S		; E3 3F ; Subtract stack-relative $3F.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	lda #$975E.w		; A9 5E 97 ; Load #$975E.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ror $0C08.w		; 6E 08 0C ; Rotate right $0C08.w [Flags: NCZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $E3.b,S		; 63 E3 ; Add with carry (stack relative) $E3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	rol $F5.b,X		; 36 F5 ; Rotate left $F5.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sta [$75.b],Y		; 97 75 ; Store accumulator (long indexed) [$75.b],Y [Reads: Direct Page, Y Index, Accumulator]
	cmp [$35.b],Y		; D7 35 ; Compare accumulator (long indexed) [$35.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	eor ($A3.b,X)		; 41 A3 ; Exclusive OR accumulator with memory ($A3.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ldx #$6163.w		; A2 63 61 ; Load #$6163.w into X register [Writes: X Index] [Flags: NZ]
	sbc ($B4.b,X)		; E1 B4 ; Subtract with carry ($B4.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy $1C.b,X		; B4 1C ; Load Y register $1C.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	jsl $1C1408.l		; 22 08 14 1C ; Jump to subroutine long $1C1408.l [Writes: Stack Pointer] [Flow: call]
	trb $4B1E.w		; 1C 1E 4B ; Test and reset bits $4B1E.w [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	inc $EF1C.w		; EE 1C EF ; Increment $EF1C.w [Flags: NZ]
	sbc $0BF5C0.l,X		; FF C0 F5 0B ; Subtract with carry (long,X) $0BF5C0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ldx $B6D2.w,Y		; BE D2 B6 ; Load X register $B6D2.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
.ACCU 8
	sep #$A6		; E2 A6
	sbc [$A4.b]		; E7 A4 ; Subtract with carry (long) [$A4.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($09.b,X)		; 01 09 ; Logical OR ($09.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $8618.w,Y		; 19 18 86 ; OR accumulator with memory $8618.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $FD807F.l,X		; FF 7F 80 FD ; Subtract with carry (long,X) $FD807F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $84C3E1.l,X		; 1F E1 C3 84 ; Logical OR long $84C3E1.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldx $02.b		; A6 02 ; Load $02.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	bit $FF.b		; 24 FF ; Test bits $FF.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $E3.b		; 00 E3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $0022.w		; 1C 22 00 ; Test and reset bits $0022.w [Reads: Accumulator] [Flags: Z]
	cop $1C.b		; 02 1C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $85D9.w,Y		; 59 D9 85 ; Exclusive OR accumulator with memory $85D9.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	rol $E000.w		; 2E 00 E0 ; Rotate left $E000.w [Flags: NCZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	bit $18.b		; 24 18 ; Test bits $18.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sbc [$08.b]		; E7 08 ; Subtract with carry (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	rol $C9.b		; 26 C9 ; Rotate left $C9.b [Reads: Direct Page] [Flags: NCZ]
	dec $A9.b		; C6 A9 ; Decrement $A9.b [Reads: Direct Page] [Flags: NZ]
	cpy $9A.b		; C4 9A ; Compare $9A.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	cpy $9B.b		; C4 9B ; Compare $9B.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	sbc $18DBE7.l,X		; FF E7 DB 18 ; Subtract with carry (long,X) $18DBE7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $3939.w,Y		; 19 39 39 ; OR accumulator with memory $3939.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($37.b),Y		; 31 37 ; AND accumulator with memory ($37.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	bit $16F5.w		; 2C F5 16 ; Test bits $16F5.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $BFC4.w,X		; FD C4 BF ; Subtract with carry $BFC4.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx #$92DF.w		; A2 DF 92 ; Load #$92DF.w into X register [Writes: X Index] [Flags: NZ]
	sbc $104048.l		; EF 48 40 10 ; Subtract with carry (long) $104048.l [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $30, $FA		; 30 FA ; Branch if minus to $30, $FA [Flow: branch]
	and $9F37FA.l		; 2F FA 37 9F ; AND accumulator with memory (long) $9F37FA.l [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ldx $B35E.w		; AE 5E B3 ; Load $B35E.w into X register [Writes: X Index] [Flags: NZ]
	adc $8070BF.l		; 6F BF 70 80 ; Add with carry (long) $8070BF.l [Writes: Accumulator] [Flags: NCVZ]
	and $0022FF.l,X		; 3F FF 22 00 ; AND accumulator with memory (long,X) $0022FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $4140.w,Y		; 19 40 41 ; OR accumulator with memory $4140.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $70, $7F		; 70 7F ; Branch if overflow set to $70, $7F [Flow: branch]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C1.b		; 00 C1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $EEDD.w,X		; 3C DD EE ; Test bits $EEDD.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	sbc $F576.w		; ED 76 F5 ; Subtract $F576.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	and $DA.b,X		; 35 DA ; Logical AND $DA.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $2DDA.w,X		; FD DA 2D ; Subtract with carry $2DDA.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $2206.w		; 0E 06 22 ; Arithmetic shift left $2206.w [Flags: NCZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($FF.b)		; 12 FF ; OR accumulator with memory (indirect) ($FF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $830022.l,X		; FF 22 00 83 ; Subtract with carry (long,X) $830022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $FF0001.l,X		; 7F 01 00 FF ; Add long $FF0001.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $B08300.l		; 22 00 83 B0 ; Jump to subroutine long $B08300.l [Writes: Stack Pointer] [Flow: call]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	sbc $130022.l,X		; FF 22 00 13 ; Subtract with carry (long,X) $130022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $7E0000.l,X		; FF 00 00 7E ; Subtract with carry (long,X) $7E0000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($E7.b,X)		; 81 E7 ; Store accumulator ($E7.b,X) [Reads: Direct Page, Accumulator, X Index]
	ror $7E91.w,X		; 7E 91 7E ; Rotate right $7E91.w,X [Reads: X Index] [Flags: NCZ]
	lda ($7E.b),Y		; B1 7E ; Load accumulator ($7E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $7E.b		; 85 7E ; Store accumulator to $7E.b [Reads: Accumulator]
	sta $3E.b,S		; 83 3E ; Store accumulator (stack relative) $3E.b,S [Reads: Stack Pointer, Accumulator]
	cmp $5A.b,S		; C3 5A ; Compare accumulator (stack relative) $5A.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	ror $0081.w,X		; 7E 81 00 ; Rotate right $0081.w,X [Reads: X Index] [Flags: NCZ]
	and $7E.b		; 25 7E ; Logical AND $7E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $7F00.w,X		; 1E 00 7F ; Arithmetic shift left $7F00.w,X [Reads: X Index] [Flags: NCZ]
	.db $80, $01		; 80 01 ; Branch always to $80, $01 [Flow: branch]
	inc $00.b		; E6 00 ; Increment $00.b [Reads: Direct Page] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $BD.b		; 00 BD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9B.b		; 00 9B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $BC0000.l,X		; FF 00 00 BC ; Subtract with carry (long,X) $BC0000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $0EE6.w		; CE E6 0E ; Decrement $0EE6.w [Flags: NZ]
	jsr ($00FE.w,X)		; FC FE 00 ; Jump to subroutine indirect indexed ($00FE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora ($DA.b,X)		; 01 DA ; Logical OR ($DA.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta ($68.b,X)		; 81 68 ; Store accumulator ($68.b,X) [Reads: Direct Page, Accumulator, X Index]
	sta ($78.b,X)		; 81 78 ; Store accumulator ($78.b,X) [Reads: Direct Page, Accumulator, X Index]
	mvp $3A,$81		; 44 81 3A ; Move block positive $3A,$81 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	asl $54.b,X		; 16 54 ; Arithmetic shift left $54.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sta ($6E.b,X)		; 81 6E ; Store accumulator ($6E.b,X) [Reads: Direct Page, Accumulator, X Index]
	cmp ($3E.b,X)		; C1 3E ; Compare accumulator ($3E.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	ror $36.b,X		; 76 36 ; Rotate right $36.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	lsr $46.b,X		; 56 46 ; Logical shift right $46.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ror $3A7E.w		; 6E 7E 3A ; Rotate right $3A7E.w [Flags: NCZ]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$CC.b]		; 07 CC ; OR accumulator with memory (long) [$CC.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc [$8C.b],Y		; F7 8C ; Subtract with carry (long indexed) [$8C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$EC.b],Y		; F7 EC ; Subtract with carry (long indexed) [$EC.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta [$CC.b],Y		; 97 CC ; Store accumulator (long indexed) [$CC.b],Y [Reads: Direct Page, Y Index, Accumulator]
	lda [$43.b],Y		; B7 43 ; Load accumulator (long indexed) [$43.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sty $01F7.w		; 8C F7 01 ; Store Y register to $01F7.w [Reads: Y Index]
	sta $0027F0.l		; 8F F0 27 00 ; Store accumulator (long) $0027F0.l [Reads: Accumulator]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc $E61BFE.l,X		; FF FE 1B E6 ; Subtract with carry (long,X) $E61BFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora #$F6.b		; 09 F6 ; Logical OR #$F6.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($FE.b,X)		; 01 FE ; Logical OR ($FE.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $44FF00.l,X		; FF 00 FF 44 ; Subtract with carry (long,X) $44FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $002780.l,X		; 7F 80 27 00 ; Add long $002780.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $3BFFFF.l		; 0F FF FF 3B ; OR accumulator with memory (long) $3BFFFF.l [Writes: Accumulator] [Flags: NZ]
	cmp [$01.b]		; C7 01 ; Compare accumulator (long) [$01.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sbc $FF738C.l,X		; FF 8C 73 FF ; Subtract with carry (long,X) $FF738C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $87.b		; 00 87 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $84AB05.l,X		; DF 05 AB 84 ; Compare accumulator (long,X) $84AB05.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	asl $70.b,X		; 16 70 ; Arithmetic shift left $70.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $50, $70		; 50 70 ; Branch if overflow clear to $50, $70 [Flow: branch]
	sta $88E6.w,X		; 9D E6 88 ; Store accumulator to $88E6.w,X [Reads: Accumulator, X Index]
	sbc $C8.b,X		; F5 C8 ; Subtract $C8.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda ($C8.b)		; B2 C8 ; Load accumulator (indirect) ($C8.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy $D8.b,X		; B4 D8 ; Load Y register $D8.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	lda [$9F.b]		; A7 9F ; Load accumulator (long) [$9F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx $CC.b		; E4 CC ; Compare $CC.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc [$EE.b],Y		; F7 EE ; Subtract with carry (long indexed) [$EE.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$00.b],Y		; F7 00 ; Subtract with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$23.b]		; 07 23 ; OR accumulator with memory (long) [$23.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda #$76.b		; A9 76 ; Load #$76.b into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp [$38.b],Y		; D7 38 ; Compare accumulator (long indexed) [$38.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	sbc [$1E.b]		; E7 1E ; Subtract with carry (long) [$1E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda ($4E.b),Y		; B1 4E ; Load accumulator ($4E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $70CF60.l,X		; 9F 60 CF 70 ; Store accumulator (long,X) $70CF60.l,X [Reads: Accumulator, X Index]
	sbc ($7E.b,X)		; E1 7E ; Subtract with carry ($7E.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $130028.l,X		; FF 28 00 13 ; Subtract with carry (long,X) $130028.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp ($D9.b),Y		; D1 D9 ; Compare accumulator ($D9.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	and ($FE.b)		; 32 FE ; AND accumulator with memory (indirect) ($FE.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $50, $7B		; 50 7B ; Branch if overflow clear to $50, $7B [Flow: branch]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	lda $DEA1C1.l,X		; BF C1 A1 DE ; Load long $DEA1C1.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$FFBF.w		; C0 BF FF ; Compare #$FFBF.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $26.b		; 00 26 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($84.b,X)		; 01 84 ; Logical OR ($84.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta $23.b		; 85 23 ; Store accumulator to $23.b [Reads: Accumulator]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $20E000.l,X		; FF 00 E0 20 ; Subtract with carry (long,X) $20E000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$E7BF.w		; E0 BF E7 ; Compare #$E7BF.w with X register [Reads: X Index] [Flags: NCZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	cpx $F9B3.w		; EC B3 F9 ; Compare $F9B3.w with X register [Reads: X Index] [Flags: NCZ]
	sbc [$FA.b]		; E7 FA ; Subtract with carry (long) [$FA.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	asl $F0.b		; 06 F0 ; Arithmetic shift left $F0.b [Reads: Direct Page] [Flags: NCZ]
	tsb $1F00.w		; 0C 00 1F ; Test and set bits $1F00.w [Reads: Accumulator] [Flags: Z]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $FF.b,S		; 03 FF ; OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $FFFF.w		; 0C FF FF ; Test and set bits $FFFF.w [Reads: Accumulator] [Flags: Z]
	brk $88.b		; 00 88 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc [$7F.b],Y		; 77 7F ; Add with carry (long indexed) [$7F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$20.b],Y		; F7 20 ; Subtract with carry (long indexed) [$20.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	ora ($89.b,X)		; 01 89 ; Logical OR ($89.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx #$5731.w		; E0 31 57 ; Compare #$5731.w with X register [Reads: X Index] [Flags: NCZ]
	ror $D7.b,X		; 76 D7 ; Rotate right $D7.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $380897.l		; 0F 97 08 38 ; OR accumulator with memory (long) $380897.l [Writes: Accumulator] [Flags: NZ]
	tsb $40.b		; 04 40 ; Test and set bits $40.b [Reads: Accumulator] [Flags: Z]
	and $40.b,S		; 23 40 ; AND accumulator with stack relative $40.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $DC00BF.l,X		; 3F BF 00 DC ; AND accumulator with memory (long,X) $DC00BF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $D0.b,S		; 03 D0 ; OR accumulator with stack relative $D0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $E0E0.w		; 0C E0 E0 ; Test and set bits $E0E0.w [Reads: Accumulator] [Flags: Z]
	cmp [$BF.b]		; C7 BF ; Compare accumulator (long) [$BF.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ldx $E0C0.w,Y		; BE C0 E0 ; Load X register $E0C0.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	sbc $0800FF.l		; EF FF 00 08 ; Subtract with carry (long) $0800FF.l [Writes: Accumulator] [Flags: NCVZ]
	ora [$14.b]		; 07 14 ; OR accumulator with memory (long) [$14.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc ($CA.b,S),Y		; F3 CA ; Subtract with carry (stack relative indirect indexed) ($CA.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	and $1CE5.w,Y		; 39 E5 1C ; AND accumulator with memory $1CE5.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lda ($4E.b)		; B2 4E ; Load accumulator (indirect) ($4E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $2CE7.w,Y		; 59 E7 2C ; Exclusive OR accumulator with memory $2CE7.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lda ($00.b,S),Y		; B3 00 ; Load accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $08		; F0 08 ; Branch if equal to $F0, $08 [Flow: branch]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sbc $B76809.l,X		; FF 09 68 B7 ; Subtract with carry (long,X) $B76809.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $37B2.w,X		; 7D B2 37 ; Add $37B2.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	and ($DF.b)		; 32 DF ; AND accumulator with memory (indirect) ($DF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc ($1F.b)		; F2 1F ; Subtract with carry (indirect) ($1F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	eor $2A.b		; 45 2A ; Exclusive OR $2A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $0F0027.l,X		; DF 27 00 0F ; Compare accumulator (long,X) $0F0027.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc [$FF.b],Y		; F7 FF ; Subtract with carry (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $BF.b		; 00 BF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$FF78.w		; C0 78 FF ; Compare #$FF78.w with Y register [Reads: Y Index] [Flags: NCZ]
	cmp [$3F.b]		; C7 3F ; Compare accumulator (long) [$3F.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sta $60FF3F.l,X		; 9F 3F FF 60 ; Store accumulator (long,X) $60FF3F.l,X [Reads: Accumulator, X Index]
	sta $0A0027.l,X		; 9F 27 00 0A ; Store accumulator (long,X) $0A0027.l,X [Reads: Accumulator, X Index]
	sbc $18C700.l,X		; FF 00 C7 18 ; Subtract with carry (long,X) $18C700.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	cpy #$FF00.w		; C0 00 FF ; Compare #$FF00.w with Y register [Reads: Y Index] [Flags: NCZ]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $80, $04		; 80 04 ; Branch always to $80, $04 [Flow: branch]
	ora $67607F.l,X		; 1F 7F 60 67 ; Logical OR long $67607F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	stz $22.b		; 64 22 ; Store zero to $22.b
	adc $FF600B.l,X		; 7F 0B 60 FF ; Add long $FF600B.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $387C00.l,X		; 7F 00 7C 38 ; Add long $387C00.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $0000.w,X		; 7D 00 00 ; Add $0000.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $040023.l,X		; FF 23 00 04 ; Subtract with carry (long,X) $040023.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $8300FF.l,X		; FF FF 00 83 ; Subtract with carry (long,X) $8300FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $82, $22, $FF		; 82 22 FF ; Branch always long to $82, $22, $FF [Flow: branch]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jmp ($C200.w,X)		; 7C 00 C2 ; Jump indirect indexed to ($C200.w,X) [Reads: X Index] [Flow: jump]
	bit $7EBD.w,X		; 3C BD 7E ; Test bits $7EBD.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	ldx $7F44.w,Y		; BE 44 7F ; Load X register $7F44.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	lda $3FDF03.l,X		; BF 03 DF 3F ; Load long $3FDF03.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $00273F.l,X		; 5F 3F 27 00 ; Exclusive OR accumulator with memory (long,X) $00273F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $3C.b		; 06 3C ; Arithmetic shift left $3C.b [Reads: Direct Page] [Flags: NCZ]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $7FA0.w,X		; 3C A0 7F ; Test bits $7FA0.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	adc ($48.b,X)		; 61 48 ; Add with carry ($48.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $0027E1.l,X		; FF E1 27 00 ; Subtract with carry (long,X) $0027E1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$FF.b]		; 07 FF ; OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $80, $59		; 80 59 ; Branch always to $80, $59 [Flow: branch]
	brk $BF.b		; 00 BF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $1A		; 80 1A ; Branch always to $80, $1A [Flow: branch]
	ldx $43.b		; A6 43 ; Load $43.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	ora $05BC.w,Y		; 19 BC 05 ; OR accumulator with memory $05BC.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $BA.b		; 06 BA ; Arithmetic shift left $BA.b [Reads: Direct Page] [Flags: NCZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $7F.b,X		; 75 7F ; Add $7F.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $E04062.l,X		; FF 62 40 E0 ; Subtract with carry (long,X) $E04062.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr $4142.w		; 20 42 41 ; Jump to subroutine at $4142.w [Writes: Stack Pointer] [Flow: call]
	tsb $FF.b		; 04 FF ; Test and set bits $FF.b [Reads: Accumulator] [Flags: Z]
	ora ($9A.b,X)		; 01 9A ; Logical OR ($9A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($58.b,X)		; 01 58 ; Logical OR ($58.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	adc [$9A.b]		; 67 9A ; Add with carry (long) [$9A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and $55368B.l,X		; 3F 8B 36 55 ; AND accumulator with memory (long,X) $55368B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora ($EC.b,S),Y		; 13 EC ; OR accumulator (stack relative indirect indexed) ($EC.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $02FF.w,X		; FE FF 02 ; Increment memory $02FF.w,X [Reads: X Index] [Flags: NZ]
	.db $80, $40		; 80 40 ; Branch always to $80, $40 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	tsb $BEA1.w		; 0C A1 BE ; Test and set bits $BEA1.w [Reads: Accumulator] [Flags: Z]
	cpy #$A003.w		; C0 03 A0 ; Compare #$A003.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora $FD43.w,X		; 1D 43 FD ; OR accumulator with memory $FD43.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $1FA108.l		; 0F 08 A1 1F ; OR accumulator with memory (long) $1FA108.l [Writes: Accumulator] [Flags: NZ]
	lda ($13.b)		; B2 13 ; Load accumulator (indirect) ($13.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx $4001.w		; EC 01 40 ; Compare $4001.w with X register [Reads: X Index] [Flags: NCZ]
	jsr ($22C2.w,X)		; FC C2 22 ; Jump to subroutine indirect indexed ($22C2.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpy #$CC07.w		; C0 07 CC ; Compare #$CC07.w with Y register [Reads: Y Index] [Flags: NCZ]
	cmp ($EC.b)		; D2 EC ; Compare accumulator (indirect) ($EC.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora ($B2.b,X)		; 01 B2 ; Logical OR ($B2.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($A1.b,S),Y		; 13 A1 ; OR accumulator (stack relative indirect indexed) ($A1.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0FF943.l,X		; 1F 43 F9 0F ; Logical OR long $0FF943.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$A0.b]		; 07 A0 ; OR accumulator with memory (long) [$A0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $03C0.w,X		; 1D C0 03 ; OR accumulator with memory $03C0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda [$B8.b]		; A7 B8 ; Load accumulator (long) [$B8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp ($CC.b)		; D2 CC ; Compare accumulator (indirect) ($CC.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	jsl $C20AC0.l		; 22 C0 0A C2 ; Jump to subroutine long $C20AC0.l [Writes: Stack Pointer] [Flow: call]
	jsr ($0740.w,X)		; FC 40 07 ; Jump to subroutine indirect indexed ($0740.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	adc $72BE81.l,X		; 7F 81 BE 72 ; Add long $72BE81.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy $4465.w,X		; BC 65 44 ; Load Y register $4465.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ldy $056D.w,X		; BC 6D 05 ; Load Y register $056D.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	jmp ($6FBB.w)		; 6C BB 6F ; Jump indirect to ($6FBB.w) [Flow: jump]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$24.b]		; 07 24 ; OR accumulator with memory (long) [$24.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $00FF01.l		; 0F 01 FF 00 ; OR accumulator with memory (long) $00FF01.l [Writes: Accumulator] [Flags: NZ]
	jsl $EB0B08.l		; 22 08 0B EB ; Jump to subroutine long $EB0B08.l [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	ora $D818EF.l		; 0F EF 18 D8 ; OR accumulator with memory (long) $D818EF.l [Writes: Accumulator] [Flags: NZ]
	.db $10, $17		; 10 17 ; Branch if plus to $10, $17 [Flow: branch]
	.db $F0, $F7		; F0 F7 ; Branch if equal to $F0, $F7 [Flow: branch]
	brk $26.b		; 00 26 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $9F581D.l,X		; FF 1D 58 9F ; Subtract with carry (long,X) $9F581D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $88788F.l		; 6F 8F 78 88 ; Add with carry (long) $88788F.l [Writes: Accumulator] [Flags: NCVZ]
	and [$80.b],Y		; 37 80 ; AND accumulator with memory (long indexed) [$80.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor [$C0.b],Y		; 57 C0 ; Exclusive OR accumulator with memory (long indexed) [$C0.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc [$E0.b]		; E7 E0 ; Subtract with carry (long) [$E0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $00FF1F.l,X		; FF 1F FF 00 ; Subtract with carry (long,X) $00FF1F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $70, $77		; 70 77 ; Branch if overflow set to $70, $77 [Flow: branch]
	adc $E01F3F.l,X		; 7F 3F 1F E0 ; Add long $E01F3F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F9FC04.l,X		; FF 04 FC F9 ; Subtract with carry (long,X) $F9FC04.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	eor $F7.b		; 45 F7 ; Exclusive OR $F7.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $030003.l,X		; FF 03 00 03 ; Subtract with carry (long,X) $030003.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$F7.b]		; 07 F7 ; OR accumulator with memory (long) [$F7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $0001FF.l		; 22 FF 01 00 ; Jump to subroutine long $0001FF.l [Writes: Stack Pointer] [Flow: call]
	sbc $0B0037.l,X		; FF 37 00 0B ; Subtract with carry (long,X) $0B0037.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy $07.b,X		; B4 07 ; Load Y register $07.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	ora $AF1890.l		; 0F 90 18 AF ; OR accumulator with memory (long) $AF1890.l [Writes: Accumulator] [Flags: NZ]
	and $807FC0.l,X		; 3F C0 7F 80 ; AND accumulator with memory (long,X) $807FC0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $80, $43		; 80 43 ; Branch always to $80, $43 [Flow: branch]
	sbc $F80500.l,X		; FF 00 05 F8 ; Subtract with carry (long,X) $F80500.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $E7		; F0 E7 ; Branch if equal to $F0, $E7 [Flow: branch]
	cpy #$7F80.w		; C0 80 7F ; Compare #$7F80.w with Y register [Reads: Y Index] [Flags: NCZ]
	jsl $0002FF.l		; 22 FF 02 00 ; Jump to subroutine long $0002FF.l [Writes: Stack Pointer] [Flow: call]
	sbc $E0457F.l,X		; FF 7F 45 E0 ; Subtract with carry (long,X) $E0457F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora [$B0.b]		; 07 B0 ; OR accumulator with memory (long) [$B0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $30, $DF		; 30 DF ; Branch if minus to $30, $DF [Flow: branch]
	sta $FFC070.l,X		; 9F 70 C0 FF ; Store accumulator (long,X) $FFC070.l,X [Reads: Accumulator, X Index]
	.db $80, $22		; 80 22 ; Branch always to $80, $22 [Flow: branch]
	sta $60CF0A.l,X		; 9F 0A CF 60 ; Store accumulator (long,X) $60CF0A.l,X [Reads: Accumulator, X Index]
	and $FB01FC.l,X		; 3F FC 01 FB ; AND accumulator with memory (long,X) $FB01FC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $7CFE.w,Y		; 79 FE 7C ; Add $7CFE.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $44.b		; C5 44 ; Compare $44.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	eor [$C3.b]		; 47 C3 ; Exclusive OR accumulator with memory (long) [$C3.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $42, $03		; 42 03 ; Reserved instruction
	inc $8386.w,X		; FE 86 83 ; Increment memory $8386.w,X [Reads: X Index] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	and $BD.b,S		; 23 BD ; AND accumulator with stack relative $BD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $A0.b,S		; 43 A0 ; Exclusive OR accumulator with stack relative $A0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr $7F01.w		; 20 01 7F ; Jump to subroutine at $7F01.w [Writes: Stack Pointer] [Flow: call]
	sbc $00FF43.l,X		; FF 43 FF 00 ; Subtract with carry (long,X) $00FF43.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$EF.b]		; 07 EF ; OR accumulator with memory (long) [$EF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $867FC0.l,X		; 7F C0 7F 86 ; Add long $867FC0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $5F5F.w,Y		; 79 5F 5F ; Add $5F5F.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $78.b,S		; 23 78 ; AND accumulator with stack relative $78.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $0043FF.l		; 22 FF 43 00 ; Jump to subroutine long $0043FF.l [Writes: Stack Pointer] [Flow: call]
	sbc $08FF06.l,X		; FF 06 FF 08 ; Subtract with carry (long,X) $08FF06.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$0C.b],Y		; F7 0C ; Subtract with carry (long indexed) [$0C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($87.b,S),Y		; F3 87 ; Subtract with carry (stack relative indirect indexed) ($87.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sta [$25.b]		; 87 25 ; Store accumulator (long) [$25.b] [Reads: Direct Page, Accumulator]
	brk $45.b		; 00 45 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $BF453F.l,X		; 5F 3F 45 BF ; Exclusive OR accumulator with memory (long,X) $BF453F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $3F5F03.l,X		; 7F 03 5F 3F ; Add long $3F5F03.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $00271F.l		; 2F 1F 27 00 ; AND accumulator with memory (long) $00271F.l [Writes: Accumulator] [Flags: NZ]
	eor $27FFE1.l		; 4F E1 FF 27 ; Exclusive OR accumulator with memory (long) $27FFE1.l [Writes: Accumulator] [Flags: NZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx $F67D.w,Y		; BE 7D F6 ; Load X register $F67D.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	adc $4477.w,X		; 7D 77 44 ; Add $4477.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $4357.w,Y		; B9 57 43 ; Load $4357.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $03BA.w,X		; 7D BA 03 ; Add $03BA.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	lda [$7D.b],Y		; B7 7D ; Load accumulator (long indexed) [$7D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $3922.w,X		; 7D 22 39 ; Add $3922.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $38.b		; 02 38 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $30, $43		; 30 43 ; Branch if minus to $30, $43 [Flow: branch]
	sbc $E0EE.w,X		; FD EE E0 ; Subtract with carry $E0EE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor [$FB.b]		; 47 FB ; Exclusive OR accumulator with memory (long) [$FB.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dec $C6FB.w		; CE FB C6 ; Decrement $C6FB.w [Flags: NZ]
	sbc $D9A6D6.l		; EF D6 A6 D9 ; Subtract with carry (long) $D9A6D6.l [Writes: Accumulator] [Flags: NCVZ]
	cpx #$ECDF.w		; E0 DF EC ; Compare #$ECDF.w with X register [Reads: X Index] [Flags: NCZ]
	eor ($EE.b,S),Y		; 53 EE ; XOR accumulator (stack relative indirect indexed) ($EE.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $C6CE.w		; EE CE C6 ; Increment $C6CE.w [Flags: NZ]
	dec $C0.b		; C6 C0 ; Decrement $C0.b [Reads: Direct Page] [Flags: NZ]
	cpy #$FF40.w		; C0 40 FF ; Compare #$FF40.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $4C.b		; 00 4C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $97BF4F.l,X		; BF 4F BF 97 ; Load long $97BF4F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc ($BF.b,S),Y		; 73 BF ; Add with carry (stack relative indirect indexed) ($BF.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	adc $FF7FE3.l,X		; 7F E3 7F FF ; Add long $FF7FE3.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $F0		; 80 F0 ; Branch always to $80, $F0 [Flow: branch]
	sta $3F3F00.l		; 8F 00 3F 3F ; Store accumulator (long) $3F3F00.l [Reads: Accumulator]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $0F007F.l,X		; 7F 7F 00 0F ; Add long $0F007F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$9F.b]		; E7 9F ; Subtract with carry (long) [$9F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $9C.b		; E5 9C ; Subtract $9C.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($0F.b,S),Y		; F3 0F ; Subtract with carry (stack relative indirect indexed) ($0F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc $7F8700.l,X		; FF 00 87 7F ; Subtract with carry (long,X) $7F8700.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $3FDC67.l		; 8F 67 DC 3F ; Store accumulator (long) $3FDC67.l [Reads: Accumulator]
	sbc $1E1F00.l,X		; FF 00 1F 1E ; Subtract with carry (long,X) $1E1F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $777F00.l		; 0F 00 7F 77 ; OR accumulator with memory (long) $777F00.l [Writes: Accumulator] [Flags: NZ]
	and $68BC00.l,X		; 3F 00 BC 68 ; AND accumulator with memory (long,X) $68BC00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldy $4665.w,X		; BC 65 46 ; Load Y register $4665.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ldy $046D.w,X		; BC 6D 04 ; Load Y register $046D.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ror $6FBA.w		; 6E BA 6F ; Rotate right $6FBA.w [Flags: NCZ]
	ldx $2767.w,Y		; BE 67 27 ; Load X register $2767.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ora $1B1007.l		; 0F 07 10 1B ; OR accumulator with memory (long) $1B1007.l [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jmp.w [$EF0F]		; DC 0F EF ; Jump long indirect [$EF0F] [Flow: jump]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	eor $10.b,S		; 43 10 ; Exclusive OR accumulator with stack relative $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp [$03.b],Y		; D7 03 ; Compare accumulator (long indexed) [$03.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$EF.b],Y		; F7 EF ; Subtract with carry (long indexed) [$EF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and [$FF.b]		; 27 FF ; AND accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx #$E62F.w		; E0 2F E6 ; Compare #$E62F.w with X register [Reads: X Index] [Flags: NCZ]
	and $C89FCF.l		; 2F CF 9F C8 ; AND accumulator with memory (long) $C89FCF.l [Writes: Accumulator] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $90.b,S		; C3 90 ; Compare accumulator (stack relative) $90.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	cmp [$90.b]		; C7 90 ; Compare accumulator (long) [$90.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sta [$70.b]		; 87 70 ; Store accumulator (long) [$70.b] [Reads: Direct Page, Accumulator]
	eor $F8.b,S		; 43 F8 ; Exclusive OR accumulator with stack relative $F8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr $10BC.w		; 20 BC 10 ; Jump to subroutine at $10BC.w [Writes: Stack Pointer] [Flow: call]
	jsr $2F27.w		; 20 27 2F ; Jump to subroutine at $2F27.w [Writes: Stack Pointer] [Flow: call]
	and $43070F.l		; 2F 0F 07 43 ; AND accumulator with memory (long) $43070F.l [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $86.b		; 00 86 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($FC.b,X)		; 81 FC ; Store accumulator ($FC.b,X) [Reads: Direct Page, Accumulator, X Index]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	inc $FC00.w,X		; FE 00 FC ; Increment memory $FC00.w,X [Reads: X Index] [Flags: NZ]
	ora ($F9.b,X)		; 01 F9 ; Logical OR ($F9.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $84.b		; 06 84 ; Arithmetic shift left $84.b [Reads: Direct Page] [Flags: NCZ]
	adc $8703.w,Y		; 79 03 87 ; Add $8703.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F9FCFE.l,X		; FF FE FC F9 ; Subtract with carry (long,X) $F9FCFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and [$00.b],Y		; 37 00 ; AND accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$6228.w		; E0 28 62 ; Compare #$6228.w with X register [Reads: X Index] [Flags: NCZ]
	ora ($C8.b,S),Y		; 13 C8 ; OR accumulator (stack relative indirect indexed) ($C8.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($9C.b),Y		; 11 9C ; OR accumulator with memory ($9C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $6526.w,Y		; 39 26 65 ; AND accumulator with memory $6526.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cmp ($D9.b,X)		; C1 D9 ; Compare accumulator ($D9.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
.ACCU 16
.INDEX 16
	rep #$79		; C2 79
	.db $42, $39		; 42 39 ; Reserved instruction
	cop $EC.b		; 02 EC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $9AC6.w		; EE C6 9A ; Increment $9AC6.w [Flags: NZ]
	rol $BC3C.w,X		; 3E 3C BC ; Rotate left $BC3C.w,X [Reads: X Index] [Flags: NCZ]
	jsr ($20CF.w,X)		; FC CF 20 ; Jump to subroutine indirect indexed ($20CF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	lda [$5F.b]		; A7 5F ; Load accumulator (long) [$5F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc #$ED56.w		; E9 56 ED ; Subtract #$ED56.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	adc ($95.b)		; 72 95 ; Add with carry (indirect) ($95.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	lda $B0506F.l		; AF 6F 50 B0 ; Load long $B0506F.l into accumulator [Writes: Accumulator] [Flags: NZ]
	adc [$BF.b]		; 67 BF ; Add with carry (long) [$BF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $180022.l,X		; 1F 22 00 18 ; Logical OR long $180022.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsr $0F10.w		; 20 10 0F ; Jump to subroutine at $0F10.w [Writes: Stack Pointer] [Flow: call]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $B3.b,S		; 03 B3 ; OR accumulator with stack relative $B3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jmp ($9774.w,X)		; 7C 74 97 ; Jump indirect indexed to ($9774.w,X) [Reads: X Index] [Flow: jump]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	and ($4B.b)		; 32 4B ; AND accumulator with memory (indirect) ($4B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $4D65.w,X		; 5D 65 4D ; Exclusive OR accumulator with memory $4D65.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $457F.w,X		; 7D 7F 45 ; Add $457F.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $84.b		; 04 84 ; Test and set bits $84.b [Reads: Accumulator] [Flags: Z]
	jsl $AF4B82.l		; 22 82 4B AF ; Jump to subroutine long $AF4B82.l [Writes: Stack Pointer] [Flow: call]
	jsr $B803.w		; 20 03 B8 ; Jump to subroutine at $B803.w [Writes: Stack Pointer] [Flow: call]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $B0, $30		; B0 30 ; Branch if carry set to $B0, $30 [Flow: branch]
	and $5F.b		; 25 5F ; Logical AND $5F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $47.b,S		; 03 47 ; OR accumulator with stack relative $47.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $4900B7.l		; 4F B7 00 49 ; Exclusive OR accumulator with memory (long) $4900B7.l [Writes: Accumulator] [Flags: NZ]
	sta [$30.b]		; 87 30 ; Store accumulator (long) [$30.b] [Reads: Direct Page, Accumulator]
	ora $48.b,S		; 03 48 ; OR accumulator with stack relative $48.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	and $CF.b		; 25 CF ; Logical AND $CF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($87.b,X)		; 01 87 ; Logical OR ($87.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta [$4F.b]		; 87 4F ; Store accumulator (long) [$4F.b] [Reads: Direct Page, Accumulator]
	lda $00277F.l,X		; BF 7F 27 00 ; Load long $00277F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $27DFAF.l		; 4F AF DF 27 ; Exclusive OR accumulator with memory (long) $27DFAF.l [Writes: Accumulator] [Flags: NZ]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($0D.b)		; F2 0D ; Subtract with carry (indirect) ($0D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$1C.b]		; E7 1C ; Subtract with carry (long) [$1C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $7CBB7C.l		; 8F 7C BB 7C ; Store accumulator (long) $7CBB7C.l [Reads: Accumulator]
	nop		; EA ; No operation
	adc $6DFA.w		; 6D FA 6D ; Add $6DFA.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	eor $BE.b,S		; 43 BE ; Exclusive OR accumulator with stack relative $BE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $0C17.w,X		; 7D 17 0C ; Add $0C17.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	trb $7C7C.w		; 1C 7C 7C ; Test and reset bits $7C7C.w [Reads: Accumulator] [Flags: Z]
	adc $7D6D.w,X		; 7D 6D 7D ; Add $7D6D.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $EE11.w,X		; 7D 11 EE ; Add $EE11.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $0E.b,X		; F5 0E ; Subtract $0E.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$0E.b],Y		; F7 0E ; Subtract with carry (long indexed) [$0E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($CA.b,S),Y		; 33 CA ; AND accumulator (stack relative indirect indexed) ($CA.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$EA.b],Y		; 17 EA ; OR accumulator with memory (long indexed) [$EA.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $AEBDEE.l,X		; DF EE BD AE ; Compare accumulator (long,X) $AEBDEE.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	sbc $22AE.w,X		; FD AE 22 ; Subtract with carry $22AE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $CE08.w		; 0E 08 CE ; Arithmetic shift left $CE08.w [Flags: NCZ]
	nop		; EA ; No operation
	inc $AEEE.w		; EE EE AE ; Increment $AEEE.w [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora [$3F.b]		; 07 3F ; OR accumulator with memory (long) [$3F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpy #$FF43.w		; C0 43 FF ; Compare #$FF43.w with Y register [Reads: Y Index] [Flags: NCZ]
	inc $2DE0.w,X		; FE E0 2D ; Increment memory $2DE0.w,X [Reads: X Index] [Flags: NZ]
	dec $FCFD.w		; CE FD FC ; Decrement $FCFD.w [Flags: NZ]
	cmp $F8.b,S		; C3 F8 ; Compare accumulator (stack relative) $F8.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	ora [$3C.b]		; 07 3C ; OR accumulator with memory (long) [$3C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc ($00.b,S),Y		; F3 00 ; Subtract with carry (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$FEFE.w		; C0 FE FE ; Compare #$FEFE.w with Y register [Reads: Y Index] [Flags: NCZ]
	jsr ($00C0.w,X)		; FC C0 00 ; Jump to subroutine indirect indexed ($00C0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $F0, $FF		; F0 FF ; Branch if equal to $F0, $FF [Flow: branch]
	jsr ($FEFF.w,X)		; FC FF FE ; Jump to subroutine indirect indexed ($FEFF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $07F8C0.l,X		; FF C0 F8 07 ; Subtract with carry (long,X) $07F8C0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $DDC6.w,Y		; F9 C6 DD ; Subtract with carry $DDC6.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($3C.b)		; F2 3C ; Subtract with carry (indirect) ($3C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora [$FC.b]		; 07 FC ; OR accumulator with memory (long) [$FC.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $00C0.w,X		; FE C0 00 ; Increment memory $00C0.w,X [Reads: X Index] [Flags: NZ]
	cpy #$F8F0.w		; C0 F0 F8 ; Compare #$F8F0.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $BE.b		; 00 BE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $BF.b,S		; 63 BF ; Add with carry (stack relative) $BF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	lda $BF4364.l,X		; BF 64 43 BF ; Load long $BF4364.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $E0, $3E		; 62 E0 3E ; Push effective relative address $62, $E0, $3E [Writes: Stack Pointer]
	ldx $BF67.w,Y		; BE 67 BF ; Load X register $BF67.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	adc $BF.b		; 65 BF ; Add $BF.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	stz $07.b		; 64 07 ; Store zero to $07.b
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tsb $0E0E.w		; 0C 0E 0E ; Test and set bits $0E0E.w [Reads: Accumulator] [Flags: Z]
	ora $FF0C0F.l		; 0F 0F 0C FF ; OR accumulator with memory (long) $FF0C0F.l [Writes: Accumulator] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora $F8.b,S		; 03 F8 ; OR accumulator with stack relative $F8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0C.b		; 05 0C ; Logical OR $0C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($84.b,X)		; 01 84 ; Logical OR ($84.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $80, $FF		; 80 FF ; Branch always to $80, $FF [Flow: branch]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $B9DF83.l,X		; 7F 83 DF B9 ; Add long $B9DF83.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F70FFF.l,X		; FF FF 0F F7 ; Subtract with carry (long,X) $F70FFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $83.b,S		; 03 83 ; OR accumulator with stack relative $83.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc $64.b,S		; E3 64 ; Subtract stack-relative $64.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	dec $41.b		; C6 41 ; Decrement $41.b [Reads: Direct Page] [Flags: NZ]
	cmp $DB4B.w		; CD 4B DB ; Compare $DB4B.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	eor [$76.b],Y		; 57 76 ; Exclusive OR accumulator with memory (long indexed) [$76.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ldx $DD2C.w		; AE 2C DD ; Load $DD2C.w into X register [Writes: X Index] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	adc ($B7.b)		; 72 B7 ; Add with carry (indirect) ($B7.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $30, $20		; 30 20 ; Branch if minus to $30, $20 [Flow: branch]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $808013.l,X		; FF 13 80 80 ; Subtract with carry (long,X) $808013.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$FF.b]		; 07 FF ; OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror $FE.b		; 66 FE ; Rotate right $FE.b [Reads: Direct Page] [Flags: NCZ]
	inc $FE.b		; E6 FE ; Increment $FE.b [Reads: Direct Page] [Flags: NZ]
	cpx $FD.b		; E4 FD ; Compare $FD.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $010080.l,X		; 7F 80 00 01 ; Add long $010080.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and [$00.b],Y		; 37 00 ; AND accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$C126.w		; E0 26 C1 ; Compare #$C126.w with X register [Reads: X Index] [Flags: NCZ]
	cmp $BC80.w,Y		; D9 80 BC ; Compare accumulator $BC80.w,Y [Reads: Y Index] [Flags: NCZ]
	bit $7E.b		; 24 7E ; Test bits $7E.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	jsl $F965FB.l		; 22 FB 65 F9 ; Jump to subroutine long $F965FB.l [Writes: Stack Pointer] [Flow: call]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	jmp.w [$D645]		; DC 45 D6 ; Jump long indirect [$D645] [Flow: jump]
	jsl $432693.l		; 22 93 26 43 ; Jump to subroutine long $432693.l [Writes: Stack Pointer] [Flow: call]
	sta ($04.b,X)		; 81 04 ; Store accumulator ($04.b,X) [Reads: Direct Page, Accumulator, X Index]
	asl $23.b		; 06 23 ; Arithmetic shift left $23.b [Reads: Direct Page] [Flags: NCZ]
	and #$FA6C.w		; 29 6C FA ; Logical AND #$FA6C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $9F37FA.l		; 2F FA 37 9F ; AND accumulator with memory (long) $9F37FA.l [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ldx $B35E.w		; AE 5E B3 ; Load $B35E.w into X register [Writes: X Index] [Flags: NZ]
	adc $8070BF.l		; 6F BF 70 80 ; Add with carry (long) $8070BF.l [Writes: Accumulator] [Flags: NCVZ]
	and $0022FF.l,X		; 3F FF 22 00 ; AND accumulator with memory (long,X) $0022FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $4140.w,Y		; 19 40 41 ; OR accumulator with memory $4140.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $70, $7F		; 70 7F ; Branch if overflow set to $70, $7F [Flow: branch]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C1.b		; 00 C1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $EEDD.w,X		; 3C DD EE ; Test bits $EEDD.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	sbc $F576.w		; ED 76 F5 ; Subtract $F576.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	and $DA.b,X		; 35 DA ; Logical AND $DA.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $2DDA.w,X		; FD DA 2D ; Subtract with carry $2DDA.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $2206.w		; 0E 06 22 ; Arithmetic shift left $2206.w [Flags: NCZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($FF.b)		; 12 FF ; OR accumulator with memory (indirect) ($FF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $830022.l,X		; FF 22 00 83 ; Subtract with carry (long,X) $830022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp $0001.w		; 4C 01 00 ; Jump to $0001.w [Flow: jump]
	sbc $830022.l,X		; FF 22 00 83 ; Subtract with carry (long,X) $830022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $B0, $04		; B0 04 ; Branch if carry set to $B0, $04 [Flow: branch]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $FF1300.l		; 22 00 13 FF ; Jump to subroutine long $FF1300.l [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $E781.w,X		; 7E 81 E7 ; Rotate right $E781.w,X [Reads: X Index] [Flags: NCZ]
	ror $7E91.w,X		; 7E 91 7E ; Rotate right $7E91.w,X [Reads: X Index] [Flags: NCZ]
	lda ($7E.b),Y		; B1 7E ; Load accumulator ($7E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $7E.b		; 85 7E ; Store accumulator to $7E.b [Reads: Accumulator]
	sta $3E.b,S		; 83 3E ; Store accumulator (stack relative) $3E.b,S [Reads: Stack Pointer, Accumulator]
	cmp $5A.b,S		; C3 5A ; Compare accumulator (stack relative) $5A.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	ror $0081.w,X		; 7E 81 00 ; Rotate right $0081.w,X [Reads: X Index] [Flags: NCZ]
	and $7E.b		; 25 7E ; Logical AND $7E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor #$7FBF.w		; 49 BF 7F ; Exclusive OR #$7FBF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $9F.b		; 04 9F ; Test and set bits $9F.b [Reads: Accumulator] [Flags: Z]
	adc $3F7F00.l,X		; 7F 00 7F 3F ; Add long $3F7F00.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $4B.b		; 00 4B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $6002DF.l		; AF DF 02 60 ; Load long $6002DF.l into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0028FF.l,X		; 9F FF 28 00 ; Store accumulator (long,X) $0028FF.l,X [Reads: Accumulator, X Index]
	sta $78.b,S		; 83 78 ; Store accumulator (stack relative) $78.b,S [Reads: Stack Pointer, Accumulator]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $7F7F.w,X		; BC 7F 7F ; Load Y register $7F7F.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	sbc $004FE4.l,X		; FF E4 4F 00 ; Subtract with carry (long,X) $004FE4.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $BE.b,S		; 43 BE ; Exclusive OR accumulator with stack relative $BE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lda $78B771.l		; AF 71 B7 78 ; Load long $78B771.l into accumulator [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	jmp ($7EBD.w,X)		; 7C BD 7E ; Jump indirect indexed to ($7EBD.w,X) [Reads: X Index] [Flow: jump]
	sta $807F4F.l		; 8F 4F 7F 80 ; Store accumulator (long) $807F4F.l [Reads: Accumulator]
	ora $040D.w		; 0D 0D 04 ; Logical OR $040D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $31.b		; 00 31 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($7B.b),Y		; 11 7B ; OR accumulator with memory ($7B.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	mvp $FF,$00		; 44 00 FF ; Move block positive $FF,$00 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	jsl $0005FF.l		; 22 FF 05 00 ; Jump to subroutine long $0005FF.l [Writes: Stack Pointer] [Flow: call]
	brk $CE.b		; 00 CE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $84.b		; 84 84 ; Store Y register to $84.b [Reads: Y Index]
	sbc $0F0022.l,X		; FF 22 00 0F ; Subtract with carry (long,X) $0F0022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FF3F00.l,X		; FF 00 3F FF ; Subtract with carry (long,X) $FF3F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $37E0DF.l,X		; FF DF E0 37 ; Subtract with carry (long,X) $37E0DF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $D89C6C.l		; CF 6C 9C D8 ; Compare accumulator (long) $D89C6C.l [Reads: Accumulator] [Flags: NCZ]
	and $72B1.w,Y		; 39 B1 72 ; AND accumulator with memory $72B1.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0C.b		; 06 0C ; Arithmetic shift left $0C.b [Reads: Direct Page] [Flags: NCZ]
	sty $B6.b		; 84 B6 ; Store Y register to $B6.b [Reads: Y Index]
	tsb $09.b		; 04 09 ; Test and set bits $09.b [Reads: Accumulator] [Flags: Z]
	sbc $7400FF.l,X		; FF FF 00 74 ; Subtract with carry (long,X) $7400FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp $B352.w		; 4C 52 B3 ; Jump to $B352.w [Flow: jump]
	lda $66.b		; A5 66 ; Load $66.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $020024.l,X		; FF 24 00 02 ; Subtract with carry (long,X) $020024.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0C.b,S		; 83 0C ; Store accumulator (stack relative) $0C.b,S [Reads: Stack Pointer, Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FFFE00.l,X		; FF 00 FE FF ; Subtract with carry (long,X) $FFFE00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $FF.b,S		; 03 FF ; OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $9EE101.l,X		; FF 01 E1 9E ; Subtract with carry (long,X) $9EE101.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp ($37.b),Y		; D1 37 ; Compare accumulator ($37.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	lda ($77.b,S),Y		; B3 77 ; Load accumulator (stack relative indirect indexed) ($77.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc [$EF.b]		; 67 EF ; Add with carry (long) [$EF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $10, $FF		; 10 FF ; Branch if plus to $10, $FF [Flow: branch]
	ora $EF3DCF.l		; 0F CF 3D EF ; OR accumulator with memory (long) $EF3DCF.l [Writes: Accumulator] [Flags: NZ]
	lsr $6FB7.w,X		; 5E B7 6F ; Logical shift right $6FB7.w,X [Reads: X Index] [Flags: NCZ]
	sta $788870.l,X		; 9F 70 88 78 ; Store accumulator (long,X) $788870.l,X [Reads: Accumulator, X Index]
	cmp [$3F.b]		; C7 3F ; Compare accumulator (long) [$3F.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	adc [$9F.b]		; 67 9F ; Add with carry (long) [$9F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $AF		; 70 AF ; Branch if overflow set to $70, $AF [Flow: branch]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $FC0F00.l		; 22 00 0F FC ; Jump to subroutine long $FC0F00.l [Writes: Stack Pointer] [Flow: call]
	ora $C7.b,S		; 03 C7 ; OR accumulator with stack relative $C7.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	adc $BD.b,S		; 63 BD ; Add with carry (stack relative) $BD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	and ($DE.b),Y		; 31 DE ; AND accumulator with memory ($DE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	sbc $F6E7F6.l		; EF F6 E7 F6 ; Subtract with carry (long) $F6E7F6.l [Writes: Accumulator] [Flags: NCVZ]
	adc [$F6.b]		; 67 F6 ; Add with carry (long) [$F6.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda [$24.b]		; A7 24 ; Load accumulator (long) [$24.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $E000C0.l		; 0F C0 00 E0 ; OR accumulator with memory (long) $E000C0.l [Writes: Accumulator] [Flags: NZ]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BF.b		; 00 BF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $B8		; 80 B8 ; Branch always to $80, $B8 [Flow: branch]
	brk $B7.b		; 00 B7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$A8.b]		; 07 A8 ; OR accumulator with memory (long) [$A8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $22109F.l		; 0F 9F 10 22 ; OR accumulator with memory (long) $22109F.l [Writes: Accumulator] [Flags: NZ]
	sbc $7F7F04.l,X		; FF 04 7F 7F ; Subtract with carry (long,X) $7F7F04.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $70, $60		; 70 60 ; Branch if overflow set to $70, $60 [Flow: branch]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	trb $BE00.w		; 1C 00 BE ; Test and reset bits $BE00.w [Reads: Accumulator] [Flags: Z]
	brk $E3.b		; 00 E3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $5D.b		; 00 5D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $BEA2.w		; 1C A2 BE ; Test and reset bits $BEA2.w [Reads: Accumulator] [Flags: Z]
	sbc $FF2440.l,X		; FF 40 24 FF ; Subtract with carry (long,X) $FF2440.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $41E3.w		; 0C E3 41 ; Test and set bits $41E3.w [Reads: Accumulator] [Flags: Z]
	brk $DF.b		; 00 DF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $E0		; 10 E0 ; Branch if plus to $10, $E0 [Flow: branch]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3D.b		; 00 3D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($3B.b,X)		; 01 3B ; Logical OR ($3B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $45.b		; 02 45 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $06.b,X		; 35 06 ; Logical AND $06.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $E0.b		; 04 E0 ; Test and set bits $E0.b [Reads: Accumulator] [Flags: Z]
	sbc $FCFEFF.l,X		; FF FF FE FC ; Subtract with carry (long,X) $FCFEFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $FC0FF8.l		; 22 F8 0F FC ; Jump to subroutine long $FC0FF8.l [Writes: Stack Pointer] [Flow: call]
	ora $CE.b,S		; 03 CE ; OR accumulator with stack relative $CE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc ($D7.b),Y		; F1 D7 ; Subtract with carry ($D7.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	tsb $CFFC.w		; 0C FC CF ; Test and set bits $CFFC.w [Reads: Accumulator] [Flags: Z]
	asl $FFE7.w,X		; 1E E7 FF ; Arithmetic shift left $FFE7.w,X [Reads: X Index] [Flags: NCZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	and $0022C0.l,X		; 3F C0 22 00 ; AND accumulator with memory (long,X) $0022C0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	trb $C010.w		; 1C 10 C0 ; Test and reset bits $C010.w [Reads: Accumulator] [Flags: Z]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$EF.b]		; 07 EF ; OR accumulator with memory (long) [$EF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $6C0EEE.l		; 0F EE 0E 6C ; OR accumulator with memory (long) $6C0EEE.l [Writes: Accumulator] [Flags: NZ]
	tsb $87B7.w		; 0C B7 87 ; Test and set bits $87B7.w [Reads: Accumulator] [Flags: Z]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	sta $DF.b,S		; 83 DF ; Store accumulator (stack relative) $DF.b,S [Reads: Stack Pointer, Accumulator]
	cpy #$E0BF.w		; C0 BF E0 ; Compare #$E0BF.w with Y register [Reads: Y Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $F1		; F0 F1 ; Branch if equal to $F0, $F1 [Flow: branch]
	sbc ($78.b,S),Y		; F3 78 ; Subtract with carry (stack relative indirect indexed) ($78.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	jmp ($1F3F.w,X)		; 7C 3F 1F ; Jump indirect indexed to ($1F3F.w,X) [Reads: X Index] [Flow: jump]
	eor $0F.b,S		; 43 0F ; Exclusive OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $6067.w		; 2D 67 60 ; Logical AND $6067.w with accumulator [Writes: Accumulator] [Flags: NZ]
	stz $60.b		; 64 60 ; Store zero to $60.b
	ora #$9B01.w		; 09 01 9B ; Logical OR #$9B01.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $F5.b,S		; 83 F5 ; Store accumulator (stack relative) $F5.b,S [Reads: Stack Pointer, Accumulator]
	ora [$E9.b]		; 07 E9 ; OR accumulator with memory (long) [$E9.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $9FFFFF.l		; 0F FF FF 9F ; OR accumulator with memory (long) $9FFFFF.l [Writes: Accumulator] [Flags: NZ]
	sta $F87CFE.l,X		; 9F FE 7C F8 ; Store accumulator (long,X) $F87CFE.l,X [Reads: Accumulator, X Index]
	.db $F0, $EF		; F0 EF ; Branch if equal to $F0, $EF [Flow: branch]
	ora $FD03F2.l		; 0F F2 03 FD ; OR accumulator with memory (long) $FD03F2.l [Writes: Accumulator] [Flags: NZ]
	ora ($8F.b,X)		; 01 8F ; Logical OR ($8F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $77.b		; 00 77 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $FB		; 70 FB ; Branch if overflow set to $70, $FB [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $CCCFEC.l		; EF EC CF CC ; Subtract with carry (long) $CCCFEC.l [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $FC		; F0 FC ; Branch if equal to $F0, $FC [Flow: branch]
	inc $8FFF.w,X		; FE FF 8F ; Increment memory $8FFF.w,X [Reads: X Index] [Flags: NZ]
	ora [$13.b]		; 07 13 ; OR accumulator with memory (long) [$13.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($07.b,S),Y		; 33 07 ; AND accumulator (stack relative indirect indexed) ($07.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $43.b		; 04 43 ; Test and set bits $43.b [Reads: Accumulator] [Flags: Z]
	and ($30.b,S),Y		; 33 30 ; AND accumulator (stack relative indirect indexed) ($30.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $0006.w		; 0C 06 00 ; Test and set bits $0006.w [Reads: Accumulator] [Flags: Z]
	cmp $F201.w		; CD 01 F2 ; Compare $F201.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora $E4.b,S		; 03 E4 ; OR accumulator with stack relative $E4.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$EF.b]		; 07 EF ; OR accumulator with memory (long) [$EF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $CFCFFB.l		; 0F FB CF CF ; OR accumulator with memory (long) $CFCFFB.l [Writes: Accumulator] [Flags: NZ]
	sta $72.b,S		; 83 72 ; Store accumulator (stack relative) $72.b,S [Reads: Stack Pointer, Accumulator]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $F0.b,S		; 43 F0 ; Exclusive OR accumulator with stack relative $F0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $7FFF00.l,X		; FF 00 FF 7F ; Subtract with carry (long,X) $7FFF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $56EF6F.l,X		; FF 6F EF 56 ; Subtract with carry (long,X) $56EF6F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $EF59.w,X		; FE 59 EF ; Increment memory $EF59.w,X [Reads: X Index] [Flags: NZ]
	eor $47E5.w		; 4D E5 47 ; Exclusive OR $47E5.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc [$57.b],Y		; F7 57 ; Subtract with carry (long indexed) [$57.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $504046.l		; 6F 46 40 50 ; Add with carry (long) $504046.l [Writes: Accumulator] [Flags: NCVZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	sbc $DFE000.l,X		; FF 00 E0 DF ; Subtract with carry (long,X) $DFE000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp.w [$703C]		; DC 3C 70 ; Jump long indirect [$703C] [Flow: jump]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	cpx #$C0C0.w		; E0 C0 C0 ; Compare #$C0C0.w with X register [Reads: X Index] [Flags: NCZ]
	rep #$C3		; C2 C3 ; Reset processor status bits #$C3 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	cmp $D7.b,X		; D5 D7 ; Compare accumulator $D7.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $283C3F.l,X		; 1F 3F 3C 28 ; Logical OR long $283C3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $E7.b		; 65 E7 ; Add $E7.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp $C3.b,S		; C3 C3 ; Compare accumulator (stack relative) $C3.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	stz $3F80.w,X		; 9E 80 3F ; Store zero to $3F80.w,X [Reads: X Index]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E3.b		; 00 E3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C1.b		; 00 C1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $247F.w,X		; 3C 7F 24 ; Test bits $247F.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	sbc $1C540B.l,X		; FF 0B 54 1C ; Subtract with carry (long,X) $1C540B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	ora $7E87F7.l		; 0F F7 87 7E ; OR accumulator with memory (long) $7E87F7.l [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	lda $DF21.w,X		; BD 21 DF ; Load $DF21.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $00FF43.l,X		; 1F 43 FF 00 ; Logical OR long $00FF43.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$F0E3.w		; 09 E3 F0 ; Logical OR #$F0E3.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	lda $FFE0DE.l,X		; BF DE E0 FF ; Load long $FFE0DE.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $43E888.l,X		; FF 88 E8 43 ; Subtract with carry (long,X) $43E888.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $D0		; 10 D0 ; Branch if plus to $10, $D0 [Flow: branch]
	cpx #$1159.w		; E0 59 11 ; Compare #$1159.w with X register [Reads: X Index] [Flags: NCZ]
	lda ($12.b),Y		; B1 12 ; Load accumulator ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda ($0D.b)		; B2 0D ; Load accumulator (indirect) ($0D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jmp ($7903.w,X)		; 7C 03 79 ; Jump indirect indexed to ($7903.w,X) [Reads: X Index] [Flow: jump]
	tsb $13.b		; 04 13 ; Test and set bits $13.b [Reads: Accumulator] [Flags: Z]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	jsr $C140.w		; 20 40 C1 ; Jump to subroutine at $C140.w [Writes: Stack Pointer] [Flow: call]
	sta $86.b,S		; 83 86 ; Store accumulator (stack relative) $86.b,S [Reads: Stack Pointer, Accumulator]
	cpx $6E57.w		; EC 57 6E ; Compare $6E57.w with X register [Reads: X Index] [Flags: NCZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	cmp $B1.b,X		; D5 B1 ; Compare accumulator $B1.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	bit $E0.b		; 24 E0 ; Test bits $E0.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cpy $9EC0.w		; CC C0 9E ; Compare $9EC0.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $80, $FB		; 80 FB ; Branch always to $80, $FB [Flow: branch]
	brk $F1.b		; 00 F1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0E.b		; 04 0E ; Test and set bits $0E.b [Reads: Accumulator] [Flags: Z]
	ora $FF7F3F.l,X		; 1F 3F 7F FF ; Logical OR long $FF7F3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $E021E1.l,X		; FF E1 21 E0 ; Subtract with carry (long,X) $E021E1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr $34F4.w		; 20 F4 34 ; Jump to subroutine at $34F4.w [Writes: Stack Pointer] [Flow: call]
	.db $F0, $30		; F0 30 ; Branch if equal to $F0, $30 [Flow: branch]
	cld		; D8 ; Clear decimal flag [Flags: D]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $80BC0F.l		; 6F 0F BC 80 ; Add with carry (long) $80BC0F.l [Writes: Accumulator] [Flags: NCVZ]
	cmp $DFDEC0.l,X		; DF C0 DE DF ; Compare accumulator (long,X) $DFDEC0.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	wai		; CB ; Wait for interrupt
	cmp $7FF0E7.l		; CF E7 F0 7F ; Compare accumulator (long) $7FF0E7.l [Reads: Accumulator] [Flags: NCZ]
	and $FD03FB.l,X		; 3F FB 03 FD ; AND accumulator with memory (long,X) $FD03FB.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($F6.b,X)		; 01 F6 ; Logical OR ($F6.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $F0, $3B		; F0 3B ; Branch if equal to $F0, $3B [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	ora $24270C.l		; 0F 0C 27 24 ; OR accumulator with memory (long) $24270C.l [Writes: Accumulator] [Flags: NZ]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $84.b		; 85 84 ; Store accumulator to $84.b [Reads: Accumulator]
	jsr ($0FFE.w,X)		; FC FE 0F ; Jump to subroutine indirect indexed ($0FFE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cmp [$F3.b]		; C7 F3 ; Compare accumulator (long) [$F3.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $FA.b,S		; 43 FA ; Exclusive OR accumulator with stack relative $FA.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $669B10.l		; 6F 10 9B 66 ; Add with carry (long) $669B10.l [Writes: Accumulator] [Flags: NCVZ]
	lda $3ADF62.l		; AF 62 DF 3A ; Load long $3ADF62.l into accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $8E771C.l		; EF 1C 77 8E ; Subtract with carry (long) $8E771C.l [Writes: Accumulator] [Flags: NCVZ]
	and ($CE.b,S),Y		; 33 CE ; AND accumulator (stack relative indirect indexed) ($CE.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cop $12.b		; 02 12 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1D.b		; 00 1D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $F9.b		; 46 F9 ; Logical shift right $F9.b [Reads: Direct Page] [Flags: NCZ]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($FE.b,X)		; 01 FE ; Logical OR ($FE.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda ($EE.b,X)		; A1 EE ; Load accumulator ($EE.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $90, $F7		; 90 F7 ; Branch if carry clear to $90, $F7 [Flow: branch]
	adc ($DF.b,X)		; 61 DF ; Add with carry ($DF.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $EF		; 30 EF ; Branch if minus to $30, $EF [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $1A13F7.l		; 6F F7 13 1A ; Add with carry (long) $1A13F7.l [Writes: Accumulator] [Flags: NCVZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	ldy $031F.w,X		; BC 1F 03 ; Load Y register $031F.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	brk $1B.b		; 00 1B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $0D.b		; 02 0D ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($1B.b,X)		; 01 1B ; Logical OR ($1B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $45.b		; 02 45 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $06.b,X		; 35 06 ; Logical AND $06.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	asl $1B.b		; 06 1B ; Arithmetic shift left $1B.b [Reads: Direct Page] [Flags: NCZ]
	cop $0D.b		; 02 0D ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $22FC.w,X		; FE FC 22 ; Increment memory $22FC.w,X [Reads: X Index] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	jsr ($19FE.w,X)		; FC FE 19 ; Jump to subroutine indirect indexed ($19FE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $FF84.w,X		; FE 84 FF ; Increment memory $FF84.w,X [Reads: X Index] [Flags: NZ]
	asl $FB.b,X		; 16 FB ; Arithmetic shift left $FB.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	cpx $F701.w		; EC 01 F7 ; Compare $F701.w with X register [Reads: X Index] [Flags: NCZ]
	eor $80.b,S		; 43 80 ; Exclusive OR accumulator with stack relative $80.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $7431E0.l,X		; 7F E0 31 74 ; Add long $7431E0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $988098.l		; CF 98 80 98 ; Compare accumulator (long) $988098.l [Reads: Accumulator] [Flags: NCZ]
	jsr ($8C3C.w,X)		; FC 3C 8C ; Jump to subroutine indirect indexed ($8C3C.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $C6.b		; E6 C6 ; Increment $C6.b [Reads: Direct Page] [Flags: NZ]
	cmp #$52B9.w		; C9 B9 52 ; Compare #$52B9.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	wai		; CB ; Wait for interrupt
	and ($D3.b)		; 32 D3 ; AND accumulator with memory (indirect) ($D3.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($D9.b),Y		; 31 D9 ; AND accumulator with memory ($D9.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	trb $CFB7.w		; 1C B7 CF ; Test and reset bits $CFB7.w [Reads: Accumulator] [Flags: Z]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	sbc [$06.b]		; E7 06 ; Subtract with carry (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tsb $14.b		; 04 14 ; Test and set bits $14.b [Reads: Accumulator] [Flags: Z]
	tsb $0306.w		; 0C 06 03 ; Test and set bits $0306.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	wai		; CB ; Wait for interrupt
	cmp $D9CE.w,X		; DD CE D9 ; Compare accumulator $D9CE.w,X [Reads: X Index] [Flags: NCZ]
	jmp $BBBCDB.l		; 5C DB BC BB ; Jump long to $BBBCDB.l [Flow: jump]
	mvn $AF,$7B		; 54 7B AF ; Move block negative $AF,$7B [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	.db $F0, $5B		; F0 5B ; Branch if equal to $F0, $5B [Flow: branch]
	sbc [$30.b]		; E7 30 ; Subtract with carry (long) [$30.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp $012022.l		; CF 22 20 01 ; Compare accumulator (long) $012022.l [Reads: Accumulator] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $80, $22		; 80 22 ; Branch always to $80, $22 [Flow: branch]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stx $FB.b		; 86 FB ; Store X register to $FB.b [Reads: X Index]
	cpy $3B.b		; C4 3B ; Compare $3B.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	rol $5BC1.w,X		; 3E C1 5B ; Rotate left $5BC1.w,X [Reads: X Index] [Flags: NCZ]
	jmp.w [$EEA5]		; DC A5 EE ; Jump long indirect [$EEA5] [Flow: jump]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($73.b,S),Y		; 53 73 ; XOR accumulator (stack relative indirect indexed) ($73.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	jsl $201700.l		; 22 00 17 20 ; Jump to subroutine long $201700.l [Writes: Stack Pointer] [Flow: call]
	.db $10, $F8		; 10 F8 ; Branch if plus to $10, $F8 [Flow: branch]
	sty $D404.w		; 8C 04 D4 ; Store Y register to $D404.w [Reads: Y Index]
	sbc [$EA.b],Y		; F7 EA ; Subtract with carry (long indexed) [$EA.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $3B1E15.l		; EF 15 1E 3B ; Subtract with carry (long) $3B1E15.l [Writes: Accumulator] [Flags: NCVZ]
	jsr ($F9F6.w,X)		; FC F6 F9 ; Jump to subroutine indirect indexed ($F9F6.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jmp ($C683.w,X)		; 7C 83 C6 ; Jump indirect indexed to ($C683.w,X) [Reads: X Index] [Flow: jump]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	stx $FB.b		; 86 FB ; Store X register to $FB.b [Reads: X Index]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $10, $E0		; 10 E0 ; Branch if plus to $10, $E0 [Flow: branch]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora $E7.b,S		; 03 E7 ; OR accumulator with stack relative $E7.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor [$E5.b],Y		; 57 E5 ; Exclusive OR accumulator with memory (long indexed) [$E5.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor [$43.b],Y		; 57 43 ; Exclusive OR accumulator with memory (long indexed) [$43.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $0B5F.w		; ED 5F 0B ; Subtract $0B5F.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sbc $F54F.w,X		; FD 4F F5 ; Subtract with carry $F54F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $E447F8.l		; 4F F8 47 E4 ; Exclusive OR accumulator with memory (long) $E447F8.l [Writes: Accumulator] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	jsl $401B60.l		; 22 60 1B 40 ; Jump to subroutine long $401B60.l [Writes: Stack Pointer] [Flow: call]
	cmp ($D6.b)		; D2 D6 ; Compare accumulator (indirect) ($D6.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sbc ($F7.b,S),Y		; F3 F7 ; Subtract with carry (stack relative indirect indexed) ($F7.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F7.b		; E5 F7 ; Subtract $F7.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	nop		; EA ; No operation
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	.db $80, $FC		; 80 FC ; Branch always to $80, $FC [Flow: branch]
	eor $C7.b		; 45 C7 ; Exclusive OR $C7.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	sta $ED.b,S		; 83 ED ; Store accumulator (stack relative) $ED.b,S [Reads: Stack Pointer, Accumulator]
	lda #$0829.w		; A9 29 08 ; Load #$0829.w into accumulator [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	sec		; 38 ; Set carry flag [Flags: C]
	mvp $AB,$12		; 44 12 AB ; Move block positive $AB,$12 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ror $46AA.w		; 6E AA 46 ; Rotate right $46AA.w [Flags: NCZ]
	adc $05AB.w		; 6D AB 05 ; Add $05AB.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	adc $559B.w		; 6D 9B 55 ; Add $559B.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	adc $1025.w		; 6D 25 10 ; Add $1025.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	ora $321028.l,X		; 1F 28 10 32 ; Logical OR long $321028.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $DC6C.w		; EE 6C DC ; Increment $DC6C.w [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	.db $90, $B7		; 90 B7 ; Branch if carry clear to $90, $B7 [Flow: branch]
	ora ($37.b),Y		; 11 37 ; OR accumulator with memory ($37.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $36.b		; 14 36 ; Test and reset bits $36.b [Reads: Accumulator] [Flags: Z]
	ora ($32.b,S),Y		; 13 32 ; OR accumulator (stack relative indirect indexed) ($32.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and #$0139.w		; 29 39 01 ; Logical AND #$0139.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cmp #$C6CD.w		; C9 CD C6 ; Compare #$C6CD.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and #$0300.w		; 29 00 03 ; Logical AND #$0300.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $10, $0C		; 10 0C ; Branch if plus to $10, $0C [Flow: branch]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx #$4F2A.w		; E0 2A 4F ; Compare #$4F2A.w with X register [Reads: X Index] [Flags: NCZ]
	ror $BF.b		; 66 BF ; Rotate right $BF.b [Reads: Direct Page] [Flags: NCZ]
	inc $19.b		; E6 19 ; Increment $19.b [Reads: Direct Page] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	adc [$F4.b]		; 67 F4 ; Add with carry (long) [$F4.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	eor ($34.b,S),Y		; 53 34 ; XOR accumulator (stack relative indirect indexed) ($34.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $D72A.w		; ED 2A D7 ; Subtract $D72A.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	ldx $98.b,Y		; B6 98 ; Load X register $98.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $08.b,X		; 34 08 ; Test bits $08.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $D0, $A0		; D0 A0 ; Branch if not equal to $D0, $A0 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	eor $C0.b,S		; 43 C0 ; Exclusive OR accumulator with stack relative $C0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit #$9C48.w		; 89 48 9C ; Test bits #$9C48.w with accumulator [Reads: Accumulator] [Flags: Z]
	jmp $8E529E.l		; 5C 9E 52 8E ; Jump long to $8E529E.l [Flow: jump]
	eor ($9C.b)		; 52 9C ; Exclusive OR accumulator with memory (indirect) ($9C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ldy $AE6A.w,X		; BC 6A AE ; Load Y register $AE6A.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	jmp $23373F.l		; 5C 3F 37 23 ; Jump long to $23373F.l [Flow: jump]
	jsl $011021.l		; 22 21 10 01 ; Jump to subroutine long $011021.l [Writes: Stack Pointer] [Flow: call]
	ora ($7F.b,X)		; 01 7F ; Logical OR ($7F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	sbc $360203.l,X		; FF 03 02 36 ; Subtract with carry (long,X) $360203.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $677F.w,Y		; 39 7F 67 ; AND accumulator with memory $677F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and $1E9921.l,X		; 3F 21 99 1E ; AND accumulator with memory (long,X) $1E9921.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$0022.w		; C0 22 00 ; Compare #$0022.w with Y register [Reads: Y Index] [Flags: NCZ]
	asl $FC.b		; 06 FC ; Arithmetic shift left $FC.b [Reads: Direct Page] [Flags: NCZ]
	cpy #$C080.w		; C0 80 C0 ; Compare #$C080.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpx #$F0FF.w		; E0 FF F0 ; Compare #$F0FF.w with X register [Reads: X Index] [Flags: NCZ]
	mvp $FA,$6F		; 44 6F FA ; Move block positive $FA,$6F [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $F0.b		; 05 F0 ; Logical OR $F0.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror $6F90.w		; 6E 90 6F ; Rotate right $6F90.w [Flags: NCZ]
	.db $B0, $2F		; B0 2F ; Branch if carry set to $B0, $2F [Flow: branch]
	eor $F8.b,S		; 43 F8 ; Exclusive OR accumulator with stack relative $F8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $003CE0.l		; 6F E0 3C 00 ; Add with carry (long) $003CE0.l [Writes: Accumulator] [Flags: NCVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora ($0D.b,X)		; 01 0D ; Logical OR ($0D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $42, $0B		; 42 0B ; Reserved instruction
	ora #$C738.w		; 09 38 C7 ; Logical OR #$C738.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $FF.b,S		; 03 FF ; OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sty $FC.b		; 84 FC ; Store Y register to $FC.b [Reads: Y Index]
	asl $FE.b		; 06 FE ; Arithmetic shift left $FE.b [Reads: Direct Page] [Flags: NCZ]
	and ($FF.b,X)		; 21 FF ; Logical AND ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ldy #$46FF.w		; A0 FF 46 ; Load #$46FF.w into Y register [Writes: Y Index] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$CF.b]		; 07 CF ; OR accumulator with memory (long) [$CF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $E68347.l		; 8F 47 83 E6 ; Store accumulator (long) $E68347.l [Reads: Accumulator]
	sbc $FBF300.l,X		; FF 00 F3 FB ; Subtract with carry (long,X) $FBF300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$FF.b],Y		; F7 FF ; Subtract with carry (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FF6300.l,X		; FF 00 63 FF ; Subtract with carry (long,X) $FF6300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $00EF00.l,X		; FF 00 EF 00 ; Subtract with carry (long,X) $00EF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $6B.b		; 00 6B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ror $1B.b		; 66 1B ; Rotate right $1B.b [Reads: Direct Page] [Flags: NCZ]
	ora ($BE.b)		; 12 BE ; OR accumulator with memory (indirect) ($BE.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	stx $44.b		; 86 44 ; Store X register to $44.b [Reads: X Index]
	adc $29E080.l,X		; 7F 80 E0 29 ; Add long $29E080.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $29FE.w,Y		; 19 FE 29 ; OR accumulator with memory $29FE.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $5BE724.l		; EF 24 E7 5B ; Subtract with carry (long) $5BE724.l [Writes: Accumulator] [Flags: NCVZ]
	ora $01.b,X		; 15 01 ; OR accumulator with memory $01.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $7E7F.w,X		; 3D 7F 7E ; AND accumulator with memory $7E7F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cpx #$F35B.w		; E0 5B F3 ; Compare #$F35B.w with X register [Reads: X Index] [Flags: NCZ]
	pei ($77.b)		; D4 77 ; Push effective indirect address ($77.b) [Reads: Direct Page] [Writes: Stack Pointer]
	cpx $77.b		; E4 77 ; Compare $77.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	sty $57.b,X		; 94 57 ; Store Y register $57.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc ($B3.b)		; 72 B3 ; Add with carry (indirect) ($B3.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	dec $1F38.w,X		; DE 38 1F ; Decrement memory $1F38.w,X [Reads: X Index] [Flags: NZ]
	tsb $0808.w		; 0C 08 08 ; Test and set bits $0808.w [Reads: Accumulator] [Flags: Z]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	trb $0C.b		; 14 0C ; Test and reset bits $0C.b [Reads: Accumulator] [Flags: Z]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $43EFE2.l		; 0F E2 EF 43 ; OR accumulator with memory (long) $43EFE2.l [Writes: Accumulator] [Flags: NZ]
	adc [$EE.b]		; 67 EE ; Add with carry (long) [$EE.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc $4DEE.w		; ED EE 4D ; Subtract $4DEE.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	dec $9D96.w		; CE 96 9D ; Decrement $9D96.w [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	bit $23F0.w,X		; 3C F0 23 ; Test bits $23F0.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	.db $10, $E0		; 10 E0 ; Branch if plus to $10, $E0 [Flow: branch]
	rol $6030.w		; 2E 30 60 ; Rotate left $6030.w [Flags: NCZ]
	cpy #$C2BD.w		; C0 BD C2 ; Compare #$C2BD.w with Y register [Reads: Y Index] [Flags: NCZ]
	sbc ($FC.b,S),Y		; F3 FC ; Subtract with carry (stack relative indirect indexed) ($FC.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	asl $F7.b,X		; 16 F7 ; Arithmetic shift left $F7.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $05.b		; C5 05 ; Compare $05.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	and $4338.w,Y		; 39 38 43 ; AND accumulator with memory $4338.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ror $7E40.w,X		; 7E 40 7E ; Rotate right $7E40.w,X [Reads: X Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sty $FA.b		; 84 FA ; Store Y register to $FA.b [Reads: Y Index]
	cmp [$81.b]		; C7 81 ; Compare accumulator (long) [$81.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sta ($4A.b,X)		; 81 4A ; Store accumulator ($4A.b,X) [Reads: Direct Page, Accumulator, X Index]
	ror $7C7C.w,X		; 7E 7C 7C ; Rotate right $7C7C.w,X [Reads: X Index] [Flags: NCZ]
	adc $0279.w,Y		; 79 79 02 ; Add $0279.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $0D.b,S		; 03 0D ; OR accumulator with stack relative $0D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $F3FF3E.l,X		; FF 3E FF F3 ; Subtract with carry (long,X) $F3FF3E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($C2BD.w,X)		; FC BD C2 ; Jump to subroutine indirect indexed ($C2BD.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sta ($83.b,X)		; 81 83 ; Store accumulator ($83.b,X) [Reads: Direct Page, Accumulator, X Index]
	stx $FC.b		; 86 FC ; Store X register to $FC.b [Reads: X Index]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($EF.b,X)		; 01 EF ; Logical OR ($EF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	eor $EC.b,S		; 43 EC ; Exclusive OR accumulator with stack relative $EC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	cpx #$EB26.w		; E0 26 EB ; Compare #$EB26.w with X register [Reads: X Index] [Flags: NCZ]
	eor $5DEF.w,X		; 5D EF 5D ; Exclusive OR accumulator with memory $5DEF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc [$4E.b],Y		; F7 4E ; Subtract with carry (long indexed) [$4E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	eor [$FD.b],Y		; 57 FD ; Exclusive OR accumulator with memory (long indexed) [$FD.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	eor ($41.b,X)		; 41 41 ; Exclusive OR accumulator with memory ($41.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	inc $5F3C.w,X		; FE 3C 5F ; Increment memory $5F3C.w,X [Reads: X Index] [Flags: NZ]
	and $82BE.w,X		; 3D BE 82 ; AND accumulator with memory $82BE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $B0504C.l		; CF 4C 50 B0 ; Compare accumulator (long) $B0504C.l [Reads: Accumulator] [Flags: NCZ]
	lda $67FBC0.l,X		; BF C0 FB 67 ; Load long $67FBC0.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $01B7.w,Y		; 59 B7 01 ; Exclusive OR accumulator with memory $01B7.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $80, $41		; 80 41 ; Branch always to $80, $41 [Flow: branch]
	.db $30, $0F		; 30 0F ; Branch if minus to $30, $0F [Flow: branch]
	jsl $2E0F00.l		; 22 00 0F 2E ; Jump to subroutine long $2E0F00.l [Writes: Stack Pointer] [Flow: call]
	cmp $D53A.w,Y		; D9 3A D5 ; Compare accumulator $D53A.w,Y [Reads: Y Index] [Flags: NCZ]
	.db $B0, $CF		; B0 CF ; Branch if carry set to $B0, $CF [Flow: branch]
	sbc [$1F.b]		; E7 1F ; Subtract with carry (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jmp $5ABC.w		; 4C BC 5A ; Jump to $5ABC.w [Flow: jump]
	clv		; B8 ; Clear overflow flag [Flags: V]
	stz $B0.b		; 64 B0 ; Store zero to $B0.b
	sbc ($39.b),Y		; F1 39 ; Subtract with carry ($39.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx #$035A.w		; E0 5A 03 ; Compare #$035A.w with X register [Reads: X Index] [Flags: NCZ]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $A7.b		; 06 A7 ; Arithmetic shift left $A7.b [Reads: Direct Page] [Flags: NCZ]
	sbc $BD.b		; E5 BD ; Subtract $BD.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	ror $3E63.w,X		; 7E 63 3E ; Rotate right $3E63.w,X [Reads: X Index] [Flags: NCZ]
	lda $86.b,X		; B5 86 ; Load $86.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	jmp $81FE.w		; 4C FE 81 ; Jump to $81FE.w [Flow: jump]
	sta $1873.w		; 8D 73 18 ; Store accumulator to $1873.w [Reads: Accumulator]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$B078.w		; C0 78 B0 ; Compare #$B078.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	and $51.b		; 25 51 ; Logical AND $51.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	mvp $85,$A0		; 44 A0 85 ; Move block positive $85,$A0 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	ora $1D90.w		; 0D 90 1D ; Logical OR $1D90.w with accumulator [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc $FD80.w,X		; 7D 80 FD ; Add $FD80.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	and ($62.b,S),Y		; 33 62 ; AND accumulator (stack relative indirect indexed) ($62.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rep #$82		; C2 82 ; Reset processor status bits #$82 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $37.b		; 06 37 ; Arithmetic shift left $37.b [Reads: Direct Page] [Flags: NCZ]
	dec $DAAB.w		; CE AB DA ; Decrement $DAAB.w [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	cmp [$36.b],Y		; D7 36 ; Compare accumulator (long indexed) [$36.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	ror $DE53.w		; 6E 53 DE ; Rotate right $DE53.w [Flags: NCZ]
	lda [$BE.b]		; A7 BE ; Load accumulator (long) [$BE.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$36.b]		; 07 36 ; OR accumulator with memory (long) [$36.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cmp $38C830.l,X		; DF 30 C8 38 ; Compare accumulator (long,X) $38C830.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	sbc [$5F.b]		; E7 5F ; Subtract with carry (long) [$5F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $6F		; F0 6F ; Branch if equal to $F0, $6F [Flow: branch]
	sbc $7FFF70.l,X		; FF 70 FF 7F ; Subtract with carry (long,X) $7FFF70.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $83FF3F.l,X		; BF 3F FF 83 ; Load long $83FF3F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b)		; 12 00 ; OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $3020.w		; 0E 20 30 ; Arithmetic shift left $3020.w [Flags: NCZ]
	and $FF0040.l,X		; 3F 40 00 FF ; AND accumulator with memory (long,X) $FF0040.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $DE3F.w,X		; 3C 3F DE ; Test bits $DE3F.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	sta $76CFEE.l,X		; 9F EE CF 76 ; Store accumulator (long,X) $76CFEE.l,X [Reads: Accumulator, X Index]
	eor $AF.b		; 45 AF ; Exclusive OR $AF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $04.b,X		; 36 04 ; Rotate left $04.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $040C.w		; 1C 0C 04 ; Test and reset bits $040C.w [Reads: Accumulator] [Flags: Z]
	jsl $070144.l		; 22 44 01 07 ; Jump to subroutine long $070144.l [Writes: Stack Pointer] [Flow: call]
	ora $83.b,S		; 03 83 ; OR accumulator with stack relative $83.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sep #$02		; E2 02 ; Set processor status bits #$02 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	cpx #$0122.w		; E0 22 01 ; Compare #$0122.w with X register [Reads: X Index] [Flags: NCZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	inc $06.b,X		; F6 06 ; Increment memory $06.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	asl $04.b,X		; 16 04 ; Arithmetic shift left $04.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $84.b		; 02 84 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ror $E781.w,X		; 7E 81 E7 ; Rotate right $E781.w,X [Reads: X Index] [Flags: NCZ]
	ror $7E91.w,X		; 7E 91 7E ; Rotate right $7E91.w,X [Reads: X Index] [Flags: NCZ]
	lda ($7E.b),Y		; B1 7E ; Load accumulator ($7E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $7E.b		; 85 7E ; Store accumulator to $7E.b [Reads: Accumulator]
	sta $3E.b,S		; 83 3E ; Store accumulator (stack relative) $3E.b,S [Reads: Stack Pointer, Accumulator]
	cmp $5A.b,S		; C3 5A ; Compare accumulator (stack relative) $5A.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	ror $0081.w,X		; 7E 81 00 ; Rotate right $0081.w,X [Reads: X Index] [Flags: NCZ]
	and $7E.b		; 25 7E ; Logical AND $7E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $1000.w		; 0E 00 10 ; Arithmetic shift left $1000.w [Flags: NCZ]
	.db $90, $38		; 90 38 ; Branch if carry clear to $90, $38 [Flow: branch]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	trb $0E94.w		; 1C 94 0E ; Test and reset bits $0E94.w [Reads: Accumulator] [Flags: Z]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	ora [$E5.b]		; 07 E5 ; OR accumulator with memory (long) [$E5.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $F2.b,S		; 03 F2 ; OR accumulator with stack relative $F2.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $33E000.l		; 22 00 E0 33 ; Jump to subroutine long $33E000.l [Writes: Stack Pointer] [Flow: call]
	.db $10, $08		; 10 08 ; Branch if plus to $10, $08 [Flow: branch]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	sta ($C0.b,X)		; 81 C0 ; Store accumulator ($C0.b,X) [Reads: Direct Page, Accumulator, X Index]
	sbc $2E445C.l,X		; FF 5C 44 2E ; Subtract with carry (long,X) $2E445C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $17.b,S		; 23 17 ; AND accumulator with stack relative $17.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($0B.b),Y		; 11 0B ; OR accumulator with memory ($0B.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $82, $8F, $C0		; 82 8F C0 ; Branch always long to $82, $8F, $C0 [Flow: branch]
	adc $180000.l,X		; 7F 00 00 18 ; Add long $180000.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $0306.w		; 0C 06 03 ; Test and set bits $0306.w [Reads: Accumulator] [Flags: Z]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta $FF.b,S		; 83 FF ; Store accumulator (stack relative) $FF.b,S [Reads: Stack Pointer, Accumulator]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$1700.w		; C0 00 17 ; Compare #$1700.w with Y register [Reads: Y Index] [Flags: NCZ]
	sbc $080B.w,Y		; F9 0B 08 ; Subtract with carry $080B.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $FF		; F0 FF ; Branch if equal to $F0, $FF [Flow: branch]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: NCZ]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $03FF.w,X		; 3E FF 03 ; Rotate left $03FF.w,X [Reads: X Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $C08080.l,X		; FF 80 80 C0 ; Subtract with carry (long,X) $C08080.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cpx #$7020.w		; E0 20 70 ; Compare #$7020.w with X register [Reads: X Index] [Flags: NCZ]
	.db $10, $B8		; 10 B8 ; Branch if plus to $10, $B8 [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ora $0000FF.l		; 0F FF 00 00 ; OR accumulator with memory (long) $0000FF.l [Writes: Accumulator] [Flags: NZ]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $7303.w		; EE 03 73 ; Increment $7303.w [Flags: NZ]
	brk $BC.b		; 00 BC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $DF		; 80 DF ; Branch always to $80, $DF [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sbc $D0F7A0.l		; EF A0 F7 D0 ; Subtract with carry (long) $D0F7A0.l [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	inc $1C31.w,X		; FE 31 1C ; Increment memory $1C31.w,X [Reads: X Index] [Flags: NZ]
	ora $010307.l		; 0F 07 03 01 ; OR accumulator with memory (long) $010307.l [Writes: Accumulator] [Flags: NZ]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FEF4.w,X		; FD F4 FE ; Subtract with carry $FEF4.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	sbc $7E7FFD.l,X		; FF FD 7F 7E ; Subtract with carry (long,X) $7E7FFD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $1F1F3F.l,X		; 3F 3F 1F 1F ; AND accumulator with memory (long,X) $1F1F3F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $22070F.l		; 0F 0F 07 22 ; OR accumulator with memory (long) $22070F.l [Writes: Accumulator] [Flags: NZ]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $40		; 80 40 ; Branch always to $80, $40 [Flow: branch]
	jsr $0810.w		; 20 10 08 ; Jump to subroutine at $0810.w [Writes: Stack Pointer] [Flow: call]
	sbc $4DF75D.l		; EF 5D F7 4D ; Subtract with carry (long) $4DF75D.l [Writes: Accumulator] [Flags: NCVZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	adc $FF.b		; 65 FF ; Add $FF.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $FF		; 70 FF ; Branch if overflow set to $70, $FF [Flow: branch]
	jmp ($7FFF.w,X)		; 7C FF 7F ; Jump indirect indexed to ($7FFF.w,X) [Reads: X Index] [Flow: jump]
	.db $80, $7F		; 80 7F ; Branch always to $80, $7F [Flow: branch]
	sbc $604000.l,X		; FF 00 40 60 ; Subtract with carry (long,X) $604000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $78		; 70 78 ; Branch if overflow set to $70, $78 [Flow: branch]
	jsl $2CE07F.l		; 22 7F E0 2C ; Jump to subroutine long $2CE07F.l [Writes: Stack Pointer] [Flow: call]
	brk $EA.b		; 00 EA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp [$3B.b],Y		; D7 3B ; Compare accumulator (long indexed) [$3B.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	and [$D9.b]		; 27 D9 ; AND accumulator with memory (long) [$D9.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp [$7A.b],Y		; D7 7A ; Compare accumulator (long indexed) [$7A.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	sbc [$FB.b],Y		; F7 FB ; Subtract with carry (long indexed) [$FB.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$F8.b]		; 07 F8 ; OR accumulator with memory (long) [$F8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $04.b,X		; F6 04 ; Increment memory $04.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc $C00000.l,X		; FF 00 00 C0 ; Subtract with carry (long,X) $C00000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr $0000.w		; 20 00 00 ; Jump to subroutine at $0000.w [Writes: Stack Pointer] [Flow: call]
	sbc ($F8.b),Y		; F1 F8 ; Subtract with carry ($F8.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $AF		; 70 AF ; Branch if overflow set to $70, $AF [Flow: branch]
	adc $B45CDB.l		; 6F DB 5C B4 ; Add with carry (long) $B45CDB.l [Writes: Accumulator] [Flags: NCVZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda #$F337.w		; A9 37 F3 ; Load #$F337.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $001CE7.l		; 0F E7 1C 00 ; OR accumulator with memory (long) $001CE7.l [Writes: Accumulator] [Flags: NZ]
	ora $83381F.l		; 0F 1F 38 83 ; OR accumulator with memory (long) $83381F.l [Writes: Accumulator] [Flags: NZ]
	lsr $00.b		; 46 00 ; Logical shift right $00.b [Reads: Direct Page] [Flags: NCZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $FF2200.l		; 22 00 22 FF ; Jump to subroutine long $FF2200.l [Writes: Stack Pointer] [Flow: call]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$2F.b]		; E7 2F ; Subtract with carry (long) [$2F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp $F3B8D8.l,X		; DF D8 B8 F3 ; Compare accumulator (long,X) $F3B8D8.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	and ($00.b)		; 32 00 ; AND accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $0022FF.l,X		; FF FF 22 00 ; Subtract with carry (long,X) $0022FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $0046.w		; 0C 46 00 ; Test and set bits $0046.w [Reads: Accumulator] [Flags: Z]
	sbc $7D04.w,X		; FD 04 7D ; Subtract with carry $7D04.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $1D.b		; 00 1D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $D4.b,S		; 83 D4 ; Store accumulator (stack relative) $D4.b,S [Reads: Stack Pointer, Accumulator]
	cop $1F.b		; 02 1F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	sta $1F7FFF.l		; 8F FF 7F 1F ; Store accumulator (long) $1F7FFF.l [Reads: Accumulator]
	ora $00FF07.l		; 0F 07 FF 00 ; OR accumulator with memory (long) $00FF07.l [Writes: Accumulator] [Flags: NZ]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sed		; F8 ; Set decimal flag [Flags: D]
	lda $B25D78.l,X		; BF 78 5D B2 ; Load long $B25D78.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	dec $5B.b,X		; D6 5B ; Decrement memory $5B.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	ror $F7.b		; 66 F7 ; Rotate right $F7.b [Reads: Direct Page] [Flags: NCZ]
	asl $F800.w		; 0E 00 F8 ; Arithmetic shift left $F800.w [Flags: NCZ]
	jsr ($1038.w,X)		; FC 38 10 ; Jump to subroutine indirect indexed ($1038.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $E63FCF.l		; 0F CF 3F E6 ; OR accumulator with memory (long) $E63FCF.l [Writes: Accumulator] [Flags: NZ]
	eor $9F6FB0.l,X		; 5F B0 6F 9F ; Exclusive OR accumulator with memory (long,X) $9F6FB0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $70, $88		; 70 88 ; Branch if overflow set to $70, $88 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	eor [$BF.b]		; 47 BF ; Exclusive OR accumulator with memory (long) [$BF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror $9F.b		; 66 9F ; Rotate right $9F.b [Reads: Direct Page] [Flags: NCZ]
	adc ($AF.b,S),Y		; 73 AF ; Add with carry (stack relative indirect indexed) ($AF.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $F80F00.l		; 22 00 0F F8 ; Jump to subroutine long $F80F00.l [Writes: Stack Pointer] [Flow: call]
	ora [$C7.b]		; 07 C7 ; OR accumulator with memory (long) [$C7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	adc $BD.b,S		; 63 BD ; Add with carry (stack relative) $BD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	and ($DE.b),Y		; 31 DE ; AND accumulator with memory ($DE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $D7E7D6.l		; EF D6 E7 D7 ; Subtract with carry (long) $D7E7D6.l [Writes: Accumulator] [Flags: NCVZ]
	sbc [$95.b]		; E7 95 ; Subtract with carry (long) [$95.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$24.b]		; E7 24 ; Subtract with carry (long) [$24.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $C700C3.l		; 0F C3 00 C7 ; OR accumulator with memory (long) $C700C3.l [Writes: Accumulator] [Flags: NZ]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7B.b		; 00 7B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $B5.b,S		; 03 B5 ; OR accumulator with stack relative $B5.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $CF.b		; 06 CF ; Arithmetic shift left $CF.b [Reads: Direct Page] [Flags: NCZ]
	eor #$7AF6.w		; 49 F6 7A ; Exclusive OR #$7AF6.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cpx $2274.w		; EC 74 22 ; Compare $2274.w with X register [Reads: X Index] [Flags: NCZ]
	sbc $FC34E0.l,X		; FF E0 34 FC ; Subtract with carry (long,X) $FC34E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $30, $01		; 30 01 ; Branch if minus to $30, $01 [Flow: branch]
	ora $FF.b,S		; 03 FF ; OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $AF.b		; 00 AF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $B9		; 30 B9 ; Branch if minus to $30, $B9 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sbc $20.b,S		; E3 20 ; Subtract stack-relative $20.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	and $E0.b,S		; 23 E0 ; AND accumulator with stack relative $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $60.b,S		; 03 60 ; OR accumulator with stack relative $60.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta ($30.b),Y		; 91 30 ; Store accumulator ($30.b),Y [Reads: Direct Page, Y Index, Accumulator]
	eor ($10.b,X)		; 41 10 ; Exclusive OR accumulator with memory ($10.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $1F07C0.l,X		; FF C0 07 1F ; Subtract with carry (long,X) $1F07C0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $EFCF9F.l,X		; 1F 9F CF EF ; Logical OR long $EFCF9F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $07F700.l		; EF 00 F7 07 ; Subtract with carry (long) $07F700.l [Writes: Accumulator] [Flags: NCVZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $3A.b,S		; 03 3A ; OR accumulator with stack relative $3A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $35.b,S		; 03 35 ; OR accumulator with stack relative $35.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $6F.b		; 06 6F ; Arithmetic shift left $6F.b [Reads: Direct Page] [Flags: NCZ]
	ora #$1AF6.w		; 09 F6 1A ; Logical OR #$1AF6.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jmp.w [$F014]		; DC 14 F0 ; Jump long indirect [$F014] [Flow: jump]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($F8FC.w,X)		; FC FC F8 ; Jump to subroutine indirect indexed ($F8FC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $F0, $E1		; F0 E1 ; Branch if equal to $F0, $E1 [Flow: branch]
	sbc $43.b,S		; E3 43 ; Subtract stack-relative $43.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	tsb $0BF7.w		; 0C F7 0B ; Test and set bits $0BF7.w [Reads: Accumulator] [Flags: Z]
	cpx $7C17.w		; EC 17 7C ; Compare $7C17.w with X register [Reads: X Index] [Flags: NCZ]
	sta [$78.b]		; 87 78 ; Store accumulator (long) [$78.b] [Reads: Direct Page, Accumulator]
	lda [$6C.b]		; A7 6C ; Load accumulator (long) [$6C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda ($66.b,S),Y		; B3 66 ; Load accumulator (stack relative indirect indexed) ($66.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $BC63.w,Y		; B9 63 BC ; Load $BC63.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx #$FF59.w		; E0 59 FF ; Compare #$FF59.w with X register [Reads: X Index] [Flags: NCZ]
	.db $80, $DB		; 80 DB ; Branch always to $80, $DB [Flow: branch]
	sta ($BF.b,X)		; 81 BF ; Store accumulator ($BF.b,X) [Reads: Direct Page, Accumulator, X Index]
	sta $DB.b,S		; 83 DB ; Store accumulator (stack relative) $DB.b,S [Reads: Stack Pointer, Accumulator]
	and $F9.b		; 25 F9 ; Logical AND $F9.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jmp $B26DB8.l		; 5C B8 6D B2 ; Jump long to $B26DB8.l [Flow: jump]
	lsr $4FD8.w		; 4E D8 4F ; Logical shift right $4FD8.w [Flags: NCZ]
	ror $437D.w,X		; 7E 7D 43 ; Rotate right $437D.w,X [Reads: X Index] [Flags: NCZ]
	ora ($42.b,X)		; 01 42 ; Logical OR ($42.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $62, $61, $60		; 62 61 60 ; Push effective relative address $62, $61, $60 [Writes: Stack Pointer]
	sbc $FC87F8.l,X		; FF F8 87 FC ; Subtract with carry (long,X) $FC87F8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	inc $BF.b		; E6 BF ; Increment $BF.b [Reads: Direct Page] [Flags: NZ]
.INDEX 8
	sep #$DF		; E2 DF
	sep #$CB		; E2 CB ; Set processor status bits #$CB [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	dec $7D.b		; C6 7D ; Decrement $7D.b [Reads: Direct Page] [Flags: NZ]
	inc $79.b		; E6 79 ; Increment $79.b [Reads: Direct Page] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc $E6FE.w,X		; FD FE E6 ; Subtract with carry $E6FE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $7E.b		; E6 7E ; Increment $7E.b [Reads: Direct Page] [Flags: NZ]
	jmp ($FC78.w,X)		; 7C 78 FC ; Jump indirect indexed to ($FC78.w,X) [Reads: X Index] [Flow: jump]
	ora $FF.b,S		; 03 FF ; OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $62CB.w,X		; 3C CB 62 ; Test bits $62CB.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	stz $B8C7.w		; 9C C7 B8 ; Store zero to $B8C7.w
	cmp [$91.b]		; C7 91 ; Compare accumulator (long) [$91.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sbc $DFFF8F.l,X		; FF 8F FF DF ; Subtract with carry (long,X) $DFFF8F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpy #$BC.b		; C0 BC ; Compare #$BC.b with Y register [Reads: Y Index] [Flags: NCZ]
	ror $E7E7.w,X		; 7E E7 E7 ; Rotate right $E7E7.w,X [Reads: X Index] [Flags: NCZ]
	sbc $F8F8FF.l,X		; FF FF F8 F8 ; Subtract with carry (long,X) $F8F8FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $F2.b,X		; 75 F2 ; Add $F2.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $A0.b,S		; 23 A0 ; AND accumulator with stack relative $A0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $FF0FFD.l,X		; 1F FD 0F FF ; Logical OR long $FF0FFD.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ldx $D914.w		; AE 14 D9 ; Load $D914.w into X register [Writes: X Index] [Flags: NZ]
	ora $72E0FF.l		; 0F FF E0 72 ; OR accumulator with memory (long) $72E0FF.l [Writes: Accumulator] [Flags: NZ]
	ldy $C022.w		; AC 22 C0 ; Load $C022.w into Y register [Writes: Y Index] [Flags: NZ]
	ora ($C7.b,X)		; 01 C7 ; Logical OR ($C7.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $FF0043.l		; EF 43 00 FF ; Subtract with carry (long) $FF0043.l [Writes: Accumulator] [Flags: NCVZ]
	ora $77FE03.l		; 0F 03 FE 77 ; OR accumulator with memory (long) $77FE03.l [Writes: Accumulator] [Flags: NZ]
	jsr ($D46A.w,X)		; FC 6A D4 ; Jump to subroutine indirect indexed ($D46A.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	adc $66DF.w		; 6D DF 66 ; Add $66DF.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp $030072.l		; CF 72 00 03 ; Compare accumulator (long) $030072.l [Reads: Accumulator] [Flags: NCZ]
	ora [$23.b]		; 07 23 ; OR accumulator with memory (long) [$23.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $FF0712.l		; 0F 12 07 FF ; OR accumulator with memory (long) $FF0712.l [Writes: Accumulator] [Flags: NZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $3C.b,S		; 83 3C ; Store accumulator (stack relative) $3C.b,S [Reads: Stack Pointer, Accumulator]
	adc $702E38.l		; 6F 38 2E 70 ; Add with carry (long) $702E38.l [Writes: Accumulator] [Flags: NCVZ]
	cpx $DCF0.w		; EC F0 DC ; Compare $DCF0.w with X register [Reads: X Index] [Flags: NCZ]
	sbc [$B8.b]		; E7 B8 ; Subtract with carry (long) [$B8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cpx $0076.w		; EC 76 00 ; Compare $0076.w with X register [Reads: X Index] [Flags: NCZ]
	cmp [$22.b]		; C7 22 ; Compare accumulator (long) [$22.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sbc $BBDF0D.l		; EF 0D DF BB ; Subtract with carry (long) $BBDF0D.l [Writes: Accumulator] [Flags: NCVZ]
	adc [$FF.b],Y		; 77 FF ; Add with carry (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and $BF40DF.l,X		; 3F DF 40 BF ; AND accumulator with memory (long,X) $BF40DF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $7098F8.l		; 0F F8 98 70 ; OR accumulator with memory (long) $7098F8.l [Writes: Accumulator] [Flags: NZ]
	mvp $F0,$10		; 44 10 F0 ; Move block positive $F0,$10 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	and $67707F.l,X		; 3F 7F 70 67 ; AND accumulator with memory (long,X) $67707F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $FF0BEF.l		; 22 EF 0B FF ; Jump to subroutine long $FF0BEF.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $7F		; 90 7F ; Branch if carry clear to $90, $7F [Flow: branch]
	eor $CF30B0.l		; 4F B0 30 CF ; Exclusive OR accumulator with memory (long) $CF30B0.l [Writes: Accumulator] [Flags: NZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stx $79.b		; 86 79 ; Store X register to $79.b [Reads: X Index]
	adc $0024.w,Y		; 79 24 00 ; Add $0024.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $80.b,X		; 16 80 ; Arithmetic shift left $80.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cmp $8679FF.l		; CF FF 79 86 ; Compare accumulator (long) $8679FF.l [Reads: Accumulator] [Flags: NCZ]
	sbc $0080FF.l,X		; FF FF 80 00 ; Subtract with carry (long,X) $0080FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $40		; 80 40 ; Branch always to $80, $40 [Flow: branch]
	cpy #$60.b		; C0 60 ; Compare #$60.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $D0, $20		; D0 20 ; Branch if not equal to $D0, $20 [Flow: branch]
	cld		; D8 ; Clear decimal flag [Flags: D]
	jsr $60DC.w		; 20 DC 60 ; Jump to subroutine at $60DC.w [Writes: Stack Pointer] [Flow: call]
	stx $78.b,Y		; 96 78 ; Store X register $78.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	wai		; CB ; Wait for interrupt
	bit $22.b		; 24 22 ; Test bits $22.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	.db $80, $E0		; 80 E0 ; Branch always to $80, $E0 [Flow: branch]
	jmp $80C0C0.l		; 5C C0 C0 80 ; Jump long to $80C0C0.l [Flow: jump]
	.db $80, $D0		; 80 D0 ; Branch always to $80, $D0 [Flow: branch]
	lda ($12.b,S),Y		; B3 12 ; Load accumulator (stack relative indirect indexed) ($12.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $90DD2C.l,X		; BF 2C DD 90 ; Load long $90DD2C.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $42.b,S		; 63 42 ; Add with carry (stack relative) $42.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	lda $1FDF20.l,X		; BF 20 DF 1F ; Load long $1FDF20.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $407F80.l,X		; FF 80 7F 40 ; Subtract with carry (long,X) $407F80.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp $2240.w		; 4C 40 22 ; Jump to $2240.w [Flow: jump]
	stz $E0C0.w		; 9C C0 E0 ; Store zero to $E0C0.w
	adc $21E1BF.l,X		; 7F BF E1 21 ; Add long $21E1BF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$20.b		; E0 20 ; Compare #$20.b with X register [Reads: X Index] [Flags: NCZ]
	cpx $24.b		; E4 24 ; Compare $24.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $F0, $30		; F0 30 ; Branch if equal to $F0, $30 [Flow: branch]
	cmp $6F19.w,Y		; D9 19 6F ; Compare accumulator $6F19.w,Y [Reads: Y Index] [Flags: NCZ]
	ora $DF80B0.l		; 0F B0 80 DF ; OR accumulator with memory (long) $DF80B0.l [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	dec $DBDF.w,X		; DE DF DB ; Decrement memory $DBDF.w,X [Reads: X Index] [Flags: NZ]
	cmp $7FF0E6.l		; CF E6 F0 7F ; Compare accumulator (long) $7FF0E6.l [Reads: Accumulator] [Flags: NCZ]
	and $FD02FB.l,X		; 3F FB 02 FD ; AND accumulator with memory (long,X) $FD02FB.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($F6.b,X)		; 01 F6 ; Logical OR ($F6.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $F0, $1B		; F0 1B ; Branch if equal to $F0, $1B [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $250C.w		; 0D 0C 25 ; Logical OR $250C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	bit $05.b		; 24 05 ; Test bits $05.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	tsb $8D.b		; 04 8D ; Test and set bits $8D.b [Reads: Accumulator] [Flags: Z]
	sty $FEFC.w		; 8C FC FE ; Store Y register to $FEFC.w [Reads: Y Index]
	ora $DBF3E7.l		; 0F E7 F3 DB ; OR accumulator with memory (long) $DBF3E7.l [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	adc ($20.b,S),Y		; 73 20 ; Add with carry (stack relative indirect indexed) ($20.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cmp $3FC03F.l,X		; DF 3F C0 3F ; Compare accumulator (long,X) $3FC03F.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	cmp $FCE718.l		; CF 18 E7 FC ; Compare accumulator (long) $FCE718.l [Reads: Accumulator] [Flags: NCZ]
	ora $F6.b,S		; 03 F6 ; OR accumulator with stack relative $F6.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $FC03.w,Y		; F9 03 FC ; Subtract with carry $FC03.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($FE.b,X)		; 01 FE ; Logical OR ($FE.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($F0.b,S),Y		; 13 F0 ; OR accumulator (stack relative indirect indexed) ($F0.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $F01FE0.l,X		; 9F E0 1F F0 ; Store accumulator (long,X) $F01FE0.l,X [Reads: Accumulator, X Index]
	sta $7FC0FF.l		; 8F FF C0 7F ; Store accumulator (long) $7FC0FF.l [Reads: Accumulator]
	cpx #$3F.b		; E0 3F ; Compare #$3F.b with X register [Reads: X Index] [Flags: NCZ]
	dec $3EC3.w,X		; DE C3 3E ; Decrement memory $3EC3.w,X [Reads: X Index] [Flags: NZ]
	sbc $3F02.w,X		; FD 02 3F ; Subtract with carry $3F02.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $230F1F.l,X		; 3F 1F 0F 23 ; AND accumulator with memory (long,X) $230F1F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($28.b)		; F2 28 ; Subtract with carry (indirect) ($28.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta ($2C.b),Y		; 91 2C ; Store accumulator ($2C.b),Y [Reads: Direct Page, Y Index, Accumulator]
	sed		; F8 ; Set decimal flag [Flags: D]
	lsr $43A2.w,X		; 5E A2 43 ; Logical shift right $43A2.w,X [Reads: X Index] [Flags: NCZ]
	cpx #$20.b		; E0 20 ; Compare #$20.b with X register [Reads: X Index] [Flags: NCZ]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: NCZ]
	jmp.w [$FF00]		; DC 00 FF ; Jump long indirect [$FF00] [Flow: jump]
	brk $C7.b		; 00 C7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $81.b,S		; C3 81 ; Compare accumulator (stack relative) $81.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	stz $229F.w		; 9C 9F 22 ; Store zero to $229F.w
	lda $BCF307.l,X		; BF 07 F3 BC ; Load long $BCF307.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	trb $0AFD.w		; 1C FD 0A ; Test and reset bits $0AFD.w [Reads: Accumulator] [Flags: Z]
	lda $43C6.w,X		; BD C6 43 ; Load $43C6.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $07E6.w,X		; 1D E6 07 ; OR accumulator with memory $07E6.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $1FE7.w,X		; 1E E7 1F ; Arithmetic shift left $1FE7.w,X [Reads: X Index] [Flags: NCZ]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: NCZ]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$23.b		; E0 23 ; Compare #$23.b with X register [Reads: X Index] [Flags: NCZ]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	and #$77DD.w		; 29 DD 77 ; Logical AND #$77DD.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp $C97F.w,X		; DD 7F C9 ; Compare accumulator $C97F.w,X [Reads: X Index] [Flags: NCZ]
	ror $3EE3.w,X		; 7E E3 3E ; Rotate right $3EE3.w,X [Reads: X Index] [Flags: NCZ]
	sbc $99FF3C.l,X		; FF 3C FF 99 ; Subtract with carry (long,X) $99FF3C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $00C3.w,X		; 3C C3 00 ; Test bits $00C3.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	sbc $7E7F77.l,X		; FF 77 7F 7E ; Subtract with carry (long,X) $7E7F77.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $183C.w,X		; 3E 3C 18 ; Rotate left $183C.w,X [Reads: X Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $718E7F.l,X		; FF 7F 8E 71 ; Subtract with carry (long,X) $718E7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $6A9B6E.l,X		; 9F 6E 9B 6A ; Store accumulator (long,X) $6A9B6E.l,X [Reads: Accumulator, X Index]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	asl $EEFB.w		; 0E FB EE ; Arithmetic shift left $EEFB.w [Flags: NCZ]
	ora $F10EE4.l,X		; 1F E4 0E F1 ; Logical OR long $F10EE4.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $0E.b,S		; 23 0E ; AND accumulator with stack relative $0E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$43.b]		; 07 43 ; OR accumulator with memory (long) [$43.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sty $09F7.w		; 8C F7 09 ; Store Y register to $09F7.w [Reads: Y Index]
	ldx $FFC1.w,Y		; BE C1 FF ; Load X register $FFC1.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ldy $AEE3.w,X		; BC E3 AE ; Load Y register $AEE3.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	sbc $C13EBC.l,X		; FF BC 3E C1 ; Subtract with carry (long,X) $C13EBC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $3C.b,X		; 15 3C ; OR accumulator with memory $3C.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	rol $003C.w,X		; 3E 3C 00 ; Rotate left $003C.w,X [Reads: X Index] [Flags: NCZ]
	jsr ($FC07.w,X)		; FC 07 FC ; Jump to subroutine indirect indexed ($FC07.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $1E.b,S		; E3 1E ; Subtract stack-relative $1E.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	sbc $FDCE.w,Y		; F9 CE FD ; Subtract with carry $FDCE.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $0EFD.w		; EE FD 0E ; Increment $0EFD.w [Flags: NZ]
	sbc $F3FC.w,Y		; F9 FC F3 ; Subtract with carry $F3FC.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($0007.w,X)		; FC 07 00 ; Jump to subroutine indirect indexed ($0007.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpx #$84.b		; E0 84 ; Compare #$84.b with X register [Reads: X Index] [Flags: NCZ]
	adc ($00.b),Y		; 71 00 ; Add with carry ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$4C.b		; E0 4C ; Compare #$4C.b with X register [Reads: X Index] [Flags: NCZ]
	brk $CF.b		; 00 CF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $DF		; 70 DF ; Branch if overflow set to $70, $DF [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $1AF74A.l,X		; BF 4A F7 1A ; Load long $1AF74A.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc [$3B.b]		; E7 3B ; Subtract with carry (long) [$3B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inc $FF3B.w		; EE 3B FF ; Increment $FF3B.w [Flags: NZ]
	adc ($FF.b,X)		; 61 FF ; Add with carry ($FF.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cop $09.b		; 02 09 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc ($63.b,S),Y		; 73 63 ; Add with carry (stack relative indirect indexed) ($63.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $D0, $EC		; D0 EC ; Branch if not equal to $D0, $EC [Flow: branch]
	sbc [$D8.b]		; E7 D8 ; Subtract with carry (long) [$D8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $A4FCB0.l		; EF B0 FC A4 ; Subtract with carry (long) $A4FCB0.l [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	sbc $93.b,S		; E3 93 ; Subtract stack-relative $93.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	stz $96.b		; 64 96 ; Store zero to $96.b
	sbc $DFEF9C.l		; EF 9C EF DF ; Subtract with carry (long) $DFEF9C.l [Writes: Accumulator] [Flags: NCVZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	lda ($A7.b,S),Y		; B3 A7 ; Load accumulator (stack relative indirect indexed) ($A7.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpy $C0C9.w		; CC C9 C0 ; Compare $C0C9.w with Y register [Reads: Y Index] [Flags: NCZ]
	stz $CD61.w,X		; 9E 61 CD ; Store zero to $CD61.w,X [Reads: X Index]
	and ($A3.b)		; 32 A3 ; AND accumulator with memory (indirect) ($A3.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $22BE.w,X		; 1D BE 22 ; OR accumulator with memory $22BE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$E01C]		; DC 1C E0 ; Jump long indirect [$E01C] [Flow: jump]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sbc $00FF6F.l,X		; FF 6F FF 00 ; Subtract with carry (long,X) $00FF6F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $5C3E.w		; 6D 3E 5C ; Add $5C3E.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	eor ($23.b,X)		; 41 23 ; Exclusive OR accumulator with memory ($23.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $A70000.l,X		; 1F 00 00 A7 ; Logical OR long $A70000.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($B6.b,S),Y		; 13 B6 ; OR accumulator (stack relative indirect indexed) ($B6.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta ($43.b)		; 92 43 ; Store accumulator (indirect) ($43.b) [Reads: Direct Page, Accumulator]
	and $1F08.w		; 2D 08 1F ; Logical AND $1F08.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ror $44.b		; 66 44 ; Rotate right $44.b [Reads: Direct Page] [Flags: NCZ]
	sbc ($B2.b,S),Y		; F3 B2 ; Subtract with carry (stack relative indirect indexed) ($B2.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc $49482F.l		; EF 2F 48 49 ; Subtract with carry (long) $49482F.l [Writes: Accumulator] [Flags: NCVZ]
	cmp ($D3.b,S),Y		; D3 D3 ; Compare accumulator (stack relative indirect indexed) ($D3.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	sta $270C.w,Y		; 99 0C 27 ; Store accumulator to $270C.w,Y [Reads: Y Index, Accumulator]
	.db $10, $80		; 10 80 ; Branch if plus to $10, $80 [Flow: branch]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $90, $60		; 90 60 ; Branch if carry clear to $90, $60 [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $70, $DC		; 70 DC ; Branch if overflow set to $70, $DC [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	bit $3FDC.w,X		; 3C DC 3F ; Test bits $3FDC.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx #$59.b		; E0 59 ; Compare #$59.b with X register [Reads: X Index] [Flags: NCZ]
	eor $06DF00.l,X		; 5F 00 DF 06 ; Exclusive OR accumulator with memory (long,X) $06DF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $B904.w,X		; DD 04 B9 ; Compare accumulator $B904.w,X [Reads: X Index] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	adc $F518.w,Y		; 79 18 F5 ; Add $F518.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $50, $6D		; 50 6D ; Branch if overflow clear to $50, $6D [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	lda $E080.w		; AD 80 E0 ; Load $E080.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cpx #$E2.b		; E0 E2 ; Compare #$E2.b with X register [Reads: X Index] [Flags: NCZ]
	dec $86.b		; C6 86 ; Decrement $86.b [Reads: Direct Page] [Flags: NZ]
	asl $5E9E.w		; 0E 9E 5E ; Arithmetic shift left $5E9E.w [Flags: NCZ]
	cpx #$A0.b		; E0 A0 ; Compare #$A0.b with X register [Reads: X Index] [Flags: NCZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	lda ($AB.b)		; B2 AB ; Load accumulator (indirect) ($AB.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $6FAF56.l,X		; DF 56 AF 6F ; Compare accumulator (long,X) $6FAF56.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	.db $90, $70		; 90 70 ; Branch if carry clear to $90, $70 [Flow: branch]
	sta $7F897F.l		; 8F 7F 89 7F ; Store accumulator (long) $7F897F.l [Reads: Accumulator]
	ora $204484.l,X		; 1F 84 44 20 ; Logical OR long $204484.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $5FD0A0.l,X		; BF A0 D0 5F ; Load long $5FD0A0.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	lda $5B5774.l		; AF 74 57 5B ; Load long $5B5774.l into accumulator [Writes: Accumulator] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	jsr $8810.w		; 20 10 88 ; Jump to subroutine at $8810.w [Writes: Stack Pointer] [Flow: call]
	sty $E4.b		; 84 E4 ; Store Y register to $E4.b [Reads: Y Index]
	sty $84.b		; 84 84 ; Store Y register to $84.b [Reads: Y Index]
	stz $FE6C.w		; 9C 6C FE ; Store zero to $FE6C.w
	asl $2F.b		; 06 2F ; Arithmetic shift left $2F.b [Reads: Direct Page] [Flags: NCZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	lda $DEA7DD.l		; AF DD A7 DE ; Load long $DEA7DD.l into accumulator [Writes: Accumulator] [Flags: NZ]
	lda $DF.b,S		; A3 DF ; Load accumulator (stack relative) $DF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda ($DF.b,X)		; A1 DF ; Load accumulator ($DF.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$1F.b		; E0 1F ; Compare #$1F.b with X register [Reads: X Index] [Flags: NCZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx #$27.b		; E0 27 ; Compare #$27.b with X register [Reads: X Index] [Flags: NCZ]
	.db $10, $18		; 10 18 ; Branch if plus to $10, $18 [Flow: branch]
	ora [$1F.b],Y		; 17 1F ; OR accumulator with memory (long indexed) [$1F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $1F		; 10 1F ; Branch if plus to $10, $1F [Flow: branch]
	lda $EFD7B0.l		; AF B0 D7 EF ; Load long $EFD7B0.l into accumulator [Writes: Accumulator] [Flags: NZ]
	lda $9FF85F.l		; AF 5F F8 9F ; Load long $9FF85F.l into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $9F		; F0 9F ; Branch if equal to $F0, $9F [Flow: branch]
	sbc [$E0.b]		; E7 E0 ; Subtract with carry (long) [$E0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$40.b		; E0 40 ; Compare #$40.b with X register [Reads: X Index] [Flags: NCZ]
	ora $3F3F1F.l		; 0F 1F 3F 3F ; OR accumulator with memory (long) $3F3F1F.l [Writes: Accumulator] [Flags: NZ]
	cmp $BE413E.l,X		; DF 3E 41 BE ; Compare accumulator (long,X) $BE413E.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	adc $3FC080.l,X		; 7F 80 C0 3F ; Add long $3FC080.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $BF		; F0 BF ; Branch if equal to $F0, $BF [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	cmp $3E6F7C.l,X		; DF 7C 6F 3E ; Compare accumulator (long,X) $3E6F7C.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	and [$25.b],Y		; 37 25 ; AND accumulator with memory (long indexed) [$25.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	ora $0C0B1B.l,X		; 1F 1B 0B 0C ; Logical OR long $0C0B1B.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$18.b],Y		; 17 18 ; OR accumulator with memory (long indexed) [$18.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sbc [$16.b],Y		; F7 16 ; Subtract with carry (long indexed) [$16.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $6F5C45.l		; EF 45 5C 6F ; Subtract with carry (long) $6F5C45.l [Writes: Accumulator] [Flags: NCVZ]
	tsb $E0.b		; 04 E0 ; Test and set bits $E0.b [Reads: Accumulator] [Flags: Z]
	.db $F0, $E3		; F0 E3 ; Branch if equal to $F0, $E3 [Flow: branch]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $AC838F.l		; 22 8F 83 AC ; Jump to subroutine long $AC838F.l [Writes: Stack Pointer] [Flow: call]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $73E73F.l,X		; FF 3F E7 73 ; Subtract with carry (long,X) $73E73F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	wai		; CB ; Wait for interrupt
	adc $75DF.w,Y		; 79 DF 75 ; Add $75DF.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $DD.b,S		; 43 DD ; Exclusive OR accumulator with stack relative $DD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc [$04.b],Y		; 77 04 ; Add with carry (long indexed) [$04.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $77227F.l,X		; 7F 7F 22 77 ; Add long $77227F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $FE.b		; 02 FE ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $43EE.w,X		; 7D EE 43 ; Add $43EE.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $F6.b		; 25 F6 ; Logical AND $F6.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx #$38.b		; E0 38 ; Compare #$38.b with X register [Reads: X Index] [Flags: NCZ]
	lda $BDE6.w		; AD E6 BD ; Load $BDE6.w into accumulator [Writes: Accumulator] [Flags: NZ]
	inc $FCBD.w,X		; FE BD FC ; Increment memory $FCBD.w,X [Reads: X Index] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc [$7C.b]		; 67 7C ; Add with carry (long) [$7C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	bit $AC2C.w,X		; 3C 2C AC ; Test bits $AC2C.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	ldy $98BC.w,X		; BC BC 98 ; Load Y register $98BC.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FE03FC.l,X		; FF FC 03 FE ; Subtract with carry (long,X) $FE03FC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $9EC7.w,X		; FD C7 9E ; Subtract with carry $9EC7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda [$8E.b],Y		; B7 8E ; Load accumulator (long indexed) [$8E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	inc $FEFD.w,X		; FE FD FE ; Increment memory $FEFD.w,X [Reads: X Index] [Flags: NZ]
	sta ($FF.b,X)		; 81 FF ; Store accumulator ($FF.b,X) [Reads: Direct Page, Accumulator, X Index]
	asl $0000.w,X		; 1E 00 00 ; Arithmetic shift left $0000.w,X [Reads: X Index] [Flags: NCZ]
	jsr ($CEFE.w,X)		; FC FE CE ; Jump to subroutine indirect indexed ($CEFE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr ($1E80.w,X)		; FC 80 1E ; Jump to subroutine indirect indexed ($1E80.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $B1F8BF.l,X		; FF BF F8 B1 ; Subtract with carry (long,X) $B1F8BF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$A7.b],Y		; F7 A7 ; Subtract with carry (long indexed) [$A7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $3FE7A8.l		; 6F A8 E7 3F ; Add with carry (long) $3FE7A8.l [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $BF		; F0 BF ; Branch if equal to $F0, $BF [Flow: branch]
	sbc $00FF9F.l,X		; FF 9F FF 00 ; Subtract with carry (long,X) $00FF9F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $38063F.l		; 22 3F 06 38 ; Jump to subroutine long $38063F.l [Writes: Stack Pointer] [Flow: call]
	and $009FBF.l,X		; 3F BF 9F 00 ; AND accumulator with memory (long,X) $009FBF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc [$4C.b],Y		; F7 4C ; Subtract with carry (long indexed) [$4C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $FD.b,S		; 43 FD ; Exclusive OR accumulator with stack relative $FD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lsr $6AE0.w		; 4E E0 6A ; Logical shift right $6AE0.w [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	eor [$F1.b]		; 47 F1 ; Exclusive OR accumulator with memory (long) [$F1.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $FF0DFE.l		; 0F FE 0D FF ; OR accumulator with memory (long) $FF0DFE.l [Writes: Accumulator] [Flags: NZ]
	jmp $66DF.w		; 4C DF 66 ; Jump to $66DF.w [Flow: jump]
	adc ($60.b,X)		; 61 60 ; Add with carry ($60.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc ($2F.b,X)		; 61 2F ; Add with carry ($2F.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $F50E0D.l		; 0F 0D 0E F5 ; OR accumulator with memory (long) $F50E0D.l [Writes: Accumulator] [Flags: NZ]
	asl $07FB.w		; 0E FB 07 ; Arithmetic shift left $07FB.w [Flags: NCZ]
	sbc $3CF738.l		; EF 38 F7 3C ; Subtract with carry (long) $3CF738.l [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	trb $0FFF.w		; 1C FF 0F ; Test and reset bits $0FFF.w [Reads: Accumulator] [Flags: Z]
	sbc $07FF00.l,X		; FF 00 FF 07 ; Subtract with carry (long,X) $07FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$30.b		; C0 30 ; Compare #$30.b with Y register [Reads: Y Index] [Flags: NCZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	adc $0F3F7F.l,X		; 7F 7F 3F 0F ; Add long $0F3F7F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $3F		; 70 3F ; Branch if overflow set to $70, $3F [Flow: branch]
	.db $D0, $3F		; D0 3F ; Branch if not equal to $D0, $3F [Flow: branch]
	cmp $E09F71.l		; CF 71 9F E0 ; Compare accumulator (long) $E09F71.l [Reads: Accumulator] [Flags: NCZ]
	and $DE7BCE.l,X		; 3F CE 7B DE ; AND accumulator with memory (long,X) $DE7BCE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc ($DE.b),Y		; 71 DE ; Add with carry ($DE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($9E.b,X)		; 61 9E ; Add with carry ($9E.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($00.b,X)		; 61 00 ; Add with carry ($00.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $7B3F1F.l		; 0F 1F 3F 7B ; OR accumulator with memory (long) $7B3F1F.l [Writes: Accumulator] [Flags: NZ]
	adc ($61.b),Y		; 71 61 ; Add with carry ($61.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $53DD.w		; 6D DD 53 ; Add $53DD.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	inc $EF21.w		; EE 21 EF ; Increment $EF21.w [Flags: NZ]
	.db $80, $EF		; 80 EF ; Branch always to $80, $EF [Flow: branch]
	ldy #$CF.b		; A0 CF ; Load #$CF.b into Y register [Writes: Y Index] [Flags: NZ]
	.db $80, $D5		; 80 D5 ; Branch always to $80, $D5 [Flow: branch]
	jmp $0A9B.w		; 4C 9B 0A ; Jump to $0A9B.w [Flow: jump]
	lda [$25.b],Y		; B7 25 ; Load accumulator (long indexed) [$25.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsr $9010.w		; 20 10 90 ; Jump to subroutine at $9010.w [Writes: Stack Pointer] [Flow: call]
	.db $90, $B0		; 90 B0 ; Branch if carry clear to $90, $B0 [Flow: branch]
	jsl $804864.l		; 22 64 48 80 ; Jump to subroutine long $804864.l [Writes: Stack Pointer] [Flow: call]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	.db $80, $20		; 80 20 ; Branch always to $80, $20 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $90, $E0		; 90 E0 ; Branch if carry clear to $90, $E0 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $70, $0C		; 70 0C ; Branch if overflow set to $70, $0C [Flow: branch]
	stz $CE.b,X		; 74 CE ; Store zero to $CE.b,X [Reads: X Index]
	ldy $8D.b,X		; B4 8D ; Load Y register $8D.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	inc $00.b,X		; F6 00 ; Increment memory $00.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $80, $06		; 80 06 ; Branch always to $80, $06 [Flow: branch]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $F3.b		; 00 F3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($FF.b)		; 32 FF ; AND accumulator with memory (indirect) ($FF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($04.b)		; 12 04 ; OR accumulator with memory (indirect) ($04.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $F0, $0F		; F0 0F ; Branch if equal to $F0, $0F [Flow: branch]
	.db $F0, $6F		; F0 6F ; Branch if equal to $F0, $6F [Flow: branch]
	cld		; D8 ; Clear decimal flag [Flags: D]
	cmp [$98.b]		; C7 98 ; Compare accumulator (long) [$98.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	.db $80, $0C		; 80 0C ; Branch always to $80, $0C [Flow: branch]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	adc [$DF.b]		; 67 DF ; Add with carry (long) [$DF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $CF		; 30 CF ; Branch if minus to $30, $CF [Flow: branch]
	and $D01FE7.l,X		; 3F E7 1F D0 ; AND accumulator with memory (long,X) $D01FE7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $E070CF.l		; 6F CF 70 E0 ; Add with carry (long) $E070CF.l [Writes: Accumulator] [Flags: NCVZ]
	adc $FF3FBF.l,X		; 7F BF 3F FF ; Add long $FF3FBF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $DE27.w		; 1C 27 DE ; Test and reset bits $DE27.w [Reads: Accumulator] [Flags: Z]
	sta ($EE.b,S),Y		; 93 EE ; Store accumulator (stack relative indirect indexed) ($EE.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	wai		; CB ; Wait for interrupt
	lsr $76.b		; 46 76 ; Logical shift right $76.b [Reads: Direct Page] [Flags: NCZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $25.b		; 02 25 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0022FF.l,X		; FF FF 22 00 ; Subtract with carry (long,X) $0022FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $FF.b		; 04 FF ; Test and set bits $FF.b [Reads: Accumulator] [Flags: Z]
	sbc $FFFF00.l,X		; FF 00 FF FF ; Subtract with carry (long,X) $FFFF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $B08300.l		; 22 00 83 B0 ; Jump to subroutine long $B08300.l [Writes: Stack Pointer] [Flow: call]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	sbc $130022.l,X		; FF 22 00 13 ; Subtract with carry (long,X) $130022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $7E0000.l,X		; FF 00 00 7E ; Subtract with carry (long,X) $7E0000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($E7.b,X)		; 81 E7 ; Store accumulator ($E7.b,X) [Reads: Direct Page, Accumulator, X Index]
	ror $7E91.w,X		; 7E 91 7E ; Rotate right $7E91.w,X [Reads: X Index] [Flags: NCZ]
	lda ($7E.b),Y		; B1 7E ; Load accumulator ($7E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $7E.b		; 85 7E ; Store accumulator to $7E.b [Reads: Accumulator]
	sta $3E.b,S		; 83 3E ; Store accumulator (stack relative) $3E.b,S [Reads: Stack Pointer, Accumulator]
	cmp $5A.b,S		; C3 5A ; Compare accumulator (stack relative) $5A.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	ror $0081.w,X		; 7E 81 00 ; Rotate right $0081.w,X [Reads: X Index] [Flags: NCZ]
	and $7E.b		; 25 7E ; Logical AND $7E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx $30.b		; E4 30 ; Compare $30.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	.db $10, $EF		; 10 EF ; Branch if plus to $10, $EF [Flow: branch]
	.db $10, $FF		; 10 FF ; Branch if plus to $10, $FF [Flow: branch]
	sbc $10FF07.l		; EF 07 FF 10 ; Subtract with carry (long) $10FF07.l [Writes: Accumulator] [Flags: NCVZ]
	sbc $EFD7FF.l		; EF FF D7 EF ; Subtract with carry (long) $EFD7FF.l [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	jsl $EF1410.l		; 22 10 14 EF ; Jump to subroutine long $EF1410.l [Writes: Stack Pointer] [Flow: call]
	sbc $10D7EF.l,X		; FF EF D7 10 ; Subtract with carry (long,X) $10D7EF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $14		; 10 14 ; Branch if plus to $10, $14 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc [$08.b],Y		; F7 08 ; Subtract with carry (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F71CEB.l,X		; FF EB 1C F7 ; Subtract with carry (long,X) $F71CEB.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sbc $F7F7FF.l,X		; FF FF F7 F7 ; Subtract with carry (long,X) $F7F7FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	trb $22.b		; 14 22 ; Test and reset bits $22.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $EB.b		; 05 EB ; Logical OR $EB.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc [$FF.b],Y		; F7 FF ; Subtract with carry (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$08.b],Y		; F7 08 ; Subtract with carry (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sty $10.b		; 84 10 ; Store Y register to $10.b [Reads: Y Index]
	ora $09.b		; 05 09 ; Logical OR $09.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp [$10.b],Y		; D7 10 ; Compare accumulator (long indexed) [$10.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	sbc $FFFF07.l		; EF 07 FF FF ; Subtract with carry (long) $FFFF07.l [Writes: Accumulator] [Flags: NCVZ]
	sbc $2810FF.l		; EF FF 10 28 ; Subtract with carry (long) $2810FF.l [Writes: Accumulator] [Flags: NCVZ]
	jsl $D70610.l		; 22 10 06 D7 ; Jump to subroutine long $D70610.l [Writes: Stack Pointer] [Flow: call]
	sbc $10EFFF.l		; EF FF EF 10 ; Subtract with carry (long) $10EFFF.l [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $14		; 10 14 ; Branch if plus to $10, $14 [Flow: branch]
	eor $08.b,S		; 43 08 ; Exclusive OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $23F609.l,X		; FF 09 F6 23 ; Subtract with carry (long,X) $23F609.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $FE81.w,X		; FE 81 FE ; Increment memory $FE81.w,X [Reads: X Index] [Flags: NZ]
	sbc $08F7EA.l,X		; FF EA F7 08 ; Subtract with carry (long,X) $08F7EA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	trb $22.b		; 14 22 ; Test and reset bits $22.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $F6.b		; 05 F6 ; Logical OR $F6.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $EAFE.w,X		; FE FE EA ; Increment memory $EAFE.w,X [Reads: X Index] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	eor $DF.b,S		; 43 DF ; Exclusive OR accumulator with stack relative $DF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tsb $70CF.w		; 0C CF 70 ; Test and set bits $70CF.w [Reads: Accumulator] [Flags: Z]
	cmp $7C.b,S		; C3 7C ; Compare accumulator (stack relative) $7C.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	sbc ($7E.b,X)		; E1 7E ; Subtract with carry ($7E.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $7F		; F0 7F ; Branch if equal to $F0, $7F [Flow: branch]
	sta $00FF1F.l,X		; 9F 1F FF 00 ; Store accumulator (long,X) $00FF1F.l,X [Reads: Accumulator, X Index]
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: NCZ]
	ora ($0E.b,X)		; 01 0E ; Logical OR ($0E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $BC.b		; 00 BC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($3F.b,S),Y		; 73 3F ; Add with carry (stack relative indirect indexed) ($3F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $3F		; F0 3F ; Branch if equal to $F0, $3F [Flow: branch]
	cpx #$F8.b		; E0 F8 ; Compare #$F8.b with X register [Reads: X Index] [Flags: NCZ]
	cmp [$F0.b]		; C7 F0 ; Compare accumulator (long) [$F0.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora $FF2300.l		; 0F 00 23 FF ; OR accumulator with memory (long) $FF2300.l [Writes: Accumulator] [Flags: NZ]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $8000FF.l		; 0F FF 00 80 ; OR accumulator with memory (long) $8000FF.l [Writes: Accumulator] [Flags: NZ]
	adc $E07FBF.l,X		; 7F BF 7F E0 ; Add long $E07FBF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cmp $27B850.l,X		; DF 50 B8 27 ; Compare accumulator (long,X) $27B850.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	pea $EB4C.w		; F4 4C EB ; Push absolute address $EB4C.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	jsl $1F0400.l		; 22 00 04 1F ; Jump to subroutine long $1F0400.l [Writes: Stack Pointer] [Flow: call]
	jsr $0340.w		; 20 40 03 ; Jump to subroutine at $0340.w [Writes: Stack Pointer] [Flow: call]
	tsb $83.b		; 04 83 ; Test and set bits $83.b [Reads: Accumulator] [Flags: Z]
	ldx $0B04.w,Y		; BE 04 0B ; Load X register $0B04.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	sbc $02FE.w,X		; FD FE 02 ; Subtract with carry $02FE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($C5.b,X)		; 01 C5 ; Logical OR ($C5.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor [$6F.b]		; 47 6F ; Exclusive OR accumulator with memory (long) [$6F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	adc $A3BD43.l,X		; 7F 43 BD A3 ; Add long $A3BD43.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $FC0400.l		; 22 00 04 FC ; Jump to subroutine long $FC0400.l [Writes: Stack Pointer] [Flow: call]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $10, $80		; 10 80 ; Branch if plus to $10, $80 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	and [$00.b],Y		; 37 00 ; AND accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $8700FF.l		; 0F FF 00 87 ; OR accumulator with memory (long) $8700FF.l [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr ($C6C5.w,X)		; FC C5 C6 ; Jump to subroutine indirect indexed ($C6C5.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	.db $82, $75, $38		; 82 75 38 ; Branch always long to $82, $75, $38 [Flow: branch]
	wai		; CB ; Wait for interrupt
	jmp $46C5.w		; 4C C5 46 ; Jump to $46C5.w [Flow: jump]
	jsl $380400.l		; 22 00 04 38 ; Jump to subroutine long $380400.l [Writes: Stack Pointer] [Flow: call]
	mvp $30,$82		; 44 82 30 ; Move block positive $30,$82 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $0B0023.l,X		; FF 23 00 0B ; Subtract with carry (long,X) $0B0023.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $02.b		; 06 02 ; Arithmetic shift left $02.b [Reads: Direct Page] [Flags: NCZ]
	tsb $1904.w		; 0C 04 19 ; Test and set bits $1904.w [Reads: Accumulator] [Flags: Z]
	ora #$1233.w		; 09 33 12 ; Logical OR #$1233.w with accumulator [Writes: Accumulator] [Flags: NZ]
	rol $04.b		; 26 04 ; Rotate left $04.b [Reads: Direct Page] [Flags: NCZ]
	jsl $010400.l		; 22 00 04 01 ; Jump to subroutine long $010400.l [Writes: Stack Pointer] [Flow: call]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $2318.w		; 0C 18 23 ; Test and set bits $2318.w [Reads: Accumulator] [Flags: Z]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $30, $20		; 30 20 ; Branch if minus to $30, $20 [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $90, $CC		; 90 CC ; Branch if carry clear to $90, $CC [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	stz $20.b		; 64 20 ; Store zero to $20.b
	jsl $800500.l		; 22 00 05 80 ; Jump to subroutine long $800500.l [Writes: Stack Pointer] [Flow: call]
	cpy #$60.b		; C0 60 ; Compare #$60.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $30, $18		; 30 18 ; Branch if minus to $30, $18 [Flow: branch]
	bit $004C.w,X		; 3C 4C 00 ; Test bits $004C.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	bit $02.b		; 24 02 ; Test bits $02.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	bit $0000.w,X		; 3C 00 00 ; Test bits $0000.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	and $18.b		; 25 18 ; Logical AND $18.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	sbc [$24.b]		; E7 24 ; Subtract with carry (long) [$24.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp $42.b,S		; C3 42 ; Compare accumulator (stack relative) $42.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	sta ($81.b,X)		; 81 81 ; Store accumulator ($81.b,X) [Reads: Direct Page, Accumulator, X Index]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $81.b,X		; 15 81 ; OR accumulator with memory $81.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sta ($C3.b,X)		; 81 C3 ; Store accumulator ($C3.b,X) [Reads: Direct Page, Accumulator, X Index]
	.db $42, $E7		; 42 E7 ; Reserved instruction
	bit $18.b		; 24 18 ; Test bits $18.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	bit $FF7E.w,X		; 3C 7E FF ; Test bits $FF7E.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	sbc $183C7E.l,X		; FF 7E 3C 18 ; Subtract with carry (long,X) $183C7E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	ora #$4301.w		; 09 01 43 ; Logical OR #$4301.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $37E007.l		; 0F 07 E0 37 ; OR accumulator with memory (long) $37E007.l [Writes: Accumulator] [Flags: NZ]
	ora $0F1E0F.l,X		; 1F 0F 1E 0F ; Logical OR long $0F1E0F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0E.b]		; 07 0E ; OR accumulator with memory (long) [$0E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	cld		; D8 ; Clear decimal flag [Flags: D]
	ora $EA0F0C.l,X		; 1F 0C 0F EA ; Logical OR long $EA0F0C.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $FBFFF9.l		; EF F9 FF FB ; Subtract with carry (long) $FBFFF9.l [Writes: Accumulator] [Flags: NCVZ]
	sbc $FDFFFE.l,X		; FF FE FF FD ; Subtract with carry (long,X) $FDFFFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F8FFFE.l,X		; FF FE FF F8 ; Subtract with carry (long,X) $F8FFFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($091A.w,X)		; FC 1A 09 ; Jump to subroutine indirect indexed ($091A.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	asl $0E0D.w		; 0E 0D 0E ; Arithmetic shift left $0E0D.w [Flags: NCZ]
	and [$CE.b],Y		; 37 CE ; AND accumulator with memory (long indexed) [$CE.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $EF.b,X		; 16 EF ; Arithmetic shift left $EF.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $50, $EF		; 50 EF ; Branch if overflow clear to $50, $EF [Flow: branch]
	eor $DFE2.w,X		; 5D E2 DF ; Exclusive OR accumulator with memory $DFE2.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$CB.b		; E0 CB ; Compare #$CB.b with X register [Reads: X Index] [Flags: NCZ]
	inc $8D.b,X		; F6 8D ; Increment memory $8D.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	sbc ($87.b)		; F2 87 ; Subtract with carry (indirect) ($87.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	and $7F7F3F.l,X		; 3F 3F 7F 7F ; AND accumulator with memory (long,X) $7F7F3F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	bit $FF.b		; 24 FF ; Test bits $FF.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	sbc ($0F.b,S),Y		; F3 0F ; Subtract with carry (stack relative indirect indexed) ($0F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $0F		; F0 0F ; Branch if equal to $F0, $0F [Flow: branch]
	inc $4701.w,X		; FE 01 47 ; Increment memory $4701.w,X [Reads: X Index] [Flags: NZ]
	sbc $FF2700.l,X		; FF 00 27 FF ; Subtract with carry (long,X) $FF2700.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	trb $9A.b		; 14 9A ; Test and reset bits $9A.b [Reads: Accumulator] [Flags: Z]
	ror $7C95.w,X		; 7E 95 7C ; Rotate right $7C95.w,X [Reads: X Index] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	wai		; CB ; Wait for interrupt
	and $3FD5.w,Y		; 39 D5 3F ; AND accumulator with memory $3FD5.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $B51F.w		; ED 1F B5 ; Subtract $B51F.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	eor $F9EF15.l		; 4F 15 EF F9 ; Exclusive OR accumulator with memory (long) $F9EF15.l [Writes: Accumulator] [Flags: NZ]
	sbc ($E5.b)		; F2 E5 ; Subtract with carry (indirect) ($E5.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cpx $F0.b		; E4 F0 ; Compare $F0.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	jsl $0A43FC.l		; 22 FC 43 0A ; Jump to subroutine long $0A43FC.l [Writes: Stack Pointer] [Flow: call]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $44.b		; 05 44 ; Logical OR $44.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $0F0100.l		; 22 00 01 0F ; Jump to subroutine long $0F0100.l [Writes: Stack Pointer] [Flow: call]
	ora $010722.l		; 0F 22 07 01 ; OR accumulator with memory (long) $010722.l [Writes: Accumulator] [Flags: NZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $7F37E0.l,X		; FF E0 37 7F ; Subtract with carry (long,X) $7F37E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $56EF6F.l,X		; FF 6F EF 56 ; Subtract with carry (long,X) $56EF6F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $EF59.w,X		; FE 59 EF ; Increment memory $EF59.w,X [Reads: X Index] [Flags: NZ]
	eor $47E5.w		; 4D E5 47 ; Exclusive OR $47E5.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc [$57.b],Y		; F7 57 ; Subtract with carry (long indexed) [$57.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $504046.l		; 6F 46 40 50 ; Add with carry (long) $504046.l [Writes: Accumulator] [Flags: NCVZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	sbc $DFE000.l,X		; FF 00 E0 DF ; Subtract with carry (long,X) $DFE000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp.w [$703C]		; DC 3C 70 ; Jump long indirect [$703C] [Flow: jump]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	cpx #$C0.b		; E0 C0 ; Compare #$C0.b with X register [Reads: X Index] [Flags: NCZ]
	cpy #$C2.b		; C0 C2 ; Compare #$C2.b with Y register [Reads: Y Index] [Flags: NCZ]
	cmp $D5.b,S		; C3 D5 ; Compare accumulator (stack relative) $D5.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	cmp [$00.b],Y		; D7 00 ; Compare accumulator (long indexed) [$00.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cpy #$03.b		; C0 03 ; Compare #$03.b with Y register [Reads: Y Index] [Flags: NCZ]
	ora $3C3F1F.l		; 0F 1F 3F 3C ; OR accumulator with memory (long) $3C3F1F.l [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	sta ($82.b)		; 92 82 ; Store accumulator (indirect) ($82.b) [Reads: Direct Page, Accumulator]
	trb $04.b		; 14 04 ; Test and reset bits $04.b [Reads: Accumulator] [Flags: Z]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E3.b		; 00 E3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C1.b		; 00 C1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $80,$00		; 44 00 80 ; Move block positive $80,$00 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora ($7D.b,X)		; 01 7D ; Logical OR ($7D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	and $FF.b		; 25 FF ; Logical AND $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	mvp $DD,$44		; 44 44 DD ; Move block positive $DD,$44 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	mvp $00,$BB		; 44 BB 00 ; Move block positive $00,$BB [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sbc $00C700.l,X		; FF 00 C7 00 ; Subtract with carry (long,X) $00C700.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $24.b,S		; 83 24 ; Store accumulator (stack relative) $24.b,S [Reads: Stack Pointer, Accumulator]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	and $FF.b		; 25 FF ; Logical AND $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx #$2C.b		; E0 2C ; Compare #$2C.b with X register [Reads: X Index] [Flags: NCZ]
	cmp $80.b,S		; C3 80 ; Compare accumulator (stack relative) $80.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	.db $80, $78		; 80 78 ; Branch always to $80, $78 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	ror $8785.w,X		; 7E 85 87 ; Rotate right $8785.w,X [Reads: X Index] [Flags: NCZ]
	.db $62, $03, $F8		; 62 03 F8 ; Push effective relative address $62, $03, $F8 [Writes: Stack Pointer]
	ora ($8D.b,X)		; 01 8D ; Logical OR ($8D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($87.b,X)		; 01 87 ; Logical OR ($87.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jsr ($FEFE.w,X)		; FC FE FE ; Jump to subroutine indirect indexed ($FEFE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $4D969B.l,X		; FF 9B 96 4D ; Subtract with carry (long,X) $4D969B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc [$04.b]		; E7 04 ; Subtract with carry (long) [$04.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($02.b,S),Y		; F3 02 ; Subtract with carry (stack relative indirect indexed) ($02.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	lda $1C01.w,Y		; B9 01 1C ; Load $1C01.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $B0, $F8		; B0 F8 ; Branch if carry set to $B0, $F8 [Flow: branch]
	jsr ($22FE.w,X)		; FC FE 22 ; Jump to subroutine indirect indexed ($22FE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $04260A.l,X		; FF 0A 26 04 ; Subtract with carry (long,X) $04260A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($12.b,S),Y		; 33 12 ; AND accumulator (stack relative indirect indexed) ($12.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0C09.w,Y		; 19 09 0C ; OR accumulator with memory $0C09.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tsb $06.b		; 04 06 ; Test and set bits $06.b [Reads: Accumulator] [Flags: Z]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	tsb $18.b		; 04 18 ; Test and set bits $18.b [Reads: Accumulator] [Flags: Z]
	tsb $0306.w		; 0C 06 03 ; Test and set bits $0306.w [Reads: Accumulator] [Flags: Z]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $20.b		; 64 20 ; Store zero to $20.b
	cpy $9848.w		; CC 48 98 ; Compare $9848.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $90, $30		; 90 30 ; Branch if carry clear to $90, $30 [Flow: branch]
	jsr $4060.w		; 20 60 40 ; Jump to subroutine at $4060.w [Writes: Stack Pointer] [Flow: call]
	cpy #$24.b		; C0 24 ; Compare #$24.b with Y register [Reads: Y Index] [Flags: NCZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $30, $60		; 30 60 ; Branch if minus to $30, $60 [Flow: branch]
	cpy #$80.b		; C0 80 ; Compare #$80.b with Y register [Reads: Y Index] [Flags: NCZ]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $81,$00		; 44 00 81 ; Move block positive $81,$00 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($7E.b,X)		; 01 7E ; Logical OR ($7E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ror $0022.w,X		; 7E 22 00 ; Rotate right $0022.w,X [Reads: X Index] [Flags: NCZ]
	ora $8104C3.l		; 0F C3 04 81 ; OR accumulator with memory (long) $8104C3.l [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $F122.w,Y		; 99 22 F1 ; Store accumulator to $F122.w,Y [Reads: Y Index, Accumulator]
	asl $E3.b		; 06 E3 ; Arithmetic shift left $E3.b [Reads: Direct Page] [Flags: NCZ]
	tsb $08E7.w		; 0C E7 08 ; Test and set bits $08E7.w [Reads: Accumulator] [Flags: Z]
	sbc $08E700.l,X		; FF 00 E7 08 ; Subtract with carry (long,X) $08E700.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and [$FF.b]		; 27 FF ; AND accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$15.b],Y		; 17 15 ; OR accumulator with memory (long indexed) [$15.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $120F10.l		; 0F 10 0F 12 ; OR accumulator with memory (long) $120F10.l [Writes: Accumulator] [Flags: NZ]
	ora $371F32.l		; 0F 32 1F 37 ; OR accumulator with memory (long) $371F32.l [Writes: Accumulator] [Flags: NZ]
	ora $3C1F3E.l,X		; 1F 3E 1F 3C ; Logical OR long $3C1F3E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $101F20.l,X		; 1F 20 1F 10 ; Logical OR long $101F20.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $12		; 10 12 ; Branch if plus to $10, $12 [Flow: branch]
	and ($36.b)		; 32 36 ; AND accumulator with memory (indirect) ($36.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $3F33.w,X		; 3D 33 3F ; AND accumulator with memory $3F33.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $3F.b,S		; 43 3F ; Exclusive OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $FFC402.l,X		; FF 02 C4 FF ; Subtract with carry (long,X) $FFC402.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	stx $43.b		; 86 43 ; Store X register to $43.b [Reads: X Index]
	sbc $FE0803.l,X		; FF 03 08 FE ; Subtract with carry (long,X) $FE0803.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$F8.b]		; 07 F8 ; OR accumulator with memory (long) [$F8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $1B17F1.l		; 0F F1 17 1B ; OR accumulator with memory (long) $1B17F1.l [Writes: Accumulator] [Flags: NZ]
	and $237E.w,X		; 3D 7E 23 ; AND accumulator with memory $237E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $F8870E.l,X		; FF 0E 87 F8 ; Subtract with carry (long,X) $F8870E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $CC3FF0.l		; 8F F0 3F CC ; Store accumulator (long) $CC3FF0.l [Reads: Accumulator]
	adc $7FCFBE.l,X		; 7F BE CF 7F ; Add long $7FCFBE.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp [$FF.b]		; C7 FF ; Compare accumulator (long) [$FF.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cpx #$FF.b		; E0 FF ; Compare #$FF.b with X register [Reads: X Index] [Flags: NCZ]
	.db $F0, $23		; F0 23 ; Branch if equal to $F0, $23 [Flow: branch]
	sbc $8FDF04.l,X		; FF 04 DF 8F ; Subtract with carry (long,X) $8FDF04.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta [$C3.b]		; 87 C3 ; Store accumulator (long) [$C3.b] [Reads: Direct Page, Accumulator]
	sbc [$49.b]		; E7 49 ; Subtract with carry (long) [$49.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FC0500.l,X		; FF 00 05 FC ; Subtract with carry (long,X) $FC0500.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $70.b,S		; 83 70 ; Store accumulator (stack relative) $70.b,S [Reads: Stack Pointer, Accumulator]
	sta $24DF38.l		; 8F 38 DF 24 ; Store accumulator (long) $24DF38.l [Reads: Accumulator]
	sbc $F0FC02.l,X		; FF 02 FC F0 ; Subtract with carry (long,X) $F0FC02.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	eor $55.b		; 45 55 ; Exclusive OR $55.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $6F9505.l		; EF 05 95 6F ; Subtract with carry (long) $6F9505.l [Writes: Accumulator] [Flags: NCVZ]
	ora $EF.b,X		; 15 EF ; OR accumulator with memory $EF.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $43F7.w		; 0C F7 43 ; Test and set bits $43F7.w [Reads: Accumulator] [Flags: Z]
	tsb $FB.b		; 04 FB ; Test and set bits $FB.b [Reads: Accumulator] [Flags: Z]
	and $FC.b,S		; 23 FC ; AND accumulator with stack relative $FC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0C1C.w		; 0D 1C 0C ; Logical OR $0C1C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $0C.b		; 04 0C ; Test and set bits $0C.b [Reads: Accumulator] [Flags: Z]
	.db $80, $7F		; 80 7F ; Branch always to $80, $7F [Flow: branch]
	lda ($7F.b)		; B2 7F ; Load accumulator (indirect) ($7F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda ($7E.b,X)		; A1 7E ; Load accumulator ($7E.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sta $7C.b,S		; 83 7C ; Store accumulator (stack relative) $7C.b,S [Reads: Stack Pointer, Accumulator]
	stx $79.b		; 86 79 ; Store X register to $79.b [Reads: X Index]
	eor $8C.b,S		; 43 8C ; Exclusive OR accumulator with stack relative $8C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc ($04.b,S),Y		; 73 04 ; Add with carry (stack relative indirect indexed) ($04.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc [$F0.b]		; 67 F0 ; Add with carry (long) [$F0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	sbc $FF24.w,X		; FD 24 FF ; Subtract with carry $FF24.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $E7.b,S		; 03 E7 ; OR accumulator with stack relative $E7.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor [$E5.b],Y		; 57 E5 ; Exclusive OR accumulator with memory (long indexed) [$E5.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor [$43.b],Y		; 57 43 ; Exclusive OR accumulator with memory (long indexed) [$43.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $0B5F.w		; ED 5F 0B ; Subtract $0B5F.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sbc $F54F.w,X		; FD 4F F5 ; Subtract with carry $F54F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $E447F8.l		; 4F F8 47 E4 ; Exclusive OR accumulator with memory (long) $E447F8.l [Writes: Accumulator] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	jsl $3DE060.l		; 22 60 E0 3D ; Jump to subroutine long $3DE060.l [Writes: Stack Pointer] [Flow: call]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cmp ($D6.b)		; D2 D6 ; Compare accumulator (indirect) ($D6.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sbc ($F7.b,S),Y		; F3 F7 ; Subtract with carry (stack relative indirect indexed) ($F7.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F7.b		; E5 F7 ; Subtract $F7.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	nop		; EA ; No operation
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	.db $80, $FC		; 80 FC ; Branch always to $80, $FC [Flow: branch]
	eor $C7.b		; 45 C7 ; Exclusive OR $C7.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	sta $ED.b,S		; 83 ED ; Store accumulator (stack relative) $ED.b,S [Reads: Stack Pointer, Accumulator]
	lda #$0829.w		; A9 29 08 ; Load #$0829.w into accumulator [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	sec		; 38 ; Set carry flag [Flags: C]
	mvp $AE,$12		; 44 12 AE ; Move block positive $AE,$12 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cpx $E3.b		; E4 E3 ; Compare $E3.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc $69.b,S		; E3 69 ; Subtract stack-relative $69.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	cmp ($44.b),Y		; D1 44 ; Compare accumulator ($44.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	ldy #$02.b		; A0 02 ; Load #$02.b into Y register [Writes: Y Index] [Flags: NZ]
	cmp $1FAF00.l,X		; DF 00 AF 1F ; Compare accumulator (long,X) $1FAF00.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	lda $63.b,S		; A3 63 ; Load accumulator (stack relative) $63.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($15.b,S),Y		; 13 15 ; OR accumulator (stack relative indirect indexed) ($15.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $3B.b,X		; 16 3B ; Arithmetic shift left $3B.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	adc $4060.w,X		; 7D 60 40 ; Add $4060.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	trb $C6BA.w		; 1C BA C6 ; Test and reset bits $C6BA.w [Reads: Accumulator] [Flags: Z]
	eor $7C.b		; 45 7C ; Exclusive OR $7C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	and $92D6.w,Y		; 39 D6 92 ; AND accumulator with memory $92D6.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $FF44.w		; ED 44 FF ; Subtract $FF44.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	mvp $22,$55		; 44 55 22 ; Move block positive $22,$55 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	eor $04.b		; 45 04 ; Exclusive OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	dec $6D.b		; C6 6D ; Decrement $6D.b [Reads: Direct Page] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	jsl $D312BA.l		; 22 BA 12 D3 ; Jump to subroutine long $D312BA.l [Writes: Stack Pointer] [Flow: call]
	cmp $D9.b,S		; C3 D9 ; Compare accumulator (stack relative) $D9.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	cmp ($B5.b,X)		; C1 B5 ; Compare accumulator ($B5.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	sta ($63.b,X)		; 81 63 ; Store accumulator ($63.b,X) [Reads: Direct Page, Accumulator, X Index]
	brk $C3.b		; 00 C3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($87.b,X)		; 01 87 ; Logical OR ($87.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $FF.b,S		; 03 FF ; OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $3C.b		; 04 3C ; Test and set bits $3C.b [Reads: Accumulator] [Flags: Z]
	rol $227E.w,X		; 3E 7E 22 ; Rotate left $227E.w,X [Reads: X Index] [Flags: NCZ]
	inc $31E0.w,X		; FE E0 31 ; Increment memory $31E0.w,X [Reads: X Index] [Flags: NZ]
	jsr ($C4F8.w,X)		; FC F8 C4 ; Jump to subroutine indirect indexed ($C4F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ror $A2.b		; 66 A2 ; Rotate right $A2.b [Reads: Direct Page] [Flags: NCZ]
	lda ($70.b,S),Y		; B3 70 ; Load accumulator (stack relative indirect indexed) ($70.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $2DA8.w,Y		; 39 A8 2D ; AND accumulator with memory $2DA8.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $50, $45		; 50 45 ; Branch if overflow clear to $50, $45 [Flow: branch]
	cpx $F425.w		; EC 25 F4 ; Compare $F425.w with X register [Reads: X Index] [Flags: NCZ]
	cmp $B8.b,X		; D5 B8 ; Compare accumulator $B8.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	lda $4C99.w		; AD 99 4C ; Load $4C99.w into accumulator [Writes: Accumulator] [Flags: NZ]
	dec $D2.b		; C6 D2 ; Decrement $D2.b [Reads: Direct Page] [Flags: NZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $42, $BC		; 42 BC ; Reserved instruction
	sbc $7D7C.w,X		; FD 7C 7D ; Subtract with carry $7D7C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	adc $79F8.w,Y		; 79 F8 79 ; Add $79F8.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc ($3B.b,X)		; 61 3B ; Add with carry ($3B.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($BF.b,X)		; 01 BF ; Logical OR ($BF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc ($8E.b,X)		; E1 8E ; Subtract with carry ($8E.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sep #$02		; E2 02 ; Set processor status bits #$02 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	.db $82, $86, $86		; 82 86 86 ; Branch always long to $82, $86, $86 [Flow: branch]
	stz $1EFE.w,X		; 9E FE 1E ; Store zero to $1EFE.w,X [Reads: X Index]
	ora $0025.w,X		; 1D 25 00 ; OR accumulator with memory $0025.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$0001.w		; 09 01 00 ; Logical OR #$0001.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: NCZ]
	tsb $1E07.w		; 0C 07 1E ; Test and set bits $1E07.w [Reads: Accumulator] [Flags: Z]
	ora $190022.l		; 0F 22 00 19 ; OR accumulator with memory (long) $190022.l [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $0C.b		; 04 0C ; Test and set bits $0C.b [Reads: Accumulator] [Flags: Z]
	asl $0000.w,X		; 1E 00 00 ; Arithmetic shift left $0000.w,X [Reads: X Index] [Flags: NCZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $F200.w,Y		; 79 00 F2 ; Add $F200.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($AF.b)		; 72 AF ; Add with carry (indirect) ($AF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $24FF17.l		; EF 17 FF 24 ; Subtract with carry (long) $24FF17.l [Writes: Accumulator] [Flags: NCVZ]
	sbc $00FF01.l,X		; FF 01 FF 00 ; Subtract with carry (long,X) $00FF01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$7E.b]		; 07 7E ; OR accumulator with memory (long) [$7E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $2210.w		; 8D 10 22 ; Store accumulator to $2210.w [Reads: Accumulator]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp [$01.b]		; C7 01 ; Compare accumulator (long) [$01.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ora [$75.b]		; 07 75 ; OR accumulator with memory (long) [$75.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $C997A9.l		; 0F A9 97 C9 ; OR accumulator with memory (long) $C997A9.l [Writes: Accumulator] [Flags: NZ]
	cmp [$6A.b],Y		; D7 6A ; Compare accumulator (long indexed) [$6A.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	inc $8A.b,X		; F6 8A ; Increment memory $8A.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	inc $01.b,X		; F6 01 ; Increment memory $01.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	dec $3C.b		; C6 3C ; Decrement $3C.b [Reads: Direct Page] [Flags: NZ]
	stz $3C5C.w		; 9C 5C 3C ; Store zero to $3C5C.w
	ora $437D.w,X		; 1D 7D 43 ; OR accumulator with memory $437D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsr $051F.w		; 20 1F 05 ; Jump to subroutine at $051F.w [Writes: Stack Pointer] [Flow: call]
	and ($0E.b),Y		; 31 0E ; AND accumulator with memory ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($0D.b)		; 12 0D ; OR accumulator with memory (indirect) ($0D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($0D.b,S),Y		; 13 0D ; OR accumulator (stack relative indirect indexed) ($0D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $17.b,S		; 43 17 ; Exclusive OR accumulator with stack relative $17.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora ($15.b,X)		; 01 15 ; Logical OR ($15.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	jsl $1E003F.l		; 22 3F 00 1E ; Jump to subroutine long $1E003F.l [Writes: Stack Pointer] [Flow: call]
	jsl $1D171F.l		; 22 1F 17 1D ; Jump to subroutine long $1D171F.l [Writes: Stack Pointer] [Flow: call]
	and $9B77C1.l,X		; 3F C1 77 9B ; AND accumulator with memory (long,X) $9B77C1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc [$7B.b],Y		; F7 7B ; Subtract with carry (long indexed) [$7B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	wai		; CB ; Wait for interrupt
	sbc [$0B.b],Y		; F7 0B ; Subtract with carry (long indexed) [$0B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$8D.b],Y		; F7 8D ; Subtract with carry (long indexed) [$8D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($86.b,S),Y		; F3 86 ; Subtract with carry (stack relative indirect indexed) ($86.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F887.w,Y		; F9 87 F8 ; Subtract with carry $F887.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $0F87E7.l,X		; FF E7 87 0F ; Subtract with carry (long,X) $0F87E7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $44FFBF.l		; 0F BF FF 44 ; OR accumulator with memory (long) $44FFBF.l [Writes: Accumulator] [Flags: NZ]
	sbc $C00BE0.l,X		; FF E0 0B C0 ; Subtract with carry (long,X) $C00BE0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $82FEC9.l,X		; FF C9 FE 82 ; Subtract with carry (long,X) $82FEC9.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FB84.w,X		; FD 84 FB ; Subtract with carry $FB84.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc [$D1.b],Y		; F7 D1 ; Subtract with carry (long indexed) [$D1.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and $00FF23.l		; 2F 23 FF 00 ; AND accumulator with memory (long) $00FF23.l [Writes: Accumulator] [Flags: NZ]
	sbc [$22.b],Y		; F7 22 ; Subtract with carry (long indexed) [$22.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $3C14.w,X		; FD 14 3C ; Subtract with carry $3C14.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $7CBF7E.l,X		; DF 7E BF 7C ; Compare accumulator (long,X) $7CBF7E.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	lda $783FF8.l,X		; BF F8 3F 78 ; Load long $783FF8.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda $D0DF39.l,X		; BF 39 DF D0 ; Load long $D0DF39.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $FCF7E8.l		; EF E8 F7 FC ; Subtract with carry (long) $FCF7E8.l [Writes: Accumulator] [Flags: NCVZ]
	inc $FBFD.w,X		; FE FD FB ; Increment memory $FBFD.w,X [Reads: X Index] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	jsl $0643FF.l		; 22 FF 43 06 ; Jump to subroutine long $0643FF.l [Writes: Stack Pointer] [Flow: call]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	eor $8B.b,S		; 43 8B ; Exclusive OR accumulator with stack relative $8B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc [$07.b],Y		; F7 07 ; Subtract with carry (long indexed) [$07.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($EF.b,S),Y		; 13 EF ; OR accumulator (stack relative indirect indexed) ($EF.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($EF.b),Y		; 11 EF ; OR accumulator with memory ($EF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($DF.b,X)		; 21 DF ; Logical AND ($DF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $25FE.w,X		; 1E FE 25 ; Arithmetic shift left $25FE.w,X [Reads: X Index] [Flags: NCZ]
	sbc $8F7019.l,X		; FF 19 70 8F ; Subtract with carry (long,X) $8F7019.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	ora [$84.b],Y		; 17 84 ; OR accumulator with memory (long indexed) [$84.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $62, $FD, $79		; 62 FD 79 ; Push effective relative address $62, $FD, $79 [Writes: Stack Pointer]
	inc $FE3D.w,X		; FE 3D FE ; Increment memory $FE3D.w,X [Reads: X Index] [Flags: NZ]
	trb $10FF.w		; 1C FF 10 ; Test and reset bits $10FF.w [Reads: Accumulator] [Flags: Z]
	sbc $BFFF7F.l,X		; FF 7F FF BF ; Subtract with carry (long,X) $BFFF7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $5F3F7F.l,X		; 7F 7F 3F 5F ; Add long $5F3F7F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $4358EF.l,X		; FF EF 58 43 ; Subtract with carry (long,X) $4358EF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx $E05A.w		; EC 5A E0 ; Compare $E05A.w with X register [Reads: X Index] [Flags: NCZ]
	rol $EB.b		; 26 EB ; Rotate left $EB.b [Reads: Direct Page] [Flags: NCZ]
	eor $5DEF.w,X		; 5D EF 5D ; Exclusive OR accumulator with memory $5DEF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc [$4E.b],Y		; F7 4E ; Subtract with carry (long indexed) [$4E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	eor [$FD.b],Y		; 57 FD ; Exclusive OR accumulator with memory (long indexed) [$FD.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	eor ($41.b,X)		; 41 41 ; Exclusive OR accumulator with memory ($41.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	inc $5F3C.w,X		; FE 3C 5F ; Increment memory $5F3C.w,X [Reads: X Index] [Flags: NZ]
	and $82BE.w,X		; 3D BE 82 ; AND accumulator with memory $82BE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $B0504C.l		; CF 4C 50 B0 ; Compare accumulator (long) $B0504C.l [Reads: Accumulator] [Flags: NCZ]
	lda $67FBC0.l,X		; BF C0 FB 67 ; Load long $67FBC0.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $01B7.w,Y		; 59 B7 01 ; Exclusive OR accumulator with memory $01B7.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $80, $41		; 80 41 ; Branch always to $80, $41 [Flow: branch]
	.db $30, $0F		; 30 0F ; Branch if minus to $30, $0F [Flow: branch]
	jsl $0C1200.l		; 22 00 12 0C ; Jump to subroutine long $0C1200.l [Writes: Stack Pointer] [Flow: call]
	and $29.b		; 25 29 ; Logical AND $29.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $2B.b,S		; 23 2B ; AND accumulator with stack relative $2B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $86.b		; 26 86 ; Rotate left $86.b [Reads: Direct Page] [Flags: NCZ]
	tsb $0CE6.w		; 0C E6 0C ; Test and set bits $0CE6.w [Reads: Accumulator] [Flags: Z]
	rol $0C.b,X		; 36 0C ; Rotate left $0C.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	rol $5E34.w		; 2E 34 5E ; Rotate left $5E34.w [Flags: NCZ]
	stz $D2.b,X		; 74 D2 ; Store zero to $D2.b,X [Reads: X Index]
	pei ($D1.b)		; D4 D1 ; Push effective indirect address ($D1.b) [Reads: Direct Page] [Writes: Stack Pointer]
	jsl $C309F3.l		; 22 F3 09 C3 ; Jump to subroutine long $C309F3.l [Writes: Stack Pointer] [Flow: call]
	sta $C6.b,S		; 83 C6 ; Store accumulator (stack relative) $C6.b,S [Reads: Stack Pointer, Accumulator]
	sta $BB.b,S		; 83 BB ; Store accumulator (stack relative) $BB.b,S [Reads: Stack Pointer, Accumulator]
	ora ($45.b,X)		; 01 45 ; Logical OR ($45.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sec		; 38 ; Set carry flag [Flags: C]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	jmp ($FE45.w,X)		; 7C 45 FE ; Jump indirect indexed to ($FE45.w,X) [Reads: X Index] [Flow: jump]
	mvp $7D,$04		; 44 04 7D ; Move block positive $7D,$04 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	lda $7C.b,S		; A3 7C ; Load accumulator (stack relative) $7C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $83.b		; C6 83 ; Decrement $83.b [Reads: Direct Page] [Flags: NZ]
	jsl $190701.l		; 22 01 07 19 ; Jump to subroutine long $190701.l [Writes: Stack Pointer] [Flow: call]
	clc		; 18 ; Clear carry flag [Flags: C]
	ror $67FA.w		; 6E FA 67 ; Rotate right $67FA.w [Flags: NCZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc [$76.b],Y		; 77 76 ; Add with carry (long indexed) [$76.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $77.b,S		; 43 77 ; Exclusive OR accumulator with stack relative $77.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc ($E0.b)		; 72 E0 ; Add with carry (indirect) ($E0.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and $3B.b		; 25 3B ; Logical AND $3B.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $1C1D.w,Y		; 39 1D 1C ; AND accumulator with memory $1C1D.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $050E.w		; 0E 0E 05 ; Arithmetic shift left $050E.w [Flags: NCZ]
	sta $89.b,X		; 95 89 ; Store accumulator to $89.b,X [Reads: Accumulator, X Index]
	sta $C68D.w		; 8D 8D C6 ; Store accumulator to $C68D.w [Reads: Accumulator]
	sbc $F1.b,S		; E3 F1 ; Subtract stack-relative $F1.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	eor $7C.b		; 45 7C ; Exclusive OR $7C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	mvn $8A,$FC		; 54 FC 8A ; Move block negative $8A,$FC [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	inc $67C5.w		; EE C5 67 ; Increment $67C5.w [Flags: NZ]
.ACCU 16
.INDEX 16
	rep #$73		; C2 73
	cmp ($69.b,X)		; C1 69 ; Compare accumulator ($69.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	jmp ($6EC8.w)		; 6C C8 6E ; Jump indirect to ($6EC8.w) [Flow: jump]
	.db $82, $03, $11		; 82 03 11 ; Branch always long to $82, $03, $11 [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sty $9396.w		; 8C 96 93 ; Store Y register to $9396.w [Reads: Y Index]
	sta ($83.b),Y		; 91 83 ; Store accumulator ($83.b),Y [Reads: Direct Page, Y Index, Accumulator]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $43.b,S		; 03 43 ; OR accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $1307.w		; 0C 07 13 ; Test and set bits $1307.w [Reads: Accumulator] [Flags: Z]
	trb $1F0F.w		; 1C 0F 1F ; Test and reset bits $1F0F.w [Reads: Accumulator] [Flags: Z]
	tsb $033C.w		; 0C 3C 03 ; Test and set bits $033C.w [Reads: Accumulator] [Flags: Z]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $1F7E3C.l,X		; 1F 3C 7E 1F ; Logical OR long $1F7E3C.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $3FDF3F.l,X		; FF 3F DF 3F ; Subtract with carry (long,X) $3FDF3F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $6F.b,S		; 43 6F ; Exclusive OR accumulator with stack relative $6F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $CF3308.l,X		; 9F 08 33 CF ; Store accumulator (long,X) $CF3308.l,X [Reads: Accumulator, X Index]
	stz $5F63.w		; 9C 63 5F ; Store zero to $5F63.w
	ldy $7E.b		; A4 7E ; Load $7E.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	sbc $7F22FF.l,X		; FF FF 22 7F ; Subtract with carry (long,X) $7F22FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $FF.b,X		; 15 FF ; OR accumulator with memory $FF.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc $80FF00.l,X		; 7F 00 FF 80 ; Add long $80FF00.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $D4FFC0.l,X		; FF C0 FF D4 ; Subtract with carry (long,X) $D4FFC0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $80FFC8.l,X		; FF C8 FF 80 ; Subtract with carry (long,X) $80FFC8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $0FFE81.l,X		; FF 81 FE 0F ; Subtract with carry (long,X) $0FFE81.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($01.b),Y		; F1 01 ; Subtract with carry ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta [$DF.b]		; 87 DF ; Store accumulator (long) [$DF.b] [Reads: Direct Page, Accumulator]
	sbc $03BB83.l,X		; FF 83 BB 03 ; Subtract with carry (long,X) $03BB83.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $7E		; 10 7E ; Branch if plus to $10, $7E [Flow: branch]
	sta ($E7.b,X)		; 81 E7 ; Store accumulator ($E7.b,X) [Reads: Direct Page, Accumulator, X Index]
	ror $7E91.w,X		; 7E 91 7E ; Rotate right $7E91.w,X [Reads: X Index] [Flags: NCZ]
	lda ($7E.b),Y		; B1 7E ; Load accumulator ($7E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $7E.b		; 85 7E ; Store accumulator to $7E.b [Reads: Accumulator]
	sta ($7E.b,S),Y		; 93 7E ; Store accumulator (stack relative indirect indexed) ($7E.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	cmp $7E.b,S		; C3 7E ; Compare accumulator (stack relative) $7E.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	ror $0081.w,X		; 7E 81 00 ; Rotate right $0081.w,X [Reads: X Index] [Flags: NCZ]
	and $7E.b		; 25 7E ; Logical AND $7E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $0F.b,S		; 43 0F ; Exclusive OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$0A.b]		; 07 0A ; OR accumulator with memory (long) [$0A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $1E0F.w,X		; 1E 0F 1E ; Arithmetic shift left $1E0F.w,X [Reads: X Index] [Flags: NCZ]
	ora [$3C.b]		; 07 3C ; OR accumulator with memory (long) [$3C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $3F.b,S		; 03 3F ; OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $15.b		; 00 15 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $2212.w		; 0E 12 22 ; Arithmetic shift left $2212.w [Flags: NCZ]
	ora $1F1F15.l		; 0F 15 1F 1F ; OR accumulator with memory (long) $1F1F15.l [Writes: Accumulator] [Flags: NZ]
	and $1B173F.l,X		; 3F 3F 17 1B ; AND accumulator with memory (long,X) $1B173F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$F8.b]		; 07 F8 ; OR accumulator with memory (long) [$F8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $E01FF0.l		; 0F F0 1F E0 ; OR accumulator with memory (long) $E01FF0.l [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	cmp [$F3.b]		; C7 F3 ; Compare accumulator (long) [$F3.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora $9A3FF9.l,X		; 1F F9 3F 9A ; Logical OR long $9A3FF9.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $237F88.l,X		; 7F 88 7F 23 ; Add long $237F88.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F9F313.l,X		; FF 13 F3 F9 ; Subtract with carry (long,X) $F9F313.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sbc ($0F.b,S),Y		; F3 0F ; Subtract with carry (stack relative indirect indexed) ($0F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$0F.b],Y		; F7 0F ; Subtract with carry (long indexed) [$0F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $5F.b		; A5 5F ; Load $5F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $2EDF.w		; 2D DF 2E ; Logical AND $2EDF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp $ECDFEE.l,X		; DF EE DF EC ; Compare accumulator (long,X) $ECDFEE.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	cmp $239F68.l,X		; DF 68 9F 23 ; Compare accumulator (long,X) $239F68.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	sbc $FE06.w,X		; FD 06 FE ; Subtract with carry $FE06.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $7BFD.w,X		; FE FD 7B ; Increment memory $7BFD.w,X [Reads: X Index] [Flags: NZ]
	sbc [$F8.b],Y		; F7 F8 ; Subtract with carry (long indexed) [$F8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsl $DE08FF.l		; 22 FF 08 DE ; Jump to subroutine long $DE08FF.l [Writes: Stack Pointer] [Flow: call]
	sbc $02FFB9.l,X		; FF B9 FF 02 ; Subtract with carry (long,X) $02FFB9.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	tsb $32FF.w		; 0C FF 32 ; Test and set bits $32FF.w [Reads: Accumulator] [Flags: Z]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $99DE.w		; 0C DE 99 ; Test and set bits $99DE.w [Reads: Accumulator] [Flags: Z]
	ora [$FD.b]		; 07 FD ; OR accumulator with memory (long) [$FD.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $601FE1.l,X		; FF E1 1F 60 ; Subtract with carry (long,X) $601FE1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $23DF22.l,X		; 9F 22 DF 23 ; Store accumulator (long,X) $23DF22.l,X [Reads: Accumulator, X Index]
	cmp $03CA83.l,X		; DF 83 CA 03 ; Compare accumulator (long,X) $03CA83.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	asl $10.b		; 06 10 ; Arithmetic shift left $10.b [Reads: Direct Page] [Flags: NCZ]
	sbc $FFE718.l		; EF 18 E7 FF ; Subtract with carry (long) $FFE718.l [Writes: Accumulator] [Flags: NCVZ]
	sbc $FF247F.l,X		; FF 7F 24 FF ; Subtract with carry (long,X) $FF247F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $A1		; 10 A1 ; Branch if plus to $10, $A1 [Flow: branch]
	sbc $10FFC1.l,X		; FF C1 FF 10 ; Subtract with carry (long,X) $10FFC1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFC33.l,X		; FF 33 FC FF ; Subtract with carry (long,X) $FFFC33.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($FA.b,X)		; 01 FA ; Logical OR ($FA.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $3EED.w,X		; 1D ED 3E ; OR accumulator with memory $3EED.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda $FF23BF.l,X		; BF BF 23 FF ; Load long $FF23BF.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $EF.b,X		; 16 EF ; Arithmetic shift left $EF.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cmp $5DEFCF.l		; CF CF EF 5D ; Compare accumulator (long) $5DEFCF.l [Reads: Accumulator] [Flags: NCZ]
	sbc [$4D.b],Y		; F7 4D ; Subtract with carry (long indexed) [$4D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	adc $FF.b		; 65 FF ; Add $FF.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $FF		; 70 FF ; Branch if overflow set to $70, $FF [Flow: branch]
	jmp ($7FFF.w,X)		; 7C FF 7F ; Jump indirect indexed to ($7FFF.w,X) [Reads: X Index] [Flow: jump]
	.db $80, $7F		; 80 7F ; Branch always to $80, $7F [Flow: branch]
	sbc $604000.l,X		; FF 00 40 60 ; Subtract with carry (long,X) $604000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $78		; 70 78 ; Branch if overflow set to $70, $78 [Flow: branch]
	jsl $32E07F.l		; 22 7F E0 32 ; Jump to subroutine long $32E07F.l [Writes: Stack Pointer] [Flow: call]
	brk $EA.b		; 00 EA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp [$3B.b],Y		; D7 3B ; Compare accumulator (long indexed) [$3B.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	and [$D9.b]		; 27 D9 ; AND accumulator with memory (long) [$D9.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp [$7A.b],Y		; D7 7A ; Compare accumulator (long indexed) [$7A.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	sbc [$FB.b],Y		; F7 FB ; Subtract with carry (long indexed) [$FB.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$F8.b]		; 07 F8 ; OR accumulator with memory (long) [$F8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $04.b,X		; F6 04 ; Increment memory $04.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc $C00000.l,X		; FF 00 00 C0 ; Subtract with carry (long,X) $C00000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr $0000.w		; 20 00 00 ; Jump to subroutine at $0000.w [Writes: Stack Pointer] [Flow: call]
	sbc ($F8.b),Y		; F1 F8 ; Subtract with carry ($F8.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $37.b		; 00 37 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $D94B.w		; ED 4B D9 ; Subtract $D94B.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta ($B3.b),Y		; 91 B3 ; Store accumulator ($B3.b),Y [Reads: Direct Page, Y Index, Accumulator]
	jsr $4064.w		; 20 64 40 ; Jump to subroutine at $4064.w [Writes: Stack Pointer] [Flow: call]
	eor #$1301.w		; 49 01 13 ; Exclusive OR #$1301.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cop $26.b		; 02 26 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $4C.b		; 24 4C ; Test bits $4C.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ldx $EC.b,Y		; B6 EC ; Load X register $EC.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	cmp $00FF.w,Y		; D9 FF 00 ; Compare accumulator $00FF.w,Y [Reads: Y Index] [Flags: NCZ]
	eor $FE.b,S		; 43 FE ; Exclusive OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor [$09.b],Y		; 57 09 ; Exclusive OR accumulator with memory (long indexed) [$09.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr $FF.b,X		; 56 FF ; Logical shift right $FF.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cop $AB.b		; 02 AB ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $A9		; 80 A9 ; Branch always to $80, $A9 [Flow: branch]
	and #$7C6D.w		; 29 6D 7C ; Logical AND #$7C6D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	dec $23.b		; C6 23 ; Decrement $23.b [Reads: Direct Page] [Flags: NZ]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($54.b,S),Y		; 33 54 ; AND accumulator (stack relative indirect indexed) ($54.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lsr $92.b,X		; 56 92 ; Logical shift right $92.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	and $F60A.w,Y		; 39 0A F6 ; AND accumulator with memory $F60A.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	pea $EC14.w		; F4 14 EC ; Push absolute address $EC14.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	lsr $C2BE.w		; 4E BE C2 ; Logical shift right $C2BE.w [Flags: NCZ]
	rol $3FD3.w,X		; 3E D3 3F ; Rotate left $3FD3.w,X [Reads: X Index] [Flags: NCZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	rol $FFFD.w,X		; 3E FD FF ; Rotate left $FFFD.w,X [Reads: X Index] [Flags: NCZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc $E1.b,X		; F5 E1 ; Subtract $E1.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($F0.b,X)		; E1 F0 ; Subtract with carry ($F0.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $03FC.w,Y		; F9 FC 03 ; Subtract with carry $03FC.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx $AF61.w		; AE 61 AF ; Load $AF61.w into X register [Writes: X Index] [Flags: NZ]
	stz $41.b		; 64 41 ; Store zero to $41.b
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	bit #$919A.w		; 89 9A 91 ; Test bits #$919A.w with accumulator [Reads: Accumulator] [Flags: Z]
	lda ($21.b)		; B2 21 ; Load accumulator (indirect) ($21.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $A1.b		; E6 A1 ; Increment $A1.b [Reads: Direct Page] [Flags: NZ]
	inc $1000.w		; EE 00 10 ; Increment $1000.w [Flags: NZ]
	.db $10, $34		; 10 34 ; Branch if plus to $10, $34 [Flow: branch]
	stz $4C.b		; 64 4C ; Store zero to $4C.b
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $10, $FF		; 10 FF ; Branch if plus to $10, $FF [Flow: branch]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $30, $D6		; 30 D6 ; Branch if minus to $30, $D6 [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $10, $E8		; 10 E8 ; Branch if plus to $10, $E8 [Flow: branch]
	trb $FAE4.w		; 1C E4 FA ; Test and reset bits $FAE4.w [Reads: Accumulator] [Flags: Z]
	asl $F7.b		; 06 F7 ; Arithmetic shift left $F7.b [Reads: Direct Page] [Flags: NCZ]
	mvp $05,$FB		; 44 FB 05 ; Move block positive $05,$FB [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	tsb $09.b		; 04 09 ; Test and set bits $09.b [Reads: Accumulator] [Flags: Z]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $4C4300.l		; 22 00 43 4C ; Jump to subroutine long $4C4300.l [Writes: Stack Pointer] [Flow: call]
	lda [$0B.b],Y		; B7 0B ; Load accumulator (long indexed) [$0B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpy $FC37.w		; CC 37 FC ; Compare $FC37.w with Y register [Reads: Y Index] [Flags: NCZ]
	sta [$58.b]		; 87 58 ; Store accumulator (long) [$58.b] [Reads: Direct Page, Accumulator]
	adc [$17.b]		; 67 17 ; Add with carry (long) [$17.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	jmp $07CF.w		; 4C CF 07 ; Jump to $07CF.w [Flow: jump]
	ora [$23.b]		; 07 23 ; OR accumulator with memory (long) [$23.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $60		; 80 60 ; Branch always to $80, $60 [Flow: branch]
	.db $30, $F8		; 30 F8 ; Branch if minus to $30, $F8 [Flow: branch]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $003000.l,X		; 1F 00 30 00 ; Logical OR long $003000.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc #$D60F.w		; 69 0F D6 ; Add #$D60F.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	ora $3EAF.w,Y		; 19 AF 3E ; OR accumulator with memory $3EAF.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $FF237F.l,X		; 5F 7F 23 FF ; Exclusive OR accumulator with memory (long,X) $FF237F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($F0.b,S),Y		; 13 F0 ; OR accumulator (stack relative indirect indexed) ($F0.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx #$80C0.w		; E0 C0 80 ; Compare #$80C0.w with X register [Reads: X Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	cpy #$FF00.w		; C0 00 FF ; Compare #$FF00.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $82, $7F, $FC		; 82 7F FC ; Branch always long to $82, $7F, $FC [Flow: branch]
	sta [$78.b]		; 87 78 ; Store accumulator (long) [$78.b] [Reads: Direct Page, Accumulator]
	bit $FF.b		; 24 FF ; Test bits $FF.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora ($7C.b,S),Y		; 13 7C ; OR accumulator (stack relative indirect indexed) ($7C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp $02F200.l,X		; DF 00 F2 02 ; Compare accumulator (long,X) $02F200.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	sbc $7C01.w,Y		; F9 01 7C ; Subtract with carry $7C01.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $39.b		; 00 39 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($72.b,X)		; 01 72 ; Logical OR ($72.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $E4.b,S		; 03 E4 ; OR accumulator with stack relative $E4.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $E0.b		; 06 E0 ; Arithmetic shift left $E0.b [Reads: Direct Page] [Flags: NCZ]
	.db $62, $FD, $1B		; 62 FD 1B ; Push effective relative address $62, $FD, $1B [Writes: Stack Pointer]
	sbc $F9FCFE.l,X		; FF FE FC F9 ; Subtract with carry (long,X) $F9FCFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($4C07.w,X)		; FC 07 4C ; Jump to subroutine indirect indexed ($4C07.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	adc ($36.b,S),Y		; 73 36 ; Add with carry (stack relative indirect indexed) ($36.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	lda $BC3B.w,Y		; B9 3B BC ; Load $BC3B.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $DF1E.w,X		; FD 1E DF ; Subtract with carry $DF1E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $766F.w		; EE 6F 76 ; Increment $766F.w [Flags: NZ]
	and [$38.b],Y		; 37 38 ; AND accumulator with memory (long indexed) [$38.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	eor $2745C6.l		; 4F C6 45 27 ; Exclusive OR accumulator with memory (long) $2745C6.l [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	and $0027FF.l		; 2F FF 27 00 ; AND accumulator with memory (long) $0027FF.l [Writes: Accumulator] [Flags: NZ]
	ora [$FF.b]		; 07 FF ; OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $FF63FF.l		; 4F FF 63 FF ; Exclusive OR accumulator with memory (long) $FF63FF.l [Writes: Accumulator] [Flags: NZ]
	.db $30, $FF		; 30 FF ; Branch if minus to $30, $FF [Flow: branch]
	trb $C086.w		; 1C 86 C0 ; Test and reset bits $C086.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp $87FF28.l		; 5C 28 FF 87 ; Jump long to $87FF28.l [Flow: jump]
	cmp ($00.b,X)		; C1 00 ; Compare accumulator ($00.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	cop $0F.b		; 02 0F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FF4303.l,X		; FF 03 43 FF ; Subtract with carry (long,X) $FF4303.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $7F33E0.l,X		; FF E0 33 7F ; Subtract with carry (long,X) $7F33E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $00001F.l,X		; 3F 1F 00 00 ; AND accumulator with memory (long,X) $00001F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $FF10EF.l,X		; FF EF 10 FF ; Subtract with carry (long,X) $FF10EF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	lda $4D920C.l,X		; BF 0C 92 4D ; Load long $4D920C.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	wai		; CB ; Wait for interrupt
	adc ($FA.b,X)		; 61 FA ; Add with carry ($FA.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $F2		; 30 F2 ; Branch if minus to $30, $F2 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $7C5E.w		; 0E 5E 7C ; Arithmetic shift left $7C5E.w [Flags: NCZ]
	jmp ($7D3D.w,X)		; 7C 3D 7D ; Jump indirect indexed to ($7D3D.w,X) [Reads: X Index] [Flow: jump]
	sbc $1C.b,S		; E3 1C ; Subtract stack-relative $1C.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	pea $5B6B.w		; F4 6B 5B ; Push absolute address $5B6B.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	cmp [$96.b],Y		; D7 96 ; Compare accumulator (long indexed) [$96.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	stz $3C2C.w,X		; 9E 2C 3C ; Store zero to $3C2C.w,X [Reads: X Index]
	jmp $7E3E7C.l		; 5C 7C 3E 7E ; Jump long to $7E3E7C.l [Flow: jump]
	sbc [$B7.b]		; E7 B7 ; Subtract with carry (long) [$B7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $C361.w		; 20 61 C3 ; Jump to subroutine at $C361.w [Writes: Stack Pointer] [Flow: call]
	sta $81.b,S		; 83 81 ; Store accumulator (stack relative) $81.b,S [Reads: Stack Pointer, Accumulator]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	eor $7F.b		; 45 7F ; Exclusive OR $7F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $80, $45		; 80 45 ; Branch always to $80, $45 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $80, $43		; 80 43 ; Branch always to $80, $43 [Flow: branch]
	cpx #$2500.w		; E0 00 25 ; Compare #$2500.w with X register [Reads: X Index] [Flags: NCZ]
	adc $43FF22.l,X		; 7F 22 FF 43 ; Add long $43FF22.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $27.b		; 00 27 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $140037.l,X		; FF 37 00 14 ; Subtract with carry (long,X) $140037.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx $D63D.w		; EC 3D D6 ; Compare $D63D.w with X register [Reads: X Index] [Flags: NCZ]
	ora $F40FEA.l,X		; 1F EA 0F F4 ; Logical OR long $F40FEA.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$7B.b]		; 07 7B ; OR accumulator with memory (long) [$7B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $3F.b,S		; 03 3F ; OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C2.b		; 00 C2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$F8F0.w		; E0 F0 F8 ; Compare #$F8F0.w with X register [Reads: X Index] [Flags: NCZ]
	jsr ($FF22.w,X)		; FC 22 FF ; Jump to subroutine indirect indexed ($FF22.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora $E000C0.l		; 0F C0 00 E0 ; OR accumulator with memory (long) $E000C0.l [Writes: Accumulator] [Flags: NZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $4F		; 80 4F ; Branch always to $80, $4F [Flow: branch]
	cpy $6C29.w		; CC 29 6C ; Compare $6C29.w with Y register [Reads: Y Index] [Flags: NCZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	rol $FF23.w,X		; 3E 23 FF ; Rotate left $FF23.w,X [Reads: X Index] [Flags: NCZ]
	cpx #$7F27.w		; E0 27 7F ; Compare #$7F27.w with X register [Reads: X Index] [Flags: NCZ]
	and ($93.b,S),Y		; 33 93 ; AND accumulator (stack relative indirect indexed) ($93.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp ($E8.b,X)		; C1 E8 ; Compare accumulator ($E8.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	tsb $06E4.w		; 0C E4 06 ; Test and set bits $06E4.w [Reads: Accumulator] [Flags: Z]
	adc ($03.b)		; 72 03 ; Add with carry (indirect) ($03.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and ($01.b),Y		; 31 01 ; AND accumulator with memory ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and [$07.b],Y		; 37 07 ; AND accumulator with memory (long indexed) [$07.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $07.b,X		; 34 07 ; Test bits $07.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and $3E01.w,X		; 3D 01 3E ; AND accumulator with memory $3E01.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $F3.b		; 00 F3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FEFC.w,Y		; F9 FC FE ; Subtract with carry $FEFC.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	inc $0DFF.w,X		; FE FF 0D ; Increment memory $0DFF.w,X [Reads: X Index] [Flags: NZ]
	.db $F0, $FB		; F0 FB ; Branch if equal to $F0, $FB [Flow: branch]
	ora ($37.b,X)		; 01 37 ; Logical OR ($37.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp $68.b,S		; C3 68 ; Compare accumulator (stack relative) $68.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	sta [$40.b]		; 87 40 ; Store accumulator (long) [$40.b] [Reads: Direct Page, Accumulator]
	.db $80, $7F		; 80 7F ; Branch always to $80, $7F [Flow: branch]
	.db $80, $43		; 80 43 ; Branch always to $80, $43 [Flow: branch]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $06.b		; 04 06 ; Test and set bits $06.b [Reads: Accumulator] [Flags: Z]
	ora $371B.w		; 0D 1B 37 ; Logical OR $371B.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $190022.l,X		; 3F 22 00 19 ; AND accumulator with memory (long,X) $190022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $E0F700.l		; EF 00 F7 E0 ; Subtract with carry (long) $E0F700.l [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	.db $F0, $05		; F0 05 ; Branch if equal to $F0, $05 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $0702.w,X		; FE 02 07 ; Increment memory $0702.w,X [Reads: X Index] [Flags: NZ]
	sbc $FC03.w,Y		; F9 03 FC ; Subtract with carry $FC03.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	cpx $FBF6.w		; EC F6 FB ; Compare $FBF6.w with X register [Reads: X Index] [Flags: NCZ]
	sbc $000001.l,X		; FF 01 00 00 ; Subtract with carry (long,X) $000001.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora $0CE943.l		; 0F 43 E9 0C ; OR accumulator with memory (long) $0CE943.l [Writes: Accumulator] [Flags: NZ]
	ora $75.b		; 05 75 ; Logical OR $75.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $3A.b		; 06 3A ; Arithmetic shift left $3A.b [Reads: Direct Page] [Flags: NCZ]
	ora $1D.b,S		; 03 1D ; OR accumulator with stack relative $1D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($43.b,X)		; 01 43 ; Logical OR ($43.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $0100.w		; 0C 00 01 ; Test and set bits $0100.w [Reads: Accumulator] [Flags: Z]
	.db $F0, $F3		; F0 F3 ; Branch if equal to $F0, $F3 [Flow: branch]
	sta $A8.b,S		; 83 A8 ; Store accumulator (stack relative) $A8.b,S [Reads: Stack Pointer, Accumulator]
	ora ($1F.b,X)		; 01 1F ; Logical OR ($1F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $BEA1FF.l,X		; FF FF A1 BE ; Subtract with carry (long,X) $BEA1FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	.db $62, $25, $30		; 62 25 30 ; Push effective relative address $62, $25, $30 [Writes: Stack Pointer]
	eor ($7C.b,X)		; 41 7C ; Exclusive OR accumulator with memory ($7C.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lda $E6.b		; A5 E6 ; Load $E6.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $1E338E.l		; 8F 8E 33 1E ; Store accumulator (long) $1E338E.l [Reads: Accumulator]
	adc $9C401E.l,X		; 7F 1E 40 9C ; Add long $9C401E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $1882.w		; CE 82 18 ; Decrement $1882.w [Flags: NZ]
	.db $70, $E0		; 70 E0 ; Branch if overflow set to $70, $E0 [Flow: branch]
	cpx #$45C6.w		; E0 C6 45 ; Compare #$45C6.w with X register [Reads: X Index] [Flags: NCZ]
	cmp [$44.b]		; C7 44 ; Compare accumulator (long) [$44.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp [$47.b]		; C7 47 ; Compare accumulator (long) [$47.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	eor [$C0.b]		; 47 C0 ; Exclusive OR accumulator with memory (long) [$C0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	adc $233822.l,X		; 7F 22 38 23 ; Add long $233822.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $220000.l,X		; 3F 00 00 22 ; AND accumulator with memory (long,X) $220000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $FF0002.l,X		; FF 02 00 FF ; Subtract with carry (long,X) $FF0002.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $010027.l,X		; FF 27 00 01 ; Subtract with carry (long,X) $010027.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $0022FF.l,X		; FF FF 22 00 ; Subtract with carry (long,X) $0022FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $7F45FF.l		; 22 FF 45 7F ; Jump to subroutine long $7F45FF.l [Writes: Stack Pointer] [Flow: call]
	sbc $FF0005.l,X		; FF 05 00 FF ; Subtract with carry (long,X) $FF0005.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $8F		; 70 8F ; Branch if overflow set to $70, $8F [Flow: branch]
	adc $0025FF.l,X		; 7F FF 25 00 ; Add long $0025FF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $7F.b		; 02 7F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $FF2870.l,X		; 7F 70 28 FF ; Add long $FF2870.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FF2200.l,X		; FF 00 22 FF ; Subtract with carry (long,X) $FF2200.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx #$FF42.w		; E0 42 FF ; Compare #$FF42.w with X register [Reads: X Index] [Flags: NCZ]
	sbc $64C200.l,X		; FF 00 C2 64 ; Subtract with carry (long,X) $64C200.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$7D.b]		; E7 7D ; Subtract with carry (long) [$7D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $18FF3C.l,X		; FF 3C FF 18 ; Subtract with carry (long,X) $18FF3C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $22DD00.l,X		; FF 00 DD 22 ; Subtract with carry (long,X) $22DD00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda ($66.b,X)		; A1 66 ; Load accumulator ($66.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $46.b		; C5 46 ; Compare $46.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	adc $7C7C.w,X		; 7D 7C 7C ; Add $7C7C.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $003C.w,X		; 7E 3C 00 ; Rotate right $003C.w,X [Reads: X Index] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	adc ($A7.b)		; 72 A7 ; Add with carry (indirect) ($A7.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc $7DEA.w,Y		; 79 EA 7D ; Add $7DEA.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $50, $DE		; 50 DE ; Branch if overflow clear to $50, $DE [Flow: branch]
	lsr $B5FE.w,X		; 5E FE B5 ; Logical shift right $B5FE.w,X [Reads: X Index] [Flags: NCZ]
	adc $418B.w		; 6D 8B 41 ; Add $418B.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp $080505.l		; CF 05 05 08 ; Compare accumulator (long) $080505.l [Reads: Accumulator] [Flags: NCZ]
	tsb $0121.w		; 0C 21 01 ; Test and set bits $0121.w [Reads: Accumulator] [Flags: Z]
	cop $34.b		; 02 34 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $56		; 30 56 ; Branch if minus to $30, $56 [Flow: branch]
	dec $DE5A.w,X		; DE 5A DE ; Decrement memory $DE5A.w,X [Reads: X Index] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	dec $DE59.w,X		; DE 59 DE ; Decrement memory $DE59.w,X [Reads: X Index] [Flags: NZ]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	adc $7AFF.w,X		; 7D FF 7A ; Add $7AFF.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $7D.b,S		; 83 7D ; Store accumulator (stack relative) $7D.b,S [Reads: Stack Pointer, Accumulator]
	sta ($22.b,X)		; 81 22 ; Store accumulator ($22.b,X) [Reads: Direct Page, Accumulator, X Index]
	and ($11.b,X)		; 21 11 ; Logical AND ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsr $0101.w		; 20 01 01 ; Jump to subroutine at $0101.w [Writes: Stack Pointer] [Flow: call]
	jmp ($317E.w,X)		; 7C 7E 31 ; Jump indirect indexed to ($317E.w,X) [Reads: X Index] [Flow: jump]
	ora $833E41.l,X		; 1F 41 3E 83 ; Logical OR long $833E41.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jmp ($F906.w,X)		; 7C 06 F9 ; Jump indirect indexed to ($F906.w,X) [Reads: X Index] [Flow: jump]
	jmp ($F883.w,X)		; 7C 83 F8 ; Jump indirect indexed to ($F883.w,X) [Reads: X Index] [Flow: jump]
	sta [$00.b]		; 87 00 ; Store accumulator (long) [$00.b] [Reads: Direct Page, Accumulator]
	jsl $DF05FF.l		; 22 FF 05 DF ; Jump to subroutine long $DF05FF.l [Writes: Stack Pointer] [Flow: call]
	lda $FEFF7F.l,X		; BF 7F FF FE ; Load long $FEFF7F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsr ($0039.w,X)		; FC 39 00 ; Jump to subroutine indirect indexed ($0039.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpx #$7C6F.w		; E0 6F 7C ; Compare #$7C6F.w with X register [Reads: X Index] [Flags: NCZ]
	lda ($6E.b),Y		; B1 6E ; Load accumulator ($6E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda $50E33A.l		; AF 3A E3 50 ; Load long $50E33A.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp ($B0.b,X)		; C1 B0 ; Compare accumulator ($B0.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	sta ($C0.b,X)		; 81 C0 ; Store accumulator ($C0.b,X) [Reads: Direct Page, Accumulator, X Index]
	cmp ($30.b,X)		; C1 30 ; Compare accumulator ($30.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	sbc ($D8.b),Y		; F1 D8 ; Subtract with carry ($D8.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $908E.w,Y		; [PATTERN: Memory clearing operation] F9 8E 90 ; Subtract with carry $908E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	stz $7E3E.w		; 9C 3E 7E ; Store zero to $7E3E.w
	rol $060E.w,X		; 3E 0E 06 ; Rotate left $060E.w,X [Reads: X Index] [Flags: NCZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	stz $CF55.w,X		; 9E 55 CF ; Store zero to $CF55.w,X [Reads: X Index]
	ldy $ED.b		; A4 ED ; Load $ED.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	sta ($F9.b,S),Y		; 93 F9 ; Store accumulator (stack relative indirect indexed) ($F9.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	stx $D0.b		; 86 D0 ; Store X register to $D0.b [Reads: X Index]
.INDEX 16
	rep #$98		; C2 98
	eor $EDA0.w		; 4D A0 ED ; Exclusive OR $EDA0.w with accumulator [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc ($30.b,X)		; 61 30 ; Add with carry ($30.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($06.b)		; 12 06 ; OR accumulator with memory (indirect) ($06.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $111327.l		; 2F 27 13 11 ; AND accumulator with memory (long) $111327.l [Writes: Accumulator] [Flags: NZ]
	lda $47FF.w,X		; BD FF 47 ; Load $47FF.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	and ($32.b,X)		; 21 32 ; Logical AND ($32.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $50, $9C		; 50 9C ; Branch if overflow clear to $50, $9C [Flow: branch]
	sta $F5.b,S		; 83 F5 ; Store accumulator (stack relative) $F5.b,S [Reads: Stack Pointer, Accumulator]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpx #$C11C.w		; E0 1C C1 ; Compare #$C11C.w with X register [Reads: X Index] [Flags: NCZ]
	eor ($70.b,S),Y		; 53 70 ; XOR accumulator (stack relative indirect indexed) ($70.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy $0863.w		; CC 63 08 ; Compare $0863.w with Y register [Reads: Y Index] [Flags: NCZ]
	trb $8F3E.w		; 1C 3E 8F ; Test and reset bits $8F3E.w [Reads: Accumulator] [Flags: Z]
	sta ($FF.b,X)		; 81 FF ; Store accumulator ($FF.b,X) [Reads: Direct Page, Accumulator, X Index]
	ldx $D9D1.w,Y		; BE D1 D9 ; Load X register $D9D1.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cpx $E5F4.w		; EC F4 E5 ; Compare $E5F4.w with X register [Reads: X Index] [Flags: NCZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	nop		; EA ; No operation
	sbc $FC1B.w,X		; FD 1B FC ; Subtract with carry $FC1B.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $F8.b,X		; F6 F8 ; Increment memory $F8.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $DB80.w,X		; FD 80 DB ; Subtract with carry $DB80.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$C337.w		; E0 37 C3 ; Compare #$C337.w with X register [Reads: X Index] [Flags: NCZ]
	sbc $0FD087.l		; EF 87 D0 0F ; Subtract with carry (long) $0FD087.l [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	and $00DF00.l,X		; 3F 00 DF 00 ; AND accumulator with memory (long,X) $00DF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $C0.b,S		; 83 C0 ; Store accumulator (stack relative) $C0.b,S [Reads: Stack Pointer, Accumulator]
	ora ($E0.b,X)		; 01 E0 ; Logical OR ($E0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $42, $EF		; 42 EF ; Reserved instruction
	sbc $FF30E0.l,X		; FF E0 30 FF ; Subtract with carry (long,X) $FF30E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $BF7F7F.l,X		; FF 7F 7F BF ; Subtract with carry (long,X) $BF7F7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $0080FF.l,X		; BF FF 80 00 ; Load long $0080FF.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $80, $5E		; 80 5E ; Branch always to $80, $5E [Flow: branch]
	asl $39A1.w,X		; 1E A1 39 ; Arithmetic shift left $39A1.w,X [Reads: X Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $40		; 80 40 ; Branch always to $80, $40 [Flow: branch]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($C6.b,X)		; E1 C6 ; Subtract with carry ($C6.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	jsr ($7E5C.w,X)		; FC 5C 7E ; Jump to subroutine indirect indexed ($7E5C.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	lsr $A67F.w		; 4E 7F A6 ; Logical shift right $A67F.w [Flags: NCZ]
	and $691FD2.l,X		; 3F D2 1F 69 ; AND accumulator with memory (long,X) $691FD2.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $198233.l		; 8F 33 82 19 ; Store accumulator (long) $198233.l [Reads: Accumulator]
	.db $80, $1B		; 80 1B ; Branch always to $80, $1B [Flow: branch]
	sta $CE9E.w,X		; 9D 9E CE ; Store accumulator to $CE9E.w,X [Reads: Accumulator, X Index]
	inc $70.b		; E6 70 ; Increment $70.b [Reads: Direct Page] [Flags: NZ]
	adc $8F7F.w,X		; 7D 7F 8F ; Add $8F7F.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $A8		; 70 A8 ; Branch if overflow set to $70, $A8 [Flow: branch]
	eor [$AF.b],Y		; 57 AF ; Exclusive OR accumulator with memory (long indexed) [$AF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $50, $A8		; 50 A8 ; Branch if overflow clear to $50, $A8 [Flow: branch]
	eor [$8F.b],Y		; 57 8F ; Exclusive OR accumulator with memory (long indexed) [$8F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $70, $8F		; 70 8F ; Branch if overflow set to $70, $8F [Flow: branch]
	adc [$88.b],Y		; 77 88 ; Add with carry (long indexed) [$88.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc [$FF.b],Y		; 77 FF ; Add with carry (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $8E.b		; 00 8E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $03		; 90 03 ; Branch if carry clear to $90, $03 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $85.b		; 00 85 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cop $85.b		; 02 85 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $228F70.l,X		; FF 70 8F 22 ; Subtract with carry (long,X) $228F70.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $7F7007.l,X		; 7F 07 70 7F ; Add long $7F7007.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $7F7F70.l,X		; 7F 70 7F 7F ; Add long $7F7F70.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FF2200.l,X		; FF 00 22 FF ; Subtract with carry (long,X) $FF2200.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FF2200.l,X		; FF 00 22 FF ; Subtract with carry (long,X) $FF2200.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FF2300.l,X		; FF 00 23 FF ; Subtract with carry (long,X) $FF2300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $2B.b,S		; 83 2B ; Store accumulator (stack relative) $2B.b,S [Reads: Stack Pointer, Accumulator]
	cop $E0.b		; 02 E0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($FF.b,X)		; 61 FF ; Add with carry ($FF.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $D14ECD.l,X		; FF CD 4E D1 ; Subtract with carry (long,X) $D14ECD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr $66E5.w,X		; 5E E5 66 ; Logical shift right $66E5.w,X [Reads: X Index] [Flags: NCZ]
	lda $66.b		; A5 66 ; Load $66.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $C87F.w,X		; 9D 7F C8 ; Store accumulator to $C87F.w,X [Reads: Accumulator, X Index]
	bit $5DA5.w,X		; 3C A5 5D ; Test bits $5DA5.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	eor [$30.b]		; 47 30 ; Exclusive OR accumulator with memory (long) [$30.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $1818.w		; 20 18 18 ; Jump to subroutine at $1818.w [Writes: Stack Pointer] [Flow: call]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	and [$FF.b]		; 27 FF ; AND accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	inc $FC00.w,X		; FE 00 FC ; Increment memory $FC00.w,X [Reads: X Index] [Flags: NZ]
	ora ($78.b,X)		; 01 78 ; Logical OR ($78.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta $F7.b,S		; 83 F7 ; Store accumulator (stack relative) $F7.b,S [Reads: Stack Pointer, Accumulator]
	cpy #$CC63.w		; C0 63 CC ; Compare #$CC63.w with Y register [Reads: Y Index] [Flags: NCZ]
	eor ($9E.b,X)		; 41 9E ; Exclusive OR accumulator with memory ($9E.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $90, $C0		; 90 C0 ; Branch if carry clear to $90, $C0 [Flow: branch]
	cmp ($4B.b,X)		; C1 4B ; Compare accumulator ($4B.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	ora [$0F.b],Y		; 17 0F ; OR accumulator with memory (long indexed) [$0F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $5FDB3F.l,X		; 1F 3F DB 5F ; Logical OR long $5FDB3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	ror $7DA9.w		; 6E A9 7D ; Rotate right $7DA9.w [Flags: NCZ]
	pea $F57C.w		; F4 7C F5 ; Push absolute address $F57C.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	jmp ($5CD6.w,X)		; 7C D6 5C ; Jump indirect indexed to ($5CD6.w,X) [Reads: X Index] [Flow: jump]
	cmp [$6D.b]		; C7 6D ; Compare accumulator (long) [$6D.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	and $FD.b		; 25 FD ; Logical AND $FD.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $0211.w		; 20 11 02 ; Jump to subroutine at $0211.w [Writes: Stack Pointer] [Flow: call]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $12.b,S		; 23 12 ; AND accumulator with stack relative $12.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $E2.b		; 02 E2 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $CB.b		; 26 CB ; Rotate left $CB.b [Reads: Direct Page] [Flags: NCZ]
	wai		; CB ; Wait for interrupt
	adc ($11.b),Y		; 71 11 ; Add with carry ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $4040FF.l,X		; FF FF 40 40 ; Subtract with carry (long,X) $4040FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $004080.l,X		; BF 80 40 00 ; Load long $004080.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $34D900.l,X		; 9F 00 D9 34 ; Store accumulator (long,X) $34D900.l,X [Reads: Accumulator, X Index]
	.db $EE		; Opcode EE overrunning bank boundry at 097FFF. Skipping. ; Increment $EE [Flags: NZ]
.ENDS
